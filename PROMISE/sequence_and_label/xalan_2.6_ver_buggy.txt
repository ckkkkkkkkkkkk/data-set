package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; class FilterExpr extends Expression { private Expression _primary ; private final Vector _predicates ; public FilterExpr ( Expression primary , Vector predicates ) { _primary = primary ; _predicates = predicates ; primary . setParent ( this ) ; } protected Expression getExpr ( ) { if ( _primary instanceof CastExpr ) return ( ( CastExpr ) _primary ) . getExpr ( ) ; else return _primary ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _primary . setParser ( parser ) ; if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = ( Expression ) _predicates . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public String toString ( ) { return "filter-expr(" + _primary + ", " + _predicates + ")" ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type ptype = _primary . typeCheck ( stable ) ; if ( ptype instanceof NodeSetType == false ) { if ( ptype instanceof ReferenceType ) { _primary = new CastExpr ( _primary , Type . NodeSet ) ; } else { throw new TypeCheckError ( this ) ; } } int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; pred . dontOptimize ( ) ; pred . typeCheck ( stable ) ; } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _predicates . size ( ) > 0 ) { translatePredicates ( classGen , methodGen ) ; } else { _primary . translate ( classGen , methodGen ) ; } } public void translatePredicates ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _predicates . size ( ) == 0 ) { translate ( classGen , methodGen ) ; } else { final int initCNLI = cpg . addMethodref ( CURRENT_NODE_LIST_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + "Z" + CURRENT_NODE_LIST_FILTER_SIG + NODE_SIG + TRANSLET_SIG + ")V" ) ; Predicate predicate = ( Predicate ) _predicates . lastElement ( ) ; _predicates . remove ( predicate ) ; il . append ( new NEW ( cpg . addClass ( CURRENT_NODE_LIST_ITERATOR ) ) ) ; il . append ( DUP ) ; translatePredicates ( classGen , methodGen ) ; il . append ( ICONST_1 ) ; predicate . translate ( classGen , methodGen ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKESPECIAL ( initCNLI ) ) ; } } } 	1	['7', '3', '0', '19', '35', '0', '0', '19', '6', '0.083333333', '226', '1', '1', '0.922077922', '0.306122449', '2', '9', '31', '3', '1.5714', '1']
package org . apache . xpath . operations ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XObject ; public class Operation extends Expression implements ExpressionOwner { protected Expression m_left ; protected Expression m_right ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_left . fixupVariables ( vars , globalsSize ) ; m_right . fixupVariables ( vars , globalsSize ) ; } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_left && m_left . canTraverseOutsideSubtree ( ) ) return true ; if ( null != m_right && m_right . canTraverseOutsideSubtree ( ) ) return true ; return false ; } public void setLeftRight ( Expression l , Expression r ) { m_left = l ; m_right = r ; l . exprSetParent ( this ) ; r . exprSetParent ( this ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject left = m_left . execute ( xctxt , true ) ; XObject right = m_right . execute ( xctxt , true ) ; XObject result = operate ( left , right ) ; left . detach ( ) ; right . detach ( ) ; return result ; } public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return null ; } public Expression getLeftOperand ( ) { return m_left ; } public Expression getRightOperand ( ) { return m_right ; } class LeftExprOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_left ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( Operation . this ) ; m_left = exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitBinaryOperation ( owner , this ) ) { m_left . callVisitors ( new LeftExprOwner ( ) , visitor ) ; m_right . callVisitors ( this , visitor ) ; } } public Expression getExpression ( ) { return m_right ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_right = exp ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! m_left . deepEquals ( ( ( Operation ) expr ) . m_left ) ) return false ; if ( ! m_right . deepEquals ( ( ( Operation ) expr ) . m_right ) ) return false ; return true ; } } 	1	['12', '2', '14', '22', '23', '0', '17', '7', '12', '0.363636364', '149', '1', '2', '0.731707317', '0.21875', '1', '7', '11.25', '5', '1.5833', '1']
package org . apache . xalan . xsltc . runtime ; import java . text . DecimalFormat ; import java . text . FieldPosition ; import java . text . MessageFormat ; import java . text . NumberFormat ; import java . util . Locale ; import java . util . ResourceBundle ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . dom . DOMSource ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . dom . AbsoluteIterator ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xalan . xsltc . dom . DOMAdapter ; import org . apache . xalan . xsltc . dom . MultiDOM ; import org . apache . xalan . xsltc . dom . SingletonIterator ; import org . apache . xalan . xsltc . dom . StepIterator ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMDefaultBase ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import org . apache . xml . serializer . NamespaceMappings ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . XMLChar ; public final class BasisLibrary implements Operators { private final static String EMPTYSTRING = "" ; public static int countF ( DTMAxisIterator iterator ) { return ( iterator . getLast ( ) ) ; } public static int positionF ( DTMAxisIterator iterator ) { return iterator . isReverse ( ) ? iterator . getLast ( ) - iterator . getPosition ( ) + 1 : iterator . getPosition ( ) ; } public static double sumF ( DTMAxisIterator iterator , DOM dom ) { try { double result = 0.0 ; int node ; while ( ( node = iterator . next ( ) ) != DTMAxisIterator . END ) { result += Double . parseDouble ( dom . getStringValueX ( node ) ) ; } return result ; } catch ( NumberFormatException e ) { return Double . NaN ; } } public static String stringF ( int node , DOM dom ) { return dom . getStringValueX ( node ) ; } public static String stringF ( Object obj , DOM dom ) { if ( obj instanceof DTMAxisIterator ) { return dom . getStringValueX ( ( ( DTMAxisIterator ) obj ) . reset ( ) . next ( ) ) ; } else if ( obj instanceof Node ) { return dom . getStringValueX ( ( ( Node ) obj ) . node ) ; } else if ( obj instanceof DOM ) { return ( ( DOM ) obj ) . getStringValue ( ) ; } else { return obj . toString ( ) ; } } public static String stringF ( Object obj , int node , DOM dom ) { if ( obj instanceof DTMAxisIterator ) { return dom . getStringValueX ( ( ( DTMAxisIterator ) obj ) . reset ( ) . next ( ) ) ; } else if ( obj instanceof Node ) { return dom . getStringValueX ( ( ( Node ) obj ) . node ) ; } else if ( obj instanceof DOM ) { return ( ( DOM ) obj ) . getStringValue ( ) ; } else if ( obj instanceof Double ) { Double d = ( Double ) obj ; final String result = d . toString ( ) ; final int length = result . length ( ) ; if ( ( result . charAt ( length - 2 ) == '.' ) && ( result . charAt ( length - 1 ) == '0' ) ) return result . substring ( 0 , length - 2 ) ; else return result ; } else { if ( obj != null ) return obj . toString ( ) ; else return stringF ( node , dom ) ; } } public static double numberF ( int node , DOM dom ) { return stringToReal ( dom . getStringValueX ( node ) ) ; } public static double numberF ( Object obj , DOM dom ) { if ( obj instanceof Double ) { return ( ( Double ) obj ) . doubleValue ( ) ; } else if ( obj instanceof Integer ) { return ( ( Integer ) obj ) . doubleValue ( ) ; } else if ( obj instanceof Boolean ) { return ( ( Boolean ) obj ) . booleanValue ( ) ? 1.0 : 0.0 ; } else if ( obj instanceof String ) { return stringToReal ( ( String ) obj ) ; } else if ( obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) obj ; return stringToReal ( dom . getStringValueX ( iter . reset ( ) . next ( ) ) ) ; } else if ( obj instanceof Node ) { return stringToReal ( dom . getStringValueX ( ( ( Node ) obj ) . node ) ) ; } else if ( obj instanceof DOM ) { return stringToReal ( ( ( DOM ) obj ) . getStringValue ( ) ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "number()" ) ; return 0.0 ; } } public static double roundF ( double d ) { return ( d < - 0.5 || d > 0.0 ) ? Math . floor ( d + 0.5 ) : ( ( d == 0.0 ) ? d : ( Double . isNaN ( d ) ? Double . NaN : - 0.0 ) ) ; } public static boolean booleanF ( Object obj ) { if ( obj instanceof Double ) { final double temp = ( ( Double ) obj ) . doubleValue ( ) ; return temp != 0.0 && ! Double . isNaN ( temp ) ; } else if ( obj instanceof Integer ) { return ( ( Integer ) obj ) . doubleValue ( ) != 0 ; } else if ( obj instanceof Boolean ) { return ( ( Boolean ) obj ) . booleanValue ( ) ; } else if ( obj instanceof String ) { return ! ( ( String ) obj ) . equals ( EMPTYSTRING ) ; } else if ( obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) obj ; return iter . reset ( ) . next ( ) != DTMAxisIterator . END ; } else if ( obj instanceof Node ) { return true ; } else if ( obj instanceof DOM ) { String temp = ( ( DOM ) obj ) . getStringValue ( ) ; return ! temp . equals ( EMPTYSTRING ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "number()" ) ; } return false ; } public static String substringF ( String value , double start ) { try { final int strlen = value . length ( ) ; int istart = ( int ) Math . round ( start ) - 1 ; if ( Double . isNaN ( start ) ) return ( EMPTYSTRING ) ; if ( istart > strlen ) return ( EMPTYSTRING ) ; if ( istart < 1 ) istart = 0 ; return value . substring ( istart ) ; } catch ( IndexOutOfBoundsException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , "substring()" ) ; return null ; } } public static String substringF ( String value , double start , double length ) { try { final int strlen = value . length ( ) ; int istart = ( int ) Math . round ( start ) - 1 ; int isum = istart + ( int ) Math . round ( length ) ; if ( Double . isInfinite ( length ) ) isum = Integer . MAX_VALUE ; if ( Double . isNaN ( start ) || Double . isNaN ( length ) ) return ( EMPTYSTRING ) ; if ( Double . isInfinite ( start ) ) return ( EMPTYSTRING ) ; if ( istart > strlen ) return ( EMPTYSTRING ) ; if ( isum < 0 ) return ( EMPTYSTRING ) ; if ( istart < 0 ) istart = 0 ; if ( isum > strlen ) return value . substring ( istart ) ; else return value . substring ( istart , isum ) ; } catch ( IndexOutOfBoundsException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , "substring()" ) ; return null ; } } public static String substring_afterF ( String value , String substring ) { final int index = value . indexOf ( substring ) ; if ( index >= 0 ) return value . substring ( index + substring . length ( ) ) ; else return EMPTYSTRING ; } public static String substring_beforeF ( String value , String substring ) { final int index = value . indexOf ( substring ) ; if ( index >= 0 ) return value . substring ( 0 , index ) ; else return EMPTYSTRING ; } public static String translateF ( String value , String from , String to ) { final int tol = to . length ( ) ; final int froml = from . length ( ) ; final int valuel = value . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int j , i = 0 ; i < valuel ; i ++ ) { final char ch = value . charAt ( i ) ; for ( j = 0 ; j < froml ; j ++ ) { if ( ch == from . charAt ( j ) ) { if ( j < tol ) result . append ( to . charAt ( j ) ) ; break ; } } if ( j == froml ) result . append ( ch ) ; } return result . toString ( ) ; } public static String normalize_spaceF ( int node , DOM dom ) { return normalize_spaceF ( dom . getStringValueX ( node ) ) ; } public static String normalize_spaceF ( String value ) { int i = 0 , n = value . length ( ) ; StringBuffer result = new StringBuffer ( ) ; while ( i < n && isWhiteSpace ( value . charAt ( i ) ) ) i ++ ; while ( true ) { while ( i < n && ! isWhiteSpace ( value . charAt ( i ) ) ) { result . append ( value . charAt ( i ++ ) ) ; } if ( i == n ) break ; while ( i < n && isWhiteSpace ( value . charAt ( i ) ) ) { i ++ ; } if ( i < n ) result . append ( ' ' ) ; } return result . toString ( ) ; } public static String generate_idF ( int node ) { if ( node > 0 ) return "N" + node ; else return EMPTYSTRING ; } public static String getLocalName ( String value ) { int idx = value . lastIndexOf ( ':' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; idx = value . lastIndexOf ( '@' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; return ( value ) ; } public static void unresolved_externalF ( String name ) { runTimeError ( EXTERNAL_FUNC_ERR , name ) ; } public static void unsupported_ElementF ( String qname , boolean isExtension ) { if ( isExtension ) runTimeError ( UNSUPPORTED_EXT_ERR , qname ) ; else runTimeError ( UNSUPPORTED_XSL_ERR , qname ) ; } public static String namespace_uriF ( DTMAxisIterator iter , DOM dom ) { return namespace_uriF ( iter . next ( ) , dom ) ; } public static String system_propertyF ( String name ) { if ( name . equals ( "xsl:version" ) ) return ( "1.0" ) ; if ( name . equals ( "xsl:vendor" ) ) return ( "Apache Software Foundation (Xalan XSLTC)" ) ; if ( name . equals ( "xsl:vendor-url" ) ) return ( "http://xml.apache.org/xalan-j" ) ; runTimeError ( INVALID_ARGUMENT_ERR , name , "system-property()" ) ; return ( EMPTYSTRING ) ; } public static String namespace_uriF ( int node , DOM dom ) { final String value = dom . getNodeName ( node ) ; final int colon = value . lastIndexOf ( ':' ) ; if ( colon >= 0 ) return value . substring ( 0 , colon ) ; else return EMPTYSTRING ; } public static String objectTypeF ( Object obj ) { if ( obj instanceof String ) return "string" ; else if ( obj instanceof Boolean ) return "boolean" ; else if ( obj instanceof Number ) return "number" ; else if ( obj instanceof DOM ) return "RTF" ; else if ( obj instanceof DTMAxisIterator ) return "node-set" ; else return "unknown" ; } public static DTMAxisIterator nodesetF ( Object obj ) { if ( obj instanceof DOM ) { final DOM dom = ( DOM ) obj ; return new SingletonIterator ( dom . getDocument ( ) , true ) ; } else if ( obj instanceof DTMAxisIterator ) { return ( DTMAxisIterator ) obj ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "node-set" , className ) ; return null ; } } private static boolean isWhiteSpace ( char ch ) { return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r' ; } private static boolean compareStrings ( String lstring , String rstring , int op , DOM dom ) { switch ( op ) { case EQ : return lstring . equals ( rstring ) ; case NE : return ! lstring . equals ( rstring ) ; case GT : return numberF ( lstring , dom ) > numberF ( rstring , dom ) ; case LT : return numberF ( lstring , dom ) < numberF ( rstring , dom ) ; case GE : return numberF ( lstring , dom ) >= numberF ( rstring , dom ) ; case LE : return numberF ( lstring , dom ) <= numberF ( rstring , dom ) ; default : runTimeError ( RUN_TIME_INTERNAL_ERR , "compare()" ) ; return false ; } } public static boolean compare ( DTMAxisIterator left , DTMAxisIterator right , int op , DOM dom ) { int lnode ; left . reset ( ) ; while ( ( lnode = left . next ( ) ) != DTMAxisIterator . END ) { final String lvalue = dom . getStringValueX ( lnode ) ; int rnode ; right . reset ( ) ; while ( ( rnode = right . next ( ) ) != DTMAxisIterator . END ) { if ( lnode == rnode ) { if ( op == EQ ) { return true ; } else if ( op == NE ) { continue ; } } if ( compareStrings ( lvalue , dom . getStringValueX ( rnode ) , op , dom ) ) { return true ; } } } return false ; } public static boolean compare ( int node , DTMAxisIterator iterator , int op , DOM dom ) { int rnode ; String value ; switch ( op ) { case EQ : rnode = iterator . next ( ) ; if ( rnode != DTMAxisIterator . END ) { value = dom . getStringValueX ( node ) ; do { if ( node == rnode || value . equals ( dom . getStringValueX ( rnode ) ) ) { return true ; } } while ( ( rnode = iterator . next ( ) ) != DTMAxisIterator . END ) ; } break ; case NE : rnode = iterator . next ( ) ; if ( rnode != DTMAxisIterator . END ) { value = dom . getStringValueX ( node ) ; do { if ( node != rnode && ! value . equals ( dom . getStringValueX ( rnode ) ) ) { return true ; } } while ( ( rnode = iterator . next ( ) ) != DTMAxisIterator . END ) ; } break ; case LT : while ( ( rnode = iterator . next ( ) ) != DTMAxisIterator . END ) { if ( rnode > node ) return true ; } break ; case GT : while ( ( rnode = iterator . next ( ) ) != DTMAxisIterator . END ) { if ( rnode < node ) return true ; } break ; } return ( false ) ; } public static boolean compare ( DTMAxisIterator left , final double rnumber , final int op , DOM dom ) { int node ; switch ( op ) { case EQ : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) == rnumber ) return true ; } break ; case NE : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) != rnumber ) return true ; } break ; case GT : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) > rnumber ) return true ; } break ; case LT : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) < rnumber ) return true ; } break ; case GE : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) >= rnumber ) return true ; } break ; case LE : while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( numberF ( dom . getStringValueX ( node ) , dom ) <= rnumber ) return true ; } break ; default : runTimeError ( RUN_TIME_INTERNAL_ERR , "compare()" ) ; } return false ; } public static boolean compare ( DTMAxisIterator left , final String rstring , int op , DOM dom ) { int node ; while ( ( node = left . next ( ) ) != DTMAxisIterator . END ) { if ( compareStrings ( dom . getStringValueX ( node ) , rstring , op , dom ) ) { return true ; } } return false ; } public static boolean compare ( Object left , Object right , int op , DOM dom ) { boolean result = false ; boolean hasSimpleArgs = hasSimpleType ( left ) && hasSimpleType ( right ) ; if ( op != EQ && op != NE ) { if ( left instanceof Node || right instanceof Node ) { if ( left instanceof Boolean ) { right = new Boolean ( booleanF ( right ) ) ; hasSimpleArgs = true ; } if ( right instanceof Boolean ) { left = new Boolean ( booleanF ( left ) ) ; hasSimpleArgs = true ; } } if ( hasSimpleArgs ) { switch ( op ) { case GT : return numberF ( left , dom ) > numberF ( right , dom ) ; case LT : return numberF ( left , dom ) < numberF ( right , dom ) ; case GE : return numberF ( left , dom ) >= numberF ( right , dom ) ; case LE : return numberF ( left , dom ) <= numberF ( right , dom ) ; default : runTimeError ( RUN_TIME_INTERNAL_ERR , "compare()" ) ; } } } if ( hasSimpleArgs ) { if ( left instanceof Boolean || right instanceof Boolean ) { result = booleanF ( left ) == booleanF ( right ) ; } else if ( left instanceof Double || right instanceof Double || left instanceof Integer || right instanceof Integer ) { result = numberF ( left , dom ) == numberF ( right , dom ) ; } else { result = stringF ( left , dom ) . equals ( stringF ( right , dom ) ) ; } if ( op == Operators . NE ) { result = ! result ; } } else { if ( left instanceof Node ) { left = new SingletonIterator ( ( ( Node ) left ) . node ) ; } if ( right instanceof Node ) { right = new SingletonIterator ( ( ( Node ) right ) . node ) ; } if ( hasSimpleType ( left ) || left instanceof DOM && right instanceof DTMAxisIterator ) { final Object temp = right ; right = left ; left = temp ; } if ( left instanceof DOM ) { if ( right instanceof Boolean ) { result = ( ( Boolean ) right ) . booleanValue ( ) ; return result == ( op == Operators . EQ ) ; } final String sleft = ( ( DOM ) left ) . getStringValue ( ) ; if ( right instanceof Number ) { result = ( ( Number ) right ) . doubleValue ( ) == stringToReal ( sleft ) ; } else if ( right instanceof String ) { result = sleft . equals ( ( String ) right ) ; } else if ( right instanceof DOM ) { result = sleft . equals ( ( ( DOM ) right ) . getStringValue ( ) ) ; } if ( op == Operators . NE ) { result = ! result ; } return result ; } DTMAxisIterator iter = ( ( DTMAxisIterator ) left ) . reset ( ) ; if ( right instanceof DTMAxisIterator ) { result = compare ( iter , ( DTMAxisIterator ) right , op , dom ) ; } else if ( right instanceof String ) { result = compare ( iter , ( String ) right , op , dom ) ; } else if ( right instanceof Number ) { final double temp = ( ( Number ) right ) . doubleValue ( ) ; result = compare ( iter , temp , op , dom ) ; } else if ( right instanceof Boolean ) { boolean temp = ( ( Boolean ) right ) . booleanValue ( ) ; result = ( iter . reset ( ) . next ( ) != DTMAxisIterator . END ) == temp ; } else if ( right instanceof DOM ) { result = compare ( iter , ( ( DOM ) right ) . getStringValue ( ) , op , dom ) ; } else if ( right == null ) { return ( false ) ; } else { final String className = right . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "compare()" ) ; } } return result ; } public static boolean testLanguage ( String testLang , DOM dom , int node ) { String nodeLang = dom . getLanguage ( node ) ; if ( nodeLang == null ) return ( false ) ; else nodeLang = nodeLang . toLowerCase ( ) ; testLang = testLang . toLowerCase ( ) ; if ( testLang . length ( ) == 2 ) { return ( nodeLang . startsWith ( testLang ) ) ; } else { return ( nodeLang . equals ( testLang ) ) ; } } private static boolean hasSimpleType ( Object obj ) { return obj instanceof Boolean || obj instanceof Double || obj instanceof Integer || obj instanceof String || obj instanceof Node || obj instanceof DOM ; } public static double stringToReal ( String s ) { try { return Double . valueOf ( s ) . doubleValue ( ) ; } catch ( NumberFormatException e ) { return Double . NaN ; } } public static int stringToInt ( String s ) { try { return Integer . parseInt ( s ) ; } catch ( NumberFormatException e ) { return ( - 1 ) ; } } private static final int DOUBLE_FRACTION_DIGITS = 340 ; private static final double lowerBounds = 0.001 ; private static final double upperBounds = 10000000 ; private static DecimalFormat defaultFormatter ; private static String defaultPattern = "" ; static { NumberFormat f = NumberFormat . getInstance ( Locale . getDefault ( ) ) ; defaultFormatter = ( f instanceof DecimalFormat ) ? ( DecimalFormat ) f : new DecimalFormat ( ) ; defaultFormatter . setMaximumFractionDigits ( DOUBLE_FRACTION_DIGITS ) ; defaultFormatter . setMinimumFractionDigits ( 0 ) ; defaultFormatter . setMinimumIntegerDigits ( 1 ) ; defaultFormatter . setGroupingUsed ( false ) ; } public static String realToString ( double d ) { final double m = Math . abs ( d ) ; if ( ( m >= lowerBounds ) && ( m < upperBounds ) ) { final String result = Double . toString ( d ) ; final int length = result . length ( ) ; if ( ( result . charAt ( length - 2 ) == '.' ) && ( result . charAt ( length - 1 ) == '0' ) ) return result . substring ( 0 , length - 2 ) ; else return result ; } else { if ( Double . isNaN ( d ) || Double . isInfinite ( d ) ) return ( Double . toString ( d ) ) ; return formatNumber ( d , defaultPattern , defaultFormatter ) ; } } public static int realToInt ( double d ) { return ( int ) d ; } private static FieldPosition _fieldPosition = new FieldPosition ( 0 ) ; public static String formatNumber ( double number , String pattern , DecimalFormat formatter ) { if ( formatter == null ) { formatter = defaultFormatter ; } try { StringBuffer result = new StringBuffer ( ) ; if ( pattern != defaultPattern ) { formatter . applyLocalizedPattern ( pattern ) ; } formatter . format ( number , result , _fieldPosition ) ; return result . toString ( ) ; } catch ( IllegalArgumentException e ) { runTimeError ( FORMAT_NUMBER_ERR , Double . toString ( number ) , pattern ) ; return ( EMPTYSTRING ) ; } } public static DTMAxisIterator referenceToNodeSet ( Object obj ) { if ( obj instanceof Node ) { return ( new SingletonIterator ( ( ( Node ) obj ) . node ) ) ; } else if ( obj instanceof DTMAxisIterator ) { return ( ( ( DTMAxisIterator ) obj ) . cloneIterator ( ) ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , className , "node-set" ) ; return null ; } } public static NodeList referenceToNodeList ( Object obj , DOM dom ) { if ( obj instanceof Node || obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = referenceToNodeSet ( obj ) ; return dom . makeNodeList ( iter ) ; } else if ( obj instanceof DOM ) { dom = ( DOM ) obj ; return dom . makeNodeList ( DTMDefaultBase . ROOTNODE ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , className , "org.w3c.dom.NodeList" ) ; return null ; } } public static org . w3c . dom . Node referenceToNode ( Object obj , DOM dom ) { if ( obj instanceof Node || obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = referenceToNodeSet ( obj ) ; return dom . makeNode ( iter ) ; } else if ( obj instanceof DOM ) { dom = ( DOM ) obj ; DTMAxisIterator iter = dom . getChildren ( DTMDefaultBase . ROOTNODE ) ; return dom . makeNode ( iter ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , className , "org.w3c.dom.Node" ) ; return null ; } } public static long referenceToLong ( Object obj ) { if ( obj instanceof Number ) { return ( ( Number ) obj ) . longValue ( ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , className , Long . TYPE ) ; return 0 ; } } public static double referenceToDouble ( Object obj ) { if ( obj instanceof Number ) { return ( ( Number ) obj ) . doubleValue ( ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , className , Double . TYPE ) ; return 0 ; } } public static boolean referenceToBoolean ( Object obj ) { if ( obj instanceof Boolean ) { return ( ( Boolean ) obj ) . booleanValue ( ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , className , Boolean . TYPE ) ; return false ; } } public static String referenceToString ( Object obj , DOM dom ) { if ( obj instanceof String ) { return ( String ) obj ; } else if ( obj instanceof DTMAxisIterator ) { return dom . getStringValueX ( ( ( DTMAxisIterator ) obj ) . reset ( ) . next ( ) ) ; } else if ( obj instanceof Node ) { return dom . getStringValueX ( ( ( Node ) obj ) . node ) ; } else if ( obj instanceof DOM ) { return ( ( DOM ) obj ) . getStringValue ( ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , className , String . class ) ; return null ; } } public static DTMAxisIterator node2Iterator ( org . w3c . dom . Node node , Translet translet , DOM dom ) { final org . w3c . dom . Node inNode = node ; org . w3c . dom . NodeList nodelist = new org . w3c . dom . NodeList ( ) { public int getLength ( ) { return 1 ; } public org . w3c . dom . Node item ( int index ) { if ( index == 0 ) return inNode ; else return null ; } } ; return nodeList2Iterator ( nodelist , translet , dom ) ; } private static void copyNodes ( org . w3c . dom . NodeList nodeList , org . w3c . dom . Document doc , org . w3c . dom . Node parent ) { final int size = nodeList . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { org . w3c . dom . Node curr = nodeList . item ( i ) ; int nodeType = curr . getNodeType ( ) ; String value = null ; try { value = curr . getNodeValue ( ) ; } catch ( DOMException ex ) { runTimeError ( RUN_TIME_INTERNAL_ERR , ex . getMessage ( ) ) ; return ; } String nodeName = curr . getNodeName ( ) ; org . w3c . dom . Node newNode = null ; switch ( nodeType ) { case org . w3c . dom . Node . ATTRIBUTE_NODE : newNode = doc . createAttributeNS ( curr . getNamespaceURI ( ) , nodeName ) ; break ; case org . w3c . dom . Node . CDATA_SECTION_NODE : newNode = doc . createCDATASection ( value ) ; break ; case org . w3c . dom . Node . COMMENT_NODE : newNode = doc . createComment ( value ) ; break ; case org . w3c . dom . Node . DOCUMENT_FRAGMENT_NODE : newNode = doc . createDocumentFragment ( ) ; break ; case org . w3c . dom . Node . DOCUMENT_NODE : newNode = doc . createElementNS ( null , "__document__" ) ; copyNodes ( curr . getChildNodes ( ) , doc , newNode ) ; break ; case org . w3c . dom . Node . DOCUMENT_TYPE_NODE : break ; case org . w3c . dom . Node . ELEMENT_NODE : org . w3c . dom . Element element = doc . createElementNS ( curr . getNamespaceURI ( ) , nodeName ) ; if ( curr . hasAttributes ( ) ) { org . w3c . dom . NamedNodeMap attributes = curr . getAttributes ( ) ; for ( int k = 0 ; k < attributes . getLength ( ) ; k ++ ) { org . w3c . dom . Node attr = attributes . item ( k ) ; element . setAttributeNS ( attr . getNamespaceURI ( ) , attr . getNodeName ( ) , attr . getNodeValue ( ) ) ; } } copyNodes ( curr . getChildNodes ( ) , doc , element ) ; newNode = element ; break ; case org . w3c . dom . Node . ENTITY_NODE : break ; case org . w3c . dom . Node . ENTITY_REFERENCE_NODE : newNode = doc . createEntityReference ( nodeName ) ; break ; case org . w3c . dom . Node . NOTATION_NODE : break ; case org . w3c . dom . Node . PROCESSING_INSTRUCTION_NODE : newNode = doc . createProcessingInstruction ( nodeName , value ) ; break ; case org . w3c . dom . Node . TEXT_NODE : newNode = doc . createTextNode ( value ) ; break ; } try { parent . appendChild ( newNode ) ; } catch ( DOMException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , e . getMessage ( ) ) ; return ; } } } public static DTMAxisIterator nodeList2Iterator ( org . w3c . dom . NodeList nodeList , Translet translet , DOM dom ) { DocumentBuilderFactory dfac = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docbldr = null ; try { docbldr = dfac . newDocumentBuilder ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException e ) { runTimeError ( RUN_TIME_INTERNAL_ERR , e . getMessage ( ) ) ; return null ; } Document doc = docbldr . newDocument ( ) ; org . w3c . dom . Node topElementNode = doc . appendChild ( doc . createElementNS ( "" , "__top__" ) ) ; copyNodes ( nodeList , doc , topElementNode ) ; if ( dom instanceof MultiDOM ) { final MultiDOM multiDOM = ( MultiDOM ) dom ; DTMDefaultBase dtm = ( DTMDefaultBase ) ( ( DOMAdapter ) multiDOM . getMain ( ) ) . getDOMImpl ( ) ; DTMManager dtmManager = dtm . getManager ( ) ; DOM idom = ( DOM ) dtmManager . getDTM ( new DOMSource ( doc ) , false , null , true , false ) ; DOMAdapter domAdapter = new DOMAdapter ( idom , translet . getNamesArray ( ) , translet . getUrisArray ( ) , translet . getTypesArray ( ) , translet . getNamespaceArray ( ) ) ; multiDOM . addDOMAdapter ( domAdapter ) ; DTMAxisIterator iter1 = idom . getAxisIterator ( Axis . CHILD ) ; DTMAxisIterator iter2 = idom . getAxisIterator ( Axis . CHILD ) ; DTMAxisIterator iter = new AbsoluteIterator ( new StepIterator ( iter1 , iter2 ) ) ; iter . setStartNode ( DTMDefaultBase . ROOTNODE ) ; return iter ; } else { runTimeError ( RUN_TIME_INTERNAL_ERR , "nodeList2Iterator()" ) ; return null ; } } public static DOM referenceToResultTree ( Object obj ) { try { return ( ( DOM ) obj ) ; } catch ( IllegalArgumentException e ) { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "reference" , className ) ; return null ; } } public static DTMAxisIterator getSingleNode ( DTMAxisIterator iterator ) { int node = iterator . next ( ) ; return ( new SingletonIterator ( node ) ) ; } private static char [ ] _characterArray = new char [ 32 ] ; public static void copy ( Object obj , SerializationHandler handler , int node , DOM dom ) { try { if ( obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) obj ; dom . copy ( iter . reset ( ) , handler ) ; } else if ( obj instanceof Node ) { dom . copy ( ( ( Node ) obj ) . node , handler ) ; } else if ( obj instanceof DOM ) { DOM newDom = ( DOM ) obj ; newDom . copy ( newDom . getDocument ( ) , handler ) ; } else { String string = obj . toString ( ) ; final int length = string . length ( ) ; if ( length > _characterArray . length ) _characterArray = new char [ length ] ; string . getChars ( 0 , length , _characterArray , 0 ) ; handler . characters ( _characterArray , 0 , length ) ; } } catch ( SAXException e ) { runTimeError ( RUN_TIME_COPY_ERR ) ; } } public static void checkAttribQName ( String name ) { final int firstOccur = name . indexOf ( ":" ) ; final int lastOccur = name . lastIndexOf ( ":" ) ; final String localName = name . substring ( lastOccur + 1 ) ; if ( firstOccur > 0 ) { final String newPrefix = name . substring ( 0 , firstOccur ) ; if ( firstOccur != lastOccur ) { final String oriPrefix = name . substring ( firstOccur + 1 , lastOccur ) ; if ( ! XMLChar . isValidNCName ( oriPrefix ) ) { runTimeError ( INVALID_QNAME_ERR , oriPrefix + ":" + localName ) ; } } if ( ! XMLChar . isValidNCName ( newPrefix ) ) { runTimeError ( INVALID_QNAME_ERR , newPrefix + ":" + localName ) ; } } if ( ( ! XMLChar . isValidNCName ( localName ) ) || ( localName . equals ( Constants . XMLNS_PREFIX ) ) ) { runTimeError ( INVALID_QNAME_ERR , localName ) ; } } public static void checkNCName ( String name ) { if ( ! XMLChar . isValidNCName ( name ) ) { runTimeError ( INVALID_NCNAME_ERR , name ) ; } } public static void checkQName ( String name ) { if ( ! XMLChar . isValidQName ( name ) ) { runTimeError ( INVALID_QNAME_ERR , name ) ; } } public static String startXslElement ( String qname , String namespace , SerializationHandler handler , DOM dom , int node ) { try { String prefix ; final int index = qname . indexOf ( ':' ) ; if ( index > 0 ) { prefix = qname . substring ( 0 , index ) ; if ( namespace == null || namespace . length ( ) == 0 ) { try { namespace = dom . lookupNamespace ( node , prefix ) ; } catch ( RuntimeException e ) { handler . flushPending ( ) ; NamespaceMappings nm = handler . getNamespaceMappings ( ) ; namespace = nm . lookupNamespace ( prefix ) ; if ( namespace == null ) { runTimeError ( NAMESPACE_PREFIX_ERR , prefix ) ; } } } handler . startElement ( namespace , qname . substring ( index + 1 ) , qname ) ; handler . namespaceAfterStartElement ( prefix , namespace ) ; } else { if ( namespace != null && namespace . length ( ) > 0 ) { prefix = generatePrefix ( ) ; qname = prefix + ':' + qname ; handler . startElement ( namespace , qname , qname ) ; handler . namespaceAfterStartElement ( prefix , namespace ) ; } else { handler . startElement ( null , null , qname ) ; } } } catch ( SAXException e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } return qname ; } public static String getPrefix ( String qname ) { final int index = qname . indexOf ( ':' ) ; return ( index > 0 ) ? qname . substring ( 0 , index ) : null ; } private static int prefixIndex = 0 ; public static String generatePrefix ( ) { return ( "ns" + prefixIndex ++ ) ; } public static final String RUN_TIME_INTERNAL_ERR = "RUN_TIME_INTERNAL_ERR" ; public static final String RUN_TIME_COPY_ERR = "RUN_TIME_COPY_ERR" ; public static final String DATA_CONVERSION_ERR = "DATA_CONVERSION_ERR" ; public static final String EXTERNAL_FUNC_ERR = "EXTERNAL_FUNC_ERR" ; public static final String EQUALITY_EXPR_ERR = "EQUALITY_EXPR_ERR" ; public static final String INVALID_ARGUMENT_ERR = "INVALID_ARGUMENT_ERR" ; public static final String FORMAT_NUMBER_ERR = "FORMAT_NUMBER_ERR" ; public static final String ITERATOR_CLONE_ERR = "ITERATOR_CLONE_ERR" ; public static final String AXIS_SUPPORT_ERR = "AXIS_SUPPORT_ERR" ; public static final String TYPED_AXIS_SUPPORT_ERR = "TYPED_AXIS_SUPPORT_ERR" ; public static final String STRAY_ATTRIBUTE_ERR = "STRAY_ATTRIBUTE_ERR" ; public static final String STRAY_NAMESPACE_ERR = "STRAY_NAMESPACE_ERR" ; public static final String NAMESPACE_PREFIX_ERR = "NAMESPACE_PREFIX_ERR" ; public static final String DOM_ADAPTER_INIT_ERR = "DOM_ADAPTER_INIT_ERR" ; public static final String PARSER_DTD_SUPPORT_ERR = "PARSER_DTD_SUPPORT_ERR" ; public static final String NAMESPACES_SUPPORT_ERR = "NAMESPACES_SUPPORT_ERR" ; public static final String CANT_RESOLVE_RELATIVE_URI_ERR = "CANT_RESOLVE_RELATIVE_URI_ERR" ; public static final String UNSUPPORTED_XSL_ERR = "UNSUPPORTED_XSL_ERR" ; public static final String UNSUPPORTED_EXT_ERR = "UNSUPPORTED_EXT_ERR" ; public static final String UNKNOWN_TRANSLET_VERSION_ERR = "UNKNOWN_TRANSLET_VERSION_ERR" ; public static final String INVALID_QNAME_ERR = "INVALID_QNAME_ERR" ; public static final String INVALID_NCNAME_ERR = "INVALID_NCNAME_ERR" ; protected static ResourceBundle m_bundle ; public final static String ERROR_MESSAGES_KEY = "error-messages" ; static { String resource = "org.apache.xalan.xsltc.runtime.ErrorMessages" ; m_bundle = ResourceBundle . getBundle ( resource ) ; } public static void runTimeError ( String code ) { throw new RuntimeException ( m_bundle . getString ( code ) ) ; } public static void runTimeError ( String code , Object [ ] args ) { final String message = MessageFormat . format ( m_bundle . getString ( code ) , args ) ; throw new RuntimeException ( message ) ; } public static void runTimeError ( String code , Object arg0 ) { runTimeError ( code , new Object [ ] { arg0 } ) ; } public static void runTimeError ( String code , Object arg0 , Object arg1 ) { runTimeError ( code , new Object [ ] { arg0 , arg1 } ) ; } public static void consoleOutput ( String msg ) { System . out . println ( msg ) ; } public static String replace ( String base , char ch , String str ) { return ( base . indexOf ( ch ) < 0 ) ? base : replace ( base , String . valueOf ( ch ) , new String [ ] { str } ) ; } public static String replace ( String base , String delim , String [ ] str ) { final int len = base . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; i ++ ) { final char ch = base . charAt ( i ) ; final int k = delim . indexOf ( ch ) ; if ( k >= 0 ) { result . append ( str [ k ] ) ; } else { result . append ( ch ) ; } } return result . toString ( ) ; } public static String mapQNameToJavaName ( String base ) { return replace ( base , ".-:/{}?#%*" , new String [ ] { "$dot$" , "$dash$" , "$colon$" , "$slash$" , "" , "$colon$" , "$ques$" , "$hash$" , "$per$" , "$aster$" } ) ; } } 	1	['69', '1', '0', '36', '198', '2330', '20', '18', '64', '1.005793226', '2601', '0.303030303', '0', '0', '0.102076125', '0', '0', '36.2173913', '49', '4.2464', '3']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_cs extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Vnitřní běhová chyba v ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Vnitřní běhová chyba při provádění funkce <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Neplatná konverze z ''{0}'' do ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "Externí funkce ''{0}'' není podporována produktem SLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Neznámý typ argumentu ve výrazu rovnosti." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Neplatný typ argumentu ''{0}'' při volání ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Pokus formátovat číslo ''{0}'' použitím vzorku ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Nelze klonovat iterátor ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Iterátor pro osu ''{0}'' není podporován." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Iterátor pro typizovanou osu ''{0}'' není podporován." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Atribut ''{0}'' je vně prvku." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Deklarace oboru názvů ''{0}''=''{1}'' je vně prvku." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "Obor názvů pro předponu ''{0}'' nebyl deklarován." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter byl vytvořen s použitím chybného typu zdroje DOM." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "Použitý analyzátor SAX nemůže manipulovat s deklaračními událostmi DTD." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "Použitý analyzátor SAX nemůže podporovat obory názvů pro XML." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "Nelze přeložit odkazy URI ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xalan . xsltc . runtime ; public interface Operators { public static final int EQ = 0 ; public static final int NE = 1 ; public static final int GT = 2 ; public static final int LT = 3 ; public static final int GE = 4 ; public static final int LE = 5 ; public static final String [ ] names = { "=" , "!=" , ">" , "<" , ">=" , "<=" } ; } 	1	['1', '1', '0', '3', '1', '0', '3', '0', '0', '2', '36', '0', '0', '0', '0', '0', '0', '28', '0', '0', '1']
package org . apache . xpath . objects ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; public class XMLStringFactoryImpl extends XMLStringFactory { private static XMLStringFactory m_xstringfactory = new XMLStringFactoryImpl ( ) ; public static XMLStringFactory getFactory ( ) { return m_xstringfactory ; } public XMLString newstr ( String string ) { return new XString ( string ) ; } public XMLString newstr ( FastStringBuffer fsb , int start , int length ) { return new XStringForFSB ( fsb , start , length ) ; } public XMLString newstr ( char [ ] string , int start , int length ) { return new XStringForChars ( string , start , length ) ; } public XMLString emptystr ( ) { return XString . EMPTYSTRING ; } } 	1	['7', '2', '0', '8', '11', '19', '4', '6', '6', '0.833333333', '39', '1', '1', '0.444444444', '0.333333333', '0', '0', '4.428571429', '1', '0.7143', '1']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xml . dtm . DTMAxisIterator ; public abstract class AnyNodeCounter extends NodeCounter { public AnyNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } public NodeCounter setStartNode ( int node ) { _node = node ; _nodeType = _document . getExpandedTypeID ( node ) ; return this ; } public String getCounter ( ) { int result ; if ( _value != Integer . MIN_VALUE ) { result = _value ; } else { int next = _node ; final int root = _document . getDocument ( ) ; result = 0 ; while ( next >= root && ! matchesFrom ( next ) ) { if ( matchesCount ( next ) ) { ++ result ; } next -- ; } } return formatNumbers ( result ) ; } public static NodeCounter getDefaultNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { return new DefaultAnyNodeCounter ( translet , document , iterator ) ; } static class DefaultAnyNodeCounter extends AnyNodeCounter { public DefaultAnyNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } public String getCounter ( ) { int result ; if ( _value != Integer . MIN_VALUE ) { result = _value ; } else { int next = _node ; result = 0 ; final int ntype = _document . getExpandedTypeID ( _node ) ; final int root = _document . getDocument ( ) ; while ( next >= 0 ) { if ( ntype == _document . getExpandedTypeID ( next ) ) { result ++ ; } if ( next == root ) { break ; } else { -- next ; } } } return formatNumbers ( result ) ; } } } 	1	['4', '2', '1', '5', '11', '4', '1', '5', '4', '2', '63', '0', '0', '0.823529412', '0.5', '1', '4', '14.75', '5', '1.75', '1']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XObject ; public abstract class Function extends Expression { public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { reportWrongNumberArgs ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum != 0 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "zero" , null ) ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { System . out . println ( "Error! Function.execute should not be called!" ) ; return null ; } public void callArgVisitors ( XPathVisitor visitor ) { } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitFunction ( owner , this ) ) { callArgVisitors ( visitor ) ; } } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; return true ; } public void postCompileStep ( Compiler compiler ) { } } 	1	['9', '2', '7', '21', '15', '36', '15', '8', '8', '2', '51', '0', '0', '0.789473684', '0.285714286', '1', '7', '4.666666667', '2', '1.1111', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETSTATIC ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xml . utils . XMLChar ; final class DecimalFormatting extends TopLevelElement { private static final String DFS_CLASS = "java.text.DecimalFormatSymbols" ; private static final String DFS_SIG = "Ljava/text/DecimalFormatSymbols;" ; private QName _name = null ; public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; if ( name . length ( ) > 0 ) { if ( ! XMLChar . isValidQName ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , name , this ) ; parser . reportError ( Constants . ERROR , err ) ; } } _name = parser . getQNameIgnoreDefaultNs ( name ) ; if ( _name == null ) { _name = parser . getQNameIgnoreDefaultNs ( EMPTYSTRING ) ; } SymbolTable stable = parser . getSymbolTable ( ) ; if ( stable . getDecimalFormatting ( _name ) != null ) { reportWarning ( this , parser , ErrorMsg . SYMBOLS_REDEF_ERR , _name . toString ( ) ) ; } else { stable . addDecimalFormatting ( _name , this ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( DFS_CLASS , "<init>" , "(" + LOCALE_SIG + ")V" ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , _name . toString ( ) ) ) ; il . append ( new NEW ( cpg . addClass ( DFS_CLASS ) ) ) ; il . append ( DUP ) ; il . append ( new GETSTATIC ( cpg . addFieldref ( LOCALE_CLASS , "US" , LOCALE_SIG ) ) ) ; il . append ( new INVOKESPECIAL ( init ) ) ; String tmp = getAttribute ( "NaN" ) ; if ( ( tmp == null ) || ( tmp . equals ( EMPTYSTRING ) ) ) { int nan = cpg . addMethodref ( DFS_CLASS , "setNaN" , "(Ljava/lang/String;)V" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , "NaN" ) ) ; il . append ( new INVOKEVIRTUAL ( nan ) ) ; } tmp = getAttribute ( "infinity" ) ; if ( ( tmp == null ) || ( tmp . equals ( EMPTYSTRING ) ) ) { int inf = cpg . addMethodref ( DFS_CLASS , "setInfinity" , "(Ljava/lang/String;)V" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , "Infinity" ) ) ; il . append ( new INVOKEVIRTUAL ( inf ) ) ; } final int nAttributes = _attributes . getLength ( ) ; for ( int i = 0 ; i < nAttributes ; i ++ ) { final String name = _attributes . getQName ( i ) ; final String value = _attributes . getValue ( i ) ; boolean valid = true ; int method = 0 ; if ( name . equals ( "decimal-separator" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setDecimalSeparator" , "(C)V" ) ; } else if ( name . equals ( "grouping-separator" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setGroupingSeparator" , "(C)V" ) ; } else if ( name . equals ( "minus-sign" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setMinusSign" , "(C)V" ) ; } else if ( name . equals ( "percent" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setPercent" , "(C)V" ) ; } else if ( name . equals ( "per-mille" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setPerMill" , "(C)V" ) ; } else if ( name . equals ( "zero-digit" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setZeroDigit" , "(C)V" ) ; } else if ( name . equals ( "digit" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setDigit" , "(C)V" ) ; } else if ( name . equals ( "pattern-separator" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setPatternSeparator" , "(C)V" ) ; } else if ( name . equals ( "NaN" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setNaN" , "(Ljava/lang/String;)V" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , value ) ) ; il . append ( new INVOKEVIRTUAL ( method ) ) ; valid = false ; } else if ( name . equals ( "infinity" ) ) { method = cpg . addMethodref ( DFS_CLASS , "setInfinity" , "(Ljava/lang/String;)V" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , value ) ) ; il . append ( new INVOKEVIRTUAL ( method ) ) ; valid = false ; } else { valid = false ; } if ( valid ) { il . append ( DUP ) ; il . append ( new PUSH ( cpg , value . charAt ( 0 ) ) ) ; il . append ( new INVOKEVIRTUAL ( method ) ) ; } } final int put = cpg . addMethodref ( TRANSLET_CLASS , "addDecimalFormat" , "(" + STRING_SIG + DFS_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( put ) ) ; } public static void translateDefaultDFS ( ClassGenerator classGen , MethodGenerator methodGen ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( DFS_CLASS , "<init>" , "(" + LOCALE_SIG + ")V" ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , EMPTYSTRING ) ) ; il . append ( new NEW ( cpg . addClass ( DFS_CLASS ) ) ) ; il . append ( DUP ) ; il . append ( new GETSTATIC ( cpg . addFieldref ( LOCALE_CLASS , "US" , LOCALE_SIG ) ) ) ; il . append ( new INVOKESPECIAL ( init ) ) ; int nan = cpg . addMethodref ( DFS_CLASS , "setNaN" , "(Ljava/lang/String;)V" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , "NaN" ) ) ; il . append ( new INVOKEVIRTUAL ( nan ) ) ; int inf = cpg . addMethodref ( DFS_CLASS , "setInfinity" , "(Ljava/lang/String;)V" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , "Infinity" ) ) ; il . append ( new INVOKEVIRTUAL ( inf ) ) ; final int put = cpg . addMethodref ( TRANSLET_CLASS , "addDecimalFormat" , "(" + STRING_SIG + DFS_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( put ) ) ; } } 	1	['5', '3', '0', '23', '36', '2', '2', '22', '4', '1', '537', '1', '1', '0.9375', '0.4', '3', '7', '105.8', '17', '4.8', '1']
package org . apache . xalan . extensions ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . trace . ExtensionEvent ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . objects . XObject ; public class ExtensionHandlerJavaPackage extends ExtensionHandlerJava { public ExtensionHandlerJavaPackage ( String namespaceUri , String scriptLang , String className ) { super ( namespaceUri , scriptLang , className ) ; } public boolean isFunctionAvailable ( String function ) { try { String fullName = m_className + function ; int lastDot = fullName . lastIndexOf ( "." ) ; if ( lastDot >= 0 ) { Class myClass = getClassForName ( fullName . substring ( 0 , lastDot ) ) ; Method [ ] methods = myClass . getMethods ( ) ; int nMethods = methods . length ; function = fullName . substring ( lastDot + 1 ) ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( function ) ) return true ; } } } catch ( ClassNotFoundException cnfe ) { } return false ; } public boolean isElementAvailable ( String element ) { try { String fullName = m_className + element ; int lastDot = fullName . lastIndexOf ( "." ) ; if ( lastDot >= 0 ) { Class myClass = getClassForName ( fullName . substring ( 0 , lastDot ) ) ; Method [ ] methods = myClass . getMethods ( ) ; int nMethods = methods . length ; element = fullName . substring ( lastDot + 1 ) ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( element ) ) { Class [ ] paramTypes = methods [ i ] . getParameterTypes ( ) ; if ( ( paramTypes . length == 2 ) && paramTypes [ 0 ] . isAssignableFrom ( org . apache . xalan . extensions . XSLProcessorContext . class ) && paramTypes [ 1 ] . isAssignableFrom ( org . apache . xalan . templates . ElemExtensionCall . class ) ) { return true ; } } } } } catch ( ClassNotFoundException cnfe ) { } return false ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { String className ; String methodName ; Class classObj ; Object targetObject ; int lastDot = funcName . lastIndexOf ( "." ) ; Object [ ] methodArgs ; Object [ ] [ ] convertedArgs ; Class [ ] paramTypes ; try { if ( funcName . endsWith ( ".new" ) ) { methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Constructor c = ( Constructor ) getFromCache ( methodKey , null , methodArgs ) ; if ( c != null ) { try { paramTypes = c . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return c . newInstance ( convertedArgs [ 0 ] ) ; } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } className = m_className + funcName . substring ( 0 , lastDot ) ; try { classObj = getClassForName ( className ) ; } catch ( ClassNotFoundException e ) { throw new TransformerException ( e ) ; } c = MethodResolver . getConstructor ( classObj , methodArgs , convertedArgs , exprContext ) ; putToCache ( methodKey , null , methodArgs , c ) ; if ( TransformerImpl . S_DEBUG ) { TransformerImpl trans = ( TransformerImpl ) exprContext . getXPathContext ( ) . getOwnerObject ( ) ; trans . getTraceManager ( ) . fireExtensionEvent ( new ExtensionEvent ( trans , c , convertedArgs [ 0 ] ) ) ; Object result ; try { result = c . newInstance ( convertedArgs [ 0 ] ) ; } catch ( Exception e ) { throw e ; } finally { trans . getTraceManager ( ) . fireExtensionEndEvent ( new ExtensionEvent ( trans , c , convertedArgs [ 0 ] ) ) ; } return result ; } else return c . newInstance ( convertedArgs [ 0 ] ) ; } else if ( - 1 != lastDot ) { methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Method m = ( Method ) getFromCache ( methodKey , null , methodArgs ) ; if ( m != null && ! TransformerImpl . S_DEBUG ) { try { paramTypes = m . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return m . invoke ( null , convertedArgs [ 0 ] ) ; } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } className = m_className + funcName . substring ( 0 , lastDot ) ; methodName = funcName . substring ( lastDot + 1 ) ; try { classObj = getClassForName ( className ) ; } catch ( ClassNotFoundException e ) { throw new TransformerException ( e ) ; } m = MethodResolver . getMethod ( classObj , methodName , methodArgs , convertedArgs , exprContext , MethodResolver . STATIC_ONLY ) ; putToCache ( methodKey , null , methodArgs , m ) ; if ( TransformerImpl . S_DEBUG ) { TransformerImpl trans = ( TransformerImpl ) exprContext . getXPathContext ( ) . getOwnerObject ( ) ; trans . getTraceManager ( ) . fireExtensionEvent ( m , null , convertedArgs [ 0 ] ) ; Object result ; try { result = m . invoke ( null , convertedArgs [ 0 ] ) ; } catch ( Exception e ) { throw e ; } finally { trans . getTraceManager ( ) . fireExtensionEndEvent ( m , null , convertedArgs [ 0 ] ) ; } return result ; } else return m . invoke ( null , convertedArgs [ 0 ] ) ; } else { if ( args . size ( ) < 1 ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INSTANCE_MTHD_CALL_REQUIRES , new Object [ ] { funcName } ) ) ; } targetObject = args . elementAt ( 0 ) ; if ( targetObject instanceof XObject ) targetObject = ( ( XObject ) targetObject ) . object ( ) ; methodArgs = new Object [ args . size ( ) - 1 ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i + 1 ) ; } Method m = ( Method ) getFromCache ( methodKey , targetObject , methodArgs ) ; if ( m != null ) { try { paramTypes = m . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } classObj = targetObject . getClass ( ) ; m = MethodResolver . getMethod ( classObj , funcName , methodArgs , convertedArgs , exprContext , MethodResolver . INSTANCE_ONLY ) ; putToCache ( methodKey , targetObject , methodArgs , m ) ; if ( TransformerImpl . S_DEBUG ) { TransformerImpl trans = ( TransformerImpl ) exprContext . getXPathContext ( ) . getOwnerObject ( ) ; trans . getTraceManager ( ) . fireExtensionEvent ( m , targetObject , convertedArgs [ 0 ] ) ; Object result ; try { result = m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } catch ( Exception e ) { throw e ; } finally { trans . getTraceManager ( ) . fireExtensionEndEvent ( m , targetObject , convertedArgs [ 0 ] ) ; } return result ; } else return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } } catch ( InvocationTargetException ite ) { Throwable resultException = ite ; Throwable targetException = ite . getTargetException ( ) ; if ( targetException instanceof TransformerException ) throw ( ( TransformerException ) targetException ) ; else if ( targetException != null ) resultException = targetException ; throw new TransformerException ( resultException ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } public Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException { return callFunction ( extFunction . getFunctionName ( ) , args , extFunction . getMethodKey ( ) , exprContext ) ; } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { Object result = null ; Class classObj ; Method m = ( Method ) getFromCache ( methodKey , null , null ) ; if ( null == m ) { try { String fullName = m_className + localPart ; int lastDot = fullName . lastIndexOf ( "." ) ; if ( lastDot < 0 ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_ELEMENT_NAME , new Object [ ] { fullName } ) ) ; try { classObj = getClassForName ( fullName . substring ( 0 , lastDot ) ) ; } catch ( ClassNotFoundException e ) { throw new TransformerException ( e ) ; } localPart = fullName . substring ( lastDot + 1 ) ; m = MethodResolver . getElementMethod ( classObj , localPart ) ; if ( ! Modifier . isStatic ( m . getModifiers ( ) ) ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ELEMENT_NAME_METHOD_STATIC , new Object [ ] { fullName } ) ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } putToCache ( methodKey , null , null , m ) ; } XSLProcessorContext xpc = new XSLProcessorContext ( transformer , stylesheetTree ) ; try { if ( TransformerImpl . S_DEBUG ) { transformer . getTraceManager ( ) . fireExtensionEvent ( m , null , new Object [ ] { xpc , element } ) ; try { result = m . invoke ( null , new Object [ ] { xpc , element } ) ; } catch ( Exception e ) { throw e ; } finally { transformer . getTraceManager ( ) . fireExtensionEndEvent ( m , null , new Object [ ] { xpc , element } ) ; } } else result = m . invoke ( null , new Object [ ] { xpc , element } ) ; } catch ( InvocationTargetException ite ) { Throwable resultException = ite ; Throwable targetException = ite . getTargetException ( ) ; if ( targetException instanceof TransformerException ) throw ( ( TransformerException ) targetException ) ; else if ( targetException != null ) resultException = targetException ; throw new TransformerException ( resultException ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } if ( result != null ) { xpc . outputToResultTree ( stylesheetTree , result ) ; } } } 	1	['6', '3', '0', '13', '51', '3', '0', '13', '6', '2', '851', '0', '0', '0.615384615', '0.388888889', '2', '5', '140.8333333', '5', '1.6667', '3']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemComment extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_COMMENT ; } public String getNodeName ( ) { return Constants . ELEMNAME_COMMENT_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { String data = transformer . transformToString ( this ) ; transformer . getResultTreeHandler ( ) . comment ( data ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEXTLITERALRESULT : case Constants . ELEMNAME_APPLY_TEMPLATES : case Constants . ELEMNAME_APPLY_IMPORTS : case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_FOREACH : case Constants . ELEMNAME_VALUEOF : case Constants . ELEMNAME_COPY_OF : case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_CHOOSE : case Constants . ELEMNAME_IF : case Constants . ELEMNAME_TEXT : case Constants . ELEMNAME_COPY : case Constants . ELEMNAME_VARIABLE : case Constants . ELEMNAME_MESSAGE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } } 	1	['5', '3', '0', '5', '17', '10', '1', '4', '5', '2', '74', '0', '0', '0.98', '0.466666667', '2', '6', '13.8', '16', '3.8', '2']
package org . apache . xalan . xsltc . compiler ; import java . text . Collator ; import java . util . ArrayList ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . classfile . Method ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ANEWARRAY ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . NOP ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . bcel . generic . TABLESWITCH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . CompareGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSortRecordFactGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSortRecordGenerator ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . dom . Axis ; final class Sort extends Instruction implements Closure { private Expression _select ; private AttributeValue _order ; private AttributeValue _caseOrder ; private AttributeValue _dataType ; private String _lang ; private String _data = null ; private String _className = null ; private ArrayList _closureVars = null ; private boolean _needsSortRecordFactory = false ; public boolean inInnerClass ( ) { return ( _className != null ) ; } public Closure getParentClosure ( ) { return null ; } public String getInnerClassName ( ) { return _className ; } public void addVariable ( VariableRefBase variableRef ) { if ( _closureVars == null ) { _closureVars = new ArrayList ( ) ; } if ( ! _closureVars . contains ( variableRef ) ) { _closureVars . add ( variableRef ) ; _needsSortRecordFactory = true ; } } private void setInnerClassName ( String className ) { _className = className ; } public void parseContents ( Parser parser ) { final SyntaxTreeNode parent = getParent ( ) ; if ( ! ( parent instanceof ApplyTemplates ) && ! ( parent instanceof ForEach ) ) { reportError ( this , parser , ErrorMsg . STRAY_SORT_ERR , null ) ; return ; } _select = parser . parseExpression ( this , "select" , "string(.)" ) ; String val = getAttribute ( "order" ) ; if ( val . length ( ) == 0 ) val = "ascending" ; _order = AttributeValue . create ( this , val , parser ) ; val = getAttribute ( "data-type" ) ; if ( val . length ( ) == 0 ) { try { final Type type = _select . typeCheck ( parser . getSymbolTable ( ) ) ; if ( type instanceof IntType ) val = "number" ; else val = "text" ; } catch ( TypeCheckError e ) { val = "text" ; } } _dataType = AttributeValue . create ( this , val , parser ) ; _lang = getAttribute ( "lang" ) ; val = getAttribute ( "case-order" ) ; _caseOrder = AttributeValue . create ( this , val , parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tselect = _select . typeCheck ( stable ) ; if ( ! ( tselect instanceof StringType ) ) { _select = new CastExpr ( _select , Type . String ) ; } _order . typeCheck ( stable ) ; _caseOrder . typeCheck ( stable ) ; _dataType . typeCheck ( stable ) ; return Type . Void ; } public void translateSortType ( ClassGenerator classGen , MethodGenerator methodGen ) { _dataType . translate ( classGen , methodGen ) ; } public void translateSortOrder ( ClassGenerator classGen , MethodGenerator methodGen ) { _order . translate ( classGen , methodGen ) ; } public void translateCaseOrder ( ClassGenerator classGen , MethodGenerator methodGen ) { _caseOrder . translate ( classGen , methodGen ) ; } public void translateLang ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _lang ) ) ; } public void translateSelect ( ClassGenerator classGen , MethodGenerator methodGen ) { _select . translate ( classGen , methodGen ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } public static void translateSortIterator ( ClassGenerator classGen , MethodGenerator methodGen , Expression nodeSet , Vector sortObjects ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( SORT_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + NODE_SORT_FACTORY_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( SORT_ITERATOR ) ) ) ; il . append ( DUP ) ; if ( nodeSet == null ) { final int children = cpg . addInterfaceMethodref ( DOM_INTF , "getAxisIterator" , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , Axis . CHILD ) ) ; il . append ( new INVOKEINTERFACE ( children , 2 ) ) ; } else { nodeSet . translate ( classGen , methodGen ) ; } compileSortRecordFactory ( sortObjects , classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } public static void compileSortRecordFactory ( Vector sortObjects , ClassGenerator classGen , MethodGenerator methodGen ) { String sortRecordClass = compileSortRecord ( sortObjects , classGen , methodGen ) ; boolean needsSortRecordFactory = false ; final int nsorts = sortObjects . size ( ) ; for ( int i = 0 ; i < nsorts ; i ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( i ) ; needsSortRecordFactory |= sort . _needsSortRecordFactory ; } String sortRecordFactoryClass = NODE_SORT_FACTORY ; if ( needsSortRecordFactory ) { sortRecordFactoryClass = compileSortRecordFactory ( sortObjects , classGen , methodGen , sortRecordClass ) ; } final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( sortRecordFactoryClass ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , sortRecordClass ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , nsorts ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int level = 0 ; level < nsorts ; level ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , level ) ) ; sort . translateSortOrder ( classGen , methodGen ) ; il . append ( AASTORE ) ; } il . append ( new PUSH ( cpg , nsorts ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int level = 0 ; level < nsorts ; level ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , level ) ) ; sort . translateSortType ( classGen , methodGen ) ; il . append ( AASTORE ) ; } il . append ( new PUSH ( cpg , nsorts ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int level = 0 ; level < nsorts ; level ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , level ) ) ; sort . translateLang ( classGen , methodGen ) ; il . append ( AASTORE ) ; } il . append ( new PUSH ( cpg , nsorts ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int level = 0 ; level < nsorts ; level ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , level ) ) ; sort . translateCaseOrder ( classGen , methodGen ) ; il . append ( AASTORE ) ; } il . append ( new INVOKESPECIAL ( cpg . addMethodref ( sortRecordFactoryClass , "<init>" , "(" + DOM_INTF_SIG + STRING_SIG + TRANSLET_INTF_SIG + "[" + STRING_SIG + "[" + STRING_SIG + "[" + STRING_SIG + "[" + STRING_SIG + ")V" ) ) ) ; final ArrayList dups = new ArrayList ( ) ; for ( int j = 0 ; j < nsorts ; j ++ ) { final Sort sort = ( Sort ) sortObjects . get ( j ) ; final int length = ( sort . _closureVars == null ) ? 0 : sort . _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { VariableRefBase varRef = ( VariableRefBase ) sort . _closureVars . get ( i ) ; if ( dups . contains ( varRef ) ) continue ; final VariableBase var = varRef . getVariable ( ) ; il . append ( DUP ) ; il . append ( var . loadInstruction ( ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( sortRecordFactoryClass , var . getEscapedName ( ) , var . getType ( ) . toSignature ( ) ) ) ) ; dups . add ( varRef ) ; } } } public static String compileSortRecordFactory ( Vector sortObjects , ClassGenerator classGen , MethodGenerator methodGen , String sortRecordClass ) { final XSLTC xsltc = ( ( Sort ) sortObjects . firstElement ( ) ) . getXSLTC ( ) ; final String className = xsltc . getHelperClassName ( ) ; final NodeSortRecordFactGenerator sortRecordFactory = new NodeSortRecordFactGenerator ( className , NODE_SORT_FACTORY , className + ".java" , ACC_PUBLIC | ACC_SUPER | ACC_FINAL , new String [ ] { } , classGen . getStylesheet ( ) ) ; ConstantPoolGen cpg = sortRecordFactory . getConstantPool ( ) ; final int nsorts = sortObjects . size ( ) ; final ArrayList dups = new ArrayList ( ) ; for ( int j = 0 ; j < nsorts ; j ++ ) { final Sort sort = ( Sort ) sortObjects . get ( j ) ; final int length = ( sort . _closureVars == null ) ? 0 : sort . _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final VariableRefBase varRef = ( VariableRefBase ) sort . _closureVars . get ( i ) ; if ( dups . contains ( varRef ) ) continue ; final VariableBase var = varRef . getVariable ( ) ; sortRecordFactory . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getEscapedName ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; dups . add ( varRef ) ; } } final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 7 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( STRING_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_INTF_SIG ) ; argTypes [ 3 ] = Util . getJCRefType ( "[" + STRING_SIG ) ; argTypes [ 4 ] = Util . getJCRefType ( "[" + STRING_SIG ) ; argTypes [ 5 ] = Util . getJCRefType ( "[" + STRING_SIG ) ; argTypes [ 6 ] = Util . getJCRefType ( "[" + STRING_SIG ) ; final String [ ] argNames = new String [ 7 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = "className" ; argNames [ 2 ] = TRANSLET_PNAME ; argNames [ 3 ] = "order" ; argNames [ 4 ] = "type" ; argNames [ 5 ] = "lang" ; argNames [ 6 ] = "case_order" ; InstructionList il = new InstructionList ( ) ; final MethodGenerator constructor = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "<init>" , className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( ALOAD_1 ) ; il . append ( ALOAD_2 ) ; il . append ( new ALOAD ( 3 ) ) ; il . append ( new ALOAD ( 4 ) ) ; il . append ( new ALOAD ( 5 ) ) ; il . append ( new ALOAD ( 6 ) ) ; il . append ( new ALOAD ( 7 ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( NODE_SORT_FACTORY , "<init>" , "(" + DOM_INTF_SIG + STRING_SIG + TRANSLET_INTF_SIG + "[" + STRING_SIG + "[" + STRING_SIG + "[" + STRING_SIG + "[" + STRING_SIG + ")V" ) ) ) ; il . append ( RETURN ) ; il = new InstructionList ( ) ; final MethodGenerator makeNodeSortRecord = new MethodGenerator ( ACC_PUBLIC , Util . getJCRefType ( NODE_SORT_RECORD_SIG ) , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT } , new String [ ] { "node" , "last" } , "makeNodeSortRecord" , className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( ILOAD_1 ) ; il . append ( ILOAD_2 ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( NODE_SORT_FACTORY , "makeNodeSortRecord" , "(II)" + NODE_SORT_RECORD_SIG ) ) ) ; il . append ( DUP ) ; il . append ( new CHECKCAST ( cpg . addClass ( sortRecordClass ) ) ) ; final int ndups = dups . size ( ) ; for ( int i = 0 ; i < ndups ; i ++ ) { final VariableRefBase varRef = ( VariableRefBase ) dups . get ( i ) ; final VariableBase var = varRef . getVariable ( ) ; final Type varType = var . getType ( ) ; il . append ( DUP ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( className , var . getEscapedName ( ) , varType . toSignature ( ) ) ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( sortRecordClass , var . getEscapedName ( ) , varType . toSignature ( ) ) ) ) ; } il . append ( POP ) ; il . append ( ARETURN ) ; constructor . setMaxLocals ( ) ; constructor . setMaxStack ( ) ; sortRecordFactory . addMethod ( constructor . getMethod ( ) ) ; makeNodeSortRecord . setMaxLocals ( ) ; makeNodeSortRecord . setMaxStack ( ) ; sortRecordFactory . addMethod ( makeNodeSortRecord . getMethod ( ) ) ; xsltc . dumpClass ( sortRecordFactory . getJavaClass ( ) ) ; return className ; } private static String compileSortRecord ( Vector sortObjects , ClassGenerator classGen , MethodGenerator methodGen ) { final XSLTC xsltc = ( ( Sort ) sortObjects . firstElement ( ) ) . getXSLTC ( ) ; final String className = xsltc . getHelperClassName ( ) ; final NodeSortRecordGenerator sortRecord = new NodeSortRecordGenerator ( className , NODE_SORT_RECORD , "sort$0.java" , ACC_PUBLIC | ACC_SUPER | ACC_FINAL , new String [ ] { } , classGen . getStylesheet ( ) ) ; final ConstantPoolGen cpg = sortRecord . getConstantPool ( ) ; final int nsorts = sortObjects . size ( ) ; final ArrayList dups = new ArrayList ( ) ; for ( int j = 0 ; j < nsorts ; j ++ ) { final Sort sort = ( Sort ) sortObjects . get ( j ) ; sort . setInnerClassName ( className ) ; final int length = ( sort . _closureVars == null ) ? 0 : sort . _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final VariableRefBase varRef = ( VariableRefBase ) sort . _closureVars . get ( i ) ; if ( dups . contains ( varRef ) ) continue ; final VariableBase var = varRef . getVariable ( ) ; sortRecord . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getEscapedName ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; dups . add ( varRef ) ; } } Method init = compileInit ( sortObjects , sortRecord , cpg , className ) ; Method extract = compileExtract ( sortObjects , sortRecord , cpg , className ) ; sortRecord . addMethod ( init ) ; sortRecord . addMethod ( extract ) ; xsltc . dumpClass ( sortRecord . getJavaClass ( ) ) ; return className ; } private static Method compileInit ( Vector sortObjects , NodeSortRecordGenerator sortRecord , ConstantPoolGen cpg , String className ) { final InstructionList il = new InstructionList ( ) ; final MethodGenerator init = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , null , null , "<init>" , className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( NODE_SORT_RECORD , "<init>" , "()V" ) ) ) ; il . append ( RETURN ) ; init . stripAttributes ( true ) ; init . setMaxLocals ( ) ; init . setMaxStack ( ) ; return init . getMethod ( ) ; } private static Method compileExtract ( Vector sortObjects , NodeSortRecordGenerator sortRecord , ConstantPoolGen cpg , String className ) { final InstructionList il = new InstructionList ( ) ; final CompareGenerator extractMethod = new CompareGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . STRING , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( DOM_INTF_SIG ) , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , Util . getJCRefType ( TRANSLET_SIG ) , org . apache . bcel . generic . Type . INT } , new String [ ] { "dom" , "current" , "level" , "translet" , "last" } , "extractValueFromDOM" , className , il , cpg ) ; final int levels = sortObjects . size ( ) ; final int match [ ] = new int [ levels ] ; final InstructionHandle target [ ] = new InstructionHandle [ levels ] ; InstructionHandle tblswitch = null ; if ( levels > 1 ) { il . append ( new ILOAD ( extractMethod . getLocalIndex ( "level" ) ) ) ; tblswitch = il . append ( new NOP ( ) ) ; } for ( int level = 0 ; level < levels ; level ++ ) { match [ level ] = level ; final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; target [ level ] = il . append ( NOP ) ; sort . translateSelect ( sortRecord , extractMethod ) ; il . append ( ARETURN ) ; } if ( levels > 1 ) { InstructionHandle defaultTarget = il . append ( new PUSH ( cpg , EMPTYSTRING ) ) ; il . insert ( tblswitch , new TABLESWITCH ( match , target , defaultTarget ) ) ; il . append ( ARETURN ) ; } extractMethod . stripAttributes ( true ) ; extractMethod . setMaxLocals ( ) ; extractMethod . setMaxStack ( ) ; extractMethod . removeNOPs ( ) ; return extractMethod . getMethod ( ) ; } } 	1	['20', '3', '0', '55', '105', '130', '2', '55', '15', '0.847953216', '1393', '1', '4', '0.746666667', '0.236363636', '1', '4', '68.2', '11', '2.5', '2']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "The current() function is not allowed in a match pattern!" } , { ER_CURRENT_TAKES_NO_ARGS , "The current() function does not accept arguments!" } , { ER_DOCUMENT_REPLACED , "document() function implementation has been replaced by org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "context does not have an owner document!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() has too many arguments." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() has too many arguments." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() has too many arguments." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() has too many arguments." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() has too many arguments." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() has too many arguments." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() has too many arguments." } , { ER_TRANSLATE_TAKES_3_ARGS , "The translate() function takes three arguments!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "The unparsed-entity-uri function should take one argument!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "namespace axis not implemented yet!" } , { ER_UNKNOWN_AXIS , "unknown axis: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "unknown match operation!" } , { ER_INCORRECT_ARG_LENGTH , "Arg length of processing-instruction() node test is incorrect!" } , { ER_CANT_CONVERT_TO_NUMBER , "Can not convert {0} to a number" } , { ER_CANT_CONVERT_TO_NODELIST , "Can not convert {0} to a NodeList!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Can not convert {0} to a NodeSetDTM!" } , { ER_CANT_CONVERT_TO_TYPE , "Can not convert {0} to a type#{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Expected match pattern in getMatchScore!" } , { ER_COULDNOT_GET_VAR_NAMED , "Could not get variable named {0}" } , { ER_UNKNOWN_OPCODE , "ERROR! Unknown op code: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Extra illegal tokens: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "misquoted literal... expected double quote!" } , { ER_EXPECTED_SINGLE_QUOTE , "misquoted literal... expected single quote!" } , { ER_EMPTY_EXPRESSION , "Empty expression!" } , { ER_EXPECTED_BUT_FOUND , "Expected {0}, but found: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Programmer assertion is incorrect! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "boolean(...) argument is no longer optional with 19990709 XPath draft." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Found ',' but no preceding argument!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Found ',' but no following argument!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' or '.[predicate]' is illegal syntax.  Use 'self::node()[predicate]' instead." } , { ER_ILLEGAL_AXIS_NAME , "illegal axis name: {0}" } , { ER_UNKNOWN_NODETYPE , "Unknown nodetype: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Pattern literal ({0}) needs to be quoted!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} could not be formatted to a number!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Could not create XML TransformerFactory Liaison: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Error! Did not find xpath select expression (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "ERROR! Could not find ENDOP after OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Error occured!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference given for variable out of context or without definition!  Name = {0}" } , { ER_AXES_NOT_ALLOWED , "Only child:: and attribute:: axes are allowed in match patterns!  Offending axes = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() has an incorrect number of arguments." } , { ER_COUNT_TAKES_1_ARG , "The count function should take one argument!" } , { ER_COULDNOT_FIND_FUNCTION , "Could not find function: {0}" } , { ER_UNSUPPORTED_ENCODING , "Unsupported encoding: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Problem occured in DTM in getNextSibling... trying to recover" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Programmer error: EmptyNodeList can not be written to." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory is not supported by XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (InputSource source) not supported in XPathContext! Can not open {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API characters(char ch[]... not handled by the DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... not handled by the DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison can not handle nodes of type {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper can not handle nodes of type {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse error: SystemID - {0} line - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse error" } , { ER_INVALID_UTF16_SURROGATE , "Invalid UTF-16 surrogate detected: {0} ?" } , { ER_OIERROR , "IO error" } , { ER_CANNOT_CREATE_URL , "Cannot create url for: {0}" } , { ER_XPATH_READOBJECT , "In XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "function token not found." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Can not deal with XPath type: {0}" } , { ER_NODESET_NOT_MUTABLE , "This NodeSet is not mutable" } , { ER_NODESETDTM_NOT_MUTABLE , "This NodeSetDTM is not mutable" } , { ER_VAR_NOT_RESOLVABLE , "Variable not resolvable: {0}" } , { ER_NULL_ERROR_HANDLER , "Null error handler" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Programmer''s assertion: unknown opcode: {0}" } , { ER_ZERO_OR_ONE , "0 or 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() not supported by XRTreeFragSelectWrapper" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() not supported by XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() not supported for XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Could not find variable with the name of {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars can not take a string for an argument" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "The FastStringBuffer argument can not be null" } , { ER_TWO_OR_THREE , "2 or 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Variable accessed before it is bound!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB can not take a string for an argument!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Error! Setting the root of a walker to null!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "This NodeSetDTM can not iterate to a previous node!" } , { ER_NODESET_CANNOT_ITERATE , "This NodeSet can not iterate to a previous node!" } , { ER_NODESETDTM_CANNOT_INDEX , "This NodeSetDTM can not do indexing or counting functions!" } , { ER_NODESET_CANNOT_INDEX , "This NodeSet can not do indexing or counting functions!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Can not call setShouldCacheNodes after nextNode has been called!" } , { ER_ONLY_ALLOWS , "{0} only allows {1} arguments" } , { ER_UNKNOWN_STEP , "Programmer''s assertion in getNextStepPos: unknown stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "A relative location path was expected following the '/' or '//' token." } , { ER_EXPECTED_LOC_PATH , "A location path was expected, but the following token was encountered:  {0}" } , { ER_EXPECTED_LOC_STEP , "A location step was expected following the '/' or '//' token." } , { ER_EXPECTED_NODE_TEST , "A node test that matches either NCName:* or QName was expected." } , { ER_EXPECTED_STEP_PATTERN , "A step pattern was expected, but '/' was encountered." } , { ER_EXPECTED_REL_PATH_PATTERN , "A relative path pattern was expected." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Cannot convert {0} to a boolean." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Cannot convert {0} to a single node. This getter applies to types ANY_UNORDERED_NODE_TYPE and FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Cannot get snapshot length on type: {0}. This getter applies to types UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Cannot iterate over non-iterator type: {0}" } , { ER_DOC_MUTATED , "Document mutated since result was returned. Iterator is invalid." } , { ER_INVALID_XPATH_TYPE , "Invalid XPath type argument: {0}" } , { ER_EMPTY_XPATH_RESULT , "Empty XPath result object" } , { ER_INCOMPATIBLE_TYPES , "The returned type: {0} cannot be coerced into the specified type: {1}" } , { ER_NULL_RESOLVER , "Unable to resolve prefix with null prefix resolver." } , { ER_CANT_CONVERT_TO_STRING , "Cannot convert {0} to a string." } , { ER_NON_SNAPSHOT_TYPE , "Cannot call snapshotItem on type: {0}. This method applies to types UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Context node does not belong to the document that is bound to this XPathEvaluator." } , { ER_WRONG_NODETYPE , "The context node type is not supported." } , { ER_XPATH_ERROR , "Unknown error in XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "locale name in the format-number function not yet handled!" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL Property not supported: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Do not currently do anything with namespace {0} in property: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException when trying to access XSL system property: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Old syntax: quo(...) is no longer defined in XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath needs a derived object to implement nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "function token not found." } , { WG_COULDNOT_FIND_FUNCTION , "Could not find function: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Can not make URL from: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "-E option not supported for DTM parser" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference given for variable out of context or without definition!  Name = {0}" } , { WG_UNSUPPORTED_ENCODING , "Unsupported encoding: {0}" } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "Parameter to createMessage was out of bounds" } , { "FORMAT_FAILED" , "Exception thrown during messageFormat call" } , { "version" , ">>>>>>> Xalan Version " } , { "version2" , "<<<<<<<" } , { "yes" , "yes" } , { "line" , "Line #" } , { "column" , "Column #" } , { "xsldone" , "XSLProcessor: done" } , { "xpath_option" , "xpath options: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath expression]" } , { "optionMatch" , "   [-match match pattern (for match diagnostics)]" } , { "optionAnyExpr" , "Or just an xpath expression will do a diagnostic dump" } , { "noParsermsg1" , "XSL Process was not successful." } , { "noParsermsg2" , "** Could not find parser **" } , { "noParsermsg3" , "Please check your classpath." } , { "noParsermsg4" , "If you don't have IBM's XML Parser for Java, you can download it from" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Warning: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '2', '18', '16', '8', '18', '0', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '6']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLChar ; import org . apache . xpath . XPathContext ; import org . xml . sax . SAXException ; public class ElemElement extends ElemUse { protected AVT m_name_avt = null ; public void setName ( AVT v ) { m_name_avt = v ; } public AVT getName ( ) { return m_name_avt ; } protected AVT m_namespace_avt = null ; public void setNamespace ( AVT v ) { m_namespace_avt = v ; } public AVT getNamespace ( ) { return m_namespace_avt ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_name_avt ) m_name_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_namespace_avt ) m_namespace_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_ELEMENT ; } public String getNodeName ( ) { return Constants . ELEMNAME_ELEMENT_STRING ; } protected String resolvePrefix ( SerializationHandler rhandler , String prefix , String nodeNamespace ) throws TransformerException { return prefix ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; SerializationHandler rhandler = transformer . getSerializationHandler ( ) ; XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; String nodeName = m_name_avt == null ? null : m_name_avt . evaluate ( xctxt , sourceNode , this ) ; String prefix = null ; String nodeNamespace = "" ; if ( ( nodeName != null ) && ( ! m_name_avt . isSimple ( ) ) && ( ! XMLChar . isValidQName ( nodeName ) ) ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_NAME , nodeName } ) ; nodeName = null ; } else if ( nodeName != null ) { prefix = QName . getPrefixPart ( nodeName ) ; if ( null != m_namespace_avt ) { nodeNamespace = m_namespace_avt . evaluate ( xctxt , sourceNode , this ) ; if ( null == nodeNamespace || ( prefix != null && prefix . length ( ) > 0 && nodeNamespace . length ( ) == 0 ) ) transformer . getMsgMgr ( ) . error ( this , XSLTErrorResources . ER_NULL_URI_NAMESPACE ) ; else { prefix = resolvePrefix ( rhandler , prefix , nodeNamespace ) ; if ( null == prefix ) prefix = "" ; if ( prefix . length ( ) > 0 ) nodeName = ( prefix + ":" + QName . getLocalPart ( nodeName ) ) ; else nodeName = QName . getLocalPart ( nodeName ) ; } } else { try { nodeNamespace = getNamespaceForPrefix ( prefix ) ; if ( ( null == nodeNamespace ) && ( prefix . length ( ) == 0 ) ) nodeNamespace = "" ; else if ( null == nodeNamespace ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_COULD_NOT_RESOLVE_PREFIX , new Object [ ] { prefix } ) ; nodeName = null ; } } catch ( Exception ex ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_COULD_NOT_RESOLVE_PREFIX , new Object [ ] { prefix } ) ; nodeName = null ; } } } constructNode ( nodeName , prefix , nodeNamespace , transformer ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { boolean shouldAddAttrs ; try { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( null == nodeName ) { shouldAddAttrs = false ; } else { if ( null != prefix ) { rhandler . startPrefixMapping ( prefix , nodeNamespace , true ) ; } rhandler . startElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; super . execute ( transformer ) ; shouldAddAttrs = true ; } transformer . executeChildTemplates ( this , shouldAddAttrs ) ; if ( null != nodeName ) { rhandler . endElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; if ( null != prefix ) { rhandler . endPrefixMapping ( prefix ) ; } } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) { if ( null != m_name_avt ) m_name_avt . callVisitors ( visitor ) ; if ( null != m_namespace_avt ) m_namespace_avt . callVisitors ( visitor ) ; } super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['12', '4', '1', '16', '47', '18', '2', '14', '9', '0.545454545', '331', '1', '2', '0.948356808', '0.229166667', '2', '6', '26.41666667', '4', '1.1667', '2']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; public class MatchPatternIterator extends LocPathIterator { protected StepPattern m_pattern ; protected int m_superAxis = - 1 ; protected DTMAxisTraverser m_traverser ; private static final boolean DEBUG = false ; MatchPatternIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; m_pattern = WalkerFactory . loadSteps ( this , compiler , firstStepPos , 0 ) ; boolean fromRoot = false ; boolean walkBack = false ; boolean walkDescendants = false ; boolean walkAttributes = false ; if ( 0 != ( analysis & ( WalkerFactory . BIT_ROOT | WalkerFactory . BIT_ANY_DESCENDANT_FROM_ROOT ) ) ) fromRoot = true ; if ( 0 != ( analysis & ( WalkerFactory . BIT_ANCESTOR | WalkerFactory . BIT_ANCESTOR_OR_SELF | WalkerFactory . BIT_PRECEDING | WalkerFactory . BIT_PRECEDING_SIBLING | WalkerFactory . BIT_FOLLOWING | WalkerFactory . BIT_FOLLOWING_SIBLING | WalkerFactory . BIT_PARENT | WalkerFactory . BIT_FILTER ) ) ) walkBack = true ; if ( 0 != ( analysis & ( WalkerFactory . BIT_DESCENDANT_OR_SELF | WalkerFactory . BIT_DESCENDANT | WalkerFactory . BIT_CHILD ) ) ) walkDescendants = true ; if ( 0 != ( analysis & ( WalkerFactory . BIT_ATTRIBUTE | WalkerFactory . BIT_NAMESPACE ) ) ) walkAttributes = true ; if ( false || DEBUG ) { System . out . print ( "analysis: " + Integer . toBinaryString ( analysis ) ) ; System . out . println ( ", " + WalkerFactory . getAnalysisString ( analysis ) ) ; } if ( fromRoot || walkBack ) { if ( walkAttributes ) { m_superAxis = Axis . ALL ; } else { m_superAxis = Axis . DESCENDANTSFROMROOT ; } } else if ( walkDescendants ) { if ( walkAttributes ) { m_superAxis = Axis . ALLFROMNODE ; } else { m_superAxis = Axis . DESCENDANTORSELF ; } } else { m_superAxis = Axis . ALL ; } if ( false || DEBUG ) { System . out . println ( "axis: " + Axis . names [ m_superAxis ] ) ; } } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( m_superAxis ) ; } public void detach ( ) { if ( m_allowDetach ) { m_traverser = null ; super . detach ( ) ; } } protected int getNextNode ( ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; return m_lastFetched ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next ; org . apache . xpath . VariableStack vars ; int savedStart ; if ( - 1 != m_stackFrame ) { vars = m_execContext . getVarStack ( ) ; savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( m_stackFrame ) ; } else { vars = null ; savedStart = 0 ; } try { if ( DEBUG ) System . out . println ( "m_pattern" + m_pattern . toString ( ) ) ; do { next = getNextNode ( ) ; if ( DTM . NULL != next ) { if ( DTMIterator . FILTER_ACCEPT == acceptNode ( next , m_execContext ) ) break ; else continue ; } else break ; } while ( next != DTM . NULL ) ; if ( DTM . NULL != next ) { if ( DEBUG ) { System . out . println ( "next: " + next ) ; System . out . println ( "name: " + m_cdtm . getNodeName ( next ) ) ; } incrementCurrentPos ( ) ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } finally { if ( - 1 != m_stackFrame ) { vars . setStackFrame ( savedStart ) ; } } } public short acceptNode ( int n , XPathContext xctxt ) { try { xctxt . pushCurrentNode ( n ) ; xctxt . pushIteratorRoot ( m_context ) ; if ( DEBUG ) { System . out . println ( "traverser: " + m_traverser ) ; System . out . print ( "node: " + n ) ; System . out . println ( ", " + m_cdtm . getNodeName ( n ) ) ; System . out . println ( "pattern: " + m_pattern . toString ( ) ) ; m_pattern . debugWhatToShow ( m_pattern . getWhatToShow ( ) ) ; } XObject score = m_pattern . execute ( xctxt ) ; if ( DEBUG ) { System . out . println ( "score: " + score ) ; System . out . println ( "skip: " + ( score == NodeTest . SCORE_NONE ) ) ; } return ( score == NodeTest . SCORE_NONE ) ? DTMIterator . FILTER_SKIP : DTMIterator . FILTER_ACCEPT ; } catch ( javax . xml . transform . TransformerException se ) { throw new RuntimeException ( se . getMessage ( ) ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . popIteratorRoot ( ) ; } } } 	1	['6', '5', '0', '11', '25', '3', '1', '11', '4', '0.75', '261', '1', '2', '0.961538462', '0.4', '1', '6', '41.83333333', '10', '2.8333', '2']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . utils . XMLChar ; import org . apache . xml . serializer . ElemDesc ; import org . apache . xml . serializer . SerializationHandler ; final class XslAttribute extends Instruction { private String _prefix ; private AttributeValue _name ; private AttributeValueTemplate _namespace = null ; private boolean _ignore = false ; private boolean _isLiteral = false ; public AttributeValue getName ( ) { return _name ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Attribute " + _name ) ; displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { boolean generated = false ; final SymbolTable stable = parser . getSymbolTable ( ) ; String name = getAttribute ( "name" ) ; String namespace = getAttribute ( "namespace" ) ; QName qname = parser . getQName ( name , false ) ; final String prefix = qname . getPrefix ( ) ; if ( ( ( prefix != null ) && ( prefix . equals ( XMLNS_PREFIX ) ) ) || ( name . equals ( XMLNS_PREFIX ) ) ) { reportError ( this , parser , ErrorMsg . ILLEGAL_ATTR_NAME_ERR , name ) ; return ; } _isLiteral = Util . isLiteral ( name ) ; if ( _isLiteral ) { if ( ! XMLChar . isValidQName ( name ) ) { reportError ( this , parser , ErrorMsg . ILLEGAL_ATTR_NAME_ERR , name ) ; return ; } } final SyntaxTreeNode parent = getParent ( ) ; final Vector siblings = parent . getContents ( ) ; for ( int i = 0 ; i < parent . elementCount ( ) ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) siblings . elementAt ( i ) ; if ( item == this ) break ; if ( item instanceof XslAttribute ) continue ; if ( item instanceof UseAttributeSets ) continue ; if ( item instanceof LiteralAttribute ) continue ; if ( item instanceof Text ) continue ; if ( item instanceof If ) continue ; if ( item instanceof Choose ) continue ; if ( item instanceof CopyOf ) continue ; if ( item instanceof VariableBase ) continue ; reportWarning ( this , parser , ErrorMsg . STRAY_ATTRIBUTE_ERR , name ) ; } if ( namespace != null && namespace != Constants . EMPTYSTRING ) { _prefix = lookupPrefix ( namespace ) ; _namespace = new AttributeValueTemplate ( namespace , parser , this ) ; } else if ( prefix != null && prefix != Constants . EMPTYSTRING ) { _prefix = prefix ; namespace = lookupNamespace ( prefix ) ; if ( namespace != null ) { _namespace = new AttributeValueTemplate ( namespace , parser , this ) ; } } if ( _namespace != null ) { if ( _prefix == null || _prefix == Constants . EMPTYSTRING ) { if ( prefix != null ) { _prefix = prefix ; } else { _prefix = stable . generateNamespacePrefix ( ) ; generated = true ; } } else if ( prefix != null && ! prefix . equals ( _prefix ) ) { _prefix = prefix ; } name = _prefix + ":" + qname . getLocalPart ( ) ; if ( ( parent instanceof LiteralElement ) && ( ! generated ) ) { ( ( LiteralElement ) parent ) . registerNamespace ( _prefix , namespace , stable , false ) ; } } if ( parent instanceof LiteralElement ) { ( ( LiteralElement ) parent ) . addAttribute ( this ) ; } _name = AttributeValue . create ( this , name , parser ) ; parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( ! _ignore ) { _name . typeCheck ( stable ) ; if ( _namespace != null ) { _namespace . typeCheck ( stable ) ; } typeCheckContents ( stable ) ; } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _ignore ) return ; _ignore = true ; if ( _namespace != null ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _prefix ) ) ; _namespace . translate ( classGen , methodGen ) ; il . append ( methodGen . namespace ( ) ) ; } if ( ! _isLiteral ) { LocalVariableGen nameValue = methodGen . addLocalVariable2 ( "nameValue" , Util . getJCRefType ( STRING_SIG ) , il . getEnd ( ) ) ; _name . translate ( classGen , methodGen ) ; il . append ( new ASTORE ( nameValue . getIndex ( ) ) ) ; il . append ( new ALOAD ( nameValue . getIndex ( ) ) ) ; final int check = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "checkAttribQName" , "(" + STRING_SIG + ")V" ) ; il . append ( new INVOKESTATIC ( check ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( DUP ) ; il . append ( new ALOAD ( nameValue . getIndex ( ) ) ) ; } else { il . append ( methodGen . loadHandler ( ) ) ; il . append ( DUP ) ; _name . translate ( classGen , methodGen ) ; } if ( ( elementCount ( ) == 1 ) && ( elementAt ( 0 ) instanceof Text ) ) { il . append ( new PUSH ( cpg , ( ( Text ) elementAt ( 0 ) ) . getText ( ) ) ) ; } else { il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , "stringValueHandler" , STRING_VALUE_HANDLER_SIG ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeHandler ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_VALUE_HANDLER , "getValue" , "()" + STRING_SIG ) ) ) ; } SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof LiteralElement && ( ( LiteralElement ) parent ) . allAttributesUnique ( ) ) { int flags = 0 ; ElemDesc elemDesc = ( ( LiteralElement ) parent ) . getElemDesc ( ) ; if ( elemDesc != null && _name instanceof SimpleAttributeValue ) { String attrName = ( ( SimpleAttributeValue ) _name ) . toString ( ) ; if ( elemDesc . isAttrFlagSet ( attrName , ElemDesc . ATTREMPTY ) ) { flags = flags | SerializationHandler . HTML_ATTREMPTY ; } else if ( elemDesc . isAttrFlagSet ( attrName , ElemDesc . ATTRURL ) ) { flags = flags | SerializationHandler . HTML_ATTRURL ; } } il . append ( new PUSH ( cpg , flags ) ) ; il . append ( methodGen . uniqueAttribute ( ) ) ; } else { il . append ( methodGen . attribute ( ) ) ; } il . append ( methodGen . storeHandler ( ) ) ; } } 	1	['6', '3', '0', '39', '72', '0', '3', '37', '5', '0.52', '550', '1', '2', '0.918032787', '0.305555556', '2', '10', '89.83333333', '30', '7.5', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExtensionHandler ; import org . apache . xalan . extensions . ExtensionsTable ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPathContext ; import org . xml . sax . SAXException ; public class ElemExtensionCall extends ElemLiteralResult { String m_extns ; String m_lang ; String m_srcURL ; String m_scriptSrc ; ElemExtensionDecl m_decl = null ; public int getXSLToken ( ) { return Constants . ELEMNAME_EXTENSIONCALL ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; m_extns = this . getNamespace ( ) ; m_decl = getElemExtensionDecl ( sroot , m_extns ) ; if ( m_decl == null ) sroot . getExtensionNamespacesManager ( ) . registerExtension ( m_extns ) ; } private ElemExtensionDecl getElemExtensionDecl ( StylesheetRoot stylesheet , String namespace ) { ElemExtensionDecl decl = null ; int n = stylesheet . getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Stylesheet imported = stylesheet . getGlobalImport ( i ) ; for ( ElemTemplateElement child = imported . getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { if ( Constants . ELEMNAME_EXTENSIONDECL == child . getXSLToken ( ) ) { decl = ( ElemExtensionDecl ) child ; String prefix = decl . getPrefix ( ) ; String declNamespace = child . getNamespaceForPrefix ( prefix ) ; if ( namespace . equals ( declNamespace ) ) { return decl ; } } } } return null ; } private void executeFallbacks ( TransformerImpl transformer ) throws TransformerException { for ( ElemTemplateElement child = m_firstChild ; child != null ; child = child . m_nextSibling ) { if ( child . getXSLToken ( ) == Constants . ELEMNAME_FALLBACK ) { try { transformer . pushElemTemplateElement ( child ) ; ( ( ElemFallback ) child ) . executeFallback ( transformer ) ; } finally { transformer . popElemTemplateElement ( ) ; } } } } private boolean hasFallbackChildren ( ) { for ( ElemTemplateElement child = m_firstChild ; child != null ; child = child . m_nextSibling ) { if ( child . getXSLToken ( ) == Constants . ELEMNAME_FALLBACK ) return true ; } return false ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { transformer . getResultTreeHandler ( ) . flushPending ( ) ; ExtensionsTable etable = transformer . getExtensionsTable ( ) ; ExtensionHandler nsh = etable . get ( m_extns ) ; if ( null == nsh ) { if ( hasFallbackChildren ( ) ) { executeFallbacks ( transformer ) ; } else { TransformerException te = new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CALL_TO_EXT_FAILED , new Object [ ] { getNodeName ( ) } ) ) ; transformer . getErrorListener ( ) . fatalError ( te ) ; } return ; } try { nsh . processElement ( this . getLocalName ( ) , this , transformer , getStylesheet ( ) , this ) ; } catch ( Exception e ) { if ( hasFallbackChildren ( ) ) executeFallbacks ( transformer ) ; else { if ( e instanceof TransformerException ) { TransformerException te = ( TransformerException ) e ; if ( null == te . getLocator ( ) ) te . setLocator ( this ) ; transformer . getErrorListener ( ) . fatalError ( te ) ; } else if ( e instanceof RuntimeException ) { transformer . getErrorListener ( ) . fatalError ( new TransformerException ( e ) ) ; } else { transformer . getErrorListener ( ) . warning ( new TransformerException ( e ) ) ; } } } } catch ( TransformerException e ) { transformer . getErrorListener ( ) . fatalError ( e ) ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public String getAttribute ( String rawName ) { AVT avt = getLiteralResultAttribute ( rawName ) ; if ( ( null != avt ) && avt . getRawName ( ) . equals ( rawName ) ) { return avt . getSimpleString ( ) ; } return null ; } public String getAttribute ( String rawName , org . w3c . dom . Node sourceNode , TransformerImpl transformer ) throws TransformerException { AVT avt = getLiteralResultAttribute ( rawName ) ; if ( ( null != avt ) && avt . getRawName ( ) . equals ( rawName ) ) { XPathContext xctxt = transformer . getXPathContext ( ) ; return avt . evaluate ( xctxt , xctxt . getDTMHandleFromNode ( sourceNode ) , this ) ; } return null ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitExtensionElement ( this ) ; } } 	1	['10', '5', '0', '21', '52', '39', '4', '18', '6', '1.022222222', '304', '0', '1', '0.963709677', '0.333333333', '3', '7', '28.9', '5', '1.7', '3']
package org . apache . xml . utils . res ; public class XResources_zh_TW extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "zh" } , { "help_language" , "zh" } , { "language" , "zh" } , { "alphabet" , new char [ ] { 0xff21 , 0xff22 , 0xff23 , 0xff24 , 0xff25 , 0xff26 , 0xff27 , 0xff28 , 0xff29 , 0xff2a , 0xff2b , 0xff2c , 0xff2d , 0xff2e , 0xff2f , 0xff30 , 0xff31 , 0xff32 , 0xff33 , 0xff34 , 0xff35 , 0xff36 , 0xff37 , 0xff38 , 0xff39 , 0xff3a } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "zero" , new char [ ] { 0x96f6 } } , { "multiplier" , new long [ ] { 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x5104 , 0x842c , 0x4edf , 0x4f70 , 0x62fe } } , { "digits" , new char [ ] { 0x58f9 , 0x8cb3 , 0x53c3 , 0x8086 , 0x4f0d , 0x9678 , 0x67d2 , 0x634c , 0x7396 } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '499', '0', '0', '0.976190476', '1', '0', '0', '165', '1', '0.3333', '1']
package org . apache . xalan . processor ; import java . util . Vector ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemExtensionCall ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xalan . templates . XMLNSDecl ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xpath . XPath ; import org . xml . sax . Attributes ; import org . xml . sax . Locator ; import org . xml . sax . helpers . AttributesImpl ; public class ProcessorLRE extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { try { ElemTemplateElement p = handler . getElemTemplateElement ( ) ; boolean excludeXSLDecl = false ; boolean isLREAsStyleSheet = false ; if ( null == p ) { XSLTElementProcessor lreProcessor = handler . popProcessor ( ) ; XSLTElementProcessor stylesheetProcessor = handler . getProcessorFor ( Constants . S_XSLNAMESPACEURL , "stylesheet" , "xsl:stylesheet" ) ; handler . pushProcessor ( lreProcessor ) ; Stylesheet stylesheet ; try { stylesheet = new StylesheetRoot ( handler . getSchema ( ) , handler . getStylesheetProcessor ( ) . getErrorListener ( ) ) ; } catch ( TransformerConfigurationException tfe ) { throw new TransformerException ( tfe ) ; } SAXSourceLocator slocator = new SAXSourceLocator ( ) ; Locator locator = handler . getLocator ( ) ; if ( null != locator ) { slocator . setLineNumber ( locator . getLineNumber ( ) ) ; slocator . setColumnNumber ( locator . getColumnNumber ( ) ) ; slocator . setPublicId ( locator . getPublicId ( ) ) ; slocator . setSystemId ( locator . getSystemId ( ) ) ; } stylesheet . setLocaterInfo ( slocator ) ; stylesheet . setPrefixes ( handler . getNamespaceSupport ( ) ) ; handler . pushStylesheet ( stylesheet ) ; isLREAsStyleSheet = true ; AttributesImpl stylesheetAttrs = new AttributesImpl ( ) ; AttributesImpl lreAttrs = new AttributesImpl ( ) ; int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String attrLocalName = attributes . getLocalName ( i ) ; String attrUri = attributes . getURI ( i ) ; String value = attributes . getValue ( i ) ; if ( ( null != attrUri ) && attrUri . equals ( Constants . S_XSLNAMESPACEURL ) ) { stylesheetAttrs . addAttribute ( null , attrLocalName , attrLocalName , attributes . getType ( i ) , attributes . getValue ( i ) ) ; } else if ( ( attrLocalName . startsWith ( "xmlns:" ) || attrLocalName . equals ( "xmlns" ) ) && value . equals ( Constants . S_XSLNAMESPACEURL ) ) { } else { lreAttrs . addAttribute ( attrUri , attrLocalName , attributes . getQName ( i ) , attributes . getType ( i ) , attributes . getValue ( i ) ) ; } } attributes = lreAttrs ; try { stylesheetProcessor . setPropertiesFromAttributes ( handler , "stylesheet" , stylesheetAttrs , stylesheet ) ; } catch ( Exception e ) { if ( stylesheet . getDeclaredPrefixes ( ) == null || ! declaredXSLNS ( stylesheet ) ) { throw new org . xml . sax . SAXException ( XSLMessages . createWarning ( XSLTErrorResources . WG_OLD_XSLT_NS , null ) ) ; } else { throw new org . xml . sax . SAXException ( e ) ; } } handler . pushElemTemplateElement ( stylesheet ) ; ElemTemplate template = new ElemTemplate ( ) ; appendAndPush ( handler , template ) ; XPath rootMatch = new XPath ( "/" , stylesheet , stylesheet , XPath . MATCH , handler . getStylesheetProcessor ( ) . getErrorListener ( ) ) ; template . setMatch ( rootMatch ) ; stylesheet . setTemplate ( template ) ; p = handler . getElemTemplateElement ( ) ; excludeXSLDecl = true ; } XSLTElementDef def = getElemDef ( ) ; Class classObject = def . getClassObject ( ) ; boolean isExtension = false ; boolean isComponentDecl = false ; boolean isUnknownTopLevel = false ; while ( null != p ) { if ( p instanceof ElemLiteralResult ) { ElemLiteralResult parentElem = ( ElemLiteralResult ) p ; isExtension = parentElem . containsExtensionElementURI ( uri ) ; } else if ( p instanceof Stylesheet ) { Stylesheet parentElem = ( Stylesheet ) p ; isExtension = parentElem . containsExtensionElementURI ( uri ) ; if ( ( false == isExtension ) && ( null != uri ) && ( uri . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) || uri . equals ( Constants . S_BUILTIN_OLD_EXTENSIONS_URL ) ) ) { isComponentDecl = true ; } else { isUnknownTopLevel = true ; } } if ( isExtension ) break ; p = p . getParentElem ( ) ; } ElemTemplateElement elem = null ; try { if ( isExtension ) { elem = new ElemExtensionCall ( ) ; } else if ( isComponentDecl ) { elem = ( ElemTemplateElement ) classObject . newInstance ( ) ; } else if ( isUnknownTopLevel ) { elem = ( ElemTemplateElement ) classObject . newInstance ( ) ; } else { elem = ( ElemTemplateElement ) classObject . newInstance ( ) ; } elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; elem . setLocaterInfo ( handler . getLocator ( ) ) ; elem . setPrefixes ( handler . getNamespaceSupport ( ) , excludeXSLDecl ) ; if ( elem instanceof ElemLiteralResult ) { ( ( ElemLiteralResult ) elem ) . setNamespace ( uri ) ; ( ( ElemLiteralResult ) elem ) . setLocalName ( localName ) ; ( ( ElemLiteralResult ) elem ) . setRawName ( rawName ) ; ( ( ElemLiteralResult ) elem ) . setIsLiteralResultAsStylesheet ( isLREAsStyleSheet ) ; } } catch ( InstantiationException ie ) { handler . error ( XSLTErrorResources . ER_FAILED_CREATING_ELEMLITRSLT , null , ie ) ; } catch ( IllegalAccessException iae ) { handler . error ( XSLTErrorResources . ER_FAILED_CREATING_ELEMLITRSLT , null , iae ) ; } setPropertiesFromAttributes ( handler , rawName , attributes , elem ) ; if ( ! isExtension && ( elem instanceof ElemLiteralResult ) ) { isExtension = ( ( ElemLiteralResult ) elem ) . containsExtensionElementURI ( uri ) ; if ( isExtension ) { elem = new ElemExtensionCall ( ) ; elem . setLocaterInfo ( handler . getLocator ( ) ) ; elem . setPrefixes ( handler . getNamespaceSupport ( ) ) ; ( ( ElemLiteralResult ) elem ) . setNamespace ( uri ) ; ( ( ElemLiteralResult ) elem ) . setLocalName ( localName ) ; ( ( ElemLiteralResult ) elem ) . setRawName ( rawName ) ; setPropertiesFromAttributes ( handler , rawName , attributes , elem ) ; } } appendAndPush ( handler , elem ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { ElemTemplateElement elem = handler . getElemTemplateElement ( ) ; if ( elem instanceof ElemLiteralResult ) { if ( ( ( ElemLiteralResult ) elem ) . getIsLiteralResultAsStylesheet ( ) ) { handler . popStylesheet ( ) ; } } super . endElement ( handler , uri , localName , rawName ) ; } private boolean declaredXSLNS ( Stylesheet stylesheet ) { Vector declaredPrefixes = stylesheet . getDeclaredPrefixes ( ) ; int n = declaredPrefixes . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) declaredPrefixes . elementAt ( i ) ; if ( decl . getURI ( ) . equals ( Constants . S_XSLNAMESPACEURL ) ) return true ; } return false ; } } 	1	['4', '5', '1', '18', '73', '6', '2', '17', '3', '2', '462', '0', '0', '0.986111111', '0.5', '4', '6', '114.5', '3', '1.25', '3']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XNodeSet ; public class FilterExprIterator extends BasicTestIterator { private Expression m_expr ; transient private XNodeSet m_exprObj ; private boolean m_mustHardReset = false ; private boolean m_canDetachNodeset = true ; public FilterExprIterator ( ) { super ( null ) ; } public FilterExprIterator ( Expression expr ) { super ( null ) ; m_expr = expr ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_exprObj = FilterExprIteratorSimple . executeFilterExpr ( context , m_execContext , getPrefixResolver ( ) , getIsTopLevel ( ) , m_stackFrame , m_expr ) ; } protected int getNextNode ( ) { if ( null != m_exprObj ) { m_lastFetched = m_exprObj . nextNode ( ) ; } else m_lastFetched = DTM . NULL ; return m_lastFetched ; } public void detach ( ) { super . detach ( ) ; m_exprObj . detach ( ) ; m_exprObj = null ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; m_expr . fixupVariables ( vars , globalsSize ) ; } public Expression getInnerExpression ( ) { return m_expr ; } public void setInnerExpression ( Expression expr ) { expr . exprSetParent ( this ) ; m_expr = expr ; } public int getAnalysisBits ( ) { if ( null != m_expr && m_expr instanceof PathComponent ) { return ( ( PathComponent ) m_expr ) . getAnalysisBits ( ) ; } return WalkerFactory . BIT_FILTER ; } public boolean isDocOrdered ( ) { return m_exprObj . isDocOrdered ( ) ; } class filterExprOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_expr ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FilterExprIterator . this ) ; m_expr = exp ; } } public void callPredicateVisitors ( XPathVisitor visitor ) { m_expr . callVisitors ( new filterExprOwner ( ) , visitor ) ; super . callPredicateVisitors ( visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; FilterExprIterator fet = ( FilterExprIterator ) expr ; if ( ! m_expr . deepEquals ( fet . m_expr ) ) return false ; return true ; } } 	1	['14', '6', '0', '11', '32', '0', '1', '11', '11', '0.730769231', '163', '1', '2', '0.914285714', '0.234693878', '4', '8', '10.35714286', '3', '1.2143', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import org . apache . xml . res . XMLMessages ; public class XPATHMessages extends XMLMessages { private static ListResourceBundle XPATHBundle = null ; private static final String XPATH_ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String createXPATHMessage ( String msgKey , Object args [ ] ) { if ( XPATHBundle == null ) XPATHBundle = loadResourceBundle ( XPATH_ERROR_RESOURCES ) ; if ( XPATHBundle != null ) { return createXPATHMsg ( XPATHBundle , msgKey , args ) ; } else return "Could not load any resource bundles." ; } public static final String createXPATHWarning ( String msgKey , Object args [ ] ) { if ( XPATHBundle == null ) XPATHBundle = loadResourceBundle ( XPATH_ERROR_RESOURCES ) ; if ( XPATHBundle != null ) { return createXPATHMsg ( XPATHBundle , msgKey , args ) ; } else return "Could not load any resource bundles." ; } public static final String createXPATHMsg ( ListResourceBundle fResourceBundle , String msgKey , Object args [ ] ) { String fmsg = null ; boolean throwex = false ; String msg = null ; if ( msgKey != null ) msg = fResourceBundle . getString ( msgKey ) ; if ( msg == null ) { msg = fResourceBundle . getString ( XPATHErrorResources . BAD_CODE ) ; throwex = true ; } if ( args != null ) { try { int n = args . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( null == args [ i ] ) args [ i ] = "" ; } fmsg = java . text . MessageFormat . format ( msg , args ) ; } catch ( Exception e ) { fmsg = fResourceBundle . getString ( XPATHErrorResources . FORMAT_FAILED ) ; fmsg += " " + msg ; } } else fmsg = msg ; if ( throwex ) { throw new RuntimeException ( fmsg ) ; } return fmsg ; } } 	1	['5', '2', '1', '2', '13', '4', '1', '1', '4', '0.875', '115', '1', '0', '0.666666667', '0.5', '0', '0', '21.6', '7', '2.6', '1']
package org . apache . xalan . templates ; import java . io . Serializable ; import java . util . Enumeration ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . UnImplNode ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . WhitespaceStrippingElementMatcher ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . helpers . NamespaceSupport ; public class ElemTemplateElement extends UnImplNode implements PrefixResolver , Serializable , ExpressionNode , WhitespaceStrippingElementMatcher , XSLTVisitable { public ElemTemplateElement ( ) { } public boolean isCompiledTemplate ( ) { return false ; } public int getXSLToken ( ) { return Constants . ELEMNAME_UNDEFINED ; } public String getNodeName ( ) { return "Unknown XSLT Element" ; } public String getLocalName ( ) { return getNodeName ( ) ; } public void runtimeInit ( TransformerImpl transformer ) throws TransformerException { } public void execute ( TransformerImpl transformer ) throws TransformerException { } public StylesheetComposed getStylesheetComposed ( ) { return m_parentNode . getStylesheetComposed ( ) ; } public Stylesheet getStylesheet ( ) { return ( null == m_parentNode ) ? null : m_parentNode . getStylesheet ( ) ; } public StylesheetRoot getStylesheetRoot ( ) { return m_parentNode . getStylesheetRoot ( ) ; } public void recompose ( StylesheetRoot root ) throws TransformerException { } public void compose ( StylesheetRoot sroot ) throws TransformerException { resolvePrefixTables ( ) ; ElemTemplateElement t = getFirstChildElem ( ) ; m_hasTextLitOnly = ( ( t != null ) && ( t . getXSLToken ( ) == Constants . ELEMNAME_TEXTLITERALRESULT ) && ( t . getNextSiblingElem ( ) == null ) ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; cstate . pushStackMark ( ) ; } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; cstate . popStackMark ( ) ; } public void error ( String msg , Object [ ] args ) { String themsg = XSLMessages . createMessage ( msg , args ) ; throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ELEMTEMPLATEELEM_ERR , new Object [ ] { themsg } ) ) ; } public void error ( String msg ) { error ( msg , null ) ; } public Node appendChild ( Node newChild ) throws DOMException { if ( null == newChild ) { error ( XSLTErrorResources . ER_NULL_CHILD , null ) ; } ElemTemplateElement elem = ( ElemTemplateElement ) newChild ; if ( null == m_firstChild ) { m_firstChild = elem ; } else { ElemTemplateElement last = ( ElemTemplateElement ) getLastChild ( ) ; last . m_nextSibling = elem ; } elem . m_parentNode = this ; return newChild ; } public ElemTemplateElement appendChild ( ElemTemplateElement elem ) { if ( null == elem ) { error ( XSLTErrorResources . ER_NULL_CHILD , null ) ; } if ( null == m_firstChild ) { m_firstChild = elem ; } else { ElemTemplateElement last = getLastChildElem ( ) ; last . m_nextSibling = elem ; } elem . setParentElem ( this ) ; return elem ; } public boolean hasChildNodes ( ) { return ( null != m_firstChild ) ; } public short getNodeType ( ) { return org . w3c . dom . Node . ELEMENT_NODE ; } public NodeList getChildNodes ( ) { return this ; } public ElemTemplateElement removeChild ( ElemTemplateElement childETE ) { if ( childETE == null || childETE . m_parentNode != this ) return null ; if ( childETE == m_firstChild ) m_firstChild = childETE . m_nextSibling ; else { ElemTemplateElement prev = childETE . getPreviousSiblingElem ( ) ; prev . m_nextSibling = childETE . m_nextSibling ; } childETE . m_parentNode = null ; childETE . m_nextSibling = null ; return childETE ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { if ( oldChild == null || oldChild . getParentNode ( ) != this ) return null ; ElemTemplateElement newChildElem = ( ( ElemTemplateElement ) newChild ) ; ElemTemplateElement oldChildElem = ( ( ElemTemplateElement ) oldChild ) ; ElemTemplateElement prev = ( ElemTemplateElement ) oldChildElem . getPreviousSibling ( ) ; if ( null != prev ) prev . m_nextSibling = newChildElem ; if ( m_firstChild == oldChildElem ) m_firstChild = newChildElem ; newChildElem . m_parentNode = this ; oldChildElem . m_parentNode = null ; newChildElem . m_nextSibling = oldChildElem . m_nextSibling ; oldChildElem . m_nextSibling = null ; return newChildElem ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { if ( null == refChild ) { appendChild ( newChild ) ; return newChild ; } if ( newChild == refChild ) { return newChild ; } Node node = m_firstChild ; Node prev = null ; boolean foundit = false ; while ( null != node ) { if ( newChild == node ) { if ( null != prev ) ( ( ElemTemplateElement ) prev ) . m_nextSibling = ( ElemTemplateElement ) node . getNextSibling ( ) ; else m_firstChild = ( ElemTemplateElement ) node . getNextSibling ( ) ; node = node . getNextSibling ( ) ; continue ; } if ( refChild == node ) { if ( null != prev ) { ( ( ElemTemplateElement ) prev ) . m_nextSibling = ( ElemTemplateElement ) newChild ; } else { m_firstChild = ( ElemTemplateElement ) newChild ; } ( ( ElemTemplateElement ) newChild ) . m_nextSibling = ( ElemTemplateElement ) refChild ; ( ( ElemTemplateElement ) newChild ) . setParentElem ( this ) ; prev = newChild ; node = node . getNextSibling ( ) ; foundit = true ; continue ; } prev = node ; node = node . getNextSibling ( ) ; } if ( ! foundit ) throw new DOMException ( DOMException . NOT_FOUND_ERR , "refChild was not found in insertBefore method!" ) ; else return newChild ; } public ElemTemplateElement replaceChild ( ElemTemplateElement newChildElem , ElemTemplateElement oldChildElem ) { if ( oldChildElem == null || oldChildElem . getParentElem ( ) != this ) return null ; ElemTemplateElement prev = oldChildElem . getPreviousSiblingElem ( ) ; if ( null != prev ) prev . m_nextSibling = newChildElem ; if ( m_firstChild == oldChildElem ) m_firstChild = newChildElem ; newChildElem . m_parentNode = this ; oldChildElem . m_parentNode = null ; newChildElem . m_nextSibling = oldChildElem . m_nextSibling ; oldChildElem . m_nextSibling = null ; return newChildElem ; } public int getLength ( ) { int count = 0 ; for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { count ++ ; } return count ; } public Node item ( int index ) { ElemTemplateElement node = m_firstChild ; for ( int i = 0 ; i < index && node != null ; i ++ ) { node = node . m_nextSibling ; } return node ; } public Document getOwnerDocument ( ) { return getStylesheet ( ) ; } public ElemTemplate getOwnerXSLTemplate ( ) { ElemTemplateElement el = this ; int type = el . getXSLToken ( ) ; while ( ( null != el ) && ( type != Constants . ELEMNAME_TEMPLATE ) ) { el = el . getParentElem ( ) ; if ( null != el ) type = el . getXSLToken ( ) ; } return ( ElemTemplate ) el ; } public String getTagName ( ) { return getNodeName ( ) ; } public boolean hasTextLitOnly ( ) { return m_hasTextLitOnly ; } public String getBaseIdentifier ( ) { return this . getSystemId ( ) ; } private int m_lineNumber ; private int m_endLineNumber ; public int getEndLineNumber ( ) { return m_endLineNumber ; } public int getLineNumber ( ) { return m_lineNumber ; } private int m_columnNumber ; private int m_endColumnNumber ; public int getEndColumnNumber ( ) { return m_endColumnNumber ; } public int getColumnNumber ( ) { return m_columnNumber ; } public String getPublicId ( ) { return ( null != m_parentNode ) ? m_parentNode . getPublicId ( ) : null ; } public String getSystemId ( ) { Stylesheet sheet = getStylesheet ( ) ; return ( sheet == null ) ? null : sheet . getHref ( ) ; } public void setLocaterInfo ( SourceLocator locator ) { m_lineNumber = locator . getLineNumber ( ) ; m_columnNumber = locator . getColumnNumber ( ) ; } public void setEndLocaterInfo ( SourceLocator locator ) { m_endLineNumber = locator . getLineNumber ( ) ; m_endColumnNumber = locator . getColumnNumber ( ) ; } private boolean m_defaultSpace = true ; private boolean m_hasTextLitOnly = false ; protected boolean m_hasVariableDecl = false ; public boolean hasVariableDecl ( ) { return m_hasVariableDecl ; } public void setXmlSpace ( int v ) { m_defaultSpace = ( ( Constants . ATTRVAL_STRIP == v ) ? true : false ) ; } public boolean getXmlSpace ( ) { return m_defaultSpace ; } private Vector m_declaredPrefixes ; public Vector getDeclaredPrefixes ( ) { return m_declaredPrefixes ; } public void setPrefixes ( NamespaceSupport nsSupport ) throws TransformerException { setPrefixes ( nsSupport , false ) ; } public void setPrefixes ( NamespaceSupport nsSupport , boolean excludeXSLDecl ) throws TransformerException { Enumeration decls = nsSupport . getDeclaredPrefixes ( ) ; while ( decls . hasMoreElements ( ) ) { String prefix = ( String ) decls . nextElement ( ) ; if ( null == m_declaredPrefixes ) m_declaredPrefixes = new Vector ( ) ; String uri = nsSupport . getURI ( prefix ) ; if ( excludeXSLDecl && uri . equals ( Constants . S_XSLNAMESPACEURL ) ) continue ; XMLNSDecl decl = new XMLNSDecl ( prefix , uri , false ) ; m_declaredPrefixes . addElement ( decl ) ; } } public String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node context ) { this . error ( XSLTErrorResources . ER_CANT_RESOLVE_NSPREFIX , null ) ; return null ; } public String getNamespaceForPrefix ( String prefix ) { Vector nsDecls = m_declaredPrefixes ; if ( null != nsDecls ) { int n = nsDecls . size ( ) ; if ( prefix . equals ( Constants . ATTRVAL_DEFAULT_PREFIX ) ) { prefix = "" ; } for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) nsDecls . elementAt ( i ) ; if ( prefix . equals ( decl . getPrefix ( ) ) ) return decl . getURI ( ) ; } } if ( null != m_parentNode ) return m_parentNode . getNamespaceForPrefix ( prefix ) ; if ( "xml" . equals ( prefix ) ) return "http://www.w3.org/XML/1998/namespace" ; return null ; } Vector m_prefixTable ; public Vector getPrefixes ( ) { return m_prefixTable ; } public boolean containsExcludeResultPrefix ( String prefix , String uri ) { ElemTemplateElement parent = this . getParentElem ( ) ; if ( null != parent ) return parent . containsExcludeResultPrefix ( prefix , uri ) ; return false ; } private boolean excludeResultNSDecl ( String prefix , String uri ) throws TransformerException { if ( uri != null ) { if ( uri . equals ( Constants . S_XSLNAMESPACEURL ) || getStylesheet ( ) . containsExtensionElementURI ( uri ) ) return true ; if ( containsExcludeResultPrefix ( prefix , uri ) ) return true ; } return false ; } public void resolvePrefixTables ( ) throws TransformerException { m_prefixTable = null ; if ( null != this . m_declaredPrefixes ) { StylesheetRoot stylesheet = this . getStylesheetRoot ( ) ; int n = m_declaredPrefixes . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) m_declaredPrefixes . elementAt ( i ) ; String prefix = decl . getPrefix ( ) ; String uri = decl . getURI ( ) ; if ( null == uri ) uri = "" ; boolean shouldExclude = excludeResultNSDecl ( prefix , uri ) ; if ( null == m_prefixTable ) m_prefixTable = new Vector ( ) ; NamespaceAlias nsAlias = stylesheet . getNamespaceAliasComposed ( uri ) ; if ( null != nsAlias ) { decl = new XMLNSDecl ( nsAlias . getStylesheetPrefix ( ) , nsAlias . getResultNamespace ( ) , shouldExclude ) ; } else decl = new XMLNSDecl ( prefix , uri , shouldExclude ) ; m_prefixTable . addElement ( decl ) ; } } ElemTemplateElement parent = this . getParentNodeElem ( ) ; if ( null != parent ) { Vector prefixes = parent . m_prefixTable ; if ( null == m_prefixTable && ! needToCheckExclude ( ) ) { this . m_prefixTable = parent . m_prefixTable ; } else { int n = prefixes . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) prefixes . elementAt ( i ) ; boolean shouldExclude = excludeResultNSDecl ( decl . getPrefix ( ) , decl . getURI ( ) ) ; if ( shouldExclude != decl . getIsExcluded ( ) ) { decl = new XMLNSDecl ( decl . getPrefix ( ) , decl . getURI ( ) , shouldExclude ) ; } addOrReplaceDecls ( decl ) ; } } } else if ( null == m_prefixTable ) { m_prefixTable = new Vector ( ) ; } } void addOrReplaceDecls ( XMLNSDecl newDecl ) { int n = m_prefixTable . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { XMLNSDecl decl = ( XMLNSDecl ) m_prefixTable . elementAt ( i ) ; if ( decl . getPrefix ( ) . equals ( newDecl . getPrefix ( ) ) ) { return ; } } m_prefixTable . addElement ( newDecl ) ; } boolean needToCheckExclude ( ) { return false ; } void executeNSDecls ( TransformerImpl transformer ) throws TransformerException { executeNSDecls ( transformer , null ) ; } void executeNSDecls ( TransformerImpl transformer , String ignorePrefix ) throws TransformerException { try { if ( null != m_prefixTable ) { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; int n = m_prefixTable . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { XMLNSDecl decl = ( XMLNSDecl ) m_prefixTable . elementAt ( i ) ; if ( ! decl . getIsExcluded ( ) && ! ( null != ignorePrefix && decl . getPrefix ( ) . equals ( ignorePrefix ) ) ) { rhandler . startPrefixMapping ( decl . getPrefix ( ) , decl . getURI ( ) , true ) ; } } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } void unexecuteNSDecls ( TransformerImpl transformer ) throws TransformerException { unexecuteNSDecls ( transformer , null ) ; } void unexecuteNSDecls ( TransformerImpl transformer , String ignorePrefix ) throws TransformerException { try { if ( null != m_prefixTable ) { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; int n = m_prefixTable . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) m_prefixTable . elementAt ( i ) ; if ( ! decl . getIsExcluded ( ) && ! ( null != ignorePrefix && decl . getPrefix ( ) . equals ( ignorePrefix ) ) ) { rhandler . endPrefixMapping ( decl . getPrefix ( ) ) ; } } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } protected int m_docOrderNumber = - 1 ; public void setUid ( int i ) { m_docOrderNumber = i ; } public int getUid ( ) { return m_docOrderNumber ; } protected ElemTemplateElement m_parentNode ; public Node getParentNode ( ) { return m_parentNode ; } public ElemTemplateElement getParentElem ( ) { return m_parentNode ; } public void setParentElem ( ElemTemplateElement p ) { m_parentNode = p ; } ElemTemplateElement m_nextSibling ; public Node getNextSibling ( ) { return m_nextSibling ; } public Node getPreviousSibling ( ) { Node walker = getParentNode ( ) , prev = null ; if ( walker != null ) for ( walker = walker . getFirstChild ( ) ; walker != null ; prev = walker , walker = walker . getNextSibling ( ) ) { if ( walker == this ) return prev ; } return null ; } public ElemTemplateElement getPreviousSiblingElem ( ) { ElemTemplateElement walker = getParentNodeElem ( ) ; ElemTemplateElement prev = null ; if ( walker != null ) for ( walker = walker . getFirstChildElem ( ) ; walker != null ; prev = walker , walker = walker . getNextSiblingElem ( ) ) { if ( walker == this ) return prev ; } return null ; } public ElemTemplateElement getNextSiblingElem ( ) { return m_nextSibling ; } public ElemTemplateElement getParentNodeElem ( ) { return m_parentNode ; } ElemTemplateElement m_firstChild ; public Node getFirstChild ( ) { return m_firstChild ; } public ElemTemplateElement getFirstChildElem ( ) { return m_firstChild ; } public Node getLastChild ( ) { ElemTemplateElement lastChild = null ; for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { lastChild = node ; } return lastChild ; } public ElemTemplateElement getLastChildElem ( ) { ElemTemplateElement lastChild = null ; for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { lastChild = node ; } return lastChild ; } transient private org . w3c . dom . Node m_DOMBackPointer ; public org . w3c . dom . Node getDOMBackPointer ( ) { return m_DOMBackPointer ; } public void setDOMBackPointer ( org . w3c . dom . Node n ) { m_DOMBackPointer = n ; } public int compareTo ( Object o ) throws ClassCastException { ElemTemplateElement ro = ( ElemTemplateElement ) o ; int roPrecedence = ro . getStylesheetComposed ( ) . getImportCountComposed ( ) ; int myPrecedence = this . getStylesheetComposed ( ) . getImportCountComposed ( ) ; if ( myPrecedence < roPrecedence ) return - 1 ; else if ( myPrecedence > roPrecedence ) return 1 ; else return this . getUid ( ) - ro . getUid ( ) ; } public boolean shouldStripWhiteSpace ( org . apache . xpath . XPathContext support , org . w3c . dom . Element targetElement ) throws TransformerException { StylesheetRoot sroot = this . getStylesheetRoot ( ) ; return ( null != sroot ) ? sroot . shouldStripWhiteSpace ( support , targetElement ) : false ; } public boolean canStripWhiteSpace ( ) { StylesheetRoot sroot = this . getStylesheetRoot ( ) ; return ( null != sroot ) ? sroot . canStripWhiteSpace ( ) : false ; } public boolean canAcceptVariables ( ) { return true ; } public void exprSetParent ( ExpressionNode n ) { setParentElem ( ( ElemTemplateElement ) n ) ; } public ExpressionNode exprGetParent ( ) { return getParentElem ( ) ; } public void exprAddChild ( ExpressionNode n , int i ) { appendChild ( ( ElemTemplateElement ) n ) ; } public ExpressionNode exprGetChild ( int i ) { return ( ExpressionNode ) item ( i ) ; } public int exprGetNumChildren ( ) { return getLength ( ) ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitInstruction ( this ) ; } public void callVisitors ( XSLTVisitor visitor ) { if ( accept ( visitor ) ) { callChildVisitors ( visitor ) ; } } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttributes ) { for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { node . callVisitors ( visitor ) ; } } protected void callChildVisitors ( XSLTVisitor visitor ) { callChildVisitors ( visitor , true ) ; } public boolean handlesNullPrefixes ( ) { return false ; } } 	1	['87', '2', '29', '95', '125', '3307', '84', '17', '77', '0.925249169', '1274', '0.785714286', '3', '0.558974359', '0.09127789', '1', '12', '13.48275862', '7', '1.4483', '1']
package org . apache . xpath ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; import org . xml . sax . ContentHandler ; public abstract class Expression implements java . io . Serializable , ExpressionNode , XPathVisitable { private ExpressionNode m_parent ; public boolean canTraverseOutsideSubtree ( ) { return false ; } public XObject execute ( XPathContext xctxt , int currentNode ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) ; } public XObject execute ( XPathContext xctxt , int currentNode , DTM dtm , int expType ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) ; } public abstract XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException ; public XObject execute ( XPathContext xctxt , boolean destructiveOK ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) . num ( ) ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) . bool ( ) ; } public XMLString xstr ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt ) . xstr ( ) ; } public boolean isNodesetExpr ( ) { return false ; } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { DTMIterator iter = execute ( xctxt ) . iter ( ) ; return iter . nextNode ( ) ; } public DTMIterator asIterator ( XPathContext xctxt , int contextNode ) throws javax . xml . transform . TransformerException { try { xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; return execute ( xctxt ) . iter ( ) ; } finally { xctxt . popCurrentNodeAndExpression ( ) ; } } public DTMIterator asIteratorRaw ( XPathContext xctxt , int contextNode ) throws javax . xml . transform . TransformerException { try { xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; XNodeSet nodeset = ( XNodeSet ) execute ( xctxt ) ; return nodeset . iterRaw ( ) ; } finally { xctxt . popCurrentNodeAndExpression ( ) ; } } public void executeCharsToContentHandler ( XPathContext xctxt , ContentHandler handler ) throws javax . xml . transform . TransformerException , org . xml . sax . SAXException { XObject obj = execute ( xctxt ) ; obj . dispatchCharactersEvents ( handler ) ; obj . detach ( ) ; } public boolean isStableNumber ( ) { return false ; } public abstract void fixupVariables ( java . util . Vector vars , int globalsSize ) ; public abstract boolean deepEquals ( Expression expr ) ; protected final boolean isSameClass ( Expression expr ) { if ( null == expr ) return false ; return ( getClass ( ) == expr . getClass ( ) ) ; } public void warn ( XPathContext xctxt , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; if ( null != xctxt ) { ErrorListener eh = xctxt . getErrorListener ( ) ; eh . warning ( new TransformerException ( fmsg , xctxt . getSAXLocator ( ) ) ) ; } } public void assertion ( boolean b , java . lang . String msg ) { if ( ! b ) { java . lang . String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } public void error ( XPathContext xctxt , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; if ( null != xctxt ) { ErrorListener eh = xctxt . getErrorListener ( ) ; TransformerException te = new TransformerException ( fmsg , this ) ; eh . fatalError ( te ) ; } } public ExpressionNode getExpressionOwner ( ) { ExpressionNode parent = exprGetParent ( ) ; while ( ( null != parent ) && ( parent instanceof Expression ) ) parent = parent . exprGetParent ( ) ; return parent ; } public void exprSetParent ( ExpressionNode n ) { assertion ( n != this , "Can not parent an expression to itself!" ) ; m_parent = n ; } public ExpressionNode exprGetParent ( ) { return m_parent ; } public void exprAddChild ( ExpressionNode n , int i ) { assertion ( false , "exprAddChild method not implemented!" ) ; } public ExpressionNode exprGetChild ( int i ) { return null ; } public int exprGetNumChildren ( ) { return 0 ; } public String getPublicId ( ) { if ( null == m_parent ) return null ; return m_parent . getPublicId ( ) ; } public String getSystemId ( ) { if ( null == m_parent ) return null ; return m_parent . getSystemId ( ) ; } public int getLineNumber ( ) { if ( null == m_parent ) return 0 ; return m_parent . getLineNumber ( ) ; } public int getColumnNumber ( ) { if ( null == m_parent ) return 0 ; return m_parent . getColumnNumber ( ) ; } } 	1	['31', '1', '6', '104', '56', '435', '96', '9', '30', '0.8', '275', '1', '1', '0', '0.190615836', '0', '0', '7.838709677', '3', '1.2903', '1']
package org . w3c . dom . xpath ; public interface XPathNSResolver { public String lookupNamespaceURI ( String prefix ) ; } 	1	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . xalan . client ; import java . applet . Applet ; import java . awt . Graphics ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringReader ; import java . io . StringWriter ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Hashtable ; import java . util . Enumeration ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; public class XSLTProcessorApplet extends Applet { TransformerFactory m_tfactory = null ; private String m_styleURL ; private String m_documentURL ; private final String PARAM_styleURL = "styleURL" ; private final String PARAM_documentURL = "documentURL" ; private String m_styleURLOfCached = null ; private String m_documentURLOfCached = null ; private URL m_codeBase = null ; private String m_treeURL = null ; private URL m_documentBase = null ; transient private Thread m_callThread = null ; transient private TrustedAgent m_trustedAgent = null ; transient private Thread m_trustedWorker = null ; transient private String m_htmlText = null ; transient private String m_sourceText = null ; transient private String m_nameOfIDAttrOfElemToModify = null ; transient private String m_elemIdToModify = null ; transient private String m_attrNameToSet = null ; transient private String m_attrValueToSet = null ; public XSLTProcessorApplet ( ) { } public String getAppletInfo ( ) { return "Name: XSLTProcessorApplet\r\n" + "Author: Scott Boag" ; } public String [ ] [ ] getParameterInfo ( ) { String [ ] [ ] info = { { PARAM_styleURL , "String" , "URL to an XSL stylesheet" } , { PARAM_documentURL , "String" , "URL to an XML document" } , } ; return info ; } public void init ( ) { String param ; param = getParameter ( PARAM_styleURL ) ; m_parameters = new Hashtable ( ) ; if ( param != null ) setStyleURL ( param ) ; param = getParameter ( PARAM_documentURL ) ; if ( param != null ) setDocumentURL ( param ) ; m_codeBase = this . getCodeBase ( ) ; m_documentBase = this . getDocumentBase ( ) ; resize ( 320 , 240 ) ; } public void start ( ) { m_trustedAgent = new TrustedAgent ( ) ; Thread currentThread = Thread . currentThread ( ) ; m_trustedWorker = new Thread ( currentThread . getThreadGroup ( ) , m_trustedAgent ) ; m_trustedWorker . start ( ) ; try { m_tfactory = TransformerFactory . newInstance ( ) ; this . showStatus ( "Causing Transformer and Parser to Load and JIT..." ) ; StringReader xmlbuf = new StringReader ( "<?xml version='1.0'?><foo/>" ) ; StringReader xslbuf = new StringReader ( "<?xml version='1.0'?><xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'><xsl:template match='foo'><out/></xsl:template></xsl:stylesheet>" ) ; PrintWriter pw = new PrintWriter ( new StringWriter ( ) ) ; synchronized ( m_tfactory ) { Templates templates = m_tfactory . newTemplates ( new StreamSource ( xslbuf ) ) ; Transformer transformer = templates . newTransformer ( ) ; transformer . transform ( new StreamSource ( xmlbuf ) , new StreamResult ( pw ) ) ; } System . out . println ( "Primed the pump!" ) ; this . showStatus ( "Ready to go!" ) ; } catch ( Exception e ) { this . showStatus ( "Could not prime the pump!" ) ; System . out . println ( "Could not prime the pump!" ) ; e . printStackTrace ( ) ; } } public void paint ( Graphics g ) { } public void stop ( ) { if ( null != m_trustedWorker ) { m_trustedWorker . stop ( ) ; m_trustedWorker = null ; } m_styleURLOfCached = null ; m_documentURLOfCached = null ; } public void destroy ( ) { if ( null != m_trustedWorker ) { m_trustedWorker . stop ( ) ; m_trustedWorker = null ; } m_styleURLOfCached = null ; m_documentURLOfCached = null ; } public void setStyleURL ( String urlString ) { m_styleURL = urlString ; } public void setDocumentURL ( String urlString ) { m_documentURL = urlString ; } public void freeCache ( ) { m_styleURLOfCached = null ; m_documentURLOfCached = null ; } public void setStyleSheetAttribute ( String nameOfIDAttrOfElemToModify , String elemId , String attrName , String value ) { m_nameOfIDAttrOfElemToModify = nameOfIDAttrOfElemToModify ; m_elemIdToModify = elemId ; m_attrNameToSet = attrName ; m_attrValueToSet = value ; } private Enumeration m_keys ; transient Hashtable m_parameters ; public void setStylesheetParam ( String key , String expr ) { m_parameters . put ( key , expr ) ; } public String escapeString ( String s ) { StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char ch = s . charAt ( i ) ; if ( '<' == ch ) { sb . append ( "&lt;" ) ; } else if ( '>' == ch ) { sb . append ( "&gt;" ) ; } else if ( '&' == ch ) { sb . append ( "&amp;" ) ; } else if ( 0xd800 <= ch && ch < 0xdc00 ) { int next ; if ( i + 1 >= length ) { throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) } ) ) ; } else { next = s . charAt ( ++ i ) ; if ( ! ( 0xdc00 <= next && next < 0xe000 ) ) throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) + " " + Integer . toHexString ( next ) } ) ) ; next = ( ( ch - 0xd800 ) << 10 ) + next - 0xdc00 + 0x00010000 ; } sb . append ( "&#x" ) ; sb . append ( Integer . toHexString ( next ) ) ; sb . append ( ";" ) ; } else { sb . append ( ch ) ; } } return sb . toString ( ) ; } public String getHtmlText ( ) { m_trustedAgent . m_getData = true ; m_callThread = Thread . currentThread ( ) ; try { synchronized ( m_callThread ) { m_callThread . wait ( ) ; } } catch ( InterruptedException ie ) { System . out . println ( ie . getMessage ( ) ) ; } return m_htmlText ; } public String getTreeAsText ( String treeURL ) throws IOException { m_treeURL = treeURL ; m_trustedAgent . m_getData = true ; m_trustedAgent . m_getSource = true ; m_callThread = Thread . currentThread ( ) ; try { synchronized ( m_callThread ) { m_callThread . wait ( ) ; } } catch ( InterruptedException ie ) { System . out . println ( ie . getMessage ( ) ) ; } return m_sourceText ; } private String getSource ( ) throws TransformerException { StringWriter osw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( osw , false ) ; String text = "" ; try { URL docURL = new URL ( m_documentBase , m_treeURL ) ; synchronized ( m_tfactory ) { Transformer transformer = m_tfactory . newTransformer ( ) ; StreamSource source = new StreamSource ( docURL . toString ( ) ) ; StreamResult result = new StreamResult ( pw ) ; transformer . transform ( source , result ) ; text = osw . toString ( ) ; } } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } catch ( Exception any_error ) { any_error . printStackTrace ( ) ; } return text ; } public String getSourceTreeAsText ( ) throws Exception { return getTreeAsText ( m_documentURL ) ; } public String getStyleTreeAsText ( ) throws Exception { return getTreeAsText ( m_styleURL ) ; } public String getResultTreeAsText ( ) throws Exception { return escapeString ( getHtmlText ( ) ) ; } public String transformToHtml ( String doc , String style ) { if ( null != doc ) { m_documentURL = doc ; } if ( null != style ) { m_styleURL = style ; } return getHtmlText ( ) ; } public String transformToHtml ( String doc ) { if ( null != doc ) { m_documentURL = doc ; } m_styleURL = null ; return getHtmlText ( ) ; } private String processTransformation ( ) throws TransformerException { String htmlData = null ; this . showStatus ( "Waiting for Transformer and Parser to finish loading and JITing..." ) ; synchronized ( m_tfactory ) { URL documentURL = null ; URL styleURL = null ; StringWriter osw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( osw , false ) ; StreamResult result = new StreamResult ( pw ) ; this . showStatus ( "Begin Transformation..." ) ; try { documentURL = new URL ( m_codeBase , m_documentURL ) ; StreamSource xmlSource = new StreamSource ( documentURL . toString ( ) ) ; styleURL = new URL ( m_codeBase , m_styleURL ) ; StreamSource xslSource = new StreamSource ( styleURL . toString ( ) ) ; Transformer transformer = m_tfactory . newTransformer ( xslSource ) ; m_keys = m_parameters . keys ( ) ; while ( m_keys . hasMoreElements ( ) ) { Object key = m_keys . nextElement ( ) ; Object expression = m_parameters . get ( key ) ; transformer . setParameter ( ( String ) key , expression ) ; } transformer . transform ( xmlSource , result ) ; } catch ( TransformerConfigurationException tfe ) { tfe . printStackTrace ( ) ; System . exit ( - 1 ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } this . showStatus ( "Transformation Done!" ) ; htmlData = osw . toString ( ) ; } return htmlData ; } class TrustedAgent implements Runnable { public boolean m_getData = false ; public boolean m_getSource = false ; public void run ( ) { while ( true ) { m_trustedWorker . yield ( ) ; if ( m_getData ) { try { m_getData = false ; m_htmlText = null ; m_sourceText = null ; if ( m_getSource ) { m_getSource = false ; m_sourceText = getSource ( ) ; } else m_htmlText = processTransformation ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { synchronized ( m_callThread ) { m_callThread . notify ( ) ; } } } else { try { m_trustedWorker . sleep ( 50 ) ; } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } } } } } } 	1	['29', '5', '0', '2', '83', '298', '1', '2', '21', '0.879251701', '801', '0.904761905', '1', '0.94214876', '0.344827586', '3', '5', '25.89655172', '10', '1.5172', '1']
package org . apache . xml . dtm . ref ; import java . util . BitSet ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public class CoroutineManager { BitSet m_activeIDs = new BitSet ( ) ; static final int m_unreasonableId = 1024 ; Object m_yield = null ; final static int NOBODY = - 1 ; final static int ANYBODY = - 1 ; int m_nextCoroutine = NOBODY ; public synchronized int co_joinCoroutineSet ( int coroutineID ) { if ( coroutineID >= 0 ) { if ( coroutineID >= m_unreasonableId || m_activeIDs . get ( coroutineID ) ) return - 1 ; } else { coroutineID = 0 ; while ( coroutineID < m_unreasonableId ) { if ( m_activeIDs . get ( coroutineID ) ) ++ coroutineID ; else break ; } if ( coroutineID >= m_unreasonableId ) return - 1 ; } m_activeIDs . set ( coroutineID ) ; return coroutineID ; } public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; } public synchronized Object co_resume ( Object arg_object , int thisCoroutine , int toCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( toCoroutine ) ) throw new java . lang . NoSuchMethodException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COROUTINE_NOT_AVAIL , new Object [ ] { Integer . toString ( toCoroutine ) } ) ) ; m_yield = arg_object ; m_nextCoroutine = toCoroutine ; notify ( ) ; while ( m_nextCoroutine != thisCoroutine || m_nextCoroutine == ANYBODY || m_nextCoroutine == NOBODY ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } if ( m_nextCoroutine == NOBODY ) { co_exit ( thisCoroutine ) ; throw new java . lang . NoSuchMethodException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COROUTINE_CO_EXIT , null ) ) ; } return m_yield ; } public synchronized void co_exit ( int thisCoroutine ) { m_activeIDs . clear ( thisCoroutine ) ; m_nextCoroutine = NOBODY ; notify ( ) ; } public synchronized void co_exit_to ( Object arg_object , int thisCoroutine , int toCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( toCoroutine ) ) throw new java . lang . NoSuchMethodException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COROUTINE_NOT_AVAIL , new Object [ ] { Integer . toString ( toCoroutine ) } ) ) ; m_yield = arg_object ; m_nextCoroutine = toCoroutine ; m_activeIDs . clear ( thisCoroutine ) ; notify ( ) ; } } 	1	['6', '1', '0', '4', '17', '0', '3', '1', '6', '0.7', '183', '0', '0', '0', '0.722222222', '0', '0', '28.5', '7', '1.8333', '1']
package org . apache . xalan . xslt ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . io . StringReader ; import java . util . Properties ; import java . util . ResourceBundle ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . TransformerFactoryConfigurationError ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . Version ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . trace . PrintTraceListener ; import org . apache . xalan . trace . TraceManager ; import org . apache . xalan . transformer . XalanProperties ; import org . apache . xml . utils . DefaultErrorHandler ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class Process { protected static void printArgOptions ( ResourceBundle resbundle ) { System . out . println ( resbundle . getString ( "xslProc_option" ) ) ; System . out . println ( "\n\t\t\t" + resbundle . getString ( "xslProc_common_options" ) + "\n" ) ; System . out . println ( resbundle . getString ( "optionXSLTC" ) ) ; System . out . println ( resbundle . getString ( "optionIN" ) ) ; System . out . println ( resbundle . getString ( "optionXSL" ) ) ; System . out . println ( resbundle . getString ( "optionOUT" ) ) ; System . out . println ( resbundle . getString ( "optionV" ) ) ; System . out . println ( resbundle . getString ( "optionEDUMP" ) ) ; System . out . println ( resbundle . getString ( "optionXML" ) ) ; System . out . println ( resbundle . getString ( "optionTEXT" ) ) ; System . out . println ( resbundle . getString ( "optionHTML" ) ) ; System . out . println ( resbundle . getString ( "optionPARAM" ) ) ; System . out . println ( resbundle . getString ( "optionMEDIA" ) ) ; System . out . println ( resbundle . getString ( "optionFLAVOR" ) ) ; System . out . println ( resbundle . getString ( "optionDIAG" ) ) ; System . out . println ( resbundle . getString ( "optionURIRESOLVER" ) ) ; System . out . println ( resbundle . getString ( "optionENTITYRESOLVER" ) ) ; waitForReturnKey ( resbundle ) ; System . out . println ( resbundle . getString ( "optionCONTENTHANDLER" ) ) ; System . out . println ( "\n\t\t\t" + resbundle . getString ( "xslProc_xalan_options" ) + "\n" ) ; System . out . println ( resbundle . getString ( "optionQC" ) ) ; System . out . println ( resbundle . getString ( "optionTT" ) ) ; System . out . println ( resbundle . getString ( "optionTG" ) ) ; System . out . println ( resbundle . getString ( "optionTS" ) ) ; System . out . println ( resbundle . getString ( "optionTTC" ) ) ; System . out . println ( resbundle . getString ( "optionTCLASS" ) ) ; System . out . println ( resbundle . getString ( "optionLINENUMBERS" ) ) ; System . out . println ( resbundle . getString ( "optionINCREMENTAL" ) ) ; System . out . println ( resbundle . getString ( "optionNOOPTIMIMIZE" ) ) ; System . out . println ( resbundle . getString ( "optionRL" ) ) ; System . out . println ( "\n\t\t\t" + resbundle . getString ( "xslProc_xsltc_options" ) + "\n" ) ; System . out . println ( resbundle . getString ( "optionXO" ) ) ; System . out . println ( resbundle . getString ( "optionXD" ) ) ; waitForReturnKey ( resbundle ) ; System . out . println ( resbundle . getString ( "optionXJ" ) ) ; System . out . println ( resbundle . getString ( "optionXP" ) ) ; System . out . println ( resbundle . getString ( "optionXN" ) ) ; System . out . println ( resbundle . getString ( "optionXX" ) ) ; System . out . println ( resbundle . getString ( "optionXT" ) ) ; } public static void main ( String argv [ ] ) { boolean doStackDumpOnError = false ; boolean setQuietMode = false ; boolean doDiag = false ; java . io . PrintWriter diagnosticsWriter = new PrintWriter ( System . err , true ) ; java . io . PrintWriter dumpWriter = diagnosticsWriter ; ResourceBundle resbundle = ( XSLMessages . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . ERROR_RESOURCES ) ) ; String flavor = "s2s" ; if ( argv . length < 1 ) { printArgOptions ( resbundle ) ; } else { boolean useXSLTC = false ; for ( int i = 0 ; i < argv . length ; i ++ ) { if ( "-XSLTC" . equalsIgnoreCase ( argv [ i ] ) ) { useXSLTC = true ; } } TransformerFactory tfactory ; if ( useXSLTC ) { String key = "javax.xml.transform.TransformerFactory" ; String value = "org.apache.xalan.xsltc.trax.TransformerFactoryImpl" ; Properties props = System . getProperties ( ) ; props . put ( key , value ) ; System . setProperties ( props ) ; } try { tfactory = TransformerFactory . newInstance ( ) ; } catch ( TransformerFactoryConfigurationError pfe ) { pfe . printStackTrace ( dumpWriter ) ; diagnosticsWriter . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_SUCCESSFUL , null ) ) ; tfactory = null ; doExit ( - 1 ) ; } boolean formatOutput = false ; boolean useSourceLocation = false ; String inFileName = null ; String outFileName = null ; String dumpFileName = null ; String xslFileName = null ; String treedumpFileName = null ; PrintTraceListener tracer = null ; String outputType = null ; String media = null ; Vector params = new Vector ( ) ; boolean quietConflictWarnings = false ; URIResolver uriResolver = null ; EntityResolver entityResolver = null ; ContentHandler contentHandler = null ; int recursionLimit = - 1 ; for ( int i = 0 ; i < argv . length ; i ++ ) { if ( "-XSLTC" . equalsIgnoreCase ( argv [ i ] ) ) { } else if ( "-TT" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceTemplates = true ; } else printInvalidXSLTCOption ( "-TT" ) ; } else if ( "-TG" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceGeneration = true ; } else printInvalidXSLTCOption ( "-TG" ) ; } else if ( "-TS" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceSelection = true ; } else printInvalidXSLTCOption ( "-TS" ) ; } else if ( "-TTC" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceElements = true ; } else printInvalidXSLTCOption ( "-TTC" ) ; } else if ( "-INDENT" . equalsIgnoreCase ( argv [ i ] ) ) { int indentAmount ; if ( ( ( i + 1 ) < argv . length ) && ( argv [ i + 1 ] . charAt ( 0 ) != '-' ) ) { indentAmount = Integer . parseInt ( argv [ ++ i ] ) ; } else { indentAmount = 0 ; } } else if ( "-IN" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) inFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-IN" } ) ) ; } else if ( "-MEDIA" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) media = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-MEDIA" } ) ) ; } else if ( "-OUT" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) outFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-OUT" } ) ) ; } else if ( "-XSL" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) xslFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XSL" } ) ) ; } else if ( "-FLAVOR" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { flavor = argv [ ++ i ] ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-FLAVOR" } ) ) ; } else if ( "-PARAM" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 2 < argv . length ) { String name = argv [ ++ i ] ; params . addElement ( name ) ; String expression = argv [ ++ i ] ; params . addElement ( expression ) ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-PARAM" } ) ) ; } else if ( "-E" . equalsIgnoreCase ( argv [ i ] ) ) { } else if ( "-V" . equalsIgnoreCase ( argv [ i ] ) ) { diagnosticsWriter . println ( resbundle . getString ( "version" ) + Version . getVersion ( ) + ", " + resbundle . getString ( "version2" ) ) ; } else if ( "-QC" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) quietConflictWarnings = true ; else printInvalidXSLTCOption ( "-QC" ) ; } else if ( "-Q" . equalsIgnoreCase ( argv [ i ] ) ) { setQuietMode = true ; } else if ( "-DIAG" . equalsIgnoreCase ( argv [ i ] ) ) { doDiag = true ; } else if ( "-XML" . equalsIgnoreCase ( argv [ i ] ) ) { outputType = "xml" ; } else if ( "-TEXT" . equalsIgnoreCase ( argv [ i ] ) ) { outputType = "text" ; } else if ( "-HTML" . equalsIgnoreCase ( argv [ i ] ) ) { outputType = "html" ; } else if ( "-EDUMP" . equalsIgnoreCase ( argv [ i ] ) ) { doStackDumpOnError = true ; if ( ( ( i + 1 ) < argv . length ) && ( argv [ i + 1 ] . charAt ( 0 ) != '-' ) ) { dumpFileName = argv [ ++ i ] ; } } else if ( "-URIRESOLVER" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { try { uriResolver = ( URIResolver ) ObjectFactory . newInstance ( argv [ ++ i ] , ObjectFactory . findClassLoader ( ) , true ) ; tfactory . setURIResolver ( uriResolver ) ; } catch ( ObjectFactory . ConfigurationError cnfe ) { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_CLASS_NOT_FOUND_FOR_OPTION , new Object [ ] { "-URIResolver" } ) ) ; doExit ( - 1 ) ; } } else { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-URIResolver" } ) ) ; doExit ( - 1 ) ; } } else if ( "-ENTITYRESOLVER" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { try { entityResolver = ( EntityResolver ) ObjectFactory . newInstance ( argv [ ++ i ] , ObjectFactory . findClassLoader ( ) , true ) ; } catch ( ObjectFactory . ConfigurationError cnfe ) { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_CLASS_NOT_FOUND_FOR_OPTION , new Object [ ] { "-EntityResolver" } ) ) ; doExit ( - 1 ) ; } } else { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-EntityResolver" } ) ) ; doExit ( - 1 ) ; } } else if ( "-CONTENTHANDLER" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { try { contentHandler = ( ContentHandler ) ObjectFactory . newInstance ( argv [ ++ i ] , ObjectFactory . findClassLoader ( ) , true ) ; } catch ( ObjectFactory . ConfigurationError cnfe ) { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_CLASS_NOT_FOUND_FOR_OPTION , new Object [ ] { "-ContentHandler" } ) ) ; doExit ( - 1 ) ; } } else { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-ContentHandler" } ) ) ; doExit ( - 1 ) ; } } else if ( "-L" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) useSourceLocation = true ; else printInvalidXSLTCOption ( "-L" ) ; } else if ( "-INCREMENTAL" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) tfactory . setAttribute ( "http://xml.apache.org/xalan/features/incremental" , java . lang . Boolean . TRUE ) ; else printInvalidXSLTCOption ( "-INCREMENTAL" ) ; } else if ( "-NOOPTIMIZE" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) tfactory . setAttribute ( "http://xml.apache.org/xalan/features/optimize" , java . lang . Boolean . FALSE ) ; else printInvalidXSLTCOption ( "-NOOPTIMIZE" ) ; } else if ( "-RL" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( i + 1 < argv . length ) recursionLimit = Integer . parseInt ( argv [ ++ i ] ) ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-rl" } ) ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXSLTCOption ( "-RL" ) ; } } else if ( "-XO" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) { tfactory . setAttribute ( "generate-translet" , "true" ) ; tfactory . setAttribute ( "translet-name" , argv [ ++ i ] ) ; } else tfactory . setAttribute ( "generate-translet" , "true" ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXalanOption ( "-XO" ) ; } } else if ( "-XD" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) tfactory . setAttribute ( "destination-directory" , argv [ ++ i ] ) ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XD" } ) ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXalanOption ( "-XD" ) ; } } else if ( "-XJ" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) { tfactory . setAttribute ( "generate-translet" , "true" ) ; tfactory . setAttribute ( "jar-name" , argv [ ++ i ] ) ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XJ" } ) ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXalanOption ( "-XJ" ) ; } } else if ( "-XP" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) tfactory . setAttribute ( "package-name" , argv [ ++ i ] ) ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XP" } ) ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXalanOption ( "-XP" ) ; } } else if ( "-XN" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { tfactory . setAttribute ( "enable-inlining" , "true" ) ; } else printInvalidXalanOption ( "-XN" ) ; } else if ( "-XX" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { tfactory . setAttribute ( "debug" , "true" ) ; } else printInvalidXalanOption ( "-XX" ) ; } else if ( "-XT" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { tfactory . setAttribute ( "auto-translet" , "true" ) ; } else printInvalidXalanOption ( "-XT" ) ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_OPTION , new Object [ ] { argv [ i ] } ) ) ; } if ( inFileName == null && xslFileName == null ) { System . err . println ( resbundle . getString ( "xslProc_no_input" ) ) ; doExit ( - 1 ) ; } try { long start = System . currentTimeMillis ( ) ; if ( null != dumpFileName ) { dumpWriter = new PrintWriter ( new FileWriter ( dumpFileName ) ) ; } Templates stylesheet = null ; if ( null != xslFileName ) { if ( flavor . equals ( "d2d" ) ) { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; dfactory . setNamespaceAware ( true ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; Node xslDOM = docBuilder . parse ( new InputSource ( xslFileName ) ) ; stylesheet = tfactory . newTemplates ( new DOMSource ( xslDOM , xslFileName ) ) ; } else { stylesheet = tfactory . newTemplates ( new StreamSource ( xslFileName ) ) ; } } PrintWriter resultWriter ; StreamResult strResult ; if ( null != outFileName ) { strResult = new StreamResult ( new FileOutputStream ( outFileName ) ) ; strResult . setSystemId ( outFileName ) ; } else { strResult = new StreamResult ( System . out ) ; } SAXTransformerFactory stf = ( SAXTransformerFactory ) tfactory ; if ( ! useXSLTC && useSourceLocation ) stf . setAttribute ( XalanProperties . SOURCE_LOCATION , Boolean . TRUE ) ; if ( null == stylesheet ) { Source source = stf . getAssociatedStylesheet ( new StreamSource ( inFileName ) , media , null , null ) ; if ( null != source ) stylesheet = tfactory . newTemplates ( source ) ; else { if ( null != media ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_STYLESHEET_IN_MEDIA , new Object [ ] { inFileName , media } ) ) ; else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_STYLESHEET_PI , new Object [ ] { inFileName } ) ) ; } } if ( null != stylesheet ) { Transformer transformer = flavor . equals ( "th" ) ? null : stylesheet . newTransformer ( ) ; if ( null != outputType ) { transformer . setOutputProperty ( OutputKeys . METHOD , outputType ) ; } if ( transformer instanceof org . apache . xalan . transformer . TransformerImpl ) { org . apache . xalan . transformer . TransformerImpl impl = ( org . apache . xalan . transformer . TransformerImpl ) transformer ; TraceManager tm = impl . getTraceManager ( ) ; if ( null != tracer ) tm . addTraceListener ( tracer ) ; impl . setQuietConflictWarnings ( quietConflictWarnings ) ; if ( useSourceLocation ) impl . setProperty ( XalanProperties . SOURCE_LOCATION , Boolean . TRUE ) ; if ( recursionLimit > 0 ) impl . setRecursionLimit ( recursionLimit ) ; } int nParams = params . size ( ) ; for ( int i = 0 ; i < nParams ; i += 2 ) { transformer . setParameter ( ( String ) params . elementAt ( i ) , ( String ) params . elementAt ( i + 1 ) ) ; } if ( uriResolver != null ) transformer . setURIResolver ( uriResolver ) ; if ( null != inFileName ) { if ( flavor . equals ( "d2d" ) ) { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; dfactory . setCoalescing ( true ) ; dfactory . setNamespaceAware ( true ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; if ( entityResolver != null ) docBuilder . setEntityResolver ( entityResolver ) ; Node xmlDoc = docBuilder . parse ( new InputSource ( inFileName ) ) ; Document doc = docBuilder . newDocument ( ) ; org . w3c . dom . DocumentFragment outNode = doc . createDocumentFragment ( ) ; transformer . transform ( new DOMSource ( xmlDoc , inFileName ) , new DOMResult ( outNode ) ) ; Transformer serializer = stf . newTransformer ( ) ; Properties serializationProps = stylesheet . getOutputProperties ( ) ; serializer . setOutputProperties ( serializationProps ) ; if ( contentHandler != null ) { SAXResult result = new SAXResult ( contentHandler ) ; serializer . transform ( new DOMSource ( outNode ) , result ) ; } else serializer . transform ( new DOMSource ( outNode ) , strResult ) ; } else if ( flavor . equals ( "th" ) ) { for ( int i = 0 ; i < 1 ; i ++ ) { XMLReader reader = null ; try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } if ( ! useXSLTC ) stf . setAttribute ( org . apache . xalan . processor . TransformerFactoryImpl . FEATURE_INCREMENTAL , Boolean . TRUE ) ; TransformerHandler th = stf . newTransformerHandler ( stylesheet ) ; reader . setContentHandler ( th ) ; reader . setDTDHandler ( th ) ; if ( th instanceof org . xml . sax . ErrorHandler ) reader . setErrorHandler ( ( org . xml . sax . ErrorHandler ) th ) ; try { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , th ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { } catch ( org . xml . sax . SAXNotSupportedException e ) { } try { reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } th . setResult ( strResult ) ; reader . parse ( new InputSource ( inFileName ) ) ; } } else { if ( entityResolver != null ) { XMLReader reader = null ; try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } reader . setEntityResolver ( entityResolver ) ; if ( contentHandler != null ) { SAXResult result = new SAXResult ( contentHandler ) ; transformer . transform ( new SAXSource ( reader , new InputSource ( inFileName ) ) , result ) ; } else { transformer . transform ( new SAXSource ( reader , new InputSource ( inFileName ) ) , strResult ) ; } } else if ( contentHandler != null ) { SAXResult result = new SAXResult ( contentHandler ) ; transformer . transform ( new StreamSource ( inFileName ) , result ) ; } else { transformer . transform ( new StreamSource ( inFileName ) , strResult ) ; } } } else { StringReader reader = new StringReader ( "<?xml version=\"1.0\"?> <doc/>" ) ; transformer . transform ( new StreamSource ( reader ) , strResult ) ; } } else { diagnosticsWriter . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_SUCCESSFUL , null ) ) ; doExit ( - 1 ) ; } if ( null != outFileName && strResult != null ) { java . io . OutputStream out = strResult . getOutputStream ( ) ; java . io . Writer writer = strResult . getWriter ( ) ; try { if ( out != null ) out . close ( ) ; if ( writer != null ) writer . close ( ) ; } catch ( java . io . IOException ie ) { } } long stop = System . currentTimeMillis ( ) ; long millisecondsDuration = stop - start ; if ( doDiag ) { Object [ ] msgArgs = new Object [ ] { inFileName , xslFileName , new Long ( millisecondsDuration ) } ; String msg = XSLMessages . createMessage ( "diagTiming" , msgArgs ) ; diagnosticsWriter . println ( '\n' ) ; diagnosticsWriter . println ( msg ) ; } } catch ( Throwable throwable ) { while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } if ( ( throwable instanceof NullPointerException ) || ( throwable instanceof ClassCastException ) ) doStackDumpOnError = true ; diagnosticsWriter . println ( ) ; if ( doStackDumpOnError ) throwable . printStackTrace ( dumpWriter ) ; else { DefaultErrorHandler . printLocation ( diagnosticsWriter , throwable ) ; diagnosticsWriter . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_XSLT_ERROR , null ) + " (" + throwable . getClass ( ) . getName ( ) + "): " + throwable . getMessage ( ) ) ; } if ( null != dumpFileName ) { dumpWriter . close ( ) ; } doExit ( - 1 ) ; } if ( null != dumpFileName ) { dumpWriter . close ( ) ; } if ( null != diagnosticsWriter ) { } } } static void doExit ( int i ) { System . exit ( i ) ; } private static void waitForReturnKey ( ResourceBundle resbundle ) { System . out . println ( resbundle . getString ( "xslProc_return_to_continue" ) ) ; try { while ( System . in . read ( ) != '\n' ) ; } catch ( java . io . IOException e ) { } } private static void printInvalidXSLTCOption ( String option ) { System . err . println ( XSLMessages . createMessage ( "xslProc_invalid_xsltc_option" , new Object [ ] { option } ) ) ; } private static void printInvalidXalanOption ( String option ) { System . err . println ( XSLMessages . createMessage ( "xslProc_invalid_xalan_option" , new Object [ ] { option } ) ) ; } } 	1	['7', '1', '0', '10', '109', '21', '0', '10', '2', '2', '2028', '0', '0', '0', '0.2', '0', '0', '288.7142857', '138', '20.4286', '2']
package org . w3c . dom . xpath ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; public interface XPathNamespace extends Node { public static final short XPATH_NAMESPACE_NODE = 13 ; public Element getOwnerElement ( ) ; } 	1	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . xml . utils ; public class IntVector implements Cloneable { protected int m_blocksize ; protected int m_map [ ] ; protected int m_firstFree = 0 ; protected int m_mapSize ; public IntVector ( ) { m_blocksize = 32 ; m_mapSize = m_blocksize ; m_map = new int [ m_blocksize ] ; } public IntVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new int [ blocksize ] ; } public IntVector ( int blocksize , int increaseSize ) { m_blocksize = increaseSize ; m_mapSize = blocksize ; m_map = new int [ blocksize ] ; } public IntVector ( IntVector v ) { m_map = new int [ v . m_mapSize ] ; m_mapSize = v . m_mapSize ; m_firstFree = v . m_firstFree ; m_blocksize = v . m_blocksize ; System . arraycopy ( v . m_map , 0 , m_map , 0 , m_firstFree ) ; } public final int size ( ) { return m_firstFree ; } public final void setSize ( int sz ) { m_firstFree = sz ; } public final void addElement ( int value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final void addElements ( int value , int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map [ m_firstFree ] = value ; m_firstFree ++ ; } } public final void addElements ( int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_firstFree += numberOfElements ; } public final void insertElementAt ( int value , int at ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } if ( at <= ( m_firstFree - 1 ) ) { System . arraycopy ( m_map , at , m_map , at + 1 , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; } public final void removeAllElements ( ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { m_map [ i ] = java . lang . Integer . MIN_VALUE ; } m_firstFree = 0 ; } public final boolean removeElement ( int s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + 1 ) < m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; return true ; } } return false ; } public final void removeElementAt ( int i ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i , m_firstFree ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; } public final void setElementAt ( int value , int index ) { m_map [ index ] = value ; } public final int elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( int s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) return true ; } return false ; } public final int indexOf ( int elem , int index ) { for ( int i = index ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final int indexOf ( int elem ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final int lastIndexOf ( int elem ) { for ( int i = ( m_firstFree - 1 ) ; i >= 0 ; i -- ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public Object clone ( ) throws CloneNotSupportedException { return new IntVector ( this ) ; } } 	1	['20', '1', '1', '5', '22', '0', '5', '0', '20', '0.342105263', '497', '1', '0', '0', '0.6', '0', '0', '23.65', '4', '1.75', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; final class UnionPathExpr extends Expression { private final Expression _pathExpr ; private final Expression _rest ; private boolean _reverse = false ; private Expression [ ] _components ; public UnionPathExpr ( Expression pathExpr , Expression rest ) { _pathExpr = pathExpr ; _rest = rest ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; final Vector components = new Vector ( ) ; flatten ( components ) ; final int size = components . size ( ) ; _components = ( Expression [ ] ) components . toArray ( new Expression [ size ] ) ; for ( int i = 0 ; i < size ; i ++ ) { _components [ i ] . setParser ( parser ) ; _components [ i ] . setParent ( this ) ; if ( _components [ i ] instanceof Step ) { final Step step = ( Step ) _components [ i ] ; final int axis = step . getAxis ( ) ; final int type = step . getNodeType ( ) ; if ( ( axis == Axis . ATTRIBUTE ) || ( type == DTM . ATTRIBUTE_NODE ) ) { _components [ i ] = _components [ 0 ] ; _components [ 0 ] = step ; } if ( Axis . isReverse [ axis ] ) _reverse = true ; } } if ( getParent ( ) instanceof Expression ) _reverse = false ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final int length = _components . length ; for ( int i = 0 ; i < length ; i ++ ) { if ( _components [ i ] . typeCheck ( stable ) != Type . NodeSet ) { _components [ i ] = new CastExpr ( _components [ i ] , Type . NodeSet ) ; } } return _type = Type . NodeSet ; } public String toString ( ) { return "union(" + _pathExpr + ", " + _rest + ')' ; } private void flatten ( Vector components ) { components . addElement ( _pathExpr ) ; if ( _rest != null ) { if ( _rest instanceof UnionPathExpr ) { ( ( UnionPathExpr ) _rest ) . flatten ( components ) ; } else { components . addElement ( _rest ) ; } } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( UNION_ITERATOR_CLASS , "<init>" , "(" + DOM_INTF_SIG + ")V" ) ; final int iter = cpg . addMethodref ( UNION_ITERATOR_CLASS , ADD_ITERATOR , ADD_ITERATOR_SIG ) ; il . append ( new NEW ( cpg . addClass ( UNION_ITERATOR_CLASS ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKESPECIAL ( init ) ) ; final int length = _components . length ; for ( int i = 0 ; i < length ; i ++ ) { _components [ i ] . translate ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( iter ) ) ; } if ( _reverse ) { final int order = cpg . addInterfaceMethodref ( DOM_INTF , ORDER_ITERATOR , ORDER_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( order , 3 ) ) ; } } } 	1	['6', '3', '0', '20', '36', '0', '1', '20', '5', '0.5', '289', '1', '3', '0.934210526', '0.285714286', '2', '8', '46.5', '7', '2.5', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_ca extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "S'ha definit més d'un full d'estils en el mateix fitxer." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "La plantilla ''{0}'' ja està definida en aquest full d''estils." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "La plantilla ''{0}'' no està definida en aquest full d''estils." } , { ErrorMsg . VARIABLE_REDEF_ERR , "La variable ''{0}'' s''ha definit més d''una vegada en el mateix àmbit." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "La variable o el paràmetre ''{0}'' no s''ha definit." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "No s''ha trobat la classe ''{0}''." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "No s''ha trobat el mètode extern ''{0}'' (ha de ser public)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "No s''ha pogut convertir l''argument o tipus de retorn a la crida del mètode ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "No s''ha trobat el fitxer o URI ''{0}''." } , { ErrorMsg . INVALID_URI_ERR , "L''URI ''{0}'' no és vàlid." } , { ErrorMsg . FILE_ACCESS_ERR , "No es pot obrir el fitxer o l''URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "S''esperava l''element <xsl:stylesheet> o <xsl:transform>." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "El prefix d''espai de noms ''{0}'' no s''ha declarat." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "No s''ha pogut resoldre la crida de la funció ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "L''argument de ''{0}'' ha de ser una cadena de literals." } , { ErrorMsg . XPATH_PARSER_ERR , "S''ha produït un error en analitzar l''expressió XPath ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "No s''ha especificat l''atribut obligatori ''{0}''." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "L''expressió XPath conté el caràcter no permès ''{0}''." } , { ErrorMsg . ILLEGAL_PI_ERR , "La instrucció de processament té el nom no permès ''{0}''." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "L''atribut ''{0}'' es troba fora de l''element." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "No es permet l''atribut ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Import/include circular. El full d''estils ''{0}'' ja s''ha carregat." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Els fragments de l'arbre de resultats no es poden classificar (es passen per alt els elements <xsl:sort>). Heu de classificar els nodes quan creeu l'arbre de resultats. " } , { ErrorMsg . SYMBOLS_REDEF_ERR , "El formatatge decimal ''{0}'' ja està definit." } , { ErrorMsg . XSL_VERSION_ERR , "XSLTC no dóna suport a la versió XSL ''{0}''." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Hi ha una referència de variable/paràmetre circular a ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "L'operador de l'expressió binària és desconegut." } , { ErrorMsg . ILLEGAL_ARG_ERR , "La crida de funció té arguments no permesos." } , { ErrorMsg . DOCUMENT_ARG_ERR , "El segon argument de la funció document() ha de ser un conjunt de nodes." } , { ErrorMsg . MISSING_WHEN_ERR , "Es necessita com a mínim un element <xsl:when> a <xsl:choose>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "Només es permet un element <xsl:otherwise> a <xsl:choose>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> només es pot utilitzar dins de <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> només es pot utilitzar dins de <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "A <xsl:choose> només es permeten els elements <xsl:when> i <xsl:otherwise>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "L'atribut 'name' falta a <xsl:attribute-set>." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "L'element subordinat no és permès." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "No podeu cridar un element ''{0}''" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "No podeu cridar un atribut ''{0}''" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Hi ha dades fora de l'element de nivell superior <xsl:stylesheet>." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "L'analitzador JAXP no s'ha configurat correctament" } , { ErrorMsg . INTERNAL_ERR , "S''ha produït un error intern d''XSLTC irrecuperable: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "L''element d''XSL ''{0}'' no té suport." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "No es reconeix l''extensió d''XSLTC ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "El document d'entrada no és un full d'estils (l'espai de noms XSL no s'ha declarat en l'element arrel)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "No s''ha trobat la destinació ''{0}'' del full d''estils." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "No s''ha implementat ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "El document d'entrada no conté cap full d'estils XSL." } , { ErrorMsg . ELEMENT_PARSE_ERR , "No s''ha pogut analitzar l''element ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "L'atribut use de <key> ha de ser node, node-set, string o number." } , { ErrorMsg . OUTPUT_VERSION_ERR , "La versió del document XML de sortida ha de ser 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "L'operador de l'expressió relacional és desconegut." } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "S''ha intentat utilitzar el conjunt d''atributs ''{0}'' que no existeix." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "No es pot analitzar la plantilla de valors d''atributs ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "El tipus de dades de la signatura de la classe ''{0}'' és desconegut." } , { ErrorMsg . DATA_CONVERSION_ERR , "No es pot convertir el tipus de dades ''{0}'' en ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Templates no conté cap definició de classe translet." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Templates no conté cap classe amb el nom ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "No s''ha pogut carregar la classe translet ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "La classe translet s''ha carregat, però no es pot crear la instància translet." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "S''ha intentat establir ErrorListener de ''{0}'' en un valor nul." } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "XSLTC només dóna suport a StreamSource, SAXSource i DOMSource." } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "L''objecte source donat a ''{0}'' no té contingut." } , { ErrorMsg . JAXP_COMPILE_ERR , "No s'ha pogut compilar el full d'estils." } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory no reconeix l''atribut ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() s'ha de cridar abans de startDocument()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformer no conté cap objecte translet." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "No s'ha definit cap manejador de sortida per al resultat de transformació." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "L''objecte result donat a ''{0}'' no és vàlid." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "S''ha intentat accedir a una propietat Transformer ''{0}'' no vàlida." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "No s''ha pogut crear l''adaptador SAX2DOM ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "S'ha cridat XSLTCSource.build() sense que s'hagués establert la identificació del sistema." } , { ErrorMsg . COMPILE_STDIN_ERR , "L'opció -i s'ha d'utilitzar amb l'opció -o." } , { ErrorMsg . COMPILE_USAGE_STR , "RESUM\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <sortida>]\n      [-d <directori>] [-j <fitxer_jar>] [-p <paquet>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <full_estils> |  -i }\n\nOPCIONS\n   -o <sortida>    assigna el nom <sortida> al translet\n generat. Per defecte, el nom de translet\n s'obté del nom de <full_estils>. Aquesta opció\n no es té en compte si es compilen diversos fulls d'estils.\n   -d <directori> especifica un directori de destinació per al translet\n   -j <fitxer_jar>   empaqueta les classes translet en un fitxer jar del nom\n                  especificat com a <fitxer_jar>\n   -p <paquet> especifica un prefix de nom de paquet per a totes les classes\n                  translet generades.\n -n habilita l'inlining (com a mitjana, el funcionament per defecte\n és millor).\n   -x            habilita la sortida de missatges de depuració addicionals\n   -s inhabilita la crida de System.exit\n   -u             interpreta els arguments <full_estils> com URL\n -i obliga el compilador a llegir el full d'estils des de l'entrada estàndard\n   -v imprimeix la versió del compilador\n   -h             imprimeix aquesta sentència d'ús.\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "RESUM \n   java org.apache.xalan.xsltc.cmdline.Transform [-j <fitxer_jar>]\n      [-x] [-s] [-n <iteracions>] {-u <url_document> | <document>}\n      <classe> [<paràm1>=<valor1> ...]\n\n   utilitza la <classe> translet per transformar un document XML\n   especificat com a <document>. La <classe> translet es troba\n   o bé a la CLASSPATH de l'usuari o bé al <fitxer_jar> que es pot especificar opcionalment.\nOPCIONS\n   -j <fitxer_jar>    especifica un fitxer jar des del qual es pot carregar el translet\n   -x habilita la sortida de missatges de depuració addicionals\n   -s              inhabilita la crida de System.exit\n   -n <iteracions> executa la transformació el nombre de vegades <iteracions> i\n               mostra informació de perfil\n   -u <url_document> especifica el document d'entrada XML com una URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> només es pot utilitzar amb <xsl:for-each> o <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "Aquesta JVM no dóna suport a la codificació de sortida ''{0}''." } , { ErrorMsg . SYNTAX_ERR , "S''ha produït un error de sintaxi a ''{0}''." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "No s''ha trobat el constructor extern ''{0}''." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "El primer argument de la funció Java no static ''{0}'' no és una referència d''objecte vàlida." } , { ErrorMsg . TYPE_CHECK_ERR , "S''ha produït un error en comprovar el tipus de l''expressió ''{0}''." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "S'ha produït un error en comprovar el tipus d'expressió en una ubicació desconeguda." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "L''opció de línia d''ordres ''{0}'' no és vàlida." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "A l''opció de línia d''ordres ''{0}'' li falta un argument obligatori." } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "AVÍS: ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "AVÍS: ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "ERROR MOLT GREU: ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "ERROR MOLT GREU: ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "ERROR:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "ERROR:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Transformació mitjançant translet ''{0}'' " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Transformació mitjançant translet ''{0}'' des del fitxer jar ''{1}''" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "No s''ha pogut crear una instància de la classe TransformerFactory ''{0}''." } , { ErrorMsg . COMPILER_ERROR_KEY , "Errors del compilador:" } , { ErrorMsg . COMPILER_WARNING_KEY , "Avisos del compilador:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Errors de translet:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_ca extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Error: No hi pot haver un caràcter '{' dins l'expressió " } , { ER_ILLEGAL_ATTRIBUTE , "{0} té un atribut no permès: {1} " } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode és nul en xsl:apply-imports. " } , { ER_CANNOT_ADD , "No es pot afegir {0} a {1} " } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode és nul en handleApplyTemplatesInstruction. " } , { ER_NO_NAME_ATTRIB , "{0} ha de tenir un atribut de nom. " } , { ER_TEMPLATE_NOT_FOUND , "No s''ha trobat la plantilla anomenada: {0} " } , { ER_CANT_RESOLVE_NAME_AVT , "No s'ha pogut resoldre l'AVT de noms a xsl:call-template. " } , { ER_REQUIRES_ATTRIB , "{0} necessita l''atribut: {1} " } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} ha de tenir un atribut ''test''." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Valor incorrecte a l''atribut de nivell: {0} " } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "El nom processing-instruction no pot ser 'xml' " } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "El nom processing-instruction ha de ser un NCName vàlid: {0} " } , { ER_NEED_MATCH_ATTRIB , "{0} ha de tenir un atribut que hi coincideixi si té una modalitat. " } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} necessita un nom o un atribut que hi coincideixi. " } , { ER_CANT_RESOLVE_NSPREFIX , "No s''ha pogut resoldre el prefix d''espai de noms: {0} " } , { ER_ILLEGAL_VALUE , "xml:space té un valor no vàlid: {0} " } , { ER_NO_OWNERDOC , "El node subordinat no té un document de propietari. " } , { ER_ELEMTEMPLATEELEM_ERR , "Error d''ElemTemplateElement: {0} " } , { ER_NULL_CHILD , "S'està intentant afegir un subordinat nul. " } , { ER_NEED_SELECT_ATTRIB , "{0} necessita un atribut de selecció. " } , { ER_NEED_TEST_ATTRIB , "xsl:when ha de tenir un atribut 'test'. " } , { ER_NEED_NAME_ATTRIB , "xsl:with-param ha de tenir un atribut 'name'. " } , { ER_NO_CONTEXT_OWNERDOC , "El context no té un document de propietari. " } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "No s''ha pogut crear la relació XML TransformerFactory: {0} " } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: el procés no ha estat correcte. " } , { ER_NOT_SUCCESSFUL , "Xalan no ha estat correcte. " } , { ER_ENCODING_NOT_SUPPORTED , "La codificació no té suport: {0} " } , { ER_COULD_NOT_CREATE_TRACELISTENER , "No s''ha pogut crear TraceListener: {0} " } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key necessita un atribut 'name'. " } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key necessita un atribut 'match'. " } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key necessita un atribut 'use'. " } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} necessita un atribut ''elements''." } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) Falta l''atribut {0} ''prefix''" } , { ER_BAD_STYLESHEET_URL , "La URL del full d''estils és incorrecta: {0} " } , { ER_FILE_NOT_FOUND , "No s''ha trobat el fitxer del full d''estils: {0} " } , { ER_IOEXCEPTION , "S''ha produït una excepció d''E/S amb el fitxer de full d''estils: {0} " } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) No s''ha trobat l''atribut href de {0} " } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} s''està incloent a ell mateix directament o indirecta. " } , { ER_PROCESSINCLUDE_ERROR , "Error de StylesheetHandler.processInclude, {0} " } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) Falta l''atribut {0} ''lang''" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) L''element {0} és fora de lloc? Falta l'element de contenidor ''component''." } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "La sortida només pot ser cap a un Element, Fragment de document, Document o Transcriptor de documents. " } , { ER_PROCESS_ERROR , "Error de StylesheetRoot.process " } , { ER_UNIMPLNODE_ERROR , "Error d''UnImplNode: {0} " } , { ER_NO_SELECT_EXPRESSION , "Error. No s'ha trobat l'expressió select d'xpath (-select). " } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "No es pot serialitzar un XSLProcessor. " } , { ER_NO_INPUT_STYLESHEET , "No s'ha especificat l'entrada del full d'estils. " } , { ER_FAILED_PROCESS_STYLESHEET , "No s'ha pogut processar el full d'estils. " } , { ER_COULDNT_PARSE_DOC , "No s''ha pogut analitzar el document {0}. " } , { ER_COULDNT_FIND_FRAGMENT , "No s''ha pogut trobar el fragment: {0} " } , { ER_NODE_NOT_ELEMENT , "El node al qual apuntava l''identificador de fragments no era un element: {0} " } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each ha de tenir o bé una coincidència o bé un atribut de nom. " } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "Les plantilles han de tenir o bé una coincidència o bé un atribut de nom. " } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "No hi ha cap clonatge d'un fragment de document. " } , { ER_CANT_CREATE_ITEM , "No es pot crear un element a l''arbre de resultats: {0} " } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space de l''XML d''origen té un valor no permès: {0} " } , { ER_NO_XSLKEY_DECLARATION , "No hi ha cap declaració de xls:key per a {0}. " } , { ER_CANT_CREATE_URL , "Error. No es pot crear la url de: {0} " } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions no té suport. " } , { ER_PROCESSOR_ERROR , "Error d'XSLT TransformerFactory " } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} no està permès dins d''un full d''estils. " } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns ja no té suport. En comptes d'això, feu servir xsl:output. " } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space ja no té suport. En comptes d'això, feu servir xsl:strip-space o xsl:preserve-space. " } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result ja no té suport. En comptes d'això, feu servir xsl:output. " } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} té un atribut no permès: {1} " } , { ER_UNKNOWN_XSL_ELEM , "Element XSL desconegut: {0} " } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort només es pot utilitzar amb xsl:apply-templates o xsl:for-each. " } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when està mal col·locat. " } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when no ha estat analitzat per xsl:choose. " } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise està mal col·locat. " } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise no té com a superior xsl:choose. " } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} no està permès dins d''una plantilla. " } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} prefix d''espai de noms d''extensió {1} desconegut " } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Les importacions només es poden produir com els primers elements del full d'estils. " } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} s''està important a ell mateix directament o indirecta. " } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:space té un valor no permès: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet no ha estat correcte. " } , { ER_SAX_EXCEPTION , "Excepció SAX " } , { ER_XSLT_ERROR , "Error d'XSLT " } , { ER_CURRENCY_SIGN_ILLEGAL , "El signe de moneda no està permès en una cadena de patró de format. " } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "La funció document no té suport al DOM de full d'estils. " } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "No es pot resoldre el prefix del solucionador sense prefix. " } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Extensió de redirecció: No s'ha pogut obtenir el nom del fitxer - els atributs file o select han de retornar una cadena vàlida. " } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "No es pot crear build FormatterListener en l'extensió de redirecció. " } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "El prefix d''exclude-result-prefixes no és vàlid: {0} " } , { ER_MISSING_NS_URI , "Falta l'URI d'espai de noms del prefix especificat. " } , { ER_MISSING_ARG_FOR_OPTION , "Falta un argument de l''opció: {0} " } , { ER_INVALID_OPTION , "Opció no vàlida: {0} " } , { ER_MALFORMED_FORMAT_STRING , "Cadena de format mal formada: {0} " } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet necessita un atribut 'version'. " } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "L''atribut {0} té un valor no permès {1} " } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose necessita un xsl:when " } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports no es permeten en un xsl:for-each " } , { ER_CANT_USE_DTM_FOR_OUTPUT , "No es pot utilitzar una DTMLiaison per a un node DOM de sortida. En lloc d'això, utilitzeu org.apache.xpath.DOM2Helper. " } , { ER_CANT_USE_DTM_FOR_INPUT , "No es pot utilitzar una DTMLiaison per a un node DOM d'entrada. En lloc d'això, utilitzeu org.apache.xpath.DOM2Helper. " } , { ER_CALL_TO_EXT_FAILED , "S''ha produït un error en la crida de l''element d''extensió {0} " } , { ER_PREFIX_MUST_RESOLVE , "El prefix s''ha de resoldre en un espai de noms: {0} " } , { ER_INVALID_UTF16_SURROGATE , "S''ha detectat un suplent UTF-16 no vàlid: {0} ? " } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} s''ha utilitzat a ell mateix; això crearà un bucle infinit. " } , { ER_CANNOT_MIX_XERCESDOM , "No es pot barrejar entrada no Xerces-DOM amb sortida Xerces-DOM. " } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException " } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "En ElemTemplateElement.readObject: {0} " } , { ER_DUPLICATE_NAMED_TEMPLATE , "S''ha trobat més d''una plantilla anomenada {0} " } , { ER_INVALID_KEY_CALL , "Crida de funció no vàlida: les crides key() recursives no estan permeses. " } , { ER_REFERENCING_ITSELF , "La variable {0} s''està fent referència a ella mateixa directa o indirectament. " } , { ER_ILLEGAL_DOMSOURCE_INPUT , "El node d'entrada no pot ser nul per a DOMSource de newTemplates. " } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "No s''ha trobat el fitxer de classe per a l''opció {0} " } , { ER_REQUIRED_ELEM_NOT_FOUND , "L''element necessari no s''ha trobat: {0} " } , { ER_INPUT_CANNOT_BE_NULL , "InputStream no pot ser nul. " } , { ER_URI_CANNOT_BE_NULL , "L'URI no pot ser nul. " } , { ER_FILE_CANNOT_BE_NULL , "El fitxer no pot ser nul. " } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource no pot ser nul. " } , { ER_CANNOT_INIT_BSFMGR , "No s'ha pogut inicialitzar BSF Manager " } , { ER_CANNOT_CMPL_EXTENSN , "No s'ha pogut compilar l'extensió " } , { ER_CANNOT_CREATE_EXTENSN , "No s''ha pogut crear l''extensió {0} a causa de {1} " } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "La crida del mètode d''instància {0} necessita una instància d'objecte com a primer argument " } , { ER_INVALID_ELEMENT_NAME , "S''ha especificat un nom d''element no vàlid {0} " } , { ER_ELEMENT_NAME_METHOD_STATIC , "El mètode del nom de l''element ha de ser estàtic {0} " } , { ER_EXTENSION_FUNC_UNKNOWN , "No es coneix la funció d''extensió {0} : {1}. " } , { ER_MORE_MATCH_CONSTRUCTOR , "Hi ha més d''una millor coincidència per al constructor de {0} " } , { ER_MORE_MATCH_METHOD , "Hi ha més d''una millor coincidència per al mètode {0} " } , { ER_MORE_MATCH_ELEMENT , "Hi ha més d''una millor coincidència per al mètode d''element {0} " } , { ER_INVALID_CONTEXT_PASSED , "S''ha donat un context no vàlid per avaluar {0} " } , { ER_POOL_EXISTS , "L'agrupació ja existeix " } , { ER_NO_DRIVER_NAME , "No s'ha especificat cap nom de controlador " } , { ER_NO_URL , "No s'ha especificat cap URL " } , { ER_POOL_SIZE_LESSTHAN_ONE , "La grandària de l'agrupació és inferior a u " } , { ER_INVALID_DRIVER , "S'ha especificat un nom de controlador no vàlid " } , { ER_NO_STYLESHEETROOT , "No s'ha trobat l'arrel del full d'estils " } , { ER_ILLEGAL_XMLSPACE_VALUE , "Valor no permès per a xml:space " } , { ER_PROCESSFROMNODE_FAILED , "S'ha produït un error a processFromNode " } , { ER_RESOURCE_COULD_NOT_LOAD , "El recurs [ {0} ] no s''ha pogut carregar: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Grandària del buffer <=0 " } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "S'ha produït un error desconegut en cridar l'extensió " } , { ER_NO_NAMESPACE_DECL , "El prefix {0} no té una declaració d''espai de noms corresponent " } , { ER_ELEM_CONTENT_NOT_ALLOWED , "El contingut de l''element no està permès per lang=javaclass {0} " } , { ER_STYLESHEET_DIRECTED_TERMINATION , "El full d'estils ha ordenat l'acabament " } , { ER_ONE_OR_TWO , "1 o 2 " } , { ER_TWO_OR_THREE , "2 o 3 " } , { ER_COULD_NOT_LOAD_RESOURCE , "No s''ha pogut carregar {0} (comproveu la CLASSPATH); ara s''estan fent servir els valors per defecte. " } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "No es poden inicialitzar les plantilles per defecte " } , { ER_RESULT_NULL , "El resultat no ha de ser nul " } , { ER_RESULT_COULD_NOT_BE_SET , "No s'ha pogut establir el resultat " } , { ER_NO_OUTPUT_SPECIFIED , "No s'ha especificat cap sortida " } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "No es pot transformar en un resultat del tipus {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "No es pot transformar un origen del tipus {0}" } , { ER_NULL_CONTENT_HANDLER , "Manejador de contingut nul " } , { ER_NULL_ERROR_HANDLER , "Manejador d'error nul " } , { ER_CANNOT_CALL_PARSE , "L'anàlisi no es pot cridar si no s'ha establert ContentHandler " } , { ER_NO_PARENT_FOR_FILTER , "El filtre no té superior " } , { ER_NO_STYLESHEET_IN_MEDIA , "No s''ha trobat cap full d''estils a {0}, suport= {1} " } , { ER_NO_STYLESHEET_PI , "No s''ha trobat cap PI d''xml-stylesheet a {0} " } , { ER_NOT_SUPPORTED , "No té suport: {0} " } , { ER_PROPERTY_VALUE_BOOLEAN , "El valor de la propietat {0} ha de ser una instància booleana " } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "No s''ha pogut arribar a l''script extern a {0} " } , { ER_RESOURCE_COULD_NOT_FIND , "No s''ha trobat el recurs [ {0} ].\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "La propietat de sortida no es reconeix: {0} " } , { ER_FAILED_CREATING_ELEMLITRSLT , "S'ha produït un error en crear la instància ElemLiteralResult " } , { ER_VALUE_SHOULD_BE_NUMBER , "El valor de {0} ha de contenir un número que es pugui analitzar " } , { ER_VALUE_SHOULD_EQUAL , "El valor de {0} ha de ser igual a yes o no " } , { ER_FAILED_CALLING_METHOD , "No s''ha pogut cridar el mètode {0} " } , { ER_FAILED_CREATING_ELEMTMPL , "No s''ha pogut crear la instància ElemTemplateElement " } , { ER_CHARS_NOT_ALLOWED , "En aquest punt del document no es permeten els caràcters " } , { ER_ATTR_NOT_ALLOWED , "L''atribut \"{0}\" no es permet en l''element {1} " } , { ER_BAD_VALUE , "{0} valor erroni {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "No s''ha trobat el valor de l''atribut {0} " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "No es reconeix el valor de l''atribut {0} " } , { ER_NULL_URI_NAMESPACE , "S'intenta generar un prefix d'espai de noms amb un URI nul " } , { ER_NUMBER_TOO_BIG , "S'intenta formatar un número més gran que l'enter llarg més gran " } , { ER_CANNOT_FIND_SAX1_DRIVER , "No es pot trobar la classe de controlador SAX1 {0} " } , { ER_SAX1_DRIVER_NOT_LOADED , "S''ha trobat la classe de controlador SAX1 {0} però no es pot carregar " } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "S''ha carregat la classe de controlador SAX1 {0} però no es pot particularitzar " } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "La classe de controlador SAX1 {0} no implementa org.xml.sax.Parser " } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "No s'ha identificat la propietat del sistema org.xml.sax.parser " } , { ER_PARSER_ARG_CANNOT_BE_NULL , "L'argument d'analitzador ha de ser nul " } , { ER_FEATURE , "Característica: {0} " } , { ER_PROPERTY , "Propietat: {0} " } , { ER_NULL_ENTITY_RESOLVER , "Solucionador d'entitat nul " } , { ER_NULL_DTD_HANDLER , "Manejador de DTD nul " } , { ER_NO_DRIVER_NAME_SPECIFIED , "No s'ha especificat cap nom de controlador " } , { ER_NO_URL_SPECIFIED , "No s'ha especificat cap URL " } , { ER_POOLSIZE_LESS_THAN_ONE , "La grandària de l'agrupació és inferior a 1 " } , { ER_INVALID_DRIVER_NAME , "S'ha especificat un nom de controlador no vàlid " } , { ER_ERRORLISTENER , "ErrorListener " } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Error del programador. Expr no té cap superior ElemTemplateElement " } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Afirmació del programador a RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} no es permet en aquesta posició del full d''estil " } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "No es permet text sense espais en blanc en aquesta posició del full d'estil " } , { INVALID_TCHAR , "S''ha utilitzat un valor no permès {1} per a l''atribut CHAR {0}. Un atribut de tipus CHAR només ha de contenir un caràcter. " } , { INVALID_QNAME , "S''ha utilitzat un valor no permès {1} per a l''atribut QNAME {0} " } , { INVALID_ENUM , "S''ha utilitzat un valor no permès {1} per a l''atribut ENUM {0}. Els valors vàlids són {2}. " } , { INVALID_NMTOKEN , "S''ha utilitzat un valor no permès {1} per a l''atribut NMTOKEN {0} " } , { INVALID_NCNAME , "S''ha utilitzat un valor no permès {1} per a l''atribut NCNAME {0} " } , { INVALID_BOOLEAN , "S''ha utilitzat un valor no permès {1} per a l''atribut boolean {0} " } , { INVALID_NUMBER , "S''ha utilitzat un valor no permès {1} per a l''atribut number {0} " } , { ER_ARG_LITERAL , "L''argument de {0} del patró de coincidència ha de ser un literal. " } , { ER_DUPLICATE_GLOBAL_VAR , "La declaració de variable global està duplicada. " } , { ER_DUPLICATE_VAR , "La declaració de variable està duplicada. " } , { ER_TEMPLATE_NAME_MATCH , "xsl:template ha de tenir un nom o un atribut de coincidència (o tots dos) " } , { ER_INVALID_PREFIX , "El prefix d''exclude-result-prefixes no és vàlid: {0} " } , { ER_NO_ATTRIB_SET , "attribute-set anomenat {0} no existeix " } , { WG_FOUND_CURLYBRACE , "S'ha trobat '}' però no hi ha cap plantilla d'atribut oberta " } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Avís: l''atribut de recompte no coincideix amb un antecessor de xsl:number. Destinació = {0} " } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Sintaxi antiga: El nom de l'atribut 'expr' s'ha canviat per 'select'. " } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan encara no pot gestionar el nom de l'entorn nacional a la funció format-number. " } , { WG_LOCALE_NOT_FOUND , "Avís: No s''ha trobat l''entorn nacional d''xml:lang={0} " } , { WG_CANNOT_MAKE_URL_FROM , "No es pot crear la URL de: {0} " } , { WG_CANNOT_LOAD_REQUESTED_DOC , "No es pot carregar el document sol·licitat: {0} " } , { WG_CANNOT_FIND_COLLATOR , "No s''ha trobat el classificador de <sort xml:lang={0} " } , { WG_FUNCTIONS_SHOULD_USE_URL , "Sintaxi antiga: la instrucció de funcions ha d''utilitzar una URL de {0} " } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "Codificació sense suport: {0}, s''utilitza UTF-8 " } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "Codificació sense suport: {0}, s''utilitza Java {1} " } , { WG_SPECIFICITY_CONFLICTS , "S''han trobat conflictes d''especificitat: {0} S''utilitzarà el darrer trobat al full d''estils. " } , { WG_PARSING_AND_PREPARING , "========= S''està analitzant i preparant {0} ========== " } , { WG_ATTR_TEMPLATE , "Plantilla Attr, {0} " } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "S'ha produït un conflicte de coincidència entre xsl:strip-space i xsl:preserve-space " } , { WG_ATTRIB_NOT_HANDLED , "Xalan encara no pot gestionar l''atribut {0} " } , { WG_NO_DECIMALFORMAT_DECLARATION , "No s''ha trobat cap declaració per al format decimal: {0} " } , { WG_OLD_XSLT_NS , "Falta l'espai de noms XSLT o és incorrecte. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Només es permet una declaració xsl:decimal-format per defecte. " } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "Els noms d''xsl:decimal-format han de ser exclusius. El nom \"{0}\" està duplicat. " } , { WG_ILLEGAL_ATTRIBUTE , "{0} té un atribut no permès: {1} " } , { WG_COULD_NOT_RESOLVE_PREFIX , "No s''ha pogut resoldre el prefix d''espai de noms: {0}. Es passarà per alt el node. " } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet necessita un atribut 'version'. " } , { WG_ILLEGAL_ATTRIBUTE_NAME , "El nom d''atribut no és permès: {0} " } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "S''ha utilitzat un valor no permès a l''atribut {0}: {1} " } , { WG_EMPTY_SECOND_ARG , "El conjunt de nodes resultant del segon argument de la funció document està buit. Torna un conjunt de nodes buit." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "El valor de l''atribut 'name' del nom xsl:processing-instruction no ha de ser 'xml' " } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "El valor de l''atribut 'name' de xsl:processing-instruction ha de ser un NCName vàlid: {0} " } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "No es pot afegir l''atribut {0} després dels nodes subordinats o abans que es produeixi un element. Es passarà per alt l''atribut. " } , { "ui_language" , "ca" } , { "help_language" , "ca" } , { "language" , "ca" } , { "BAD_CODE" , "El paràmetre de createMessage estava fora dels límits. " } , { "FORMAT_FAILED" , "S'ha generat una excepció durant la crida messageFormat. " } , { "version" , ">>>>>>> Versió Xalan " } , { "version2" , "<<<<<<< " } , { "yes" , "sí" } , { "line" , "Línia núm. " } , { "column" , "Columna núm. " } , { "xsldone" , "XSLProcessor: fet " } , { "xslProc_option" , "Opcions de classe del procés de línia d'ordres de Xalan-J: " } , { "xslProc_option" , "Opcions de classe del procés de línia d'ordres de Xalan-J: " } , { "xslProc_invalid_xsltc_option" , "L''opció {0} no té suport en modalitat XSLTC. " } , { "xslProc_invalid_xalan_option" , "L''opció {0} només es pot fer servir amb -XSLTC. " } , { "xslProc_no_input" , "Error: no s'ha especificat cap full d'estils o xml d'entrada. Per obtenir les instruccions d'ús, executeu aquesta ordre sense opcions. " } , { "xslProc_common_options" , "-Opcions comuns- " } , { "xslProc_xalan_options" , "-Opcions per a Xalan- " } , { "xslProc_xsltc_options" , "-Opcions per a XSLTC- " } , { "xslProc_return_to_continue" , "(premeu <retorn> per continuar) " } , { "optionXSLTC" , "[-XSLTC (Fa servir XSLTC per a la transformació)] " } , { "optionIN" , "[-IN inputXMLURL] " } , { "optionXSL" , "[-XSL XSLTransformationURL] " } , { "optionOUT" , "[-OUT outputFileName] " } , { "optionLXCIN" , "[-LXCIN compiledStylesheetFileNameIn] " } , { "optionLXCOUT" , "[-LXCOUT compiledStylesheetFileNameOutOut] " } , { "optionPARSER" , "[-PARSER nom de classe completament qualificat de la relació de l'analitzador] " } , { "optionE" , "[-E (No amplia les referències d'entitat)] " } , { "optionV" , "[-E (No amplia les referències d'entitat)] " } , { "optionQC" , "[-QC (Avisos de conflictes de patró reduït)] " } , { "optionQ" , "[-Q  (Modalitat reduïda)] " } , { "optionLF" , "[-LF (Utilitza salts de línia només a la sortida {el valor per defecte és CR/LF})] " } , { "optionCR" , "[-CR (Utilitza retorns de carro només a la sortida {el valor per defecte és CR/LF})] " } , { "optionESCAPE" , "[-ESCAPE (Caràcters per aplicar un escapament {el valor per defecte és <>&\"\'\\r\\n}] " } , { "optionINDENT" , "[-INDENT (Controla quants espais tindrà el sagnat {el valor per defecte és 0})] " } , { "optionTT" , "[-TT (Fa un rastreig de les plantilles a mesura que es criden.)] " } , { "optionTG" , "[-TG (Fa un rastreig de cada un dels esdeveniments de generació.)] " } , { "optionTS" , "[-TS (Fa un rastreig de cada un dels esdeveniments de selecció.)] " } , { "optionTTC" , "[-TTC (Fa un rastreig dels subordinats de plantilla a mesura que es processen.)] " } , { "optionTCLASS" , "[-TCLASS (Classe TraceListener per a extensions de rastreig.)] " } , { "optionVALIDATE" , "[-VALIDATE (Estableix si es produeix la validació. Per defecte no està activada.)] " } , { "optionEDUMP" , "[-EDUMP {nom de fitxer opcional} (Fa el buidatge de la pila si es produeix un error.)] " } , { "optionXML" , "[-XML (Utilitza el formatador XML i afegeix la capçalera XML.)] " } , { "optionTEXT" , "[-TEXT (Utilitza el formatador de text simple.)] " } , { "optionHTML" , "[-HTML (Utilitza el formatador HTML.)] " } , { "optionPARAM" , "[-PARAM expressió del nom (Estableix un paràmetre de full d'estils)] " } , { "noParsermsg1" , "El procés XSL no ha estat correcte. " } , { "noParsermsg2" , "** No s'ha trobat l'analitzador ** " } , { "noParsermsg3" , "Comproveu la vostra classpath. " } , { "noParsermsg4" , "Si no teniu XML Parser for Java d'IBM, el podeu baixar d' " } , { "noParsermsg5" , "AlphaWorks d'IBM: http://www.alphaworks.ibm.com/formula/xml " } , { "optionURIRESOLVER" , "[-URIRESOLVER nom de classe complet (URIResolver que s'ha d'utilitzar per resoldre URI)] " } , { "optionENTITYRESOLVER" , "[-ENTITYRESOLVER nom de classe complet (EntityResolver que s'ha d'utilitzar per resoldre entitats)] " } , { "optionCONTENTHANDLER" , "[-CONTENTHANDLER nom de classe complet (ContentHandler que s'ha d'utilitzar per serialitzar la sortida)] " } , { "optionLINENUMBERS" , "[-L utilitza els números de línia del document origen] " } , { "optionMEDIA" , "   [-MEDIA mediaType (Utilitza l'atribut media per trobar un full d'estils relacionat amb un document.)]" } , { "optionFLAVOR" , "   [-FLAVOR flavorName (Utilitza explícitament s2s=SAX o d2d=DOM per fer una transformació.)] " } , { "optionDIAG" , "   [-DIAG (Imprimeix els mil·lisegons en total que ha trigat la transformació.)]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL (sol·licita la construcció de DTM incremental establint http://xml.apache.org/xalan/features/incremental en true.)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE (sol·licita que no es processi l'optimització de full d'estils establint http://xml.apache.org/xalan/features/optimize en false.)]" } , { "optionRL" , "   [-RL recursionlimit (confirma el límit numèric de la profunditat de recursivitat del full d'estils.)]" } , { "optionXO" , "[-XO [nom_translet] (assigna el nom al translet generat)] " } , { "optionXD" , "[-XD directori_destinació (especifica un directori de destinació per al translet)] " } , { "optionXJ" , "[-XJ fitxer_jar (empaqueta les classes de translet en un fitxer jar amb el nom <fitxer_jar>)] " } , { "optionXP" , "[-XP paquet (especifica un prefix de nom de paquet per a totes les classes de translet generades)] " } , { "optionXN" , "[-XN (habilita l'inlining de plantilles)] " } , { "optionXX" , "[-XX (activa la sortida de missatges de depuració addicionals)] " } , { "optionXT" , "[-XT (utilitza el translet per a la transformació si és possible)] " } , { "diagTiming" , "--------- La transformació de {0} mitjançant {1} ha trigat {2} ms " } , { "recursionTooDeep" , "La imbricació de plantilles té massa nivells. Imbricació = {0}, plantilla{1} {2} " } , { "nameIs" , "el nom és " } , { "matchPatternIs" , "el patró de coincidència és " } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Avís: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "ca" , "ES" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xpath . operations ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . QName ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . axes . PathComponent ; import org . apache . xpath . axes . WalkerFactory ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class Variable extends Expression implements PathComponent { private boolean m_fixUpWasCalled = false ; protected QName m_qname ; protected int m_index ; public void setIndex ( int index ) { m_index = index ; } public int getIndex ( ) { return m_index ; } public void setIsGlobal ( boolean isGlobal ) { m_isGlobal = isGlobal ; } public boolean getGlobal ( ) { return m_isGlobal ; } protected boolean m_isGlobal = false ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_fixUpWasCalled = true ; int sz = vars . size ( ) ; for ( int i = vars . size ( ) - 1 ; i >= 0 ; i -- ) { QName qn = ( QName ) vars . elementAt ( i ) ; if ( qn . equals ( m_qname ) ) { if ( i < globalsSize ) { m_isGlobal = true ; m_index = i ; } else { m_index = i - globalsSize ; } return ; } } java . lang . String msg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_COULD_NOT_FIND_VAR , new Object [ ] { m_qname . toString ( ) } ) ; TransformerException te = new TransformerException ( msg , this ) ; throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } public void setQName ( QName qname ) { m_qname = qname ; } public QName getQName ( ) { return m_qname ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt , false ) ; } public XObject execute ( XPathContext xctxt , boolean destructiveOK ) throws javax . xml . transform . TransformerException { org . apache . xml . utils . PrefixResolver xprefixResolver = xctxt . getNamespaceContext ( ) ; if ( m_fixUpWasCalled ) { XObject result ; if ( m_isGlobal ) result = xctxt . getVarStack ( ) . getGlobalVariable ( xctxt , m_index , destructiveOK ) ; else result = xctxt . getVarStack ( ) . getLocalVariable ( xctxt , m_index , destructiveOK ) ; if ( null == result ) { warn ( xctxt , XPATHErrorResources . WG_ILLEGAL_VARIABLE_REFERENCE , new Object [ ] { m_qname . getLocalPart ( ) } ) ; result = new XNodeSet ( xctxt . getDTMManager ( ) ) ; } return result ; } else { synchronized ( this ) { org . apache . xalan . templates . ElemVariable vvar = getElemVariable ( ) ; if ( null != vvar ) { m_index = vvar . getIndex ( ) ; m_isGlobal = vvar . getIsTopLevel ( ) ; m_fixUpWasCalled = true ; return execute ( xctxt ) ; } } throw new javax . xml . transform . TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VAR_NOT_RESOLVABLE , new Object [ ] { m_qname . toString ( ) } ) ) ; } } public org . apache . xalan . templates . ElemVariable getElemVariable ( ) { org . apache . xpath . ExpressionNode owner = getExpressionOwner ( ) ; if ( null != owner && owner instanceof org . apache . xalan . templates . ElemTemplateElement ) { org . apache . xalan . templates . ElemVariable vvar ; org . apache . xalan . templates . ElemTemplateElement prev = ( org . apache . xalan . templates . ElemTemplateElement ) owner ; if ( ! ( prev instanceof org . apache . xalan . templates . Stylesheet ) ) { while ( ! ( prev . getParentNode ( ) instanceof org . apache . xalan . templates . Stylesheet ) ) { org . apache . xalan . templates . ElemTemplateElement savedprev = prev ; while ( null != ( prev = prev . getPreviousSiblingElem ( ) ) ) { if ( prev instanceof org . apache . xalan . templates . ElemVariable ) { vvar = ( org . apache . xalan . templates . ElemVariable ) prev ; if ( vvar . getName ( ) . equals ( m_qname ) ) { return vvar ; } } } prev = savedprev . getParentElem ( ) ; } } vvar = prev . getStylesheetRoot ( ) . getVariableOrParamComposed ( m_qname ) ; if ( null != vvar ) { return vvar ; } } return null ; } public boolean isStableNumber ( ) { return true ; } public int getAnalysisBits ( ) { org . apache . xalan . templates . ElemVariable vvar = getElemVariable ( ) ; if ( null != vvar ) { XPath xpath = vvar . getSelect ( ) ; if ( null != xpath ) { Expression expr = xpath . getExpression ( ) ; if ( null != expr && expr instanceof PathComponent ) { return ( ( PathComponent ) expr ) . getAnalysisBits ( ) ; } } } return WalkerFactory . BIT_FILTER ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { visitor . visitVariableRef ( owner , this ) ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! m_qname . equals ( ( ( Variable ) expr ) . m_qname ) ) return false ; if ( getElemVariable ( ) != ( ( Variable ) expr ) . getElemVariable ( ) ) return false ; return true ; } static final java . lang . String PSUEDOVARNAMESPACE = "http://xml.apache.org/xalan/psuedovar" ; public boolean isPsuedoVarRef ( ) { java . lang . String ns = m_qname . getNamespaceURI ( ) ; if ( ( null != ns ) && ns . equals ( PSUEDOVARNAMESPACE ) ) { if ( m_qname . getLocalName ( ) . startsWith ( "#" ) ) return true ; } return false ; } } 	1	['16', '2', '1', '26', '51', '50', '8', '19', '16', '0.746666667', '356', '0.8', '1', '0.666666667', '0.1875', '2', '10', '20.9375', '9', '2.25', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_hu extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "A current() függvény nem megengedett az illesztési mintában!" } , { ER_CURRENT_TAKES_NO_ARGS , "A current() függvény nem fogad el argumentumokat!" } , { ER_DOCUMENT_REPLACED , "A document() függvény megvalósítását lecserélte az org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "A környezetnek nincs tulajdonos dokumentuma!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "A local-name()-nek túl sok argumentuma van." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "A namespace-uri()-nek túl sok argumentuma van." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "A normalize-space()-nek túl sok argumentuma van." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "A number()-nek túl sok argumentuma van." } , { ER_NAME_HAS_TOO_MANY_ARGS , "A name()-nek túl sok argumentuma van." } , { ER_STRING_HAS_TOO_MANY_ARGS , "A string()-nek túl sok argumentuma van." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "A string-length()-nek túl sok argumentuma van." } , { ER_TRANSLATE_TAKES_3_ARGS , "A translate() függvény három argumentumot kér!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "Az unparsed-entity-uri függvényhez egy argumentum szükséges!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "A névtér tengely még nincs magvalósítva!" } , { ER_UNKNOWN_AXIS , "Ismeretlen tengely: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "ismeretlen illesztési művelet!" } , { ER_INCORRECT_ARG_LENGTH , "A processing-instruction() csomópont teszt argumentumának hossza helytelen!" } , { ER_CANT_CONVERT_TO_NUMBER , "A(z) {0} nem konvertálható számmá" } , { ER_CANT_CONVERT_TO_NODELIST , "A(z) {0} nem konvertálható NodeList-té!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "A(z) {0} nem konvertálható NodeSetDTM-mé!" } , { ER_CANT_CONVERT_TO_TYPE , "{0} nem konvertálható type#{1} típussá" } , { ER_EXPECTED_MATCH_PATTERN , "Illesztési mintát vártunk a getMatchScore-ban!" } , { ER_COULDNOT_GET_VAR_NAMED , "Nem lehet lekérni a(z) {0} nevű változót" } , { ER_UNKNOWN_OPCODE , "HIBA! Ismeretlen opkód: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Extra tiltott tokenek: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "rosszul idézett literál... dupla idézőjelet vártunk!" } , { ER_EXPECTED_SINGLE_QUOTE , "rosszul idézett literál... szimpla idézőjelet vártunk!" } , { ER_EMPTY_EXPRESSION , "Üres kifejezés!" } , { ER_EXPECTED_BUT_FOUND , "{0}-t vártunk, de ezt találtuk: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "A programozó feltevése hibás! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "A boolean(...) argumentuma többé nem opcionális az 19990709 XPath vázlat szerint." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "','-t találtunk, de nincs előtte argumentum!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "','-t találtunk, de nincs utána argumentum!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "A '..[feltétel]' vagy '.[feltétel]' szintaktika tiltott.  Használja inkább a 'self::node()[predicate]' definíciót." } , { ER_ILLEGAL_AXIS_NAME , "Tiltott tengelynév: {0}" } , { ER_UNKNOWN_NODETYPE , "Ismeretlen node-típus: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "A minta-literált ({0}) idézőjelek közé kell tenni!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "A(z) {0} nem formázható számmá!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Nem lehet XML TransformerFactory Liaison-t létrehozni: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Hiba! Az xpath kiválasztási kifejezés nem található (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "HIBA! Nem található ENDOP az OP_LOCATIONPATH után" } , { ER_ERROR_OCCURED , "Hiba történt!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "A változóra adott VariableReference (változóhivatkozás) kívül van a környezeten vagy nincs definíciója!  Név = {0}" } , { ER_AXES_NOT_ALLOWED , "Csak a child:: és az attribute:: tengelyek illeszkedhetnek mintákra.  Zavaró tengelyek = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "A key()-nek nem megfelelő számú argumentuma van." } , { ER_COUNT_TAKES_1_ARG , "A count függvényhez csak egy argumentumot lehet megadni!" } , { ER_COULDNOT_FIND_FUNCTION , "Nem található a függvény: {0}" } , { ER_UNSUPPORTED_ENCODING , "Nem támogatott kódolás: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Probléma merült fel a DTM-ben a getNextSibling-ben... megpróbáljuk helyrehozni" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Programozói hiba: az EmptyNodeList-be (üres csomópontlistába) nem lehet írni." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "A setDOMFactory-t nem támogatja az XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Az előtagnak egy névtérre kell feloldódnia: {0}" } , { ER_PARSE_NOT_SUPPORTED , "Az elemés (InputSource forrás) nem támogatott az XPathContext-ben! Nem lehet megnyitni a(z) {0}-t" } , { ER_SAX_API_NOT_HANDLED , "SAX API characters(char ch[]... függvényt nem kezeli a DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "Az ignorableWhitespace(char ch[]... függvényt nem kezeli a DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "A DTMLiaison nem tud {0} típusú csomópontokat kezelni" } , { ER_XERCES_CANNOT_HANDLE_NODES , "A DOM2Helper nem tud {0} típusú csomópontokat kezelni" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse hiba: SystemID - {0} sor - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse hiba" } , { ER_INVALID_UTF16_SURROGATE , "Érvénytelen UTF-16 helyettesítés: {0} ?" } , { ER_OIERROR , "IO hiba" } , { ER_CANNOT_CREATE_URL , "Nem lehet URL-t létrehozni ehhez: {0}" } , { ER_XPATH_READOBJECT , "A XPath.readObject metódusban: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "A függvény jelsor nem található." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Nem lehet megbirkózni az XPath típussal: {0}" } , { ER_NODESET_NOT_MUTABLE , "Ez a NodeSet nem illeszthető be" } , { ER_NODESETDTM_NOT_MUTABLE , "Ez a NodeSetDTM nem illeszthető be" } , { ER_VAR_NOT_RESOLVABLE , "A változó nem oldható fel: {0}" } , { ER_NULL_ERROR_HANDLER , "Null hibakezelő" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Programozói értesítés: ismeretlen műveletkód: {0}" } , { ER_ZERO_OR_ONE , "0 vagy 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "Az rtf()-et nem támogatja az XRTreeFragSelectWrapper" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "Az asNodeIterator()-t nem támogatja az XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "Az fsb() nem támogatott az XStringForChars-nál" } , { ER_COULD_NOT_FIND_VAR , "Nem található {0} nevű változó" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "Az XStringForChars-nak nem adhat meg karakterlánc argumentumot" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "A FastStringBuffer argumentum nem lehet null" } , { ER_TWO_OR_THREE , "2 vagy 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Változóelérés értékadás előtt!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB nem kaphat sztring argumentumot!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Hiba! A bejáró gyökerét null-ra állította!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Ez a NodeSetDTM nem iterálhat egy korábbi node-ra!" } , { ER_NODESET_CANNOT_ITERATE , "Ez a NodeSet nem iterálhat egy korábbi node-ra!" } , { ER_NODESETDTM_CANNOT_INDEX , "Ez a NodeSetDTM nem indexelhet és nem számlálhatja a funkciókat!" } , { ER_NODESET_CANNOT_INDEX , "Ez a NodeSet nem indexelhet és nem számlálhatja a funkciókat!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Nem hívható setShouldCacheNodes nextNode hívása után!" } , { ER_ONLY_ALLOWS , "{0} csak {1} argumentumot engedélyez" } , { ER_UNKNOWN_STEP , "Programozói értesítés getNextStepPos hívásban: ismeretlen stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Egy relatív elhelyezési útvonalat vártunk a '/' vagy '//' token után." } , { ER_EXPECTED_LOC_PATH , "Egy hely útvonalat vártam, de a következő tokent találtam:  {0}" } , { ER_EXPECTED_LOC_STEP , "Egy elhelyezési lépést vártunk a '/' vagy '//' token után." } , { ER_EXPECTED_NODE_TEST , "Egy olyan node-tesztet vártunk, ami vagy az NCName:*-ra vagy a QName-re illeszkedik." } , { ER_EXPECTED_STEP_PATTERN , "Egy lépésmintát vártunk, de '/' szerepelt." } , { ER_EXPECTED_REL_PATH_PATTERN , "Relatív útvonalat vártunk." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Nem lehet {0}-t logikaivá konvertálni." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Nem lehet {0}-t egyszerű node-dá konvertálni. Ez a fordító az ANY_UNORDERED_NODE_TYPE és a FIRST_ORDERED_NODE_TYPE típusokra használható." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Nem lehet megkapni a pillanatkép hosszát a következő típusra: {0}. Ez a fordító az UNORDERED_NODE_SNAPSHOT_TYPE és az ORDERED_NODE_SNAPSHOT_TYPE típusokra használható." } , { ER_NON_ITERATOR_TYPE , "Nem lehet iterálni nem iterátor típust: {0}" } , { ER_DOC_MUTATED , "A dokumentum megváltozott, mióta az eredmény visszatért. Az iterátor érvénytelen." } , { ER_INVALID_XPATH_TYPE , "Érvénytelen XPath típus-argumentum: {0}" } , { ER_EMPTY_XPATH_RESULT , "Üres XPath eredményobjektum" } , { ER_INCOMPATIBLE_TYPES , "A visszadott típus: {0} nem lehet a megadott típussá változtatni: {1}" } , { ER_NULL_RESOLVER , "Nem lehet feloldani a prefixet null prefix-feloldóval." } , { ER_CANT_CONVERT_TO_STRING , "Nem lehet {0} típust sztringgé konvertálni." } , { ER_NON_SNAPSHOT_TYPE , "Nem lehet snapshotItem-et hívni a következő típusra: {0}. Ez a metódust az UNORDERED_NODE_SNAPSHOT_TYPE és ORDERED_NODE_SNAPSHOT_TYPE típusokra alkalmazható." } , { ER_WRONG_DOCUMENT , "A környezeti node nem az XPathEvaluator-hoz tartozó dokumentumhoz tartozik." } , { ER_WRONG_NODETYPE , "A környezeti node típusa nem támogatott." } , { ER_XPATH_ERROR , "Ismeretlen hiba az XPath-ban." } , { WG_LOCALE_NAME_NOT_HANDLED , "A locale-név a format-number függvényben még nincs kezelve!" } , { WG_PROPERTY_NOT_SUPPORTED , "Az XSL tulajdonság nem támogatott: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Jelenleg ne tegyen semmit a(z) {0} névtérrel a tulajdonságban: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException az XSL rendszertulajdonság elérésénél: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "A régi szintaktika: quo(...) többé nincs definiálva az XPath-ban." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "Az XPath-nak kell egy származtatott objektum a nodeTest-hez!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "A függvény jelsor nem található." } , { WG_COULDNOT_FIND_FUNCTION , "Nem található a függvény: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Nem készíthető URL ebből: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "A -E opció nem támogatott a DTM elemzőhöz" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "A változóra adott VariableReference (változóhivatkozás) kívül van a környezeten vagy nincs definíciója!  Név = {0}" } , { WG_UNSUPPORTED_ENCODING , "Nem támogatott kódolás: {0}" } , { "ui_language" , "hu" } , { "help_language" , "hu" } , { "language" , "hu" } , { "BAD_CODE" , "A createMessage paramétere nincs a megfelelő tartományban" } , { "FORMAT_FAILED" , "Kivétel történt a messageFormat hívás alatt" } , { "version" , ">>>>>>> Xalan verzió " } , { "version2" , "<<<<<<<" } , { "yes" , "igen" } , { "line" , "Sor #" } , { "column" , "Oszlop #" } , { "xsldone" , "XSLProcessor: kész" } , { "xpath_option" , "xpath opciói: " } , { "optionIN" , "   [-in bemenetiXMLURL]" } , { "optionSelect" , "   [-select xpath kifejezés]" } , { "optionMatch" , "   [-match illesztési minta (az illesztési diagnosztikához)]" } , { "optionAnyExpr" , "Vagy csak egy xpath kifejezés megcsinál egy diagnosztikai dump-ot" } , { "noParsermsg1" , "Az XSL processz sikertelen volt." } , { "noParsermsg2" , "** Az elemző nem található **" } , { "noParsermsg3" , "Kérem, ellenőrizze az osztály elérési utat." } , { "noParsermsg4" , "Ha önnek nincs meg az IBM Java XML elemzője, akkor letöltheti az" } , { "noParsermsg5" , "az IBM AlphaWorks weblapról: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Hiba: " ; public static final String WARNING_HEADER = "Figyelmeztetés: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MINTA " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "hu" , "HU" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_cs extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Chyba: Ve výrazu nelze použít znak '{'" } , { ER_ILLEGAL_ATTRIBUTE , "{0} má neplatný atribut: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "Funkce sourceNode má v prvku xsl:apply-imports hodnotu null!" } , { ER_CANNOT_ADD , "Nelze přidat {0} do {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "Funkce sourceNode má v instrukci handleApplyTemplatesInstruction hodnotu null!" } , { ER_NO_NAME_ATTRIB , "{0} musí mít jmenný atribut" } , { ER_TEMPLATE_NOT_FOUND , "Nelze nalézt šablonu s názvem: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Nelze nalézt název AVT v šabloně xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} musí mít atribut: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} musí obsahovat atribut ''test''." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Nesprávná hodnota atributu úrovně: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "název instrukce processing-instruction nemůže být 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "název instrukce processing-instruction musí být platný název NCName: {0}" } , { ER_NEED_MATCH_ATTRIB , "Má-li {0} režim, musí mít vyhovující atribut." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} vyžaduje buď název, nebo vyhovující atribut." } , { ER_CANT_RESOLVE_NSPREFIX , "Nelze přeložit předponu oboru názvů: {0}" } , { ER_ILLEGAL_VALUE , "Nepovolená hodnota prvku xml:space: {0}" } , { ER_NO_OWNERDOC , "Uzel potomka nemá dokument vlastníka!" } , { ER_ELEMTEMPLATEELEM_ERR , "Chyba funkce ElemTemplateElement: {0}" } , { ER_NULL_CHILD , "Pokus o přidání potomka s hodnotou null!" } , { ER_NEED_SELECT_ATTRIB , "{0} vyžaduje atribut select." } , { ER_NEED_TEST_ATTRIB , "Prvek xsl:when musí obsahovat atribut 'test'." } , { ER_NEED_NAME_ATTRIB , "Prvek xsl:with-param musí obsahovat atribut 'name'." } , { ER_NO_CONTEXT_OWNERDOC , "Parametr context nemá dokument vlastníka!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Nelze vytvořit prvek XML TransformerFactory Liaison: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: Proces nebyl úspěšný." } , { ER_NOT_SUCCESSFUL , "Xalan: nebylo úspěšné." } , { ER_ENCODING_NOT_SUPPORTED , "Kódování není podporováno: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Nelze vytvořit TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "Prvek xsl:key vyžaduje atribut 'name'!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "Prvek xsl:key vyžaduje atribut 'match'!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "Prvek xsl:key vyžaduje atribut 'use'!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} vyžaduje atribut ''elements''!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} - chybí atribut ''prefix''" } , { ER_BAD_STYLESHEET_URL , "Nesprávná adresa URL předlohy se styly: {0}" } , { ER_FILE_NOT_FOUND , "Soubor předlohy se styly nebyl nalezen: {0}" } , { ER_IOEXCEPTION , "Soubor předlohy se styly má výjimku vstupu/výstupu: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Pro {0} nelze najít atribut href" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0}: přímo nebo nepřímo zahrnuje sebe sama!" } , { ER_PROCESSINCLUDE_ERROR , "Chyba: StylesheetHandler.processInclude {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} - chybí atribut ''lang''" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) Nesprávně umístěný prvek {0}?? Chybí prvek pořadače ''component''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "U atributů Element, DocumentFragment, Document a PrintWriter lze volat pouze výstup." } , { ER_PROCESS_ERROR , "Chyba: StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "Chyba: UnImplNode: {0}" } , { ER_NO_SELECT_EXPRESSION , "Chyba! Nebyl nalezen výraz výběru xpath (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Nelze serializovat XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "Nebyl zadán vstup předlohy se styly!" } , { ER_FAILED_PROCESS_STYLESHEET , "Nepodařilo se zpracovat předlohu se styly!" } , { ER_COULDNT_PARSE_DOC , "Nelze analyzovat dokument {0}!" } , { ER_COULDNT_FIND_FRAGMENT , "Nelze nalézt fragment: {0}" } , { ER_NODE_NOT_ELEMENT , "Uzel, na který odkazuje identifikátor fragmentu, není prvek: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "atribut for-each musí mít buď shodu nebo název atributu" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "atribut templates musí mít buď shodu nebo název atributu" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Žádný klon fragmentu dokumentu!" } , { ER_CANT_CREATE_ITEM , "Ve stromu výsledků nelze vytvořit položku: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "Parametr xml:space ve zdrojovém XML má neplatnou hodnotu: {0}" } , { ER_NO_XSLKEY_DECLARATION , "{0} nemá deklarován žádný parametr xsl:key!" } , { ER_CANT_CREATE_URL , "Chyba! Nelze vytvořit url pro: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "Nepodporovaná funkce xsl:functions" } , { ER_PROCESSOR_ERROR , "Chyba: XSLT TransformerFactory" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} - není v rámci předlohy se styly povoleno!" } , { ER_RESULTNS_NOT_SUPPORTED , "Parametr result-ns již není podporován! Místo toho použijte parametr xsl:output." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "Parametr default-space již není podporován! Místo toho použijte parametr xsl:strip-space nebo xsl:preserve-space." } , { ER_INDENTRESULT_NOT_SUPPORTED , "Parametr indent-result již není podporován! Místo toho použijte parametr xsl:output." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} má neplatný atribut: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Neznámý prvek XSL: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) Parametr xsl:sort lze použít pouze s parametrem xsl:apply-templates nebo xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) Nesprávně umístěný prvek xsl:when!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) Prvkek xsl:when nemá v parametru xsl:choose žádného rodiče!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) Nesprávně umístěný prvek xsl:otherwise!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) Prvek xsl:otherwise nemá v parametru xsl:choose žádného rodiče!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} - není v rámci šablony povoleno!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0}: neznámá předpona {1} přípony oboru názvů" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Importy musí být v rámci šablony se styly na prvních místech!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0}: přímo nebo nepřímo importuje samo sebe!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) Parametr xml:space má neplatnou hodnotu: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "Neúspěšný proces processStylesheet!" } , { ER_SAX_EXCEPTION , "Výjimka SAX" } , { ER_XSLT_ERROR , "Chyba XSLT" } , { ER_CURRENCY_SIGN_ILLEGAL , "znak měny není v řetězci vzorku formátu povolen" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Funkce Document není v předloze se styly DOM podporována!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Nelze přeložit předponu překladače non-Prefix!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Přesměrování přípony: Nelze získat název souboru - atribut file nebo select musí vrátit platný řetězec." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "V příponě Redirect nelze vytvořit FormatterListener!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Neplatná předpona ve funkci exclude-result-prefixes: {0}" } , { ER_MISSING_NS_URI , "U zadané předpony chybí obor názvů URI" } , { ER_MISSING_ARG_FOR_OPTION , "Chybějící argument volby: {0}" } , { ER_INVALID_OPTION , "Neplatná volba: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Vadný formátovací řetězec: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "Prvek xsl:stylesheet vyžaduje atribut 'version'!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Parametr Attribute: {0} má neplatnou hodnotu: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "Prvek xsl:choose vyžaduje parametr xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "Parametr xsl:for-each není v xsl:apply-imports povolen" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Nelze použít DTMLiaison u výstupu uzlu DOM node... Místo toho použijte org.apache.xpath.DOM2Helper!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Nelze použít DTMLiaison u vstupu uzlu DOM node... Místo toho použijte org.apache.xpath.DOM2Helper!" } , { ER_CALL_TO_EXT_FAILED , "Neúspěšné volání prvku přípony: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Předponu musí být možno přeložit do oboru názvů: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Byla zjištěna neplatná náhrada UTF-16: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "Prvek xsl:attribute-set {0} používá sám sebe, což způsobí nekonečnou smyčku." } , { ER_CANNOT_MIX_XERCESDOM , "Vstup Xerces-DOM nelze směšovat s výstupem Xerces-DOM!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "V ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Nalezena více než jedna šablona s názvem: {0}" } , { ER_INVALID_KEY_CALL , "Neplatné volání funkce: rekurzivní volání funkce key() není povoleno" } , { ER_REFERENCING_ITSELF , "Proměnná {0} odkazuje přímo či nepřímo sama na sebe!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Vstupní uzel DOMSource pro newTemplates nesmí mít hodnotu null!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Nebyl nalezen soubor třídy pro volbu {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Nebyl nalezen požadovaný prvek: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "Parametr InputStream nesmí mít hodnotu null" } , { ER_URI_CANNOT_BE_NULL , "Parametr URI nesmí mít hodnotu null" } , { ER_FILE_CANNOT_BE_NULL , "Parametr File nesmí mít hodnotu null" } , { ER_SOURCE_CANNOT_BE_NULL , "Parametr InputSource nesmí mít hodnotu null" } , { ER_CANNOT_INIT_BSFMGR , "Nelze inicializovat BSF Manager" } , { ER_CANNOT_CMPL_EXTENSN , "Příponu nelze kompilovat" } , { ER_CANNOT_CREATE_EXTENSN , "Nelze vytvořit příponu: {0}, protože: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "Volání metody {0} metodou Instance vyžaduje jako první argument instanci Object" } , { ER_INVALID_ELEMENT_NAME , "Byl zadán neplatný název prvku {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Název metody prvku musí být static {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Funkce výjimky {0} : {1} je neznámá" } , { ER_MORE_MATCH_CONSTRUCTOR , "Konstruktor {0} má více nejlepších shod." } , { ER_MORE_MATCH_METHOD , "Metoda {0} má více nejlepších shod." } , { ER_MORE_MATCH_ELEMENT , "Metoda prvku {0} má více nejlepších shod." } , { ER_INVALID_CONTEXT_PASSED , "Do vyhodnocení byl předán neplatný kontext {0}." } , { ER_POOL_EXISTS , "Společná oblast již existuje." } , { ER_NO_DRIVER_NAME , "Nebylo zadáno žádné jméno ovladače." } , { ER_NO_URL , "Nebyla specifikována žádná adresa URL." } , { ER_POOL_SIZE_LESSTHAN_ONE , "Velikost společné oblasti je menší než jedna!" } , { ER_INVALID_DRIVER , "Byl zadán neplatný název ovladače!" } , { ER_NO_STYLESHEETROOT , "Nebyl nalezen kořen předlohy se styly!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Neplatná hodnota parametru xml:space" } , { ER_PROCESSFROMNODE_FAILED , "Selhání procesu processFromNode" } , { ER_RESOURCE_COULD_NOT_LOAD , "Nelze zavést zdroj [ {0} ]: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Velikost vyrovnávací paměti <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Při volání přípony došlo k neznámé chybě" } , { ER_NO_NAMESPACE_DECL , "Předpona {0} nemá deklarován odpovídající obor názvů" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Obsah prvku není povolen pro lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Ukončení směrované na předlohu se styly." } , { ER_ONE_OR_TWO , "1 nebo 2" } , { ER_TWO_OR_THREE , "2 nebo 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Nelze zavést {0} (zkontrolujte proměnnou CLASSPATH) - proto se používají pouze výchozí hodnoty" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Nelze aktualizovat výchozí šablony." } , { ER_RESULT_NULL , "Výsledek by neměl mít hodnotu null" } , { ER_RESULT_COULD_NOT_BE_SET , "Nelze nastavit výsledek" } , { ER_NO_OUTPUT_SPECIFIED , "Nebyl určen žádný výstup" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Nelze převést na výsledek typu {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Nelze převést na zdroj typu {0}" } , { ER_NULL_CONTENT_HANDLER , "Obslužný program obsahu hodnoty null" } , { ER_NULL_ERROR_HANDLER , "Obslužný program pro zpracování chyb hodnoty null" } , { ER_CANNOT_CALL_PARSE , "Není-li nastaven obslužný program ContentHandler, nelze volat analyzátor." } , { ER_NO_PARENT_FOR_FILTER , "Filtr nemá rodiče." } , { ER_NO_STYLESHEET_IN_MEDIA , "Nebyla nalezena předloha se styly v: {0}, médium= {1}" } , { ER_NO_STYLESHEET_PI , "Nebyla nalezena předloha se styly xml-stylesheet PI v: {0}" } , { ER_NOT_SUPPORTED , "Nepodporováno: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Hodnota vlastnosti {0} by měla být booleovská instance" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "Z {0} nelze získat externí skript." } , { ER_RESOURCE_COULD_NOT_FIND , "Nelze najít zdroj [ {0} ].\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Neznámá vlastnost výstupu: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Nepodařilo se vytvořit instanci ElemLiteralResult" } , { ER_VALUE_SHOULD_BE_NUMBER , "Hodnota pro {0} by měla obsahovat analyzovatelné číslo" } , { ER_VALUE_SHOULD_EQUAL , "Hodnota {0} musí být yes nebo no." } , { ER_FAILED_CALLING_METHOD , "Volání metody {0} selhalo." } , { ER_FAILED_CREATING_ELEMTMPL , "Nepodařilo se vytvořit instanci ElemTemplateElement." } , { ER_CHARS_NOT_ALLOWED , "V této části dokumentu nejsou znaky povoleny." } , { ER_ATTR_NOT_ALLOWED , "Atribut \"{0}\" není u prvku {1} povolen!" } , { ER_BAD_VALUE , "{0}: nesprávná hodnota {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "Atribut hodnoty ({0}) nebyl nalezen " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "Atribut hodnoty ({0}) nebyl rozpoznán " } , { ER_NULL_URI_NAMESPACE , "Pokus o generování oboru názvů s URI s hodnotou null." } , { ER_NUMBER_TOO_BIG , "Pokus o formátování většího čísla, než je největší dlouhé celé číslo." } , { ER_CANNOT_FIND_SAX1_DRIVER , "Nelze najít třídu ovladače SAX1  {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "Třída ovladače SAX1 {0} byla nalezena, ale nebylo možno ji zavést." } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "Třída ovladače SAX1 {0} byla nalezena, ale nebylo možno s ní založit instanci." } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "Třída ovladače SAX1 {0} neimplementuje org.xml.sax.Parser." } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Nebyla určena vlastnost systému org.xml.sax.parser." } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Argument analyzátoru nesmí mít hodnotu null." } , { ER_FEATURE , "Funkce: {0}" } , { ER_PROPERTY , "Vlastnost: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Řešitel s hodnotou entity null" } , { ER_NULL_DTD_HANDLER , "Obslužný program DTD s hodnotou null" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Nebyl zadán název ovladače!" } , { ER_NO_URL_SPECIFIED , "Nebyla specifikována adresa URL!" } , { ER_POOLSIZE_LESS_THAN_ONE , "Velikost společné oblasti je menší než 1!" } , { ER_INVALID_DRIVER_NAME , "Zadán neplatný název ovladače!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Chyba programátora! Výraz nemá rodiče ElemTemplateElement!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Tvrzení programátora v RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} - není povoleno v tomto stylu na daném místě!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Neprázdný text není povolen v tomto stylu na daném místě!" } , { INVALID_TCHAR , "Neplatná hodnota: {1} použito pro atribut CHAR: {0}. Atribut typu CHAR smí mít pouze jeden znak." } , { INVALID_QNAME , "Neplatná hodnota: {1} použito pro atribut QNAME: {0}" } , { INVALID_ENUM , "Neplatná hodnota: {1} použito pro atribut ENUM {0}. Platné hodnoty jsou: {2}." } , { INVALID_NMTOKEN , "Neplatná hodnota: {1} použito pro atribut NMTOKEN: {0} " } , { INVALID_NCNAME , "Neplatná hodnota: {1} použito pro atribut NCNAME: {0} " } , { INVALID_BOOLEAN , "Neplatná hodnota: {1} použito pro booleovský atribut: {0} " } , { INVALID_NUMBER , "Neplatná hodnota: {1} použito pro atribut čísla: {0} " } , { ER_ARG_LITERAL , "Argument pro {0} ve vyhovujícím vzorku musí být typu literal." } , { ER_DUPLICATE_GLOBAL_VAR , "Duplicitní deklarace globální proměnné." } , { ER_DUPLICATE_VAR , "Duplicitní deklarace proměnné." } , { ER_TEMPLATE_NAME_MATCH , "Prvek xsl:template musí mít název nebo odpovídající atribut (nebo obojí)" } , { ER_INVALID_PREFIX , "Neplatná předpona ve funkci exclude-result-prefixes: {0}" } , { ER_NO_ATTRIB_SET , "sada atributů pojmenovaná {0} neexistuje" } , { WG_FOUND_CURLYBRACE , "Byl nalezen znak '}', ale není otevřena žádná šablona atributu!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Varování: čítač atributu se neshoduje s předchůdcem v xsl:number! Cíl = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Stará syntaxe: Název atributu 'expr' byl změněn na 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan ještě neobsluhuje název národního prostředí ve funkci format-number." } , { WG_LOCALE_NOT_FOUND , "Varování: Nebylo nalezeno národní prostředí pro parametr xml:lang={0}" } , { WG_CANNOT_MAKE_URL_FROM , "Nelze vytvořit adresu URL z: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Požadovaný dokument nelze načíst: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Nelze najít funkci Collator pro <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Stará syntaxe: instrukce funkcí by měla používat adresu url {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "nepodporované kódování: {0}, použito kódování UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "nepodporované kódování: {0}, použita Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Byl nalezen konflikt specifičnosti: {0} Bude použit naposledy nalezený výskyt z předlohy se styly." } , { WG_PARSING_AND_PREPARING , "========= Analýza a příprava {0} ==========" } , { WG_ATTR_TEMPLATE , "Šablona atributů, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Konflikt souladu funkcí xsl:strip-space a xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan prozatím neobsluhuje atribut {0}!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "U desetinného formátu nebyla nalezena žádná deklarace: {0}" } , { WG_OLD_XSLT_NS , "Chybějící nebo nesprávný obor názvů XSLT. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Povolena je pouze výchozí deklarace prvku xsl:decimal-format." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "Názvy prvků xsl:decimal-format musí být jedinečné. Byla vytvořena kopie názvu \"{0}\"." } , { WG_ILLEGAL_ATTRIBUTE , "{0} má neplatný atribut: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Nelze přeložit předponu oboru názvů: {0}. Uzel bude ignorován." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "Prvek xsl:stylesheet vyžaduje atribut 'version'!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Neplatný název atributu: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "V atributu {0} byla použita neplatná hodnota: {1}" } , { WG_EMPTY_SECOND_ARG , "Výsledné nastavení uzlu z druhého argumentu dokumentu je prázdné. Vrátí se prázdná sada uzlů." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Hodnota atributu 'name' názvu prvku xsl:processing-instruction nesmí být 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Hodnota atributu 'name' instrukce xsl:processing-instruction musí být platným názvem NCName: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Nelze přidat atribut {0} po uzlech potomků ani před tím, než je vytvořen prvek. Atribut bude ignorován." } , { "ui_language" , "cs" } , { "help_language" , "cs" } , { "language" , "cs" } , { "BAD_CODE" , "Parametr funkce createMessage je mimo limit" } , { "FORMAT_FAILED" , "Při volání funkce messageFormat došlo k výjimce" } , { "version" , ">>>>>>> Verze Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "ano" } , { "line" , "Řádek #" } , { "column" , "Sloupec #" } , { "xsldone" , "XSLProcessor: hotovo" } , { "xslProc_option" , "Příkazový řádek Xalan-J: Zpracování voleb třídy:" } , { "xslProc_option" , "Příkazový řádek Xalan-J: Zpracování voleb třídy:" } , { "xslProc_invalid_xsltc_option" , "Volba {0} není v režimu XSLTC podporovaná." } , { "xslProc_invalid_xalan_option" , "Volba {0} může být použita pouze s -XSLTC." } , { "xslProc_no_input" , "Chyba: Žádná předloha stylu ani vstup xml nejsou určeny. K zobrazení pokynů spusťte tento příkaz bez jakékoliv volby." } , { "xslProc_common_options" , "-Obecné volby-" } , { "xslProc_xalan_options" , "-Volby pro Xalan-" } , { "xslProc_xsltc_options" , "-Volby pro XSLTC-" } , { "xslProc_return_to_continue" , "(pokračujte stisknutím klávesy <Enter>)" } , { "optionXSLTC" , "   [-XSLTC (použije XSLTC pro transformaci)]" } , { "optionIN" , "   [-IN inputXMLURL]" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER plně kvalifikovaný název třídy spojení analyzátoru]" } , { "optionE" , "   [-E (nerozšiřovat odkazy entity)]" } , { "optionV" , "   [-E (nerozšiřovat odkazy entity)]" } , { "optionQC" , "   [-QC (varování před konflikty vzorkování v tichém režimu)]" } , { "optionQ" , "   [-Q  (tichý režim)]" } , { "optionLF" , "   [-LF (ve výstupu použít pouze řádkování - LF {výchozí nastavení je CR/LF})]" } , { "optionCR" , "   [-CR (ve výstupu použít pouze znak nový řádek - CR {výchozí nastavení je CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (nastavení znaků escape sekvence {výchozí nastavení je <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (ovlivňuje počet znaků odsazení {výchozí nastavení je 0})]" } , { "optionTT" , "   [-TT (trasuje šablony při volání)]" } , { "optionTG" , "   [-TG (trasuje všechny události generování)]" } , { "optionTS" , "   [-TS (trasuje všechny události výběru)]" } , { "optionTTC" , "   [-TTC (trasuje potomky šablony v průběhu jejich zpracování)]" } , { "optionTCLASS" , "   [-TCLASS (třída TraceListener přípon trasování)]" } , { "optionVALIDATE" , "   [-VALIDATE (zapíná/vypíná validaci;  výchozí nastavení je vypnuto)]" } , { "optionEDUMP" , "   [-EDUMP {volitelný název souboru} (při chybě vypíše obsah zásobníku)]" } , { "optionXML" , "   [-XML (použije program pro formátování XML a přidá záhlaví XML)]" } , { "optionTEXT" , "   [-TEXT (použije jednoduchý program pro formátování textu)]" } , { "optionHTML" , "   [-HTML (použije program pro formátování HTML)]" } , { "optionPARAM" , "   [-PARAM název výrazu (nastaví parametr předlohy se styly)]" } , { "noParsermsg1" , "Proces XSL nebyl úspěšný." } , { "noParsermsg2" , "** Nelze najít analyzátor **" } , { "noParsermsg3" , "Zkontrolujte cestu classpath." } , { "noParsermsg4" , "Nemáte-li analyzátor XML jazyka Java společnosti IBM, můžete si jej stáhnout z adresy:" } , { "noParsermsg5" , "AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER celé jméno třídy (pro překlad URI použije funkci URIResolver)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER celé jméno třídy (pro překlad entit použije funkci EntityResolver)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER celé jméno třídy (pro serializaci výstupu použije funkci ContentHandler)]" } , { "optionLINENUMBERS" , "   [-L ve zdrojovém dokumentu použije čísla řádků]" } , { "optionMEDIA" , "   [-MEDIA mediaType (k vyhledání předlohy se styly přiřazené dokumentu použije atribut média)]" } , { "optionFLAVOR" , "   [-FLAVOR flavorName (při transformaci se explicitně použije s2s=SAX nebo d2d=DOM)] " } , { "optionDIAG" , "   [-DIAG (vytiskne čas transformace v milisekundách)]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL (vyžaduje inkrementální konstrukci DTM nastavením hodnoty http://xml.apache.org/xalan/features/incremental na true)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE (vyžaduje optimalizaci předlohy se styly nastavením hodnoty http://xml.apache.org/xalan/features/optimize na false)]" } , { "optionRL" , "   [-RL recursionlimit (potvrdí číselný limit hloubky předlohy se styly)]" } , { "optionXO" , "   [-XO [transletName] (přiřadí název k generovanému transletu)]" } , { "optionXD" , "   [-XD destinationDirectory (určuje cílový adresář pro translet)]" } , { "optionXJ" , "   [-XJ jarfile (zabalí třídy transletu do souboru jar s názvem <jarfile>)]" } , { "optionXP" , "   [-XP package (určí předponu názvu sady pro všechny generované třídy transletu)]" } , { "optionXN" , "   [-XN (povolí zarovnání šablon)]" } , { "optionXX" , "   [-XX (zapne další výstup zpráv ladění)]" } , { "optionXT" , "   [-XT (Použije translet k transformaci, je-li to možné)]" } , { "diagTiming" , " --------- Transformace {0} pomocí {1} trvala {2} ms." } , { "recursionTooDeep" , "Vnoření šablon je příliš hluboké. Vnoření = {0}, šablona {1} {2}" } , { "nameIs" , "název je" } , { "matchPatternIs" , "vzorek shody je" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#chyba" ; public static final String ERROR_HEADER = "Chyba: " ; public static final String WARNING_HEADER = "Varování: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "cs" , "CZ" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xml . utils ; public class CharKey extends Object { private char m_char ; public CharKey ( char key ) { m_char = key ; } public CharKey ( ) { } public final void setChar ( char c ) { m_char = c ; } public final int hashCode ( ) { return ( int ) m_char ; } public final boolean equals ( Object obj ) { return ( ( CharKey ) obj ) . m_char == m_char ; } } 	1	['5', '1', '0', '1', '6', '0', '1', '0', '5', '0.25', '32', '1', '0', '0', '0.533333333', '1', '1', '5.2', '2', '0.8', '1']
package org . apache . xalan . lib ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . TimeZone ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class ExsltDatetime { static final String dt = "yyyy-MM-dd'T'HH:mm:ss" ; static final String d = "yyyy-MM-dd" ; static final String gym = "yyyy-MM" ; static final String gy = "yyyy" ; static final String gmd = "--MM-dd" ; static final String gm = "--MM--" ; static final String gd = "---dd" ; static final String t = "HH:mm:ss" ; static final String EMPTY_STR = "" ; public static String dateTime ( ) { Calendar cal = Calendar . getInstance ( ) ; Date datetime = cal . getTime ( ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( dt ) ; StringBuffer buff = new StringBuffer ( dateFormat . format ( datetime ) ) ; int offset = cal . get ( Calendar . ZONE_OFFSET ) + cal . get ( Calendar . DST_OFFSET ) ; if ( offset == 0 ) buff . append ( "Z" ) ; else { int hrs = offset / ( 60 * 60 * 1000 ) ; int min = offset % ( 60 * 60 * 1000 ) ; char posneg = hrs < 0 ? '-' : '+' ; buff . append ( posneg + formatDigits ( hrs ) + ':' + formatDigits ( min ) ) ; } return buff . toString ( ) ; } private static String formatDigits ( int q ) { String dd = String . valueOf ( Math . abs ( q ) ) ; return dd . length ( ) == 1 ? '0' + dd : dd ; } public static String date ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String leader = edz [ 0 ] ; String datetime = edz [ 1 ] ; String zone = edz [ 2 ] ; if ( datetime == null || zone == null ) return EMPTY_STR ; String [ ] formatsIn = { dt , d } ; String formatOut = d ; Date date = testFormats ( datetime , formatsIn ) ; if ( date == null ) return EMPTY_STR ; SimpleDateFormat dateFormat = new SimpleDateFormat ( formatOut ) ; dateFormat . setLenient ( false ) ; String dateOut = dateFormat . format ( date ) ; if ( dateOut . length ( ) == 0 ) return EMPTY_STR ; else return ( leader + dateOut + zone ) ; } public static String date ( ) { String datetime = dateTime ( ) . toString ( ) ; String date = datetime . substring ( 0 , datetime . indexOf ( "T" ) ) ; String zone = datetime . substring ( getZoneStart ( datetime ) ) ; return ( date + zone ) ; } public static String time ( String timeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( timeIn ) ; String time = edz [ 1 ] ; String zone = edz [ 2 ] ; if ( time == null || zone == null ) return EMPTY_STR ; String [ ] formatsIn = { dt , d } ; String formatOut = t ; Date date = testFormats ( time , formatsIn ) ; if ( date == null ) return EMPTY_STR ; SimpleDateFormat dateFormat = new SimpleDateFormat ( formatOut ) ; String out = dateFormat . format ( date ) ; return ( out + zone ) ; } public static String time ( ) { String datetime = dateTime ( ) . toString ( ) ; String time = datetime . substring ( datetime . indexOf ( "T" ) + 1 ) ; String zone = datetime . substring ( getZoneStart ( datetime ) ) ; return ( time + zone ) ; } public static double year ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; boolean ad = edz [ 0 ] . length ( ) == 0 ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , d , gym , gy } ; double yr = getNumber ( datetime , formats , Calendar . YEAR ) ; if ( ad || yr == Double . NaN ) return yr ; else return - yr ; } public static double year ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . YEAR ) ; } public static double monthInYear ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , d , gym , gm , gmd } ; return getNumber ( datetime , formats , Calendar . MONTH ) ; } public static double monthInYear ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . MONTH ) ; } public static double weekInYear ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , d } ; return getNumber ( datetime , formats , Calendar . WEEK_OF_YEAR ) ; } public static double weekInYear ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . WEEK_OF_YEAR ) ; } public static double dayInYear ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , d } ; return getNumber ( datetime , formats , Calendar . DAY_OF_YEAR ) ; } public static double dayInYear ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . DAY_OF_YEAR ) ; } public static double dayInMonth ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; String [ ] formats = { dt , d , gmd , gd } ; double day = getNumber ( datetime , formats , Calendar . DAY_OF_MONTH ) ; return day ; } public static double dayInMonth ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . DAY_OF_MONTH ) ; } public static double dayOfWeekInMonth ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , d } ; return getNumber ( datetime , formats , Calendar . DAY_OF_WEEK_IN_MONTH ) ; } public static double dayOfWeekInMonth ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . DAY_OF_WEEK_IN_MONTH ) ; } public static double dayInWeek ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , d } ; return getNumber ( datetime , formats , Calendar . DAY_OF_WEEK ) ; } public static double dayInWeek ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . DAY_OF_WEEK ) ; } public static double hourInDay ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , t } ; return getNumber ( datetime , formats , Calendar . HOUR_OF_DAY ) ; } public static double hourInDay ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . HOUR_OF_DAY ) ; } public static double minuteInHour ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , t } ; return getNumber ( datetime , formats , Calendar . MINUTE ) ; } public static double minuteInHour ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . MINUTE ) ; } public static double secondInMinute ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return Double . NaN ; String [ ] formats = { dt , t } ; return getNumber ( datetime , formats , Calendar . SECOND ) ; } public static double secondInMinute ( ) { Calendar cal = Calendar . getInstance ( ) ; return cal . get ( Calendar . SECOND ) ; } public static XObject leapYear ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return new XNumber ( Double . NaN ) ; String [ ] formats = { dt , d , gym , gy } ; double dbl = getNumber ( datetime , formats , Calendar . YEAR ) ; if ( dbl == Double . NaN ) return new XNumber ( Double . NaN ) ; int yr = ( int ) dbl ; return new XBoolean ( yr % 400 == 0 || ( yr % 100 != 0 && yr % 4 == 0 ) ) ; } public static boolean leapYear ( ) { Calendar cal = Calendar . getInstance ( ) ; int yr = ( int ) cal . get ( Calendar . YEAR ) ; return ( yr % 400 == 0 || ( yr % 100 != 0 && yr % 4 == 0 ) ) ; } public static String monthName ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return EMPTY_STR ; String [ ] formatsIn = { dt , d , gym , gm } ; String formatOut = "MMMM" ; return getNameOrAbbrev ( datetimeIn , formatsIn , formatOut ) ; } public static String monthName ( ) { Calendar cal = Calendar . getInstance ( ) ; String format = "MMMM" ; return getNameOrAbbrev ( format ) ; } public static String monthAbbreviation ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return EMPTY_STR ; String [ ] formatsIn = { dt , d , gym , gm } ; String formatOut = "MMM" ; return getNameOrAbbrev ( datetimeIn , formatsIn , formatOut ) ; } public static String monthAbbreviation ( ) { String format = "MMM" ; return getNameOrAbbrev ( format ) ; } public static String dayName ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return EMPTY_STR ; String [ ] formatsIn = { dt , d } ; String formatOut = "EEEE" ; return getNameOrAbbrev ( datetimeIn , formatsIn , formatOut ) ; } public static String dayName ( ) { String format = "EEEE" ; return getNameOrAbbrev ( format ) ; } public static String dayAbbreviation ( String datetimeIn ) throws ParseException { String [ ] edz = getEraDatetimeZone ( datetimeIn ) ; String datetime = edz [ 1 ] ; if ( datetime == null ) return EMPTY_STR ; String [ ] formatsIn = { dt , d } ; String formatOut = "EEE" ; return getNameOrAbbrev ( datetimeIn , formatsIn , formatOut ) ; } public static String dayAbbreviation ( ) { String format = "EEE" ; return getNameOrAbbrev ( format ) ; } private static String [ ] getEraDatetimeZone ( String in ) { String leader = "" ; String datetime = in ; String zone = "" ; if ( in . charAt ( 0 ) == '-' && ! in . startsWith ( "--" ) ) { leader = "-" ; datetime = in . substring ( 1 ) ; } int z = getZoneStart ( datetime ) ; if ( z > 0 ) { zone = datetime . substring ( z ) ; datetime = datetime . substring ( 0 , z ) ; } else if ( z == - 2 ) zone = null ; return new String [ ] { leader , datetime , zone } ; } private static int getZoneStart ( String datetime ) { if ( datetime . indexOf ( "Z" ) == datetime . length ( ) - 1 ) return datetime . length ( ) - 1 ; else if ( datetime . length ( ) >= 6 && datetime . charAt ( datetime . length ( ) - 3 ) == ':' && ( datetime . charAt ( datetime . length ( ) - 6 ) == '+' || datetime . charAt ( datetime . length ( ) - 6 ) == '-' ) ) { try { SimpleDateFormat dateFormat = new SimpleDateFormat ( "HH:mm" ) ; dateFormat . setLenient ( false ) ; Date d = dateFormat . parse ( datetime . substring ( datetime . length ( ) - 5 ) ) ; return datetime . length ( ) - 6 ; } catch ( ParseException pe ) { System . out . println ( "ParseException " + pe . getErrorOffset ( ) ) ; return - 2 ; } } return - 1 ; } private static Date testFormats ( String in , String [ ] formats ) throws ParseException { for ( int i = 0 ; i < formats . length ; i ++ ) { try { SimpleDateFormat dateFormat = new SimpleDateFormat ( formats [ i ] ) ; dateFormat . setLenient ( false ) ; return dateFormat . parse ( in ) ; } catch ( ParseException pe ) { } } return null ; } private static double getNumber ( String in , String [ ] formats , int calField ) throws ParseException { Calendar cal = Calendar . getInstance ( ) ; cal . setLenient ( false ) ; Date date = testFormats ( in , formats ) ; if ( date == null ) return Double . NaN ; cal . setTime ( date ) ; return cal . get ( calField ) ; } private static String getNameOrAbbrev ( String in , String [ ] formatsIn , String formatOut ) throws ParseException { for ( int i = 0 ; i < formatsIn . length ; i ++ ) { try { SimpleDateFormat dateFormat = new SimpleDateFormat ( formatsIn [ i ] ) ; dateFormat . setLenient ( false ) ; Date dt = dateFormat . parse ( in ) ; dateFormat . applyPattern ( formatOut ) ; return dateFormat . format ( dt ) ; } catch ( ParseException pe ) { } } return "" ; } private static String getNameOrAbbrev ( String format ) { Calendar cal = Calendar . getInstance ( ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( format ) ; return dateFormat . format ( cal . getTime ( ) ) ; } public static String formatDate ( String dateTime , String pattern ) { final String yearSymbols = "Gy" ; final String monthSymbols = "M" ; final String daySymbols = "dDEFwW" ; TimeZone timeZone ; String zone ; if ( dateTime . endsWith ( "Z" ) || dateTime . endsWith ( "z" ) ) { timeZone = TimeZone . getTimeZone ( "GMT" ) ; dateTime = dateTime . substring ( 0 , dateTime . length ( ) - 1 ) + "GMT" ; zone = "z" ; } else if ( ( dateTime . length ( ) >= 6 ) && ( dateTime . charAt ( dateTime . length ( ) - 3 ) == ':' ) && ( ( dateTime . charAt ( dateTime . length ( ) - 6 ) == '+' ) || ( dateTime . charAt ( dateTime . length ( ) - 6 ) == '-' ) ) ) { String offset = dateTime . substring ( dateTime . length ( ) - 6 ) ; if ( "+00:00" . equals ( offset ) || "-00:00" . equals ( offset ) ) { timeZone = TimeZone . getTimeZone ( "GMT" ) ; } else { timeZone = TimeZone . getTimeZone ( "GMT" + offset ) ; } zone = "z" ; dateTime = dateTime . substring ( 0 , dateTime . length ( ) - 6 ) + "GMT" + offset ; } else { timeZone = TimeZone . getDefault ( ) ; zone = "" ; } String [ ] formats = { dt + zone , d , gym , gy } ; try { SimpleDateFormat inFormat = new SimpleDateFormat ( t + zone ) ; inFormat . setLenient ( false ) ; Date d = inFormat . parse ( dateTime ) ; SimpleDateFormat outFormat = new SimpleDateFormat ( strip ( yearSymbols + monthSymbols + daySymbols , pattern ) ) ; outFormat . setTimeZone ( timeZone ) ; return outFormat . format ( d ) ; } catch ( ParseException pe ) { } for ( int i = 0 ; i < formats . length ; i ++ ) { try { SimpleDateFormat inFormat = new SimpleDateFormat ( formats [ i ] ) ; inFormat . setLenient ( false ) ; Date d = inFormat . parse ( dateTime ) ; SimpleDateFormat outFormat = new SimpleDateFormat ( pattern ) ; outFormat . setTimeZone ( timeZone ) ; return outFormat . format ( d ) ; } catch ( ParseException pe ) { } } try { SimpleDateFormat inFormat = new SimpleDateFormat ( gmd ) ; inFormat . setLenient ( false ) ; Date d = inFormat . parse ( dateTime ) ; SimpleDateFormat outFormat = new SimpleDateFormat ( strip ( yearSymbols , pattern ) ) ; outFormat . setTimeZone ( timeZone ) ; return outFormat . format ( d ) ; } catch ( ParseException pe ) { } try { SimpleDateFormat inFormat = new SimpleDateFormat ( gm ) ; inFormat . setLenient ( false ) ; Date d = inFormat . parse ( dateTime ) ; SimpleDateFormat outFormat = new SimpleDateFormat ( strip ( yearSymbols , pattern ) ) ; outFormat . setTimeZone ( timeZone ) ; return outFormat . format ( d ) ; } catch ( ParseException pe ) { } try { SimpleDateFormat inFormat = new SimpleDateFormat ( gd ) ; inFormat . setLenient ( false ) ; Date d = inFormat . parse ( dateTime ) ; SimpleDateFormat outFormat = new SimpleDateFormat ( strip ( yearSymbols + monthSymbols , pattern ) ) ; outFormat . setTimeZone ( timeZone ) ; return outFormat . format ( d ) ; } catch ( ParseException pe ) { } return EMPTY_STR ; } private static String strip ( String symbols , String pattern ) { int quoteSemaphore = 0 ; int i = 0 ; StringBuffer result = new StringBuffer ( pattern . length ( ) ) ; while ( i < pattern . length ( ) ) { char ch = pattern . charAt ( i ) ; if ( ch == '\'' ) { int endQuote = pattern . indexOf ( '\'' , i + 1 ) ; if ( endQuote == - 1 ) { endQuote = pattern . length ( ) ; } result . append ( pattern . substring ( i , endQuote ) ) ; i = endQuote ++ ; } else if ( symbols . indexOf ( ch ) > - 1 ) { i ++ ; } else { result . append ( ch ) ; i ++ ; } } return result . toString ( ) ; } } 	1	['45', '1', '0', '3', '86', '990', '0', '3', '37', '1.022727273', '1528', '0', '0', '0', '0.172222222', '0', '0', '32.75555556', '10', '1.6', '2']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . serializer . SerializationHandler ; import org . xml . sax . SAXException ; public class ElemTextLiteral extends ElemTemplateElement { private boolean m_preserveSpace ; public void setPreserveSpace ( boolean v ) { m_preserveSpace = v ; } public boolean getPreserveSpace ( ) { return m_preserveSpace ; } private char m_ch [ ] ; private String m_str ; public void setChars ( char [ ] v ) { m_ch = v ; } public char [ ] getChars ( ) { return m_ch ; } public synchronized String getNodeValue ( ) { if ( null == m_str ) { m_str = new String ( m_ch ) ; } return m_str ; } private boolean m_disableOutputEscaping = false ; public void setDisableOutputEscaping ( boolean v ) { m_disableOutputEscaping = v ; } public boolean getDisableOutputEscaping ( ) { return m_disableOutputEscaping ; } public int getXSLToken ( ) { return Constants . ELEMNAME_TEXTLITERALRESULT ; } public String getNodeName ( ) { return "#Text" ; } public void execute ( TransformerImpl transformer ) throws TransformerException { try { SerializationHandler rth = transformer . getResultTreeHandler ( ) ; if ( TransformerImpl . S_DEBUG ) { rth . flushPending ( ) ; transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; } if ( m_disableOutputEscaping ) { rth . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; } rth . characters ( m_ch , 0 , m_ch . length ) ; if ( m_disableOutputEscaping ) { rth . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } finally { if ( TransformerImpl . S_DEBUG ) { try { transformer . getResultTreeHandler ( ) . flushPending ( ) ; transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } } } } } 	1	['11', '3', '0', '9', '21', '29', '6', '4', '11', '0.825', '135', '1', '0', '0.951456311', '0.340909091', '2', '5', '10.90909091', '2', '1', '2']
package org . apache . xalan . processor ; import java . io . IOException ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . TreeWalker ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; class ProcessorInclude extends XSLTElementProcessor { private String m_href = null ; public String getHref ( ) { return m_href ; } public void setHref ( String baseIdent ) { m_href = baseIdent ; } protected int getStylesheetType ( ) { return StylesheetHandler . STYPE_INCLUDE ; } protected String getStylesheetInclErr ( ) { return XSLTErrorResources . ER_STYLESHEET_INCLUDES_ITSELF ; } public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { setPropertiesFromAttributes ( handler , rawName , attributes , this ) ; try { String hrefUrl = SystemIDResolver . getAbsoluteURI ( getHref ( ) , handler . getBaseIdentifier ( ) ) ; if ( handler . importStackContains ( hrefUrl ) ) { throw new org . xml . sax . SAXException ( XSLMessages . createMessage ( getStylesheetInclErr ( ) , new Object [ ] { hrefUrl } ) ) ; } handler . pushImportURL ( hrefUrl ) ; int savedStylesheetType = handler . getStylesheetType ( ) ; handler . setStylesheetType ( this . getStylesheetType ( ) ) ; handler . pushNewNamespaceSupport ( ) ; try { parse ( handler , uri , localName , rawName , attributes ) ; } finally { handler . setStylesheetType ( savedStylesheetType ) ; handler . popImportURL ( ) ; handler . popNamespaceSupport ( ) ; } } catch ( TransformerException te ) { handler . error ( te . getMessage ( ) , te ) ; } } protected void parse ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { TransformerFactoryImpl processor = handler . getStylesheetProcessor ( ) ; URIResolver uriresolver = processor . getURIResolver ( ) ; try { Source source = null ; if ( null != uriresolver ) { source = uriresolver . resolve ( getHref ( ) , handler . getBaseIdentifier ( ) ) ; if ( null != source && source instanceof DOMSource ) { Node node = ( ( DOMSource ) source ) . getNode ( ) ; String systemId = source . getSystemId ( ) ; if ( systemId == null ) { systemId = SystemIDResolver . getAbsoluteURI ( getHref ( ) , handler . getBaseIdentifier ( ) ) ; } TreeWalker walker = new TreeWalker ( handler , new org . apache . xml . utils . DOM2Helper ( ) , systemId ) ; try { walker . traverse ( node ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } return ; } } if ( null == source ) { String absURL = SystemIDResolver . getAbsoluteURI ( getHref ( ) , handler . getBaseIdentifier ( ) ) ; source = new StreamSource ( absURL ) ; } XMLReader reader = null ; if ( source instanceof SAXSource ) { SAXSource saxSource = ( SAXSource ) source ; reader = saxSource . getXMLReader ( ) ; } InputSource inputSource = SAXSource . sourceToInputSource ( source ) ; if ( null == reader ) { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } } if ( null == reader ) reader = XMLReaderFactory . createXMLReader ( ) ; if ( null != reader ) { reader . setContentHandler ( handler ) ; handler . pushBaseIndentifier ( inputSource . getSystemId ( ) ) ; try { reader . parse ( inputSource ) ; } finally { handler . popBaseIndentifier ( ) ; } } } catch ( IOException ioe ) { handler . error ( XSLTErrorResources . ER_IOEXCEPTION , new Object [ ] { getHref ( ) } , ioe ) ; } catch ( TransformerException te ) { handler . error ( te . getMessage ( ) , te ) ; } } } 	1	['7', '4', '1', '11', '47', '15', '2', '9', '3', '0.333333333', '268', '1', '0', '0.972222222', '0.5', '1', '1', '37.14285714', '1', '0.8571', '1']
package org . apache . xalan . lib ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMNodeIterator ; import org . apache . xpath . NodeSet ; public class ExsltCommon { public static String objectType ( Object obj ) { if ( obj instanceof String ) return "string" ; else if ( obj instanceof Boolean ) return "boolean" ; else if ( obj instanceof Number ) return "number" ; else if ( obj instanceof DTMNodeIterator ) { DTMIterator dtmI = ( ( DTMNodeIterator ) obj ) . getDTMIterator ( ) ; if ( dtmI instanceof org . apache . xpath . axes . RTFIterator ) return "RTF" ; else return "node-set" ; } else return "unknown" ; } public static NodeSet nodeSet ( ExpressionContext myProcessor , Object rtf ) { return Extensions . nodeset ( myProcessor , rtf ) ; } } 	1	['3', '1', '0', '6', '6', '3', '0', '6', '3', '2', '41', '0', '0', '0', '0.444444444', '0', '0', '12.66666667', '6', '2.3333', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_it extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "La funzione corrente () non è consentita in un modello di corrispondenza." } , { ER_CURRENT_TAKES_NO_ARGS , "La funzione corrente () non accetta argomenti." } , { ER_DOCUMENT_REPLACED , "L'implementazione della funzione documento () è stata sostituita da org.apache.xalan.xslt.FuncDocument." } , { ER_CONTEXT_HAS_NO_OWNERDOC , "il contesto non ha un documento proprietario." } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() ha troppi argomenti." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() ha troppi argomenti." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() ha troppi argomenti." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() ha troppi argomenti." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() ha troppi argomenti." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() ha troppi argomenti." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() ha troppi argomenti." } , { ER_TRANSLATE_TAKES_3_ARGS , "La funzione translate() richiede tre argomenti." } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "La funzione unparsed-entity-uri richiede un argomento." } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "namespace axis non ancora implementato." } , { ER_UNKNOWN_AXIS , "asse sconosciuto: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "operazione di corrispondenza sconosciuta." } , { ER_INCORRECT_ARG_LENGTH , "Lunghezza argomento nella prova nodo processing-instruction() incorretta." } , { ER_CANT_CONVERT_TO_NUMBER , "Impossibile convertire {0} in un numero" } , { ER_CANT_CONVERT_TO_NODELIST , "Impossibile convertire {0} in un NodeList." } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Impossibile convertire {0} in un NodeSetDTM." } , { ER_CANT_CONVERT_TO_TYPE , "Impossibile convertire {0} in un type#{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Modello corrispondenza previsto in getMatchScore!" } , { ER_COULDNOT_GET_VAR_NAMED , "Impossibile richiamare la variabile denominata {0}" } , { ER_UNKNOWN_OPCODE , "ERRORE! Codice operativo sconosciuto: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Token aggiuntivi non validi: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "letterale con numero di apici errato... previsti i doppi apici." } , { ER_EXPECTED_SINGLE_QUOTE , "letterale con numero di apici errato... previsto un solo apice." } , { ER_EMPTY_EXPRESSION , "Espressione vuota." } , { ER_EXPECTED_BUT_FOUND , "Era previsto {0}, ma è stato trovato: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Asserzione programmatore errata. - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "Argomento boolean(...) non più facoltativo con 19990709 XPath draft." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Trovata ',' senza argomento che la precede." } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Trovata ',' senza argomento che la segue." } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicato]' o '.[predicato]' è una sintassi non valida. Utilizzare 'self::node()[predicato]'." } , { ER_ILLEGAL_AXIS_NAME , "nome asse non valido: {0}" } , { ER_UNKNOWN_NODETYPE , "Nodetype sconosciuto: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Il letterale modello ({0}) deve essere racchiuso fra virgolette." } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} non può essere formattato in un numero." } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Impossibile creare XML TransformerFactory Liaison: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Errore! Impossibile trovare espressione selezione xpath (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "ERRORE! Impossibile trovare ENDOP dopo OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Si è verificato un errore." } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference fornito per la variabile è fuori contesto o senza definizione.  Nome = {0}" } , { ER_AXES_NOT_ALLOWED , "Sono consentiti solo gli assi child:: e attribute:: nei modelli di corrispondenza. Violazione asse = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() con numero di argomenti scorretto." } , { ER_COUNT_TAKES_1_ARG , "La funzione count richiede un argomento." } , { ER_COULDNOT_FIND_FUNCTION , "Impossibile trovare la funzione: {0}" } , { ER_UNSUPPORTED_ENCODING , "Codifica non supportata: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Si è verificato un problema in DTM durante l'esecuzione di getNextSibling... tentativo di recupero in corso" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Errore di programmazione: Impossibile scrivere su EmptyNodeList. " } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory non supportato da XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Il prefisso deve risolvere in uno spazio nomi: {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (InputSource source) non supportato in XPathContext! Impossibile aprire {0}" } , { ER_SAX_API_NOT_HANDLED , "Caratteri SAX API (char ch[]... non gestiti da DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... non gestiti da DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison non può gestire i nodi di tipo {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper non può gestire i nodi di tipo {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Errore DOM2Helper.parse: SystemID - {0} riga - {1}" } , { ER_XERCES_PARSE_ERROR , "Errore DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Rilevato surrogato UTF-16 non valido: {0} ?" } , { ER_OIERROR , "Errore IO" } , { ER_CANNOT_CREATE_URL , "Impossibile creare url per: {0}" } , { ER_XPATH_READOBJECT , "In XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "token funzione non trovato." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Impossibile gestire il tipo XPath: {0}" } , { ER_NODESET_NOT_MUTABLE , "Questo NodeSet non è trasformabile" } , { ER_NODESETDTM_NOT_MUTABLE , "Questo NodeSetDTM non è trasformabile" } , { ER_VAR_NOT_RESOLVABLE , "Variabile non risolvibile: {0}" } , { ER_NULL_ERROR_HANDLER , "Handler errori nullo" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Asserzione di programma: codice operativo sconosciuto: {0}" } , { ER_ZERO_OR_ONE , "0 oppure 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() non supportato da XRTreeFragSelectWrapper" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() non supportato da XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() non supportato per XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Impossibile trovare la variabile con il nome {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars non può accettare una stringa come argomento" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "L'argomento FastStringBuffer non può essere nullo" } , { ER_TWO_OR_THREE , "2 o 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Variabile acceduta prima che fosse delimitata." } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB non può accettare una stringa come argomento. " } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Errore! Si sta impostando il nodo di partenza su null" } , { ER_NODESETDTM_CANNOT_ITERATE , "NodeSetDTM non può collegarsi al nodo precedente" } , { ER_NODESET_CANNOT_ITERATE , "NodeSet non può collegarsi al nodo precedente" } , { ER_NODESETDTM_CANNOT_INDEX , "NodeSetDTM non può eseguire l'indicizzazione o il conteggio delle funzioni." } , { ER_NODESET_CANNOT_INDEX , "NodeSet non può eseguire l'indicizzazione o il conteggio delle funzioni." } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Impossibile chiamare setShouldCacheNodes dopo aver chiamato nextNode." } , { ER_ONLY_ALLOWS , "{0} consente solo {1} argomenti" } , { ER_UNKNOWN_STEP , "Asserzione di programma in getNextStepPos: stepType sconosciuto: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Era previsto un percorso relativo dopo il token '/' oppure '//'. " } , { ER_EXPECTED_LOC_PATH , "Era previsto un percorso, ma è stato rilevato il seguente token:  {0}" } , { ER_EXPECTED_LOC_STEP , "Era previsto un passo di posizione dopo il token '/' oppure '//'. " } , { ER_EXPECTED_NODE_TEST , "Era prevista una prova nodo che corrisponde a NCName:* oppure a QName. " } , { ER_EXPECTED_STEP_PATTERN , "Era previsto un modello passo, ma è stato rilevato '/'. " } , { ER_EXPECTED_REL_PATH_PATTERN , "Era previsto un modello percorso relativo. " } , { ER_CANT_CONVERT_TO_BOOLEAN , "Impossibile convertire {0} in un booleano. " } , { ER_CANT_CONVERT_TO_SINGLENODE , "Impossibile convertire {0} in un nodo singolo. Questo getter si applica ai tipi ANY_UNORDERED_NODE_TYPE e FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Impossibile richiamare la lunghezza istantanea per il tipo: {0}. Questo getter si applica ai tipi UNORDERED_NODE_SNAPSHOT_TYPE e ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Impossibile collegarsi ad un tipo non iteratore: {0}" } , { ER_DOC_MUTATED , "Documento modificato da quando è stato restituito il risultato. Iteratore non valido. " } , { ER_INVALID_XPATH_TYPE , "Argomento di tipo XPath non valido: {0}" } , { ER_EMPTY_XPATH_RESULT , "Oggetto risultato XPath vuoto " } , { ER_INCOMPATIBLE_TYPES , "Il tipo restituito: {0} non può essere forzato nel tipo specificato: {1}" } , { ER_NULL_RESOLVER , "Impossibile risolvere il prefisso con resolver di prefisso nullo. " } , { ER_CANT_CONVERT_TO_STRING , "Impossibile convertire {0} in una stringa. " } , { ER_NON_SNAPSHOT_TYPE , "Impossibile richiamare snapshotItem sul tipo: {0}. Questo metodo si applica ai tipi UNORDERED_NODE_SNAPSHOT_TYPE e ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Il nodo di contesto non appartiene al documento collegato a questo XPathEvaluator." } , { ER_WRONG_NODETYPE , "Il tipo di nodo di contesto non è supportato. " } , { ER_XPATH_ERROR , "Errore sconosciuto in XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "nome locale nella funzione format-number non ancora gestito." } , { WG_PROPERTY_NOT_SUPPORTED , "Proprietà XSL non supportata: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Non eseguire alcune azione per lo spazio nomi {0} nella proprietà: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException durante il tentativo di accesso alla proprietà di sistema XSL: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Sintassi obsoleta: quo(...) non è più definito in XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath richiede un oggetto derivato per implementare nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "token funzione non trovato." } , { WG_COULDNOT_FIND_FUNCTION , "Impossibile trovare la funzione: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Impossibile ricavare l''URL da: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "Opzione -E non supportata per il parser DTM" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference fornito per la variabile è fuori contesto o senza definizione.  Nome = {0}" } , { WG_UNSUPPORTED_ENCODING , "Codifica non supportata: {0}" } , { "ui_language" , "it" } , { "help_language" , "it" } , { "language" , "it" } , { "BAD_CODE" , "Il parametro per createMessage fuori limite" } , { "FORMAT_FAILED" , "Rilevata eccezione durante la chiamata messageFormat" } , { "version" , ">>>>>>> Versione Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "sì" } , { "line" , "Riga #" } , { "column" , "Colonna #" } , { "xsldone" , "XSLProcessor: eseguito" } , { "xpath_option" , "opzioni xpath: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select espressione xpath]" } , { "optionMatch" , "   [-match associa il modello (per le diagnostiche di corrispondenza)]" } , { "optionAnyExpr" , "Oppure per un'espressione xpath eseguirà un dump diagnostico" } , { "noParsermsg1" , "Elaborazione XSL non riuscita." } , { "noParsermsg2" , "** Impossibile trovare il parser **" } , { "noParsermsg3" , "Controllare il classpath." } , { "noParsermsg4" , "Se non si possiede IBM XML Parser per Java, è possibile scaricarlo da" } , { "noParsermsg5" , "IBM AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#errore" ; public static final String ERROR_HEADER = "Errore: " ; public static final String WARNING_HEADER = "Avvertenza: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MODELLO " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "it" , "IT" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; final class ParentLocationPath extends RelativeLocationPath { private Expression _step ; private final RelativeLocationPath _path ; private Type stype ; private boolean _orderNodes = false ; private boolean _axisMismatch = false ; public ParentLocationPath ( RelativeLocationPath path , Expression step ) { _path = path ; _step = step ; _path . setParent ( this ) ; _step . setParent ( this ) ; if ( _step instanceof Step ) { _axisMismatch = checkAxisMismatch ( ) ; } } public void setAxis ( int axis ) { _path . setAxis ( axis ) ; } public int getAxis ( ) { return _path . getAxis ( ) ; } public RelativeLocationPath getPath ( ) { return ( _path ) ; } public Expression getStep ( ) { return ( _step ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _step . setParser ( parser ) ; _path . setParser ( parser ) ; } public String toString ( ) { return "ParentLocationPath(" + _path + ", " + _step + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { stype = _step . typeCheck ( stable ) ; _path . typeCheck ( stable ) ; if ( _axisMismatch ) enableNodeOrdering ( ) ; return _type = Type . NodeSet ; } public void enableNodeOrdering ( ) { SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof ParentLocationPath ) ( ( ParentLocationPath ) parent ) . enableNodeOrdering ( ) ; else { _orderNodes = true ; } } public boolean checkAxisMismatch ( ) { int left = _path . getAxis ( ) ; int right = ( ( Step ) _step ) . getAxis ( ) ; if ( ( ( left == Axis . ANCESTOR ) || ( left == Axis . ANCESTORORSELF ) ) && ( ( right == Axis . CHILD ) || ( right == Axis . DESCENDANT ) || ( right == Axis . DESCENDANTORSELF ) || ( right == Axis . PARENT ) || ( right == Axis . PRECEDING ) || ( right == Axis . PRECEDINGSIBLING ) ) ) return true ; if ( ( left == Axis . CHILD ) && ( right == Axis . ANCESTOR ) || ( right == Axis . ANCESTORORSELF ) || ( right == Axis . PARENT ) || ( right == Axis . PRECEDING ) ) return true ; if ( ( left == Axis . DESCENDANT ) || ( left == Axis . DESCENDANTORSELF ) ) return true ; if ( ( ( left == Axis . FOLLOWING ) || ( left == Axis . FOLLOWINGSIBLING ) ) && ( ( right == Axis . FOLLOWING ) || ( right == Axis . PARENT ) || ( right == Axis . PRECEDING ) || ( right == Axis . PRECEDINGSIBLING ) ) ) return true ; if ( ( ( left == Axis . PRECEDING ) || ( left == Axis . PRECEDINGSIBLING ) ) && ( ( right == Axis . DESCENDANT ) || ( right == Axis . DESCENDANTORSELF ) || ( right == Axis . FOLLOWING ) || ( right == Axis . FOLLOWINGSIBLING ) || ( right == Axis . PARENT ) || ( right == Axis . PRECEDING ) || ( right == Axis . PRECEDINGSIBLING ) ) ) return true ; if ( ( right == Axis . FOLLOWING ) && ( left == Axis . CHILD ) ) { if ( _path instanceof Step ) { int type = ( ( Step ) _path ) . getNodeType ( ) ; if ( type == DTM . ATTRIBUTE_NODE ) return true ; } } return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int initSI = cpg . addMethodref ( STEP_ITERATOR_CLASS , "<init>" , "(" + NODE_ITERATOR_SIG + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( STEP_ITERATOR_CLASS ) ) ) ; il . append ( DUP ) ; _path . translate ( classGen , methodGen ) ; _step . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( initSI ) ) ; Expression stp = _step ; if ( stp instanceof ParentLocationPath ) stp = ( ( ParentLocationPath ) stp ) . getStep ( ) ; if ( ( _path instanceof Step ) && ( stp instanceof Step ) ) { final int path = ( ( Step ) _path ) . getAxis ( ) ; final int step = ( ( Step ) stp ) . getAxis ( ) ; if ( ( path == Axis . DESCENDANTORSELF && step == Axis . CHILD ) || ( path == Axis . PRECEDING && step == Axis . PARENT ) ) { final int incl = cpg . addMethodref ( NODE_ITERATOR_BASE , "includeSelf" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEVIRTUAL ( incl ) ) ; } } if ( _orderNodes ) { final int order = cpg . addInterfaceMethodref ( DOM_INTF , ORDER_ITERATOR , ORDER_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( order , 3 ) ) ; } } } 	1	['11', '4', '0', '19', '42', '0', '1', '19', '11', '0.64', '380', '1', '3', '0.879518072', '0.204545455', '2', '7', '33.09090909', '35', '4.8182', '2']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; import org . apache . xml . dtm . ref . DTMDefaultBase ; import org . apache . xml . utils . SuballocatedIntVector ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public final class MultiDOM implements DOM { private static final int NO_TYPE = DOM . FIRST_TYPE - 2 ; private static final int INITIAL_SIZE = 4 ; private DOM [ ] _adapters ; private DOMAdapter _main ; private DTMManager _dtmManager ; private int _free ; private int _size ; private Hashtable _documents = new Hashtable ( ) ; private final class AxisIterator extends DTMAxisIteratorBase { private final int _axis ; private final int _type ; private DTMAxisIterator _source ; private int _dtmId = - 1 ; public AxisIterator ( final int axis , final int type ) { _axis = axis ; _type = type ; } public int next ( ) { if ( _source == null ) { return ( END ) ; } return _source . next ( ) ; } public void setRestartable ( boolean flag ) { if ( _source != null ) { _source . setRestartable ( flag ) ; } } public DTMAxisIterator setStartNode ( final int node ) { if ( node == DTM . NULL ) { return this ; } int dom = node > > > DTMManager . IDENT_DTM_NODE_BITS ; if ( _source == null || _dtmId != dom ) { if ( _type == NO_TYPE ) { _source = _adapters [ dom ] . getAxisIterator ( _axis ) ; } else if ( _axis == Axis . CHILD ) { _source = _adapters [ dom ] . getTypedChildren ( _type ) ; } else { _source = _adapters [ dom ] . getTypedAxisIterator ( _axis , _type ) ; } } _dtmId = dom ; _source . setStartNode ( node ) ; return this ; } public DTMAxisIterator reset ( ) { if ( _source != null ) { _source . reset ( ) ; } return this ; } public int getLast ( ) { if ( _source != null ) { return _source . getLast ( ) ; } else { return END ; } } public int getPosition ( ) { if ( _source != null ) { return _source . getPosition ( ) ; } else { return END ; } } public boolean isReverse ( ) { return Axis . isReverse [ _axis ] ; } public void setMark ( ) { if ( _source != null ) { _source . setMark ( ) ; } } public void gotoMark ( ) { if ( _source != null ) { _source . gotoMark ( ) ; } } public DTMAxisIterator cloneIterator ( ) { final AxisIterator clone = new AxisIterator ( _axis , _type ) ; if ( _source != null ) { clone . _source = _source . cloneIterator ( ) ; } clone . _dtmId = _dtmId ; return clone ; } } private final class NodeValueIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private String _value ; private boolean _op ; private final boolean _isReverse ; private int _returnType = RETURN_PARENT ; public NodeValueIterator ( DTMAxisIterator source , int returnType , String value , boolean op ) { _source = source ; _returnType = returnType ; _value = value ; _op = op ; _isReverse = source . isReverse ( ) ; } public boolean isReverse ( ) { return _isReverse ; } public DTMAxisIterator cloneIterator ( ) { try { NodeValueIterator clone = ( NodeValueIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . setRestartable ( false ) ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public int next ( ) { int node ; while ( ( node = _source . next ( ) ) != END ) { String val = getStringValueX ( node ) ; if ( _value . equals ( val ) == _op ) { if ( _returnType == RETURN_CURRENT ) return returnNode ( node ) ; else return returnNode ( getParent ( node ) ) ; } } return END ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; return resetPosition ( ) ; } return this ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } public MultiDOM ( DOM main ) { _size = INITIAL_SIZE ; _free = 1 ; _adapters = new DOM [ INITIAL_SIZE ] ; DOMAdapter adapter = ( DOMAdapter ) main ; _adapters [ 0 ] = adapter ; _main = adapter ; DOM dom = adapter . getDOMImpl ( ) ; if ( dom instanceof DTMDefaultBase ) { _dtmManager = ( ( DTMDefaultBase ) dom ) . getManager ( ) ; } addDOMAdapter ( adapter , false ) ; } public int nextMask ( ) { return _free ; } public void setupMapping ( String [ ] names , String [ ] uris , int [ ] types , String [ ] namespaces ) { } public int addDOMAdapter ( DOMAdapter adapter ) { return addDOMAdapter ( adapter , true ) ; } private int addDOMAdapter ( DOMAdapter adapter , boolean indexByURI ) { DOM dom = adapter . getDOMImpl ( ) ; int domNo = 1 ; int dtmSize = 1 ; SuballocatedIntVector dtmIds = null ; if ( dom instanceof DTMDefaultBase ) { DTMDefaultBase dtmdb = ( DTMDefaultBase ) dom ; dtmIds = dtmdb . getDTMIDs ( ) ; dtmSize = dtmIds . size ( ) ; domNo = dtmIds . elementAt ( dtmSize - 1 ) > > > DTMManager . IDENT_DTM_NODE_BITS ; } else if ( dom instanceof SimpleResultTreeImpl ) { SimpleResultTreeImpl simpleRTF = ( SimpleResultTreeImpl ) dom ; domNo = simpleRTF . getDocument ( ) > > > DTMManager . IDENT_DTM_NODE_BITS ; } if ( domNo >= _size ) { int oldSize = _size ; do { _size *= 2 ; } while ( _size <= domNo ) ; final DOMAdapter [ ] newArray = new DOMAdapter [ _size ] ; System . arraycopy ( _adapters , 0 , newArray , 0 , oldSize ) ; _adapters = newArray ; } _free = domNo + 1 ; if ( dtmSize == 1 ) { _adapters [ domNo ] = adapter ; } else if ( dtmIds != null ) { int domPos = 0 ; for ( int i = dtmSize - 1 ; i >= 0 ; i -- ) { domPos = dtmIds . elementAt ( i ) > > > DTMManager . IDENT_DTM_NODE_BITS ; _adapters [ domPos ] = adapter ; } domNo = domPos ; } if ( indexByURI ) { String uri = adapter . getDocumentURI ( 0 ) ; _documents . put ( uri , new Integer ( domNo ) ) ; } if ( dom instanceof AdaptiveResultTreeImpl ) { AdaptiveResultTreeImpl adaptiveRTF = ( AdaptiveResultTreeImpl ) dom ; DOM nestedDom = adaptiveRTF . getNestedDOM ( ) ; if ( nestedDom != null ) { DOMAdapter newAdapter = new DOMAdapter ( nestedDom , adapter . getNamesArray ( ) , adapter . getUrisArray ( ) , adapter . getTypesArray ( ) , adapter . getNamespaceArray ( ) ) ; addDOMAdapter ( newAdapter ) ; } } return domNo ; } public int getDocumentMask ( String uri ) { Integer domIdx = ( Integer ) _documents . get ( uri ) ; if ( domIdx == null ) { return ( - 1 ) ; } else { return domIdx . intValue ( ) ; } } public DOM getDOMAdapter ( String uri ) { Integer domIdx = ( Integer ) _documents . get ( uri ) ; if ( domIdx == null ) { return ( null ) ; } else { return ( _adapters [ domIdx . intValue ( ) ] ) ; } } public int getDocument ( ) { return _main . getDocument ( ) ; } public DTMManager getDTMManager ( ) { return _dtmManager ; } public DTMAxisIterator getIterator ( ) { return _main . getIterator ( ) ; } public String getStringValue ( ) { return _main . getStringValue ( ) ; } public DTMAxisIterator getChildren ( final int node ) { return _adapters [ getDTMId ( node ) ] . getChildren ( node ) ; } public DTMAxisIterator getTypedChildren ( final int type ) { return new AxisIterator ( Axis . CHILD , type ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { return new AxisIterator ( axis , NO_TYPE ) ; } public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) { return new AxisIterator ( axis , type ) ; } public DTMAxisIterator getNthDescendant ( int node , int n , boolean includeself ) { return _adapters [ getDTMId ( node ) ] . getNthDescendant ( node , n , includeself ) ; } public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iterator , int type , String value , boolean op ) { return ( new NodeValueIterator ( iterator , type , value , op ) ) ; } public DTMAxisIterator getNamespaceAxisIterator ( final int axis , final int ns ) { DTMAxisIterator iterator = _main . getNamespaceAxisIterator ( axis , ns ) ; return ( iterator ) ; } public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) { return _adapters [ getDTMId ( node ) ] . orderNodes ( source , node ) ; } public int getExpandedTypeID ( final int node ) { if ( node != DTM . NULL ) { return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getExpandedTypeID ( node ) ; } else { return DTM . NULL ; } } public int getNamespaceType ( final int node ) { return _adapters [ getDTMId ( node ) ] . getNamespaceType ( node ) ; } public int getNSType ( int node ) { return _adapters [ getDTMId ( node ) ] . getNSType ( node ) ; } public int getParent ( final int node ) { if ( node == DTM . NULL ) { return DTM . NULL ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getParent ( node ) ; } public int getAttributeNode ( final int type , final int el ) { if ( el == DTM . NULL ) { return DTM . NULL ; } return _adapters [ el > > > DTMManager . IDENT_DTM_NODE_BITS ] . getAttributeNode ( type , el ) ; } public String getNodeName ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getNodeName ( node ) ; } public String getNodeNameX ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getNodeNameX ( node ) ; } public String getNamespaceName ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getNamespaceName ( node ) ; } public String getStringValueX ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getStringValueX ( node ) ; } public void copy ( final int node , SerializationHandler handler ) throws TransletException { if ( node != DTM . NULL ) { _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . copy ( node , handler ) ; } } public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException { int node ; while ( ( node = nodes . next ( ) ) != DTM . NULL ) { _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . copy ( node , handler ) ; } } public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException { if ( node == DTM . NULL ) { return "" ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . shallowCopy ( node , handler ) ; } public boolean lessThan ( final int node1 , final int node2 ) { if ( node1 == DTM . NULL ) { return true ; } if ( node2 == DTM . NULL ) { return false ; } final int dom1 = getDTMId ( node1 ) ; final int dom2 = getDTMId ( node2 ) ; return dom1 == dom2 ? _adapters [ dom1 ] . lessThan ( node1 , node2 ) : dom1 < dom2 ; } public void characters ( final int textNode , SerializationHandler handler ) throws TransletException { if ( textNode != DTM . NULL ) { _adapters [ textNode > > > DTMManager . IDENT_DTM_NODE_BITS ] . characters ( textNode , handler ) ; } } public void setFilter ( StripFilter filter ) { for ( int dom = 0 ; dom < _free ; dom ++ ) { if ( _adapters [ dom ] != null ) { _adapters [ dom ] . setFilter ( filter ) ; } } } public Node makeNode ( int index ) { if ( index == DTM . NULL ) { return null ; } return _adapters [ getDTMId ( index ) ] . makeNode ( index ) ; } public Node makeNode ( DTMAxisIterator iter ) { return _main . makeNode ( iter ) ; } public NodeList makeNodeList ( int index ) { if ( index == DTM . NULL ) { return null ; } return _adapters [ getDTMId ( index ) ] . makeNodeList ( index ) ; } public NodeList makeNodeList ( DTMAxisIterator iter ) { return _main . makeNodeList ( iter ) ; } public String getLanguage ( int node ) { return _adapters [ getDTMId ( node ) ] . getLanguage ( node ) ; } public int getSize ( ) { int size = 0 ; for ( int i = 0 ; i < _size ; i ++ ) { size += _adapters [ i ] . getSize ( ) ; } return ( size ) ; } public String getDocumentURI ( int node ) { if ( node == DTM . NULL ) { node = DOM . NULL ; } return _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . getDocumentURI ( 0 ) ; } public boolean isElement ( final int node ) { if ( node == DTM . NULL ) { return false ; } return ( _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . isElement ( node ) ) ; } public boolean isAttribute ( final int node ) { if ( node == DTM . NULL ) { return false ; } return ( _adapters [ node > > > DTMManager . IDENT_DTM_NODE_BITS ] . isAttribute ( node ) ) ; } public int getDTMId ( int nodeHandle ) { if ( nodeHandle == DTM . NULL ) return 0 ; int id = nodeHandle > > > DTMManager . IDENT_DTM_NODE_BITS ; while ( id >= 2 && _adapters [ id ] == _adapters [ id - 1 ] ) { id -- ; } return id ; } public int getNodeIdent ( int nodeHandle ) { return _adapters [ nodeHandle > > > DTMManager . IDENT_DTM_NODE_BITS ] . getNodeIdent ( nodeHandle ) ; } public int getNodeHandle ( int nodeId ) { return _main . getNodeHandle ( nodeId ) ; } public DOM getResultTreeFrag ( int initSize , int rtfType ) { return _main . getResultTreeFrag ( initSize , rtfType ) ; } public DOM getResultTreeFrag ( int initSize , int rtfType , boolean addToManager ) { return _main . getResultTreeFrag ( initSize , rtfType , addToManager ) ; } public DOM getMain ( ) { return _main ; } public SerializationHandler getOutputDomBuilder ( ) { return _main . getOutputDomBuilder ( ) ; } public String lookupNamespace ( int node , String prefix ) throws TransletException { return _main . lookupNamespace ( node , prefix ) ; } public String getUnparsedEntityURI ( String entity ) { return _main . getUnparsedEntityURI ( entity ) ; } public Hashtable getElementsWithIDs ( ) { return _main . getElementsWithIDs ( ) ; } } 	1	['54', '1', '0', '16', '115', '277', '4', '14', '52', '0.870283019', '803', '1', '4', '0', '0.171296296', '0', '0', '13.72222222', '11', '1.6111', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . ArrayList ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFNONNULL ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . L2I ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MatchGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeCounterGenerator ; import org . apache . xalan . xsltc . compiler . util . RealType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Number extends Instruction implements Closure { private static final int LEVEL_SINGLE = 0 ; private static final int LEVEL_MULTIPLE = 1 ; private static final int LEVEL_ANY = 2 ; static final private String [ ] ClassNames = { "org.apache.xalan.xsltc.dom.SingleNodeCounter" , "org.apache.xalan.xsltc.dom.MultipleNodeCounter" , "org.apache.xalan.xsltc.dom.AnyNodeCounter" } ; static final private String [ ] FieldNames = { "___single_node_counter" , "___multiple_node_counter" , "___any_node_counter" } ; private Pattern _from = null ; private Pattern _count = null ; private Expression _value = null ; private AttributeValueTemplate _lang = null ; private AttributeValueTemplate _format = null ; private AttributeValueTemplate _letterValue = null ; private AttributeValueTemplate _groupingSeparator = null ; private AttributeValueTemplate _groupingSize = null ; private int _level = LEVEL_SINGLE ; private boolean _formatNeeded = false ; private String _className = null ; private ArrayList _closureVars = null ; public boolean inInnerClass ( ) { return ( _className != null ) ; } public Closure getParentClosure ( ) { return null ; } public String getInnerClassName ( ) { return _className ; } public void addVariable ( VariableRefBase variableRef ) { if ( _closureVars == null ) { _closureVars = new ArrayList ( ) ; } if ( ! _closureVars . contains ( variableRef ) ) { _closureVars . add ( variableRef ) ; } } public void parseContents ( Parser parser ) { final int count = _attributes . getLength ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final String name = _attributes . getQName ( i ) ; final String value = _attributes . getValue ( i ) ; if ( name . equals ( "value" ) ) { _value = parser . parseExpression ( this , name , null ) ; } else if ( name . equals ( "count" ) ) { _count = parser . parsePattern ( this , name , null ) ; } else if ( name . equals ( "from" ) ) { _from = parser . parsePattern ( this , name , null ) ; } else if ( name . equals ( "level" ) ) { if ( value . equals ( "single" ) ) { _level = LEVEL_SINGLE ; } else if ( value . equals ( "multiple" ) ) { _level = LEVEL_MULTIPLE ; } else if ( value . equals ( "any" ) ) { _level = LEVEL_ANY ; } } else if ( name . equals ( "format" ) ) { _format = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } else if ( name . equals ( "lang" ) ) { _lang = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } else if ( name . equals ( "letter-value" ) ) { _letterValue = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } else if ( name . equals ( "grouping-separator" ) ) { _groupingSeparator = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } else if ( name . equals ( "grouping-size" ) ) { _groupingSize = new AttributeValueTemplate ( value , parser , this ) ; _formatNeeded = true ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _value != null ) { Type tvalue = _value . typeCheck ( stable ) ; if ( tvalue instanceof RealType == false ) { _value = new CastExpr ( _value , Type . Real ) ; } } if ( _count != null ) { _count . typeCheck ( stable ) ; } if ( _from != null ) { _from . typeCheck ( stable ) ; } if ( _format != null ) { _format . typeCheck ( stable ) ; } if ( _lang != null ) { _lang . typeCheck ( stable ) ; } if ( _letterValue != null ) { _letterValue . typeCheck ( stable ) ; } if ( _groupingSeparator != null ) { _groupingSeparator . typeCheck ( stable ) ; } if ( _groupingSize != null ) { _groupingSize . typeCheck ( stable ) ; } return Type . Void ; } public boolean hasValue ( ) { return _value != null ; } public boolean isDefault ( ) { return _from == null && _count == null ; } private void compileDefault ( ClassGenerator classGen , MethodGenerator methodGen ) { int index ; ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; int [ ] fieldIndexes = getXSLTC ( ) . getNumberFieldIndexes ( ) ; if ( fieldIndexes [ _level ] == - 1 ) { Field defaultNode = new Field ( ACC_PRIVATE , cpg . addUtf8 ( FieldNames [ _level ] ) , cpg . addUtf8 ( NODE_COUNTER_SIG ) , null , cpg . getConstantPool ( ) ) ; classGen . addField ( defaultNode ) ; fieldIndexes [ _level ] = cpg . addFieldref ( classGen . getClassName ( ) , FieldNames [ _level ] , NODE_COUNTER_SIG ) ; } il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( fieldIndexes [ _level ] ) ) ; final BranchHandle ifBlock1 = il . append ( new IFNONNULL ( null ) ) ; index = cpg . addMethodref ( ClassNames [ _level ] , "getDefaultNodeCounter" , "(" + TRANSLET_INTF_SIG + DOM_INTF_SIG + NODE_ITERATOR_SIG + ")" + NODE_COUNTER_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; il . append ( DUP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( SWAP ) ; il . append ( new PUTFIELD ( fieldIndexes [ _level ] ) ) ; final BranchHandle ifBlock2 = il . append ( new GOTO ( null ) ) ; ifBlock1 . setTarget ( il . append ( classGen . loadTranslet ( ) ) ) ; il . append ( new GETFIELD ( fieldIndexes [ _level ] ) ) ; ifBlock2 . setTarget ( il . append ( NOP ) ) ; } private void compileConstructor ( ClassGenerator classGen ) { MethodGenerator cons ; final InstructionList il = new InstructionList ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; cons = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( TRANSLET_INTF_SIG ) , Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) } , new String [ ] { "dom" , "translet" , "iterator" } , "<init>" , _className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( ALOAD_1 ) ; il . append ( ALOAD_2 ) ; il . append ( new ALOAD ( 3 ) ) ; int index = cpg . addMethodref ( ClassNames [ _level ] , "<init>" , "(" + TRANSLET_INTF_SIG + DOM_INTF_SIG + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new INVOKESPECIAL ( index ) ) ; il . append ( RETURN ) ; cons . stripAttributes ( true ) ; cons . setMaxLocals ( ) ; cons . setMaxStack ( ) ; classGen . addMethod ( cons . getMethod ( ) ) ; } private void compileLocals ( NodeCounterGenerator nodeCounterGen , MatchGenerator matchGen , InstructionList il ) { int field ; LocalVariableGen local ; ConstantPoolGen cpg = nodeCounterGen . getConstantPool ( ) ; local = matchGen . addLocalVariable ( "iterator" , Util . getJCRefType ( NODE_ITERATOR_SIG ) , null , null ) ; field = cpg . addFieldref ( NODE_COUNTER , "_iterator" , ITERATOR_FIELD_SIG ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( field ) ) ; il . append ( new ASTORE ( local . getIndex ( ) ) ) ; matchGen . setIteratorIndex ( local . getIndex ( ) ) ; local = matchGen . addLocalVariable ( "translet" , Util . getJCRefType ( TRANSLET_SIG ) , null , null ) ; field = cpg . addFieldref ( NODE_COUNTER , "_translet" , "Lorg/apache/xalan/xsltc/Translet;" ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( field ) ) ; il . append ( new CHECKCAST ( cpg . addClass ( TRANSLET_CLASS ) ) ) ; il . append ( new ASTORE ( local . getIndex ( ) ) ) ; nodeCounterGen . setTransletIndex ( local . getIndex ( ) ) ; local = matchGen . addLocalVariable ( "document" , Util . getJCRefType ( DOM_INTF_SIG ) , null , null ) ; field = cpg . addFieldref ( _className , "_document" , DOM_INTF_SIG ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( field ) ) ; il . append ( new ASTORE ( local . getIndex ( ) ) ) ; matchGen . setDomIndex ( local . getIndex ( ) ) ; } private void compilePatterns ( ClassGenerator classGen , MethodGenerator methodGen ) { int current ; int field ; LocalVariableGen local ; MatchGenerator matchGen ; NodeCounterGenerator nodeCounterGen ; _className = getXSLTC ( ) . getHelperClassName ( ) ; nodeCounterGen = new NodeCounterGenerator ( _className , ClassNames [ _level ] , toString ( ) , ACC_PUBLIC | ACC_SUPER , null , classGen . getStylesheet ( ) ) ; InstructionList il = null ; ConstantPoolGen cpg = nodeCounterGen . getConstantPool ( ) ; final int closureLen = ( _closureVars == null ) ? 0 : _closureVars . size ( ) ; for ( int i = 0 ; i < closureLen ; i ++ ) { VariableBase var = ( ( VariableRefBase ) _closureVars . get ( i ) ) . getVariable ( ) ; nodeCounterGen . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getEscapedName ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; } compileConstructor ( nodeCounterGen ) ; if ( _from != null ) { il = new InstructionList ( ) ; matchGen = new MatchGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , } , new String [ ] { "node" , } , "matchesFrom" , _className , il , cpg ) ; compileLocals ( nodeCounterGen , matchGen , il ) ; il . append ( matchGen . loadContextNode ( ) ) ; _from . translate ( nodeCounterGen , matchGen ) ; _from . synthesize ( nodeCounterGen , matchGen ) ; il . append ( IRETURN ) ; matchGen . stripAttributes ( true ) ; matchGen . setMaxLocals ( ) ; matchGen . setMaxStack ( ) ; matchGen . removeNOPs ( ) ; nodeCounterGen . addMethod ( matchGen . getMethod ( ) ) ; } if ( _count != null ) { il = new InstructionList ( ) ; matchGen = new MatchGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , } , new String [ ] { "node" , } , "matchesCount" , _className , il , cpg ) ; compileLocals ( nodeCounterGen , matchGen , il ) ; il . append ( matchGen . loadContextNode ( ) ) ; _count . translate ( nodeCounterGen , matchGen ) ; _count . synthesize ( nodeCounterGen , matchGen ) ; il . append ( IRETURN ) ; matchGen . stripAttributes ( true ) ; matchGen . setMaxLocals ( ) ; matchGen . setMaxStack ( ) ; matchGen . removeNOPs ( ) ; nodeCounterGen . addMethod ( matchGen . getMethod ( ) ) ; } getXSLTC ( ) . dumpClass ( nodeCounterGen . getJavaClass ( ) ) ; cpg = classGen . getConstantPool ( ) ; il = methodGen . getInstructionList ( ) ; final int index = cpg . addMethodref ( _className , "<init>" , "(" + TRANSLET_INTF_SIG + DOM_INTF_SIG + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( _className ) ) ) ; il . append ( DUP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( new INVOKESPECIAL ( index ) ) ; for ( int i = 0 ; i < closureLen ; i ++ ) { final VariableRefBase varRef = ( VariableRefBase ) _closureVars . get ( i ) ; final VariableBase var = varRef . getVariable ( ) ; final Type varType = var . getType ( ) ; il . append ( DUP ) ; il . append ( var . loadInstruction ( ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( _className , var . getEscapedName ( ) , varType . toSignature ( ) ) ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { int index ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( hasValue ( ) ) { compileDefault ( classGen , methodGen ) ; _value . translate ( classGen , methodGen ) ; index = cpg . addMethodref ( MATH_CLASS , "round" , "(D)J" ) ; il . append ( new INVOKESTATIC ( index ) ) ; il . append ( new L2I ( ) ) ; index = cpg . addMethodref ( NODE_COUNTER , "setValue" , "(I)" + NODE_COUNTER_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } else if ( isDefault ( ) ) { compileDefault ( classGen , methodGen ) ; } else { compilePatterns ( classGen , methodGen ) ; } if ( ! hasValue ( ) ) { il . append ( methodGen . loadContextNode ( ) ) ; index = cpg . addMethodref ( NODE_COUNTER , SET_START_NODE , "(I)" + NODE_COUNTER_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } if ( _formatNeeded ) { if ( _format != null ) { _format . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , "1" ) ) ; } if ( _lang != null ) { _lang . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , "en" ) ) ; } if ( _letterValue != null ) { _letterValue . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; } if ( _groupingSeparator != null ) { _groupingSeparator . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; } if ( _groupingSize != null ) { _groupingSize . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , "0" ) ) ; } index = cpg . addMethodref ( NODE_COUNTER , "getCounter" , "(" + STRING_SIG + STRING_SIG + STRING_SIG + STRING_SIG + STRING_SIG + ")" + STRING_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } else { index = cpg . addMethodref ( NODE_COUNTER , "setDefaultFormatting" , "()" + NODE_COUNTER_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; index = cpg . addMethodref ( NODE_COUNTER , "getCounter" , "()" + STRING_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } il . append ( methodGen . loadHandler ( ) ) ; index = cpg . addMethodref ( TRANSLET_CLASS , CHARACTERSW , CHARACTERSW_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } } 	1	['15', '3', '0', '53', '104', '23', '2', '52', '9', '0.798319328', '1308', '1', '8', '0.811594203', '0.214285714', '2', '3', '85.06666667', '14', '3.1333', '1']
package org . apache . xalan . serialize ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; public abstract class SerializerFactory { private SerializerFactory ( ) { } public static Serializer getSerializer ( Properties format ) { org . apache . xml . serializer . Serializer ser ; ser = org . apache . xml . serializer . SerializerFactory . getSerializer ( format ) ; SerializerFactory . SerializerWrapper si = new SerializerWrapper ( ser ) ; return si ; } private static class SerializerWrapper implements Serializer { private final org . apache . xml . serializer . Serializer m_serializer ; private DOMSerializer m_old_DOMSerializer ; SerializerWrapper ( org . apache . xml . serializer . Serializer ser ) { m_serializer = ser ; } public void setOutputStream ( OutputStream output ) { m_serializer . setOutputStream ( output ) ; } public OutputStream getOutputStream ( ) { return m_serializer . getOutputStream ( ) ; } public void setWriter ( Writer writer ) { m_serializer . setWriter ( writer ) ; } public Writer getWriter ( ) { return m_serializer . getWriter ( ) ; } public void setOutputFormat ( Properties format ) { m_serializer . setOutputFormat ( format ) ; } public Properties getOutputFormat ( ) { return m_serializer . getOutputFormat ( ) ; } public ContentHandler asContentHandler ( ) throws IOException { return m_serializer . asContentHandler ( ) ; } public DOMSerializer asDOMSerializer ( ) throws IOException { if ( m_old_DOMSerializer == null ) { m_old_DOMSerializer = new DOMSerializerWrapper ( m_serializer . asDOMSerializer ( ) ) ; } return m_old_DOMSerializer ; } public boolean reset ( ) { return m_serializer . reset ( ) ; } } private static class DOMSerializerWrapper implements DOMSerializer { private final org . apache . xml . serializer . DOMSerializer m_dom ; DOMSerializerWrapper ( org . apache . xml . serializer . DOMSerializer domser ) { m_dom = domser ; } public void serialize ( Node node ) throws IOException { m_dom . serialize ( node ) ; } } } 	1	['2', '1', '0', '4', '5', '1', '0', '4', '1', '2', '15', '0', '0', '0', '0.5', '0', '0', '6.5', '1', '0.5', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_ko extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "일치 패턴에서 current() 함수가 허용되지 않습니다!" } , { ER_CURRENT_TAKES_NO_ARGS , "current() 함수가 인수를 승인하지 않습니다!" } , { ER_DOCUMENT_REPLACED , "document() 함수 구현이 org.apache.xalan.xslt.FuncDocument로 바뀌었습니다!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "문맥에 소유자 문서가 없습니다!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name()이 너무 많은 인수를 가집니다." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri()가 너무 많은 인수를 가집니다." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space()가 너무 많은 인수를 가집니다." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number()가 너무 많은 인수를 가집니다." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name()이 너무 많은 인수를 가집니다." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string()이 너무 많은 인수를 가집니다." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length()가 너무 많은 인수를 가집니다." } , { ER_TRANSLATE_TAKES_3_ARGS , "translate() 함수가 세 개의 인수를 취합니다!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "unparsed-entity-uri 함수는 하나의 인수를 취해야 합니다!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "이름 공간 축이 아직 구현되지 않았습니다!" } , { ER_UNKNOWN_AXIS , "알 수 없는 축: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "알 수 없는 일치 조작입니다!" } , { ER_INCORRECT_ARG_LENGTH , "processing-instruction() node 테스트의 인수 길이가 올바르지 않습니다!" } , { ER_CANT_CONVERT_TO_NUMBER , "{0}을(를) 숫자로 변환할 수 없습니다." } , { ER_CANT_CONVERT_TO_NODELIST , "{0}을(를) NodeList로 변환할 수 없습니다!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0}을(를) NodeSetDTM으로 변환할 수 없습니다!" } , { ER_CANT_CONVERT_TO_TYPE , "{0}을(를) 유형 번호 {1}(으)로 변환할 수 없습니다." } , { ER_EXPECTED_MATCH_PATTERN , "getMatchScore에서 패턴이 일치할 것이라 예상했습니다!" } , { ER_COULDNOT_GET_VAR_NAMED , "이름이 {0}인 변수를 가져올 수 없습니다." } , { ER_UNKNOWN_OPCODE , "오류! 알 수 없는 op 코드: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "유효하지 않은 추가 토큰: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "따옴표가 틀린 리터럴... 큰 따옴표를 예상했습니다!" } , { ER_EXPECTED_SINGLE_QUOTE , "따옴표가 틀린 리터럴... 작은 따옴표를 예상했습니다!" } , { ER_EMPTY_EXPRESSION , "빈 표현식!" } , { ER_EXPECTED_BUT_FOUND , "{0}을(를) 예상했으나 {1}이(가) 발견됨" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "프로그래머 단언문이 올바르지 않습니다! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "19990709 XPath 초안에서는 부울(...) 인수가 더 이상 선택적이지 않습니다." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "','를 발견했으나 그 앞에 어떠한 인수도 없습니다!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "','를 발견했으나 뒤에 어떠한 인수도 없습니다!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' 또는 '.[predicate]'는 유효하지 않은 구문입니다.  대신 'self::node()[predicate]'를 사용하십시오." } , { ER_ILLEGAL_AXIS_NAME , "유효하지 않은 축 이름: {0}" } , { ER_UNKNOWN_NODETYPE , "알 수 없는 노드 유형: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "패턴 리터럴({0})은 따옴표가 있어야 합니다!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0}은(는) 숫자로 포맷할 수 없습니다!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "XML TransformerFactory Liaison을 작성할 수 없습니다: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "오류! xpath 선택 표현식(-select)을 찾을 수 없습니다." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "오류! OP_LOCATIONPATH 뒤에 ENDOP를 찾을 수 없습니다." } , { ER_ERROR_OCCURED , "오류가 발생했습니다!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "변수에 대해 주어진 VariableReference가 범위를 벗어났거나 정의가 없습니다!  이름 = {0}" } , { ER_AXES_NOT_ALLOWED , "하위:: 및 속성:: 축만 패턴에 일치할 수 있습니다!  위반 축 = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key()의 인수 수가 올바르지 않습니다." } , { ER_COUNT_TAKES_1_ARG , "count 함수는 하나의 인수를 취해야 합니다!" } , { ER_COULDNOT_FIND_FUNCTION , "함수를 찾을 수 없습니다: {0}" } , { ER_UNSUPPORTED_ENCODING , "지원되지 않는 인코딩: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "getNextSibling의 DTM에 문제가 발생했습니다... 복구 시도 중" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "프로그래머 오류: EmptyNodeList를 쓸 수 없습니다." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "XPathContext에서 setDOMFactory를 지원하지 않습니다!" } , { ER_PREFIX_MUST_RESOLVE , "접두부는 이름 공간으로 분석되어야 합니다: {0}" } , { ER_PARSE_NOT_SUPPORTED , "XPathContext에서 구문 분석(InputSource 소스)이 지원되지 않습니다! {0}을(를) 열 수 없습니다." } , { ER_SAX_API_NOT_HANDLED , "SAX API 문자(char ch[]... 가 DTM에 의해 처리되지 않습니다!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... 가 DTM에 의해 처리되지 않습니다!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison이 {0} 유형의 노드를 처리할 수 없습니다." } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper가 {0} 유형의 노드를 처리할 수 없습니다." } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse 오류: 시스템 ID - {0} 회선 - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse 오류" } , { ER_INVALID_UTF16_SURROGATE , "잘못된 UTF-16 대리자(surrogate)가 발견되었습니다: {0} ?" } , { ER_OIERROR , "IO 오류" } , { ER_CANNOT_CREATE_URL , "url을 작성할 수 없습니다: {0}" } , { ER_XPATH_READOBJECT , "XPath.readObject의 {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "함수 토큰이 없습니다." } , { ER_CANNOT_DEAL_XPATH_TYPE , "XPath 유형을 처리할 수 없습니다: {0}" } , { ER_NODESET_NOT_MUTABLE , "이 NodeSet가 가변적이지 않습니다." } , { ER_NODESETDTM_NOT_MUTABLE , "이 NodeSetDTM이 가변적이지 않습니다." } , { ER_VAR_NOT_RESOLVABLE , "변수를 분석할 수 없습니다: {0}" } , { ER_NULL_ERROR_HANDLER , "널(null) 오류 핸들러" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "프로그래머의 단언문: 알 수 없는 op 코드: {0}" } , { ER_ZERO_OR_ONE , "0 또는 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "XRTreeFragSelectWrapper에서 rtf()를 지원하지 않습니다." } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "XRTreeFragSelectWrapper에서 asNodeIterator()를 지원하지 않습니다." } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "XStringForChars에 대해 fsb()가 지원되지 않습니다." } , { ER_COULD_NOT_FIND_VAR , "이름이 {0}인 변수를 찾을 수 없습니다." } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars는 인수로 문자열을 가져올 수 없습니다." } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer 인수는 널(null)이 될 수 없습니다." } , { ER_TWO_OR_THREE , "2 또는 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "변수가 바인드되기 전에 변수에 액세스했습니다!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB는 인수로 문자열을 취할 수 없습니다!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! 오류! 워커의 루트로 널(null)이 설정되었습니다!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "이 NodeSetDTM은 이전 노드로 반복할 수 없습니다!" } , { ER_NODESET_CANNOT_ITERATE , "이 NodeSet는 이전 노드로 반복할 수 없습니다!" } , { ER_NODESETDTM_CANNOT_INDEX , "이 NodeSetDTM은 색인 또는 카운팅 함수를 사용할 수 없습니다!" } , { ER_NODESET_CANNOT_INDEX , "이 NodeSet는 색인 또는 카운팅 함수를 사용할 수 없습니다!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "nextNode가 호출된 후에 setShouldCacheNodes를 호출할 수 없습니다!" } , { ER_ONLY_ALLOWS , "{0}은(는) {1} 인수만을 허용합니다." } , { ER_UNKNOWN_STEP , "getNextStepPos에 프로그래머의 단언문: 알 수 없는 stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "관련 위치 경로가 다음의 '/' 또는 '//' 토큰을 예상했습니다." } , { ER_EXPECTED_LOC_PATH , "위치 경로가 예상되었지만 다음 토큰이 발견되었습니다:  {0}" } , { ER_EXPECTED_LOC_STEP , "위치 단계가 다음의 '/' 또는 '//' 토큰을 예상했습니다." } , { ER_EXPECTED_NODE_TEST , "NCName:* 또는 QName과 일치하는 노드 테스트가 예상되었습니다." } , { ER_EXPECTED_STEP_PATTERN , "단계 패턴이 예상되었지만 '/'가 발견되었습니다." } , { ER_EXPECTED_REL_PATH_PATTERN , "관련 경로 패턴이 예상되었습니다." } , { ER_CANT_CONVERT_TO_BOOLEAN , "{0}을(를) 부울로 변환할 수 없습니다." } , { ER_CANT_CONVERT_TO_SINGLENODE , "{0}을(를) 단일 노드로 변환할 수 없습니다. 이러한 getter 은 ANY_UNORDERED_NODE_TYPE 및 FIRST_ORDERED_NODE_TYPE 유형에 적용됩니다." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "{0} 유형에 대한 스냅샷 길이를 가져올 수 없습니다. 이러한 getter 은 UNORDERED_NODE_SNAPSHOT_TYPE 및 ORDERED_NODE_SNAPSHOT_TYPE 유형에 적용됩니다." } , { ER_NON_ITERATOR_TYPE , "비 반복기 유형 {0}에 대해 반복할 수 없습니다." } , { ER_DOC_MUTATED , "결과가 리턴되었으므로 문서가 변경됩니다. 반복기가 올바르지 않습니다." } , { ER_INVALID_XPATH_TYPE , "잘못된 XPath 유형 인수: {0}" } , { ER_EMPTY_XPATH_RESULT , "비어 있는 XPath result 오브젝트" } , { ER_INCOMPATIBLE_TYPES , "리턴된 유형 {0}은(는) 지정된 유형 {1}(으)로 강제 지정될 수 없습니다." } , { ER_NULL_RESOLVER , "널(null) 접두부 분석기로 접두부를 분석할 수 없습니다." } , { ER_CANT_CONVERT_TO_STRING , "{0}을(를) 문자열로 변환할 수 없습니다." } , { ER_NON_SNAPSHOT_TYPE , "{0} 유형에 대한 snapshotItem을 호출할 수 없습니다. 이러한 방법은 UNORDERED_NODE_SNAPSHOT_TYPE 및 ORDERED_NODE_SNAPSHOT_TYPE 유형에 적용됩니다." } , { ER_WRONG_DOCUMENT , "컨텍스트 노드는 이 XPathEvaluator로 바인드되는 문서에 포함되지 않습니다." } , { ER_WRONG_NODETYPE , "컨텍스트 노드 유형이 지원되지 않습니다." } , { ER_XPATH_ERROR , "XPath의 알 수 없는 오류." } , { WG_LOCALE_NAME_NOT_HANDLED , "format-number 함수에 있는 로케일 이름이 아직 처리되지 않았습니다!" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL 특성이 지원되지 않습니다: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "특성에서 {0} 이름 공간과 관련하여 현재 아무런 작업도 수행하지 않습니다: {1}" } , { WG_SECURITY_EXCEPTION , "XSL 시스템 특성에 액세스 시도 중 SecurityException: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "이전 구문: quo(...)가 더 이상 XPath에 정의되지 않습니다." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "nodeTest를 구현하려면 XPath에 도출된 오브젝트가 있어야 합니다!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "함수 토큰이 없습니다." } , { WG_COULDNOT_FIND_FUNCTION , "함수를 찾을 수 없습니다: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "{0}에서 URL을 작성할 수 없습니다." } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "DTM 구문 분석기에 대해 -E 옵션이 지원되지 않습니다." } , { WG_ILLEGAL_VARIABLE_REFERENCE , "변수에 대해 주어진 VariableReference가 범위를 벗어났거나 정의가 없습니다! 이름 = {0}" } , { WG_UNSUPPORTED_ENCODING , "지원되지 않는 인코딩: {0}" } , { "ui_language" , "ko" } , { "help_language" , "ko" } , { "language" , "ko" } , { "BAD_CODE" , "createMessage에 대한 매개변수가 범위를 벗어남" } , { "FORMAT_FAILED" , "messageFormat 호출 중 예외 발생" } , { "version" , ">>>>>>> Xalan 버전 " } , { "version2" , "<<<<<<<" } , { "yes" , "예" } , { "line" , "행 #" } , { "column" , "열 #" } , { "xsldone" , "XSLProcessor: 완료" } , { "xpath_option" , "xpath 옵션: " } , { "optionIN" , "[-in inputXMLURL]" } , { "optionSelect" , "[-select xpath expression]" } , { "optionMatch" , "[-match match pattern (일치 진단을 위해)]" } , { "optionAnyExpr" , "또는 xpath 표현식만으로 진단 덤프가 수행될 것입니다." } , { "noParsermsg1" , "XSL 프로세스가 실패했습니다." } , { "noParsermsg2" , "** 구문 분석기를 찾을 수 없습니다. **" } , { "noParsermsg3" , "클래스 경로를 점검하십시오." } , { "noParsermsg4" , "Java용 IBM XML 구문 분석기가 없으면" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml 에서 다운로드 할 수 있습니다." } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "오류: " ; public static final String WARNING_HEADER = "경고: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "ko" , "KR" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XNodeSet ; public class FilterExprIteratorSimple extends LocPathIterator { private Expression m_expr ; transient private XNodeSet m_exprObj ; private boolean m_mustHardReset = false ; private boolean m_canDetachNodeset = true ; public FilterExprIteratorSimple ( ) { super ( null ) ; } public FilterExprIteratorSimple ( Expression expr ) { super ( null ) ; m_expr = expr ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_exprObj = executeFilterExpr ( context , m_execContext , getPrefixResolver ( ) , getIsTopLevel ( ) , m_stackFrame , m_expr ) ; } public static XNodeSet executeFilterExpr ( int context , XPathContext xctxt , PrefixResolver prefixResolver , boolean isTopLevel , int stackFrame , Expression expr ) throws org . apache . xml . utils . WrappedRuntimeException { PrefixResolver savedResolver = xctxt . getNamespaceContext ( ) ; XNodeSet result = null ; try { xctxt . pushCurrentNode ( context ) ; xctxt . setNamespaceContext ( prefixResolver ) ; if ( isTopLevel ) { VariableStack vars = xctxt . getVarStack ( ) ; int savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( stackFrame ) ; result = ( org . apache . xpath . objects . XNodeSet ) expr . execute ( xctxt ) ; result . setShouldCacheNodes ( true ) ; vars . setStackFrame ( savedStart ) ; } else result = ( org . apache . xpath . objects . XNodeSet ) expr . execute ( xctxt ) ; } catch ( javax . xml . transform . TransformerException se ) { throw new org . apache . xml . utils . WrappedRuntimeException ( se ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . setNamespaceContext ( savedResolver ) ; } return result ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next ; if ( null != m_exprObj ) { m_lastFetched = next = m_exprObj . nextNode ( ) ; } else m_lastFetched = next = DTM . NULL ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } public void detach ( ) { if ( m_allowDetach ) { super . detach ( ) ; m_exprObj . detach ( ) ; m_exprObj = null ; } } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; m_expr . fixupVariables ( vars , globalsSize ) ; } public Expression getInnerExpression ( ) { return m_expr ; } public void setInnerExpression ( Expression expr ) { expr . exprSetParent ( this ) ; m_expr = expr ; } public int getAnalysisBits ( ) { if ( null != m_expr && m_expr instanceof PathComponent ) { return ( ( PathComponent ) m_expr ) . getAnalysisBits ( ) ; } return WalkerFactory . BIT_FILTER ; } public boolean isDocOrdered ( ) { return m_exprObj . isDocOrdered ( ) ; } class filterExprOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_expr ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FilterExprIteratorSimple . this ) ; m_expr = exp ; } } public void callPredicateVisitors ( XPathVisitor visitor ) { m_expr . callVisitors ( new filterExprOwner ( ) , visitor ) ; super . callPredicateVisitors ( visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; FilterExprIteratorSimple fet = ( FilterExprIteratorSimple ) expr ; if ( ! m_expr . deepEquals ( fet . m_expr ) ) return false ; return true ; } public int getAxis ( ) { if ( null != m_exprObj ) return m_exprObj . getAxis ( ) ; else return Axis . FILTEREDLIST ; } } 	1	['16', '5', '0', '16', '44', '8', '4', '13', '14', '0.75', '261', '1', '2', '0.899280576', '0.18125', '3', '10', '15.0625', '4', '1.4375', '1']
package org . apache . xml . serializer ; import java . io . Writer ; import java . io . OutputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . xml . serializer . DOMSerializer ; import org . xml . sax . ContentHandler ; public interface Serializer { public void setOutputStream ( OutputStream output ) ; public OutputStream getOutputStream ( ) ; public void setWriter ( Writer writer ) ; public Writer getWriter ( ) ; public void setOutputFormat ( Properties format ) ; public Properties getOutputFormat ( ) ; public ContentHandler asContentHandler ( ) throws IOException ; public DOMSerializer asDOMSerializer ( ) throws IOException ; public boolean reset ( ) ; } 	1	['9', '1', '0', '11', '9', '36', '10', '1', '9', '2', '9', '0', '0', '0', '0.333333333', '0', '0', '0', '1', '1', '1']
package org . apache . xpath . objects ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xpath . res . XPATHErrorResources ; public class XStringForFSB extends XString { int m_start ; int m_length ; protected String m_strCache = null ; protected int m_hash = 0 ; public XStringForFSB ( FastStringBuffer val , int start , int length ) { super ( val ) ; m_start = start ; m_length = length ; if ( null == val ) throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , null ) ) ; } private XStringForFSB ( String val ) { super ( val ) ; throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_FSB_CANNOT_TAKE_STRING , null ) ) ; } public FastStringBuffer fsb ( ) { return ( ( FastStringBuffer ) m_obj ) ; } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { fsb . append ( str ( ) ) ; } public boolean hasString ( ) { return ( null != m_strCache ) ; } public Object object ( ) { return str ( ) ; } public String str ( ) { if ( null == m_strCache ) { m_strCache = fsb ( ) . getString ( m_start , m_length ) ; } return m_strCache ; } public void dispatchCharactersEvents ( org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { fsb ( ) . sendSAXcharacters ( ch , m_start , m_length ) ; } public void dispatchAsComment ( org . xml . sax . ext . LexicalHandler lh ) throws org . xml . sax . SAXException { fsb ( ) . sendSAXComment ( lh , m_start , m_length ) ; } public int length ( ) { return m_length ; } public char charAt ( int index ) { return fsb ( ) . charAt ( m_start + index ) ; } public void getChars ( int srcBegin , int srcEnd , char dst [ ] , int dstBegin ) { int n = srcEnd - srcBegin ; if ( n > m_length ) n = m_length ; if ( n > ( dst . length - dstBegin ) ) n = ( dst . length - dstBegin ) ; int end = srcBegin + m_start + n ; int d = dstBegin ; FastStringBuffer fsb = fsb ( ) ; for ( int i = srcBegin + m_start ; i < end ; i ++ ) { dst [ d ++ ] = fsb . charAt ( i ) ; } } public boolean equals ( XMLString obj2 ) { if ( this == obj2 ) { return true ; } int n = m_length ; if ( n == obj2 . length ( ) ) { FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { if ( fsb . charAt ( i ) != obj2 . charAt ( j ) ) { return false ; } i ++ ; j ++ ; } return true ; } return false ; } public boolean equals ( XObject obj2 ) { if ( this == obj2 ) { return true ; } if ( obj2 . getType ( ) == XObject . CLASS_NUMBER ) return obj2 . equals ( this ) ; String str = obj2 . str ( ) ; int n = m_length ; if ( n == str . length ( ) ) { FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { if ( fsb . charAt ( i ) != str . charAt ( j ) ) { return false ; } i ++ ; j ++ ; } return true ; } return false ; } public boolean equals ( String anotherString ) { int n = m_length ; if ( n == anotherString . length ( ) ) { FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { if ( fsb . charAt ( i ) != anotherString . charAt ( j ) ) { return false ; } i ++ ; j ++ ; } return true ; } return false ; } public boolean equals ( Object obj2 ) { if ( null == obj2 ) return false ; if ( obj2 instanceof XNumber ) return obj2 . equals ( this ) ; else if ( obj2 instanceof XNodeSet ) return obj2 . equals ( this ) ; else if ( obj2 instanceof XStringForFSB ) return equals ( ( XMLString ) this ) ; else return equals ( obj2 . toString ( ) ) ; } public boolean equalsIgnoreCase ( String anotherString ) { return ( m_length == anotherString . length ( ) ) ? str ( ) . equalsIgnoreCase ( anotherString ) : false ; } public int compareTo ( XMLString xstr ) { int len1 = m_length ; int len2 = xstr . length ( ) ; int n = Math . min ( len1 , len2 ) ; FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { char c1 = fsb . charAt ( i ) ; char c2 = xstr . charAt ( j ) ; if ( c1 != c2 ) { return c1 - c2 ; } i ++ ; j ++ ; } return len1 - len2 ; } public int compareToIgnoreCase ( XMLString xstr ) { int len1 = m_length ; int len2 = xstr . length ( ) ; int n = Math . min ( len1 , len2 ) ; FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = 0 ; while ( n -- != 0 ) { char c1 = Character . toLowerCase ( fsb . charAt ( i ) ) ; char c2 = Character . toLowerCase ( xstr . charAt ( j ) ) ; if ( c1 != c2 ) { return c1 - c2 ; } i ++ ; j ++ ; } return len1 - len2 ; } public int hashCode ( ) { return super . hashCode ( ) ; } public boolean startsWith ( XMLString prefix , int toffset ) { FastStringBuffer fsb = fsb ( ) ; int to = m_start + toffset ; int tlim = m_start + m_length ; int po = 0 ; int pc = prefix . length ( ) ; if ( ( toffset < 0 ) || ( toffset > m_length - pc ) ) { return false ; } while ( -- pc >= 0 ) { if ( fsb . charAt ( to ) != prefix . charAt ( po ) ) { return false ; } to ++ ; po ++ ; } return true ; } public boolean startsWith ( XMLString prefix ) { return startsWith ( prefix , 0 ) ; } public int indexOf ( int ch ) { return indexOf ( ch , 0 ) ; } public int indexOf ( int ch , int fromIndex ) { int max = m_start + m_length ; FastStringBuffer fsb = fsb ( ) ; if ( fromIndex < 0 ) { fromIndex = 0 ; } else if ( fromIndex >= m_length ) { return - 1 ; } for ( int i = m_start + fromIndex ; i < max ; i ++ ) { if ( fsb . charAt ( i ) == ch ) { return i - m_start ; } } return - 1 ; } public XMLString substring ( int beginIndex ) { int len = m_length - beginIndex ; if ( len <= 0 ) return XString . EMPTYSTRING ; else { int start = m_start + beginIndex ; return new XStringForFSB ( fsb ( ) , start , len ) ; } } public XMLString substring ( int beginIndex , int endIndex ) { int len = endIndex - beginIndex ; if ( len > m_length ) len = m_length ; if ( len <= 0 ) return XString . EMPTYSTRING ; else { int start = m_start + beginIndex ; return new XStringForFSB ( fsb ( ) , start , len ) ; } } public XMLString concat ( String str ) { return new XString ( str ( ) . concat ( str ) ) ; } public XMLString trim ( ) { return fixWhiteSpace ( true , true , false ) ; } private static boolean isSpace ( char ch ) { return XMLCharacterRecognizer . isWhiteSpace ( ch ) ; } public XMLString fixWhiteSpace ( boolean trimHead , boolean trimTail , boolean doublePunctuationSpaces ) { int end = m_length + m_start ; char [ ] buf = new char [ m_length ] ; FastStringBuffer fsb = fsb ( ) ; boolean edit = false ; int d = 0 ; boolean pres = false ; for ( int s = m_start ; s < end ; s ++ ) { char c = fsb . charAt ( s ) ; if ( isSpace ( c ) ) { if ( ! pres ) { if ( ' ' != c ) { edit = true ; } buf [ d ++ ] = ' ' ; if ( doublePunctuationSpaces && ( d != 0 ) ) { char prevChar = buf [ d - 1 ] ; if ( ! ( ( prevChar == '.' ) || ( prevChar == '!' ) || ( prevChar == '?' ) ) ) { pres = true ; } } else { pres = true ; } } else { edit = true ; pres = true ; } } else { buf [ d ++ ] = c ; pres = false ; } } if ( trimTail && 1 <= d && ' ' == buf [ d - 1 ] ) { edit = true ; d -- ; } int start = 0 ; if ( trimHead && 0 < d && ' ' == buf [ 0 ] ) { edit = true ; start ++ ; } XMLStringFactory xsf = XMLStringFactoryImpl . getFactory ( ) ; return edit ? xsf . newstr ( buf , start , d - start ) : this ; } public double toDouble ( ) { if ( m_length == 0 ) return Double . NaN ; int i ; char c ; String valueString = fsb ( ) . getString ( m_start , m_length ) ; for ( i = 0 ; i < m_length ; i ++ ) if ( ! XMLCharacterRecognizer . isWhiteSpace ( valueString . charAt ( i ) ) ) break ; if ( valueString . charAt ( i ) == '-' ) i ++ ; for ( ; i < m_length ; i ++ ) { c = valueString . charAt ( i ) ; if ( c != '.' && ( c < '0' || c > '9' ) ) break ; } for ( ; i < m_length ; i ++ ) if ( ! XMLCharacterRecognizer . isWhiteSpace ( valueString . charAt ( i ) ) ) break ; if ( i != m_length ) return Double . NaN ; try { return new Double ( valueString ) . doubleValue ( ) ; } catch ( NumberFormatException nfe ) { return Double . NaN ; } } } 	1	['31', '4', '0', '10', '59', '117', '1', '10', '29', '0.5', '823', '0.5', '0', '0.802721088', '0.150537634', '4', '20', '25.41935484', '14', '2.9032', '2']
package org . apache . xalan . extensions ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMNodeIterator ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . objects . XString ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class MethodResolver { public static final int STATIC_ONLY = 1 ; public static final int INSTANCE_ONLY = 2 ; public static final int STATIC_AND_INSTANCE = 3 ; public static final int DYNAMIC = 4 ; public static Constructor getConstructor ( Class classObj , Object [ ] argsIn , Object [ ] [ ] argsOut , ExpressionContext exprContext ) throws NoSuchMethodException , SecurityException , TransformerException { Constructor bestConstructor = null ; Class [ ] bestParamTypes = null ; Constructor [ ] constructors = classObj . getConstructors ( ) ; int nMethods = constructors . length ; int bestScore = Integer . MAX_VALUE ; int bestScoreCount = 0 ; for ( int i = 0 ; i < nMethods ; i ++ ) { Constructor ctor = constructors [ i ] ; Class [ ] paramTypes = ctor . getParameterTypes ( ) ; int numberMethodParams = paramTypes . length ; int paramStart = 0 ; boolean isFirstExpressionContext = false ; int scoreStart ; if ( numberMethodParams == ( argsIn . length + 1 ) ) { Class javaClass = paramTypes [ 0 ] ; if ( ExpressionContext . class . isAssignableFrom ( javaClass ) ) { isFirstExpressionContext = true ; scoreStart = 0 ; paramStart ++ ; } else continue ; } else scoreStart = 1000 ; if ( argsIn . length == ( numberMethodParams - paramStart ) ) { int score = scoreMatch ( paramTypes , paramStart , argsIn , scoreStart ) ; if ( - 1 == score ) continue ; if ( score < bestScore ) { bestConstructor = ctor ; bestParamTypes = paramTypes ; bestScore = score ; bestScoreCount = 1 ; } else if ( score == bestScore ) bestScoreCount ++ ; } } if ( null == bestConstructor ) { throw new NoSuchMethodException ( errString ( "function" , "constructor" , classObj , "" , 0 , argsIn ) ) ; } else convertParams ( argsIn , argsOut , bestParamTypes , exprContext ) ; return bestConstructor ; } public static Method getMethod ( Class classObj , String name , Object [ ] argsIn , Object [ ] [ ] argsOut , ExpressionContext exprContext , int searchMethod ) throws NoSuchMethodException , SecurityException , TransformerException { if ( name . indexOf ( "-" ) > 0 ) name = replaceDash ( name ) ; Method bestMethod = null ; Class [ ] bestParamTypes = null ; Method [ ] methods = classObj . getMethods ( ) ; int nMethods = methods . length ; int bestScore = Integer . MAX_VALUE ; int bestScoreCount = 0 ; boolean isStatic ; for ( int i = 0 ; i < nMethods ; i ++ ) { Method method = methods [ i ] ; int xsltParamStart = 0 ; if ( method . getName ( ) . equals ( name ) ) { isStatic = Modifier . isStatic ( method . getModifiers ( ) ) ; switch ( searchMethod ) { case STATIC_ONLY : if ( ! isStatic ) { continue ; } break ; case INSTANCE_ONLY : if ( isStatic ) { continue ; } break ; case STATIC_AND_INSTANCE : break ; case DYNAMIC : if ( ! isStatic ) xsltParamStart = 1 ; } int javaParamStart = 0 ; Class [ ] paramTypes = method . getParameterTypes ( ) ; int numberMethodParams = paramTypes . length ; boolean isFirstExpressionContext = false ; int scoreStart ; int argsLen = ( null != argsIn ) ? argsIn . length : 0 ; if ( numberMethodParams == ( argsLen - xsltParamStart + 1 ) ) { Class javaClass = paramTypes [ 0 ] ; if ( ExpressionContext . class . isAssignableFrom ( javaClass ) ) { isFirstExpressionContext = true ; scoreStart = 0 ; javaParamStart ++ ; } else { continue ; } } else scoreStart = 1000 ; if ( ( argsLen - xsltParamStart ) == ( numberMethodParams - javaParamStart ) ) { int score = scoreMatch ( paramTypes , javaParamStart , argsIn , scoreStart ) ; if ( - 1 == score ) continue ; if ( score < bestScore ) { bestMethod = method ; bestParamTypes = paramTypes ; bestScore = score ; bestScoreCount = 1 ; } else if ( score == bestScore ) bestScoreCount ++ ; } } } if ( null == bestMethod ) { throw new NoSuchMethodException ( errString ( "function" , "method" , classObj , name , searchMethod , argsIn ) ) ; } else convertParams ( argsIn , argsOut , bestParamTypes , exprContext ) ; return bestMethod ; } private static String replaceDash ( String name ) { char dash = '-' ; StringBuffer buff = new StringBuffer ( "" ) ; for ( int i = 0 ; i < name . length ( ) ; i ++ ) { if ( name . charAt ( i ) == dash ) { } else if ( i > 0 && name . charAt ( i - 1 ) == dash ) buff . append ( Character . toUpperCase ( name . charAt ( i ) ) ) ; else buff . append ( name . charAt ( i ) ) ; } return buff . toString ( ) ; } public static Method getElementMethod ( Class classObj , String name ) throws NoSuchMethodException , SecurityException , TransformerException { Method bestMethod = null ; Method [ ] methods = classObj . getMethods ( ) ; int nMethods = methods . length ; int bestScoreCount = 0 ; for ( int i = 0 ; i < nMethods ; i ++ ) { Method method = methods [ i ] ; if ( method . getName ( ) . equals ( name ) ) { Class [ ] paramTypes = method . getParameterTypes ( ) ; if ( ( paramTypes . length == 2 ) && paramTypes [ 1 ] . isAssignableFrom ( org . apache . xalan . templates . ElemExtensionCall . class ) && paramTypes [ 0 ] . isAssignableFrom ( org . apache . xalan . extensions . XSLProcessorContext . class ) ) { if ( ++ bestScoreCount == 1 ) bestMethod = method ; else break ; } } } if ( null == bestMethod ) { throw new NoSuchMethodException ( errString ( "element" , "method" , classObj , name , 0 , null ) ) ; } else if ( bestScoreCount > 1 ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_MORE_MATCH_ELEMENT , new Object [ ] { name } ) ) ; return bestMethod ; } public static void convertParams ( Object [ ] argsIn , Object [ ] [ ] argsOut , Class [ ] paramTypes , ExpressionContext exprContext ) throws javax . xml . transform . TransformerException { if ( paramTypes == null ) argsOut [ 0 ] = null ; else { int nParams = paramTypes . length ; argsOut [ 0 ] = new Object [ nParams ] ; int paramIndex = 0 ; if ( ( nParams > 0 ) && ExpressionContext . class . isAssignableFrom ( paramTypes [ 0 ] ) ) { argsOut [ 0 ] [ 0 ] = exprContext ; paramIndex ++ ; } if ( argsIn != null ) { for ( int i = argsIn . length - nParams + paramIndex ; paramIndex < nParams ; i ++ , paramIndex ++ ) { argsOut [ 0 ] [ paramIndex ] = convert ( argsIn [ i ] , paramTypes [ paramIndex ] ) ; } } } } static class ConversionInfo { ConversionInfo ( Class cl , int score ) { m_class = cl ; m_score = score ; } Class m_class ; int m_score ; } private static final int SCOREBASE = 1 ; static ConversionInfo [ ] m_javaObjConversions = { new ConversionInfo ( Double . TYPE , 11 ) , new ConversionInfo ( Float . TYPE , 12 ) , new ConversionInfo ( Long . TYPE , 13 ) , new ConversionInfo ( Integer . TYPE , 14 ) , new ConversionInfo ( Short . TYPE , 15 ) , new ConversionInfo ( Character . TYPE , 16 ) , new ConversionInfo ( Byte . TYPE , 17 ) , new ConversionInfo ( java . lang . String . class , 18 ) } ; static ConversionInfo [ ] m_booleanConversions = { new ConversionInfo ( Boolean . TYPE , 0 ) , new ConversionInfo ( java . lang . Boolean . class , 1 ) , new ConversionInfo ( java . lang . Object . class , 2 ) , new ConversionInfo ( java . lang . String . class , 3 ) } ; static ConversionInfo [ ] m_numberConversions = { new ConversionInfo ( Double . TYPE , 0 ) , new ConversionInfo ( java . lang . Double . class , 1 ) , new ConversionInfo ( Float . TYPE , 3 ) , new ConversionInfo ( Long . TYPE , 4 ) , new ConversionInfo ( Integer . TYPE , 5 ) , new ConversionInfo ( Short . TYPE , 6 ) , new ConversionInfo ( Character . TYPE , 7 ) , new ConversionInfo ( Byte . TYPE , 8 ) , new ConversionInfo ( Boolean . TYPE , 9 ) , new ConversionInfo ( java . lang . String . class , 10 ) , new ConversionInfo ( java . lang . Object . class , 11 ) } ; static ConversionInfo [ ] m_stringConversions = { new ConversionInfo ( java . lang . String . class , 0 ) , new ConversionInfo ( java . lang . Object . class , 1 ) , new ConversionInfo ( Character . TYPE , 2 ) , new ConversionInfo ( Double . TYPE , 3 ) , new ConversionInfo ( Float . TYPE , 3 ) , new ConversionInfo ( Long . TYPE , 3 ) , new ConversionInfo ( Integer . TYPE , 3 ) , new ConversionInfo ( Short . TYPE , 3 ) , new ConversionInfo ( Byte . TYPE , 3 ) , new ConversionInfo ( Boolean . TYPE , 4 ) } ; static ConversionInfo [ ] m_rtfConversions = { new ConversionInfo ( org . w3c . dom . traversal . NodeIterator . class , 0 ) , new ConversionInfo ( org . w3c . dom . NodeList . class , 1 ) , new ConversionInfo ( org . w3c . dom . Node . class , 2 ) , new ConversionInfo ( java . lang . String . class , 3 ) , new ConversionInfo ( java . lang . Object . class , 5 ) , new ConversionInfo ( Character . TYPE , 6 ) , new ConversionInfo ( Double . TYPE , 7 ) , new ConversionInfo ( Float . TYPE , 7 ) , new ConversionInfo ( Long . TYPE , 7 ) , new ConversionInfo ( Integer . TYPE , 7 ) , new ConversionInfo ( Short . TYPE , 7 ) , new ConversionInfo ( Byte . TYPE , 7 ) , new ConversionInfo ( Boolean . TYPE , 8 ) } ; static ConversionInfo [ ] m_nodesetConversions = { new ConversionInfo ( org . w3c . dom . traversal . NodeIterator . class , 0 ) , new ConversionInfo ( org . w3c . dom . NodeList . class , 1 ) , new ConversionInfo ( org . w3c . dom . Node . class , 2 ) , new ConversionInfo ( java . lang . String . class , 3 ) , new ConversionInfo ( java . lang . Object . class , 5 ) , new ConversionInfo ( Character . TYPE , 6 ) , new ConversionInfo ( Double . TYPE , 7 ) , new ConversionInfo ( Float . TYPE , 7 ) , new ConversionInfo ( Long . TYPE , 7 ) , new ConversionInfo ( Integer . TYPE , 7 ) , new ConversionInfo ( Short . TYPE , 7 ) , new ConversionInfo ( Byte . TYPE , 7 ) , new ConversionInfo ( Boolean . TYPE , 8 ) } ; static ConversionInfo [ ] [ ] m_conversions = { m_javaObjConversions , m_booleanConversions , m_numberConversions , m_stringConversions , m_nodesetConversions , m_rtfConversions } ; public static int scoreMatch ( Class [ ] javaParamTypes , int javaParamsStart , Object [ ] xsltArgs , int score ) { if ( ( xsltArgs == null ) || ( javaParamTypes == null ) ) return score ; int nParams = xsltArgs . length ; for ( int i = nParams - javaParamTypes . length + javaParamsStart , javaParamTypesIndex = javaParamsStart ; i < nParams ; i ++ , javaParamTypesIndex ++ ) { Object xsltObj = xsltArgs [ i ] ; int xsltClassType = ( xsltObj instanceof XObject ) ? ( ( XObject ) xsltObj ) . getType ( ) : XObject . CLASS_UNKNOWN ; Class javaClass = javaParamTypes [ javaParamTypesIndex ] ; if ( xsltClassType == XObject . CLASS_NULL ) { if ( ! javaClass . isPrimitive ( ) ) { score += 10 ; continue ; } else return - 1 ; } ConversionInfo [ ] convInfo = m_conversions [ xsltClassType ] ; int nConversions = convInfo . length ; int k ; for ( k = 0 ; k < nConversions ; k ++ ) { ConversionInfo cinfo = convInfo [ k ] ; if ( javaClass . isAssignableFrom ( cinfo . m_class ) ) { score += cinfo . m_score ; break ; } } if ( k == nConversions ) { if ( XObject . CLASS_UNKNOWN == xsltClassType ) { Class realClass = null ; if ( xsltObj instanceof XObject ) { Object realObj = ( ( XObject ) xsltObj ) . object ( ) ; if ( null != realObj ) { realClass = realObj . getClass ( ) ; } else { score += 10 ; continue ; } } else { realClass = xsltObj . getClass ( ) ; } if ( javaClass . isAssignableFrom ( realClass ) ) { score += 0 ; } else return - 1 ; } else return - 1 ; } } return score ; } static Object convert ( Object xsltObj , Class javaClass ) throws javax . xml . transform . TransformerException { if ( xsltObj instanceof XObject ) { XObject xobj = ( ( XObject ) xsltObj ) ; int xsltClassType = xobj . getType ( ) ; switch ( xsltClassType ) { case XObject . CLASS_NULL : return null ; case XObject . CLASS_BOOLEAN : { if ( javaClass == java . lang . String . class ) return xobj . str ( ) ; else return new Boolean ( xobj . bool ( ) ) ; } case XObject . CLASS_NUMBER : { if ( javaClass == java . lang . String . class ) return xobj . str ( ) ; else if ( javaClass == Boolean . TYPE ) return new Boolean ( xobj . bool ( ) ) ; else { return convertDoubleToNumber ( xobj . num ( ) , javaClass ) ; } } case XObject . CLASS_STRING : { if ( ( javaClass == java . lang . String . class ) || ( javaClass == java . lang . Object . class ) ) return xobj . str ( ) ; else if ( javaClass == Character . TYPE ) { String str = xobj . str ( ) ; if ( str . length ( ) > 0 ) return new Character ( str . charAt ( 0 ) ) ; else return null ; } else if ( javaClass == Boolean . TYPE ) return new Boolean ( xobj . bool ( ) ) ; else { return convertDoubleToNumber ( xobj . num ( ) , javaClass ) ; } } case XObject . CLASS_RTREEFRAG : { if ( ( javaClass == NodeIterator . class ) || ( javaClass == java . lang . Object . class ) ) { DTMIterator dtmIter = ( ( XRTreeFrag ) xobj ) . asNodeIterator ( ) ; return new DTMNodeIterator ( dtmIter ) ; } else if ( javaClass == NodeList . class ) { return ( ( XRTreeFrag ) xobj ) . convertToNodeset ( ) ; } else if ( javaClass == Node . class ) { DTMIterator iter = ( ( XRTreeFrag ) xobj ) . asNodeIterator ( ) ; int rootHandle = iter . nextNode ( ) ; DTM dtm = iter . getDTM ( rootHandle ) ; return dtm . getNode ( dtm . getFirstChild ( rootHandle ) ) ; } else if ( javaClass == java . lang . String . class ) { return xobj . str ( ) ; } else if ( javaClass == Boolean . TYPE ) { return new Boolean ( xobj . bool ( ) ) ; } else if ( javaClass . isPrimitive ( ) ) { return convertDoubleToNumber ( xobj . num ( ) , javaClass ) ; } else { DTMIterator iter = ( ( XRTreeFrag ) xobj ) . asNodeIterator ( ) ; int rootHandle = iter . nextNode ( ) ; DTM dtm = iter . getDTM ( rootHandle ) ; Node child = dtm . getNode ( dtm . getFirstChild ( rootHandle ) ) ; if ( javaClass . isAssignableFrom ( child . getClass ( ) ) ) return child ; else return null ; } } case XObject . CLASS_NODESET : { if ( ( javaClass == NodeIterator . class ) || ( javaClass == java . lang . Object . class ) ) { return xobj . nodeset ( ) ; } else if ( javaClass == NodeList . class ) { return xobj . nodelist ( ) ; } else if ( javaClass == Node . class ) { DTMIterator ni = xobj . iter ( ) ; int handle = ni . nextNode ( ) ; if ( handle != DTM . NULL ) return ni . getDTM ( handle ) . getNode ( handle ) ; else return null ; } else if ( javaClass == java . lang . String . class ) { return xobj . str ( ) ; } else if ( javaClass == Boolean . TYPE ) { return new Boolean ( xobj . bool ( ) ) ; } else if ( javaClass . isPrimitive ( ) ) { return convertDoubleToNumber ( xobj . num ( ) , javaClass ) ; } else { DTMIterator iter = xobj . iter ( ) ; int childHandle = iter . nextNode ( ) ; DTM dtm = iter . getDTM ( childHandle ) ; Node child = dtm . getNode ( childHandle ) ; if ( javaClass . isAssignableFrom ( child . getClass ( ) ) ) return child ; else return null ; } } } xsltObj = xobj . object ( ) ; } if ( null != xsltObj ) { if ( javaClass == java . lang . String . class ) { return xsltObj . toString ( ) ; } else if ( javaClass . isPrimitive ( ) ) { XString xstr = new XString ( xsltObj . toString ( ) ) ; double num = xstr . num ( ) ; return convertDoubleToNumber ( num , javaClass ) ; } else if ( javaClass == java . lang . Class . class ) { return xsltObj . getClass ( ) ; } else { return xsltObj ; } } else { return xsltObj ; } } static Object convertDoubleToNumber ( double num , Class javaClass ) { if ( ( javaClass == Double . TYPE ) || ( javaClass == java . lang . Double . class ) ) return new Double ( num ) ; else if ( javaClass == Float . TYPE ) return new Float ( num ) ; else if ( javaClass == Long . TYPE ) { return new Long ( ( long ) num ) ; } else if ( javaClass == Integer . TYPE ) { return new Integer ( ( int ) num ) ; } else if ( javaClass == Short . TYPE ) { return new Short ( ( short ) num ) ; } else if ( javaClass == Character . TYPE ) { return new Character ( ( char ) num ) ; } else if ( javaClass == Byte . TYPE ) { return new Byte ( ( byte ) num ) ; } else { return new Double ( num ) ; } } private static String errString ( String callType , String searchType , Class classObj , String funcName , int searchMethod , Object [ ] xsltArgs ) { String resultString = "For extension " + callType + ", could not find " + searchType + " " ; switch ( searchMethod ) { case STATIC_ONLY : return resultString + "static " + classObj . getName ( ) + "." + funcName + "([ExpressionContext,] " + errArgs ( xsltArgs , 0 ) + ")." ; case INSTANCE_ONLY : return resultString + classObj . getName ( ) + "." + funcName + "([ExpressionContext,] " + errArgs ( xsltArgs , 0 ) + ")." ; case STATIC_AND_INSTANCE : return resultString + classObj . getName ( ) + "." + funcName + "([ExpressionContext,] " + errArgs ( xsltArgs , 0 ) + ").\n" + "Checked both static and instance methods." ; case DYNAMIC : return resultString + "static " + classObj . getName ( ) + "." + funcName + "([ExpressionContext, ]" + errArgs ( xsltArgs , 0 ) + ") nor\n" + classObj + "." + funcName + "([ExpressionContext,] " + errArgs ( xsltArgs , 1 ) + ")." ; default : if ( callType . equals ( "function" ) ) { return resultString + classObj . getName ( ) + "([ExpressionContext,] " + errArgs ( xsltArgs , 0 ) + ")." ; } else { return resultString + classObj . getName ( ) + "." + funcName + "(org.apache.xalan.extensions.XSLProcessorContext, " + "org.apache.xalan.templates.ElemExtensionCall)." ; } } } private static String errArgs ( Object [ ] xsltArgs , int startingArg ) { StringBuffer returnArgs = new StringBuffer ( ) ; for ( int i = startingArg ; i < xsltArgs . length ; i ++ ) { if ( i != startingArg ) returnArgs . append ( ", " ) ; if ( xsltArgs [ i ] instanceof XObject ) returnArgs . append ( ( ( XObject ) xsltArgs [ i ] ) . getTypeString ( ) ) ; else returnArgs . append ( xsltArgs [ i ] . getClass ( ) . getName ( ) ) ; } return returnArgs . toString ( ) ; } } 	1	['12', '1', '0', '11', '69', '64', '2', '9', '6', '1.015151515', '1693', '0.083333333', '7', '0', '0.281818182', '0', '0', '139.0833333', '14', '3.3333', '1']
package org . apache . xalan . lib . sql ; import java . math . BigDecimal ; import java . sql . Connection ; import java . sql . Date ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . sql . SQLWarning ; import java . sql . Statement ; import java . sql . Time ; import java . sql . Timestamp ; import java . util . Enumeration ; import java . util . Properties ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMManagerDefault ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBooleanStatic ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . TransformerException ; public class XConnection { private static final boolean DEBUG = false ; private ConnectionPool m_ConnectionPool = null ; private Connection m_Connection = null ; private boolean m_DefaultPoolingEnabled = false ; private Vector m_OpenSQLDocuments = new Vector ( ) ; private ConnectionPoolManager m_PoolMgr = new ConnectionPoolManager ( ) ; private Vector m_ParameterList = new Vector ( ) ; private Exception m_Error = null ; private SQLDocument m_LastSQLDocumentWithError = null ; private boolean m_FullErrors = false ; private SQLQueryParser m_QueryParser = new SQLQueryParser ( ) ; private boolean m_IsDefaultPool = false ; private boolean m_IsStreamingEnabled = true ; private boolean m_InlineVariables = false ; private boolean m_IsMultipleResultsEnabled = false ; private boolean m_IsStatementCachingEnabled = false ; public XConnection ( ) { } public XConnection ( ExpressionContext exprContext , String ConnPoolName ) { connect ( exprContext , ConnPoolName ) ; } public XConnection ( ExpressionContext exprContext , String driver , String dbURL ) { connect ( exprContext , driver , dbURL ) ; } public XConnection ( ExpressionContext exprContext , NodeList list ) { connect ( exprContext , list ) ; } public XConnection ( ExpressionContext exprContext , String driver , String dbURL , String user , String password ) { connect ( exprContext , driver , dbURL , user , password ) ; } public XConnection ( ExpressionContext exprContext , String driver , String dbURL , Element protocolElem ) { connect ( exprContext , driver , dbURL , protocolElem ) ; } public XBooleanStatic connect ( ExpressionContext exprContext , String ConnPoolName ) { try { m_ConnectionPool = m_PoolMgr . getPool ( ConnPoolName ) ; if ( m_ConnectionPool == null ) throw new java . lang . IllegalArgumentException ( "Invalid Pool Name" ) ; m_IsDefaultPool = false ; return new XBooleanStatic ( true ) ; } catch ( Exception e ) { setError ( e , exprContext ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , String driver , String dbURL ) { try { init ( driver , dbURL , new Properties ( ) ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { setError ( e , exprContext ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { setError ( e , exprContext ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , Element protocolElem ) { try { initFromElement ( protocolElem ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { setError ( e , exprContext ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { setError ( e , exprContext ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , NodeList list ) { try { initFromElement ( ( Element ) list . item ( 0 ) ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { setError ( e , exprContext ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { setError ( e , exprContext ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , String driver , String dbURL , String user , String password ) { try { Properties prop = new Properties ( ) ; prop . put ( "user" , user ) ; prop . put ( "password" , password ) ; init ( driver , dbURL , prop ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { setError ( e , exprContext ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { setError ( e , exprContext ) ; return new XBooleanStatic ( false ) ; } } public XBooleanStatic connect ( ExpressionContext exprContext , String driver , String dbURL , Element protocolElem ) { try { Properties prop = new Properties ( ) ; NamedNodeMap atts = protocolElem . getAttributes ( ) ; for ( int i = 0 ; i < atts . getLength ( ) ; i ++ ) { prop . put ( atts . item ( i ) . getNodeName ( ) , atts . item ( i ) . getNodeValue ( ) ) ; } init ( driver , dbURL , prop ) ; return new XBooleanStatic ( true ) ; } catch ( SQLException e ) { setError ( e , exprContext ) ; return new XBooleanStatic ( false ) ; } catch ( Exception e ) { setError ( e , exprContext ) ; return new XBooleanStatic ( false ) ; } } private void initFromElement ( Element e ) throws SQLException { Properties prop = new Properties ( ) ; String driver = "" ; String dbURL = "" ; Node n = e . getFirstChild ( ) ; if ( null == n ) return ; do { String nName = n . getNodeName ( ) ; if ( nName . equalsIgnoreCase ( "dbdriver" ) ) { driver = "" ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { driver = n1 . getNodeValue ( ) ; } } if ( nName . equalsIgnoreCase ( "dburl" ) ) { dbURL = "" ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { dbURL = n1 . getNodeValue ( ) ; } } if ( nName . equalsIgnoreCase ( "password" ) ) { String s = "" ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { s = n1 . getNodeValue ( ) ; } prop . put ( "password" , s ) ; } if ( nName . equalsIgnoreCase ( "user" ) ) { String s = "" ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { s = n1 . getNodeValue ( ) ; } prop . put ( "user" , s ) ; } if ( nName . equalsIgnoreCase ( "protocol" ) ) { String Name = "" ; NamedNodeMap attrs = n . getAttributes ( ) ; Node n1 = attrs . getNamedItem ( "name" ) ; if ( null != n1 ) { String s = "" ; Name = n1 . getNodeValue ( ) ; Node n2 = n . getFirstChild ( ) ; if ( null != n2 ) s = n2 . getNodeValue ( ) ; prop . put ( Name , s ) ; } } } while ( ( n = n . getNextSibling ( ) ) != null ) ; init ( driver , dbURL , prop ) ; } private void init ( String driver , String dbURL , Properties prop ) throws SQLException { Connection con = null ; if ( DEBUG ) System . out . println ( "XConnection, Connection Init" ) ; String user = prop . getProperty ( "user" ) ; if ( user == null ) user = "" ; String passwd = prop . getProperty ( "password" ) ; if ( passwd == null ) passwd = "" ; String poolName = driver + dbURL + user + passwd ; ConnectionPool cpool = m_PoolMgr . getPool ( poolName ) ; if ( cpool == null ) { if ( DEBUG ) { System . out . println ( "XConnection, Creating Connection" ) ; System . out . println ( " Driver  :" + driver ) ; System . out . println ( " URL     :" + dbURL ) ; System . out . println ( " user    :" + user ) ; System . out . println ( " passwd  :" + passwd ) ; } DefaultConnectionPool defpool = new DefaultConnectionPool ( ) ; if ( ( DEBUG ) && ( defpool == null ) ) System . out . println ( "Failed to Create a Default Connection Pool" ) ; defpool . setDriver ( driver ) ; defpool . setURL ( dbURL ) ; defpool . setProtocol ( prop ) ; if ( m_DefaultPoolingEnabled ) defpool . setPoolEnabled ( true ) ; m_PoolMgr . registerPool ( poolName , defpool ) ; m_ConnectionPool = defpool ; } else { m_ConnectionPool = cpool ; } m_IsDefaultPool = true ; try { con = m_ConnectionPool . getConnection ( ) ; } catch ( SQLException e ) { if ( con != null ) { m_ConnectionPool . releaseConnectionOnError ( con ) ; con = null ; } throw e ; } finally { if ( con != null ) m_ConnectionPool . releaseConnection ( con ) ; } } public ConnectionPool getConnectionPool ( ) { return m_ConnectionPool ; } public DTM query ( ExpressionContext exprContext , String queryString ) { SQLDocument doc = null ; try { if ( DEBUG ) System . out . println ( "pquery()" ) ; if ( null == m_ConnectionPool ) return null ; SQLQueryParser query = m_QueryParser . parse ( this , queryString , SQLQueryParser . NO_INLINE_PARSER ) ; doc = SQLDocument . getNewDocument ( exprContext ) ; doc . execute ( this , query ) ; m_OpenSQLDocuments . addElement ( doc ) ; } catch ( Exception e ) { if ( DEBUG ) System . out . println ( "exception in query()" ) ; if ( doc != null ) { if ( doc . hasErrors ( ) ) { setError ( e , doc , doc . checkWarnings ( ) ) ; } doc . close ( ) ; doc = null ; } } finally { if ( DEBUG ) System . out . println ( "leaving query()" ) ; } return doc ; } public DTM pquery ( ExpressionContext exprContext , String queryString ) { return ( pquery ( exprContext , queryString , null ) ) ; } public DTM pquery ( ExpressionContext exprContext , String queryString , String typeInfo ) { SQLDocument doc = null ; try { if ( DEBUG ) System . out . println ( "pquery()" ) ; if ( null == m_ConnectionPool ) return null ; SQLQueryParser query = m_QueryParser . parse ( this , queryString , SQLQueryParser . NO_OVERRIDE ) ; if ( ! m_InlineVariables ) { addTypeToData ( typeInfo ) ; query . setParameters ( m_ParameterList ) ; } doc = SQLDocument . getNewDocument ( exprContext ) ; doc . execute ( this , query ) ; m_OpenSQLDocuments . addElement ( doc ) ; } catch ( Exception e ) { if ( DEBUG ) System . out . println ( "exception in query()" ) ; if ( doc != null ) { if ( doc . hasErrors ( ) ) { setError ( e , doc , doc . checkWarnings ( ) ) ; } doc . close ( ) ; doc = null ; } } finally { if ( DEBUG ) System . out . println ( "leaving query()" ) ; } return doc ; } private void addTypeToData ( String typeInfo ) { int indx ; if ( typeInfo != null && m_ParameterList != null ) { StringTokenizer plist = new StringTokenizer ( typeInfo ) ; indx = 0 ; while ( plist . hasMoreTokens ( ) ) { String value = plist . nextToken ( ) ; QueryParameter qp = ( QueryParameter ) m_ParameterList . elementAt ( indx ) ; if ( null != qp ) { qp . setTypeName ( value ) ; } indx ++ ; } } } public void addParameter ( String value ) { addParameterWithType ( value , null ) ; } public void addParameterWithType ( String value , String Type ) { m_ParameterList . addElement ( new QueryParameter ( value , Type ) ) ; } public void addParameterFromElement ( Element e ) { NamedNodeMap attrs = e . getAttributes ( ) ; Node Type = attrs . getNamedItem ( "type" ) ; Node n1 = e . getFirstChild ( ) ; if ( null != n1 ) { String value = n1 . getNodeValue ( ) ; if ( value == null ) value = "" ; m_ParameterList . addElement ( new QueryParameter ( value , Type . getNodeValue ( ) ) ) ; } } public void addParameterFromElement ( NodeList nl ) { int count = nl . getLength ( ) ; for ( int x = 0 ; x < count ; x ++ ) { addParameters ( ( Element ) nl . item ( x ) ) ; } } private void addParameters ( Element elem ) { Node n = elem . getFirstChild ( ) ; if ( null == n ) return ; do { if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap attrs = n . getAttributes ( ) ; Node Type = attrs . getNamedItem ( "type" ) ; String TypeStr ; if ( Type == null ) TypeStr = "string" ; else TypeStr = Type . getNodeValue ( ) ; Node n1 = n . getFirstChild ( ) ; if ( null != n1 ) { String value = n1 . getNodeValue ( ) ; if ( value == null ) value = "" ; m_ParameterList . addElement ( new QueryParameter ( value , TypeStr ) ) ; } } } while ( ( n = n . getNextSibling ( ) ) != null ) ; } public void clearParameters ( ) { m_ParameterList . removeAllElements ( ) ; } public void enableDefaultConnectionPool ( ) { if ( DEBUG ) System . out . println ( "Enabling Default Connection Pool" ) ; m_DefaultPoolingEnabled = true ; if ( m_ConnectionPool == null ) return ; if ( m_IsDefaultPool ) return ; m_ConnectionPool . setPoolEnabled ( true ) ; } public void disableDefaultConnectionPool ( ) { if ( DEBUG ) System . out . println ( "Disabling Default Connection Pool" ) ; m_DefaultPoolingEnabled = false ; if ( m_ConnectionPool == null ) return ; if ( ! m_IsDefaultPool ) return ; m_ConnectionPool . setPoolEnabled ( false ) ; } public void enableStreamingMode ( ) { if ( DEBUG ) System . out . println ( "Enabling Streaming Mode" ) ; m_IsStreamingEnabled = true ; } public void disableStreamingMode ( ) { if ( DEBUG ) System . out . println ( "Disable Streaming Mode" ) ; m_IsStreamingEnabled = false ; } public DTM getError ( ) { if ( m_FullErrors ) { for ( int idx = 0 ; idx < m_OpenSQLDocuments . size ( ) ; idx ++ ) { SQLDocument doc = ( SQLDocument ) m_OpenSQLDocuments . elementAt ( idx ) ; SQLWarning warn = doc . checkWarnings ( ) ; if ( warn != null ) setError ( null , doc , warn ) ; } } return ( buildErrorDocument ( ) ) ; } public void close ( ) throws SQLException { if ( DEBUG ) System . out . println ( "Entering XConnection.close()" ) ; while ( m_OpenSQLDocuments . size ( ) != 0 ) { SQLDocument d = ( SQLDocument ) m_OpenSQLDocuments . elementAt ( 0 ) ; try { d . close ( ) ; } catch ( Exception se ) { } m_OpenSQLDocuments . removeElementAt ( 0 ) ; } if ( null != m_Connection ) { m_ConnectionPool . releaseConnection ( m_Connection ) ; m_Connection = null ; } if ( DEBUG ) System . out . println ( "Exiting XConnection.close" ) ; } public void close ( SQLDocument sqldoc ) throws SQLException { if ( DEBUG ) System . out . println ( "Entering XConnection.close(" + sqldoc + ")" ) ; int size = m_OpenSQLDocuments . size ( ) ; for ( int x = 0 ; x < size ; x ++ ) { SQLDocument d = ( SQLDocument ) m_OpenSQLDocuments . elementAt ( x ) ; if ( d == sqldoc ) { d . close ( ) ; m_OpenSQLDocuments . removeElementAt ( x ) ; } } } private SQLErrorDocument buildErrorDocument ( ) { SQLErrorDocument eDoc = null ; if ( m_LastSQLDocumentWithError != null ) { ExpressionContext ctx = m_LastSQLDocumentWithError . getExpressionContext ( ) ; SQLWarning warn = m_LastSQLDocumentWithError . checkWarnings ( ) ; try { DTMManager mgr = ( ( XPathContext . XPathExpressionContext ) ctx ) . getDTMManager ( ) ; DTMManagerDefault mgrDefault = ( DTMManagerDefault ) mgr ; int dtmIdent = mgrDefault . getFirstFreeDTMID ( ) ; eDoc = new SQLErrorDocument ( mgr , dtmIdent << DTMManager . IDENT_DTM_NODE_BITS , m_Error , warn , m_FullErrors ) ; mgrDefault . addDTM ( eDoc , dtmIdent ) ; m_Error = null ; m_LastSQLDocumentWithError = null ; } catch ( Exception e ) { eDoc = null ; } } return ( eDoc ) ; } public void setError ( Exception excp , ExpressionContext expr ) { try { ErrorListener listen = expr . getErrorListener ( ) ; if ( listen != null && excp != null ) { listen . warning ( new TransformerException ( excp . toString ( ) , expr . getXPathContext ( ) . getSAXLocator ( ) , excp ) ) ; } } catch ( Exception e ) { } } public void setError ( Exception excp , SQLDocument doc , SQLWarning warn ) { ExpressionContext cont = doc . getExpressionContext ( ) ; m_LastSQLDocumentWithError = doc ; try { ErrorListener listen = cont . getErrorListener ( ) ; if ( listen != null && excp != null ) listen . warning ( new TransformerException ( excp . toString ( ) , cont . getXPathContext ( ) . getSAXLocator ( ) , excp ) ) ; if ( listen != null && warn != null ) { listen . warning ( new TransformerException ( warn . toString ( ) , cont . getXPathContext ( ) . getSAXLocator ( ) , warn ) ) ; } if ( excp != null ) m_Error = excp ; if ( warn != null ) { SQLWarning tw = new SQLWarning ( warn . getMessage ( ) , warn . getSQLState ( ) , warn . getErrorCode ( ) ) ; SQLWarning nw = warn . getNextWarning ( ) ; while ( nw != null ) { tw . setNextWarning ( new SQLWarning ( nw . getMessage ( ) , nw . getSQLState ( ) , nw . getErrorCode ( ) ) ) ; nw = nw . getNextWarning ( ) ; } tw . setNextWarning ( new SQLWarning ( warn . getMessage ( ) , warn . getSQLState ( ) , warn . getErrorCode ( ) ) ) ; } } catch ( Exception e ) { } } public void setFeature ( String feature , String setting ) { boolean value = false ; if ( "true" . equalsIgnoreCase ( setting ) ) value = true ; if ( "streaming" . equalsIgnoreCase ( feature ) ) { m_IsStreamingEnabled = value ; } else if ( "inline-variables" . equalsIgnoreCase ( feature ) ) { m_InlineVariables = value ; } else if ( "multiple-results" . equalsIgnoreCase ( feature ) ) { m_IsMultipleResultsEnabled = value ; } else if ( "cache-statements" . equalsIgnoreCase ( feature ) ) { m_IsStatementCachingEnabled = value ; } else if ( "default-pool-enabled" . equalsIgnoreCase ( feature ) ) { m_DefaultPoolingEnabled = value ; if ( m_ConnectionPool == null ) return ; if ( m_IsDefaultPool ) return ; m_ConnectionPool . setPoolEnabled ( value ) ; } else if ( "full-errors" . equalsIgnoreCase ( feature ) ) { m_FullErrors = value ; } } public String getFeature ( String feature ) { String value = null ; if ( "streaming" . equalsIgnoreCase ( feature ) ) value = m_IsStreamingEnabled ? "true" : "false" ; else if ( "inline-variables" . equalsIgnoreCase ( feature ) ) value = m_InlineVariables ? "true" : "false" ; else if ( "multiple-results" . equalsIgnoreCase ( feature ) ) value = m_IsMultipleResultsEnabled ? "true" : "false" ; else if ( "cache-statements" . equalsIgnoreCase ( feature ) ) value = m_IsStatementCachingEnabled ? "true" : "false" ; else if ( "default-pool-enabled" . equalsIgnoreCase ( feature ) ) value = m_DefaultPoolingEnabled ? "true" : "false" ; else if ( "full-errors" . equalsIgnoreCase ( feature ) ) value = m_FullErrors ? "true" : "false" ; return ( value ) ; } protected void finalize ( ) { if ( DEBUG ) System . out . println ( "In XConnection, finalize" ) ; try { close ( ) ; } catch ( Exception e ) { } } } 	1	['38', '1', '0', '14', '110', '273', '2', '14', '32', '0.72972973', '1595', '1', '4', '0', '0.248538012', '0', '0', '40.55263158', '13', '2.2895', '2']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_cs extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Nepodporovaná funkce!" } , { ER_CANNOT_OVERWRITE_CAUSE , "Příčinu nelze přepsat" } , { ER_NO_DEFAULT_IMPL , "Nebyla nalezena výchozí implementace. " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "Funkce ChunkedIntArray({0}) není aktuálně podporována." } , { ER_OFFSET_BIGGER_THAN_SLOT , "Offset je větší než slot." } , { ER_COROUTINE_NOT_AVAIL , "Společná rutina není k dispozici, id={0}" } , { ER_COROUTINE_CO_EXIT , "Funkce CoroutineManager obdržela požadavek co_exit()" } , { ER_COJOINROUTINESET_FAILED , "Selhala funkce co_joinCoroutineSet()" } , { ER_COROUTINE_PARAM , "Chyba parametru společné rutiny ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nNeočekávané: odpovědi funkce analyzátoru doTerminate {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "během analýzy nelze volat analyzátor" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Chyba: zadaný iterátor osy {0} není implementován" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Chyba: zadaný iterátor osy {0} není implementován " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Nepodporovaný klon iterátoru." } , { ER_UNKNOWN_AXIS_TYPE , "Neznámý typ osy průchodu: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Nepodporovaná osa průchodu: {0}" } , { ER_NO_DTMIDS_AVAIL , "Žádná další ID DTM nejsou k dispozici" } , { ER_NOT_SUPPORTED , "Nepodporováno: {0}" } , { ER_NODE_NON_NULL , "Uzel použitý ve funkci getDTMHandleFromNode musí mít hodnotu not-null" } , { ER_COULD_NOT_RESOLVE_NODE , "Uzel nelze přeložit do manipulátoru" } , { ER_STARTPARSE_WHILE_PARSING , "Během analýzy nelze volat funkci startParse." } , { ER_STARTPARSE_NEEDS_SAXPARSER , "Funkce startParse vyžaduje SAXParser s hodnotou not-null." } , { ER_COULD_NOT_INIT_PARSER , "nelze inicializovat analyzátor s: " } , { ER_EXCEPTION_CREATING_POOL , "výjimka při vytváření nové instance společné oblasti" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Cesta obsahuje neplatnou escape sekvenci" } , { ER_SCHEME_REQUIRED , "Je vyžadováno schéma!" } , { ER_NO_SCHEME_IN_URI , "V URI nebylo nalezeno žádné schéma: {0}" } , { ER_NO_SCHEME_INURI , "V URI nebylo nalezeno žádné schéma" } , { ER_PATH_INVALID_CHAR , "Cesta obsahuje neplatný znak: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Nelze nastavit schéma řetězce s hodnotou null." } , { ER_SCHEME_NOT_CONFORMANT , "Schéma nevyhovuje." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Adresa hostitele má nesprávný formát." } , { ER_PORT_WHEN_HOST_NULL , "Má-li hostitel hodnotu null, nelze nastavit port." } , { ER_INVALID_PORT , "Neplatné číslo portu." } , { ER_FRAG_FOR_GENERIC_URI , "Fragment lze nastavit jen u generického URI." } , { ER_FRAG_WHEN_PATH_NULL , "Má-li cesta hodnotu null, nelze nastavit fragment." } , { ER_FRAG_INVALID_CHAR , "Fragment obsahuje neplatný znak." } , { ER_PARSER_IN_USE , "Analyzátor se již používá." } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Během analýzy nelze měnit {0} {1}." } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Způsobení sama sebe (self-causation) není povoleno" } , { ER_NO_USERINFO_IF_NO_HOST , "Není-li určen hostitel, nelze zadat údaje o uživateli." } , { ER_NO_PORT_IF_NO_HOST , "Není-li určen hostitel, nelze zadat port." } , { ER_NO_QUERY_STRING_IN_PATH , "V řetězci cesty a dotazu nelze zadat řetězec dotazu." } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Fragment nelze určit zároveň v cestě i ve fragmentu." } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "URI nelze inicializovat s prázdnými parametry." } , { ER_METHOD_NOT_SUPPORTED , "Prozatím nepodporovaná metoda. " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "Filtr IncrementalSAXSource_Filter nelze aktuálně znovu spustit." } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "Před požadavkem startParse není XMLReader." } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Nepodporovaná osa průchodu: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "Prvek ListingErrorHandler byl vytvořen s funkcí PrintWriter s hodnotou null!" } , { ER_SYSTEMID_UNKNOWN , "Neznámý identifikátor SystemId" } , { ER_LOCATION_UNKNOWN , "Chyba se vyskytla na neznámém místě" } , { ER_PREFIX_MUST_RESOLVE , "Předponu musí být možno přeložit do oboru názvů: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "Funkce XPathContext nepodporuje funkci createDocument()!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Potomek atributu nemá dokument vlastníka!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Potomek atributu nemá prvek dokumentu vlastníka!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Varování: výstup textu nemůže předcházet prvku dokumentu! Ignorováno..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "DOM nemůže mít několik kořenů!" } , { ER_ARG_LOCALNAME_NULL , "Argument 'localName' má hodnotu null" } , { ER_ARG_LOCALNAME_INVALID , "Hodnota Localname ve funkci QNAME by měla být platným prvkem NCName" } , { ER_ARG_PREFIX_INVALID , "Předpona ve funkci QNAME by měla být platným prvkem NCName" } , { "BAD_CODE" , "Parametr funkce createMessage je mimo limit" } , { "FORMAT_FAILED" , "Při volání funkce messageFormat došlo k výjimce" } , { "line" , "Řádek #" } , { "column" , "Sloupec #" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "Třída serializace ''{0}'' neimplementuje org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "Nelze najít zdroj [ {0} ].\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "Nelze zavést zdroj [ {0} ]: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Velikost vyrovnávací paměti <=0" } , { ER_INVALID_UTF16_SURROGATE , "Byla zjištěna neplatná náhrada UTF-16: {0} ?" } , { ER_OIERROR , "Chyba vstupu/výstupu" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Nelze přidat atribut {0} po uzlech potomků ani před tím, než je vytvořen prvek. Atribut bude ignorován." } , { ER_NAMESPACE_PREFIX , "Obor názvů pro předponu ''{0}'' nebyl deklarován." } , { ER_STRAY_ATTRIBUTE , "Atribut ''{0}'' je vně prvku." } , { ER_STRAY_NAMESPACE , "Deklarace oboru názvů ''{0}''=''{1}'' je vně prvku." } , { ER_COULD_NOT_LOAD_RESOURCE , "Nelze zavést ''{0}'' (zkontrolujte proměnnou CLASSPATH), proto se používají pouze výchozí hodnoty" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "Nelze načíst soubor vlastností ''{0}'' pro výstupní metodu ''{1}'' (zkontrolujte proměnnou CLASSPATH)." } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "cs" , "CZ" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemText ; public class ProcessorText extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { ProcessorCharacters charProcessor = ( ProcessorCharacters ) handler . getProcessorFor ( null , "text()" , "text" ) ; charProcessor . setXslTextElement ( ( ElemText ) elem ) ; ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; parent . appendChild ( elem ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { ProcessorCharacters charProcessor = ( ProcessorCharacters ) handler . getProcessorFor ( null , "text()" , "text" ) ; charProcessor . setXslTextElement ( null ) ; } } 	1	['3', '5', '0', '7', '10', '3', '1', '6', '2', '2', '40', '0', '0', '0.990697674', '0.583333333', '2', '4', '12.33333333', '1', '0.6667', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Run-time internal error in ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Run-time error when executing <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Invalid conversion from ''{0}'' to ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "External function ''{0}'' not supported by XSLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Unknown argument type in equality expression." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Invalid argument type ''{0}'' in call to ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Attempting to format number ''{0}'' using pattern ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Cannot clone iterator ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Iterator for axis ''{0}'' not supported." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Iterator for typed axis ''{0}'' not supported." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Attribute ''{0}'' outside of element." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Namespace declaration ''{0}''=''{1}'' outside of element." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "Namespace for prefix ''{0}'' has not been declared." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter created using wrong type of source DOM." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "The SAX parser you are using does not handle DTD declaration events." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "The SAX parser you are using does not have support for XML Namespaces." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "Could not resolve the URI reference ''{0}''." } , { BasisLibrary . UNSUPPORTED_XSL_ERR , "Unsupported XSL element ''{0}''" } , { BasisLibrary . UNSUPPORTED_EXT_ERR , "Unrecognized XSLTC extension ''{0}''" } , { BasisLibrary . UNKNOWN_TRANSLET_VERSION_ERR , "The specified translet, ''{0}'', was created using a version of XSLTC more recent than the version of the XSLTC run-time that is in use.  You must recompile the stylesheet or use a more recent version of XSLTC to run this translet." } , { BasisLibrary . INVALID_QNAME_ERR , "An attribute whose value must be a QName had the value ''{0}''" } , { BasisLibrary . INVALID_NCNAME_ERR , "An attribute whose value must be an NCName had the value ''{0}''" } , } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '299', '1', '0', '0.974358974', '1', '0', '0', '98.33333333', '1', '0.3333', '2']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_ca extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "La funció current() no és permesa en un patró de coincidència. " } , { ER_CURRENT_TAKES_NO_ARGS , "La funció current() no accepta arguments. " } , { ER_DOCUMENT_REPLACED , "La implementació de la funció document() s'ha substituït per org.apache.xalan.xslt.FuncDocument. " } , { ER_CONTEXT_HAS_NO_OWNERDOC , "El context no té un document de propietari. " } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() té massa arguments. " } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() té massa arguments. " } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() té massa arguments. " } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() té massa arguments. " } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() té massa arguments. " } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() té massa arguments. " } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() té massa arguments. " } , { ER_TRANSLATE_TAKES_3_ARGS , "La funció translate() té tres arguments. " } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "La funció unparsed-entity-uri ha de tenir un argument. " } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "L'eix de l'espai de noms encara no s'ha implementat. " } , { ER_UNKNOWN_AXIS , "Eix desconegut: {0} " } , { ER_UNKNOWN_MATCH_OPERATION , "Operació de coincidència desconeguda. " } , { ER_INCORRECT_ARG_LENGTH , "La longitud de l'argument de la prova de node processing-instruction() no és correcta. " } , { ER_CANT_CONVERT_TO_NUMBER , "No es pot convertir {0} en un número. " } , { ER_CANT_CONVERT_TO_NODELIST , "No es pot convertir {0} en una NodeList. " } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "No es pot convertir {0} en un NodeSetDTM. " } , { ER_CANT_CONVERT_TO_TYPE , "No es pot convertir {0} en un tipus #{1} " } , { ER_EXPECTED_MATCH_PATTERN , "El patró de coincidència de getMatchScore és l'esperat. " } , { ER_COULDNOT_GET_VAR_NAMED , "No s''ha pogut obtenir la variable {0}. " } , { ER_UNKNOWN_OPCODE , "ERROR. Codi op desconegut: {0} " } , { ER_EXTRA_ILLEGAL_TOKENS , "Senyals addicionals no permesos: {0} " } , { ER_EXPECTED_DOUBLE_QUOTE , "Les cometes del literal són incorrectes. Hi ha d'haver cometes dobles. " } , { ER_EXPECTED_SINGLE_QUOTE , "Les cometes del literal són incorrectes. Hi ha d'haver una cometa simple. " } , { ER_EMPTY_EXPRESSION , "Expressió buida. " } , { ER_EXPECTED_BUT_FOUND , "S''esperava {0}, però s''ha detectat {1} " } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "L''afirmació del programador és incorrecta. - {0} " } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "L'argument boolean(...) ja no és opcional amb l'esborrany d'XPath 19990709. " } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "S'ha trobat ',' però no hi havia cap argument abans. " } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "S'ha trobat ',' però no hi havia cap argument darrere. " } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' o '.[predicate]' no és una sintaxi permesa. En comptes d'això, utilitzeu 'self::node()[predicate]'. " } , { ER_ILLEGAL_AXIS_NAME , "Nom d''eix no permès: {0} " } , { ER_UNKNOWN_NODETYPE , "Tipus de node desconegut: {0} " } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "El literal de patró ({0}) ha d''anar entre cometes. " } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} no s''ha pogut formatar com a número. " } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "No s''ha pogut crear la relació XML TransformerFactory: {0} " } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Error. No s'ha trobat l'expressió select d'xpath (-select). " } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "ERROR. No s'ha trobat ENDOP després d'OP_LOCATIONPATH. " } , { ER_ERROR_OCCURED , "S'ha produït un error. " } , { ER_ILLEGAL_VARIABLE_REFERENCE , "S''ha donat VariableReference per a una variable fora de context o sense definició. Nom = {0} " } , { ER_AXES_NOT_ALLOWED , "Només es permeten els eixos subordinat:: i atribut:: en els patrons de coincidència. Eixos incorrectes = {0} " } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() té un nombre incorrecte d'arguments. " } , { ER_COUNT_TAKES_1_ARG , "La funció count ha de tenir un argument. " } , { ER_COULDNOT_FIND_FUNCTION , "No s''ha pogut trobar la funció: {0} " } , { ER_UNSUPPORTED_ENCODING , "Codificació sense suport: {0} " } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "S'ha produït un error en el DTM de getNextSibling. S'intentarà solucionar. " } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Error del programador: no es pot escriure a EmptyNodeList. " } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "XPathContext no dóna suport a setDOMFactory. " } , { ER_PREFIX_MUST_RESOLVE , "El prefix s''ha de resoldre en un espai de noms: {0} " } , { ER_PARSE_NOT_SUPPORTED , "L''anàlisi (origen InputSource) no té suport a XPathContext. No es pot obrir {0}. " } , { ER_SAX_API_NOT_HANDLED , "Caràcters SAX API (char ch[]... no es poden gestionar pel DTM. " } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... no es poden gestionar pel DTM. " } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison no pot gestionar nodes del tipus {0}. " } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper no pot gestionar nodes del tipus {0}. " } , { ER_XERCES_PARSE_ERROR_DETAILS , "Error de DOM2Helper.parse: ID del sistema - {0} línia - {1} " } , { ER_XERCES_PARSE_ERROR , "Error de DOM2Helper.parse " } , { ER_INVALID_UTF16_SURROGATE , "S''ha detectat un suplent UTF-16 no vàlid: {0} ? " } , { ER_OIERROR , "Error d'E/S " } , { ER_CANNOT_CREATE_URL , "No es pot crear la url de: {0} " } , { ER_XPATH_READOBJECT , "En XPath.readObject: {0} " } , { ER_FUNCTION_TOKEN_NOT_FOUND , "No s'ha trobat el senyal de funció. " } , { ER_CANNOT_DEAL_XPATH_TYPE , "No s''ha pogut tractar amb el tipus d''XPath: {0} " } , { ER_NODESET_NOT_MUTABLE , "Aquest NodeSet no és mutable. " } , { ER_NODESETDTM_NOT_MUTABLE , "Aquest NodeSetDTM no és mutable. " } , { ER_VAR_NOT_RESOLVABLE , "No es pot resoldre la variable: {0} " } , { ER_NULL_ERROR_HANDLER , "Manejador d'error nul " } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Afirmació del programador: opcode desconegut: {0}" } , { ER_ZERO_OR_ONE , "0 o 1 " } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() no té suport de XRTreeFragSelectWrapper " } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() no té suport de XRTreeFragSelectWrapper " } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() no té suport de XStringForChars " } , { ER_COULD_NOT_FIND_VAR , "No s''ha trobat la variable amb el nom de {0} " } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars no pot agafar una cadena com a argument. " } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "L'argument FastStringBuffer no pot ser nul." } , { ER_TWO_OR_THREE , "2 o 3 " } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "S'ha accedit a la variable abans que estigués vinculada. " } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB no pot agafar una cadena com a argument. " } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n Error. S'està establint l'arrel d'un itinerant en nul. " } , { ER_NODESETDTM_CANNOT_ITERATE , "Aquest NodeSetDTM no es pot iterar en un node previ " } , { ER_NODESET_CANNOT_ITERATE , "Aquest NodeSet no es pot iterar en un node previ " } , { ER_NODESETDTM_CANNOT_INDEX , "Aquest NodeSetDTM no pot indexar ni efectuar funcions de recompte " } , { ER_NODESET_CANNOT_INDEX , "Aquest NodeSet no pot indexar ni efectuar funcions de recompte " } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "No es pot cridar setShouldCacheNodes després que s'hagi cridat nextNode " } , { ER_ONLY_ALLOWS , "{0} només permet {1} arguments " } , { ER_UNKNOWN_STEP , "Afirmació del programador a getNextStepPos: stepType desconegut: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "S'esperava una via d'accés relativa darrere del senyal '/' o '//'. " } , { ER_EXPECTED_LOC_PATH , "S''esperava una via d''accés d''ubicació, però s''ha trobat el senyal següent: {0}" } , { ER_EXPECTED_LOC_STEP , "S'esperava un pas d'ubicació després del senyal '/' o '//'. " } , { ER_EXPECTED_NODE_TEST , "S'esperava una prova de node que coincidís amb NCName:* o QName. " } , { ER_EXPECTED_STEP_PATTERN , "S'esperava un patró de pas però s'ha trobat '/'. " } , { ER_EXPECTED_REL_PATH_PATTERN , "S'esperava un patró de via d'accés relativa. " } , { ER_CANT_CONVERT_TO_BOOLEAN , "No es pot convertir {0} en booleà. " } , { ER_CANT_CONVERT_TO_SINGLENODE , "No es pot convertir {0} en un node únic. Aquest captador fa referència als tipus ANY_UNORDERED_NODE_TYPE i FIRST_ORDERED_NODE_TYPE. " } , { ER_CANT_GET_SNAPSHOT_LENGTH , "No es pot obtenir la longitud de la instantània del tipus: {0}. Aquest captador fa referència als tipus UNORDERED_NODE_SNAPSHOT_TYPE i ORDERED_NODE_SNAPSHOT_TYPE. " } , { ER_NON_ITERATOR_TYPE , "No es pot iterar en un tipus no iterador: {0} " } , { ER_DOC_MUTATED , "El document s'ha modificat des que es van produir els resultats. L'iterador no és vàlid. " } , { ER_INVALID_XPATH_TYPE , "L''argument de tipus XPath no és vàlid: {0} " } , { ER_EMPTY_XPATH_RESULT , "L'objecte de resultats XPath està buit. " } , { ER_INCOMPATIBLE_TYPES , "El tipus retornat {0} no es pot encaixar en el tipus especificat {1} " } , { ER_NULL_RESOLVER , "No es pot resoldre el prefix amb un solucionador de prefix nul. " } , { ER_CANT_CONVERT_TO_STRING , "No es pot convertir {0} en cadena. " } , { ER_NON_SNAPSHOT_TYPE , "No es pot cridar snapshotItem en el tipus: {0}. Aquest mètode fa referència als tipus UNORDERED_NODE_SNAPSHOT_TYPE i ORDERED_NODE_SNAPSHOT_TYPE. " } , { ER_WRONG_DOCUMENT , "El node de context no pertany al document vinculat a aquest XPathEvaluator. " } , { ER_WRONG_NODETYPE , "El tipus de node de context no té suport. " } , { ER_XPATH_ERROR , "S'ha produït un error desconegut a XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "No s'ha gestionat encara el nom d'entorn nacional en la funció format-number. " } , { WG_PROPERTY_NOT_SUPPORTED , "La propietat XSL no té suport: {0} " } , { WG_DONT_DO_ANYTHING_WITH_NS , "No feu res ara mateix amb l''espai de noms {0} de la propietat: {1} " } , { WG_SECURITY_EXCEPTION , "S''ha produït SecurityException en intentar accedir a la propietat de sistema XSL: {0} " } , { WG_QUO_NO_LONGER_DEFINED , "Sintaxi antiga: quo(...) ja no està definit a XPath. " } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath necessita un objecte deduït per implementar nodeTest. " } , { WG_FUNCTION_TOKEN_NOT_FOUND , "No s'ha trobat el senyal de funció. " } , { WG_COULDNOT_FIND_FUNCTION , "No s''ha pogut trobar la funció: {0} " } , { WG_CANNOT_MAKE_URL_FROM , "No es pot crear la URL de: {0} " } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "L'opció -E no té suport a l'analitzador de DTM " } , { WG_ILLEGAL_VARIABLE_REFERENCE , "S''ha donat VariableReference per a una variable fora de context o sense definició. Nom = {0} " } , { WG_UNSUPPORTED_ENCODING , "Codificació sense suport: {0} " } , { "ui_language" , "ca" } , { "help_language" , "ca" } , { "language" , "ca" } , { "BAD_CODE" , "El paràmetre de createMessage estava fora dels límits. " } , { "FORMAT_FAILED" , "S'ha generat una excepció durant la crida messageFormat. " } , { "version" , ">>>>>>> Versió Xalan " } , { "version2" , "<<<<<<< " } , { "yes" , "sí" } , { "line" , "Línia núm. " } , { "column" , "Columna núm. " } , { "xsldone" , "XSLProcessor: fet " } , { "xpath_option" , "Opcions d'xpath: " } , { "optionIN" , "[-in inputXMLURL] " } , { "optionSelect" , "[-select expressió xpath] " } , { "optionMatch" , "[-match patró coincidència (per a diagnòstics de coincidència)] " } , { "optionAnyExpr" , "O només una expressió xpath farà un buidatge de diagnòstic. " } , { "noParsermsg1" , "El procés XSL no ha estat correcte. " } , { "noParsermsg2" , "** No s'ha trobat l'analitzador ** " } , { "noParsermsg3" , "Comproveu la vostra classpath. " } , { "noParsermsg4" , "Si no teniu XML Parser for Java d'IBM, el podeu baixar d' " } , { "noParsermsg5" , "AlphaWorks d'IBM: http://www.alphaworks.ibm.com/formula/xml " } , { "gtone" , ">1 " } , { "zero" , "0 " } , { "one" , "1 " } , { "two" , "2 " } , { "three" , "3 " } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Avís: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "ca" , "ES" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xalan . xsltc . trax ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TemplatesHandler ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . xml . sax . XMLFilter ; public class SmartTransformerFactoryImpl extends SAXTransformerFactory { private SAXTransformerFactory _xsltcFactory = null ; private SAXTransformerFactory _xalanFactory = null ; private SAXTransformerFactory _currFactory = null ; private ErrorListener _errorlistener = null ; private URIResolver _uriresolver = null ; public SmartTransformerFactoryImpl ( ) { } private void createXSLTCTransformerFactory ( ) { _xsltcFactory = new TransformerFactoryImpl ( ) ; _currFactory = _xsltcFactory ; } private void createXalanTransformerFactory ( ) { final String xalanMessage = "org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl " + "could not create an " + "org.apache.xalan.processor.TransformerFactoryImpl." ; try { Class xalanFactClass = ObjectFactory . findProviderClass ( "org.apache.xalan.processor.TransformerFactoryImpl" , ObjectFactory . findClassLoader ( ) , true ) ; _xalanFactory = ( SAXTransformerFactory ) xalanFactClass . newInstance ( ) ; } catch ( ClassNotFoundException e ) { System . err . println ( xalanMessage ) ; } catch ( InstantiationException e ) { System . err . println ( xalanMessage ) ; } catch ( IllegalAccessException e ) { System . err . println ( xalanMessage ) ; } _currFactory = _xalanFactory ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { _errorlistener = listener ; } public ErrorListener getErrorListener ( ) { return _errorlistener ; } public Object getAttribute ( String name ) throws IllegalArgumentException { if ( ( name . equals ( "translet-name" ) ) || ( name . equals ( "debug" ) ) ) { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } return _xsltcFactory . getAttribute ( name ) ; } else { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } return _xalanFactory . getAttribute ( name ) ; } } public void setAttribute ( String name , Object value ) throws IllegalArgumentException { if ( ( name . equals ( "translet-name" ) ) || ( name . equals ( "debug" ) ) ) { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } _xsltcFactory . setAttribute ( name , value ) ; } else { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } _xalanFactory . setAttribute ( name , value ) ; } } public boolean getFeature ( String name ) { String [ ] features = { DOMSource . FEATURE , DOMResult . FEATURE , SAXSource . FEATURE , SAXResult . FEATURE , StreamSource . FEATURE , StreamResult . FEATURE } ; for ( int i = 0 ; i < features . length ; i ++ ) { if ( name . equals ( features [ i ] ) ) return true ; } return false ; } public URIResolver getURIResolver ( ) { return _uriresolver ; } public void setURIResolver ( URIResolver resolver ) { _uriresolver = resolver ; } public Source getAssociatedStylesheet ( Source source , String media , String title , String charset ) throws TransformerConfigurationException { if ( _currFactory == null ) { createXSLTCTransformerFactory ( ) ; } return _currFactory . getAssociatedStylesheet ( source , media , title , charset ) ; } public Transformer newTransformer ( ) throws TransformerConfigurationException { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xalanFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xalanFactory . setURIResolver ( _uriresolver ) ; } _currFactory = _xalanFactory ; return _currFactory . newTransformer ( ) ; } public Transformer newTransformer ( Source source ) throws TransformerConfigurationException { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xalanFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xalanFactory . setURIResolver ( _uriresolver ) ; } _currFactory = _xalanFactory ; return _currFactory . newTransformer ( source ) ; } public Templates newTemplates ( Source source ) throws TransformerConfigurationException { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xsltcFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xsltcFactory . setURIResolver ( _uriresolver ) ; } _currFactory = _xsltcFactory ; return _currFactory . newTemplates ( source ) ; } public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xsltcFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xsltcFactory . setURIResolver ( _uriresolver ) ; } return _xsltcFactory . newTemplatesHandler ( ) ; } public TransformerHandler newTransformerHandler ( ) throws TransformerConfigurationException { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xalanFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xalanFactory . setURIResolver ( _uriresolver ) ; } return _xalanFactory . newTransformerHandler ( ) ; } public TransformerHandler newTransformerHandler ( Source src ) throws TransformerConfigurationException { if ( _xalanFactory == null ) { createXalanTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xalanFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xalanFactory . setURIResolver ( _uriresolver ) ; } return _xalanFactory . newTransformerHandler ( src ) ; } public TransformerHandler newTransformerHandler ( Templates templates ) throws TransformerConfigurationException { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xsltcFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xsltcFactory . setURIResolver ( _uriresolver ) ; } return _xsltcFactory . newTransformerHandler ( templates ) ; } public XMLFilter newXMLFilter ( Source src ) throws TransformerConfigurationException { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } if ( _errorlistener != null ) { _xsltcFactory . setErrorListener ( _errorlistener ) ; } if ( _uriresolver != null ) { _xsltcFactory . setURIResolver ( _uriresolver ) ; } Templates templates = _xsltcFactory . newTemplates ( src ) ; if ( templates == null ) return null ; return newXMLFilter ( templates ) ; } public XMLFilter newXMLFilter ( Templates templates ) throws TransformerConfigurationException { try { return new org . apache . xalan . xsltc . trax . TrAXFilter ( templates ) ; } catch ( TransformerConfigurationException e1 ) { if ( _xsltcFactory == null ) { createXSLTCTransformerFactory ( ) ; } ErrorListener errorListener = _xsltcFactory . getErrorListener ( ) ; if ( errorListener != null ) { try { errorListener . fatalError ( e1 ) ; return null ; } catch ( TransformerException e2 ) { new TransformerConfigurationException ( e2 ) ; } } throw e1 ; } } } 	1	['21', '3', '0', '3', '45', '0', '0', '3', '19', '0.5', '476', '1', '0', '0.5', '0.220238095', '1', '2', '21.42857143', '3', '1.0476', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_ca extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Aquesta funció no té suport. " } , { ER_CANNOT_OVERWRITE_CAUSE , "No es pot sobreescriure una causa " } , { ER_NO_DEFAULT_IMPL , "No s'ha trobat cap implementació per defecte " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "En l''actualitat ChunkedIntArray({0}) no té suport " } , { ER_OFFSET_BIGGER_THAN_SLOT , "El desplaçament és més gran que la ranura " } , { ER_COROUTINE_NOT_AVAIL , "Coroutine no està disponible, id={0} " } , { ER_COROUTINE_CO_EXIT , "CoroutineManager ha rebut una petició co_exit() " } , { ER_COJOINROUTINESET_FAILED , "S'ha produït un error a co_joinCoroutineSet() " } , { ER_COROUTINE_PARAM , "Error de paràmetre coroutine ({0}) " } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: doTerminate de l''analitzador respon {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "L'anàlisi no es pot cridar mentre s'està duent a terme " } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: l''iterador de tipus de l''eix {0} no s''ha implementat " } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: l''iterador de l''eix {0} no s''ha implementat " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "El clonatge de l'iterador no té suport " } , { ER_UNKNOWN_AXIS_TYPE , "Tipus de commutació de l''eix desconeguda: {0} " } , { ER_AXIS_NOT_SUPPORTED , "La commutació de l''eix no té suport: {0} " } , { ER_NO_DTMIDS_AVAIL , "No hi ha més ID de DTM disponibles " } , { ER_NOT_SUPPORTED , "No té suport: {0} " } , { ER_NODE_NON_NULL , "El node no ha de ser nul per a getDTMHandleFromNode " } , { ER_COULD_NOT_RESOLVE_NODE , "No s'ha pogut resoldre el node en un manejador " } , { ER_STARTPARSE_WHILE_PARSING , "startParse no es pot cridar mentre s'està duent a terme l'anàlisi " } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse necessita un SAXParser que no sigui nul " } , { ER_COULD_NOT_INIT_PARSER , "No s'ha pogut inicialitzar l'analitzador amb " } , { ER_EXCEPTION_CREATING_POOL , "S'ha produït una excepció en crear una nova instància de l'agrupació " } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "La via d'accés conté una seqüència d'escapament no vàlida " } , { ER_SCHEME_REQUIRED , "Es necessita l'esquema " } , { ER_NO_SCHEME_IN_URI , "No s''ha trobat cap esquema a l''URI: {0} " } , { ER_NO_SCHEME_INURI , "No s'ha trobat cap esquema a l'URI " } , { ER_PATH_INVALID_CHAR , "La via d'accés conté un caràcter no vàlid {0} " } , { ER_SCHEME_FROM_NULL_STRING , "No es pot establir un esquema des d'una cadena nul·la " } , { ER_SCHEME_NOT_CONFORMANT , "L'esquema no té conformitat. " } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "El sistema principal no té una adreça ben formada " } , { ER_PORT_WHEN_HOST_NULL , "El port no es pot establir quan el sistema principal és nul " } , { ER_INVALID_PORT , "Número de port no vàlid " } , { ER_FRAG_FOR_GENERIC_URI , "El fragment només es pot establir per a un URI genèric " } , { ER_FRAG_WHEN_PATH_NULL , "El fragment no es pot establir si la via d'accés és nul·la " } , { ER_FRAG_INVALID_CHAR , "El fragment conté un caràcter no vàlid " } , { ER_PARSER_IN_USE , "L'analitzador ja s'està utilitzant " } , { ER_CANNOT_CHANGE_WHILE_PARSING , "No es pot modificar {0} {1} mentre es du a terme l''anàlisi " } , { ER_SELF_CAUSATION_NOT_PERMITTED , "La causalitat pròpia no està permesa. " } , { ER_NO_USERINFO_IF_NO_HOST , "No es pot especificar informació de l'usuari si no s'especifica el sistema principal " } , { ER_NO_PORT_IF_NO_HOST , "No es pot especificar el port si no s'especifica el sistema principal " } , { ER_NO_QUERY_STRING_IN_PATH , "No es pot especificar una cadena de consulta en la via d'accés i la cadena de consulta " } , { ER_NO_FRAGMENT_STRING_IN_PATH , "No es pot especificar un fragment tant en la via d'accés com en el fragment " } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "No es pot inicialitzar l'URI amb paràmetres buits " } , { ER_METHOD_NOT_SUPPORTED , "Aquest mètode encara no té suport " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "Ara mateix no es pot reiniciar IncrementalSAXSource_Filter " } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader no es pot produir abans de la petició d'startParse " } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "La commutació de l''eix no té suport: {0} " } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "S''ha creat ListingErrorHandler amb PrintWriter nul " } , { ER_SYSTEMID_UNKNOWN , "ID del sistema (SystemId) desconegut " } , { ER_LOCATION_UNKNOWN , "Ubicació de l'error desconeguda" } , { ER_PREFIX_MUST_RESOLVE , "El prefix s''ha de resoldre en un espai de noms: {0} " } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() no té suport a XPathContext " } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "El subordinat de l'atribut no té un document de propietari. " } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "El subordinat de l'atribut no té un element de document de propietari. " } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Avís: no es pot produir text abans de l'element de document. Es passa per alt. " } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "No hi pot haver més d'una arrel en un DOM. " } , { ER_ARG_LOCALNAME_NULL , "L'argument 'localName' és nul. " } , { ER_ARG_LOCALNAME_INVALID , "El nom local de QNAME ha de ser un NCName vàlid. " } , { ER_ARG_PREFIX_INVALID , "El prefix de QNAME ha de ser un NCName vàlid. " } , { "BAD_CODE" , "El paràmetre de createMessage estava fora dels límits. " } , { "FORMAT_FAILED" , "S'ha generat una excepció durant la crida messageFormat. " } , { "line" , "Línia núm. " } , { "column" , "Columna núm. " } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "La classe de serialitzador ''{0}'' no implementa org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "No s''ha trobat el recurs [ {0} ].\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "El recurs [ {0} ] no s''ha pogut carregar: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Grandària del buffer <=0 " } , { ER_INVALID_UTF16_SURROGATE , "S''ha detectat un suplent UTF-16 no vàlid: {0} ? " } , { ER_OIERROR , "Error d'E/S " } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "No es pot afegir l''atribut {0} després dels nodes subordinats o abans que es produeixi un element. Es passarà per alt l''atribut. " } , { ER_NAMESPACE_PREFIX , "L''espai de noms del prefix ''{0}'' no s''ha declarat." } , { ER_STRAY_ATTRIBUTE , "L''atribut ''{0}'' es troba fora de l''element." } , { ER_STRAY_NAMESPACE , "La declaració d''espai de noms ''{0}''=''{1}'' es troba fora de l''element." } , { ER_COULD_NOT_LOAD_RESOURCE , "No s''ha pogut carregar ''{0}'' (comproveu la CLASSPATH); ara s''estan fent servir els valors per defecte." } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "No s''ha pogut carregar el fitxer de propietats ''{0}'' del mètode de sortida ''{1}'' (comproveu la CLASSPATH)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "ca" , "ES" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xml . utils ; public class ThreadControllerWrapper { static ThreadController m_tpool = new ThreadController ( ) ; public static void setThreadController ( ThreadController tpool ) { m_tpool = tpool ; } public static Thread runThread ( Runnable runnable , int priority ) { return m_tpool . run ( runnable , priority ) ; } public static void waitThread ( Thread worker , Runnable task ) throws InterruptedException { m_tpool . waitThread ( worker , task ) ; } public static class ThreadController { public Thread run ( Runnable task , int priority ) { Thread t = new Thread ( task ) ; t . start ( ) ; return t ; } public void waitThread ( Thread worker , Runnable task ) throws InterruptedException { worker . join ( ) ; } } } 	1	['5', '1', '0', '3', '9', '0', '2', '1', '4', '0.25', '27', '0', '1', '0', '0.3', '0', '0', '4.2', '1', '0.6', '2']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_zh_CN extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "匹配模式中不允许出现 current() 函数！" } , { ER_CURRENT_TAKES_NO_ARGS , "current() 函数不接受自变量！" } , { ER_DOCUMENT_REPLACED , "document() 函数实现已被 org.apache.xalan.xslt.FuncDocument 替换！" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "上下文没有所有者文档！" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() 的自变量太多。" } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() 的自变量太多。" } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() 的自变量太多。" } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() 的自变量太多。" } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() 的自变量太多。" } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() 的自变量太多。" } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() 的自变量太多。" } , { ER_TRANSLATE_TAKES_3_ARGS , "translate() 函数有三个自变量！" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "unparsed-entity-uri 函数应有一个自变量！" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "名称空间轴尚未实现！" } , { ER_UNKNOWN_AXIS , "未知轴：{0}" } , { ER_UNKNOWN_MATCH_OPERATION , "未知的匹配操作！" } , { ER_INCORRECT_ARG_LENGTH , "processing-instruction() 节点测试的自变量长度不正确！" } , { ER_CANT_CONVERT_TO_NUMBER , "无法将 {0} 转换成数字" } , { ER_CANT_CONVERT_TO_NODELIST , "无法将 {0} 转换成 NodeList！" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "无法将 {0} 转换成 NodeSetDTM！" } , { ER_CANT_CONVERT_TO_TYPE , "无法将 {0} 转换成 type#{1}" } , { ER_EXPECTED_MATCH_PATTERN , "getMatchScore 中期望的匹配模式！" } , { ER_COULDNOT_GET_VAR_NAMED , "无法获取名为 {0} 的变量" } , { ER_UNKNOWN_OPCODE , "错误！未知操作码：{0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "额外的非法标记：{0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "错误引用的文字... 期望为双引号！" } , { ER_EXPECTED_SINGLE_QUOTE , "错误引用的文字... 期望为单引号！" } , { ER_EMPTY_EXPRESSION , "空表达式！" } , { ER_EXPECTED_BUT_FOUND , "期望 {0}，但找到了：{1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "程序员的断定不正确！― {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "19990709 XPath 草稿中，布尔（...）自变量不再是可选的了。" } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "已找到“，”但前面没有自变量！" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "已找到“，”但后面没有自变量！" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "“..[predicate]”或“.[predicate]”是非法的语法。请改为使用“self::node()[predicate]”。" } , { ER_ILLEGAL_AXIS_NAME , "非法的轴名称：{0}" } , { ER_UNKNOWN_NODETYPE , "未知节点类型：{0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "需要引用模式文字（{0}）！" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} 无法格式化为数字！" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "无法创建 XML TransformerFactory 联系：{0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "错误！找不到 xpath 选择表达式（-select）。" } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "错误！在 OP_LOCATIONPATH 之后找不到 ENDOP" } , { ER_ERROR_OCCURED , "出现错误！" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "将 VariableReference 赋给上下文外的变量或没有定义的变量！名称 = {0}" } , { ER_AXES_NOT_ALLOWED , "在匹配模式中只允许 child:: 和 attribute:: 轴！违反的轴 = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() 的自变量个数不正确。" } , { ER_COUNT_TAKES_1_ARG , "count 函数应该有一个自变量！" } , { ER_COULDNOT_FIND_FUNCTION , "找不到函数：{0}" } , { ER_UNSUPPORTED_ENCODING , "不受支持的编码：{0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "getNextSibling 过程中，DTM 中出现问题...正在尝试恢复" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "程序员错误：EmptyNodeList 不可写。" } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "XPathContext 不支持 setDOMFactory！" } , { ER_PREFIX_MUST_RESOLVE , "前缀必须解析为名称空间：{0}" } , { ER_PARSE_NOT_SUPPORTED , "XPathContext 中不支持 parse (InputSource source)！无法打开 {0}" } , { ER_SAX_API_NOT_HANDLED , "DTM 不处理 SAX API characters(char ch[]...！" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "DTM 不处理 ignorableWhitespace(char ch[]...！" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison 不能处理类型 {0} 的节点" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper 不能处理类型 {0} 的节点" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse 错误：SystemID － 第 {0} 行 － {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse 错误" } , { ER_INVALID_UTF16_SURROGATE , "检测到无效的 UTF-16 替代者：{0}？" } , { ER_OIERROR , "IO 错误" } , { ER_CANNOT_CREATE_URL , "无法为 {0} 创建 URL" } , { ER_XPATH_READOBJECT , "在 XPath.readObject 中：{0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "找不到函数令牌。" } , { ER_CANNOT_DEAL_XPATH_TYPE , "无法处理 XPath 类型：{0}" } , { ER_NODESET_NOT_MUTABLE , "此 NodeSet 是不易变的" } , { ER_NODESETDTM_NOT_MUTABLE , "此 NodeSetDTM 是不易变的" } , { ER_VAR_NOT_RESOLVABLE , "变量不可解析：{0}" } , { ER_NULL_ERROR_HANDLER , "错误处理程序为空" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "程序员断言：未知操作码：{0}" } , { ER_ZERO_OR_ONE , "0 或 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "XRTreeFragSelectWrapper 不支持 rtf()" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "XRTreeFragSelectWrapper 不支持 asNodeIterator()" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "XStringForChars 不支持 fsb()" } , { ER_COULD_NOT_FIND_VAR , "找不到名为 {0} 的变量" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars 无法将字符串作为自变量" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer 自变量不能为空" } , { ER_TWO_OR_THREE , "2 或 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "在绑定前已访问变量！" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB 无法将字符串作为自变量！" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n ！！！！错误！正在将步行程序的根设置为空！！！" } , { ER_NODESETDTM_CANNOT_ITERATE , "此 NodeSetDTM 无法迭代到先前的节点！" } , { ER_NODESET_CANNOT_ITERATE , "此 NodeSet 无法迭代到先前的节点！" } , { ER_NODESETDTM_CANNOT_INDEX , "此 NodeSetDTM 无法执行索引或计数功能！" } , { ER_NODESET_CANNOT_INDEX , "此 NodeSet 无法执行索引或计数功能！" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "已经调用 nextNode 后无法调用 setShouldCacheNodes！" } , { ER_ONLY_ALLOWS , "{0} 仅允许 {1} 个自变量" } , { ER_UNKNOWN_STEP , "程序员在 getNextStepPos 中的断言：未知的 stepType：{0}" } , { ER_EXPECTED_REL_LOC_PATH , "在“/”或“//”标记后期望出现相对位置路径。" } , { ER_EXPECTED_LOC_PATH , "期望出现位置路径，但遇到以下标记:{0}" } , { ER_EXPECTED_LOC_STEP , "“/”或“//”标记后期望出现位置步骤。" } , { ER_EXPECTED_NODE_TEST , "期望出现与 NCName:* 或 QName 匹配的节点测试。" } , { ER_EXPECTED_STEP_PATTERN , "期望出现步骤模式，但遇到了“/”。" } , { ER_EXPECTED_REL_PATH_PATTERN , "期望出现相对路径模式。" } , { ER_CANT_CONVERT_TO_BOOLEAN , "无法将 {0} 转换成布尔型。" } , { ER_CANT_CONVERT_TO_SINGLENODE , "无法将 {0} 转换成单节点。此获取方法应用于类型 ANY_UNORDERED_NODE_TYPE 和 FIRST_ORDERED_NODE_TYPE。" } , { ER_CANT_GET_SNAPSHOT_LENGTH , "无法在类型 {0} 上获取快照长度。此获取方法应用于类型 UNORDERED_NODE_SNAPSHOT_TYPE 和 ORDERED_NODE_SNAPSHOT_TYPE。" } , { ER_NON_ITERATOR_TYPE , "无法对非迭代类型 {0} 进行迭代" } , { ER_DOC_MUTATED , "返回结果后文档发生变化。迭代器无效。" } , { ER_INVALID_XPATH_TYPE , "无效的 XPath 类型自变量：{0}" } , { ER_EMPTY_XPATH_RESULT , "空的 XPath 结果对象" } , { ER_INCOMPATIBLE_TYPES , "返回类型 {0} 无法强制转换为指定的类型：{1}" } , { ER_NULL_RESOLVER , "无法使用空前缀解析器解析前缀。" } , { ER_CANT_CONVERT_TO_STRING , "无法将 {0} 转换成字符串。" } , { ER_NON_SNAPSHOT_TYPE , "无法在类型 {0} 上调用 snapshotItem。此方法应用于类型 UNORDERED_NODE_SNAPSHOT_TYPE 和 ORDERED_NODE_SNAPSHOT_TYPE。" } , { ER_WRONG_DOCUMENT , "上下文节点不属于绑定到此 XPathEvaluator 的文档。" } , { ER_WRONG_NODETYPE , "不支持上下文节点类型。" } , { ER_XPATH_ERROR , "XPath 未知错误" } , { WG_LOCALE_NAME_NOT_HANDLED , "format-number 函数中未处理过的语言环境名！" } , { WG_PROPERTY_NOT_SUPPORTED , "不支持 XSL 属性：{0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "当前不要在属性 {1} 中对名称空间 {0} 进行任何处理" } , { WG_SECURITY_EXCEPTION , "在试图访问 XSL 系统属性 {0} 时发生 SecurityException 异常" } , { WG_QUO_NO_LONGER_DEFINED , "XPath 中不再定义旧语法：quo(...)。" } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath 需要一个派生的对象以实现 nodeTest！" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "找不到函数令牌。" } , { WG_COULDNOT_FIND_FUNCTION , "找不到函数：{0}" } , { WG_CANNOT_MAKE_URL_FROM , "无法从 {0} 生成 URL" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "DTM 解析器不支持 -E 选项" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "将 VariableReference 赋给上下文外的变量或没有定义的变量！名称 = {0}" } , { WG_UNSUPPORTED_ENCODING , "不受支持的编码：{0}" } , { "ui_language" , "zh" } , { "help_language" , "zh" } , { "language" , "zh" } , { "BAD_CODE" , "createMessage 的参数超出范围" } , { "FORMAT_FAILED" , "在 messageFormat 调用过程中抛出的异常" } , { "version" , ">>>>>>> Xalan 版本" } , { "version2" , "<<<<<<<" } , { "yes" , "是" } , { "line" , "行号" } , { "column" , "列号" } , { "xsldone" , "XSLProcessor：完成" } , { "xpath_option" , "xpath 选项：" } , { "optionIN" , "[-in inputXMLURL]" } , { "optionSelect" , "[-select xpath 表达式]" } , { "optionMatch" , "[-match 匹配模式（用于匹配诊断）]" } , { "optionAnyExpr" , "或者仅一个 xpath 表达式就将完成一个诊断转储" } , { "noParsermsg1" , "XSL 处理不成功。" } , { "noParsermsg2" , "** 找不到解析器 **" } , { "noParsermsg3" , "请检查您的类路径。" } , { "noParsermsg4" , "如果没有 IBM 的 XML Parser for Java，您可以从以下位置下载它：" } , { "noParsermsg5" , "IBM 的 AlphaWorks：http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#错误" ; public static final String ERROR_HEADER = "错误:" ; public static final String WARNING_HEADER = "警告:" ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "zh" , "CN" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "无法装入任何资源包。" , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_zh_CN extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "不支持函数！" } , { ER_CANNOT_OVERWRITE_CAUSE , "无法覆盖原因" } , { ER_NO_DEFAULT_IMPL , "找不到缺省实现" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "当前不支持 ChunkedIntArray({0})" } , { ER_OFFSET_BIGGER_THAN_SLOT , "偏移大于槽" } , { ER_COROUTINE_NOT_AVAIL , "协同程序不可用，id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager 接收到 co_exit() 请求" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() 失败" } , { ER_COROUTINE_PARAM , "协同程序参数错误（{0}）" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\n意外：解析器 doTerminate 应答 {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "分析时可能没有调用 parse" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "错误：没有实现为轴 {0} 输入的迭代器" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "错误：没有实现轴 {0} 的迭代器" } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "不支持迭代器克隆" } , { ER_UNKNOWN_AXIS_TYPE , "未知的轴遍历类型：{0}" } , { ER_AXIS_NOT_SUPPORTED , "不支持轴遍历程序：{0}" } , { ER_NO_DTMIDS_AVAIL , "无更多的 DTM 标识可用" } , { ER_NOT_SUPPORTED , "不支持：{0}" } , { ER_NODE_NON_NULL , "节点对于 getDTMHandleFromNode 必须是非空的" } , { ER_COULD_NOT_RESOLVE_NODE , "无法将节点解析到句柄" } , { ER_STARTPARSE_WHILE_PARSING , "分析时可能没有调用 startParse" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse 需要非空的 SAXParser" } , { ER_COULD_NOT_INIT_PARSER , "无法用以下工具初始化解析器" } , { ER_EXCEPTION_CREATING_POOL , "为池创建新实例时发生异常" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "路径包含无效的转义序列" } , { ER_SCHEME_REQUIRED , "模式是必需的！" } , { ER_NO_SCHEME_IN_URI , "在 URI 中找不到模式：{0}" } , { ER_NO_SCHEME_INURI , "URI 中未找到模式" } , { ER_PATH_INVALID_CHAR , "路径包含非法字符：{0}" } , { ER_SCHEME_FROM_NULL_STRING , "无法从空字符串设置模式" } , { ER_SCHEME_NOT_CONFORMANT , "模式不一致。" } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "主机不是格式良好的地址" } , { ER_PORT_WHEN_HOST_NULL , "主机为空时，无法设置端口" } , { ER_INVALID_PORT , "无效的端口号" } , { ER_FRAG_FOR_GENERIC_URI , "只能为一般 URI 设置片段" } , { ER_FRAG_WHEN_PATH_NULL , "路径为空时，无法设置片段" } , { ER_FRAG_INVALID_CHAR , "片段包含无效的字符" } , { ER_PARSER_IN_USE , "解析器已在使用" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "分析时无法更改 {0} {1}" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "不允许自成因果关系" } , { ER_NO_USERINFO_IF_NO_HOST , "如果没有指定主机，则不可以指定 Userinfo" } , { ER_NO_PORT_IF_NO_HOST , "如果没有指定主机，则不可以指定端口" } , { ER_NO_QUERY_STRING_IN_PATH , "路径和查询字符串中不能指定查询字符串" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "路径和片段中都无法指定片段" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "无法以空参数初始化 URI" } , { ER_METHOD_NOT_SUPPORTED , "尚不支持方法" } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "当前不可重新启动 IncrementalSAXSource_Filter" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader 不在 startParse 请求之前" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "不支持轴遍历程序：{0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "以空的 PrintWriter 创建了 ListingErrorHandler！" } , { ER_SYSTEMID_UNKNOWN , "SystemId 未知" } , { ER_LOCATION_UNKNOWN , "错误位置未知" } , { ER_PREFIX_MUST_RESOLVE , "前缀必须解析为名称空间：{0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "XPathContext 中不支持 createDocument ()！" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "子属性没有所有者文档！" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "子属性没有所有者文档元素！" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "警告：无法输出 document 元素前的文本！忽略..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "DOM 上不能有多个根！" } , { ER_ARG_LOCALNAME_NULL , "自变量“localName”为空" } , { ER_ARG_LOCALNAME_INVALID , "QNAME 中的本地名应当是有效的 NCName" } , { ER_ARG_PREFIX_INVALID , "QNAME 中的前缀应当是有效的 NCName" } , { "BAD_CODE" , "createMessage 的参数超出范围" } , { "FORMAT_FAILED" , "在 messageFormat 调用过程中抛出的异常" } , { "line" , "行号" } , { "column" , "列号" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "串行器类“{0}”不实现 org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "找不到资源 [ {0} ]。\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "资源 [ {0} ] 无法装入：{1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "缓冲区大小 <=0" } , { ER_INVALID_UTF16_SURROGATE , "检测到无效的 UTF-16 替代者：{0}？" } , { ER_OIERROR , "IO 错误" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "在生成子节点之后或在生成元素之前无法添加属性 {0}。将忽略属性。" } , { ER_NAMESPACE_PREFIX , "没有说明名称空间前缀“{0}”。" } , { ER_STRAY_ATTRIBUTE , "属性“{0}”在元素外。" } , { ER_STRAY_NAMESPACE , "名称空间说明“{0}”=“{1}”在元素外。" } , { ER_COULD_NOT_LOAD_RESOURCE , "无法装入“{0}”（检查 CLASSPATH），现在只使用缺省值" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "无法为输出方法“{1}”装载属性文件“{0}”（检查 CLASSPATH）" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "zh" , "CN" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "无法装入任何资源包。" , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; public class ElemVariablePsuedo extends ElemVariable { XUnresolvedVariableSimple m_lazyVar ; public void setSelect ( XPath v ) { super . setSelect ( v ) ; m_lazyVar = new XUnresolvedVariableSimple ( this ) ; } public void execute ( TransformerImpl transformer ) throws TransformerException { transformer . getXPathContext ( ) . getVarStack ( ) . setLocalVariable ( m_index , m_lazyVar ) ; } } 	1	['3', '4', '0', '8', '9', '1', '1', '7', '3', '0.5', '26', '0', '1', '0.99086758', '0.555555556', '0', '0', '7.333333333', '1', '0.6667', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_de extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Die Funktion current() ist in einem Übereinstimmungsmuster nicht zulässig!" } , { ER_CURRENT_TAKES_NO_ARGS , "In der Funktion current() dürfen keine Argumente angegeben werden!" } , { ER_DOCUMENT_REPLACED , "Die Implementierung der Funktion document() wurde durch org.apache.xalan.xslt.FuncDocument ersetzt!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "Der Kontextknoten verfügt nicht über ein Eignerdokument!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() weist zu viele Argumente auf." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() weist zu viele Argumente auf." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() weist zu viele Argumente auf." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() weist zu viele Argumente auf." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() weist zu viele Argumente auf." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() weist zu viele Argumente auf." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() weist zu viele Argumente auf." } , { ER_TRANSLATE_TAKES_3_ARGS , "Die Funktion translate() erfordert drei Argumente!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "Die Funktion unparsed-entity-uri sollte ein einziges Argument enthalten!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "Die Namensbereichachse ist bisher nicht implementiert!" } , { ER_UNKNOWN_AXIS , "Unbekannte Achse: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "Unbekannter Übereinstimmungsvorgang!" } , { ER_INCORRECT_ARG_LENGTH , "Die Länge des Arguments für den Knotentest von processing-instruction() ist falsch!" } , { ER_CANT_CONVERT_TO_NUMBER , "{0} kann nicht in eine Zahl konvertiert werden!" } , { ER_CANT_CONVERT_TO_NODELIST , "{0} kann nicht in NodeList konvertiert werden!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0} kann nicht in NodeSetDTM konvertiert werden!" } , { ER_CANT_CONVERT_TO_TYPE , "{0} kann nicht in type#{1} konvertiert werden." } , { ER_EXPECTED_MATCH_PATTERN , "Übereinstimmungsmuster in getMatchScore erwartet!" } , { ER_COULDNOT_GET_VAR_NAMED , "Die Variable mit dem Namen {0} konnte nicht abgerufen werden." } , { ER_UNKNOWN_OPCODE , "FEHLER! Unbekannter Operationscode: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Zusätzliche nicht zulässige Token: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Falsche Anführungszeichen für Literal... Doppelte Anführungszeichen wurden erwartet!" } , { ER_EXPECTED_SINGLE_QUOTE , "Falsche Anführungszeichen für Literal... Einfache Anführungszeichen wurden erwartet!" } , { ER_EMPTY_EXPRESSION , "Leerer Ausdruck!" } , { ER_EXPECTED_BUT_FOUND , "Erwartet wurde {0}, gefunden wurde: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Festlegung des Programmierers ist falsch! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "Das Argument boolean(...) ist im XPath-Entwurf 19990709 nicht mehr optional." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Gefunden wurde ',' ohne vorangestelltes Argument!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Gefunden wurde ',' ohne nachfolgendes Argument!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' oder '.[predicate]' ist eine nicht zulässige Syntax.  Verwenden Sie stattdessen 'self::node()[predicate]'." } , { ER_ILLEGAL_AXIS_NAME , "Nicht zulässiger Achsenname: {0}" } , { ER_UNKNOWN_NODETYPE , "Unbekannter Knotentyp: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Musterliteral ({0}) muss in Anführungszeichen angegeben werden!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} konnte nicht als Zahl formatiert werden!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "XML-TransformerFactory-Liaison konnte nicht erstellt werden: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Fehler! xpath-Auswahlausdruck (-select) konnte nicht gefunden werden." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "FEHLER! ENDOP konnte nach OP_LOCATIONPATH nicht gefunden werden." } , { ER_ERROR_OCCURED , "Es ist ein Fehler aufgetreten!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "Das für die Variable angegebene Argument VariableReference befindet sich außerhalb des Kontexts oder weist keine Definition auf!  Name = {0}" } , { ER_AXES_NOT_ALLOWED , "Nur die Achsen ''child::'' und ''attribute::'' sind in Suchmustern zulässig!  Fehlerhafte Achsen = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() weist eine falsche Anzahl Argumenten auf." } , { ER_COUNT_TAKES_1_ARG , "Die Funktion count sollte ein einziges Argument enthalten!" } , { ER_COULDNOT_FIND_FUNCTION , "Die Funktion konnte nicht gefunden werden: {0}" } , { ER_UNSUPPORTED_ENCODING , "Nicht unterstützte Verschlüsselung: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "In dem DTM in getNextSibling ist ein Fehler aufgetreten... Wiederherstellung wird durchgeführt" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Programmierungsfehler: In EmptyNodeList kann nicht geschrieben werden." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory wird nicht von XPathContext unterstützt!" } , { ER_PREFIX_MUST_RESOLVE , "Das Präfix muss in einen Namensbereich aufgelöst werden: {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (InputSource Quelle) wird nicht in XPathContext unterstützt! {0} kann nicht geöffnet werden." } , { ER_SAX_API_NOT_HANDLED , "SAX-API characters(char ch[]... wird nicht von dem DTM verarbeitet!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... wird nicht von dem DTM verarbeitet!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison kann keine Knoten vom Typ {0} verarbeiten" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper kann keine Knoten vom Typ {0} verarbeiten" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Fehler bei DOM2Helper.parse: System-ID - {0} Zeile - {1}" } , { ER_XERCES_PARSE_ERROR , "Fehler bei DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Ungültige UTF-16-Ersetzung festgestellt: {0} ?" } , { ER_OIERROR , "E/A-Fehler" } , { ER_CANNOT_CREATE_URL , "URL kann nicht erstellt werden für: {0}" } , { ER_XPATH_READOBJECT , "In XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "Funktionstoken wurde nicht gefunden." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Der XPath-Typ kann nicht verarbeitet werden: {0}" } , { ER_NODESET_NOT_MUTABLE , "Diese NodeSet kann nicht geändert werden" } , { ER_NODESETDTM_NOT_MUTABLE , "Dieses NodeSetDTM kann nicht geändert werden" } , { ER_VAR_NOT_RESOLVABLE , "Die Variable kann nicht aufgelöst werden: {0}" } , { ER_NULL_ERROR_HANDLER , "Kein Fehlerbehandlungsprogramm vorhanden" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Programmiererfestlegung: Unbekannter Operationscode: {0} " } , { ER_ZERO_OR_ONE , "0 oder 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() wird nicht von XRTreeFragSelectWrapper unterstützt" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() wird nicht von XRTreeFragSelectWrapper unterstützt" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() wird nicht für XStringForChars unterstützt" } , { ER_COULD_NOT_FIND_VAR , "Die Variable mit dem Namen {0} konnte nicht gefunden werden" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars kann keine Zeichenfolge als Argument enthalten" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "Das Argument FastStringBuffer kann nicht Null sein" } , { ER_TWO_OR_THREE , "2 oder 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Auf die Variable wurde zugegriffen, bevor diese gebunden wurde!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB kann keine Zeichenfolge als Argument enthalten!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Fehler! Root eines Walker wird auf Null gesetzt!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Dieses NodeSetDTM kann keinen vorherigen Knoten wiederholen!" } , { ER_NODESET_CANNOT_ITERATE , "Diese NodeSet kann keinen vorherigen Knoten wiederholen!" } , { ER_NODESETDTM_CANNOT_INDEX , "Dieses NodeSetDTM kann keine Indexierungs- oder Zählfunktionen ausführen!" } , { ER_NODESET_CANNOT_INDEX , "Diese NodeSet kann keine Indexierungs- oder Zählfunktionen ausführen!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "setShouldCacheNodes kann nicht aufgerufen werden, nachdem nextNode aufgerufen wurde!" } , { ER_ONLY_ALLOWS , "{0} erlaubt nur {1} Argument(e)" } , { ER_UNKNOWN_STEP , "Programmiererfestlegung in getNextStepPos: stepType unbekannt: {0} " } , { ER_EXPECTED_REL_LOC_PATH , "Nach dem Token '/' oder '//' wurde ein relativer Positionspfad erwartet." } , { ER_EXPECTED_LOC_PATH , "Es wurde ein Positionspfad erwartet, aber folgendes Token wurde festgestellt: {0} " } , { ER_EXPECTED_LOC_STEP , "Nach dem Token '/' oder '//' wurde ein Positionsschritt erwartet." } , { ER_EXPECTED_NODE_TEST , "Es wurde ein Knotentest erwartet, der entweder NCName:* oder dem QNamen entspricht." } , { ER_EXPECTED_STEP_PATTERN , "Es wurde ein Schrittmuster erwartet, aber '/' festgestellt." } , { ER_EXPECTED_REL_PATH_PATTERN , "Es wurde ein Muster eines relativen Pfads erwartet." } , { ER_CANT_CONVERT_TO_BOOLEAN , "{0} kann nicht in einen Booleschen Wert konvertiert werden." } , { ER_CANT_CONVERT_TO_SINGLENODE , "{0} kann nicht in einen Einzelknoten konvertiert werden. Diese Abruffunktion gilt für die Typen ANY_UNORDERED_NODE_TYPE und FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Die Länge der Momentaufnahme für den Typ {0} kann nicht abgerufen werden. Diese Abruffunktion gilt für die Typen UNORDERED_NODE_SNAPSHOT_TYPE und ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Für Nicht-Iterator-Typen können keine Iterationen ausgeführt werden: {0}" } , { ER_DOC_MUTATED , "Seit der Rückgabe des Ergebnisses wurde das Dokument geändert. Der Iterator ist ungültig." } , { ER_INVALID_XPATH_TYPE , "Ungültiges XPath-Typenargument: {0}" } , { ER_EMPTY_XPATH_RESULT , "Leeres XPath-Ergebnisobjekt" } , { ER_INCOMPATIBLE_TYPES , "Eine Konvertierung des zurückgegebenen Typs {0} in den angegebenen Typ {1} kann nicht erzwungen werden." } , { ER_NULL_RESOLVER , "Das Präfix kann nicht mit einer Auflösungsfunktion für Nullpräfixe aufgelöst werden." } , { ER_CANT_CONVERT_TO_STRING , "{0} kann nicht in eine Zeichenfolge (string) konvertiert werden." } , { ER_NON_SNAPSHOT_TYPE , "snapshotItem kann nicht für Typ {0} aufgerufen werden. Diese Methode gilt für die Typen UNORDERED_NODE_SNAPSHOT_TYPE und ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Kontextknoten gehört nicht zu dem Dokument, das an diesen XPathEvaluator gebunden ist." } , { ER_WRONG_NODETYPE , "Der Kontextknotentyp wird nicht unterstützt." } , { ER_XPATH_ERROR , "Unbekannter Fehler in XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "Der Name der Ländereinstellung in der Funktion format-number wurde bisher nicht verarbeitet!" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL-Merkmal wird nicht unterstützt: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Führen Sie derzeit keine Vorgänge mit dem Namensbereich {0} in folgendem Merkmal durch: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException beim Zugriff auf XSL-Systemmerkmal: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Veraltete Syntax: quo(...) ist nicht mehr in XPath definiert." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath benötigt für die Implementierung von nodeTest ein abgeleitetes Objekt!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "Funktionstoken wurde nicht gefunden." } , { WG_COULDNOT_FIND_FUNCTION , "Die Funktion konnte nicht gefunden werden: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "URL konnte nicht erstellt werden aus: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "Option -E wird für DTM-Parser nicht unterstützt" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "Das für die Variable angegebene Argument VariableReference befindet sich außerhalb des Kontexts oder weist keine Definition auf!  Name = {0}" } , { WG_UNSUPPORTED_ENCODING , "Nicht unterstützte Verschlüsselung: {0}" } , { "ui_language" , "de" } , { "help_language" , "de" } , { "language" , "de" } , { "BAD_CODE" , "Der Parameter für createMessage lag außerhalb des gültigen Bereichs" } , { "FORMAT_FAILED" , "Während des Aufrufs von messageFormat wurde eine Ausnahmebedingung ausgelöst" } , { "version" , ">>>>>>> Xalan-Version " } , { "version2" , "<<<<<<<" } , { "yes" , "ja" } , { "line" , "Zeilennummer" } , { "column" , "Spaltennummer" } , { "xsldone" , "XSLProcessor: fertig" } , { "xpath_option" , "xpath-Optionen: " } , { "optionIN" , "[-in EingabeXMLURL]" } , { "optionSelect" , "[-select Xpath-Ausdruck]" } , { "optionMatch" , "[-match Übereinstimmungsmuster (für Übereinstimmungsdiagnose)]" } , { "optionAnyExpr" , "Über einen einfachen xpath-Ausdruck wird ein Diagnosespeicherauszug erstellt" } , { "noParsermsg1" , "XSL-Prozess konnte nicht erfolgreich durchgeführt werden." } , { "noParsermsg2" , "** Parser konnte nicht gefunden werden **" } , { "noParsermsg3" , "Bitte überprüfen Sie den Klassenpfad." } , { "noParsermsg4" , "Wenn Sie nicht über einen IBM XML-Parser für Java verfügen, können Sie ihn über" } , { "noParsermsg5" , "IBM AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "FEHLERHAFTER_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FEHLGESCHLAGEN" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#Fehler" ; public static final String ERROR_HEADER = "Fehler: " ; public static final String WARNING_HEADER = "Achtung: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MUSTER " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xalan . templates ; import org . apache . xpath . XPathVisitor ; public class XSLTVisitor extends XPathVisitor { public boolean visitInstruction ( ElemTemplateElement elem ) { return true ; } public boolean visitStylesheet ( ElemTemplateElement elem ) { return true ; } public boolean visitTopLevelInstruction ( ElemTemplateElement elem ) { return true ; } public boolean visitTopLevelVariableOrParamDecl ( ElemTemplateElement elem ) { return true ; } public boolean visitVariableOrParamDecl ( ElemVariable elem ) { return true ; } public boolean visitLiteralResultElement ( ElemLiteralResult elem ) { return true ; } public boolean visitAVT ( AVT elem ) { return true ; } public boolean visitExtensionElement ( ElemExtensionCall elem ) { return true ; } } 	1	['9', '2', '1', '20', '10', '36', '19', '6', '9', '2', '28', '0', '0', '0.6', '0.314814815', '0', '0', '2.111111111', '1', '0.8889', '1']
package org . apache . xalan . xsltc . dom ; public interface Axis extends org . apache . xml . dtm . Axis { public static final boolean [ ] isReverse = { true , true , false , false , false , false , false , false , false , false , false , true , true , false } ; } 	1	['1', '1', '0', '7', '1', '0', '6', '1', '0', '2', '62', '0', '0', '0', '0', '0', '0', '60', '0', '0', '1']
package org . apache . xalan . trace ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class TracerEvent implements java . util . EventListener { public final ElemTemplateElement m_styleNode ; public final TransformerImpl m_processor ; public final Node m_sourceNode ; public final QName m_mode ; public TracerEvent ( TransformerImpl processor , Node sourceNode , QName mode , ElemTemplateElement styleNode ) { this . m_processor = processor ; this . m_sourceNode = sourceNode ; this . m_mode = mode ; this . m_styleNode = styleNode ; } public static String printNode ( Node n ) { String r = n . hashCode ( ) + " " ; if ( n instanceof Element ) { r += "<" + n . getNodeName ( ) ; Node c = n . getFirstChild ( ) ; while ( null != c ) { if ( c instanceof Attr ) { r += printNode ( c ) + " " ; } c = c . getNextSibling ( ) ; } r += ">" ; } else { if ( n instanceof Attr ) { r += n . getNodeName ( ) + "=" + n . getNodeValue ( ) ; } else { r += n . getNodeName ( ) ; } } return r ; } public static String printNodeList ( NodeList l ) { String r = l . hashCode ( ) + "[" ; int len = l . getLength ( ) - 1 ; int i = 0 ; while ( i < len ) { Node n = l . item ( i ) ; if ( null != n ) { r += printNode ( n ) + ", " ; } ++ i ; } if ( i == len ) { Node n = l . item ( len ) ; if ( null != n ) { r += printNode ( n ) ; } } return r + "]" ; } } 	1	['3', '1', '0', '7', '15', '3', '4', '3', '3', '1', '183', '0', '3', '0', '0.388888889', '0', '0', '58.66666667', '5', '3.3333', '1']
package org . apache . xpath . domapi ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . xpath . XPathException ; import org . w3c . dom . xpath . XPathExpression ; import org . w3c . dom . xpath . XPathNamespace ; public class XPathExpressionImpl implements XPathExpression { private PrefixResolver m_resolver ; private XPath m_xpath ; private Document m_doc = null ; XPathExpressionImpl ( XPath xpath , Document doc ) { m_xpath = xpath ; m_doc = doc ; } public Object evaluate ( Node contextNode , short type , Object result ) throws XPathException , DOMException { if ( m_doc != null ) { if ( ( contextNode != m_doc ) && ( ! contextNode . getOwnerDocument ( ) . equals ( m_doc ) ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_WRONG_DOCUMENT , null ) ; throw new DOMException ( DOMException . WRONG_DOCUMENT_ERR , fmsg ) ; } short nodeType = contextNode . getNodeType ( ) ; if ( ( nodeType != Document . DOCUMENT_NODE ) && ( nodeType != Document . ELEMENT_NODE ) && ( nodeType != Document . ATTRIBUTE_NODE ) && ( nodeType != Document . TEXT_NODE ) && ( nodeType != Document . CDATA_SECTION_NODE ) && ( nodeType != Document . COMMENT_NODE ) && ( nodeType != Document . PROCESSING_INSTRUCTION_NODE ) && ( nodeType != XPathNamespace . XPATH_NAMESPACE_NODE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_WRONG_NODETYPE , null ) ; throw new DOMException ( DOMException . NOT_SUPPORTED_ERR , fmsg ) ; } } if ( ! XPathResultImpl . isValidType ( type ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INVALID_XPATH_TYPE , new Object [ ] { new Integer ( type ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } XPathContext xpathSupport = new XPathContext ( ) ; if ( null != m_doc ) { xpathSupport . getDTMHandleFromNode ( m_doc ) ; } XObject xobj = null ; try { xobj = m_xpath . execute ( xpathSupport , contextNode , m_resolver ) ; } catch ( TransformerException te ) { throw new XPathException ( XPathException . INVALID_EXPRESSION_ERR , te . getMessageAndLocation ( ) ) ; } return new XPathResultImpl ( type , xobj , contextNode ) ; } } 	1	['2', '1', '0', '7', '16', '0', '1', '6', '1', '0.333333333', '137', '1', '2', '0', '0.583333333', '0', '0', '66', '1', '0.5', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_fr extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "Plusieurs feuilles de styles ont été définies dans le même fichier." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "Le modèle ''{0}'' est déjà défini dans cette feuille de style." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "Le modèle ''{0}'' n''est pas défini dans cette feuille de style." } , { ErrorMsg . VARIABLE_REDEF_ERR , "La variable ''{0}'' est définie plusieurs fois dans la même portée." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "Variable ou paramètre ''{0}'' non défini." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "La classe ''{0}'' est introuvable." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "La méthode externe ''{0}'' est introuvable (doit être publique)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Impossible de convertir le type d''argument/de retour dans la méthode ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "Fichier ou URI ''{0}'' introuvable." } , { ErrorMsg . INVALID_URI_ERR , "URI ''{0}'' incorrect." } , { ErrorMsg . FILE_ACCESS_ERR , "Impossible d''ouvrir le fichier ou l''URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "L''élément <xsl:stylesheet> ou <xsl:transform> est attendu." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Le préfixe de l''espace de noms ''{0}'' n''est pas déclaré." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Impossible de résoudre l''appel à la fonction ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "L''argument de ''{0}'' doit être une chaîne littérale." } , { ErrorMsg . XPATH_PARSER_ERR , "Erreur d''analyse de l''expression XPath ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "L''attribut obligatoire ''{0}'' est absent." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Le caractère ''{0}'' est incorrect dans l''expression XPath." } , { ErrorMsg . ILLEGAL_PI_ERR , "Le nom ''{0}'' est incorrect dans l''instruction de traitement." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "L''attribut ''{0}'' est à l''extérieur de l''élément." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Attribut incorrect ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "import/include circulaire. La feuille de style ''{0}'' est déjà chargée." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Tri impossible des fragments de l''arborescence de résultats (les éléments <xsl:sort> sont ignorés). Vous devez trier les noeuds lors de la création de l''arborescence de résultats." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Le formatage décimal ''{0}'' est déjà défini." } , { ErrorMsg . XSL_VERSION_ERR , "La version XSL ''{0}'' n''est pas prise en charge par XSLTC." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Référence variable/paramètre circulaire dans ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Opérateur inconnu dans une expression binaire." } , { ErrorMsg . ILLEGAL_ARG_ERR , "Argument(s) incorrect(s) pour l''appel de fonction." } , { ErrorMsg . DOCUMENT_ARG_ERR , "Le deuxième argument de la fonction document() doit être un ensemble de noeuds." } , { ErrorMsg . MISSING_WHEN_ERR , "Au moins un élément <xsl:when> est requis dans <xsl:choose>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "Un seul élément <xsl:otherwise> est autorisé dans <xsl:choose>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> peut être utilisé uniquement dans <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> peut être utilisé uniquement dans <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "Seuls les éléments <xsl:when> et <xsl:otherwise> sont autorisés dans <xsl:choose>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "Attribut ''name'' absent de <xsl:attribute-set>." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Elément enfant incorrect." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "Vous ne pouvez pas appeler un élément ''{0}''" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "Vous ne pouvez pas appeler un attribut ''{0}''" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Données textuelles à l''extérieur de l''élément de niveau supérieur <xsl:stylesheet>." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "L''analyseur JAXP n''est pas configuré correctement" } , { ErrorMsg . INTERNAL_ERR , "Erreur interne XSLTC irrémédiable : ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Elément XSL non pris en charge ''{0}''." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "Extension XSLTC non reconnue ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "Le document de base n''est pas une feuille de style (l''espace de noms XSL n''est pas déclaré dans l''élément root)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "La feuille de style cible ''{0}'' est introuvable." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Non mis en oeuvre : ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "Le document de base ne contient pas de feuille de style XSL." } , { ErrorMsg . ELEMENT_PARSE_ERR , "Analyse impossible de l''élément ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "L''attribut use de <key> doit avoir la valeur node, node-set, string ou number." } , { ErrorMsg . OUTPUT_VERSION_ERR , "La version du document XML de sortie doit être 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Opérateur inconnu dans une expression relationnelle." } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Tentative d''utilisation du jeu d''attributs non existant ''{0}''." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Analyse impossible du modèle de valeur d''attribut ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Type de données inconnu dans la signature de la classe ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "Conversion impossible du type de données ''{0}'' en ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Cette classe Templates ne contient pas de définition de classe translet valide." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Cette classe Templates ne contient pas de classe du nom ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Chargement impossible de la classe translet ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "La classe translet est chargée, mais il est impossible de créer une instance translet." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "Tentative de définition de ErrorListener pour ''{0}'' à une valeur NULL" } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "Seuls StreamSource, SAXSource et DOMSource sont pris en charge par XSLTC" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "L''objet source transmis à ''{0}'' est vide." } , { ErrorMsg . JAXP_COMPILE_ERR , "Impossible de compiler la feuille de style" } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory ne reconnaît pas l''attribut ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() doit être appelé avant startDocument()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformer ne comporte pas d''objet translet encapsulé." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "Aucun gestionnaire de sortie n''a été défini pour le résultat de la transformation." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "L''objet Result transmis à ''{0}'' est incorrect." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Tentative d''accès à une propriété Transformer incorrecte ''{0}''." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Création impossible de l''adaptateur SAX2DOM : ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "Appel de la part de XSLTCSource.build() sans définition d''identification du système." } , { ErrorMsg . COMPILE_STDIN_ERR , "L''option -i doit être utilisée avec l''option -o." } , { ErrorMsg . COMPILE_USAGE_STR , "SYNOPSIS\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <sortie>]\n      [-d <répertoire>] [-j <fichier_jar>] [-p <module>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }\n\nOPTIONS\n   -o <sortie>    donne le nom<sortie> au translet généré\n. Par défaut, le nom du translet\n                  provient du nom<feuille_de_style>. Cette option\n                  est ignorée si plusieurs feuilles de style sont compilées.\n   -d <répertoire> spécifie un répertoire de destination pour translet\n   -j <fichier_jar>   rassemble les classes translet dans le fichier \n       <fichier_jar>\n   -p <module>   spécifie un préfixe de nom de module pour toutes les classes\n              translet générées.\n   -n             active la mise en ligne de modèle (comportement par défaut - préférable \n                  on en moyenne).\n   -x             active le débogage supplémentaire de sortie de message\n   -s             désactive l'appel de System.exit\n   -u             interprète les arguments <stylesheet> comme des adresses URL\n   -i             force le compilateur à lire la feuille de style dans stdin\n   -v             imprime la version du compilateur\n   -h             imprime cette ligne de syntaxe\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SYNOPSIS \n   java org.apache.xalan.xsltc.cmdline.Transform [-j <fichier_jar>]\n      [-x] [-s] [-n <itérations>] {-u <url_document> | <document>}\n      <classe> [<param1>=<valeur1> ...]\n\n   utilise la <classe> translet pour transformer le document XML \n  <document>. La <classe> translet se trouve dans la\n   fonction CLASSPATH de l'utilisateur ou dans le <fichier_jar> indiqué en option.\nOPTIONS\n   -j <fichier_jar>    spécifie un fichier jar à partir duquel charger translet\n   -x              active le débogage supplémentaire de sortie de message\n   -s              désactive l'appel à System.exit\n   -n <itérations> exécute la transformation <itérations> fois et \n                   affiche des informations de profil\n   -u <url_document> spécifie le document de base XML en tant qu'adresse URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> peut être utilisé uniquement dans <xsl:for-each> ou <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "Le codage de sortie ''{0}'' n''est pas pris en charge dans cette JVM." } , { ErrorMsg . SYNTAX_ERR , "Erreur de syntaxe dans ''{0}''." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "Constructor externe ''{0}'' introuvable." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "Le premier argument de la fonction Java non static ''{0}'' n''est pas une référence d''objet valide." } , { ErrorMsg . TYPE_CHECK_ERR , "Erreur de contrôle du type de l''expression ''{0}''." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Erreur de contrôle du type d''une expression se trouvant dans un emplacement inconnu." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "L''option de ligne de commande ''{0}'' n''est pas correcte." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "Un argument obligatoire est absent de l''option de ligne de commande ''{0}''." } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "AVERTISSEMENT :  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "AVERTISSEMENT :  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "ERREUR BLOQUANTE :  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "ERREUR BLOQUANTE :  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "ERREUR :  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "ERREUR :  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Transformation avec translet ''{0}'' " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Transformation avec translet ''{0}'' du fichier jar ''{1}''" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "Création impossible d''une instance de la classe TransformerFactory ''{0}''." } , { ErrorMsg . COMPILER_ERROR_KEY , "Erreurs de compilation :" } , { ErrorMsg . COMPILER_WARNING_KEY , "Avertissements de compilation :" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Erreurs de translet :" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xalan . transformer ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . KeyDeclaration ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class KeyRefIterator extends org . apache . xpath . axes . ChildTestIterator { public KeyRefIterator ( QName name , XMLString ref , Vector keyDecls , DTMIterator ki ) { super ( null ) ; m_name = name ; m_ref = ref ; m_keyDeclarations = keyDecls ; m_keysNodes = ki ; setWhatToShow ( org . apache . xml . dtm . DTMFilter . SHOW_ALL ) ; } DTMIterator m_keysNodes ; protected int getNextNode ( ) { int next ; while ( DTM . NULL != ( next = m_keysNodes . nextNode ( ) ) ) { if ( DTMIterator . FILTER_ACCEPT == filterNode ( next ) ) break ; } m_lastFetched = next ; return next ; } public short filterNode ( int testNode ) { boolean foundKey = false ; Vector keys = m_keyDeclarations ; QName name = m_name ; KeyIterator ki = ( KeyIterator ) ( ( ( XNodeSet ) m_keysNodes ) . getContainedIter ( ) ) ; org . apache . xpath . XPathContext xctxt = ki . getXPathContext ( ) ; if ( null == xctxt ) assertion ( false , "xctxt can not be null here!" ) ; try { XMLString lookupKey = m_ref ; int nDeclarations = keys . size ( ) ; for ( int i = 0 ; i < nDeclarations ; i ++ ) { KeyDeclaration kd = ( KeyDeclaration ) keys . elementAt ( i ) ; if ( ! kd . getName ( ) . equals ( name ) ) continue ; foundKey = true ; XObject xuse = kd . getUse ( ) . execute ( xctxt , testNode , ki . getPrefixResolver ( ) ) ; if ( xuse . getType ( ) != xuse . CLASS_NODESET ) { XMLString exprResult = xuse . xstr ( ) ; if ( lookupKey . equals ( exprResult ) ) return DTMIterator . FILTER_ACCEPT ; } else { DTMIterator nl = ( ( XNodeSet ) xuse ) . iterRaw ( ) ; int useNode ; while ( DTM . NULL != ( useNode = nl . nextNode ( ) ) ) { DTM dtm = getDTM ( useNode ) ; XMLString exprResult = dtm . getStringValue ( useNode ) ; if ( ( null != exprResult ) && lookupKey . equals ( exprResult ) ) return DTMIterator . FILTER_ACCEPT ; } } } } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } if ( ! foundKey ) throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_XSLKEY_DECLARATION , new Object [ ] { name . getLocalName ( ) } ) ) ; return DTMIterator . FILTER_REJECT ; } protected XMLString m_ref ; protected QName m_name ; protected Vector m_keyDeclarations ; } 	1	['3', '7', '0', '15', '26', '0', '0', '15', '2', '0', '171', '0.75', '3', '0.985185185', '0.444444444', '3', '4', '54.66666667', '6', '3', '1']
package org . apache . xml . dtm ; import javax . xml . transform . SourceLocator ; import org . apache . xml . utils . XMLString ; public interface DTM { public static final int NULL = - 1 ; public static final short ROOT_NODE = 0 ; public static final short ELEMENT_NODE = 1 ; public static final short ATTRIBUTE_NODE = 2 ; public static final short TEXT_NODE = 3 ; public static final short CDATA_SECTION_NODE = 4 ; public static final short ENTITY_REFERENCE_NODE = 5 ; public static final short ENTITY_NODE = 6 ; public static final short PROCESSING_INSTRUCTION_NODE = 7 ; public static final short COMMENT_NODE = 8 ; public static final short DOCUMENT_NODE = 9 ; public static final short DOCUMENT_TYPE_NODE = 10 ; public static final short DOCUMENT_FRAGMENT_NODE = 11 ; public static final short NOTATION_NODE = 12 ; public static final short NAMESPACE_NODE = 13 ; public static final short NTYPES = 14 ; public void setFeature ( String featureId , boolean state ) ; public void setProperty ( String property , Object value ) ; public DTMAxisTraverser getAxisTraverser ( final int axis ) ; public DTMAxisIterator getAxisIterator ( final int axis ) ; public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) ; public boolean hasChildNodes ( int nodeHandle ) ; public int getFirstChild ( int nodeHandle ) ; public int getLastChild ( int nodeHandle ) ; public int getAttributeNode ( int elementHandle , String namespaceURI , String name ) ; public int getFirstAttribute ( int nodeHandle ) ; public int getFirstNamespaceNode ( int nodeHandle , boolean inScope ) ; public int getNextSibling ( int nodeHandle ) ; public int getPreviousSibling ( int nodeHandle ) ; public int getNextAttribute ( int nodeHandle ) ; public int getNextNamespaceNode ( int baseHandle , int namespaceHandle , boolean inScope ) ; public int getParent ( int nodeHandle ) ; public int getDocument ( ) ; public int getOwnerDocument ( int nodeHandle ) ; public int getDocumentRoot ( int nodeHandle ) ; public XMLString getStringValue ( int nodeHandle ) ; public int getStringValueChunkCount ( int nodeHandle ) ; public char [ ] getStringValueChunk ( int nodeHandle , int chunkIndex , int [ ] startAndLen ) ; public int getExpandedTypeID ( int nodeHandle ) ; public int getExpandedTypeID ( String namespace , String localName , int type ) ; public String getLocalNameFromExpandedNameID ( int ExpandedNameID ) ; public String getNamespaceFromExpandedNameID ( int ExpandedNameID ) ; public String getNodeName ( int nodeHandle ) ; public String getNodeNameX ( int nodeHandle ) ; public String getLocalName ( int nodeHandle ) ; public String getPrefix ( int nodeHandle ) ; public String getNamespaceURI ( int nodeHandle ) ; public String getNodeValue ( int nodeHandle ) ; public short getNodeType ( int nodeHandle ) ; public short getLevel ( int nodeHandle ) ; public boolean isSupported ( String feature , String version ) ; public String getDocumentBaseURI ( ) ; public void setDocumentBaseURI ( String baseURI ) ; public String getDocumentSystemIdentifier ( int nodeHandle ) ; public String getDocumentEncoding ( int nodeHandle ) ; public String getDocumentStandalone ( int nodeHandle ) ; public String getDocumentVersion ( int documentHandle ) ; public boolean getDocumentAllDeclarationsProcessed ( ) ; public String getDocumentTypeDeclarationSystemIdentifier ( ) ; public String getDocumentTypeDeclarationPublicIdentifier ( ) ; public int getElementById ( String elementId ) ; public String getUnparsedEntityURI ( String name ) ; public boolean supportsPreStripping ( ) ; public boolean isNodeAfter ( int firstNodeHandle , int secondNodeHandle ) ; public boolean isCharacterElementContentWhitespace ( int nodeHandle ) ; public boolean isDocumentAllDeclarationsProcessed ( int documentHandle ) ; public boolean isAttributeSpecified ( int attributeHandle ) ; public void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException ; public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException ; public org . w3c . dom . Node getNode ( int nodeHandle ) ; public boolean needsTwoThreads ( ) ; public org . xml . sax . ContentHandler getContentHandler ( ) ; public org . xml . sax . ext . LexicalHandler getLexicalHandler ( ) ; public org . xml . sax . EntityResolver getEntityResolver ( ) ; public org . xml . sax . DTDHandler getDTDHandler ( ) ; public org . xml . sax . ErrorHandler getErrorHandler ( ) ; public org . xml . sax . ext . DeclHandler getDeclHandler ( ) ; public void appendChild ( int newChild , boolean clone , boolean cloneDepth ) ; public void appendTextChild ( String str ) ; public SourceLocator getSourceLocatorFor ( int node ) ; public void documentRegistration ( ) ; public void documentRelease ( ) ; public void migrateTo ( DTMManager manager ) ; } 	1	['67', '1', '0', '95', '67', '2211', '92', '4', '67', '1.015151515', '83', '0', '0', '0', '0.242537313', '0', '0', '0', '1', '1', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . ClonerToResultTree ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xalan . serialize . SerializerUtils ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xpath . XPathContext ; public class ElemCopy extends ElemUse { public int getXSLToken ( ) { return Constants . ELEMNAME_COPY ; } public String getNodeName ( ) { return Constants . ELEMNAME_COPY_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext xctxt = transformer . getXPathContext ( ) ; try { int sourceNode = xctxt . getCurrentNode ( ) ; xctxt . pushCurrentNode ( sourceNode ) ; DTM dtm = xctxt . getDTM ( sourceNode ) ; short nodeType = dtm . getNodeType ( sourceNode ) ; if ( ( DTM . DOCUMENT_NODE != nodeType ) && ( DTM . DOCUMENT_FRAGMENT_NODE != nodeType ) ) { SerializationHandler rthandler = transformer . getSerializationHandler ( ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; ClonerToResultTree . cloneToResultTree ( sourceNode , nodeType , dtm , rthandler , false ) ; if ( DTM . ELEMENT_NODE == nodeType ) { super . execute ( transformer ) ; SerializerUtils . processNSDecls ( rthandler , sourceNode , nodeType , dtm ) ; transformer . executeChildTemplates ( this , true ) ; String ns = dtm . getNamespaceURI ( sourceNode ) ; String localName = dtm . getLocalName ( sourceNode ) ; transformer . getResultTreeHandler ( ) . endElement ( ns , localName , dtm . getNodeName ( sourceNode ) ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } else { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; super . execute ( transformer ) ; transformer . executeChildTemplates ( this , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { xctxt . popCurrentNode ( ) ; } } } 	1	['4', '4', '0', '10', '25', '6', '1', '9', '4', '2', '121', '0', '0', '0.985365854', '0.625', '2', '4', '29.25', '1', '0.75', '2']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_es extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "¡Función no soportada!" } , { ER_CANNOT_OVERWRITE_CAUSE , "No se puede escribir encima de la causa" } , { ER_NO_DEFAULT_IMPL , "No se ha encontrado una implementación por omisión" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) no soportada actualmente" } , { ER_OFFSET_BIGGER_THAN_SLOT , "El desplazamiento es mayor que el espacio" } , { ER_COROUTINE_NOT_AVAIL , "Corrutina no disponible, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager ha recibido una petición co_exit()" } , { ER_COJOINROUTINESET_FAILED , "Anomalía de co_joinCoroutineSet()" } , { ER_COROUTINE_PARAM , "Error del parámetro de corrutina ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nINESPERADO: Respuestas doTerminate del analizador {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "No se puede llamar a parse mientras se está analizando" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: El iterador escrito para el eje {0} no está implementado" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: El iterador para el eje {0} no está implementado" } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "La réplica del iterador no está soportada" } , { ER_UNKNOWN_AXIS_TYPE , "Tipo de cruce de eje desconocido: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Cruzador de eje no soportado: {0}" } , { ER_NO_DTMIDS_AVAIL , "No hay más ID de DTM disponibles" } , { ER_NOT_SUPPORTED , "No soportado: {0}" } , { ER_NODE_NON_NULL , "El nodo no debe ser nulo para getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "No se puede resolver el nodo como un manejador" } , { ER_STARTPARSE_WHILE_PARSING , "No se puede llamar a startParse mientras se está analizando" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse necesita un SAXParser no nulo" } , { ER_COULD_NOT_INIT_PARSER , "No se ha podido inicializar el analizador con " } , { ER_EXCEPTION_CREATING_POOL , "Se ha producido una excepción al crear la nueva instancia de la agrupación" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "La vía de acceso contiene una secuencia de escape no válida" } , { ER_SCHEME_REQUIRED , "¡Se necesita un esquema!" } , { ER_NO_SCHEME_IN_URI , "No se ha encontrado un esquema en el URI: {0}" } , { ER_NO_SCHEME_INURI , "No se ha encontrado un esquema en el URI" } , { ER_PATH_INVALID_CHAR , "La vía de acceso contiene un carácter no válido: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "No se puede establecer un esquema de una serie nula" } , { ER_SCHEME_NOT_CONFORMANT , "El esquema no es compatible." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "El sistema principal no es una dirección bien formada" } , { ER_PORT_WHEN_HOST_NULL , "No se puede establecer el puerto si el sistema principal es nulo" } , { ER_INVALID_PORT , "Número de puerto no válido" } , { ER_FRAG_FOR_GENERIC_URI , "Sólo se puede establecer el fragmento para un URI genérico" } , { ER_FRAG_WHEN_PATH_NULL , "No se puede establecer el fragmento si la vía de acceso es nula" } , { ER_FRAG_INVALID_CHAR , "El fragmento contiene un carácter no válido" } , { ER_PARSER_IN_USE , "El analizador ya está en uso" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "No se puede cambiar {0} {1} mientras se analiza" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Autocausalidad no permitida" } , { ER_NO_USERINFO_IF_NO_HOST , "No se puede especificar la información de usuario si no se ha especificado el sistema principal" } , { ER_NO_PORT_IF_NO_HOST , "No se puede especificar el puerto si no se ha especificado el sistema principal" } , { ER_NO_QUERY_STRING_IN_PATH , "No se puede especificar la serie de consulta en la vía de acceso y en la serie de consulta" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "No se puede especificar el fragmento en la vía de acceso y en el fragmento" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "No se puede inicializar el URI con parámetros vacíos" } , { ER_METHOD_NOT_SUPPORTED , "El método no está aún soportado" } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter no es actualmente reiniciable" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader no debe ir antes que la petición startParse" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Cruzador de eje no soportado: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "¡Se ha creado ListingErrorHandler con PrintWriter nulo!" } , { ER_SYSTEMID_UNKNOWN , "SystemId desconocido" } , { ER_LOCATION_UNKNOWN , "Ubicación del error desconocida" } , { ER_PREFIX_MUST_RESOLVE , "El prefijo debe resolverse como un espacio de nombres: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "¡createDocument() no soportada en XPathContext!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "¡El hijo atributo no tiene un documento propietario!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "¡El hijo atributo no tiene un elemento documento propietario!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "¡Aviso: no puede haber salida de texto antes del elemento documento! Ignorando..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "¡No puede haber más de una raíz en DOM!" } , { ER_ARG_LOCALNAME_NULL , "El argumento 'localName' es nulo" } , { ER_ARG_LOCALNAME_INVALID , "Localname en QNAME debe ser un NCName válido" } , { ER_ARG_PREFIX_INVALID , "Prefix en QNAME debe ser un NCName válido" } , { "BAD_CODE" , "El parámetro para createMessage estaba fuera de los límites" } , { "FORMAT_FAILED" , "Se ha generado una excepción durante la llamada messageFormat" } , { "line" , "Línea núm." } , { "column" , "Columna núm." } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "La clase serializer ''{0}'' no implementa org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "No se ha podido cargar el recurso [ {0} ].\n{1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "No se ha podido cargar el recurso [ {0} ]: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Tamaño de almacenamiento intermedio <=0" } , { ER_INVALID_UTF16_SURROGATE , "¿Se ha detectado un sustituto UTF-16 no válido: {0}?" } , { ER_OIERROR , "Error de ES" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "No se puede añadir el atributo {0} después de nodos hijo o antes de que se produzca un elemento. Se ignorará el atributo." } , { ER_NAMESPACE_PREFIX , "No se ha declarado el espacio de nombres para el prefijo ''{0}''." } , { ER_STRAY_ATTRIBUTE , "Atributo ''{0}'' fuera del elemento." } , { ER_STRAY_NAMESPACE , "Declaración del espacio de nombres ''{0}''=''{1}'' fuera del elemento." } , { ER_COULD_NOT_LOAD_RESOURCE , "No se ha podido cargar ''{0}'' (compruebe la CLASSPATH), ahora sólo se están utilizando los valores por omisión" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "No se ha podido cargar el archivo de propiedades ''{0}'' para el método de salida ''{1}'' (compruebe la CLASSPATH)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "es" , "ES" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xalan . extensions ; import java . io . IOException ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . functions . FuncExtFunction ; public abstract class ExtensionHandler { protected String m_namespaceUri ; protected String m_scriptLang ; static Class getClassForName ( String className ) throws ClassNotFoundException { if ( className . equals ( "org.apache.xalan.xslt.extensions.Redirect" ) ) { className = "org.apache.xalan.lib.Redirect" ; } return ObjectFactory . findProviderClass ( className , ObjectFactory . findClassLoader ( ) , true ) ; } protected ExtensionHandler ( String namespaceUri , String scriptLang ) { m_namespaceUri = namespaceUri ; m_scriptLang = scriptLang ; } public abstract boolean isFunctionAvailable ( String function ) ; public abstract boolean isElementAvailable ( String element ) ; public abstract Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException ; public abstract Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException ; public abstract void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException ; } 	1	['7', '1', '3', '13', '11', '21', '7', '6', '5', '1', '29', '1', '0', '0', '0.349206349', '0', '0', '2.857142857', '1', '0.8571', '1']
package org . apache . xalan . extensions ; import java . io . IOException ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . XPathContext ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class ExtensionHandlerExsltFunction extends ExtensionHandler { private String m_namespace ; private StylesheetRoot m_stylesheet ; private static final QName RESULTQNAME = new QName ( Constants . S_EXSLT_FUNCTIONS_URL , Constants . EXSLT_ELEMNAME_FUNCRESULT_STRING ) ; public ExtensionHandlerExsltFunction ( String ns , StylesheetRoot stylesheet ) { super ( ns , "xml" ) ; m_namespace = ns ; m_stylesheet = stylesheet ; } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { } public ElemExsltFunction getFunction ( String funcName ) { QName qname = new QName ( m_namespace , funcName ) ; ElemTemplate templ = m_stylesheet . getTemplateComposed ( qname ) ; if ( templ != null && templ instanceof ElemExsltFunction ) return ( ElemExsltFunction ) templ ; else return null ; } public boolean isFunctionAvailable ( String funcName ) { return getFunction ( funcName ) != null ; } public boolean isElementAvailable ( String elemName ) { if ( ! ( new QName ( m_namespace , elemName ) . equals ( RESULTQNAME ) ) ) { return false ; } else { ElemTemplateElement elem = m_stylesheet . getFirstChildElem ( ) ; while ( elem != null && elem != m_stylesheet ) { if ( elem instanceof ElemExsltFuncResult && ancestorIsFunction ( elem ) ) return true ; ElemTemplateElement nextElem = elem . getFirstChildElem ( ) ; if ( nextElem == null ) nextElem = elem . getNextSiblingElem ( ) ; if ( nextElem == null ) nextElem = elem . getParentElem ( ) ; elem = nextElem ; } } return false ; } private boolean ancestorIsFunction ( ElemTemplateElement child ) { while ( child . getParentElem ( ) != null && ! ( child . getParentElem ( ) instanceof StylesheetRoot ) ) { if ( child . getParentElem ( ) instanceof ElemExsltFunction ) return true ; child = child . getParentElem ( ) ; } return false ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { throw new TransformerException ( "This method should not be called." ) ; } public Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException { ExpressionNode parent = extFunction . exprGetParent ( ) ; while ( parent != null && ! ( parent instanceof ElemTemplate ) ) { parent = parent . exprGetParent ( ) ; } ElemTemplate callerTemplate = ( parent != null ) ? ( ElemTemplate ) parent : null ; XObject [ ] methodArgs ; methodArgs = new XObject [ args . size ( ) ] ; try { for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = XObject . create ( args . elementAt ( i ) ) ; } ElemExsltFunction elemFunc = getFunction ( extFunction . getFunctionName ( ) ) ; if ( null != elemFunc ) { XPathContext context = exprContext . getXPathContext ( ) ; TransformerImpl transformer = ( TransformerImpl ) context . getOwnerObject ( ) ; transformer . pushCurrentFuncResult ( null ) ; elemFunc . execute ( transformer , methodArgs ) ; XObject val = ( XObject ) transformer . popCurrentFuncResult ( ) ; return ( val == null ) ? new XString ( "" ) : val ; } else { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_FUNCTION_NOT_FOUND , new Object [ ] { extFunction . getFunctionName ( ) } ) ) ; } } catch ( TransformerException e ) { throw e ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } } 	1	['9', '2', '0', '16', '32', '28', '0', '16', '7', '0.625', '228', '1', '2', '0.461538462', '0.325', '1', '1', '24', '8', '2.2222', '1']
package org . apache . xml . dtm . ref ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . xerces . parsers . SAXParser ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class IncrementalSAXSource_Xerces implements IncrementalSAXSource { Method fParseSomeSetup = null ; Method fParseSome = null ; Object fPullParserConfig = null ; Method fConfigSetInput = null ; Method fConfigParse = null ; Method fSetInputSource = null ; Constructor fConfigInputSourceCtor = null ; Method fConfigSetByteStream = null ; Method fConfigSetCharStream = null ; Method fConfigSetEncoding = null ; Method fReset = null ; SAXParser fIncrementalParser ; private boolean fParseInProgress = false ; public IncrementalSAXSource_Xerces ( ) throws NoSuchMethodException { try { Class xniConfigClass = ObjectFactory . findProviderClass ( "org.apache.xerces.xni.parser.XMLParserConfiguration" , ObjectFactory . findClassLoader ( ) , true ) ; Class [ ] args1 = { xniConfigClass } ; Constructor ctor = SAXParser . class . getConstructor ( args1 ) ; Class xniStdConfigClass = ObjectFactory . findProviderClass ( "org.apache.xerces.parsers.StandardParserConfiguration" , ObjectFactory . findClassLoader ( ) , true ) ; fPullParserConfig = xniStdConfigClass . newInstance ( ) ; Object [ ] args2 = { fPullParserConfig } ; fIncrementalParser = ( SAXParser ) ctor . newInstance ( args2 ) ; Class fXniInputSourceClass = ObjectFactory . findProviderClass ( "org.apache.xerces.xni.parser.XMLInputSource" , ObjectFactory . findClassLoader ( ) , true ) ; Class [ ] args3 = { fXniInputSourceClass } ; fConfigSetInput = xniStdConfigClass . getMethod ( "setInputSource" , args3 ) ; Class [ ] args4 = { String . class , String . class , String . class } ; fConfigInputSourceCtor = fXniInputSourceClass . getConstructor ( args4 ) ; Class [ ] args5 = { java . io . InputStream . class } ; fConfigSetByteStream = fXniInputSourceClass . getMethod ( "setByteStream" , args5 ) ; Class [ ] args6 = { java . io . Reader . class } ; fConfigSetCharStream = fXniInputSourceClass . getMethod ( "setCharacterStream" , args6 ) ; Class [ ] args7 = { String . class } ; fConfigSetEncoding = fXniInputSourceClass . getMethod ( "setEncoding" , args7 ) ; Class [ ] argsb = { Boolean . TYPE } ; fConfigParse = xniStdConfigClass . getMethod ( "parse" , argsb ) ; Class [ ] noargs = new Class [ 0 ] ; fReset = fIncrementalParser . getClass ( ) . getMethod ( "reset" , noargs ) ; } catch ( Exception e ) { IncrementalSAXSource_Xerces dummy = new IncrementalSAXSource_Xerces ( new SAXParser ( ) ) ; this . fParseSomeSetup = dummy . fParseSomeSetup ; this . fParseSome = dummy . fParseSome ; this . fIncrementalParser = dummy . fIncrementalParser ; } } public IncrementalSAXSource_Xerces ( SAXParser parser ) throws NoSuchMethodException { fIncrementalParser = parser ; Class me = parser . getClass ( ) ; Class [ ] parms = { InputSource . class } ; fParseSomeSetup = me . getMethod ( "parseSomeSetup" , parms ) ; parms = new Class [ 0 ] ; fParseSome = me . getMethod ( "parseSome" , parms ) ; } static public IncrementalSAXSource createIncrementalSAXSource ( ) { try { return new IncrementalSAXSource_Xerces ( ) ; } catch ( NoSuchMethodException e ) { IncrementalSAXSource_Filter iss = new IncrementalSAXSource_Filter ( ) ; iss . setXMLReader ( new SAXParser ( ) ) ; return iss ; } } static public IncrementalSAXSource createIncrementalSAXSource ( SAXParser parser ) { try { return new IncrementalSAXSource_Xerces ( parser ) ; } catch ( NoSuchMethodException e ) { IncrementalSAXSource_Filter iss = new IncrementalSAXSource_Filter ( ) ; iss . setXMLReader ( parser ) ; return iss ; } } public void setContentHandler ( org . xml . sax . ContentHandler handler ) { ( ( XMLReader ) fIncrementalParser ) . setContentHandler ( handler ) ; } public void setLexicalHandler ( org . xml . sax . ext . LexicalHandler handler ) { try { ( ( XMLReader ) fIncrementalParser ) . setProperty ( "http://xml.org/sax/properties/lexical-handler" , handler ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { } catch ( org . xml . sax . SAXNotSupportedException e ) { } } public void setDTDHandler ( org . xml . sax . DTDHandler handler ) { ( ( XMLReader ) fIncrementalParser ) . setDTDHandler ( handler ) ; } public void startParse ( InputSource source ) throws SAXException { if ( fIncrementalParser == null ) throw new SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_STARTPARSE_NEEDS_SAXPARSER , null ) ) ; if ( fParseInProgress ) throw new SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_STARTPARSE_WHILE_PARSING , null ) ) ; boolean ok = false ; try { ok = parseSomeSetup ( source ) ; } catch ( Exception ex ) { throw new SAXException ( ex ) ; } if ( ! ok ) throw new SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COULD_NOT_INIT_PARSER , null ) ) ; } public Object deliverMoreNodes ( boolean parsemore ) { if ( ! parsemore ) { fParseInProgress = false ; return Boolean . FALSE ; } Object arg ; try { boolean keepgoing = parseSome ( ) ; arg = keepgoing ? Boolean . TRUE : Boolean . FALSE ; } catch ( SAXException ex ) { arg = ex ; } catch ( IOException ex ) { arg = ex ; } catch ( Exception ex ) { arg = new SAXException ( ex ) ; } return arg ; } private boolean parseSomeSetup ( InputSource source ) throws SAXException , IOException , IllegalAccessException , java . lang . reflect . InvocationTargetException , java . lang . InstantiationException { if ( fConfigSetInput != null ) { Object [ ] parms1 = { source . getPublicId ( ) , source . getSystemId ( ) , null } ; Object xmlsource = fConfigInputSourceCtor . newInstance ( parms1 ) ; Object [ ] parmsa = { source . getByteStream ( ) } ; fConfigSetByteStream . invoke ( xmlsource , parmsa ) ; parmsa [ 0 ] = source . getCharacterStream ( ) ; fConfigSetCharStream . invoke ( xmlsource , parmsa ) ; parmsa [ 0 ] = source . getEncoding ( ) ; fConfigSetEncoding . invoke ( xmlsource , parmsa ) ; Object [ ] noparms = new Object [ 0 ] ; fReset . invoke ( fIncrementalParser , noparms ) ; parmsa [ 0 ] = xmlsource ; fConfigSetInput . invoke ( fPullParserConfig , parmsa ) ; return parseSome ( ) ; } else { Object [ ] parm = { source } ; Object ret = fParseSomeSetup . invoke ( fIncrementalParser , parm ) ; return ( ( Boolean ) ret ) . booleanValue ( ) ; } } static final Object [ ] noparms = new Object [ 0 ] ; static final Object [ ] parmsfalse = { Boolean . FALSE } ; private boolean parseSome ( ) throws SAXException , IOException , IllegalAccessException , java . lang . reflect . InvocationTargetException { if ( fConfigSetInput != null ) { Object ret = ( Boolean ) ( fConfigParse . invoke ( fPullParserConfig , parmsfalse ) ) ; return ( ( Boolean ) ret ) . booleanValue ( ) ; } else { Object ret = fParseSome . invoke ( fIncrementalParser , noparms ) ; return ( ( Boolean ) ret ) . booleanValue ( ) ; } } public static void main ( String args [ ] ) { System . out . println ( "Starting..." ) ; CoroutineManager co = new CoroutineManager ( ) ; int appCoroutineID = co . co_joinCoroutineSet ( - 1 ) ; if ( appCoroutineID == - 1 ) { System . out . println ( "ERROR: Couldn't allocate coroutine number.\n" ) ; return ; } IncrementalSAXSource parser = createIncrementalSAXSource ( ) ; org . apache . xml . serialize . XMLSerializer trace ; trace = new org . apache . xml . serialize . XMLSerializer ( System . out , null ) ; parser . setContentHandler ( trace ) ; parser . setLexicalHandler ( trace ) ; for ( int arg = 0 ; arg < args . length ; ++ arg ) { try { InputSource source = new InputSource ( args [ arg ] ) ; Object result = null ; boolean more = true ; parser . startParse ( source ) ; for ( result = parser . deliverMoreNodes ( more ) ; result == Boolean . TRUE ; result = parser . deliverMoreNodes ( more ) ) { System . out . println ( "\nSome parsing successful, trying more.\n" ) ; if ( arg + 1 < args . length && "!" . equals ( args [ arg + 1 ] ) ) { ++ arg ; more = false ; } } if ( result instanceof Boolean && ( ( Boolean ) result ) == Boolean . FALSE ) { System . out . println ( "\nParser ended (EOF or on request).\n" ) ; } else if ( result == null ) { System . out . println ( "\nUNEXPECTED: Parser says shut down prematurely.\n" ) ; } else if ( result instanceof Exception ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ( Exception ) result ) ; } } catch ( SAXException e ) { e . printStackTrace ( ) ; } } } } 	1	['13', '1', '0', '9', '49', '14', '0', '9', '10', '0.483333333', '680', '0.066666667', '0', '0', '0.1875', '0', '0', '50.15384615', '9', '1.5385', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_sk extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Funkcia current () nie je povolená v porovnávacom vzore!" } , { ER_CURRENT_TAKES_NO_ARGS , "Funkcia current () nepríjma argumenty!" } , { ER_DOCUMENT_REPLACED , "Implementácia funkcie document() bola nahradená org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "kontext nemá dokument vlastníka!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() má priveľa argumentov." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() má priveľa argumentov." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() má priveľa argumentov." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() má priveľa argumentov." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() má priveľa argumentov." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() má priveľa argumentov" } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() má priveľa argumentov" } , { ER_TRANSLATE_TAKES_3_ARGS , "Funkcia translate() príjma tri argumenty!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "Funkcia unparsed-entity-uri by mala prijať jeden argument!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "osi názvových priestorov ešte nie sú implementované!" } , { ER_UNKNOWN_AXIS , "neznáma os: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "neznáma porovnávacia operácia!" } , { ER_INCORRECT_ARG_LENGTH , "Testovanie uzla arg length of processing-instruction() je nesprávne!" } , { ER_CANT_CONVERT_TO_NUMBER , "Nie je možné konvertovať {0} na číslo" } , { ER_CANT_CONVERT_TO_NODELIST , "Nie je možné konvertovať {0} na NodeList!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Nie je možné konvertovať {0} na NodeSetDTM!" } , { ER_CANT_CONVERT_TO_TYPE , "Nie je možná konverzia {0} na typ#{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Očakávaný porovnávací vzor v getMatchScore!" } , { ER_COULDNOT_GET_VAR_NAMED , "Nie je možné dosiahnuť premennú s názvom {0}" } , { ER_UNKNOWN_OPCODE , "CHYBA! Neznámy kód op: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Nadbytočné neplatné symboly: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Nesprávny literál... očakávaná dvojitá citácia!" } , { ER_EXPECTED_SINGLE_QUOTE , "Nesprávny literál... očakávaná jediná citácia!" } , { ER_EMPTY_EXPRESSION , "Prázdny výraz!" } , { ER_EXPECTED_BUT_FOUND , "Očakávala sa {0}, ale bola nájdená: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Programátorské vyjadrenie je nesprávne! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "argument boolean(...) už nie je voliteľný s konceptom 19990709 XPath." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Nájdene ',' ale žiaden predchádzajúci argument!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Nájdené ',' ale žiaden nasledujúci argument!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' alebo '.[predicate]' je nesprávna syntax.  Použite namiesto toho 'self::node()[predicate]'." } , { ER_ILLEGAL_AXIS_NAME , "Neplatný názov osi: {0}" } , { ER_UNKNOWN_NODETYPE , "Neznámy typ uzla: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Vzorový literál ({0}) potrebuje byť citovaný!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} nemôže byť formátované na číslo!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Nebolo možné vytvoriť vzťah XML TransformerFactory: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Chyba! Nenašiel sa výraz výberu xpath (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "CHYBA! Nebolo možné nájsť ENDOP po OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Vyskytla sa chyba!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference bol daný pre premennú mimo kontext, alebo bez definície!  Názov = {0}" } , { ER_AXES_NOT_ALLOWED , "Len potomok:: atribút:: osi sú povolené v zhodných vzoroch!  Chybné osi = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() má nesprávny počet argumentov." } , { ER_COUNT_TAKES_1_ARG , "Funkcia count by mala prijať jeden argument!" } , { ER_COULDNOT_FIND_FUNCTION , "Nebolo možné nájsť funkciu: {0}" } , { ER_UNSUPPORTED_ENCODING , "Nepodporované kódovanie: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Vyskytol sa problém v DTM v getNextSibling... pokus o obnovu" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Chyba programátora: EmptyNodeList nebolo možné zapísať." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory nie je podporované XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Predpona sa musí rozlíšiť do názvového priestoru: {0}" } , { ER_PARSE_NOT_SUPPORTED , "analýza (InputSource source) nie je podporovaná XPathContext! Nie je možné otvoriť {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API znaky(char ch[]... nie sú spracované DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... nie sú spracované DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison nemôže spracovať uzly typu {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper nemôže spracovať uzly typu {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Chyba DOM2Helper.parse: SystemID - {0} riadok - {1}" } , { ER_XERCES_PARSE_ERROR , "chyba DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Bolo zistené neplatné nahradenie UTF-16: {0} ?" } , { ER_OIERROR , "chyba IO" } , { ER_CANNOT_CREATE_URL , "Nie je možné vytvoriť url pre: {0}" } , { ER_XPATH_READOBJECT , "V XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "nebol nájdený symbol funkcie." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Nie je možné pracovať s typom XPath: {0}" } , { ER_NODESET_NOT_MUTABLE , "Tento NodeSet je nestály" } , { ER_NODESETDTM_NOT_MUTABLE , "Tento NodeSetDTM nie je nestály" } , { ER_VAR_NOT_RESOLVABLE , "Premennú nie je možné rozlíšiť: {0}" } , { ER_NULL_ERROR_HANDLER , "Nulový chybový manipulačný program" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Tvrdenie programátora: neznámy operačný kód: {0}" } , { ER_ZERO_OR_ONE , "0 alebo 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() nie je podporovaný XRTreeFragSelectWrapper" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() nie je podporovaný XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() nie je podporovaný pre XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Nebolo možné nájsť premennú s názvom {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars nemôže ako argument prijať reťazec" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "Argument FastStringBuffer nemôže byť null" } , { ER_TWO_OR_THREE , "2 alebo 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Premenná bola získaná skôr, než bola viazaná!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB nemôže považovať reťazec za argument!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Chyba! Nastavenie root of a walker na null!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Tento NodeSetDTM sa nemôže iterovať na predchádzajúci uzol!" } , { ER_NODESET_CANNOT_ITERATE , "Tento NodeSet sa nemôže iterovať na predchádzajúci uzol!" } , { ER_NODESETDTM_CANNOT_INDEX , "Tento NodeSetDTM nemôže vykonávať funkcie indexovania alebo počítania!" } , { ER_NODESET_CANNOT_INDEX , "Tento NodeSet nemôže vykonávať funkcie indexovania alebo počítania!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Nie je možné volať setShouldCacheNodes po volaní nextNode!" } , { ER_ONLY_ALLOWS , "{0} povoľuje iba {1} argumentov" } , { ER_UNKNOWN_STEP , "Tvrdenie programátora v getNextStepPos: neznáme stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Po symbole '/' alebo '//' sa očakávala cesta relatívneho umiestnenia." } , { ER_EXPECTED_LOC_PATH , "Očakávala sa cesta umiestnenia, ale našiel sa tento symbol : {0}" } , { ER_EXPECTED_LOC_STEP , "Po symbole '/' alebo '//' sa očakával krok umiestnenia." } , { ER_EXPECTED_NODE_TEST , "Očakával sa test uzlov, ktorý sa zhoduje buď s NCName:* alebo s QName." } , { ER_EXPECTED_STEP_PATTERN , "Očakával sa vzor kroku, ale bol zaznamenaný '/'." } , { ER_EXPECTED_REL_PATH_PATTERN , "Očakával sa vzor relatívnej cesty." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Nie je možná konverzia {0} na boolovský." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Nie je možná konverzia {0} na jeden uzol. Tento sa skôr aplikuje na typy ANY_UNORDERED_NODE_TYPE a FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Nie je možné získať dĺžku snímky na type: {0}. Táto sa skôr aplikuje na typy UNORDERED_NODE_SNAPSHOT_TYPE a ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Nie je možné iterovať cez neiterátorský typ: {0}" } , { ER_DOC_MUTATED , "Dokument sa od vrátenia výsledku zmenil. Iterátor je neplatný." } , { ER_INVALID_XPATH_TYPE , "Neplatný argument typu XPath: {0}" } , { ER_EMPTY_XPATH_RESULT , "Prázdny objekt výsledku XPath" } , { ER_INCOMPATIBLE_TYPES , "Vrátený typ: {0} nemožno prinútiť do uvedeného typu: {1}" } , { ER_NULL_RESOLVER , "Nie je možné rozlíšiť predponu s rozlišovačom nulovej predpony." } , { ER_CANT_CONVERT_TO_STRING , "Nie je možná konverzia {0} na reťazec." } , { ER_NON_SNAPSHOT_TYPE , "Nie je možné volať snapshotItem na type: {0}. Táto metóda sa aplikuje na typy UNORDERED_NODE_SNAPSHOT_TYPE a ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Uzol kontextu nepatrí k dokumentu, ktorý je viazaný na tento XPathEvaluator." } , { ER_WRONG_NODETYPE , "Typ uzla kontextu nie je podporovaný." } , { ER_XPATH_ERROR , "Neznáma chyba v XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "názov umiestnenia vo funkcii format-number ešte nebol spracovaný!" } , { WG_PROPERTY_NOT_SUPPORTED , "Vlastníctvo XSL nie je podporované: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Nerobte momentálne nič s názvovým priestorom {0} vo vlastníctve: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException počas pokusu o prístup do systémového vlastníctva XSL: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Stará syntax: quo(...) už nie je v XPath definované." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath potrebuje odvodený objekt na implementáciu nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "nebol nájdený symbol funkcie." } , { WG_COULDNOT_FIND_FUNCTION , "Nebolo možné nájsť funkciu: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Nie je možné vytvoriť URL z: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "-E voľba nie je podporovaná syntaktickým analyzátorom DTM" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference bol daný pre premennú mimo kontext, alebo bez definície!  Názov = {0}" } , { WG_UNSUPPORTED_ENCODING , "Nepodporované kódovanie: {0}" } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "Parameter na createMessage bol mimo ohraničenia" } , { "FORMAT_FAILED" , "Výnimka počas volania messageFormat" } , { "version" , ">>>>>>> Verzia Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "áno" } , { "line" , "Riadok #" } , { "column" , "Stĺpec #" } , { "xsldone" , "XSLProcessor: vykonané" } , { "xpath_option" , "voľby xpath: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath výraz]" } , { "optionMatch" , "   [-match porovnávací vzor (pre diagnostiku zhody)]" } , { "optionAnyExpr" , "Alebo len výraz xpath vykoná výpis pamäte diagnostiky" } , { "noParsermsg1" , "Proces XSL nebol úspešný." } , { "noParsermsg2" , "** Nebolo možné nájsť syntaktický analyzátor **" } , { "noParsermsg3" , "Skontroluje, prosím, svoju classpath." } , { "noParsermsg4" , "Ak nemáte Syntaktický analyzátor XML pre jazyk Java od firmy IBM, môžete si ho stiahnuť z" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Chyba: " ; public static final String WARNING_HEADER = "Upozornenie: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_de extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "In einer Datei sind mehrere Formatvorlagen definiert." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "Vorlage ''{0}'' ist in dieser Formatvorlage bereits definiert." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "Vorlage ''{0}'' ist in dieser Formatvorlage nicht definiert." } , { ErrorMsg . VARIABLE_REDEF_ERR , "Variable ''{0}'' ist in einem Bereich mehrmals definiert." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "Variable oder Parameter ''{0}'' ist nicht definiert." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "Klasse ''{0}'' wurde nicht gefunden." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "Die externe Methode ''{0}'' wurde nicht gefunden (muss 'public' sein)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Argument-/Rückgabetyp in Aufruf kann nicht in Methode ''{0}'' konvertiert werden." } , { ErrorMsg . FILE_NOT_FOUND_ERR , "Datei oder URI ''{0}'' wurde nicht gefunden." } , { ErrorMsg . INVALID_URI_ERR , "Ungültiger URI ''{0}''." } , { ErrorMsg . FILE_ACCESS_ERR , "Datei oder URI ''{0}'' kann nicht geöffnet werden." } , { ErrorMsg . MISSING_ROOT_ERR , "<xsl:stylesheet>- oder <xsl:transform>-Element erwartet." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Namensbereichspräfix ''{0}'' ist nicht deklariert." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Aufruf für Funktion ''{0}'' kann nicht aufgelöst werden." } , { ErrorMsg . NEED_LITERAL_ERR , "Argument für ''{0}'' muss eine Literalzeichenfolge sein." } , { ErrorMsg . XPATH_PARSER_ERR , "Fehler bei Syntaxanalyse des XPath-Ausdrucks ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Erforderliches Attribut ''{0}'' fehlt." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Unzulässiges Zeichen ''{0}'' in XPath-Ausdruck." } , { ErrorMsg . ILLEGAL_PI_ERR , "Unzulässiger Name ''{0}'' für Verarbeitungsanweisung." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "Attribut ''{0}'' befindet sich nicht in einem Element." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Unzulässiges Attribut ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Schleife bei 'import'/'include'. Formatvorlage ''{0}'' ist bereits geladen." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Ergebnisbaumfragmente können nicht sortiert werden (<xsl:sort>-Elemente werden ignoriert). Sie müssen die Knoten sortieren, wenn Sie den Ergebnisbaum erstellen." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Dezimalformatierung ''{0}'' ist bereits definiert." } , { ErrorMsg . XSL_VERSION_ERR , "XSL-Version ''{0}'' wird von XSLTC nicht unterstützt." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Rückbezüglicher Variablen-/Parameterverweis in ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Unbekannter Operator für Binärausdruck." } , { ErrorMsg . ILLEGAL_ARG_ERR , "Unzulässige(s) Argument(e) für Funktionsaufruf." } , { ErrorMsg . DOCUMENT_ARG_ERR , "Zweites Argument für document()-Funktion muss eine Knotengruppe sein." } , { ErrorMsg . MISSING_WHEN_ERR , "Es ist mindestens ein <xsl:when>-Element in <xsl:choose> erforderlich." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "Es ist nur ein <xsl:otherwise>-Element in <xsl:choose> zulässig." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> kann nur in <xsl:choose> verwendet werden." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> kann nur in <xsl:choose> verwendet werden." } , { ErrorMsg . WHEN_ELEMENT_ERR , "In <xsl:choose> sind nur <xsl:when>- und <xsl:otherwise>-Elemente zulässig." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "Das Attribut 'name' fehlt für <xsl:attribute-set>." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Zulässiges Kindelement." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "Sie können ein Element nicht ''{0}'' nennen." } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "Sie können ein Attribut nicht ''{0}'' nennen." } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Textdaten außerhalb von <xsl:stylesheet>-Element der höchsten Ebene." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "JAXP-Parser ist nicht richtig konfiguriert." } , { ErrorMsg . INTERNAL_ERR , "Nicht behebbarer XSLTC-interner Fehler: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Nicht unterstütztes XSL-Element ''{0}''." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "Nicht erkannte XSLTC-Erweiterung ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "Das Eingabedokument ist keine Formatvorlage (der XSL-Namensbereich wird nicht im Stammelement deklariert)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Das Formatvorlagenziel ''{0}'' wurde nicht gefunden." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Nicht implementiert: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "Das Eingabedokument enthält keine XSL-Formatvorlage." } , { ErrorMsg . ELEMENT_PARSE_ERR , "Element ''{0}'' konnte nicht syntaktisch analysiert werden." } , { ErrorMsg . KEY_USE_ATTR_ERR , "Das Attribut 'use' von <key> muss 'node', 'node-set', 'string' oder 'number' sein." } , { ErrorMsg . OUTPUT_VERSION_ERR , "Die Version des XML-Ausgabedokuments sollte 1.0 sein." } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Unbekannter Operator für Vergleichsausdruck." } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Es wird versucht, die nicht vorhandene Attributgruppe ''{0}'' zu verwenden." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Die Attributwertvorlage {0} kann nicht syntaktisch analysiert werden." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Unbekannter Datentyp in Signatur für Klasse ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "Datentyp ''{0}'' kann nicht in ''{1}'' konvertiert werden." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Diese Klasse 'Templates' enthält keine gültige Translet-Klassendefinition." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Diese Klasse 'Templates' enthält keine Klasse mit dem Namen ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Die Translet-Klasse ''{0}'' konnte nicht geladen werden." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Die Translet-Klasse wurde geladen, es kann jedoch kein Translet-Exemplar erstellt werden." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "Es wird versucht, ErrorListener für ''{0}'' auf Null zu setzen." } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "Nur StreamSource, SAXSource und DOMSource werden von XSLTC unterstützt." } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "Das Source-Objekt, das an ''{0}'' übergeben wurde, hat keinen Inhalt." } , { ErrorMsg . JAXP_COMPILE_ERR , "Die Formatvorlage konnte nicht kompiliert werden." } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory erkennt Attribut ''{0}'' nicht." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() muss vor startDocument() aufgerufen werden." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformer hat kein eingebundenes Translet-Objekt." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "Es ist keine Ausgabesteuerroutine für die Umsetzungsergebnisse definiert." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "Das Result-Objekt, das an ''{0}'' übergeben wurde, ist ungültig." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Es wird versucht, auf das ungültige Transformer-Merkmal ''{0}'' zuzugreifen." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Der SAX2DOM-Adapter konnte nicht erstellt werden: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() wurde aufgerufen, ohne dass die System-ID gesetzt war." } , { ErrorMsg . COMPILE_STDIN_ERR , "Die Option -i muss mit der Option -o verwendet werden." } , { ErrorMsg . COMPILE_USAGE_STR , "SYNTAX\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <ausgabe>]\n      [-d <verzeichnis>] [-j <jardatei>]  [-p <paket>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <formatvorlage> | -i }\n\nOPTIONEN\n   -o <ausgabe>    Ordnet dem generierten Translet den Namen \n                  <ausgabe> zu. Der Translet-Name wird standardmäßig\n                  dem Namen von <formatvorlage> entnommen. Diese Option\n                  wird ignoriert, wenn mehrere Formatvorlagen kompiliert werden. \n      -d <verzeichnis> Gibt ein Zielverzeichnis für Translet an.\n   -j <jardatei>   Packt Translet-Klassen in eine jar-Datei mit dem\n                  Namen, der für <jardatei> angegeben wurde.\n   -p <paket>   Gibt ein Paketnamenpräfix für alle\n                   generierten Translet-Klassen an.\n   -n             Aktiviert Inline-Anordnung von Vorlagen (Standardverhalten \n                  durchschnittlich besser).\n   -x          Aktiviert zusätzliche Debugnachrichtenausgabe. \n   -s             Inaktiviert den Aufruf von System.exit.\n   -u          Interpretiert Argumente von <formatvorlage> als URLs.\n   -i             Erzwingt, dass der Compiler die Formatvorlage aus der Standardeingabe liest.\n   -v             Gibt die Version des Compilers aus.\n   -h             Gibt diese Syntaxanweisung aus. \n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SYNTAX \n   java org.apache.xalan.xsltc.cmdline.Transform [-j <jardatei>]\n      [-x] [-s] [-n <iterationen>] {-u <dokument_url> | <dokument>}\n      <klasse> [<param1>=<wert1> ...]\n\n   Verwendet die <klasse> von Translet, um ein XML-Dokument umzusetzen, \n   das als <dokument> angegeben wurde. Die <klasse> von Translet befindet sich entweder in\n   der CLASSPATH-Angabe des Benutzers oder in der optional angegebenen <jardatei>.\nOPTIONEN\n   -j <jardatei>    Gibt eine jar-Datei an, aus der das Translet geladen wird. \n   -x              Aktiviert zusätzliche Debugnachrichtenausgabe.\n   -s              Inaktiviert den Aufruf von System.exit\n   -n <iterationen> Führt die Umsetzung <iterationen> Mal aus und\n                   zeigt Profilinformationen an.\n   -u <dokument_url> Gibt das XML-Eingabedokument als URL an.\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> kann nur in <xsl:for-each> oder <xsl:apply-templates> verwendet werden." } , { ErrorMsg . UNSUPPORTED_ENCODING , "Ausgabeverschlüsselung ''{0}'' wird auf dieser JVM nicht unterstützt." } , { ErrorMsg . SYNTAX_ERR , "Syntaxfehler in ''{0}''." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "Der externe Konstruktor ''{0}'' wurde nicht gefunden." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "Das erste Argument der nichtstatischen Java-Funktion ''{0}'' ist kein gültiger Objektverweis." } , { ErrorMsg . TYPE_CHECK_ERR , "Fehler beim Überprüfen des Typs des Ausdrucks ''{0}''." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Fehler beim Überprüfen des Typs eines Ausdrucks an einer unbekannten Position." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "Die Befehlszeilenoption ''{0}'' ist nicht gültig." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "In der Befehlszeilenoption ''{0}'' fehlt ein erforderliches Argument." } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "WARNUNG:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "WARNUNG:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "SCHWER WIEGENDER FEHLER:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "SCHWER WIEGENDER FEHLER:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "FEHLER:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "FEHLER:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Umsetzung mit Translet ''{0}'' " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Umsetzung mit Translet ''{0}'' aus jar-Datei ''{1}''" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "Es konnte kein Exemplar der TransformerFactory-Klasse ''{0}'' erstellt werden." } , { ErrorMsg . COMPILER_ERROR_KEY , "Compilerfehler:" } , { ErrorMsg . COMPILER_WARNING_KEY , "Compilerwarnungen:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Translet-Fehler:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xpath . functions ; import org . apache . xalan . templates . Constants ; import org . apache . xpath . ExtensionsProvider ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Keywords ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncExtFunctionAvailable extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String prefix ; String namespace ; String methName ; String fullName = m_arg0 . execute ( xctxt ) . str ( ) ; int indexOfNSSep = fullName . indexOf ( ':' ) ; if ( indexOfNSSep < 0 ) { prefix = "" ; namespace = Constants . S_XSLNAMESPACEURL ; methName = fullName ; } else { prefix = fullName . substring ( 0 , indexOfNSSep ) ; namespace = xctxt . getNamespaceContext ( ) . getNamespaceForPrefix ( prefix ) ; if ( null == namespace ) return XBoolean . S_FALSE ; methName = fullName . substring ( indexOfNSSep + 1 ) ; } if ( namespace . equals ( Constants . S_XSLNAMESPACEURL ) ) { try { return Keywords . functionAvailable ( methName ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } catch ( Exception e ) { return XBoolean . S_FALSE ; } } else { ExtensionsProvider extProvider = ( ExtensionsProvider ) xctxt . getOwnerObject ( ) ; return extProvider . functionAvailable ( namespace , methName ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } } 	1	['2', '4', '0', '9', '14', '1', '1', '8', '2', '2', '72', '0', '0', '0.979591837', '0.75', '2', '7', '35', '1', '0.5', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_fr extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "La fonction current() n'est pas admise dans un motif de correspondance !" } , { ER_CURRENT_TAKES_NO_ARGS , "La fonction current() n'accepte pas d'arguments !" } , { ER_DOCUMENT_REPLACED , "L'implémentation de la fonction document() a été remplacée par org.apache.xalan.xslt.FuncDocument !" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "Le contexte ne possède pas de document propriétaire !" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() possède trop d'arguments." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() possède trop d'arguments." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() possède trop d'arguments." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() possède trop d'arguments." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() possède trop d'arguments." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() possède trop d'arguments." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() possède trop d'arguments." } , { ER_TRANSLATE_TAKES_3_ARGS , "La fonction translate() accepte trois arguments !" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "Un argument doit être fournie à la fonction unparsed-entity-uri !" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "L'axe de l'espace de noms n'est pas implémenté !" } , { ER_UNKNOWN_AXIS , "axe inconnu : {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "opération de correspondance inconnue !" } , { ER_INCORRECT_ARG_LENGTH , "La longueur d'argument du test du noeud processing-instruction() n'est pas correcte !" } , { ER_CANT_CONVERT_TO_NUMBER , "Impossible de convertir {0} en un nombre" } , { ER_CANT_CONVERT_TO_NODELIST , "Impossible de convertir {0} en un NodeList !" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Impossible de convertir {0} en un NodeSetDTM !" } , { ER_CANT_CONVERT_TO_TYPE , "Impossible de convertir {0} en un type#{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Motif de correspondance obligatoire dans getMatchScore !" } , { ER_COULDNOT_GET_VAR_NAMED , "Impossible d''extraire la variable {0}" } , { ER_UNKNOWN_OPCODE , "ERREUR ! Code opération inconnu : {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Jetons incorrects supplémentaires : {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Erreur de guillemets dans un littéral... Guillemet double obligatoire !" } , { ER_EXPECTED_SINGLE_QUOTE , "Erreur de guillemets dans un littéral... Guillemet simple obligatoire !" } , { ER_EMPTY_EXPRESSION , "Expression vide !" } , { ER_EXPECTED_BUT_FOUND , "{1} a été trouvé alors que {0} était attendu :" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Assertion de programme incorrecte ! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "L'argument booléen(...) n'est plus optionnel avec le document de normalisation XPath 19990709." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Virgule trouvée sans argument qui la précède !" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Virgule trouvée sans argument qui la suit !" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "''..La syntaxe ''[prédicat]'' ou ''.[prédicat]'' est incorrecte.  Préférez ''self::node()[prédicat]''." } , { ER_ILLEGAL_AXIS_NAME , "nom d''axe incorrect : {0}" } , { ER_UNKNOWN_NODETYPE , "Type de noeud inconnu : {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Le littéral de motif ({0}) doit figurer entre guillemets !" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} ne peut être formatée sous forme numérique !" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Impossible de créer XML TransformerFactory Liaison : {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Erreur ! Impossible de trouver l'expression de sélection xpath (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "ERREUR ! Impossible de trouver ENDOP après OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Une erreur s'est produite !" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "Référence de la variable hors contexte ou sans définition ! Nom = {0}" } , { ER_AXES_NOT_ALLOWED , "Seuls les axes child:: et attribute:: sont autorisés dans des motifs de correspondance !  Axes incorrects= {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() possède un nombre non valide d'arguments." } , { ER_COUNT_TAKES_1_ARG , "Un seul argument doit être fourni à la fonction count !" } , { ER_COULDNOT_FIND_FUNCTION , "Impossible de trouver la fonction : {0}" } , { ER_UNSUPPORTED_ENCODING , "Code non pris en charge : {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Une erreur s'est produite dans la DTM de getNextSibling... Tentative de reprise en cours" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Erreur de programme : Ecriture impossible dans EmptyNodeList." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "SetDOMFactory n'est pas pris en charge par XPathContext !" } , { ER_PREFIX_MUST_RESOLVE , "Le préfixe doit se convertir en espace de noms : {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (InputSource source) non pris en charge dans XPathContext ! Ouverture de {0} impossible" } , { ER_SAX_API_NOT_HANDLED , "Caractères (char ch[]...) de l'API SAX non pris en charge par le DTM !" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... non pris en charge par le DTM !" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison ne prend pas en charge des noeuds de type {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper ne prend pas en charge des noeuds de type {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Erreur de DOM2Helper.parse : ID système - {0} ligne - {1}" } , { ER_XERCES_PARSE_ERROR , "Erreur de DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Substitut UTF-16 non valide détecté : {0} ?" } , { ER_OIERROR , "Erreur d'E-S" } , { ER_CANNOT_CREATE_URL , "Impossible de créer une URL pour : {0}" } , { ER_XPATH_READOBJECT , "Dans XPath.readObject : {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "jeton de fonction introuvable." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Impossible de traiter le type XPath : {0}" } , { ER_NODESET_NOT_MUTABLE , "NodeSet indivisible" } , { ER_NODESETDTM_NOT_MUTABLE , "NodeSetDTM indivisible" } , { ER_VAR_NOT_RESOLVABLE , "Impossible de résoudre la variable : {0}" } , { ER_NULL_ERROR_HANDLER , "Gestionnaire d'erreurs vide" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Assertion de programme : code opération inconnu : {0}" } , { ER_ZERO_OR_ONE , "0 ou 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() non pris en charge par XRTreeFragSelectWrapper" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() non pris en charge par XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() non pris en charge par XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Impossible de trouver la variable portant le nom {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars n'accepte pas de chaîne comme argument" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "L'argument FastStringBuffer ne doit pas être vide" } , { ER_TWO_OR_THREE , "2 ou 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "L'accès à la variable a précédé la liaison de celle-ci !" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB n'accepte pas de chaîne comme argument !" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Erreur ! Définition d'une valeur nulle pour la racine d'un élément walker !!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Ce NodeSetDTM ne permet pas d'itération vers un noeud précédent !" } , { ER_NODESET_CANNOT_ITERATE , "Ce NodeSet ne permet pas d'itération vers un noeud précédent !" } , { ER_NODESETDTM_CANNOT_INDEX , "Ce NodeSetDTM ne peut pas effectuer de fonctions d'indexage ou de dénombrement !" } , { ER_NODESET_CANNOT_INDEX , "Ce NodeSet ne peut pas effectuer de fonctions d'indexage ou de dénombrement !" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Impossible d'appeler setShouldCacheNodes après nextNode !" } , { ER_ONLY_ALLOWS , "{0} accepte uniquement {1} arguments" } , { ER_UNKNOWN_STEP , "Assertion du programmeur dans getNextStepPos : stepType inconnu : {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Un chemin d'emplacement relatif était attendu après le jeton ''/'' ou ''//''." } , { ER_EXPECTED_LOC_PATH , "Un chemin d'emplacement était attendu, mais le jeton suivant a été détecté :  {0}" } , { ER_EXPECTED_LOC_STEP , "Une étape d'emplacement était attendue après le jeton ''/'' ou ''//''." } , { ER_EXPECTED_NODE_TEST , "Un test de noeud correspondant à NCName:* ou QName était attendu." } , { ER_EXPECTED_STEP_PATTERN , "Un modèle d'étape était attendu, mais ''/'' a été détecté." } , { ER_EXPECTED_REL_PATH_PATTERN , "Un modèle de chemin relatif était attendu." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Conversion impossible de {0} en valeur booléenne." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Conversion impossible de {0} en noeud unique. Ce getter s''applique aux types ANY_UNORDERED_NODE_TYPE et FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Obtention impossible de la longueur d''image instantanée sur le type : {0}. Ce getter s''applique aux types UNORDERED_NODE_SNAPSHOT_TYPE et ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Itération impossible sur un type de programme de non itération : {0}" } , { ER_DOC_MUTATED , "Mutation du document depuis le renvoi du résultat. L'itérateur est incorrect." } , { ER_INVALID_XPATH_TYPE , "Argument de type XPath incorrect : {0}" } , { ER_EMPTY_XPATH_RESULT , "Objet résultat XPath vide" } , { ER_INCOMPATIBLE_TYPES , "Le type renvoyé : {0} ne peut pas être forcé dans le type spécifié : {1}" } , { ER_NULL_RESOLVER , "Conversion impossible du préfixe avec un solveur de préfixe de valeur nulle." } , { ER_CANT_CONVERT_TO_STRING , "Conversion impossible de {0} en chaîne." } , { ER_NON_SNAPSHOT_TYPE , "Appel impossible de snapshotItem sur le type : {0}. Cette méthode s''applique aux types UNORDERED_NODE_SNAPSHOT_TYPE et ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Le noeud de contexte n'appartient pas au document lié à ce XPathEvaluator." } , { ER_WRONG_NODETYPE , "Le type de noeud contextuel n'est pas pris en charge." } , { ER_XPATH_ERROR , "Erreur inconnue détectée dans XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "Le nom d'environnement local de la fonction format-number n'est pas encore pris en charge." } , { WG_PROPERTY_NOT_SUPPORTED , "Propriété XSL non prise en charge : {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Espace de noms {0} inexploitable dans la propriété : {1}" } , { WG_SECURITY_EXCEPTION , "Une exception de sécurité s''est produite lors de l''accès à la propriété : {0}" } , { WG_QUO_NO_LONGER_DEFINED , "L'ancienne syntaxe : quo(...) n'est plus définie dans XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath requiert un objet dérivé pour implémenter nodeTest !" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "jeton de fonction introuvable." } , { WG_COULDNOT_FIND_FUNCTION , "Impossible de trouver la fonction : {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Impossible de créer l''URL à partir de : {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "L'option -E n'est pas prise en charge pour l'analyseur DTM" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "Référence de la variable hors contexte ou sans définition ! Nom = {0}" } , { WG_UNSUPPORTED_ENCODING , "Codage non pris en charge : {0}" } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "Le paramètre de createMessage se trouve hors limites" } , { "FORMAT_FAILED" , "Exception soulevée lors de l'appel de messageFormat" } , { "version" , ">>>>>>> Version de Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "oui" } , { "line" , "Ligne #" } , { "column" , "Colonne #" } , { "xsldone" , "XSLProcessor : terminé" } , { "xpath_option" , "options xpath : " } , { "optionIN" , "   [-in URLXMLentrée]" } , { "optionSelect" , "   [-select expression xpath]" } , { "optionMatch" , "   [-match motif de correspondance (diagnostics)]" } , { "optionAnyExpr" , "Une expression xpath effectuera un vidage de diagnostics" } , { "noParsermsg1" , "Echec du processus XSL." } , { "noParsermsg2" , "** Analyseur introuvable **" } , { "noParsermsg3" , "Vérifiez le chemin d'accès des classes." } , { "noParsermsg4" , "XML Parser for Java disponible en téléchargement sur le site" } , { "noParsermsg5" , "AlphaWorks de IBM : http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Erreur : " ; public static final String WARNING_HEADER = "Avertissement : " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class TransletOutput extends Instruction { private Expression _filename ; private boolean _append ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "TransletOutput: " + _filename ) ; } public void parseContents ( Parser parser ) { String filename = getAttribute ( "file" ) ; String append = getAttribute ( "append" ) ; if ( ( filename == null ) || ( filename . equals ( EMPTYSTRING ) ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "file" ) ; } _filename = AttributeValue . create ( this , filename , parser ) ; if ( append != null && ( append . toLowerCase ( ) . equals ( "yes" ) || append . toLowerCase ( ) . equals ( "true" ) ) ) { _append = true ; } else _append = false ; parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type type = _filename . typeCheck ( stable ) ; if ( type instanceof StringType == false ) { _filename = new CastExpr ( _filename , Type . String ) ; } typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadHandler ( ) ) ; final int open = cpg . addMethodref ( TRANSLET_CLASS , "openOutputHandler" , "(" + STRING_SIG + "Z)" + TRANSLET_OUTPUT_SIG ) ; final int close = cpg . addMethodref ( TRANSLET_CLASS , "closeOutputHandler" , "(" + TRANSLET_OUTPUT_SIG + ")V" ) ; il . append ( classGen . loadTranslet ( ) ) ; _filename . translate ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , _append ) ) ; il . append ( new INVOKEVIRTUAL ( open ) ) ; il . append ( methodGen . storeHandler ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( close ) ) ; il . append ( methodGen . storeHandler ( ) ) ; } } 	1	['5', '3', '0', '20', '33', '0', '0', '20', '4', '0.5', '176', '1', '1', '0.933333333', '0.333333333', '2', '7', '33.8', '6', '1.8', '1']
package org . apache . xalan . lib ; import java . util . Hashtable ; import java . util . StringTokenizer ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xalan . xslt . EnvironmentCheck ; import org . apache . xpath . NodeSet ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . w3c . dom . traversal . NodeIterator ; import org . xml . sax . SAXNotSupportedException ; public class Extensions { private Extensions ( ) { } public static NodeSet nodeset ( ExpressionContext myProcessor , Object rtf ) { String textNodeValue ; if ( rtf instanceof NodeIterator ) { return new NodeSet ( ( NodeIterator ) rtf ) ; } else { if ( rtf instanceof String ) { textNodeValue = ( String ) rtf ; } else if ( rtf instanceof Boolean ) { textNodeValue = new XBoolean ( ( ( Boolean ) rtf ) . booleanValue ( ) ) . str ( ) ; } else if ( rtf instanceof Double ) { textNodeValue = new XNumber ( ( ( Double ) rtf ) . doubleValue ( ) ) . str ( ) ; } else { textNodeValue = rtf . toString ( ) ; } try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document myDoc = db . newDocument ( ) ; Text textNode = myDoc . createTextNode ( textNodeValue ) ; DocumentFragment docFrag = myDoc . createDocumentFragment ( ) ; docFrag . appendChild ( textNode ) ; return new NodeSet ( docFrag ) ; } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } } } public static NodeList intersection ( NodeList nl1 , NodeList nl2 ) { return ExsltSets . intersection ( nl1 , nl2 ) ; } public static NodeList difference ( NodeList nl1 , NodeList nl2 ) { return ExsltSets . difference ( nl1 , nl2 ) ; } public static NodeList distinct ( NodeList nl ) { return ExsltSets . distinct ( nl ) ; } public static boolean hasSameNodes ( NodeList nl1 , NodeList nl2 ) { NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet ns2 = new NodeSet ( nl2 ) ; if ( ns1 . getLength ( ) != ns2 . getLength ( ) ) return false ; for ( int i = 0 ; i < ns1 . getLength ( ) ; i ++ ) { Node n = ns1 . elementAt ( i ) ; if ( ! ns2 . contains ( n ) ) return false ; } return true ; } public static XObject evaluate ( ExpressionContext myContext , String xpathExpr ) throws SAXNotSupportedException { return ExsltDynamic . evaluate ( myContext , xpathExpr ) ; } public static NodeList tokenize ( String toTokenize , String delims ) { Document doc = DocumentHolder . m_doc ; StringTokenizer lTokenizer = new StringTokenizer ( toTokenize , delims ) ; NodeSet resultSet = new NodeSet ( ) ; synchronized ( doc ) { while ( lTokenizer . hasMoreTokens ( ) ) { resultSet . addNode ( doc . createTextNode ( lTokenizer . nextToken ( ) ) ) ; } } return resultSet ; } public static NodeList tokenize ( String toTokenize ) { return tokenize ( toTokenize , " \t\n\r" ) ; } public static Node checkEnvironment ( ExpressionContext myContext ) { Document factoryDocument ; try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; factoryDocument = db . newDocument ( ) ; } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } Node resultNode = null ; try { resultNode = checkEnvironmentUsingWhich ( myContext , factoryDocument ) ; if ( null != resultNode ) return resultNode ; EnvironmentCheck envChecker = new EnvironmentCheck ( ) ; Hashtable h = envChecker . getEnvironmentHash ( ) ; resultNode = factoryDocument . createElement ( "checkEnvironmentExtension" ) ; envChecker . appendEnvironmentReport ( resultNode , factoryDocument , h ) ; envChecker = null ; } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } return resultNode ; } private static Node checkEnvironmentUsingWhich ( ExpressionContext myContext , Document factoryDocument ) { final String WHICH_CLASSNAME = "org.apache.env.Which" ; final String WHICH_METHODNAME = "which" ; final Class WHICH_METHOD_ARGS [ ] = { java . util . Hashtable . class , java . lang . String . class , java . lang . String . class } ; try { Class clazz = ObjectFactory . findProviderClass ( WHICH_CLASSNAME , ObjectFactory . findClassLoader ( ) , true ) ; if ( null == clazz ) return null ; java . lang . reflect . Method method = clazz . getMethod ( WHICH_METHODNAME , WHICH_METHOD_ARGS ) ; Hashtable report = new Hashtable ( ) ; Object [ ] methodArgs = { report , "XmlCommons;Xalan;Xerces;Crimson;Ant" , "" } ; Object returnValue = method . invoke ( null , methodArgs ) ; Node resultNode = factoryDocument . createElement ( "checkEnvironmentExtension" ) ; org . apache . xml . utils . Hashtree2Node . appendHashToNode ( report , "whichReport" , resultNode , factoryDocument ) ; return resultNode ; } catch ( Throwable t ) { return null ; } } private static class DocumentHolder { private static final Document m_doc ; static { try { m_doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } } } } 	1	['11', '1', '0', '13', '52', '55', '1', '12', '9', '2', '304', '0', '0', '0', '0.212121212', '0', '0', '26.63636364', '5', '1.8182', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . util . Properties ; import javax . xml . transform . Result ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . Trie ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ToHTMLStream extends ToStream { protected boolean m_inDTD = false ; private boolean m_inBlockElem = false ; protected static final CharInfo m_htmlcharInfo = CharInfo . getCharInfo ( CharInfo . HTML_ENTITIES_RESOURCE , Method . HTML ) ; static final Trie m_elementFlags = new Trie ( ) ; static { m_elementFlags . put ( "BASEFONT" , new ElemDesc ( 0 | ElemDesc . EMPTY ) ) ; m_elementFlags . put ( "FRAME" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "FRAMESET" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "NOFRAMES" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "ISINDEX" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "APPLET" , new ElemDesc ( 0 | ElemDesc . WHITESPACESENSITIVE ) ) ; m_elementFlags . put ( "CENTER" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "DIR" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "MENU" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TT" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "I" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "B" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "BIG" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "SMALL" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "EM" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "STRONG" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "DFN" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "CODE" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "SAMP" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "KBD" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "VAR" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "CITE" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "ABBR" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "ACRONYM" , new ElemDesc ( 0 | ElemDesc . PHRASE ) ) ; m_elementFlags . put ( "SUP" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "SUB" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "SPAN" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "BDO" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "BR" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "BODY" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "ADDRESS" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "DIV" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "A" , new ElemDesc ( 0 | ElemDesc . SPECIAL ) ) ; m_elementFlags . put ( "MAP" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "AREA" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "LINK" , new ElemDesc ( 0 | ElemDesc . HEADMISC | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "IMG" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . EMPTY | ElemDesc . WHITESPACESENSITIVE ) ) ; m_elementFlags . put ( "OBJECT" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . HEADMISC | ElemDesc . WHITESPACESENSITIVE ) ) ; m_elementFlags . put ( "PARAM" , new ElemDesc ( 0 | ElemDesc . EMPTY ) ) ; m_elementFlags . put ( "HR" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET | ElemDesc . EMPTY ) ) ; m_elementFlags . put ( "P" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "H1" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H2" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H3" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H4" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H5" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "H6" , new ElemDesc ( 0 | ElemDesc . HEAD | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "PRE" , new ElemDesc ( 0 | ElemDesc . PREFORMATTED | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "Q" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL ) ) ; m_elementFlags . put ( "BLOCKQUOTE" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "INS" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "DEL" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "DL" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "DT" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "DD" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "OL" , new ElemDesc ( 0 | ElemDesc . LIST | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "UL" , new ElemDesc ( 0 | ElemDesc . LIST | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "LI" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "FORM" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "LABEL" , new ElemDesc ( 0 | ElemDesc . FORMCTRL ) ) ; m_elementFlags . put ( "INPUT" , new ElemDesc ( 0 | ElemDesc . FORMCTRL | ElemDesc . INLINELABEL | ElemDesc . EMPTY ) ) ; m_elementFlags . put ( "SELECT" , new ElemDesc ( 0 | ElemDesc . FORMCTRL | ElemDesc . INLINELABEL ) ) ; m_elementFlags . put ( "OPTGROUP" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "OPTION" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "TEXTAREA" , new ElemDesc ( 0 | ElemDesc . FORMCTRL | ElemDesc . INLINELABEL ) ) ; m_elementFlags . put ( "FIELDSET" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM ) ) ; m_elementFlags . put ( "LEGEND" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "BUTTON" , new ElemDesc ( 0 | ElemDesc . FORMCTRL | ElemDesc . INLINELABEL ) ) ; m_elementFlags . put ( "TABLE" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "CAPTION" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "THEAD" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TFOOT" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TBODY" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "COLGROUP" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "COL" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TR" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "TH" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "TD" , new ElemDesc ( 0 ) ) ; m_elementFlags . put ( "HEAD" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . HEADELEM ) ) ; m_elementFlags . put ( "TITLE" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "BASE" , new ElemDesc ( 0 | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "META" , new ElemDesc ( 0 | ElemDesc . HEADMISC | ElemDesc . EMPTY | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "STYLE" , new ElemDesc ( 0 | ElemDesc . HEADMISC | ElemDesc . RAW | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "SCRIPT" , new ElemDesc ( 0 | ElemDesc . SPECIAL | ElemDesc . ASPECIAL | ElemDesc . HEADMISC | ElemDesc . RAW ) ) ; m_elementFlags . put ( "NOSCRIPT" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "HTML" , new ElemDesc ( 0 | ElemDesc . BLOCK ) ) ; m_elementFlags . put ( "FONT" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "S" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "STRIKE" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "U" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "NOBR" , new ElemDesc ( 0 | ElemDesc . FONTSTYLE ) ) ; m_elementFlags . put ( "IFRAME" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "LAYER" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; m_elementFlags . put ( "ILAYER" , new ElemDesc ( 0 | ElemDesc . BLOCK | ElemDesc . BLOCKFORM | ElemDesc . BLOCKFORMFIELDSET ) ) ; ElemDesc elemDesc ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "AREA" ) ; elemDesc . setAttr ( "HREF" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "NOHREF" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "BASE" ) ; elemDesc . setAttr ( "HREF" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "BLOCKQUOTE" ) ; elemDesc . setAttr ( "CITE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "Q" ) ; elemDesc . setAttr ( "CITE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "INS" ) ; elemDesc . setAttr ( "CITE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "DEL" ) ; elemDesc . setAttr ( "CITE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "A" ) ; elemDesc . setAttr ( "HREF" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "NAME" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "LINK" ) ; elemDesc . setAttr ( "HREF" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "INPUT" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "USEMAP" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "CHECKED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "ISMAP" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "READONLY" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "SELECT" ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "MULTIPLE" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "OPTGROUP" ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "OPTION" ) ; elemDesc . setAttr ( "SELECTED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "TEXTAREA" ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc . setAttr ( "READONLY" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "BUTTON" ) ; elemDesc . setAttr ( "DISABLED" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "SCRIPT" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "FOR" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "DEFER" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "IMG" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "LONGDESC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "USEMAP" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "ISMAP" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "OBJECT" ) ; elemDesc . setAttr ( "CLASSID" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "CODEBASE" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "DATA" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "ARCHIVE" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "USEMAP" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "DECLARE" , ElemDesc . ATTREMPTY ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "FORM" ) ; elemDesc . setAttr ( "ACTION" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "HEAD" ) ; elemDesc . setAttr ( "PROFILE" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "FRAME" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "LONGDESC" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "IFRAME" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc . setAttr ( "LONGDESC" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "LAYER" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "ILAYER" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; elemDesc = ( ElemDesc ) m_elementFlags . get ( "DIV" ) ; elemDesc . setAttr ( "SRC" , ElemDesc . ATTRURL ) ; } static private final ElemDesc m_dummy = new ElemDesc ( 0 | ElemDesc . BLOCK ) ; private boolean m_specialEscapeURLs = true ; private boolean m_omitMetaTag = false ; public void setSpecialEscapeURLs ( boolean bool ) { m_specialEscapeURLs = bool ; } public void setOmitMetaTag ( boolean bool ) { m_omitMetaTag = bool ; } public void setOutputFormat ( Properties format ) { m_specialEscapeURLs = OutputPropertyUtils . getBooleanProperty ( OutputPropertiesFactory . S_USE_URL_ESCAPING , format ) ; m_omitMetaTag = OutputPropertyUtils . getBooleanProperty ( OutputPropertiesFactory . S_OMIT_META_TAG , format ) ; super . setOutputFormat ( format ) ; } private final boolean getSpecialEscapeURLs ( ) { return m_specialEscapeURLs ; } private final boolean getOmitMetaTag ( ) { return m_omitMetaTag ; } public static final ElemDesc getElemDesc ( String name ) { Object obj = m_elementFlags . get ( name ) ; if ( null != obj ) return ( ElemDesc ) obj ; return m_dummy ; } public ToHTMLStream ( ) { super ( ) ; m_charInfo = m_htmlcharInfo ; m_prefixMap = new NamespaceMappings ( ) ; } protected void startDocumentInternal ( ) throws org . xml . sax . SAXException { super . startDocumentInternal ( ) ; m_needToCallStartDocument = false ; m_needToOutputDocTypeDecl = true ; m_startNewLine = false ; setOmitXMLDeclaration ( true ) ; if ( true == m_needToOutputDocTypeDecl ) { String doctypeSystem = getDoctypeSystem ( ) ; String doctypePublic = getDoctypePublic ( ) ; if ( ( null != doctypeSystem ) || ( null != doctypePublic ) ) { final java . io . Writer writer = m_writer ; try { writer . write ( "<!DOCTYPE HTML" ) ; if ( null != doctypePublic ) { writer . write ( " PUBLIC \"" ) ; writer . write ( doctypePublic ) ; writer . write ( '"' ) ; } if ( null != doctypeSystem ) { if ( null == doctypePublic ) writer . write ( " SYSTEM \"" ) ; else writer . write ( '"' ) ; writer . write ( doctypeSystem ) ; writer . write ( '"' ) ; } writer . write ( '>' ) ; outputLineSep ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } } m_needToOutputDocTypeDecl = false ; } public final void endDocument ( ) throws org . xml . sax . SAXException { flushPending ( ) ; if ( m_doIndent && ! m_isprevtext ) { try { outputLineSep ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } flushWriter ( ) ; if ( m_tracer != null ) super . fireEndDoc ( ) ; } public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { ElemContext elemContext = m_elemContext ; if ( elemContext . m_startTagOpen ) { closeStartTag ( ) ; elemContext . m_startTagOpen = false ; } else if ( m_cdataTagOpen ) { closeCDATA ( ) ; m_cdataTagOpen = false ; } else if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } if ( null != namespaceURI && namespaceURI . length ( ) > 0 ) { super . startElement ( namespaceURI , localName , name , atts ) ; return ; } try { ElemDesc elemDesc = getElemDesc ( name ) ; int elemFlags = elemDesc . getFlags ( ) ; if ( m_doIndent ) { boolean isBlockElement = ( elemFlags & ElemDesc . BLOCK ) != 0 ; if ( m_ispreserve ) m_ispreserve = false ; else if ( ( null != elemContext . m_elementName ) && ( ! m_inBlockElem || isBlockElement ) ) { m_startNewLine = true ; indent ( ) ; } m_inBlockElem = ! isBlockElement ; } if ( atts != null ) addAttributes ( atts ) ; m_isprevtext = false ; final java . io . Writer writer = m_writer ; writer . write ( '<' ) ; writer . write ( name ) ; if ( m_tracer != null ) firePseudoAttributes ( ) ; if ( ( elemFlags & ElemDesc . EMPTY ) != 0 ) { m_elemContext = elemContext . push ( ) ; m_elemContext . m_elementName = name ; m_elemContext . m_elementDesc = elemDesc ; return ; } else { elemContext = elemContext . push ( namespaceURI , localName , name ) ; m_elemContext = elemContext ; elemContext . m_elementDesc = elemDesc ; elemContext . m_isRaw = ( elemFlags & ElemDesc . RAW ) != 0 ; } if ( ( elemFlags & ElemDesc . HEADELEM ) != 0 ) { closeStartTag ( ) ; elemContext . m_startTagOpen = false ; if ( ! m_omitMetaTag ) { if ( m_doIndent ) indent ( ) ; writer . write ( "<META http-equiv=\"Content-Type\" content=\"text/html; charset=" ) ; String encoding = getEncoding ( ) ; String encode = Encodings . getMimeEncoding ( encoding ) ; writer . write ( encode ) ; writer . write ( "\">" ) ; } } } catch ( IOException e ) { throw new SAXException ( e ) ; } } public final void endElement ( final String namespaceURI , final String localName , final String name ) throws org . xml . sax . SAXException { if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( null != namespaceURI && namespaceURI . length ( ) > 0 ) { super . endElement ( namespaceURI , localName , name ) ; return ; } try { ElemContext elemContext = m_elemContext ; final ElemDesc elemDesc = elemContext . m_elementDesc ; final int elemFlags = elemDesc . getFlags ( ) ; final boolean elemEmpty = ( elemFlags & ElemDesc . EMPTY ) != 0 ; if ( m_doIndent ) { final boolean isBlockElement = ( elemFlags & ElemDesc . BLOCK ) != 0 ; boolean shouldIndent = false ; if ( m_ispreserve ) { m_ispreserve = false ; } else if ( m_doIndent && ( ! m_inBlockElem || isBlockElement ) ) { m_startNewLine = true ; shouldIndent = true ; } if ( ! elemContext . m_startTagOpen && shouldIndent ) indent ( elemContext . m_currentElemDepth - 1 ) ; m_inBlockElem = ! isBlockElement ; } final java . io . Writer writer = m_writer ; if ( ! elemContext . m_startTagOpen ) { writer . write ( "</" ) ; writer . write ( name ) ; writer . write ( '>' ) ; } else { if ( m_tracer != null ) super . fireStartElem ( name ) ; int nAttrs = m_attributes . getLength ( ) ; if ( nAttrs > 0 ) { processAttributes ( m_writer , nAttrs ) ; m_attributes . clear ( ) ; } if ( ! elemEmpty ) { writer . write ( "></" ) ; writer . write ( name ) ; writer . write ( '>' ) ; } else { writer . write ( '>' ) ; } } if ( ( elemFlags & ElemDesc . WHITESPACESENSITIVE ) != 0 ) m_ispreserve = true ; m_isprevtext = false ; if ( m_tracer != null ) super . fireEndElem ( name ) ; if ( elemEmpty ) { m_elemContext = elemContext . m_prev ; return ; } if ( ! elemContext . m_startTagOpen ) { if ( m_doIndent && ! m_preserves . isEmpty ( ) ) m_preserves . pop ( ) ; } m_elemContext = elemContext . m_prev ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } protected void processAttribute ( java . io . Writer writer , String name , String value , ElemDesc elemDesc ) throws IOException { writer . write ( ' ' ) ; if ( ( ( value . length ( ) == 0 ) || value . equalsIgnoreCase ( name ) ) && elemDesc != null && elemDesc . isAttrFlagSet ( name , ElemDesc . ATTREMPTY ) ) { writer . write ( name ) ; } else { writer . write ( name ) ; writer . write ( "=\"" ) ; if ( elemDesc != null && elemDesc . isAttrFlagSet ( name , ElemDesc . ATTRURL ) ) writeAttrURI ( writer , value , m_specialEscapeURLs ) ; else writeAttrString ( writer , value , this . getEncoding ( ) ) ; writer . write ( '"' ) ; } } private boolean isASCIIDigit ( char c ) { return ( c >= '0' && c <= '9' ) ; } private static String makeHHString ( int i ) { String s = Integer . toHexString ( i ) . toUpperCase ( ) ; if ( s . length ( ) == 1 ) { s = "0" + s ; } return s ; } private boolean isHHSign ( String str ) { boolean sign = true ; try { char r = ( char ) Integer . parseInt ( str , 16 ) ; } catch ( NumberFormatException e ) { sign = false ; } return sign ; } public void writeAttrURI ( final java . io . Writer writer , String string , boolean doURLEscaping ) throws IOException { final int end = string . length ( ) ; if ( end > m_attrBuff . length ) { m_attrBuff = new char [ end * 2 + 1 ] ; } string . getChars ( 0 , end , m_attrBuff , 0 ) ; final char [ ] chars = m_attrBuff ; int cleanStart = 0 ; int cleanLength = 0 ; char ch = 0 ; for ( int i = 0 ; i < end ; i ++ ) { ch = chars [ i ] ; if ( ( ch < 32 ) || ( ch > 126 ) ) { if ( cleanLength > 0 ) { writer . write ( chars , cleanStart , cleanLength ) ; cleanLength = 0 ; } if ( doURLEscaping ) { if ( ch <= 0x7F ) { writer . write ( '%' ) ; writer . write ( makeHHString ( ch ) ) ; } else if ( ch <= 0x7FF ) { int high = ( ch > > 6 ) | 0xC0 ; int low = ( ch & 0x3F ) | 0x80 ; writer . write ( '%' ) ; writer . write ( makeHHString ( high ) ) ; writer . write ( '%' ) ; writer . write ( makeHHString ( low ) ) ; } else if ( isUTF16Surrogate ( ch ) ) { int highSurrogate = ( ( int ) ch ) & 0x03FF ; int wwww = ( ( highSurrogate & 0x03C0 ) > > 6 ) ; int uuuuu = wwww + 1 ; int zzzz = ( highSurrogate & 0x003C ) > > 2 ; int yyyyyy = ( ( highSurrogate & 0x0003 ) << 4 ) & 0x30 ; ch = chars [ ++ i ] ; int lowSurrogate = ( ( int ) ch ) & 0x03FF ; yyyyyy = yyyyyy | ( ( lowSurrogate & 0x03C0 ) > > 6 ) ; int xxxxxx = ( lowSurrogate & 0x003F ) ; int byte1 = 0xF0 | ( uuuuu > > 2 ) ; int byte2 = 0x80 | ( ( ( uuuuu & 0x03 ) << 4 ) & 0x30 ) | zzzz ; int byte3 = 0x80 | yyyyyy ; int byte4 = 0x80 | xxxxxx ; writer . write ( '%' ) ; writer . write ( makeHHString ( byte1 ) ) ; writer . write ( '%' ) ; writer . write ( makeHHString ( byte2 ) ) ; writer . write ( '%' ) ; writer . write ( makeHHString ( byte3 ) ) ; writer . write ( '%' ) ; writer . write ( makeHHString ( byte4 ) ) ; } else { int high = ( ch > > 12 ) | 0xE0 ; int middle = ( ( ch & 0x0FC0 ) > > 6 ) | 0x80 ; int low = ( ch & 0x3F ) | 0x80 ; writer . write ( '%' ) ; writer . write ( makeHHString ( high ) ) ; writer . write ( '%' ) ; writer . write ( makeHHString ( middle ) ) ; writer . write ( '%' ) ; writer . write ( makeHHString ( low ) ) ; } } else if ( escapingNotNeeded ( ch ) ) { writer . write ( ch ) ; } else { writer . write ( "&#" ) ; writer . write ( Integer . toString ( ch ) ) ; writer . write ( ';' ) ; } cleanStart = i + 1 ; } else if ( ch == '"' ) { if ( cleanLength > 0 ) { writer . write ( chars , cleanStart , cleanLength ) ; cleanLength = 0 ; } if ( doURLEscaping ) writer . write ( "%22" ) ; else writer . write ( "&quot;" ) ; cleanStart = i + 1 ; } else { cleanLength ++ ; } } if ( cleanLength > 1 ) { if ( cleanStart == 0 ) writer . write ( string ) ; else writer . write ( chars , cleanStart , cleanLength ) ; } else if ( cleanLength == 1 ) { writer . write ( ch ) ; } } public void writeAttrString ( final java . io . Writer writer , String string , String encoding ) throws IOException { final int end = string . length ( ) ; if ( end > m_attrBuff . length ) { m_attrBuff = new char [ end * 2 + 1 ] ; } string . getChars ( 0 , end , m_attrBuff , 0 ) ; final char [ ] chars = m_attrBuff ; int cleanStart = 0 ; int cleanLength = 0 ; char ch = 0 ; for ( int i = 0 ; i < end ; i ++ ) { ch = chars [ i ] ; if ( escapingNotNeeded ( ch ) && ( ! m_charInfo . isSpecialAttrChar ( ch ) ) ) { cleanLength ++ ; } else if ( '<' == ch || '>' == ch ) { cleanLength ++ ; } else if ( ( '&' == ch ) && ( ( i + 1 ) < end ) && ( '{' == chars [ i + 1 ] ) ) { cleanLength ++ ; } else { if ( cleanLength > 0 ) { writer . write ( chars , cleanStart , cleanLength ) ; cleanLength = 0 ; } int pos = accumDefaultEntity ( writer , ch , i , chars , end , false , false ) ; if ( i != pos ) { i = pos - 1 ; } else { if ( isUTF16Surrogate ( ch ) ) { writeUTF16Surrogate ( ch , chars , i , end ) ; i ++ ; } String entityName = m_charInfo . getEntityNameForChar ( ch ) ; if ( null != entityName ) { writer . write ( '&' ) ; writer . write ( entityName ) ; writer . write ( ';' ) ; } else if ( escapingNotNeeded ( ch ) ) { writer . write ( ch ) ; } else { writer . write ( "&#" ) ; writer . write ( Integer . toString ( ch ) ) ; writer . write ( ';' ) ; } } cleanStart = i + 1 ; } } if ( cleanLength > 1 ) { if ( cleanStart == 0 ) writer . write ( string ) ; else writer . write ( chars , cleanStart , cleanLength ) ; } else if ( cleanLength == 1 ) { writer . write ( ch ) ; } } public final void characters ( char chars [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( m_elemContext . m_isRaw ) { try { if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } m_ispreserve = true ; writeNormalizedChars ( chars , start , length , false , m_lineSepUse ) ; if ( m_tracer != null ) super . fireCharEvent ( chars , start , length ) ; return ; } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OIERROR , null ) , ioe ) ; } } else { super . characters ( chars , start , length ) ; } } public final void cdata ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( ( null != m_elemContext . m_elementName ) && ( m_elemContext . m_elementName . equalsIgnoreCase ( "SCRIPT" ) || m_elemContext . m_elementName . equalsIgnoreCase ( "STYLE" ) ) ) { try { if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } m_ispreserve = true ; if ( shouldIndent ( ) ) indent ( ) ; writeNormalizedChars ( ch , start , length , true , m_lineSepUse ) ; } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OIERROR , null ) , ioe ) ; } } else { super . cdata ( ch , start , length ) ; } } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { flushPending ( ) ; if ( target . equals ( Result . PI_DISABLE_OUTPUT_ESCAPING ) ) { startNonEscaping ( ) ; } else if ( target . equals ( Result . PI_ENABLE_OUTPUT_ESCAPING ) ) { endNonEscaping ( ) ; } else { try { if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } else if ( m_needToCallStartDocument ) startDocumentInternal ( ) ; if ( shouldIndent ( ) ) indent ( ) ; final java . io . Writer writer = m_writer ; writer . write ( "<?" ) ; writer . write ( target ) ; if ( data . length ( ) > 0 && ! Character . isSpaceChar ( data . charAt ( 0 ) ) ) writer . write ( ' ' ) ; writer . write ( data ) ; writer . write ( '>' ) ; if ( m_elemContext . m_currentElemDepth <= 0 ) outputLineSep ( ) ; m_startNewLine = true ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } if ( m_tracer != null ) super . fireEscapingEvent ( target , data ) ; } public final void entityReference ( String name ) throws org . xml . sax . SAXException { try { final java . io . Writer writer = m_writer ; writer . write ( '&' ) ; writer . write ( name ) ; writer . write ( ';' ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public final void endElement ( String elemName ) throws SAXException { endElement ( null , null , elemName ) ; } public void processAttributes ( java . io . Writer writer , int nAttrs ) throws IOException , SAXException { for ( int i = 0 ; i < nAttrs ; i ++ ) { processAttribute ( writer , m_attributes . getQName ( i ) , m_attributes . getValue ( i ) , m_elemContext . m_elementDesc ) ; } } protected void closeStartTag ( ) throws SAXException { try { if ( m_tracer != null ) super . fireStartElem ( m_elemContext . m_elementName ) ; int nAttrs = m_attributes . getLength ( ) ; if ( nAttrs > 0 ) { processAttributes ( m_writer , nAttrs ) ; m_attributes . clear ( ) ; } m_writer . write ( '>' ) ; if ( m_cdataSectionElements != null ) m_elemContext . m_isCdataSection = isCdataSection ( ) ; if ( m_doIndent ) { m_isprevtext = false ; m_preserves . push ( m_ispreserve ) ; } } catch ( IOException e ) { throw new SAXException ( e ) ; } } protected synchronized void init ( OutputStream output , Properties format ) throws UnsupportedEncodingException { if ( null == format ) { format = OutputPropertiesFactory . getDefaultMethodProperties ( Method . HTML ) ; } super . init ( output , format , false ) ; } public void setOutputStream ( OutputStream output ) { try { Properties format ; if ( null == m_format ) format = OutputPropertiesFactory . getDefaultMethodProperties ( Method . HTML ) ; else format = m_format ; init ( output , format , true ) ; } catch ( UnsupportedEncodingException uee ) { } } public void namespaceAfterStartElement ( String prefix , String uri ) throws SAXException { if ( m_elemContext . m_elementURI == null ) { String prefix1 = getPrefixPart ( m_elemContext . m_elementName ) ; if ( prefix1 == null && EMPTYSTRING . equals ( prefix ) ) { m_elemContext . m_elementURI = uri ; } } startPrefixMapping ( prefix , uri , false ) ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { m_inDTD = true ; super . startDTD ( name , publicId , systemId ) ; } public void endDTD ( ) throws org . xml . sax . SAXException { m_inDTD = false ; } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { } public void elementDecl ( String name , String model ) throws SAXException { } public void internalEntityDecl ( String name , String value ) throws SAXException { } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { } public void addUniqueAttribute ( String name , String value , int flags ) throws SAXException { try { final java . io . Writer writer = m_writer ; if ( ( flags & NO_BAD_CHARS ) > 0 && m_htmlcharInfo . onlyQuotAmpLtGt ) { writer . write ( ' ' ) ; writer . write ( name ) ; writer . write ( "=\"" ) ; writer . write ( value ) ; writer . write ( '"' ) ; } else if ( ( flags & HTML_ATTREMPTY ) > 0 && ( value . length ( ) == 0 || value . equalsIgnoreCase ( name ) ) ) { writer . write ( ' ' ) ; writer . write ( name ) ; } else { writer . write ( ' ' ) ; writer . write ( name ) ; writer . write ( "=\"" ) ; if ( ( flags & HTML_ATTRURL ) > 0 ) { writeAttrURI ( writer , value , m_specialEscapeURLs ) ; } else { writeAttrString ( writer , value , this . getEncoding ( ) ) ; } writer . write ( '"' ) ; } } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void comment ( char ch [ ] , int start , int length ) throws SAXException { if ( m_inDTD ) return ; super . comment ( ch , start , length ) ; } public boolean reset ( ) { boolean ret = super . reset ( ) ; if ( ! ret ) return false ; initToHTMLStream ( ) ; return true ; } private void initToHTMLStream ( ) { m_inBlockElem = false ; m_inDTD = false ; m_omitMetaTag = false ; m_specialEscapeURLs = true ; } } 	1	['38', '3', '0', '15', '120', '509', '2', '13', '27', '0.88030888', '2737', '0.857142857', '3', '0.824390244', '0.184275184', '3', '32', '70.84210526', '3', '1.1053', '5']
package org . apache . xalan . templates ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathFactory ; import org . apache . xpath . compiler . XPathParser ; import org . apache . xpath . objects . XObject ; public class AVTPartXPath extends AVTPart { private XPath m_xpath ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_xpath . fixupVariables ( vars , globalsSize ) ; } public boolean canTraverseOutsideSubtree ( ) { return m_xpath . getExpression ( ) . canTraverseOutsideSubtree ( ) ; } public AVTPartXPath ( XPath xpath ) { m_xpath = xpath ; } public AVTPartXPath ( String val , org . apache . xml . utils . PrefixResolver nsNode , XPathParser xpathProcessor , XPathFactory factory , XPathContext liaison ) throws javax . xml . transform . TransformerException { m_xpath = new XPath ( val , null , nsNode , XPath . SELECT , liaison . getErrorListener ( ) ) ; } public String getSimpleString ( ) { return "{" + m_xpath . getPatternString ( ) + "}" ; } public void evaluate ( XPathContext xctxt , FastStringBuffer buf , int context , org . apache . xml . utils . PrefixResolver nsNode ) throws javax . xml . transform . TransformerException { XObject xobj = m_xpath . execute ( xctxt , context , nsNode ) ; if ( null != xobj ) { xobj . appendToFsb ( buf ) ; } } public void callVisitors ( XSLTVisitor visitor ) { m_xpath . getExpression ( ) . callVisitors ( m_xpath , visitor ) ; } } 	1	['7', '2', '0', '13', '20', '0', '1', '12', '7', '0', '74', '1', '1', '0.5', '0.25974026', '0', '0', '9.428571429', '1', '0.7143', '1']
package org . apache . xalan . xsltc . trax ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Reader ; import java . io . Writer ; import java . net . URL ; import java . net . URLConnection ; import java . net . UnknownServiceException ; import java . util . Enumeration ; import java . util . Properties ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMCache ; import org . apache . xalan . xsltc . DOMEnhancedForDTM ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xml . serializer . OutputPropertiesFactory ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . dom . DOMWSFilter ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . dom . XSLTCDTMManager ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xalan . xsltc . runtime . output . TransletOutputHandlerFactory ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . utils . XMLReaderManager ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . LexicalHandler ; public final class TransformerImpl extends Transformer implements DOMCache , ErrorListener { private final static String EMPTY_STRING = "" ; private final static String NO_STRING = "no" ; private final static String YES_STRING = "yes" ; private final static String XML_STRING = "xml" ; private final static String LEXICAL_HANDLER_PROPERTY = "http://xml.org/sax/properties/lexical-handler" ; private static final String NAMESPACE_FEATURE = "http://xml.org/sax/features/namespaces" ; private AbstractTranslet _translet = null ; private String _method = null ; private String _encoding = null ; private String _sourceSystemId = null ; private ErrorListener _errorListener = this ; private URIResolver _uriResolver = null ; private Properties _properties , _propertiesClone ; private TransletOutputHandlerFactory _tohFactory = null ; private DOM _dom = null ; private int _indentNumber ; private TransformerFactoryImpl _tfactory = null ; private XSLTCDTMManager _dtmManager = null ; private XMLReaderManager _readerManager = XMLReaderManager . getInstance ( ) ; private boolean _isIdentity = false ; private Hashtable _parameters = null ; static class MessageHandler extends org . apache . xalan . xsltc . runtime . MessageHandler { private ErrorListener _errorListener ; public MessageHandler ( ErrorListener errorListener ) { _errorListener = errorListener ; } public void displayMessage ( String msg ) { if ( _errorListener == null ) { System . err . println ( msg ) ; } else { try { _errorListener . warning ( new TransformerException ( msg ) ) ; } catch ( TransformerException e ) { } } } } protected TransformerImpl ( Properties outputProperties , int indentNumber , TransformerFactoryImpl tfactory ) { this ( null , outputProperties , indentNumber , tfactory ) ; _isIdentity = true ; } protected TransformerImpl ( Translet translet , Properties outputProperties , int indentNumber , TransformerFactoryImpl tfactory ) { _translet = ( AbstractTranslet ) translet ; _properties = createOutputProperties ( outputProperties ) ; _propertiesClone = ( Properties ) _properties . clone ( ) ; _indentNumber = indentNumber ; _tfactory = tfactory ; } protected AbstractTranslet getTranslet ( ) { return _translet ; } public boolean isIdentity ( ) { return _isIdentity ; } public void transform ( Source source , Result result ) throws TransformerException { if ( ! _isIdentity ) { if ( _translet == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_TRANSLET_ERR ) ; throw new TransformerException ( err . toString ( ) ) ; } transferOutputProperties ( _translet ) ; } final SerializationHandler toHandler = getOutputHandler ( result ) ; if ( toHandler == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_HANDLER_ERR ) ; throw new TransformerException ( err . toString ( ) ) ; } if ( _uriResolver != null && ! _isIdentity ) { _translet . setDOMCache ( this ) ; } if ( _isIdentity ) { transferOutputProperties ( toHandler ) ; } transform ( source , toHandler , _encoding ) ; if ( result instanceof DOMResult ) { ( ( DOMResult ) result ) . setNode ( _tohFactory . getNode ( ) ) ; } } public SerializationHandler getOutputHandler ( Result result ) throws TransformerException { _method = ( String ) _properties . get ( OutputKeys . METHOD ) ; _encoding = ( String ) _properties . getProperty ( OutputKeys . ENCODING ) ; _tohFactory = TransletOutputHandlerFactory . newInstance ( ) ; _tohFactory . setEncoding ( _encoding ) ; if ( _method != null ) { _tohFactory . setOutputMethod ( _method ) ; } if ( _indentNumber >= 0 ) { _tohFactory . setIndentNumber ( _indentNumber ) ; } try { if ( result instanceof SAXResult ) { final SAXResult target = ( SAXResult ) result ; final ContentHandler handler = target . getHandler ( ) ; _tohFactory . setHandler ( handler ) ; LexicalHandler lexicalHandler = target . getLexicalHandler ( ) ; if ( lexicalHandler != null ) { _tohFactory . setLexicalHandler ( lexicalHandler ) ; } _tohFactory . setOutputType ( TransletOutputHandlerFactory . SAX ) ; return _tohFactory . getSerializationHandler ( ) ; } else if ( result instanceof DOMResult ) { _tohFactory . setNode ( ( ( DOMResult ) result ) . getNode ( ) ) ; _tohFactory . setOutputType ( TransletOutputHandlerFactory . DOM ) ; return _tohFactory . getSerializationHandler ( ) ; } else if ( result instanceof StreamResult ) { final StreamResult target = ( StreamResult ) result ; _tohFactory . setOutputType ( TransletOutputHandlerFactory . STREAM ) ; final Writer writer = target . getWriter ( ) ; if ( writer != null ) { _tohFactory . setWriter ( writer ) ; return _tohFactory . getSerializationHandler ( ) ; } final OutputStream ostream = target . getOutputStream ( ) ; if ( ostream != null ) { _tohFactory . setOutputStream ( ostream ) ; return _tohFactory . getSerializationHandler ( ) ; } String systemId = result . getSystemId ( ) ; if ( systemId == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_RESULT_ERR ) ; throw new TransformerException ( err . toString ( ) ) ; } URL url = null ; if ( systemId . startsWith ( "file:" ) ) { url = new URL ( systemId ) ; _tohFactory . setOutputStream ( new FileOutputStream ( url . getFile ( ) ) ) ; return _tohFactory . getSerializationHandler ( ) ; } else if ( systemId . startsWith ( "http:" ) ) { url = new URL ( systemId ) ; final URLConnection connection = url . openConnection ( ) ; _tohFactory . setOutputStream ( connection . getOutputStream ( ) ) ; return _tohFactory . getSerializationHandler ( ) ; } else { url = new File ( systemId ) . toURL ( ) ; _tohFactory . setOutputStream ( new FileOutputStream ( url . getFile ( ) ) ) ; return _tohFactory . getSerializationHandler ( ) ; } } } catch ( UnknownServiceException e ) { throw new TransformerException ( e ) ; } catch ( ParserConfigurationException e ) { throw new TransformerException ( e ) ; } catch ( IOException e ) { throw new TransformerException ( e ) ; } return null ; } protected void setDOM ( DOM dom ) { _dom = dom ; } private DOM getDOM ( Source source ) throws TransformerException { try { DOM dom = null ; if ( source != null ) { DTMWSFilter wsfilter ; if ( _translet != null && _translet instanceof StripFilter ) { wsfilter = new DOMWSFilter ( _translet ) ; } else { wsfilter = null ; } boolean hasIdCall = ( _translet != null ) ? _translet . hasIdCall ( ) : false ; if ( _dtmManager == null ) { _dtmManager = ( XSLTCDTMManager ) _tfactory . getDTMManagerClass ( ) . newInstance ( ) ; } dom = ( DOM ) _dtmManager . getDTM ( source , false , wsfilter , true , false , false , 0 , hasIdCall ) ; } else if ( _dom != null ) { dom = _dom ; _dom = null ; } else { return null ; } if ( ! _isIdentity ) { _translet . prepassDocument ( dom ) ; } return dom ; } catch ( Exception e ) { if ( _errorListener != null ) { postErrorToListener ( e . getMessage ( ) ) ; } throw new TransformerException ( e ) ; } } protected TransformerFactoryImpl getTransformerFactory ( ) { return _tfactory ; } private void transformIdentity ( Source source , SerializationHandler handler ) throws Exception { if ( source != null ) { _sourceSystemId = source . getSystemId ( ) ; } if ( source instanceof StreamSource ) { final StreamSource stream = ( StreamSource ) source ; final InputStream streamInput = stream . getInputStream ( ) ; final Reader streamReader = stream . getReader ( ) ; final XMLReader reader = _readerManager . getXMLReader ( ) ; try { try { reader . setProperty ( LEXICAL_HANDLER_PROPERTY , handler ) ; } catch ( SAXException e ) { } reader . setContentHandler ( handler ) ; InputSource input ; if ( streamInput != null ) { input = new InputSource ( streamInput ) ; input . setSystemId ( _sourceSystemId ) ; } else if ( streamReader != null ) { input = new InputSource ( streamReader ) ; input . setSystemId ( _sourceSystemId ) ; } else if ( _sourceSystemId != null ) { input = new InputSource ( _sourceSystemId ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_SOURCE_ERR ) ; throw new TransformerException ( err . toString ( ) ) ; } reader . parse ( input ) ; } finally { _readerManager . releaseXMLReader ( reader ) ; } } else if ( source instanceof SAXSource ) { final SAXSource sax = ( SAXSource ) source ; XMLReader reader = sax . getXMLReader ( ) ; final InputSource input = sax . getInputSource ( ) ; boolean userReader = true ; try { if ( reader == null ) { reader = _readerManager . getXMLReader ( ) ; userReader = false ; } try { reader . setProperty ( LEXICAL_HANDLER_PROPERTY , handler ) ; } catch ( SAXException e ) { } reader . setContentHandler ( handler ) ; reader . parse ( input ) ; } finally { if ( ! userReader ) { _readerManager . releaseXMLReader ( reader ) ; } } } else if ( source instanceof DOMSource ) { final DOMSource domsrc = ( DOMSource ) source ; new DOM2TO ( domsrc . getNode ( ) , handler ) . parse ( ) ; } else if ( source instanceof XSLTCSource ) { final DOM dom = ( ( XSLTCSource ) source ) . getDOM ( null , _translet ) ; ( ( SAXImpl ) dom ) . copy ( handler ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_SOURCE_ERR ) ; throw new TransformerException ( err . toString ( ) ) ; } } private void transform ( Source source , SerializationHandler handler , String encoding ) throws TransformerException { try { if ( ( source instanceof StreamSource && source . getSystemId ( ) == null && ( ( StreamSource ) source ) . getInputStream ( ) == null && ( ( StreamSource ) source ) . getReader ( ) == null ) || ( source instanceof SAXSource && ( ( SAXSource ) source ) . getInputSource ( ) == null && ( ( SAXSource ) source ) . getXMLReader ( ) == null ) || ( source instanceof DOMSource && ( ( DOMSource ) source ) . getNode ( ) == null ) ) { DocumentBuilderFactory builderF = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = builderF . newDocumentBuilder ( ) ; String systemID = source . getSystemId ( ) ; source = new DOMSource ( builder . newDocument ( ) ) ; if ( systemID != null ) { source . setSystemId ( systemID ) ; } } if ( _isIdentity ) { transformIdentity ( source , handler ) ; } else { _translet . transform ( getDOM ( source ) , handler ) ; } } catch ( TransletException e ) { if ( _errorListener != null ) postErrorToListener ( e . getMessage ( ) ) ; throw new TransformerException ( e ) ; } catch ( RuntimeException e ) { if ( _errorListener != null ) postErrorToListener ( e . getMessage ( ) ) ; throw new TransformerException ( e ) ; } catch ( Exception e ) { if ( _errorListener != null ) postErrorToListener ( e . getMessage ( ) ) ; throw new TransformerException ( e ) ; } finally { _dtmManager = null ; } } public ErrorListener getErrorListener ( ) { return _errorListener ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( listener == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ERROR_LISTENER_NULL_ERR , "Transformer" ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } _errorListener = listener ; if ( _translet != null ) _translet . setMessageHandler ( new MessageHandler ( _errorListener ) ) ; } private void postErrorToListener ( String message ) { try { _errorListener . error ( new TransformerException ( message ) ) ; } catch ( TransformerException e ) { } } private void postWarningToListener ( String message ) { try { _errorListener . warning ( new TransformerException ( message ) ) ; } catch ( TransformerException e ) { } } private String makeCDATAString ( Hashtable cdata ) { if ( cdata == null ) return null ; StringBuffer result = new StringBuffer ( ) ; Enumeration elements = cdata . keys ( ) ; if ( elements . hasMoreElements ( ) ) { result . append ( ( String ) elements . nextElement ( ) ) ; while ( elements . hasMoreElements ( ) ) { String element = ( String ) elements . nextElement ( ) ; result . append ( ' ' ) ; result . append ( element ) ; } } return ( result . toString ( ) ) ; } public Properties getOutputProperties ( ) { return ( Properties ) _properties . clone ( ) ; } public String getOutputProperty ( String name ) throws IllegalArgumentException { if ( ! validOutputProperty ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_UNKNOWN_PROP_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } return _properties . getProperty ( name ) ; } public void setOutputProperties ( Properties properties ) throws IllegalArgumentException { if ( properties != null ) { final Enumeration names = properties . propertyNames ( ) ; while ( names . hasMoreElements ( ) ) { final String name = ( String ) names . nextElement ( ) ; if ( isDefaultProperty ( name , properties ) ) continue ; if ( validOutputProperty ( name ) ) { _properties . setProperty ( name , properties . getProperty ( name ) ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_UNKNOWN_PROP_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } } } else { _properties = _propertiesClone ; } } public void setOutputProperty ( String name , String value ) throws IllegalArgumentException { if ( ! validOutputProperty ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_UNKNOWN_PROP_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } _properties . setProperty ( name , value ) ; } private void transferOutputProperties ( AbstractTranslet translet ) { if ( _properties == null ) return ; Enumeration names = _properties . propertyNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; String value = ( String ) _properties . get ( name ) ; if ( value == null ) continue ; if ( name . equals ( OutputKeys . ENCODING ) ) { translet . _encoding = value ; } else if ( name . equals ( OutputKeys . METHOD ) ) { translet . _method = value ; } else if ( name . equals ( OutputKeys . DOCTYPE_PUBLIC ) ) { translet . _doctypePublic = value ; } else if ( name . equals ( OutputKeys . DOCTYPE_SYSTEM ) ) { translet . _doctypeSystem = value ; } else if ( name . equals ( OutputKeys . MEDIA_TYPE ) ) { translet . _mediaType = value ; } else if ( name . equals ( OutputKeys . STANDALONE ) ) { translet . _standalone = value ; } else if ( name . equals ( OutputKeys . VERSION ) ) { translet . _version = value ; } else if ( name . equals ( OutputKeys . OMIT_XML_DECLARATION ) ) { translet . _omitHeader = ( value != null && value . toLowerCase ( ) . equals ( "yes" ) ) ; } else if ( name . equals ( OutputKeys . INDENT ) ) { translet . _indent = ( value != null && value . toLowerCase ( ) . equals ( "yes" ) ) ; } else if ( name . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) ) { if ( value != null ) { translet . _cdata = null ; StringTokenizer e = new StringTokenizer ( value ) ; while ( e . hasMoreTokens ( ) ) { translet . addCdataElement ( e . nextToken ( ) ) ; } } } } } public void transferOutputProperties ( SerializationHandler handler ) { if ( _properties == null ) return ; String doctypePublic = null ; String doctypeSystem = null ; Enumeration names = _properties . propertyNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; String value = ( String ) _properties . get ( name ) ; if ( value == null ) continue ; if ( name . equals ( OutputKeys . DOCTYPE_PUBLIC ) ) { doctypePublic = value ; } else if ( name . equals ( OutputKeys . DOCTYPE_SYSTEM ) ) { doctypeSystem = value ; } else if ( name . equals ( OutputKeys . MEDIA_TYPE ) ) { handler . setMediaType ( value ) ; } else if ( name . equals ( OutputKeys . STANDALONE ) ) { handler . setStandalone ( value ) ; } else if ( name . equals ( OutputKeys . VERSION ) ) { handler . setVersion ( value ) ; } else if ( name . equals ( OutputKeys . OMIT_XML_DECLARATION ) ) { handler . setOmitXMLDeclaration ( value != null && value . toLowerCase ( ) . equals ( "yes" ) ) ; } else if ( name . equals ( OutputKeys . INDENT ) ) { handler . setIndent ( value != null && value . toLowerCase ( ) . equals ( "yes" ) ) ; } else if ( name . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) ) { if ( value != null ) { StringTokenizer e = new StringTokenizer ( value ) ; Vector uriAndLocalNames = null ; while ( e . hasMoreTokens ( ) ) { final String token = e . nextToken ( ) ; int lastcolon = token . lastIndexOf ( ':' ) ; String uri ; String localName ; if ( lastcolon > 0 ) { uri = token . substring ( 0 , lastcolon ) ; localName = token . substring ( lastcolon + 1 ) ; } else { uri = null ; localName = token ; } if ( uriAndLocalNames == null ) { uriAndLocalNames = new Vector ( ) ; } uriAndLocalNames . addElement ( uri ) ; uriAndLocalNames . addElement ( localName ) ; } handler . setCdataSectionElements ( uriAndLocalNames ) ; } } } if ( doctypePublic != null || doctypeSystem != null ) { handler . setDoctype ( doctypeSystem , doctypePublic ) ; } } private Properties createOutputProperties ( Properties outputProperties ) { final Properties defaults = new Properties ( ) ; setDefaults ( defaults , "xml" ) ; final Properties base = new Properties ( defaults ) ; if ( outputProperties != null ) { final Enumeration names = outputProperties . propertyNames ( ) ; while ( names . hasMoreElements ( ) ) { final String name = ( String ) names . nextElement ( ) ; base . setProperty ( name , outputProperties . getProperty ( name ) ) ; } } else { base . setProperty ( OutputKeys . ENCODING , _translet . _encoding ) ; if ( _translet . _method != null ) base . setProperty ( OutputKeys . METHOD , _translet . _method ) ; } final String method = base . getProperty ( OutputKeys . METHOD ) ; if ( method != null ) { if ( method . equals ( "html" ) ) { setDefaults ( defaults , "html" ) ; } else if ( method . equals ( "text" ) ) { setDefaults ( defaults , "text" ) ; } } return base ; } private void setDefaults ( Properties props , String method ) { final Properties method_props = OutputPropertiesFactory . getDefaultMethodProperties ( method ) ; { final Enumeration names = method_props . propertyNames ( ) ; while ( names . hasMoreElements ( ) ) { final String name = ( String ) names . nextElement ( ) ; props . setProperty ( name , method_props . getProperty ( name ) ) ; } } } private boolean validOutputProperty ( String name ) { return ( name . equals ( OutputKeys . ENCODING ) || name . equals ( OutputKeys . METHOD ) || name . equals ( OutputKeys . INDENT ) || name . equals ( OutputKeys . DOCTYPE_PUBLIC ) || name . equals ( OutputKeys . DOCTYPE_SYSTEM ) || name . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) || name . equals ( OutputKeys . MEDIA_TYPE ) || name . equals ( OutputKeys . OMIT_XML_DECLARATION ) || name . equals ( OutputKeys . STANDALONE ) || name . equals ( OutputKeys . VERSION ) || name . charAt ( 0 ) == '{' ) ; } private boolean isDefaultProperty ( String name , Properties properties ) { return ( properties . get ( name ) == null ) ; } public void setParameter ( String name , Object value ) { if ( value == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_INVALID_SET_PARAM_VALUE , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } if ( _isIdentity ) { if ( _parameters == null ) { _parameters = new Hashtable ( ) ; } _parameters . put ( name , value ) ; } else { _translet . addParameter ( name , value ) ; } } public void clearParameters ( ) { if ( _isIdentity && _parameters != null ) { _parameters . clear ( ) ; } else { _translet . clearParameters ( ) ; } } public final Object getParameter ( String name ) { if ( _isIdentity ) { return ( _parameters != null ) ? _parameters . get ( name ) : null ; } else { return _translet . getParameter ( name ) ; } } public URIResolver getURIResolver ( ) { return _uriResolver ; } public void setURIResolver ( URIResolver resolver ) { _uriResolver = resolver ; } public DOM retrieveDocument ( String baseURI , String href , Translet translet ) { try { if ( href . length ( ) == 0 ) { href = new String ( baseURI ) ; } Source resolvedSource = _uriResolver . resolve ( href , baseURI ) ; if ( resolvedSource == null ) { StreamSource streamSource = new StreamSource ( SystemIDResolver . getAbsoluteURI ( href , baseURI ) ) ; return getDOM ( streamSource ) ; } return getDOM ( resolvedSource ) ; } catch ( TransformerException e ) { if ( _errorListener != null ) postErrorToListener ( "File not found: " + e . getMessage ( ) ) ; return ( null ) ; } } public void error ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . ERROR_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . ERROR_MSG , e . getMessageAndLocation ( ) ) ) ; } throw e ; } public void fatalError ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . FATAL_ERR_MSG , e . getMessageAndLocation ( ) ) ) ; } throw e ; } public void warning ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . WARNING_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . WARNING_MSG , e . getMessageAndLocation ( ) ) ) ; } } } 	1	['35', '2', '0', '26', '164', '329', '4', '23', '19', '0.897058824', '1673', '1', '7', '0.282608696', '0.135714286', '0', '0', '46.17142857', '20', '2.8286', '2']
package org . apache . xpath . operations ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XObject ; public abstract class UnaryOperation extends Expression implements ExpressionOwner { protected Expression m_right ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_right . fixupVariables ( vars , globalsSize ) ; } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_right && m_right . canTraverseOutsideSubtree ( ) ) return true ; return false ; } public void setRight ( Expression r ) { m_right = r ; r . exprSetParent ( this ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return operate ( m_right . execute ( xctxt ) ) ; } public abstract XObject operate ( XObject right ) throws javax . xml . transform . TransformerException ; public Expression getOperand ( ) { return m_right ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitUnaryOperation ( owner , this ) ) { m_right . callVisitors ( this , visitor ) ; } } public Expression getExpression ( ) { return m_right ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_right = exp ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! m_right . deepEquals ( ( ( UnaryOperation ) expr ) . m_right ) ) return false ; return true ; } } 	1	['11', '2', '4', '11', '20', '0', '6', '6', '11', '0.2', '88', '1', '1', '0.75', '0.227272727', '1', '7', '6.909090909', '3', '1.3636', '1']
package org . apache . xpath . patterns ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . compiler . PsuedoNames ; import org . apache . xpath . objects . XObject ; public class StepPattern extends NodeTest implements SubContextList , ExpressionOwner { protected int m_axis ; public StepPattern ( int whatToShow , String namespace , String name , int axis , int axisForPredicate ) { super ( whatToShow , namespace , name ) ; m_axis = axis ; } public StepPattern ( int whatToShow , int axis , int axisForPredicate ) { super ( whatToShow ) ; m_axis = axis ; } String m_targetString ; public void calcTargetString ( ) { int whatToShow = getWhatToShow ( ) ; switch ( whatToShow ) { case DTMFilter . SHOW_COMMENT : m_targetString = PsuedoNames . PSEUDONAME_COMMENT ; break ; case DTMFilter . SHOW_TEXT : case DTMFilter . SHOW_CDATA_SECTION : case ( DTMFilter . SHOW_TEXT | DTMFilter . SHOW_CDATA_SECTION ) : m_targetString = PsuedoNames . PSEUDONAME_TEXT ; break ; case DTMFilter . SHOW_ALL : m_targetString = PsuedoNames . PSEUDONAME_ANY ; break ; case DTMFilter . SHOW_DOCUMENT : case DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT : m_targetString = PsuedoNames . PSEUDONAME_ROOT ; break ; case DTMFilter . SHOW_ELEMENT : if ( this . WILD == m_name ) m_targetString = PsuedoNames . PSEUDONAME_ANY ; else m_targetString = m_name ; break ; default : m_targetString = PsuedoNames . PSEUDONAME_ANY ; break ; } } public String getTargetString ( ) { return m_targetString ; } StepPattern m_relativePathPattern ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_predicates ) { for ( int i = 0 ; i < m_predicates . length ; i ++ ) { m_predicates [ i ] . fixupVariables ( vars , globalsSize ) ; } } if ( null != m_relativePathPattern ) { m_relativePathPattern . fixupVariables ( vars , globalsSize ) ; } } public void setRelativePathPattern ( StepPattern expr ) { m_relativePathPattern = expr ; expr . exprSetParent ( this ) ; calcScore ( ) ; } public StepPattern getRelativePathPattern ( ) { return m_relativePathPattern ; } public Expression [ ] getPredicates ( ) { return m_predicates ; } Expression [ ] m_predicates ; public boolean canTraverseOutsideSubtree ( ) { int n = getPredicateCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( getPredicate ( i ) . canTraverseOutsideSubtree ( ) ) return true ; } return false ; } public Expression getPredicate ( int i ) { return m_predicates [ i ] ; } public final int getPredicateCount ( ) { return ( null == m_predicates ) ? 0 : m_predicates . length ; } public void setPredicates ( Expression [ ] predicates ) { m_predicates = predicates ; if ( null != predicates ) { for ( int i = 0 ; i < predicates . length ; i ++ ) { predicates [ i ] . exprSetParent ( this ) ; } } calcScore ( ) ; } public void calcScore ( ) { if ( ( getPredicateCount ( ) > 0 ) || ( null != m_relativePathPattern ) ) { m_score = SCORE_OTHER ; } else super . calcScore ( ) ; if ( null == m_targetString ) calcTargetString ( ) ; } public XObject execute ( XPathContext xctxt , int currentNode ) throws javax . xml . transform . TransformerException { DTM dtm = xctxt . getDTM ( currentNode ) ; if ( dtm != null ) { int expType = dtm . getExpandedTypeID ( currentNode ) ; return execute ( xctxt , currentNode , dtm , expType ) ; } return NodeTest . SCORE_NONE ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt , xctxt . getCurrentNode ( ) ) ; } public XObject execute ( XPathContext xctxt , int currentNode , DTM dtm , int expType ) throws javax . xml . transform . TransformerException { if ( m_whatToShow == NodeTest . SHOW_BYFUNCTION ) { if ( null != m_relativePathPattern ) { return m_relativePathPattern . execute ( xctxt ) ; } else return NodeTest . SCORE_NONE ; } XObject score ; score = super . execute ( xctxt , currentNode , dtm , expType ) ; if ( score == NodeTest . SCORE_NONE ) return NodeTest . SCORE_NONE ; if ( getPredicateCount ( ) != 0 ) { if ( ! executePredicates ( xctxt , dtm , currentNode ) ) return NodeTest . SCORE_NONE ; } if ( null != m_relativePathPattern ) return m_relativePathPattern . executeRelativePathPattern ( xctxt , dtm , currentNode ) ; return score ; } private final boolean checkProximityPosition ( XPathContext xctxt , int predPos , DTM dtm , int context , int pos ) { try { DTMAxisTraverser traverser = dtm . getAxisTraverser ( Axis . PRECEDINGSIBLING ) ; for ( int child = traverser . first ( context ) ; DTM . NULL != child ; child = traverser . next ( context , child ) ) { try { xctxt . pushCurrentNode ( child ) ; if ( NodeTest . SCORE_NONE != super . execute ( xctxt , child ) ) { boolean pass = true ; try { xctxt . pushSubContextList ( this ) ; for ( int i = 0 ; i < predPos ; i ++ ) { xctxt . pushPredicatePos ( i ) ; try { XObject pred = m_predicates [ i ] . execute ( xctxt ) ; try { if ( XObject . CLASS_NUMBER == pred . getType ( ) ) { throw new Error ( "Why: Should never have been called" ) ; } else if ( ! pred . boolWithSideEffects ( ) ) { pass = false ; break ; } } finally { pred . detach ( ) ; } } finally { xctxt . popPredicatePos ( ) ; } } } finally { xctxt . popSubContextList ( ) ; } if ( pass ) pos -- ; if ( pos < 1 ) return false ; } } finally { xctxt . popCurrentNode ( ) ; } } } catch ( javax . xml . transform . TransformerException se ) { throw new java . lang . RuntimeException ( se . getMessage ( ) ) ; } return ( pos == 1 ) ; } private final int getProximityPosition ( XPathContext xctxt , int predPos , boolean findLast ) { int pos = 0 ; int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int parent = dtm . getParent ( context ) ; try { DTMAxisTraverser traverser = dtm . getAxisTraverser ( Axis . CHILD ) ; for ( int child = traverser . first ( parent ) ; DTM . NULL != child ; child = traverser . next ( parent , child ) ) { try { xctxt . pushCurrentNode ( child ) ; if ( NodeTest . SCORE_NONE != super . execute ( xctxt , child ) ) { boolean pass = true ; try { xctxt . pushSubContextList ( this ) ; for ( int i = 0 ; i < predPos ; i ++ ) { xctxt . pushPredicatePos ( i ) ; try { XObject pred = m_predicates [ i ] . execute ( xctxt ) ; try { if ( XObject . CLASS_NUMBER == pred . getType ( ) ) { if ( ( pos + 1 ) != ( int ) pred . numWithSideEffects ( ) ) { pass = false ; break ; } } else if ( ! pred . boolWithSideEffects ( ) ) { pass = false ; break ; } } finally { pred . detach ( ) ; } } finally { xctxt . popPredicatePos ( ) ; } } } finally { xctxt . popSubContextList ( ) ; } if ( pass ) pos ++ ; if ( ! findLast && child == context ) { return pos ; } } } finally { xctxt . popCurrentNode ( ) ; } } } catch ( javax . xml . transform . TransformerException se ) { throw new java . lang . RuntimeException ( se . getMessage ( ) ) ; } return pos ; } public int getProximityPosition ( XPathContext xctxt ) { return getProximityPosition ( xctxt , xctxt . getPredicatePos ( ) , false ) ; } public int getLastPos ( XPathContext xctxt ) { return getProximityPosition ( xctxt , xctxt . getPredicatePos ( ) , true ) ; } protected final XObject executeRelativePathPattern ( XPathContext xctxt , DTM dtm , int currentNode ) throws javax . xml . transform . TransformerException { XObject score = NodeTest . SCORE_NONE ; int context = currentNode ; DTMAxisTraverser traverser ; traverser = dtm . getAxisTraverser ( m_axis ) ; for ( int relative = traverser . first ( context ) ; DTM . NULL != relative ; relative = traverser . next ( context , relative ) ) { try { xctxt . pushCurrentNode ( relative ) ; score = execute ( xctxt ) ; if ( score != NodeTest . SCORE_NONE ) break ; } finally { xctxt . popCurrentNode ( ) ; } } return score ; } protected final boolean executePredicates ( XPathContext xctxt , DTM dtm , int currentNode ) throws javax . xml . transform . TransformerException { boolean result = true ; boolean positionAlreadySeen = false ; int n = getPredicateCount ( ) ; try { xctxt . pushSubContextList ( this ) ; for ( int i = 0 ; i < n ; i ++ ) { xctxt . pushPredicatePos ( i ) ; try { XObject pred = m_predicates [ i ] . execute ( xctxt ) ; try { if ( XObject . CLASS_NUMBER == pred . getType ( ) ) { int pos = ( int ) pred . num ( ) ; if ( positionAlreadySeen ) { result = ( pos == 1 ) ; break ; } else { positionAlreadySeen = true ; if ( ! checkProximityPosition ( xctxt , i , dtm , currentNode , pos ) ) { result = false ; break ; } } } else if ( ! pred . boolWithSideEffects ( ) ) { result = false ; break ; } } finally { pred . detach ( ) ; } } finally { xctxt . popPredicatePos ( ) ; } } } finally { xctxt . popSubContextList ( ) ; } return result ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( StepPattern pat = this ; pat != null ; pat = pat . m_relativePathPattern ) { if ( pat != this ) buf . append ( "/" ) ; buf . append ( Axis . names [ pat . m_axis ] ) ; buf . append ( "::" ) ; if ( 0x000005000 == pat . m_whatToShow ) { buf . append ( "doc()" ) ; } else if ( DTMFilter . SHOW_BYFUNCTION == pat . m_whatToShow ) { buf . append ( "function()" ) ; } else if ( DTMFilter . SHOW_ALL == pat . m_whatToShow ) { buf . append ( "node()" ) ; } else if ( DTMFilter . SHOW_TEXT == pat . m_whatToShow ) { buf . append ( "text()" ) ; } else if ( DTMFilter . SHOW_PROCESSING_INSTRUCTION == pat . m_whatToShow ) { buf . append ( "processing-instruction(" ) ; if ( null != pat . m_name ) { buf . append ( pat . m_name ) ; } buf . append ( ")" ) ; } else if ( DTMFilter . SHOW_COMMENT == pat . m_whatToShow ) { buf . append ( "comment()" ) ; } else if ( null != pat . m_name ) { if ( DTMFilter . SHOW_ATTRIBUTE == pat . m_whatToShow ) { buf . append ( "@" ) ; } if ( null != pat . m_namespace ) { buf . append ( "{" ) ; buf . append ( pat . m_namespace ) ; buf . append ( "}" ) ; } buf . append ( pat . m_name ) ; } else if ( DTMFilter . SHOW_ATTRIBUTE == pat . m_whatToShow ) { buf . append ( "@" ) ; } else if ( ( DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT ) == pat . m_whatToShow ) { buf . append ( "doc-root()" ) ; } else { buf . append ( "?" + Integer . toHexString ( pat . m_whatToShow ) ) ; } if ( null != pat . m_predicates ) { for ( int i = 0 ; i < pat . m_predicates . length ; i ++ ) { buf . append ( "[" ) ; buf . append ( pat . m_predicates [ i ] ) ; buf . append ( "]" ) ; } } } return buf . toString ( ) ; } private static final boolean DEBUG_MATCHES = false ; public double getMatchScore ( XPathContext xctxt , int context ) throws javax . xml . transform . TransformerException { xctxt . pushCurrentNode ( context ) ; xctxt . pushCurrentExpressionNode ( context ) ; try { XObject score = execute ( xctxt ) ; return score . num ( ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . popCurrentExpressionNode ( ) ; } } public void setAxis ( int axis ) { m_axis = axis ; } public int getAxis ( ) { return m_axis ; } class PredOwner implements ExpressionOwner { int m_index ; PredOwner ( int index ) { m_index = index ; } public Expression getExpression ( ) { return m_predicates [ m_index ] ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( StepPattern . this ) ; m_predicates [ m_index ] = exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitMatchPattern ( owner , this ) ) { callSubtreeVisitors ( visitor ) ; } } protected void callSubtreeVisitors ( XPathVisitor visitor ) { if ( null != m_predicates ) { int n = m_predicates . length ; for ( int i = 0 ; i < n ; i ++ ) { ExpressionOwner predOwner = new PredOwner ( i ) ; if ( visitor . visitPredicate ( predOwner , m_predicates [ i ] ) ) { m_predicates [ i ] . callVisitors ( predOwner , visitor ) ; } } } if ( null != m_relativePathPattern ) { m_relativePathPattern . callVisitors ( this , visitor ) ; } } public Expression getExpression ( ) { return m_relativePathPattern ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_relativePathPattern = ( StepPattern ) exp ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; StepPattern sp = ( StepPattern ) expr ; if ( null != m_predicates ) { int n = m_predicates . length ; if ( ( null == sp . m_predicates ) || ( sp . m_predicates . length != n ) ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m_predicates [ i ] . deepEquals ( sp . m_predicates [ i ] ) ) return false ; } } else if ( null != sp . m_predicates ) return false ; if ( null != m_relativePathPattern ) { if ( ! m_relativePathPattern . deepEquals ( sp . m_relativePathPattern ) ) return false ; } else if ( sp . m_relativePathPattern != null ) return false ; return true ; } } 	1	['31', '3', '2', '23', '81', '239', '12', '13', '26', '0.733333333', '1095', '0.4', '2', '0.641975309', '0.180107527', '2', '9', '34.16129032', '17', '3.0645', '2']
package org . apache . xpath . objects ; import java . io . Serializable ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathException ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class XObject extends Expression implements Serializable , Cloneable { protected Object m_obj ; public XObject ( ) { } public XObject ( Object obj ) { m_obj = obj ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return this ; } public void allowDetachToRelease ( boolean allowRelease ) { } public void detach ( ) { } public void destruct ( ) { if ( null != m_obj ) { allowDetachToRelease ( true ) ; detach ( ) ; m_obj = null ; } } public void reset ( ) { } public void dispatchCharactersEvents ( org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { xstr ( ) . dispatchCharactersEvents ( ch ) ; } static public XObject create ( Object val ) { return XObjectFactory . create ( val ) ; } static public XObject create ( Object val , XPathContext xctxt ) { return XObjectFactory . create ( val , xctxt ) ; } public static final int CLASS_NULL = - 1 ; public static final int CLASS_UNKNOWN = 0 ; public static final int CLASS_BOOLEAN = 1 ; public static final int CLASS_NUMBER = 2 ; public static final int CLASS_STRING = 3 ; public static final int CLASS_NODESET = 4 ; public static final int CLASS_RTREEFRAG = 5 ; public static final int CLASS_UNRESOLVEDVARIABLE = 600 ; public int getType ( ) { return CLASS_UNKNOWN ; } public String getTypeString ( ) { return "#UNKNOWN (" + object ( ) . getClass ( ) . getName ( ) + ")" ; } public double num ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_NUMBER , new Object [ ] { getTypeString ( ) } ) ; return 0.0 ; } public double numWithSideEffects ( ) throws javax . xml . transform . TransformerException { return num ( ) ; } public boolean bool ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_NUMBER , new Object [ ] { getTypeString ( ) } ) ; return false ; } public boolean boolWithSideEffects ( ) throws javax . xml . transform . TransformerException { return bool ( ) ; } public XMLString xstr ( ) { return XMLStringFactoryImpl . getFactory ( ) . newstr ( str ( ) ) ; } public String str ( ) { return ( m_obj != null ) ? m_obj . toString ( ) : "" ; } public String toString ( ) { return str ( ) ; } public int rtf ( XPathContext support ) { int result = rtf ( ) ; if ( DTM . NULL == result ) { DTM frag = support . createDocumentFragment ( ) ; frag . appendTextChild ( str ( ) ) ; result = frag . getDocument ( ) ; } return result ; } public DocumentFragment rtree ( XPathContext support ) { DocumentFragment docFrag = null ; int result = rtf ( ) ; if ( DTM . NULL == result ) { DTM frag = support . createDocumentFragment ( ) ; frag . appendTextChild ( str ( ) ) ; docFrag = ( DocumentFragment ) frag . getNode ( frag . getDocument ( ) ) ; } else { DTM frag = support . getDTM ( result ) ; docFrag = ( DocumentFragment ) frag . getNode ( frag . getDocument ( ) ) ; } return docFrag ; } public DocumentFragment rtree ( ) { return null ; } public int rtf ( ) { return DTM . NULL ; } public Object object ( ) { return m_obj ; } public DTMIterator iter ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_NODELIST , new Object [ ] { getTypeString ( ) } ) ; return null ; } public XObject getFresh ( ) { return this ; } public NodeIterator nodeset ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_NODELIST , new Object [ ] { getTypeString ( ) } ) ; return null ; } public NodeList nodelist ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_NODELIST , new Object [ ] { getTypeString ( ) } ) ; return null ; } public NodeSetDTM mutableNodeset ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_MUTABLENODELIST , new Object [ ] { getTypeString ( ) } ) ; return ( NodeSetDTM ) m_obj ; } public Object castToType ( int t , XPathContext support ) throws javax . xml . transform . TransformerException { Object result ; switch ( t ) { case CLASS_STRING : result = str ( ) ; break ; case CLASS_NUMBER : result = new Double ( num ( ) ) ; break ; case CLASS_NODESET : result = iter ( ) ; break ; case CLASS_BOOLEAN : result = new Boolean ( bool ( ) ) ; break ; case CLASS_UNKNOWN : result = m_obj ; break ; default : error ( XPATHErrorResources . ER_CANT_CONVERT_TO_TYPE , new Object [ ] { getTypeString ( ) , Integer . toString ( t ) } ) ; result = null ; } return result ; } public boolean lessThan ( XObject obj2 ) throws javax . xml . transform . TransformerException { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . greaterThan ( this ) ; return this . num ( ) < obj2 . num ( ) ; } public boolean lessThanOrEqual ( XObject obj2 ) throws javax . xml . transform . TransformerException { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . greaterThanOrEqual ( this ) ; return this . num ( ) <= obj2 . num ( ) ; } public boolean greaterThan ( XObject obj2 ) throws javax . xml . transform . TransformerException { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . lessThan ( this ) ; return this . num ( ) > obj2 . num ( ) ; } public boolean greaterThanOrEqual ( XObject obj2 ) throws javax . xml . transform . TransformerException { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . lessThanOrEqual ( this ) ; return this . num ( ) >= obj2 . num ( ) ; } public boolean equals ( XObject obj2 ) { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . equals ( this ) ; if ( null != m_obj ) { return m_obj . equals ( obj2 . m_obj ) ; } else { return obj2 . m_obj == null ; } } public boolean notEquals ( XObject obj2 ) throws javax . xml . transform . TransformerException { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . notEquals ( this ) ; return ! equals ( obj2 ) ; } protected void error ( String msg ) throws javax . xml . transform . TransformerException { error ( msg , null ) ; } protected void error ( String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; { throw new XPathException ( fmsg , this ) ; } } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { fsb . append ( str ( ) ) ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { assertion ( false , "callVisitors should not be called for this object!!!" ) ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! this . equals ( ( XObject ) expr ) ) return false ; return true ; } } 	1	['42', '2', '7', '143', '68', '819', '130', '15', '40', '0.953929539', '465', '0.111111111', '0', '0.428571429', '0.112244898', '2', '8', '9.857142857', '4', '1.1667', '1']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . Type ; public final class NamedMethodGenerator extends MethodGenerator { protected static int CURRENT_INDEX = 4 ; private static final int PARAM_START_INDEX = 5 ; public NamedMethodGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; } public int getLocalIndex ( String name ) { if ( name . equals ( "current" ) ) { return CURRENT_INDEX ; } return super . getLocalIndex ( name ) ; } public Instruction loadParameter ( int index ) { return new ALOAD ( index + PARAM_START_INDEX ) ; } public Instruction storeParameter ( int index ) { return new ASTORE ( index + PARAM_START_INDEX ) ; } } 	1	['5', '5', '0', '9', '10', '8', '2', '7', '4', '1', '45', '1', '0', '0.978723404', '0.4375', '2', '3', '7.6', '2', '0.8', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_zh_CN extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "错误：表达式中不能有“{”" } , { ER_ILLEGAL_ATTRIBUTE , "{0} 有一个非法属性：{1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode 在 xsl:apply-imports 中为空！" } , { ER_CANNOT_ADD , "无法将 {0} 添加到 {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode 在 handleApplyTemplatesInstruction 中为空！" } , { ER_NO_NAME_ATTRIB , "{0} 必须有 name 属性。" } , { ER_TEMPLATE_NOT_FOUND , "找不到以下名称的模板：{0}" } , { ER_CANT_RESOLVE_NAME_AVT , "无法解析 xsl:call-template 中的名称 AVT。" } , { ER_REQUIRES_ATTRIB , "{0} 需要属性：{1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} 必须有“test”属性。" } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "级别属性 {0} 上的值错误" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "processing-instruction 名称不能是“xml”" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "processing-instruction 名称必须是有效的 NCName：{0}" } , { ER_NEED_MATCH_ATTRIB , "{0} 如果有某种方式，就必须有 match 属性。" } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} 需要 name 属性或 match 属性。" } , { ER_CANT_RESOLVE_NSPREFIX , "无法解析名称空间前缀：{0}" } , { ER_ILLEGAL_VALUE , "xml:space 有非法的值：{0}" } , { ER_NO_OWNERDOC , "子节点没有所有者文档！" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement 错误：{0}" } , { ER_NULL_CHILD , "正在尝试添加空的子代！" } , { ER_NEED_SELECT_ATTRIB , "{0} 需要 select 属性。" } , { ER_NEED_TEST_ATTRIB , "xsl:when 必须有“test”属性。" } , { ER_NEED_NAME_ATTRIB , "xsl:with-param 必须有“name”属性。" } , { ER_NO_CONTEXT_OWNERDOC , "上下文没有所有者文档！" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "无法创建 XML TransformerFactory 联系：{0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: Process 不成功。" } , { ER_NOT_SUCCESSFUL , "Xalan: 不成功。" } , { ER_ENCODING_NOT_SUPPORTED , "不支持编码：{0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "无法创建 TraceListener：{0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key 需要“name”属性！" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key 需要“match”属性！" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key 需要“use”属性！" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "（StylesheetHandler）{0} 需要“elements”属性！" } , { ER_MISSING_PREFIX_ATTRIB , "（StylesheetHandler）{0} 属性“prefix”丢失" } , { ER_BAD_STYLESHEET_URL , "样式表 URL 错误：{0}" } , { ER_FILE_NOT_FOUND , "找不到样式表文件：{0}" } , { ER_IOEXCEPTION , "样式表文件发生 IO 异常：{0}" } , { ER_NO_HREF_ATTRIB , "（StylesheetHandler）无法为 {0} 找到 href 属性" } , { ER_STYLESHEET_INCLUDES_ITSELF , "（StylesheetHandler）{0} 正在直接或间接地包含它自身！" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude 错误，{0}" } , { ER_MISSING_LANG_ATTRIB , "（StylesheetHandler）{0} 属性“lang”丢失" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "（StylesheetHandler）{0} 元素错放？缺少容器元素“component”" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "只能输出到 Element、DocumentFragment、Document 或 PrintWriter。" } , { ER_PROCESS_ERROR , "StylesheetRoot.process 错误" } , { ER_UNIMPLNODE_ERROR , "UnImplNode 错误：{0}" } , { ER_NO_SELECT_EXPRESSION , "错误！找不到 xpath 选择表达式（-select）。" } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "无法序列化 XSLProcessor！" } , { ER_NO_INPUT_STYLESHEET , "没有指定样式表输入！" } , { ER_FAILED_PROCESS_STYLESHEET , "无法处理样式表！" } , { ER_COULDNT_PARSE_DOC , "无法分析 {0} 文档！" } , { ER_COULDNT_FIND_FRAGMENT , "找不到片段：{0}" } , { ER_NODE_NOT_ELEMENT , "片段标识指向的节点不是元素：{0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each 必须有 match 属性或 name 属性" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "templates 必须有 match 属性或 name 属性" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "无文档片段的克隆！" } , { ER_CANT_CREATE_ITEM , "无法在结果树中创建项：{0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "源 XML 中的 xml:space 有非法值：{0}" } , { ER_NO_XSLKEY_DECLARATION , "没有 {0} 的 xsl:key 说明！" } , { ER_CANT_CREATE_URL , "错误！无法为 {0} 创建 URL" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "不支持 xsl:functions" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory 错误" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "（StylesheetHandler）样式表内不允许 {0}！" } , { ER_RESULTNS_NOT_SUPPORTED , "不再支持 result-ns！请改为使用 xsl:output。" } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "不再支持 default-space！请改为使用 xsl:strip-space 或 xsl:preserve-space。" } , { ER_INDENTRESULT_NOT_SUPPORTED , "不再支持 indent-result！请改为使用 xsl:output。" } , { ER_ILLEGAL_ATTRIB , "（StylesheetHandler）{0} 有非法属性：{1}" } , { ER_UNKNOWN_XSL_ELEM , "未知 XSL 元素：{0}" } , { ER_BAD_XSLSORT_USE , "（StylesheetHandler）xsl:sort 只能与 xsl:apply-templates 或 xsl:for-each 一起使用。" } , { ER_MISPLACED_XSLWHEN , "（StylesheetHandler）错放了 xsl:when！" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "（StylesheetHandler）xsl:choose 不是 xsl:when 的父代！" } , { ER_MISPLACED_XSLOTHERWISE , "（StylesheetHandler）错放了 xsl:otherwise！" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "（StylesheetHandler）xsl:choose 不是 xsl:otherwise 的父代！" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "（StylesheetHandler）模板内不允许 {0}！" } , { ER_UNKNOWN_EXT_NS_PREFIX , "（StylesheetHandler）{0} 扩展名称空间前缀 {1} 未知" } , { ER_IMPORTS_AS_FIRST_ELEM , "（StylesheetHandler）导入只能作为样式表中最前面的元素发生！" } , { ER_IMPORTING_ITSELF , "（StylesheetHandler）{0} 正在直接或间接地导入它自身！" } , { ER_XMLSPACE_ILLEGAL_VAL , "（StylesheetHandler）“+”xml:space 有非法值：{0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet 不成功！" } , { ER_SAX_EXCEPTION , "SAX 异常" } , { ER_XSLT_ERROR , "XSLT 错误" } , { ER_CURRENCY_SIGN_ILLEGAL , "格式模式字符串中不允许存在货币符号" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "样式表 DOM 中不支持文档函数！" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "无法解析非前缀解析程序的前缀！" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "重定向扩展：无法获取文件名 ― 文件或 select 属性必须返回有效字符串。" } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "无法在重定向扩展中构建 FormatterListener！" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "exclude-result-prefixes 中的前缀无效：{0}" } , { ER_MISSING_NS_URI , "缺少指定前缀的名称空间 URI" } , { ER_MISSING_ARG_FOR_OPTION , "缺少选项的自变量：{0}" } , { ER_INVALID_OPTION , "无效的选项：{0}" } , { ER_MALFORMED_FORMAT_STRING , "格式不好的格式字符串：{0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet 需要“version”属性！" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "属性：{0} 有非法的值：{1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose 需要 xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:for-each 中不允许 xsl:apply-imports" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "无法将 DTMLiaison 用于输出 DOM 节点... 改为传递 org.apache.xpath.DOM2Helper！" } , { ER_CANT_USE_DTM_FOR_INPUT , "无法将 DTMLiaison 用于输入 DOM 节点... 改为传递 org.apache.xpath.DOM2Helper！" } , { ER_CALL_TO_EXT_FAILED , "调用扩展元素失败：{0}" } , { ER_PREFIX_MUST_RESOLVE , "前缀必须解析为名称空间：{0}" } , { ER_INVALID_UTF16_SURROGATE , "检测到无效的 UTF-16 替代者：{0}？" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} 使用了自身，这将导致无限循环。" } , { ER_CANNOT_MIX_XERCESDOM , "无法将非 Xerces-DOM 输入与 Xerces-DOM 输出混合！" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet ― TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "在 ElemTemplateElement.readObject 中：{0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "找到多个名为 {0} 的模板" } , { ER_INVALID_KEY_CALL , "无效的函数调用：不允许循环 key() 调用" } , { ER_REFERENCING_ITSELF , "变量 {0} 正在直接或间接地引用它自身！" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "输入节点对于 newTemplates 的 DOMSource 不能为空！" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "找不到选项 {0} 的类文件" } , { ER_REQUIRED_ELEM_NOT_FOUND , "找不到必需的元素：{0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream 不能为空" } , { ER_URI_CANNOT_BE_NULL , "URI 不能为空" } , { ER_FILE_CANNOT_BE_NULL , "File 不能为空" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource 不能为空" } , { ER_CANNOT_INIT_BSFMGR , "无法初始化 BSF Manager" } , { ER_CANNOT_CMPL_EXTENSN , "无法编译扩展" } , { ER_CANNOT_CREATE_EXTENSN , "由于 {1}，无法创建扩展 {0}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "对方法 {0} 的实例方法调用要求以对象实例作为第一自变量" } , { ER_INVALID_ELEMENT_NAME , "指定了无效的元素名称 {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "元素名称方法必须是 static {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "扩展函数 {0}：{1} 未知" } , { ER_MORE_MATCH_CONSTRUCTOR , "对于 {0}，构造函数有多个最佳匹配" } , { ER_MORE_MATCH_METHOD , "方法 {0} 有多个最佳匹配" } , { ER_MORE_MATCH_ELEMENT , "element 方法 {0} 有多个最佳匹配" } , { ER_INVALID_CONTEXT_PASSED , "传递了无效的上下文来求值 {0}" } , { ER_POOL_EXISTS , "池已经存在" } , { ER_NO_DRIVER_NAME , "未指定驱动程序名称" } , { ER_NO_URL , "未指定 URL" } , { ER_POOL_SIZE_LESSTHAN_ONE , "池大小小于 1！" } , { ER_INVALID_DRIVER , "指定了无效的驱动程序名称！" } , { ER_NO_STYLESHEETROOT , "找不到样式表根目录！" } , { ER_ILLEGAL_XMLSPACE_VALUE , "xml:space 的值非法" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode 失败" } , { ER_RESOURCE_COULD_NOT_LOAD , "资源 [ {0} ] 无法装入：{1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "缓冲区大小 <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "调用扩展时发生未知错误" } , { ER_NO_NAMESPACE_DECL , "前缀 {0} 没有相应的名称空间说明" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "lang=javaclass {0} 不允许元素内容" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "样式表定向的终止" } , { ER_ONE_OR_TWO , "1 或 2" } , { ER_TWO_OR_THREE , "2 或 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "无法装入 {0}（检查 CLASSPATH），现在只使用缺省值" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "无法初始化缺省模板" } , { ER_RESULT_NULL , "结果不应为空" } , { ER_RESULT_COULD_NOT_BE_SET , "无法设置结果" } , { ER_NO_OUTPUT_SPECIFIED , "未指定输出" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "无法转换到类型为 {0} 的结果" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "无法转换类型为 {0} 的源" } , { ER_NULL_CONTENT_HANDLER , "内容处理程序为空" } , { ER_NULL_ERROR_HANDLER , "错误处理程序为空" } , { ER_CANNOT_CALL_PARSE , "如果没有设置 ContentHandler，则无法调用分析" } , { ER_NO_PARENT_FOR_FILTER , "过滤器无父代" } , { ER_NO_STYLESHEET_IN_MEDIA , "在 {0} 中找不到样式表，介质 = {1}" } , { ER_NO_STYLESHEET_PI , "在 {0} 中找不到 xml-stylesheet PI" } , { ER_NOT_SUPPORTED , "不支持：{0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "特性 {0} 的值应当是布尔实例" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "无法抵达 {0} 上的外部脚本" } , { ER_RESOURCE_COULD_NOT_FIND , "找不到资源 [ {0} ]。\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "没有识别输出属性：{0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "创建 ElemLiteralResult 实例失败" } , { ER_VALUE_SHOULD_BE_NUMBER , "{0} 的值应当包含可进行分析的数值" } , { ER_VALUE_SHOULD_EQUAL , "{0} 的值应当等于 yes 或 no" } , { ER_FAILED_CALLING_METHOD , "调用 {0} 方法失败" } , { ER_FAILED_CREATING_ELEMTMPL , "创建 ElemTemplateElement 实例失败" } , { ER_CHARS_NOT_ALLOWED , "文档中此时不允许存在字符" } , { ER_ATTR_NOT_ALLOWED , "{1} 元素上不允许存在“{0}”属性！" } , { ER_BAD_VALUE , "{0} 错误值 {1}" } , { ER_ATTRIB_VALUE_NOT_FOUND , "找不到 {0} 属性值" } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "没有识别出 {0} 属性值" } , { ER_NULL_URI_NAMESPACE , "正在试图以空的 URI 生成名称空间前缀" } , { ER_NUMBER_TOO_BIG , "正在试图格式化大于最大长整数的数值" } , { ER_CANNOT_FIND_SAX1_DRIVER , "找不到 SAX1 驱动程序类 {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "找到了 SAX1 驱动程序类 {0}，但无法装入它" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "装入了 SAX1 驱动程序类 {0}，但无法将它实例化" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1 驱动程序类 {0} 不实现 org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "没有指定系统属性 org.xml.sax.parser" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "解析器自变量不得为空" } , { ER_FEATURE , "功能部件：{0}" } , { ER_PROPERTY , "属性：{0}" } , { ER_NULL_ENTITY_RESOLVER , "实体解析程序为空" } , { ER_NULL_DTD_HANDLER , "DTD 处理程序为空" } , { ER_NO_DRIVER_NAME_SPECIFIED , "未指定驱动程序名称！" } , { ER_NO_URL_SPECIFIED , "未指定 URL！" } , { ER_POOLSIZE_LESS_THAN_ONE , "池大小小于 1！" } , { ER_INVALID_DRIVER_NAME , "指定了无效的驱动程序名称！" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "程序员的错误！expr 没有 ElemTemplateElement 父代！" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "程序员在 RundundentExprEliminator 中的断言：{0}" } , { ER_NOT_ALLOWED_IN_POSITION , "样式表中在此位置不允许 {0}！" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "样式表中在此位置不允许非空白空间的文本！" } , { INVALID_TCHAR , "用于 CHAR 属性 {0} 的值 {1} 非法。类型 CHAR 的属性必须只有一个字符！" } , { INVALID_QNAME , "用于 QNAME 属性 {0} 的值 {1} 非法" } , { INVALID_ENUM , "用于 ENUM 属性 {0} 的值 {1} 非法。有效的值是：{2}。" } , { INVALID_NMTOKEN , "用于 NMTOKEN 属性 {0} 的值 {1} 非法" } , { INVALID_NCNAME , "用于 NCNAME 属性 {0} 的值 {1} 非法" } , { INVALID_BOOLEAN , "用于 boolean 属性 {0} 的值 {1} 非法" } , { INVALID_NUMBER , "用于 number 属性 {0} 的值 {1} 非法" } , { ER_ARG_LITERAL , "匹配模式中 {0} 的自变量必须是文字。" } , { ER_DUPLICATE_GLOBAL_VAR , "全局变量说明重复。" } , { ER_DUPLICATE_VAR , "变量说明重复。" } , { ER_TEMPLATE_NAME_MATCH , "xsl:template 必须有一个 name 或 match 属性（或两者兼有）" } , { ER_INVALID_PREFIX , "exclude-result-prefixes 中的前缀无效：{0}" } , { ER_NO_ATTRIB_SET , "名为 {0} 的属性集不存在" } , { WG_FOUND_CURLYBRACE , "找到“}”，但没有打开属性模板！" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "警告：count 属性与 xsl:number 中的上级不匹配！目标 = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "旧语法：“expr”属性的名称已经更改为“select”。" } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan 在 format-number 函数中尚未处理语言环境名。" } , { WG_LOCALE_NOT_FOUND , "警告：找不到 xml:lang={0} 的语言环境" } , { WG_CANNOT_MAKE_URL_FROM , "无法从 {0} 生成 URL" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "无法装入请求的文档：{0}" } , { WG_CANNOT_FIND_COLLATOR , "找不到 <sort xml:lang={0} 的整理器" } , { WG_FUNCTIONS_SHOULD_USE_URL , "旧语法：函数指令应当使用 {0} 的 URL" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "不支持编码：{0}，正在使用 UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "不支持编码：{0}，正在使用 Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "发现特性冲突：将使用样式表中最后找到的 {0}。" } , { WG_PARSING_AND_PREPARING , "========= 分析和准备 {0} ==========" } , { WG_ATTR_TEMPLATE , "Attr 模板，{0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "xsl:strip-space 和 xsl:preserve-space 之间的匹配冲突" } , { WG_ATTRIB_NOT_HANDLED , "Xalan 尚未处理 {0} 属性！" } , { WG_NO_DECIMALFORMAT_DECLARATION , "找不到十进制格式的说明：{0}" } , { WG_OLD_XSLT_NS , "XSLT 名称空间丢失或不正确。" } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "只允许一个缺省的 xsl:decimal-format 说明。" } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format 名称必须唯一。名称“{0}”有重复。" } , { WG_ILLEGAL_ATTRIBUTE , "{0} 有一个非法属性：{1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "无法解析名称空间前缀：{0}。将忽略节点。" } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet 需要“version”属性！" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "非法属性名称：{0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "用于属性 {0} 的值非法：{1}" } , { WG_EMPTY_SECOND_ARG , "从文档函数的第二自变量产生的节点集是空的。返回一个空节点集。" } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "xsl:processing-instruction 名称的“name”属性的值不得为“xml”" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "xsl:processing-instruction 的“name”属性的值必须是有效的 NCName：{0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "在生成子节点之后或在生成元素之前无法添加属性 {0}。将忽略属性。" } , { "ui_language" , "zh" } , { "help_language" , "zh" } , { "language" , "zh" } , { "BAD_CODE" , "createMessage 的参数超出范围" } , { "FORMAT_FAILED" , "在 messageFormat 调用过程中抛出的异常" } , { "version" , ">>>>>>> Xalan 版本" } , { "version2" , "<<<<<<<" } , { "yes" , "是" } , { "line" , "行号" } , { "column" , "列号" } , { "xsldone" , "XSLProcessor：完成" } , { "xslProc_option" , "Xalan-J 命令行 Process 类选项：" } , { "xslProc_option" , "Xalan-J 命令行 Process 类选项：" } , { "xslProc_invalid_xsltc_option" , "在 XSLTC 方式中，不支持选项 {0}。" } , { "xslProc_invalid_xalan_option" , "选项 {0} 只能与 -XSLTC 一起使用。" } , { "xslProc_no_input" , "错误：没有指定样式表或输入 xml。不带任何选项运行此命令，以了解用法的指示信息。" } , { "xslProc_common_options" , "― 公共选项 ―" } , { "xslProc_xalan_options" , "― Xalan 选项 ―" } , { "xslProc_xsltc_options" , "― XSLTC 选项 ―" } , { "xslProc_return_to_continue" , "（请按 <return> 键继续）" } , { "optionXSLTC" , "   [-XSLTC （使用 XSLTC 转换）]" } , { "optionIN" , "   [-IN inputXMLURL]" } , { "optionXSL" , "[-XSL XSLTransformationURL]" } , { "optionOUT" , "[-OUT outputFileName]" } , { "optionLXCIN" , "[-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "[-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER fully qualified class name of parser liaison]" } , { "optionE" , "[-E （不要展开实体 refs）]" } , { "optionV" , "[-E （不要展开实体 refs）]" } , { "optionQC" , "[-QC （不显示冲突警告）]" } , { "optionQ" , "[-Q （不显示模式）]" } , { "optionLF" , "[-LF （输出时仅使用 linefeeds {default is CR/LF}）]" } , { "optionCR" , "[-CR （输出时仅使用 carriage returns {default is CR/LF}）]" } , { "optionESCAPE" , "[-ESCAPE （设置转义字符{default is <>&\"\'\\r\\n}）]" } , { "optionINDENT" , "[-INDENT （控制缩进多少空格{default is 0}）]" } , { "optionTT" , "[-TT （在模板被调用时跟踪模板。）]" } , { "optionTG" , "[-TG （跟踪每一个生成事件。）]" } , { "optionTS" , "[-TS （跟踪每一个选择事件。）]" } , { "optionTTC" , "[-TTC （在子模板被处理时对其进行跟踪。）]" } , { "optionTCLASS" , "[-TCLASS （跟踪扩展的 TraceListener 类。）]" } , { "optionVALIDATE" , "[-VALIDATE （设置是否出现验证。缺省时验证是关闭的。）]" } , { "optionEDUMP" , "[-EDUMP {optional filename} （发生错误时堆栈转储。）]" } , { "optionXML" , "[-XML （使用 XML 格式化程序并添加 XML 头。）]" } , { "optionTEXT" , "[-TEXT （使用简单文本格式化程序。）]" } , { "optionHTML" , "[-HTML （使用 HTML 格式化程序）]" } , { "optionPARAM" , "[-PARAM name expression （设置样识表参数）]" } , { "noParsermsg1" , "XSL 处理不成功。" } , { "noParsermsg2" , "** 找不到解析器 **" } , { "noParsermsg3" , "请检查您的类路径。" } , { "noParsermsg4" , "如果没有 IBM 的 XML Parser for Java，您可以从以下位置下载它：" } , { "noParsermsg5" , "IBM 的 AlphaWorks：http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "[-URIRESOLVER full class name （使用 URIResolver 解析 URI）]" } , { "optionENTITYRESOLVER" , "[-ENTITYRESOLVER full class name （使用 EntityResolver 解析 实体）]" } , { "optionCONTENTHANDLER" , "[-CONTENTHANDLER full class name （使用 ContentHandler 串行化输出）]" } , { "optionLINENUMBERS" , "[-L use line numbers for source document]" } , { "optionMEDIA" , "   [-MEDIA mediaType （使用 media 属性查找与文档关联的样式表。）]" } , { "optionFLAVOR" , "   [-FLAVOR flavorName （显式使用 s2s=SAX 或 d2d=DOM 转换。）]" } , { "optionDIAG" , "[-DIAG （显示全部毫秒转换标记。）]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL （通过设置http://xml.apache.org/xalan/features/incremental 为 true 请求增加的 DTM 构造。）]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE （通过设置http://xml.apache.org/xalan/features/optimize 为 false 请求不需要式样表优化处理。）]" } , { "optionRL" , "   [-RL recursionlimit （断言样式表递归深度的数字极限。）]" } , { "optionXO" , "[-XO [transletName] （断言生成 translet 的名字）]" } , { "optionXD" , "[-XD destinationDirectory （指定 translet 目标目录）]" } , { "optionXJ" , "[-XJ jarfile （将类 translet 成名字为 <jarfile> jar 文件的包）]" } , { "optionXP" , "[-XP package （指出所有生成 translet 类的包名字前缀）]" } , { "optionXN" , "[-XN （开启模板内联）]" } , { "optionXX" , "[-XX （打开附加调试信息输出）]" } , { "optionXT" , "[-XT （若可能使用 translet 进行转换）]" } , { "diagTiming" , "--------- {0} 通过 {1} 的转换耗时 {2} 毫秒" } , { "recursionTooDeep" , "模板嵌套太深。嵌套 = {0}，模板 {1} {2}" } , { "nameIs" , "名称为" } , { "matchPatternIs" , "匹配模式为" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#错误" ; public static final String ERROR_HEADER = "错误:" ; public static final String WARNING_HEADER = "警告:" ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "zh" , "CN" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "无法装入任何资源包。" , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . OpCodes ; import org . apache . xpath . patterns . NodeTest ; public class DescendantIterator extends LocPathIterator { DescendantIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; int stepType = compiler . getOp ( firstStepPos ) ; boolean orSelf = ( OpCodes . FROM_DESCENDANTS_OR_SELF == stepType ) ; boolean fromRoot = false ; if ( OpCodes . FROM_SELF == stepType ) { orSelf = true ; } else if ( OpCodes . FROM_ROOT == stepType ) { fromRoot = true ; int nextStepPos = compiler . getNextStepPos ( firstStepPos ) ; if ( compiler . getOp ( nextStepPos ) == OpCodes . FROM_DESCENDANTS_OR_SELF ) orSelf = true ; } int nextStepPos = firstStepPos ; while ( true ) { nextStepPos = compiler . getNextStepPos ( nextStepPos ) ; if ( nextStepPos > 0 ) { int stepOp = compiler . getOp ( nextStepPos ) ; if ( OpCodes . ENDOP != stepOp ) firstStepPos = nextStepPos ; else break ; } else break ; } if ( ( analysis & WalkerFactory . BIT_CHILD ) != 0 ) orSelf = false ; if ( fromRoot ) { if ( orSelf ) m_axis = Axis . DESCENDANTSORSELFFROMROOT ; else m_axis = Axis . DESCENDANTSFROMROOT ; } else if ( orSelf ) m_axis = Axis . DESCENDANTORSELF ; else m_axis = Axis . DESCENDANT ; int whatToShow = compiler . getWhatToShow ( firstStepPos ) ; if ( ( 0 == ( whatToShow & ( DTMFilter . SHOW_ATTRIBUTE | DTMFilter . SHOW_ELEMENT | DTMFilter . SHOW_PROCESSING_INSTRUCTION ) ) ) || ( whatToShow == DTMFilter . SHOW_ALL ) ) initNodeTest ( whatToShow ) ; else { initNodeTest ( whatToShow , compiler . getStepNS ( firstStepPos ) , compiler . getStepLocalName ( firstStepPos ) ) ; } initPredicateInfo ( compiler , firstStepPos ) ; } public DescendantIterator ( ) { super ( null ) ; m_axis = Axis . DESCENDANTSORSELFFROMROOT ; int whatToShow = DTMFilter . SHOW_ALL ; initNodeTest ( whatToShow ) ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { DescendantIterator clone = ( DescendantIterator ) super . cloneWithReset ( ) ; clone . m_traverser = m_traverser ; clone . resetProximityPositions ( ) ; return clone ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; if ( DTM . NULL == m_lastFetched ) { resetProximityPositions ( ) ; } int next ; org . apache . xpath . VariableStack vars ; int savedStart ; if ( - 1 != m_stackFrame ) { vars = m_execContext . getVarStack ( ) ; savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( m_stackFrame ) ; } else { vars = null ; savedStart = 0 ; } try { do { if ( 0 == m_extendedTypeID ) { next = m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; } else { next = m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context , m_extendedTypeID ) : m_traverser . next ( m_context , m_lastFetched , m_extendedTypeID ) ; } if ( DTM . NULL != next ) { if ( DTMIterator . FILTER_ACCEPT == acceptNode ( next ) ) break ; else continue ; } else break ; } while ( next != DTM . NULL ) ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } finally { if ( - 1 != m_stackFrame ) { vars . setStackFrame ( savedStart ) ; } } } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( m_axis ) ; String localName = getLocalName ( ) ; String namespace = getNamespace ( ) ; int what = m_whatToShow ; if ( DTMFilter . SHOW_ALL == what || localName == NodeTest . WILD || namespace == NodeTest . WILD ) { m_extendedTypeID = 0 ; } else { int type = getNodeTypeTest ( what ) ; m_extendedTypeID = m_cdtm . getExpandedTypeID ( namespace , localName , type ) ; } } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( getPredicateCount ( ) > 0 ) return super . asNode ( xctxt ) ; int current = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( current ) ; DTMAxisTraverser traverser = dtm . getAxisTraverser ( m_axis ) ; String localName = getLocalName ( ) ; String namespace = getNamespace ( ) ; int what = m_whatToShow ; if ( DTMFilter . SHOW_ALL == what || localName == NodeTest . WILD || namespace == NodeTest . WILD ) { return traverser . first ( current ) ; } else { int type = getNodeTypeTest ( what ) ; int extendedType = dtm . getExpandedTypeID ( namespace , localName , type ) ; return traverser . first ( current , extendedType ) ; } } public void detach ( ) { if ( m_allowDetach ) { m_traverser = null ; m_extendedTypeID = 0 ; super . detach ( ) ; } } public int getAxis ( ) { return m_axis ; } transient protected DTMAxisTraverser m_traverser ; protected int m_axis ; protected int m_extendedTypeID ; public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( m_axis != ( ( DescendantIterator ) expr ) . m_axis ) return false ; return true ; } } 	1	['9', '5', '0', '11', '42', '0', '2', '9', '8', '0.583333333', '426', '1', '1', '0.946969697', '0.277777778', '3', '11', '46', '14', '2.8889', '1']
package org . apache . xpath . functions ; import java . io . BufferedInputStream ; import java . io . InputStream ; import java . util . Properties ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . apache . xpath . res . XPATHErrorResources ; public class FuncSystemProperty extends FunctionOneArg { static String XSLT_PROPERTIES = "org/apache/xalan/res/XSLTInfo.properties" ; public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String fullName = m_arg0 . execute ( xctxt ) . str ( ) ; int indexOfNSSep = fullName . indexOf ( ':' ) ; String result ; String propName = "" ; Properties xsltInfo = new Properties ( ) ; loadPropertyFile ( XSLT_PROPERTIES , xsltInfo ) ; if ( indexOfNSSep > 0 ) { String prefix = ( indexOfNSSep >= 0 ) ? fullName . substring ( 0 , indexOfNSSep ) : "" ; String namespace ; namespace = xctxt . getNamespaceContext ( ) . getNamespaceForPrefix ( prefix ) ; propName = ( indexOfNSSep < 0 ) ? fullName : fullName . substring ( indexOfNSSep + 1 ) ; if ( namespace . startsWith ( "http://www.w3.org/XSL/Transform" ) || namespace . equals ( "http://www.w3.org/1999/XSL/Transform" ) ) { result = xsltInfo . getProperty ( propName ) ; if ( null == result ) { warn ( xctxt , XPATHErrorResources . WG_PROPERTY_NOT_SUPPORTED , new Object [ ] { fullName } ) ; return XString . EMPTYSTRING ; } } else { warn ( xctxt , XPATHErrorResources . WG_DONT_DO_ANYTHING_WITH_NS , new Object [ ] { namespace , fullName } ) ; try { result = System . getProperty ( propName ) ; if ( null == result ) { return XString . EMPTYSTRING ; } } catch ( SecurityException se ) { warn ( xctxt , XPATHErrorResources . WG_SECURITY_EXCEPTION , new Object [ ] { fullName } ) ; return XString . EMPTYSTRING ; } } } else { try { result = System . getProperty ( fullName ) ; if ( null == result ) { return XString . EMPTYSTRING ; } } catch ( SecurityException se ) { warn ( xctxt , XPATHErrorResources . WG_SECURITY_EXCEPTION , new Object [ ] { fullName } ) ; return XString . EMPTYSTRING ; } } if ( propName . equals ( "version" ) && result . length ( ) > 0 ) { try { return new XNumber ( 1.0 ) ; } catch ( Exception ex ) { return new XString ( result ) ; } } else return new XString ( result ) ; } public void loadPropertyFile ( String file , Properties target ) { try { SecuritySupport ss = SecuritySupport . getInstance ( ) ; InputStream is = ss . getResourceAsStream ( ObjectFactory . findClassLoader ( ) , file ) ; BufferedInputStream bis = new BufferedInputStream ( is ) ; target . load ( bis ) ; bis . close ( ) ; } catch ( Exception ex ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ex ) ; } } } 	1	['4', '4', '0', '10', '28', '4', '0', '10', '3', '0.666666667', '191', '0', '0', '0.96', '0.5', '2', '8', '46.5', '1', '0.5', '2']
package org . apache . xalan . xsltc . cmdline ; import java . io . File ; import java . net . URL ; import java . util . Vector ; import org . apache . xalan . xsltc . cmdline . getopt . GetOpt ; import org . apache . xalan . xsltc . cmdline . getopt . GetOptsException ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; public final class Compile { private static int VERSION_MAJOR = 1 ; private static int VERSION_MINOR = 4 ; private static int VERSION_DELTA = 0 ; private static boolean _allowExit = true ; public static void printUsage ( ) { StringBuffer vers = new StringBuffer ( "XSLTC version " + VERSION_MAJOR + "." + VERSION_MINOR + ( ( VERSION_DELTA > 0 ) ? ( "." + VERSION_DELTA ) : ( "" ) ) ) ; System . err . println ( vers + "\n" + new ErrorMsg ( ErrorMsg . COMPILE_USAGE_STR ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } public static void main ( String [ ] args ) { try { boolean inputIsURL = false ; boolean useStdIn = false ; boolean classNameSet = false ; final GetOpt getopt = new GetOpt ( args , "o:d:j:p:uxhsinv" ) ; if ( args . length < 1 ) printUsage ( ) ; final XSLTC xsltc = new XSLTC ( ) ; xsltc . init ( ) ; int c ; while ( ( c = getopt . getNextOption ( ) ) != - 1 ) { switch ( c ) { case 'i' : useStdIn = true ; break ; case 'o' : xsltc . setClassName ( getopt . getOptionArg ( ) ) ; classNameSet = true ; break ; case 'd' : xsltc . setDestDirectory ( getopt . getOptionArg ( ) ) ; break ; case 'p' : xsltc . setPackageName ( getopt . getOptionArg ( ) ) ; break ; case 'j' : xsltc . setJarFileName ( getopt . getOptionArg ( ) ) ; break ; case 'x' : xsltc . setDebug ( true ) ; break ; case 'u' : inputIsURL = true ; break ; case 's' : _allowExit = false ; break ; case 'n' : xsltc . setTemplateInlining ( true ) ; break ; case 'v' : case 'h' : default : printUsage ( ) ; break ; } } boolean compileOK ; if ( useStdIn ) { if ( ! classNameSet ) { System . err . println ( new ErrorMsg ( ErrorMsg . COMPILE_STDIN_ERR ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } compileOK = xsltc . compile ( System . in , xsltc . getClassName ( ) ) ; } else { final String [ ] stylesheetNames = getopt . getCmdArgs ( ) ; final Vector stylesheetVector = new Vector ( ) ; for ( int i = 0 ; i < stylesheetNames . length ; i ++ ) { final String name = stylesheetNames [ i ] ; URL url ; if ( inputIsURL ) url = new URL ( name ) ; else url = ( new File ( name ) ) . toURL ( ) ; stylesheetVector . addElement ( url ) ; } compileOK = xsltc . compile ( stylesheetVector ) ; } if ( compileOK ) { xsltc . printWarnings ( ) ; if ( xsltc . getJarFileName ( ) != null ) xsltc . outputToJar ( ) ; if ( _allowExit ) System . exit ( 0 ) ; } else { xsltc . printWarnings ( ) ; xsltc . printErrors ( ) ; if ( _allowExit ) System . exit ( - 1 ) ; } } catch ( GetOptsException ex ) { System . err . println ( ex ) ; printUsage ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; if ( _allowExit ) System . exit ( - 1 ) ; } } } 	1	['4', '1', '0', '4', '40', '0', '0', '4', '3', '0.333333333', '240', '1', '0', '0', '0.333333333', '0', '0', '58', '12', '3.75', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_it extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Funzione non supportata." } , { ER_CANNOT_OVERWRITE_CAUSE , "Impossibile sovrascrivere causa" } , { ER_NO_DEFAULT_IMPL , "Non è stata trovata alcuna implementazione predefinita " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) correntemente non supportato" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Offset più grande dello slot" } , { ER_COROUTINE_NOT_AVAIL , "Coroutine non disponibile, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager ha ricevuto la richiesta co_exit()" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() con esito negativo" } , { ER_COROUTINE_PARAM , "Errore parametro Coroutine {0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nNON PREVISTO: Risposte doTerminate del parser {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "impossibile richiamare l'analisi durante l''analisi" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Errore: iteratore immesso per l''asse {0} non implementato " } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Errore: iteratore per l''asse {0} non implementato " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Clone iteratore non supportato" } , { ER_UNKNOWN_AXIS_TYPE , "Tipo trasversale di asse sconosciuto: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Trasversale dell''asse non supportato: {0}" } , { ER_NO_DTMIDS_AVAIL , "Non vi sono ulteriori ID DTM disponibili" } , { ER_NOT_SUPPORTED , "Non supportato: {0}" } , { ER_NODE_NON_NULL , "Il nodo deve essere non nullo per getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "Impossibile risolvere il nodo in un handle" } , { ER_STARTPARSE_WHILE_PARSING , "Impossibile richiamare startParse durante l'analisi" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse richiede SAXParser non nullo" } , { ER_COULD_NOT_INIT_PARSER , "impossibile inizializzare il parser con" } , { ER_EXCEPTION_CREATING_POOL , "si è verificata un'eccezione durante la creazione della nuova istanza per il pool" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Il percorso contiene sequenza di escape non valida" } , { ER_SCHEME_REQUIRED , "Lo schema è obbligatorio." } , { ER_NO_SCHEME_IN_URI , "Nessuno schema trovato nell''URI: {0}" } , { ER_NO_SCHEME_INURI , "Non è stato trovato alcuno schema nell'URI" } , { ER_PATH_INVALID_CHAR , "Il percorso contiene un carattere non valido: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Impossibile impostare lo schema da una stringa nulla" } , { ER_SCHEME_NOT_CONFORMANT , "Lo schema non è conforme." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Host non è un'indirizzo corretto" } , { ER_PORT_WHEN_HOST_NULL , "La porta non può essere impostata se l'host è nullo" } , { ER_INVALID_PORT , "Numero di porta non valido" } , { ER_FRAG_FOR_GENERIC_URI , "Il frammento può essere impostato solo per un URI generico" } , { ER_FRAG_WHEN_PATH_NULL , "Il frammento non può essere impostato se il percorso è nullo" } , { ER_FRAG_INVALID_CHAR , "Il frammento contiene un carattere non valido" } , { ER_PARSER_IN_USE , "Parser già in utilizzo" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Impossibile modificare {0} {1} durante l''analisi" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Self-causation non consentito" } , { ER_NO_USERINFO_IF_NO_HOST , "Userinfo non può essere specificato se l'host non è specificato" } , { ER_NO_PORT_IF_NO_HOST , "La porta non può essere specificata se l'host non è specificato" } , { ER_NO_QUERY_STRING_IN_PATH , "La stringa di interrogazione non può essere specificata nella stringa di interrogazione e percorso." } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Il frammento non può essere specificato sia nel percorso che nel frammento" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Impossibile inizializzare l'URI con i parametri vuoti" } , { ER_METHOD_NOT_SUPPORTED , "Metodo non ancora supportato " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter correntemente non riavviabile" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader non si trova prima della richiesta startParse" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Trasversale dell''asse non supportato: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler creato con PrintWriter nullo." } , { ER_SYSTEMID_UNKNOWN , "SystemId sconosciuto" } , { ER_LOCATION_UNKNOWN , "Posizione di errore sconosciuta" } , { ER_PREFIX_MUST_RESOLVE , "Il prefisso deve risolvere in uno spazio nomi: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() non supportato in XPathContext!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Il secondario dell'attributo non ha un documento proprietario." } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Il secondario dell'attributo non ha un elemento del documento proprietario." } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Attenzione: impossibile emettere testo prima dell'elemento del documento. Operazione ignorata..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Impossibile avere più di una root in un DOM!" } , { ER_ARG_LOCALNAME_NULL , "Argomento 'localName' nullo" } , { ER_ARG_LOCALNAME_INVALID , "Localname in QNAME deve essere un NCName valido " } , { ER_ARG_PREFIX_INVALID , "Prefix in QNAME deve essere un NCName valido " } , { "BAD_CODE" , "Il parametro per createMessage fuori limite" } , { "FORMAT_FAILED" , "Rilevata eccezione durante la chiamata messageFormat" } , { "line" , "Riga #" } , { "column" , "Colonna #" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "La classe serializer ''{0}'' non implementa org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "Risorsa [ {0} ] non trovata.\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "Impossibile caricare la risorsa [ {0} ]: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Dimensione buffer <=0" } , { ER_INVALID_UTF16_SURROGATE , "Rilevato surrogato UTF-16 non valido: {0} ?" } , { ER_OIERROR , "Errore IO" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Impossibile aggiungere l''attributo {0} dopo i nodi secondari o prima che sia prodotto un elemento. L''attributo verrà ignorato. " } , { ER_NAMESPACE_PREFIX , "Lo spazio nomi per il prefisso ''{0}'' non è stato dichiarato. " } , { ER_STRAY_ATTRIBUTE , "Attributo ''{0}'' al di fuori dell''elemento. " } , { ER_STRAY_NAMESPACE , "Dichiarazione dello spazio nome ''{0}''=''{1}'' al di fuori dell''elemento. " } , { ER_COULD_NOT_LOAD_RESOURCE , "Impossibile caricare ''{0}'' (verificare CLASSPATH); verranno utilizzati i valori predefiniti " } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "Impossibile caricare il file delle proprietà ''{0}'' per il metodo di emissione ''{1}'' (verificare CLASSPATH)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "it" , "IT" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_ja extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "機能はサポートされていません!" } , { ER_CANNOT_OVERWRITE_CAUSE , "cause を上書きできません" } , { ER_NO_DEFAULT_IMPL , "デフォルト・インプリメンテーションが見つかりません " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "現在 ChunkedIntArray({0}) はサポートされていません" } , { ER_OFFSET_BIGGER_THAN_SLOT , "オフセットがスロットより大です" } , { ER_COROUTINE_NOT_AVAIL , "連携ルーチンが使用可能でありません。id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager が co_exit() 要求を受け取りました" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() が失敗しました" } , { ER_COROUTINE_PARAM , "連携ルーチン・パラメーター・エラー ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\n予想外: パーサー doTerminate が {0} を応答しています" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "parse は構文解析中に呼び出してはいけません" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "エラー: 軸 {0} の型付きイテレーターはインプリメントされていません" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "エラー: 軸 {0} のイテレーターはインプリメントされていません " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "イテレーターの複製はサポートされていません" } , { ER_UNKNOWN_AXIS_TYPE , "不明の軸トラバース・タイプ: {0}" } , { ER_AXIS_NOT_SUPPORTED , "軸トラバーサーはサポートされていません: {0}" } , { ER_NO_DTMIDS_AVAIL , "使用可能な DTM ID はこれ以上ありません" } , { ER_NOT_SUPPORTED , "サポートされていません: {0}" } , { ER_NODE_NON_NULL , "getDTMHandleFromNode のノードは非ヌルでなければなりません" } , { ER_COULD_NOT_RESOLVE_NODE , "ノードをハンドルに解決できませんでした" } , { ER_STARTPARSE_WHILE_PARSING , "startParse は構文解析中に呼び出してはいけません" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse にはヌル以外の SAXParser が必要です" } , { ER_COULD_NOT_INIT_PARSER , "パーサーを次で初期化できませんでした:" } , { ER_EXCEPTION_CREATING_POOL , "プールの新規インスタンスを作成中に例外" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "パスに無効なエスケープ・シーケンスが含まれています" } , { ER_SCHEME_REQUIRED , "スキームが必要です!" } , { ER_NO_SCHEME_IN_URI , "スキームは URI {0} で見つかりません" } , { ER_NO_SCHEME_INURI , "スキームは URI で見つかりません" } , { ER_PATH_INVALID_CHAR , "パスに無効文字: {0} が含まれています" } , { ER_SCHEME_FROM_NULL_STRING , "ヌル・ストリングからはスキームを設定できません" } , { ER_SCHEME_NOT_CONFORMANT , "スキームは一致していません。" } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "ホストはうまく構成されたアドレスでありません" } , { ER_PORT_WHEN_HOST_NULL , "ホストがヌルであるとポートを設定できません" } , { ER_INVALID_PORT , "無効なポート番号" } , { ER_FRAG_FOR_GENERIC_URI , "総称 URI のフラグメントしか設定できません" } , { ER_FRAG_WHEN_PATH_NULL , "パスがヌルであるとフラグメントを設定できません" } , { ER_FRAG_INVALID_CHAR , "フラグメントに無効文字が含まれています" } , { ER_PARSER_IN_USE , "パーサーはすでに使用中です" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "構文解析中に {0} {1} を変更できません" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "自己原因は許可されません" } , { ER_NO_USERINFO_IF_NO_HOST , "ホストが指定されていない場合は Userinfo を指定してはいけません" } , { ER_NO_PORT_IF_NO_HOST , "ホストが指定されていない場合はポートを指定してはいけません" } , { ER_NO_QUERY_STRING_IN_PATH , "照会ストリングはパスおよび照会ストリング内に指定できません" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "フラグメントはパスとフラグメントの両方に指定できません" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "URI は空のパラメーターを使用して初期化できません" } , { ER_METHOD_NOT_SUPPORTED , "メソッドはまだサポートされていません " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "現在 IncrementalSAXSource_Filter は再始動可能でありません" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader が startParse 要求の前でありません" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "軸トラバーサーはサポートされていません: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler がヌル PrintWriter で作成されました!" } , { ER_SYSTEMID_UNKNOWN , "SystemId は不明" } , { ER_LOCATION_UNKNOWN , "エラーのロケーションは不明" } , { ER_PREFIX_MUST_RESOLVE , "接頭部はネーム・スペースに解決されなければなりません: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() は XPathContext 内でサポートされません!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "属性の子に所有者文書がありません!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "属性の子に所有者文書エレメントがありません!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "警告: 文書エレメントの前にテキストを出力できません!  無視しています..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "DOM では複数のルートをもてません!" } , { ER_ARG_LOCALNAME_NULL , "引き数 'localName' がヌルです。" } , { ER_ARG_LOCALNAME_INVALID , "QNAME 内のローカル名は有効な NCName であるはずです" } , { ER_ARG_PREFIX_INVALID , "QNAME 内の接頭部は有効な NCName であるはずです" } , { "BAD_CODE" , "createMessage へのパラメーターが境界外でした。" } , { "FORMAT_FAILED" , "messageFormat 呼び出し中に例外がスローされました。" } , { "line" , "行 #" } , { "column" , "桁 #" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "シリアライザー・クラス ''{0}'' は org.xml.sax.ContentHandler をインプリメントしません。" } , { ER_RESOURCE_COULD_NOT_FIND , "リソース [ {0} ] は見つかりませんでした。\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "リソース [ {0} ] をロードできませんでした: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "バッファー・サイズ <=0" } , { ER_INVALID_UTF16_SURROGATE , "無効な UTF-16 サロゲートが検出されました: {0} ?" } , { ER_OIERROR , "入出力エラー" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "下位ノードの後またはエレメントが生成される前に属性 {0} を追加できません。属性は無視されます。" } , { ER_NAMESPACE_PREFIX , "接頭部 ''{0}'' のネーム・スペースが宣言されていません。" } , { ER_STRAY_ATTRIBUTE , "属性 ''{0}'' がエレメントの外側です。" } , { ER_STRAY_NAMESPACE , "ネーム・スペース宣言 ''{0}''=''{1}'' がエレメントの外側です。" } , { ER_COULD_NOT_LOAD_RESOURCE , "''{0}'' をロードできませんでした (CLASSPATH を調べてください)。現在は単にデフォルトを使用しています。" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "出力メソッド ''{1}'' のプロパティー・ファイル ''{0}'' をロードできませんでした (CLASSPATH を確認)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xalan . templates ; import java . util . Enumeration ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . StringVector ; import org . apache . xpath . XPathContext ; import org . xml . sax . SAXException ; public class ElemLiteralResult extends ElemUse { private boolean isLiteralResultAsStylesheet = false ; public void setIsLiteralResultAsStylesheet ( boolean b ) { isLiteralResultAsStylesheet = b ; } public boolean getIsLiteralResultAsStylesheet ( ) { return isLiteralResultAsStylesheet ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_avts ) { int nAttrs = m_avts . size ( ) ; for ( int i = ( nAttrs - 1 ) ; i >= 0 ; i -- ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; } } } private Vector m_avts = null ; private Vector m_xslAttr = null ; public void addLiteralResultAttribute ( AVT avt ) { if ( null == m_avts ) m_avts = new Vector ( ) ; m_avts . addElement ( avt ) ; } public void addLiteralResultAttribute ( String att ) { if ( null == m_xslAttr ) m_xslAttr = new Vector ( ) ; m_xslAttr . addElement ( att ) ; } public void setXmlSpace ( AVT avt ) { addLiteralResultAttribute ( avt ) ; String val = avt . getSimpleString ( ) ; if ( val . equals ( "default" ) ) { super . setXmlSpace ( Constants . ATTRVAL_STRIP ) ; } else if ( val . equals ( "preserve" ) ) { super . setXmlSpace ( Constants . ATTRVAL_PRESERVE ) ; } } public AVT getLiteralResultAttribute ( String name ) { if ( null != m_avts ) { int nAttrs = m_avts . size ( ) ; for ( int i = ( nAttrs - 1 ) ; i >= 0 ; i -- ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; if ( avt . getRawName ( ) . equals ( name ) ) { return avt ; } } } return null ; } public boolean containsExcludeResultPrefix ( String prefix , String uri ) { if ( uri == null || ( null == m_excludeResultPrefixes && null == m_ExtensionElementURIs ) ) return super . containsExcludeResultPrefix ( prefix , uri ) ; if ( prefix . length ( ) == 0 ) prefix = Constants . ATTRVAL_DEFAULT_PREFIX ; if ( m_excludeResultPrefixes != null ) for ( int i = 0 ; i < m_excludeResultPrefixes . size ( ) ; i ++ ) { if ( uri . equals ( getNamespaceForPrefix ( m_excludeResultPrefixes . elementAt ( i ) ) ) ) return true ; } if ( m_ExtensionElementURIs != null && m_ExtensionElementURIs . contains ( uri ) ) return true ; return super . containsExcludeResultPrefix ( prefix , uri ) ; } public void resolvePrefixTables ( ) throws TransformerException { super . resolvePrefixTables ( ) ; StylesheetRoot stylesheet = getStylesheetRoot ( ) ; if ( ( null != m_namespace ) && ( m_namespace . length ( ) > 0 ) ) { NamespaceAlias nsa = stylesheet . getNamespaceAliasComposed ( m_namespace ) ; if ( null != nsa ) { m_namespace = nsa . getResultNamespace ( ) ; String resultPrefix = nsa . getStylesheetPrefix ( ) ; if ( ( null != resultPrefix ) && ( resultPrefix . length ( ) > 0 ) ) m_rawName = resultPrefix + ":" + m_localName ; else m_rawName = m_localName ; } } if ( null != m_avts ) { int n = m_avts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; String ns = avt . getURI ( ) ; if ( ( null != ns ) && ( ns . length ( ) > 0 ) ) { NamespaceAlias nsa = stylesheet . getNamespaceAliasComposed ( m_namespace ) ; if ( null != nsa ) { String namespace = nsa . getResultNamespace ( ) ; String resultPrefix = nsa . getStylesheetPrefix ( ) ; String rawName = avt . getName ( ) ; if ( ( null != resultPrefix ) && ( resultPrefix . length ( ) > 0 ) ) rawName = resultPrefix + ":" + rawName ; avt . setURI ( namespace ) ; avt . setRawName ( rawName ) ; } } } } } boolean needToCheckExclude ( ) { if ( null == m_excludeResultPrefixes && null == m_prefixTable && m_ExtensionElementURIs == null ) return false ; else { if ( null == m_prefixTable ) m_prefixTable = new Vector ( ) ; return true ; } } private String m_namespace ; public void setNamespace ( String ns ) { if ( null == ns ) ns = "" ; m_namespace = ns ; } public String getNamespace ( ) { return m_namespace ; } private String m_localName ; public void setLocalName ( String localName ) { m_localName = localName ; } public String getLocalName ( ) { return m_localName ; } private String m_rawName ; public void setRawName ( String rawName ) { m_rawName = rawName ; } public String getRawName ( ) { return m_rawName ; } public String getPrefix ( ) { int len = m_rawName . length ( ) - m_localName . length ( ) - 1 ; return ( len > 0 ) ? m_rawName . substring ( 0 , len ) : "" ; } private StringVector m_ExtensionElementURIs ; public void setExtensionElementPrefixes ( StringVector v ) { m_ExtensionElementURIs = v ; } public String getExtensionElementPrefix ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_ExtensionElementURIs ) throw new ArrayIndexOutOfBoundsException ( ) ; return m_ExtensionElementURIs . elementAt ( i ) ; } public int getExtensionElementPrefixCount ( ) { return ( null != m_ExtensionElementURIs ) ? m_ExtensionElementURIs . size ( ) : 0 ; } public boolean containsExtensionElementURI ( String uri ) { if ( null == m_ExtensionElementURIs ) return false ; return m_ExtensionElementURIs . contains ( uri ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_LITERALRESULT ; } public String getNodeName ( ) { return m_rawName ; } private String m_version ; public void setVersion ( String v ) { m_version = v ; } public String getVersion ( ) { return m_version ; } private StringVector m_excludeResultPrefixes ; public void setExcludeResultPrefixes ( StringVector v ) { m_excludeResultPrefixes = v ; } private boolean excludeResultNSDecl ( String prefix , String uri ) throws TransformerException { if ( null != m_excludeResultPrefixes ) { return containsExcludeResultPrefix ( prefix , uri ) ; } return false ; } public void execute ( TransformerImpl transformer ) throws TransformerException { SerializationHandler rhandler = transformer . getSerializationHandler ( ) ; try { if ( TransformerImpl . S_DEBUG ) { rhandler . flushPending ( ) ; transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; } rhandler . startPrefixMapping ( getPrefix ( ) , getNamespace ( ) ) ; executeNSDecls ( transformer ) ; rhandler . startElement ( getNamespace ( ) , getLocalName ( ) , getRawName ( ) ) ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } TransformerException tException = null ; try { super . execute ( transformer ) ; if ( null != m_avts ) { int nAttrs = m_avts . size ( ) ; for ( int i = ( nAttrs - 1 ) ; i >= 0 ; i -- ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; String stringedValue = avt . evaluate ( xctxt , sourceNode , this ) ; if ( null != stringedValue ) { rhandler . addAttribute ( avt . getURI ( ) , avt . getName ( ) , avt . getRawName ( ) , "CDATA" , stringedValue ) ; } } } transformer . executeChildTemplates ( this , true ) ; } catch ( TransformerException te ) { tException = te ; } catch ( SAXException se ) { tException = new TransformerException ( se ) ; } try { if ( TransformerImpl . S_DEBUG ) { transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } rhandler . endElement ( getNamespace ( ) , getLocalName ( ) , getRawName ( ) ) ; } catch ( SAXException se ) { if ( tException != null ) throw tException ; else throw new TransformerException ( se ) ; } if ( tException != null ) throw tException ; unexecuteNSDecls ( transformer ) ; try { rhandler . endPrefixMapping ( getPrefix ( ) ) ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } } public Enumeration enumerateLiteralResultAttributes ( ) { return ( null == m_avts ) ? null : m_avts . elements ( ) ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitLiteralResultElement ( this ) ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs && null != m_avts ) { int nAttrs = m_avts . size ( ) ; for ( int i = ( nAttrs - 1 ) ; i >= 0 ; i -- ) { AVT avt = ( AVT ) m_avts . elementAt ( i ) ; avt . callVisitors ( visitor ) ; } } super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['32', '4', '2', '18', '88', '354', '6', '13', '28', '0.88172043', '686', '1', '2', '0.86695279', '0.180555556', '3', '19', '20.15625', '10', '1.8438', '3']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; public abstract class Pattern extends Expression { public abstract Type typeCheck ( SymbolTable stable ) throws TypeCheckError ; public abstract void translate ( ClassGenerator classGen , MethodGenerator methodGen ) ; public abstract double getPriority ( ) ; } 	1	['17', '3', '2', '20', '31', '136', '11', '9', '17', '2', '72', '0', '0', '0.816091954', '0.277310924', '2', '5', '3.235294118', '1', '0.9412', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_de extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Funktion nicht unterstützt!" } , { ER_CANNOT_OVERWRITE_CAUSE , "cause kann nicht überschrieben werden." } , { ER_NO_DEFAULT_IMPL , "Keine Standardimplementierung gefunden. " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) momentan nicht unterstützt." } , { ER_OFFSET_BIGGER_THAN_SLOT , "Offset ist größer als Bereich." } , { ER_COROUTINE_NOT_AVAIL , "Koroutine nicht verfügbar, ID: {0}." } , { ER_COROUTINE_CO_EXIT , "CoroutineManager hat Anforderung co_exit() empfangen." } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() ist fehlgeschlagen." } , { ER_COROUTINE_PARAM , "Parameterfehler der Koroutine ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNERWARTET: Parser doTerminate antwortet {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "parse darf während der Syntaxanalyse nicht aufgerufen werden." } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Fehler: Iterator mit Typangabe für Achse {0} ist nicht implementiert." } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Fehler: Iterator für Achse {0} ist nicht implementiert. " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Iterator 'clone' ist nicht unterstützt." } , { ER_UNKNOWN_AXIS_TYPE , "Unbekannter Achsentraversiertyp: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Achsentraversierer nicht unterstützt: {0}" } , { ER_NO_DTMIDS_AVAIL , "Keine weiteren Dokumenttypmodell-IDs verfügbar" } , { ER_NOT_SUPPORTED , "Nicht unterstützt: {0}" } , { ER_NODE_NON_NULL , "Knoten muss ungleich Null sein für getDTMHandleFromNode." } , { ER_COULD_NOT_RESOLVE_NODE , "Der Knoten konnte nicht in eine Kennung aufgelöst werden." } , { ER_STARTPARSE_WHILE_PARSING , "startParse kann während der Syntaxanalyse nicht aufgerufen werden." } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse erfordert SAXParser ungleich Null." } , { ER_COULD_NOT_INIT_PARSER , "Konnte Parser nicht initialisieren mit" } , { ER_EXCEPTION_CREATING_POOL , "Ausnahmebedingung beim Erstellen eines neuen Exemplars für Pool." } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Der Pfad enthält eine ungültige Escapezeichenfolge." } , { ER_SCHEME_REQUIRED , "Schema ist erforderlich!" } , { ER_NO_SCHEME_IN_URI , "Kein Schema gefunden in URI: {0}." } , { ER_NO_SCHEME_INURI , "Kein Schema gefunden in URI" } , { ER_PATH_INVALID_CHAR , "Pfad enthält ungültiges Zeichen: {0}." } , { ER_SCHEME_FROM_NULL_STRING , "Schema kann nicht von Nullzeichenfolge festgelegt werden." } , { ER_SCHEME_NOT_CONFORMANT , "Das Schema ist nicht angepasst." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Der Host ist keine syntaktisch korrekte Adresse." } , { ER_PORT_WHEN_HOST_NULL , "Der Port kann nicht festgelegt werden, wenn der Host gleich Null ist." } , { ER_INVALID_PORT , "Ungültige Portnummer" } , { ER_FRAG_FOR_GENERIC_URI , "Fragment kann nur für eine generische URI (Uniform Resource Identifier) festgelegt werden." } , { ER_FRAG_WHEN_PATH_NULL , "Fragment kann nicht festgelegt werden, wenn der Pfad gleich Null ist." } , { ER_FRAG_INVALID_CHAR , "Fragment enthält ein ungültiges Zeichen." } , { ER_PARSER_IN_USE , "Der Parser wird bereits verwendet." } , { ER_CANNOT_CHANGE_WHILE_PARSING , "{0} {1} kann während der Syntaxanalyse nicht geändert werden." } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Selbstverursachung ist nicht zulässig." } , { ER_NO_USERINFO_IF_NO_HOST , "Benutzerinformationen können nicht angegeben werden, wenn der Host nicht angegeben wurde." } , { ER_NO_PORT_IF_NO_HOST , "Der Port kann nicht angegeben werden, wenn der Host nicht angegeben wurde." } , { ER_NO_QUERY_STRING_IN_PATH , "Abfragezeichenfolge kann nicht im Pfad und in der Abfragezeichenfolge angegeben werden." } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Fragment kann nicht im Pfad und im Fragment angegeben werden." } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "URI (Uniform Resource Identifier) kann nicht mit leeren Parametern initialisiert werden." } , { ER_METHOD_NOT_SUPPORTED , "Die Methode wird noch nicht unterstützt. " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter ist momentan nicht wieder anlauffähig." } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader nicht vor Anforderung startParse" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Achsentraversierer nicht unterstützt: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler erstellt ohne Druckausgabeprogramm!" } , { ER_SYSTEMID_UNKNOWN , "System-ID unbekannt" } , { ER_LOCATION_UNKNOWN , "Position des Fehlers unbekannt" } , { ER_PREFIX_MUST_RESOLVE , "Das Präfix muss in einen Namensbereich aufgelöst werden: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() wird nicht in XPathContext unterstützt!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Das Attribut child weist kein Eignerdokument auf!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Das Attribut child weist kein Eignerdokumentelement auf!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Warnung: Vor dem Dokumentelement kann kein Text ausgegeben werden!  Wird ignoriert..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Mehr als ein Root für ein Dokumentobjektmodell ist nicht möglich!" } , { ER_ARG_LOCALNAME_NULL , "Das Argument 'localName' ist Null." } , { ER_ARG_LOCALNAME_INVALID , "Der lokale Name (Localname) in QNAME muss ein gültiger NCName sein." } , { ER_ARG_PREFIX_INVALID , "Das Präfix in QNAME muss ein gültiger NCName sein." } , { "BAD_CODE" , "Der Parameter für createMessage lag außerhalb des gültigen Bereichs" } , { "FORMAT_FAILED" , "Während des Aufrufs von messageFormat wurde eine Ausnahmebedingung ausgelöst" } , { "line" , "Zeilennummer" } , { "column" , "Spaltennummer" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "Die Parallel-Seriell-Umsetzerklasse ''{0}'' implementiert org.xml.sax.ContentHandler nicht." } , { ER_RESOURCE_COULD_NOT_FIND , "Die Ressource [ {0} ] konnte nicht gefunden werden.\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "Die Ressource [ {0} ] konnte nicht geladen werden: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Puffergröße <=0" } , { ER_INVALID_UTF16_SURROGATE , "Ungültige UTF-16-Ersetzung festgestellt: {0} ?" } , { ER_OIERROR , "E/A-Fehler" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Attribut {0} kann nicht nach Kindknoten oder vor dem Erstellen eines Elements hinzugefügt werden.  Das Attribut wird ignoriert." } , { ER_NAMESPACE_PREFIX , "Der Namensbereich für Präfix ''{0}'' wurde nicht deklariert." } , { ER_STRAY_ATTRIBUTE , "Attribut ''{0}'' befindet sich nicht in einem Element." } , { ER_STRAY_NAMESPACE , "Namensbereichsdeklaration ''{0}''=''{1}'' befindet sich nicht in einem Element." } , { ER_COULD_NOT_LOAD_RESOURCE , "''{0}'' konnte nicht geladen werden (CLASSPATH prüfen); es werden die Standardwerte verwendet" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "Merkmaldatei ''{0}'' konnte für Ausgabemethode ''{1}'' nicht geladen werden (CLASSPATH prüfen)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NamedMethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . utils . XMLChar ; public final class Template extends TopLevelElement { private QName _name ; private QName _mode ; private Pattern _pattern ; private double _priority ; private int _position ; private boolean _disabled = false ; private boolean _compiled = false ; private boolean _simplified = false ; private boolean _isSimpleNamedTemplate = false ; private Vector _parameters = new Vector ( ) ; public boolean hasParams ( ) { return _parameters . size ( ) > 0 ; } public boolean isSimplified ( ) { return ( _simplified ) ; } public void setSimplified ( ) { _simplified = true ; } public boolean isSimpleNamedTemplate ( ) { return _isSimpleNamedTemplate ; } public void addParameter ( Param param ) { _parameters . addElement ( param ) ; } public Vector getParameters ( ) { return _parameters ; } public void disable ( ) { _disabled = true ; } public boolean disabled ( ) { return ( _disabled ) ; } public double getPriority ( ) { return _priority ; } public int getPosition ( ) { return ( _position ) ; } public boolean isNamed ( ) { return _name != null ; } public Pattern getPattern ( ) { return _pattern ; } public QName getName ( ) { return _name ; } public void setName ( QName qname ) { if ( _name == null ) _name = qname ; } public QName getModeName ( ) { return _mode ; } public int compareTo ( Object template ) { Template other = ( Template ) template ; if ( _priority > other . _priority ) return 1 ; else if ( _priority < other . _priority ) return - 1 ; else if ( _position > other . _position ) return 1 ; else if ( _position < other . _position ) return - 1 ; else return 0 ; } public void display ( int indent ) { Util . println ( '\n' ) ; indent ( indent ) ; if ( _name != null ) { indent ( indent ) ; Util . println ( "name = " + _name ) ; } else if ( _pattern != null ) { indent ( indent ) ; Util . println ( "match = " + _pattern . toString ( ) ) ; } if ( _mode != null ) { indent ( indent ) ; Util . println ( "mode = " + _mode ) ; } displayContents ( indent + IndentIncrement ) ; } private boolean resolveNamedTemplates ( Template other , Parser parser ) { if ( other == null ) return true ; SymbolTable stable = parser . getSymbolTable ( ) ; final int us = this . getImportPrecedence ( ) ; final int them = other . getImportPrecedence ( ) ; if ( us > them ) { other . disable ( ) ; return true ; } else if ( us < them ) { stable . addTemplate ( other ) ; this . disable ( ) ; return true ; } else { return false ; } } private Stylesheet _stylesheet = null ; public Stylesheet getStylesheet ( ) { return _stylesheet ; } public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; final String mode = getAttribute ( "mode" ) ; final String match = getAttribute ( "match" ) ; final String priority = getAttribute ( "priority" ) ; _stylesheet = super . getStylesheet ( ) ; if ( name . length ( ) > 0 ) { if ( ! XMLChar . isValidQName ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , name , this ) ; parser . reportError ( Constants . ERROR , err ) ; } _name = parser . getQNameIgnoreDefaultNs ( name ) ; } if ( mode . length ( ) > 0 ) { if ( ! XMLChar . isValidQName ( mode ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , mode , this ) ; parser . reportError ( Constants . ERROR , err ) ; } _mode = parser . getQNameIgnoreDefaultNs ( mode ) ; } if ( match . length ( ) > 0 ) { _pattern = parser . parsePattern ( this , "match" , null ) ; } if ( priority . length ( ) > 0 ) { _priority = Double . parseDouble ( priority ) ; } else { if ( _pattern != null ) _priority = _pattern . getPriority ( ) ; else _priority = Double . NaN ; } _position = parser . getTemplateIndex ( ) ; if ( _name != null ) { Template other = parser . getSymbolTable ( ) . addTemplate ( this ) ; if ( ! resolveNamedTemplates ( other , parser ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TEMPLATE_REDEF_ERR , _name , this ) ; parser . reportError ( Constants . ERROR , err ) ; } if ( _pattern == null && _mode == null ) { _isSimpleNamedTemplate = true ; } } if ( _parent instanceof Stylesheet ) { ( ( Stylesheet ) _parent ) . addTemplate ( this ) ; } parser . setTemplate ( this ) ; parseChildren ( parser ) ; parser . setTemplate ( null ) ; } public void parseSimplified ( Stylesheet stylesheet , Parser parser ) { _stylesheet = stylesheet ; setParent ( stylesheet ) ; _name = null ; _mode = null ; _priority = Double . NaN ; _pattern = parser . parsePattern ( this , "/" ) ; final Vector contents = _stylesheet . getContents ( ) ; final SyntaxTreeNode root = ( SyntaxTreeNode ) contents . elementAt ( 0 ) ; if ( root instanceof LiteralElement ) { addElement ( root ) ; root . setParent ( this ) ; contents . set ( 0 , this ) ; parser . setTemplate ( this ) ; root . parseContents ( parser ) ; parser . setTemplate ( null ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _pattern != null ) { _pattern . typeCheck ( stable ) ; } return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _disabled ) return ; String className = classGen . getClassName ( ) ; if ( _compiled && isNamed ( ) ) { String methodName = Util . escape ( _name . toString ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( className , methodName , "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + "I)V" ) ) ) ; return ; } if ( _compiled ) return ; _compiled = true ; if ( _isSimpleNamedTemplate && methodGen instanceof NamedMethodGenerator ) { int numParams = _parameters . size ( ) ; NamedMethodGenerator namedMethodGen = ( NamedMethodGenerator ) methodGen ; for ( int i = 0 ; i < numParams ; i ++ ) { Param param = ( Param ) _parameters . elementAt ( i ) ; param . setLoadInstruction ( namedMethodGen . loadParameter ( i ) ) ; param . setStoreInstruction ( namedMethodGen . storeParameter ( i ) ) ; } } translateContents ( classGen , methodGen ) ; il . setPositions ( true ) ; } } 	1	['25', '3', '0', '27', '85', '172', '10', '22', '24', '0.863636364', '589', '1', '4', '0.714285714', '0.141818182', '2', '8', '22.12', '13', '2.28', '1']
package org . apache . xml . utils . res ; public class XResources_sv extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "sv" } , { "help_language" , "sv" } , { "language" , "sv" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '314', '0', '0', '0.976190476', '1', '0', '0', '103.3333333', '1', '0.3333', '1']
package org . apache . xml . utils ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . w3c . dom . Attr ; import org . w3c . dom . CDATASection ; import org . w3c . dom . Comment ; import org . w3c . dom . DOMException ; import org . w3c . dom . DOMImplementation ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . EntityReference ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; public class UnImplNode implements Node , Element , NodeList , Document { public UnImplNode ( ) { } public void error ( String msg ) { System . out . println ( "DOM ERROR! class: " + this . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( XMLMessages . createXMLMessage ( msg , null ) ) ; } public void error ( String msg , Object [ ] args ) { System . out . println ( "DOM ERROR! class: " + this . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( XMLMessages . createXMLMessage ( msg , args ) ) ; } public Node appendChild ( Node newChild ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean hasChildNodes ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public short getNodeType ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return 0 ; } public Node getParentNode ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public NodeList getChildNodes ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node getFirstChild ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node getLastChild ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node getNextSibling ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public int getLength ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return 0 ; } public Node item ( int index ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Document getOwnerDocument ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getTagName ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getNodeName ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void normalize ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public NodeList getElementsByTagName ( String name ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr setAttributeNode ( Attr newAttr ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean hasAttribute ( String name ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public boolean hasAttributeNS ( String name , String x ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public Attr getAttributeNode ( String name ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void removeAttribute ( String name ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void setAttribute ( String name , String value ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String getAttribute ( String name ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean hasAttributes ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr getAttributeNodeNS ( String namespaceURI , String localName ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String getAttributeNS ( String namespaceURI , String localName ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node getPreviousSibling ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node cloneNode ( boolean deep ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getNodeValue ( ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setNodeValue ( String nodeValue ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void setValue ( String value ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public Element getOwnerElement ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean getSpecified ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public NamedNodeMap getAttributes ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node removeChild ( Node oldChild ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public boolean isSupported ( String feature , String version ) { return false ; } public String getNamespaceURI ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getPrefix ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setPrefix ( String prefix ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String getLocalName ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public DocumentType getDoctype ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public DOMImplementation getImplementation ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Element getDocumentElement ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Element createElement ( String tagName ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public DocumentFragment createDocumentFragment ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Text createTextNode ( String data ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Comment createComment ( String data ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public CDATASection createCDATASection ( String data ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr createAttribute ( String name ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public EntityReference createEntityReference ( String name ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node importNode ( Node importedNode , boolean deep ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Element getElementById ( String elementId ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setData ( String data ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String substringData ( int offset , int count ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void appendData ( String arg ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void insertData ( int offset , String arg ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void deleteData ( int offset , int count ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public void replaceData ( int offset , int count , String arg ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public Text splitText ( int offset ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public Node adoptNode ( Node source ) throws DOMException { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public String getEncoding ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setEncoding ( String encoding ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public boolean getStandalone ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public void setStandalone ( boolean standalone ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public boolean getStrictErrorChecking ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return false ; } public void setStrictErrorChecking ( boolean strictErrorChecking ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } public String getVersion ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } public void setVersion ( String version ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } } 	1	['107', '1', '1', '2', '117', '5671', '1', '1', '107', '2', '648', '0', '0', '0', '0.191069574', '0', '0', '5.056074766', '1', '0.9907', '1']
package org . apache . xml . serializer ; import javax . xml . transform . Transformer ; import org . w3c . dom . Node ; public interface TransformStateSetter { void setCurrentNode ( Node n ) ; void resetState ( Transformer transformer ) ; } 	1	['2', '1', '0', '4', '2', '1', '4', '0', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '1']
package org . apache . xpath . compiler ; import org . apache . xpath . Expression ; import org . apache . xpath . functions . Function ; public class FunctionTable { public static final int FUNC_CURRENT = 0 ; public static final int FUNC_LAST = 1 ; public static final int FUNC_POSITION = 2 ; public static final int FUNC_COUNT = 3 ; public static final int FUNC_ID = 4 ; public static final int FUNC_KEY = 5 ; public static final int FUNC_LOCAL_PART = 7 ; public static final int FUNC_NAMESPACE = 8 ; public static final int FUNC_QNAME = 9 ; public static final int FUNC_GENERATE_ID = 10 ; public static final int FUNC_NOT = 11 ; public static final int FUNC_TRUE = 12 ; public static final int FUNC_FALSE = 13 ; public static final int FUNC_BOOLEAN = 14 ; public static final int FUNC_NUMBER = 15 ; public static final int FUNC_FLOOR = 16 ; public static final int FUNC_CEILING = 17 ; public static final int FUNC_ROUND = 18 ; public static final int FUNC_SUM = 19 ; public static final int FUNC_STRING = 20 ; public static final int FUNC_STARTS_WITH = 21 ; public static final int FUNC_CONTAINS = 22 ; public static final int FUNC_SUBSTRING_BEFORE = 23 ; public static final int FUNC_SUBSTRING_AFTER = 24 ; public static final int FUNC_NORMALIZE_SPACE = 25 ; public static final int FUNC_TRANSLATE = 26 ; public static final int FUNC_CONCAT = 27 ; public static final int FUNC_SUBSTRING = 29 ; public static final int FUNC_STRING_LENGTH = 30 ; public static final int FUNC_SYSTEM_PROPERTY = 31 ; public static final int FUNC_LANG = 32 ; public static final int FUNC_EXT_FUNCTION_AVAILABLE = 33 ; public static final int FUNC_EXT_ELEM_AVAILABLE = 34 ; public static final int FUNC_UNPARSED_ENTITY_URI = 36 ; public static final int FUNC_DOCLOCATION = 35 ; public static FuncLoader m_functions [ ] ; private static final int NUM_BUILT_IN_FUNCS = 37 ; private static final int NUM_ALLOWABLE_ADDINS = 30 ; static int m_funcNextFreeIndex = NUM_BUILT_IN_FUNCS ; static { m_functions = new FuncLoader [ NUM_BUILT_IN_FUNCS + NUM_ALLOWABLE_ADDINS ] ; m_functions [ FUNC_CURRENT ] = new FuncLoader ( "FuncCurrent" , FUNC_CURRENT ) ; m_functions [ FUNC_LAST ] = new FuncLoader ( "FuncLast" , FUNC_LAST ) ; m_functions [ FUNC_POSITION ] = new FuncLoader ( "FuncPosition" , FUNC_POSITION ) ; m_functions [ FUNC_COUNT ] = new FuncLoader ( "FuncCount" , FUNC_COUNT ) ; m_functions [ FUNC_ID ] = new FuncLoader ( "FuncId" , FUNC_ID ) ; m_functions [ FUNC_KEY ] = new FuncLoader ( "org.apache.xalan.templates.FuncKey" , FUNC_KEY ) ; m_functions [ FUNC_LOCAL_PART ] = new FuncLoader ( "FuncLocalPart" , FUNC_LOCAL_PART ) ; m_functions [ FUNC_NAMESPACE ] = new FuncLoader ( "FuncNamespace" , FUNC_NAMESPACE ) ; m_functions [ FUNC_QNAME ] = new FuncLoader ( "FuncQname" , FUNC_QNAME ) ; m_functions [ FUNC_GENERATE_ID ] = new FuncLoader ( "FuncGenerateId" , FUNC_GENERATE_ID ) ; m_functions [ FUNC_NOT ] = new FuncLoader ( "FuncNot" , FUNC_NOT ) ; m_functions [ FUNC_TRUE ] = new FuncLoader ( "FuncTrue" , FUNC_TRUE ) ; m_functions [ FUNC_FALSE ] = new FuncLoader ( "FuncFalse" , FUNC_FALSE ) ; m_functions [ FUNC_BOOLEAN ] = new FuncLoader ( "FuncBoolean" , FUNC_BOOLEAN ) ; m_functions [ FUNC_LANG ] = new FuncLoader ( "FuncLang" , FUNC_LANG ) ; m_functions [ FUNC_NUMBER ] = new FuncLoader ( "FuncNumber" , FUNC_NUMBER ) ; m_functions [ FUNC_FLOOR ] = new FuncLoader ( "FuncFloor" , FUNC_FLOOR ) ; m_functions [ FUNC_CEILING ] = new FuncLoader ( "FuncCeiling" , FUNC_CEILING ) ; m_functions [ FUNC_ROUND ] = new FuncLoader ( "FuncRound" , FUNC_ROUND ) ; m_functions [ FUNC_SUM ] = new FuncLoader ( "FuncSum" , FUNC_SUM ) ; m_functions [ FUNC_STRING ] = new FuncLoader ( "FuncString" , FUNC_STRING ) ; m_functions [ FUNC_STARTS_WITH ] = new FuncLoader ( "FuncStartsWith" , FUNC_STARTS_WITH ) ; m_functions [ FUNC_CONTAINS ] = new FuncLoader ( "FuncContains" , FUNC_CONTAINS ) ; m_functions [ FUNC_SUBSTRING_BEFORE ] = new FuncLoader ( "FuncSubstringBefore" , FUNC_SUBSTRING_BEFORE ) ; m_functions [ FUNC_SUBSTRING_AFTER ] = new FuncLoader ( "FuncSubstringAfter" , FUNC_SUBSTRING_AFTER ) ; m_functions [ FUNC_NORMALIZE_SPACE ] = new FuncLoader ( "FuncNormalizeSpace" , FUNC_NORMALIZE_SPACE ) ; m_functions [ FUNC_TRANSLATE ] = new FuncLoader ( "FuncTranslate" , FUNC_TRANSLATE ) ; m_functions [ FUNC_CONCAT ] = new FuncLoader ( "FuncConcat" , FUNC_CONCAT ) ; m_functions [ FUNC_SYSTEM_PROPERTY ] = new FuncLoader ( "FuncSystemProperty" , FUNC_SYSTEM_PROPERTY ) ; m_functions [ FUNC_EXT_FUNCTION_AVAILABLE ] = new FuncLoader ( "FuncExtFunctionAvailable" , FUNC_EXT_FUNCTION_AVAILABLE ) ; m_functions [ FUNC_EXT_ELEM_AVAILABLE ] = new FuncLoader ( "FuncExtElementAvailable" , FUNC_EXT_ELEM_AVAILABLE ) ; m_functions [ FUNC_SUBSTRING ] = new FuncLoader ( "FuncSubstring" , FUNC_SUBSTRING ) ; m_functions [ FUNC_STRING_LENGTH ] = new FuncLoader ( "FuncStringLength" , FUNC_STRING_LENGTH ) ; m_functions [ FUNC_DOCLOCATION ] = new FuncLoader ( "FuncDoclocation" , FUNC_DOCLOCATION ) ; m_functions [ FUNC_UNPARSED_ENTITY_URI ] = new FuncLoader ( "FuncUnparsedEntityURI" , FUNC_UNPARSED_ENTITY_URI ) ; } public static Function getFunction ( int which ) throws javax . xml . transform . TransformerException { return m_functions [ which ] . getFunction ( ) ; } public static int installFunction ( String name , Expression func ) { int funcIndex ; Object funcIndexObj = Keywords . m_functions . get ( name ) ; if ( null != funcIndexObj ) { funcIndex = ( ( Integer ) funcIndexObj ) . intValue ( ) ; } else { funcIndex = m_funcNextFreeIndex ; m_funcNextFreeIndex ++ ; Keywords . m_functions . put ( name , new Integer ( funcIndex ) ) ; } FuncLoader loader = new FuncLoader ( func . getClass ( ) . getName ( ) , funcIndex ) ; m_functions [ funcIndex ] = loader ; return funcIndex ; } public static void installFunction ( Expression func , int funcIndex ) { FuncLoader loader = new FuncLoader ( func . getClass ( ) . getName ( ) , funcIndex ) ; m_functions [ funcIndex ] = loader ; } } 	1	['5', '1', '0', '7', '14', '0', '3', '4', '4', '1.211538462', '391', '0.051282051', '1', '0', '0.375', '0', '0', '69.4', '2', '0.8', '2']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . utils . XMLChar ; final class WithParam extends Instruction { private QName _name ; protected String _escapedName ; private Expression _select ; private boolean _doParameterOptimization = false ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "with-param " + _name ) ; if ( _select != null ) { indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; } displayContents ( indent + IndentIncrement ) ; } public String getEscapedName ( ) { return _escapedName ; } public QName getName ( ) { return _name ; } public void setName ( QName name ) { _name = name ; _escapedName = Util . escape ( name . getStringRep ( ) ) ; } public void setDoParameterOptimization ( boolean flag ) { _doParameterOptimization = flag ; } public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; if ( name . length ( ) > 0 ) { if ( ! XMLChar . isValidQName ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , name , this ) ; parser . reportError ( Constants . ERROR , err ) ; } setName ( parser . getQNameIgnoreDefaultNs ( name ) ) ; } else { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "name" ) ; } final String select = getAttribute ( "select" ) ; if ( select . length ( ) > 0 ) { _select = parser . parseExpression ( this , "select" , null ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _select != null ) { final Type tselect = _select . typeCheck ( stable ) ; if ( tselect instanceof ReferenceType == false ) { _select = new CastExpr ( _select , Type . Reference ) ; } } else { typeCheckContents ( stable ) ; } return Type . Void ; } public void translateValue ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _select != null ) { _select . translate ( classGen , methodGen ) ; _select . startIterator ( classGen , methodGen ) ; } else if ( hasContents ( ) ) { compileResultTree ( classGen , methodGen ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _doParameterOptimization ) { translateValue ( classGen , methodGen ) ; return ; } String name = Util . escape ( getEscapedName ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , name ) ) ; translateValue ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , false ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , ADD_PARAMETER , ADD_PARAMETER_SIG ) ) ) ; il . append ( POP ) ; } } 	1	['10', '3', '0', '24', '46', '19', '1', '23', '9', '0.666666667', '250', '1', '2', '0.861538462', '0.2375', '1', '7', '23.6', '4', '1.6', '1']
package org . apache . xpath . axes ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . FunctionTable ; import org . apache . xpath . compiler . OpCodes ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . patterns . ContextMatchStepPattern ; import org . apache . xpath . patterns . FunctionPattern ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xpath . res . XPATHErrorResources ; public class WalkerFactory { static AxesWalker loadOneWalker ( WalkingIterator lpi , Compiler compiler , int stepOpCodePos ) throws javax . xml . transform . TransformerException { AxesWalker firstWalker = null ; int stepType = compiler . getOp ( stepOpCodePos ) ; if ( stepType != OpCodes . ENDOP ) { firstWalker = createDefaultWalker ( compiler , stepType , lpi , 0 ) ; firstWalker . init ( compiler , stepOpCodePos , stepType ) ; } return firstWalker ; } static AxesWalker loadWalkers ( WalkingIterator lpi , Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; AxesWalker firstWalker = null ; AxesWalker walker , prevWalker = null ; int analysis = analyze ( compiler , stepOpCodePos , stepIndex ) ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { walker = createDefaultWalker ( compiler , stepOpCodePos , lpi , analysis ) ; walker . init ( compiler , stepOpCodePos , stepType ) ; walker . exprSetParent ( lpi ) ; if ( null == firstWalker ) { firstWalker = walker ; } else { prevWalker . setNextWalker ( walker ) ; walker . setPrevWalker ( prevWalker ) ; } prevWalker = walker ; stepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( stepOpCodePos < 0 ) break ; } return firstWalker ; } public static boolean isSet ( int analysis , int bits ) { return ( 0 != ( analysis & bits ) ) ; } public static void diagnoseIterator ( String name , int analysis , Compiler compiler ) { System . out . println ( compiler . toString ( ) + ", " + name + ", " + Integer . toBinaryString ( analysis ) + ", " + getAnalysisString ( analysis ) ) ; } public static DTMIterator newDTMIterator ( Compiler compiler , int opPos , boolean isTopLevel ) throws javax . xml . transform . TransformerException { int firstStepPos = compiler . getFirstChildPos ( opPos ) ; int analysis = analyze ( compiler , firstStepPos , 0 ) ; boolean isOneStep = isOneStep ( analysis ) ; DTMIterator iter ; if ( isOneStep && walksSelfOnly ( analysis ) && isWild ( analysis ) && ! hasPredicate ( analysis ) ) { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "SelfIteratorNoPredicate" , analysis , compiler ) ; iter = new SelfIteratorNoPredicate ( compiler , opPos , analysis ) ; } else if ( walksChildrenOnly ( analysis ) && isOneStep ) { if ( isWild ( analysis ) && ! hasPredicate ( analysis ) ) { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "ChildIterator" , analysis , compiler ) ; iter = new ChildIterator ( compiler , opPos , analysis ) ; } else { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "ChildTestIterator" , analysis , compiler ) ; iter = new ChildTestIterator ( compiler , opPos , analysis ) ; } } else if ( isOneStep && walksAttributes ( analysis ) ) { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "AttributeIterator" , analysis , compiler ) ; iter = new AttributeIterator ( compiler , opPos , analysis ) ; } else if ( isOneStep && ! walksFilteredList ( analysis ) ) { if ( ! walksNamespaces ( analysis ) && ( walksInDocOrder ( analysis ) || isSet ( analysis , BIT_PARENT ) ) ) { if ( false || DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "OneStepIteratorForward" , analysis , compiler ) ; iter = new OneStepIteratorForward ( compiler , opPos , analysis ) ; } else { if ( false || DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "OneStepIterator" , analysis , compiler ) ; iter = new OneStepIterator ( compiler , opPos , analysis ) ; } } else if ( isOptimizableForDescendantIterator ( compiler , firstStepPos , 0 ) ) { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "DescendantIterator" , analysis , compiler ) ; iter = new DescendantIterator ( compiler , opPos , analysis ) ; } else { if ( isNaturalDocOrder ( compiler , firstStepPos , 0 , analysis ) ) { if ( false || DEBUG_ITERATOR_CREATION ) { diagnoseIterator ( "WalkingIterator" , analysis , compiler ) ; } iter = new WalkingIterator ( compiler , opPos , analysis , true ) ; } else { if ( DEBUG_ITERATOR_CREATION ) diagnoseIterator ( "WalkingIteratorSorted" , analysis , compiler ) ; iter = new WalkingIteratorSorted ( compiler , opPos , analysis , true ) ; } } if ( iter instanceof LocPathIterator ) ( ( LocPathIterator ) iter ) . setIsTopLevel ( isTopLevel ) ; return iter ; } public static int getAxisFromStep ( Compiler compiler , int stepOpCodePos ) throws javax . xml . transform . TransformerException { int stepType = compiler . getOp ( stepOpCodePos ) ; switch ( stepType ) { case OpCodes . FROM_FOLLOWING : return Axis . FOLLOWING ; case OpCodes . FROM_FOLLOWING_SIBLINGS : return Axis . FOLLOWINGSIBLING ; case OpCodes . FROM_PRECEDING : return Axis . PRECEDING ; case OpCodes . FROM_PRECEDING_SIBLINGS : return Axis . PRECEDINGSIBLING ; case OpCodes . FROM_PARENT : return Axis . PARENT ; case OpCodes . FROM_NAMESPACE : return Axis . NAMESPACE ; case OpCodes . FROM_ANCESTORS : return Axis . ANCESTOR ; case OpCodes . FROM_ANCESTORS_OR_SELF : return Axis . ANCESTORORSELF ; case OpCodes . FROM_ATTRIBUTES : return Axis . ATTRIBUTE ; case OpCodes . FROM_ROOT : return Axis . ROOT ; case OpCodes . FROM_CHILDREN : return Axis . CHILD ; case OpCodes . FROM_DESCENDANTS_OR_SELF : return Axis . DESCENDANTORSELF ; case OpCodes . FROM_DESCENDANTS : return Axis . DESCENDANT ; case OpCodes . FROM_SELF : return Axis . SELF ; case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : case OpCodes . OP_VARIABLE : return Axis . FILTEREDLIST ; } throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } static public int getAnalysisBitFromAxes ( int axis ) { switch ( axis ) { case Axis . ANCESTOR : return BIT_ANCESTOR ; case Axis . ANCESTORORSELF : return BIT_ANCESTOR_OR_SELF ; case Axis . ATTRIBUTE : return BIT_ATTRIBUTE ; case Axis . CHILD : return BIT_CHILD ; case Axis . DESCENDANT : return BIT_DESCENDANT ; case Axis . DESCENDANTORSELF : return BIT_DESCENDANT_OR_SELF ; case Axis . FOLLOWING : return BIT_FOLLOWING ; case Axis . FOLLOWINGSIBLING : return BIT_FOLLOWING_SIBLING ; case Axis . NAMESPACE : case Axis . NAMESPACEDECLS : return BIT_NAMESPACE ; case Axis . PARENT : return BIT_PARENT ; case Axis . PRECEDING : return BIT_PRECEDING ; case Axis . PRECEDINGSIBLING : return BIT_PRECEDING_SIBLING ; case Axis . SELF : return BIT_SELF ; case Axis . ALLFROMNODE : return BIT_DESCENDANT_OR_SELF ; case Axis . DESCENDANTSFROMROOT : case Axis . ALL : case Axis . DESCENDANTSORSELFFROMROOT : return BIT_ANY_DESCENDANT_FROM_ROOT ; case Axis . ROOT : return BIT_ROOT ; case Axis . FILTEREDLIST : return BIT_FILTER ; default : return BIT_FILTER ; } } static boolean functionProximateOrContainsProximate ( Compiler compiler , int opPos ) { int endFunc = opPos + compiler . getOp ( opPos + 1 ) - 1 ; opPos = compiler . getFirstChildPos ( opPos ) ; int funcID = compiler . getOp ( opPos ) ; switch ( funcID ) { case FunctionTable . FUNC_LAST : case FunctionTable . FUNC_POSITION : return true ; default : opPos ++ ; int i = 0 ; for ( int p = opPos ; p < endFunc ; p = compiler . getNextOpPos ( p ) , i ++ ) { int innerExprOpPos = p + 2 ; int argOp = compiler . getOp ( innerExprOpPos ) ; boolean prox = isProximateInnerExpr ( compiler , innerExprOpPos ) ; if ( prox ) return true ; } } return false ; } static boolean isProximateInnerExpr ( Compiler compiler , int opPos ) { int op = compiler . getOp ( opPos ) ; int innerExprOpPos = opPos + 2 ; switch ( op ) { case OpCodes . OP_ARGUMENT : if ( isProximateInnerExpr ( compiler , innerExprOpPos ) ) return true ; break ; case OpCodes . OP_VARIABLE : case OpCodes . OP_NUMBERLIT : case OpCodes . OP_LITERAL : case OpCodes . OP_LOCATIONPATH : break ; case OpCodes . OP_FUNCTION : boolean isProx = functionProximateOrContainsProximate ( compiler , opPos ) ; if ( isProx ) return true ; break ; case OpCodes . OP_GT : case OpCodes . OP_GTE : case OpCodes . OP_LT : case OpCodes . OP_LTE : case OpCodes . OP_EQUALS : int leftPos = compiler . getFirstChildPos ( op ) ; int rightPos = compiler . getNextOpPos ( leftPos ) ; isProx = isProximateInnerExpr ( compiler , leftPos ) ; if ( isProx ) return true ; isProx = isProximateInnerExpr ( compiler , rightPos ) ; if ( isProx ) return true ; break ; default : return true ; } return false ; } public static boolean mightBeProximate ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { boolean mightBeProximate = false ; int argLen ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : argLen = compiler . getArgLength ( opPos ) ; break ; default : argLen = compiler . getArgLengthOfStep ( opPos ) ; } int predPos = compiler . getFirstPredicateOpPos ( opPos ) ; int count = 0 ; while ( OpCodes . OP_PREDICATE == compiler . getOp ( predPos ) ) { count ++ ; int innerExprOpPos = predPos + 2 ; int predOp = compiler . getOp ( innerExprOpPos ) ; switch ( predOp ) { case OpCodes . OP_VARIABLE : return true ; case OpCodes . OP_LOCATIONPATH : break ; case OpCodes . OP_NUMBER : case OpCodes . OP_NUMBERLIT : return true ; case OpCodes . OP_FUNCTION : boolean isProx = functionProximateOrContainsProximate ( compiler , innerExprOpPos ) ; if ( isProx ) return true ; break ; case OpCodes . OP_GT : case OpCodes . OP_GTE : case OpCodes . OP_LT : case OpCodes . OP_LTE : case OpCodes . OP_EQUALS : int leftPos = compiler . getFirstChildPos ( innerExprOpPos ) ; int rightPos = compiler . getNextOpPos ( leftPos ) ; isProx = isProximateInnerExpr ( compiler , leftPos ) ; if ( isProx ) return true ; isProx = isProximateInnerExpr ( compiler , rightPos ) ; if ( isProx ) return true ; break ; default : return true ; } predPos = compiler . getNextOpPos ( predPos ) ; } return mightBeProximate ; } private static boolean isOptimizableForDescendantIterator ( Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; int stepCount = 0 ; boolean foundDorDS = false ; boolean foundSelf = false ; boolean foundDS = false ; int nodeTestType = OpCodes . NODETYPE_NODE ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { if ( nodeTestType != OpCodes . NODETYPE_NODE && nodeTestType != OpCodes . NODETYPE_ROOT ) return false ; stepCount ++ ; if ( stepCount > 3 ) return false ; boolean mightBeProximate = mightBeProximate ( compiler , stepOpCodePos , stepType ) ; if ( mightBeProximate ) return false ; switch ( stepType ) { case OpCodes . FROM_FOLLOWING : case OpCodes . FROM_FOLLOWING_SIBLINGS : case OpCodes . FROM_PRECEDING : case OpCodes . FROM_PRECEDING_SIBLINGS : case OpCodes . FROM_PARENT : case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : case OpCodes . FROM_NAMESPACE : case OpCodes . FROM_ANCESTORS : case OpCodes . FROM_ANCESTORS_OR_SELF : case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : case OpCodes . MATCH_ANY_ANCESTOR : case OpCodes . MATCH_IMMEDIATE_ANCESTOR : return false ; case OpCodes . FROM_ROOT : if ( 1 != stepCount ) return false ; break ; case OpCodes . FROM_CHILDREN : if ( ! foundDS && ! ( foundDorDS && foundSelf ) ) return false ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : foundDS = true ; case OpCodes . FROM_DESCENDANTS : if ( 3 == stepCount ) return false ; foundDorDS = true ; break ; case OpCodes . FROM_SELF : if ( 1 != stepCount ) return false ; foundSelf = true ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } nodeTestType = compiler . getStepTestType ( stepOpCodePos ) ; int nextStepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( nextStepOpCodePos < 0 ) break ; if ( OpCodes . ENDOP != compiler . getOp ( nextStepOpCodePos ) ) { if ( compiler . countPredicates ( stepOpCodePos ) > 0 ) { return false ; } } stepOpCodePos = nextStepOpCodePos ; } return true ; } private static int analyze ( Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; int stepCount = 0 ; int analysisResult = 0x00000000 ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { stepCount ++ ; boolean predAnalysis = analyzePredicate ( compiler , stepOpCodePos , stepType ) ; if ( predAnalysis ) analysisResult |= BIT_PREDICATE ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : analysisResult |= BIT_FILTER ; break ; case OpCodes . FROM_ROOT : analysisResult |= BIT_ROOT ; break ; case OpCodes . FROM_ANCESTORS : analysisResult |= BIT_ANCESTOR ; break ; case OpCodes . FROM_ANCESTORS_OR_SELF : analysisResult |= BIT_ANCESTOR_OR_SELF ; break ; case OpCodes . FROM_ATTRIBUTES : analysisResult |= BIT_ATTRIBUTE ; break ; case OpCodes . FROM_NAMESPACE : analysisResult |= BIT_NAMESPACE ; break ; case OpCodes . FROM_CHILDREN : analysisResult |= BIT_CHILD ; break ; case OpCodes . FROM_DESCENDANTS : analysisResult |= BIT_DESCENDANT ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : if ( 2 == stepCount && BIT_ROOT == analysisResult ) { analysisResult |= BIT_ANY_DESCENDANT_FROM_ROOT ; } analysisResult |= BIT_DESCENDANT_OR_SELF ; break ; case OpCodes . FROM_FOLLOWING : analysisResult |= BIT_FOLLOWING ; break ; case OpCodes . FROM_FOLLOWING_SIBLINGS : analysisResult |= BIT_FOLLOWING_SIBLING ; break ; case OpCodes . FROM_PRECEDING : analysisResult |= BIT_PRECEDING ; break ; case OpCodes . FROM_PRECEDING_SIBLINGS : analysisResult |= BIT_PRECEDING_SIBLING ; break ; case OpCodes . FROM_PARENT : analysisResult |= BIT_PARENT ; break ; case OpCodes . FROM_SELF : analysisResult |= BIT_SELF ; break ; case OpCodes . MATCH_ATTRIBUTE : analysisResult |= ( BIT_MATCH_PATTERN | BIT_ATTRIBUTE ) ; break ; case OpCodes . MATCH_ANY_ANCESTOR : analysisResult |= ( BIT_MATCH_PATTERN | BIT_ANCESTOR ) ; break ; case OpCodes . MATCH_IMMEDIATE_ANCESTOR : analysisResult |= ( BIT_MATCH_PATTERN | BIT_PARENT ) ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } if ( OpCodes . NODETYPE_NODE == compiler . getOp ( stepOpCodePos + 3 ) ) { analysisResult |= BIT_NODETEST_ANY ; } stepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( stepOpCodePos < 0 ) break ; } analysisResult |= ( stepCount & BITS_COUNT ) ; return analysisResult ; } public static boolean isDownwardAxisOfMany ( int axis ) { return ( ( Axis . DESCENDANTORSELF == axis ) || ( Axis . DESCENDANT == axis ) || ( Axis . FOLLOWING == axis ) || ( Axis . PRECEDING == axis ) ) ; } static StepPattern loadSteps ( MatchPatternIterator mpi , Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { if ( DEBUG_PATTERN_CREATION ) { System . out . println ( "================" ) ; System . out . println ( "loadSteps for: " + compiler . getPatternString ( ) ) ; } int stepType ; StepPattern step = null ; StepPattern firstStep = null , prevStep = null ; int analysis = analyze ( compiler , stepOpCodePos , stepIndex ) ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { step = createDefaultStepPattern ( compiler , stepOpCodePos , mpi , analysis , firstStep , prevStep ) ; if ( null == firstStep ) { firstStep = step ; } else { step . setRelativePathPattern ( prevStep ) ; } prevStep = step ; stepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( stepOpCodePos < 0 ) break ; } int axis = Axis . SELF ; int paxis = Axis . SELF ; StepPattern tail = step ; for ( StepPattern pat = step ; null != pat ; pat = pat . getRelativePathPattern ( ) ) { int nextAxis = pat . getAxis ( ) ; pat . setAxis ( axis ) ; int whatToShow = pat . getWhatToShow ( ) ; if ( whatToShow == DTMFilter . SHOW_ATTRIBUTE || whatToShow == DTMFilter . SHOW_NAMESPACE ) { int newAxis = ( whatToShow == DTMFilter . SHOW_ATTRIBUTE ) ? Axis . ATTRIBUTE : Axis . NAMESPACE ; if ( isDownwardAxisOfMany ( axis ) ) { StepPattern attrPat = new StepPattern ( whatToShow , pat . getNamespace ( ) , pat . getLocalName ( ) , newAxis , 0 ) ; XNumber score = pat . getStaticScore ( ) ; pat . setNamespace ( null ) ; pat . setLocalName ( NodeTest . WILD ) ; attrPat . setPredicates ( pat . getPredicates ( ) ) ; pat . setPredicates ( null ) ; pat . setWhatToShow ( DTMFilter . SHOW_ELEMENT ) ; StepPattern rel = pat . getRelativePathPattern ( ) ; pat . setRelativePathPattern ( attrPat ) ; attrPat . setRelativePathPattern ( rel ) ; attrPat . setStaticScore ( score ) ; if ( Axis . PRECEDING == pat . getAxis ( ) ) pat . setAxis ( Axis . PRECEDINGANDANCESTOR ) ; else if ( Axis . DESCENDANT == pat . getAxis ( ) ) pat . setAxis ( Axis . DESCENDANTORSELF ) ; pat = attrPat ; } else if ( Axis . CHILD == pat . getAxis ( ) ) { pat . setAxis ( Axis . ATTRIBUTE ) ; } } axis = nextAxis ; tail = pat ; } if ( axis < Axis . ALL ) { StepPattern selfPattern = new ContextMatchStepPattern ( axis , paxis ) ; XNumber score = tail . getStaticScore ( ) ; tail . setRelativePathPattern ( selfPattern ) ; tail . setStaticScore ( score ) ; selfPattern . setStaticScore ( score ) ; } if ( DEBUG_PATTERN_CREATION ) { System . out . println ( "Done loading steps: " + step . toString ( ) ) ; System . out . println ( "" ) ; } return step ; } private static StepPattern createDefaultStepPattern ( Compiler compiler , int opPos , MatchPatternIterator mpi , int analysis , StepPattern tail , StepPattern head ) throws javax . xml . transform . TransformerException { int stepType = compiler . getOp ( opPos ) ; boolean simpleInit = false ; int totalNumberWalkers = ( analysis & BITS_COUNT ) ; boolean prevIsOneStepDown = true ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; int whatToShow = compiler . getWhatToShow ( opPos ) ; StepPattern ai = null ; int axis , predicateAxis ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : prevIsOneStepDown = false ; Expression expr ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : expr = compiler . compile ( opPos ) ; break ; default : expr = compiler . compile ( opPos + 2 ) ; } axis = Axis . FILTEREDLIST ; predicateAxis = Axis . FILTEREDLIST ; ai = new FunctionPattern ( expr , axis , predicateAxis ) ; simpleInit = true ; break ; case OpCodes . FROM_ROOT : whatToShow = DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT ; axis = Axis . ROOT ; predicateAxis = Axis . ROOT ; ai = new StepPattern ( DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT , axis , predicateAxis ) ; break ; case OpCodes . FROM_ATTRIBUTES : whatToShow = DTMFilter . SHOW_ATTRIBUTE ; axis = Axis . PARENT ; predicateAxis = Axis . ATTRIBUTE ; break ; case OpCodes . FROM_NAMESPACE : whatToShow = DTMFilter . SHOW_NAMESPACE ; axis = Axis . PARENT ; predicateAxis = Axis . NAMESPACE ; break ; case OpCodes . FROM_ANCESTORS : axis = Axis . DESCENDANT ; predicateAxis = Axis . ANCESTOR ; break ; case OpCodes . FROM_CHILDREN : axis = Axis . PARENT ; predicateAxis = Axis . CHILD ; break ; case OpCodes . FROM_ANCESTORS_OR_SELF : axis = Axis . DESCENDANTORSELF ; predicateAxis = Axis . ANCESTORORSELF ; break ; case OpCodes . FROM_SELF : axis = Axis . SELF ; predicateAxis = Axis . SELF ; break ; case OpCodes . FROM_PARENT : axis = Axis . CHILD ; predicateAxis = Axis . PARENT ; break ; case OpCodes . FROM_PRECEDING_SIBLINGS : axis = Axis . FOLLOWINGSIBLING ; predicateAxis = Axis . PRECEDINGSIBLING ; break ; case OpCodes . FROM_PRECEDING : axis = Axis . FOLLOWING ; predicateAxis = Axis . PRECEDING ; break ; case OpCodes . FROM_FOLLOWING_SIBLINGS : axis = Axis . PRECEDINGSIBLING ; predicateAxis = Axis . FOLLOWINGSIBLING ; break ; case OpCodes . FROM_FOLLOWING : axis = Axis . PRECEDING ; predicateAxis = Axis . FOLLOWING ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : axis = Axis . ANCESTORORSELF ; predicateAxis = Axis . DESCENDANTORSELF ; break ; case OpCodes . FROM_DESCENDANTS : axis = Axis . ANCESTOR ; predicateAxis = Axis . DESCENDANT ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } if ( null == ai ) { whatToShow = compiler . getWhatToShow ( opPos ) ; ai = new StepPattern ( whatToShow , compiler . getStepNS ( opPos ) , compiler . getStepLocalName ( opPos ) , axis , predicateAxis ) ; } if ( false || DEBUG_PATTERN_CREATION ) { System . out . print ( "new step: " + ai ) ; System . out . print ( ", axis: " + Axis . names [ ai . getAxis ( ) ] ) ; System . out . print ( ", predAxis: " + Axis . names [ ai . getAxis ( ) ] ) ; System . out . print ( ", what: " ) ; System . out . print ( "    " ) ; ai . debugWhatToShow ( ai . getWhatToShow ( ) ) ; } int argLen = compiler . getFirstPredicateOpPos ( opPos ) ; ai . setPredicates ( compiler . getCompiledPredicates ( argLen ) ) ; return ai ; } static boolean analyzePredicate ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { int argLen ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : argLen = compiler . getArgLength ( opPos ) ; break ; default : argLen = compiler . getArgLengthOfStep ( opPos ) ; } int pos = compiler . getFirstPredicateOpPos ( opPos ) ; int nPredicates = compiler . countPredicates ( pos ) ; return ( nPredicates > 0 ) ? true : false ; } private static AxesWalker createDefaultWalker ( Compiler compiler , int opPos , WalkingIterator lpi , int analysis ) { AxesWalker ai = null ; int stepType = compiler . getOp ( opPos ) ; boolean simpleInit = false ; int totalNumberWalkers = ( analysis & BITS_COUNT ) ; boolean prevIsOneStepDown = true ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : prevIsOneStepDown = false ; if ( DEBUG_WALKER_CREATION ) System . out . println ( "new walker:  FilterExprWalker: " + analysis + ", " + compiler . toString ( ) ) ; ai = new FilterExprWalker ( lpi ) ; simpleInit = true ; break ; case OpCodes . FROM_ROOT : ai = new AxesWalker ( lpi , Axis . ROOT ) ; break ; case OpCodes . FROM_ANCESTORS : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . ANCESTOR ) ; break ; case OpCodes . FROM_ANCESTORS_OR_SELF : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . ANCESTORORSELF ) ; break ; case OpCodes . FROM_ATTRIBUTES : ai = new AxesWalker ( lpi , Axis . ATTRIBUTE ) ; break ; case OpCodes . FROM_NAMESPACE : ai = new AxesWalker ( lpi , Axis . NAMESPACE ) ; break ; case OpCodes . FROM_CHILDREN : ai = new AxesWalker ( lpi , Axis . CHILD ) ; break ; case OpCodes . FROM_DESCENDANTS : prevIsOneStepDown = false ; ai = new AxesWalker ( lpi , Axis . DESCENDANT ) ; break ; case OpCodes . FROM_DESCENDANTS_OR_SELF : prevIsOneStepDown = false ; ai = new AxesWalker ( lpi , Axis . DESCENDANTORSELF ) ; break ; case OpCodes . FROM_FOLLOWING : prevIsOneStepDown = false ; ai = new AxesWalker ( lpi , Axis . FOLLOWING ) ; break ; case OpCodes . FROM_FOLLOWING_SIBLINGS : prevIsOneStepDown = false ; ai = new AxesWalker ( lpi , Axis . FOLLOWINGSIBLING ) ; break ; case OpCodes . FROM_PRECEDING : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . PRECEDING ) ; break ; case OpCodes . FROM_PRECEDING_SIBLINGS : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . PRECEDINGSIBLING ) ; break ; case OpCodes . FROM_PARENT : prevIsOneStepDown = false ; ai = new ReverseAxesWalker ( lpi , Axis . PARENT ) ; break ; case OpCodes . FROM_SELF : ai = new AxesWalker ( lpi , Axis . SELF ) ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } if ( simpleInit ) { ai . initNodeTest ( DTMFilter . SHOW_ALL ) ; } else { int whatToShow = compiler . getWhatToShow ( opPos ) ; if ( ( 0 == ( whatToShow & ( DTMFilter . SHOW_ATTRIBUTE | DTMFilter . SHOW_NAMESPACE | DTMFilter . SHOW_ELEMENT | DTMFilter . SHOW_PROCESSING_INSTRUCTION ) ) ) || ( whatToShow == DTMFilter . SHOW_ALL ) ) ai . initNodeTest ( whatToShow ) ; else { ai . initNodeTest ( whatToShow , compiler . getStepNS ( opPos ) , compiler . getStepLocalName ( opPos ) ) ; } } return ai ; } public static String getAnalysisString ( int analysis ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "count: " + getStepCount ( analysis ) + " " ) ; if ( ( analysis & BIT_NODETEST_ANY ) != 0 ) { buf . append ( "NTANY|" ) ; } if ( ( analysis & BIT_PREDICATE ) != 0 ) { buf . append ( "PRED|" ) ; } if ( ( analysis & BIT_ANCESTOR ) != 0 ) { buf . append ( "ANC|" ) ; } if ( ( analysis & BIT_ANCESTOR_OR_SELF ) != 0 ) { buf . append ( "ANCOS|" ) ; } if ( ( analysis & BIT_ATTRIBUTE ) != 0 ) { buf . append ( "ATTR|" ) ; } if ( ( analysis & BIT_CHILD ) != 0 ) { buf . append ( "CH|" ) ; } if ( ( analysis & BIT_DESCENDANT ) != 0 ) { buf . append ( "DESC|" ) ; } if ( ( analysis & BIT_DESCENDANT_OR_SELF ) != 0 ) { buf . append ( "DESCOS|" ) ; } if ( ( analysis & BIT_FOLLOWING ) != 0 ) { buf . append ( "FOL|" ) ; } if ( ( analysis & BIT_FOLLOWING_SIBLING ) != 0 ) { buf . append ( "FOLS|" ) ; } if ( ( analysis & BIT_NAMESPACE ) != 0 ) { buf . append ( "NS|" ) ; } if ( ( analysis & BIT_PARENT ) != 0 ) { buf . append ( "P|" ) ; } if ( ( analysis & BIT_PRECEDING ) != 0 ) { buf . append ( "PREC|" ) ; } if ( ( analysis & BIT_PRECEDING_SIBLING ) != 0 ) { buf . append ( "PRECS|" ) ; } if ( ( analysis & BIT_SELF ) != 0 ) { buf . append ( ".|" ) ; } if ( ( analysis & BIT_FILTER ) != 0 ) { buf . append ( "FLT|" ) ; } if ( ( analysis & BIT_ROOT ) != 0 ) { buf . append ( "R|" ) ; } return buf . toString ( ) ; } static final boolean DEBUG_PATTERN_CREATION = false ; static final boolean DEBUG_WALKER_CREATION = false ; static final boolean DEBUG_ITERATOR_CREATION = false ; public static boolean hasPredicate ( int analysis ) { return ( 0 != ( analysis & BIT_PREDICATE ) ) ; } public static boolean isWild ( int analysis ) { return ( 0 != ( analysis & BIT_NODETEST_ANY ) ) ; } public static boolean walksAncestors ( int analysis ) { return isSet ( analysis , BIT_ANCESTOR | BIT_ANCESTOR_OR_SELF ) ; } public static boolean walksAttributes ( int analysis ) { return ( 0 != ( analysis & BIT_ATTRIBUTE ) ) ; } public static boolean walksNamespaces ( int analysis ) { return ( 0 != ( analysis & BIT_NAMESPACE ) ) ; } public static boolean walksChildren ( int analysis ) { return ( 0 != ( analysis & BIT_CHILD ) ) ; } public static boolean walksDescendants ( int analysis ) { return isSet ( analysis , BIT_DESCENDANT | BIT_DESCENDANT_OR_SELF ) ; } public static boolean walksSubtree ( int analysis ) { return isSet ( analysis , BIT_DESCENDANT | BIT_DESCENDANT_OR_SELF | BIT_CHILD ) ; } public static boolean walksSubtreeOnlyMaybeAbsolute ( int analysis ) { return walksSubtree ( analysis ) && ! walksExtraNodes ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) ; } public static boolean walksSubtreeOnly ( int analysis ) { return walksSubtreeOnlyMaybeAbsolute ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean walksFilteredList ( int analysis ) { return isSet ( analysis , BIT_FILTER ) ; } public static boolean walksSubtreeOnlyFromRootOrContext ( int analysis ) { return walksSubtree ( analysis ) && ! walksExtraNodes ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isSet ( analysis , BIT_FILTER ) ; } public static boolean walksInDocOrder ( int analysis ) { return ( walksSubtreeOnlyMaybeAbsolute ( analysis ) || walksExtraNodesOnly ( analysis ) || walksFollowingOnlyMaybeAbsolute ( analysis ) ) && ! isSet ( analysis , BIT_FILTER ) ; } public static boolean walksFollowingOnlyMaybeAbsolute ( int analysis ) { return isSet ( analysis , BIT_SELF | BIT_FOLLOWING_SIBLING | BIT_FOLLOWING ) && ! walksSubtree ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) ; } public static boolean walksUp ( int analysis ) { return isSet ( analysis , BIT_PARENT | BIT_ANCESTOR | BIT_ANCESTOR_OR_SELF ) ; } public static boolean walksSideways ( int analysis ) { return isSet ( analysis , BIT_FOLLOWING | BIT_FOLLOWING_SIBLING | BIT_PRECEDING | BIT_PRECEDING_SIBLING ) ; } public static boolean walksExtraNodes ( int analysis ) { return isSet ( analysis , BIT_NAMESPACE | BIT_ATTRIBUTE ) ; } public static boolean walksExtraNodesOnly ( int analysis ) { return walksExtraNodes ( analysis ) && ! isSet ( analysis , BIT_SELF ) && ! walksSubtree ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean isAbsolute ( int analysis ) { return isSet ( analysis , BIT_ROOT | BIT_FILTER ) ; } public static boolean walksChildrenOnly ( int analysis ) { return walksChildren ( analysis ) && ! isSet ( analysis , BIT_SELF ) && ! walksExtraNodes ( analysis ) && ! walksDescendants ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ( ! isAbsolute ( analysis ) || isSet ( analysis , BIT_ROOT ) ) ; } public static boolean walksChildrenAndExtraAndSelfOnly ( int analysis ) { return walksChildren ( analysis ) && ! walksDescendants ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ( ! isAbsolute ( analysis ) || isSet ( analysis , BIT_ROOT ) ) ; } public static boolean walksDescendantsAndExtraAndSelfOnly ( int analysis ) { return ! walksChildren ( analysis ) && walksDescendants ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ( ! isAbsolute ( analysis ) || isSet ( analysis , BIT_ROOT ) ) ; } public static boolean walksSelfOnly ( int analysis ) { return isSet ( analysis , BIT_SELF ) && ! walksSubtree ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean walksUpOnly ( int analysis ) { return ! walksSubtree ( analysis ) && walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean walksDownOnly ( int analysis ) { return walksSubtree ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean walksDownExtraOnly ( int analysis ) { return walksSubtree ( analysis ) && walksExtraNodes ( analysis ) && ! walksUp ( analysis ) && ! walksSideways ( analysis ) && ! isAbsolute ( analysis ) ; } public static boolean canSkipSubtrees ( int analysis ) { return isSet ( analysis , BIT_CHILD ) | walksSideways ( analysis ) ; } public static boolean canCrissCross ( int analysis ) { if ( walksSelfOnly ( analysis ) ) return false ; else if ( walksDownOnly ( analysis ) && ! canSkipSubtrees ( analysis ) ) return false ; else if ( walksChildrenAndExtraAndSelfOnly ( analysis ) ) return false ; else if ( walksDescendantsAndExtraAndSelfOnly ( analysis ) ) return false ; else if ( walksUpOnly ( analysis ) ) return false ; else if ( walksExtraNodesOnly ( analysis ) ) return false ; else if ( walksSubtree ( analysis ) && ( walksSideways ( analysis ) || walksUp ( analysis ) || canSkipSubtrees ( analysis ) ) ) return true ; else return false ; } static public boolean isNaturalDocOrder ( int analysis ) { if ( canCrissCross ( analysis ) || isSet ( analysis , BIT_NAMESPACE ) || walksFilteredList ( analysis ) ) return false ; if ( walksInDocOrder ( analysis ) ) return true ; return false ; } private static boolean isNaturalDocOrder ( Compiler compiler , int stepOpCodePos , int stepIndex , int analysis ) throws javax . xml . transform . TransformerException { if ( canCrissCross ( analysis ) ) return false ; if ( isSet ( analysis , BIT_NAMESPACE ) ) return false ; if ( isSet ( analysis , BIT_FOLLOWING | BIT_FOLLOWING_SIBLING ) && isSet ( analysis , BIT_PRECEDING | BIT_PRECEDING_SIBLING ) ) return false ; int stepType ; int stepCount = 0 ; boolean foundWildAttribute = false ; int potentialDuplicateMakingStepCount = 0 ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { stepCount ++ ; switch ( stepType ) { case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : if ( foundWildAttribute ) return false ; String localName = compiler . getStepLocalName ( stepOpCodePos ) ; if ( localName . equals ( "*" ) ) { foundWildAttribute = true ; } break ; case OpCodes . FROM_FOLLOWING : case OpCodes . FROM_FOLLOWING_SIBLINGS : case OpCodes . FROM_PRECEDING : case OpCodes . FROM_PRECEDING_SIBLINGS : case OpCodes . FROM_PARENT : case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : case OpCodes . FROM_NAMESPACE : case OpCodes . FROM_ANCESTORS : case OpCodes . FROM_ANCESTORS_OR_SELF : case OpCodes . MATCH_ANY_ANCESTOR : case OpCodes . MATCH_IMMEDIATE_ANCESTOR : case OpCodes . FROM_DESCENDANTS_OR_SELF : case OpCodes . FROM_DESCENDANTS : if ( potentialDuplicateMakingStepCount > 0 ) return false ; potentialDuplicateMakingStepCount ++ ; case OpCodes . FROM_ROOT : case OpCodes . FROM_CHILDREN : case OpCodes . FROM_SELF : if ( foundWildAttribute ) return false ; break ; default : throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , new Object [ ] { Integer . toString ( stepType ) } ) ) ; } int nextStepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( nextStepOpCodePos < 0 ) break ; stepOpCodePos = nextStepOpCodePos ; } return true ; } public static boolean isOneStep ( int analysis ) { return ( analysis & BITS_COUNT ) == 0x00000001 ; } public static int getStepCount ( int analysis ) { return ( analysis & BITS_COUNT ) ; } public static final int BITS_COUNT = 0x000000FF ; public static final int BITS_RESERVED = 0x00000F00 ; public static final int BIT_PREDICATE = ( 0x00001000 ) ; public static final int BIT_ANCESTOR = ( 0x00001000 << 1 ) ; public static final int BIT_ANCESTOR_OR_SELF = ( 0x00001000 << 2 ) ; public static final int BIT_ATTRIBUTE = ( 0x00001000 << 3 ) ; public static final int BIT_CHILD = ( 0x00001000 << 4 ) ; public static final int BIT_DESCENDANT = ( 0x00001000 << 5 ) ; public static final int BIT_DESCENDANT_OR_SELF = ( 0x00001000 << 6 ) ; public static final int BIT_FOLLOWING = ( 0x00001000 << 7 ) ; public static final int BIT_FOLLOWING_SIBLING = ( 0x00001000 << 8 ) ; public static final int BIT_NAMESPACE = ( 0x00001000 << 9 ) ; public static final int BIT_PARENT = ( 0x00001000 << 10 ) ; public static final int BIT_PRECEDING = ( 0x00001000 << 11 ) ; public static final int BIT_PRECEDING_SIBLING = ( 0x00001000 << 12 ) ; public static final int BIT_SELF = ( 0x00001000 << 13 ) ; public static final int BIT_FILTER = ( 0x00001000 << 14 ) ; public static final int BIT_ROOT = ( 0x00001000 << 15 ) ; public static final int BITMASK_TRAVERSES_OUTSIDE_SUBTREE = ( BIT_NAMESPACE | BIT_PRECEDING_SIBLING | BIT_PRECEDING | BIT_FOLLOWING_SIBLING | BIT_FOLLOWING | BIT_PARENT | BIT_ANCESTOR_OR_SELF | BIT_ANCESTOR | BIT_FILTER | BIT_ROOT ) ; public static final int BIT_BACKWARDS_SELF = ( 0x00001000 << 16 ) ; public static final int BIT_ANY_DESCENDANT_FROM_ROOT = ( 0x00001000 << 17 ) ; public static final int BIT_NODETEST_ANY = ( 0x00001000 << 18 ) ; public static final int BIT_MATCH_PATTERN = ( 0x00001000 << 19 ) ; } 	1	['51', '1', '0', '25', '117', '1275', '11', '23', '40', '1.02', '2140', '0', '0', '0', '0.181372549', '0', '0', '40.45098039', '18', '3.3333', '2']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . w3c . dom . Node ; public class DTMChildIterNodeList extends DTMNodeListBase { private int m_firstChild ; private DTM m_parentDTM ; private DTMChildIterNodeList ( ) { } public DTMChildIterNodeList ( DTM parentDTM , int parentHandle ) { m_parentDTM = parentDTM ; m_firstChild = parentDTM . getFirstChild ( parentHandle ) ; } public Node item ( int index ) { int handle = m_firstChild ; while ( -- index >= 0 && handle != DTM . NULL ) { handle = m_parentDTM . getNextSibling ( handle ) ; } if ( handle == DTM . NULL ) { return null ; } return m_parentDTM . getNode ( handle ) ; } public int getLength ( ) { int count = 0 ; for ( int handle = m_firstChild ; handle != DTM . NULL ; handle = m_parentDTM . getNextSibling ( handle ) ) { ++ count ; } return count ; } } 	1	['4', '2', '0', '3', '8', '0', '1', '2', '3', '0.333333333', '62', '1', '1', '0.5', '0.583333333', '0', '0', '14', '4', '1.5', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_fr extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Erreur interne d''exécution dans ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Erreur d'exécution de <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Conversion incorrecte de ''{0}'' en ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "Fonction externe ''{0}'' non prise en charge par XSLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Type d'argument inconnu dans l'expression d'égalité." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Type d''argument inconnu ''{0}'' dans l''appel à ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Tentative de formatage du nombre ''{0}'' avec le modèle ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Clonage impossible de l''itérateur ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Itérateur non pris en charge pour l''axe ''{0}''." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Itérateur non pris en charge pour l''axe indiqué ''{0}''." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "L''attribut ''{0}'' est à l''extérieur de l''élément." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "La déclaration d''espace de noms ''{0}''=''{1}'' est à l''extérieur de l''élément." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "L''espace de noms du préfixe ''{0}'' n''a pas été déclaré." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter a été créé avec un type incorrect de source de DOM." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "L''analyseur SAX que vous utilisez ne traite pas les événements de déclaration DTD." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "L'analyseur SAX que vous utilisez ne prend pas en charge les espaces de nom XML." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "Résolution impossible de la référence à l''URI ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xalan . templates ; import java . text . DecimalFormat ; import java . text . DecimalFormatSymbols ; import java . text . NumberFormat ; import java . util . Locale ; import java . util . NoSuchElementException ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . CountersTable ; import org . apache . xalan . transformer . DecimalToRoman ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . NodeVector ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . StringBufferPool ; import org . apache . xml . utils . res . XResourceBundle ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; import org . xml . sax . SAXException ; public class ElemNumber extends ElemTemplateElement { private class MyPrefixResolver implements PrefixResolver { DTM dtm ; int handle ; boolean handleNullPrefix ; public MyPrefixResolver ( Node xpathExpressionContext , DTM dtm , int handle , boolean handleNullPrefix ) { this . dtm = dtm ; this . handle = handle ; this . handleNullPrefix = handleNullPrefix ; } public String getNamespaceForPrefix ( String prefix ) { return dtm . getNamespaceURI ( handle ) ; } public String getNamespaceForPrefix ( String prefix , Node context ) { return getNamespaceForPrefix ( prefix ) ; } public String getBaseIdentifier ( ) { return ElemNumber . this . getBaseIdentifier ( ) ; } public boolean handlesNullPrefixes ( ) { return handleNullPrefix ; } } private XPath m_countMatchPattern = null ; public void setCount ( XPath v ) { m_countMatchPattern = v ; } public XPath getCount ( ) { return m_countMatchPattern ; } private XPath m_fromMatchPattern = null ; public void setFrom ( XPath v ) { m_fromMatchPattern = v ; } public XPath getFrom ( ) { return m_fromMatchPattern ; } private int m_level = Constants . NUMBERLEVEL_SINGLE ; public void setLevel ( int v ) { m_level = v ; } public int getLevel ( ) { return m_level ; } private XPath m_valueExpr = null ; public void setValue ( XPath v ) { m_valueExpr = v ; } public XPath getValue ( ) { return m_valueExpr ; } private AVT m_format_avt = null ; public void setFormat ( AVT v ) { m_format_avt = v ; } public AVT getFormat ( ) { return m_format_avt ; } private AVT m_lang_avt = null ; public void setLang ( AVT v ) { m_lang_avt = v ; } public AVT getLang ( ) { return m_lang_avt ; } private AVT m_lettervalue_avt = null ; public void setLetterValue ( AVT v ) { m_lettervalue_avt = v ; } public AVT getLetterValue ( ) { return m_lettervalue_avt ; } private AVT m_groupingSeparator_avt = null ; public void setGroupingSeparator ( AVT v ) { m_groupingSeparator_avt = v ; } public AVT getGroupingSeparator ( ) { return m_groupingSeparator_avt ; } private AVT m_groupingSize_avt = null ; public void setGroupingSize ( AVT v ) { m_groupingSize_avt = v ; } public AVT getGroupingSize ( ) { return m_groupingSize_avt ; } private final static DecimalToRoman m_romanConvertTable [ ] = { new DecimalToRoman ( 1000 , "M" , 900 , "CM" ) , new DecimalToRoman ( 500 , "D" , 400 , "CD" ) , new DecimalToRoman ( 100L , "C" , 90L , "XC" ) , new DecimalToRoman ( 50L , "L" , 40L , "XL" ) , new DecimalToRoman ( 10L , "X" , 9L , "IX" ) , new DecimalToRoman ( 5L , "V" , 4L , "IV" ) , new DecimalToRoman ( 1L , "I" , 1L , "I" ) } ; private static char [ ] m_alphaCountTable = null ; public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_countMatchPattern ) m_countMatchPattern . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_format_avt ) m_format_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_fromMatchPattern ) m_fromMatchPattern . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_groupingSeparator_avt ) m_groupingSeparator_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_groupingSize_avt ) m_groupingSize_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_lang_avt ) m_lang_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_lettervalue_avt ) m_lettervalue_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_valueExpr ) m_valueExpr . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_NUMBER ; } public String getNodeName ( ) { return Constants . ELEMNAME_NUMBER_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; int sourceNode = transformer . getXPathContext ( ) . getCurrentNode ( ) ; String countString = getCountString ( transformer , sourceNode ) ; try { transformer . getResultTreeHandler ( ) . characters ( countString . toCharArray ( ) , 0 , countString . length ( ) ) ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; return null ; } int findAncestor ( XPathContext xctxt , XPath fromMatchPattern , XPath countMatchPattern , int context , ElemNumber namespaceContext ) throws javax . xml . transform . TransformerException { DTM dtm = xctxt . getDTM ( context ) ; while ( DTM . NULL != context ) { if ( null != fromMatchPattern ) { if ( fromMatchPattern . getMatchScore ( xctxt , context ) != XPath . MATCH_SCORE_NONE ) { break ; } } if ( null != countMatchPattern ) { if ( countMatchPattern . getMatchScore ( xctxt , context ) != XPath . MATCH_SCORE_NONE ) { break ; } } context = dtm . getParent ( context ) ; } return context ; } private int findPrecedingOrAncestorOrSelf ( XPathContext xctxt , XPath fromMatchPattern , XPath countMatchPattern , int context , ElemNumber namespaceContext ) throws javax . xml . transform . TransformerException { DTM dtm = xctxt . getDTM ( context ) ; while ( DTM . NULL != context ) { if ( null != fromMatchPattern ) { if ( fromMatchPattern . getMatchScore ( xctxt , context ) != XPath . MATCH_SCORE_NONE ) { context = DTM . NULL ; break ; } } if ( null != countMatchPattern ) { if ( countMatchPattern . getMatchScore ( xctxt , context ) != XPath . MATCH_SCORE_NONE ) { break ; } } int prevSibling = dtm . getPreviousSibling ( context ) ; if ( DTM . NULL == prevSibling ) { context = dtm . getParent ( context ) ; } else { context = dtm . getLastChild ( prevSibling ) ; if ( context == DTM . NULL ) context = prevSibling ; } } return context ; } XPath getCountMatchPattern ( XPathContext support , int contextNode ) throws javax . xml . transform . TransformerException { XPath countMatchPattern = m_countMatchPattern ; DTM dtm = support . getDTM ( contextNode ) ; if ( null == countMatchPattern ) { switch ( dtm . getNodeType ( contextNode ) ) { case DTM . ELEMENT_NODE : MyPrefixResolver resolver ; if ( dtm . getNamespaceURI ( contextNode ) == null ) { resolver = new MyPrefixResolver ( dtm . getNode ( contextNode ) , dtm , contextNode , false ) ; } else { resolver = new MyPrefixResolver ( dtm . getNode ( contextNode ) , dtm , contextNode , true ) ; } countMatchPattern = new XPath ( dtm . getNodeName ( contextNode ) , this , resolver , XPath . MATCH , support . getErrorListener ( ) ) ; break ; case DTM . ATTRIBUTE_NODE : countMatchPattern = new XPath ( "@" + dtm . getNodeName ( contextNode ) , this , this , XPath . MATCH , support . getErrorListener ( ) ) ; break ; case DTM . CDATA_SECTION_NODE : case DTM . TEXT_NODE : countMatchPattern = new XPath ( "text()" , this , this , XPath . MATCH , support . getErrorListener ( ) ) ; break ; case DTM . COMMENT_NODE : countMatchPattern = new XPath ( "comment()" , this , this , XPath . MATCH , support . getErrorListener ( ) ) ; break ; case DTM . DOCUMENT_NODE : countMatchPattern = new XPath ( "/" , this , this , XPath . MATCH , support . getErrorListener ( ) ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : countMatchPattern = new XPath ( "pi(" + dtm . getNodeName ( contextNode ) + ")" , this , this , XPath . MATCH , support . getErrorListener ( ) ) ; break ; default : countMatchPattern = null ; } } return countMatchPattern ; } String getCountString ( TransformerImpl transformer , int sourceNode ) throws TransformerException { long [ ] list = null ; XPathContext xctxt = transformer . getXPathContext ( ) ; CountersTable ctable = transformer . getCountersTable ( ) ; if ( null != m_valueExpr ) { XObject countObj = m_valueExpr . execute ( xctxt , sourceNode , this ) ; long count = ( long ) java . lang . Math . floor ( countObj . num ( ) + 0.5 ) ; list = new long [ 1 ] ; list [ 0 ] = count ; } else { if ( Constants . NUMBERLEVEL_ANY == m_level ) { list = new long [ 1 ] ; list [ 0 ] = ctable . countNode ( xctxt , this , sourceNode ) ; } else { NodeVector ancestors = getMatchingAncestors ( xctxt , sourceNode , Constants . NUMBERLEVEL_SINGLE == m_level ) ; int lastIndex = ancestors . size ( ) - 1 ; if ( lastIndex >= 0 ) { list = new long [ lastIndex + 1 ] ; for ( int i = lastIndex ; i >= 0 ; i -- ) { int target = ancestors . elementAt ( i ) ; list [ lastIndex - i ] = ctable . countNode ( xctxt , this , target ) ; } } } } return ( null != list ) ? formatNumberList ( transformer , list , sourceNode ) : "" ; } public int getPreviousNode ( XPathContext xctxt , int pos ) throws TransformerException { XPath countMatchPattern = getCountMatchPattern ( xctxt , pos ) ; DTM dtm = xctxt . getDTM ( pos ) ; if ( Constants . NUMBERLEVEL_ANY == m_level ) { XPath fromMatchPattern = m_fromMatchPattern ; while ( DTM . NULL != pos ) { int next = dtm . getPreviousSibling ( pos ) ; if ( DTM . NULL == next ) { next = dtm . getParent ( pos ) ; if ( ( DTM . NULL != next ) && ( ( ( ( null != fromMatchPattern ) && ( fromMatchPattern . getMatchScore ( xctxt , next ) != XPath . MATCH_SCORE_NONE ) ) ) || ( dtm . getNodeType ( next ) == DTM . DOCUMENT_NODE ) ) ) { pos = DTM . NULL ; break ; } } else { int child = next ; while ( DTM . NULL != child ) { child = dtm . getLastChild ( next ) ; if ( DTM . NULL != child ) next = child ; } } pos = next ; if ( ( DTM . NULL != pos ) && ( ( null == countMatchPattern ) || ( countMatchPattern . getMatchScore ( xctxt , pos ) != XPath . MATCH_SCORE_NONE ) ) ) { break ; } } } else { while ( DTM . NULL != pos ) { pos = dtm . getPreviousSibling ( pos ) ; if ( ( DTM . NULL != pos ) && ( ( null == countMatchPattern ) || ( countMatchPattern . getMatchScore ( xctxt , pos ) != XPath . MATCH_SCORE_NONE ) ) ) { break ; } } } return pos ; } public int getTargetNode ( XPathContext xctxt , int sourceNode ) throws TransformerException { int target = DTM . NULL ; XPath countMatchPattern = getCountMatchPattern ( xctxt , sourceNode ) ; if ( Constants . NUMBERLEVEL_ANY == m_level ) { target = findPrecedingOrAncestorOrSelf ( xctxt , m_fromMatchPattern , countMatchPattern , sourceNode , this ) ; } else { target = findAncestor ( xctxt , m_fromMatchPattern , countMatchPattern , sourceNode , this ) ; } return target ; } NodeVector getMatchingAncestors ( XPathContext xctxt , int node , boolean stopAtFirstFound ) throws javax . xml . transform . TransformerException { NodeSetDTM ancestors = new NodeSetDTM ( xctxt . getDTMManager ( ) ) ; XPath countMatchPattern = getCountMatchPattern ( xctxt , node ) ; DTM dtm = xctxt . getDTM ( node ) ; while ( DTM . NULL != node ) { if ( ( null != m_fromMatchPattern ) && ( m_fromMatchPattern . getMatchScore ( xctxt , node ) != XPath . MATCH_SCORE_NONE ) ) { if ( ! stopAtFirstFound ) break ; } if ( null == countMatchPattern ) System . out . println ( "Programmers error! countMatchPattern should never be null!" ) ; if ( countMatchPattern . getMatchScore ( xctxt , node ) != XPath . MATCH_SCORE_NONE ) { ancestors . addElement ( node ) ; if ( stopAtFirstFound ) break ; } node = dtm . getParent ( node ) ; } return ancestors ; } Locale getLocale ( TransformerImpl transformer , int contextNode ) throws TransformerException { Locale locale = null ; if ( null != m_lang_avt ) { XPathContext xctxt = transformer . getXPathContext ( ) ; String langValue = m_lang_avt . evaluate ( xctxt , contextNode , this ) ; if ( null != langValue ) { locale = new Locale ( langValue . toUpperCase ( ) , "" ) ; if ( null == locale ) { transformer . getMsgMgr ( ) . warn ( this , null , xctxt . getDTM ( contextNode ) . getNode ( contextNode ) , XSLTErrorResources . WG_LOCALE_NOT_FOUND , new Object [ ] { langValue } ) ; locale = Locale . getDefault ( ) ; } } } else { locale = Locale . getDefault ( ) ; } return locale ; } private DecimalFormat getNumberFormatter ( TransformerImpl transformer , int contextNode ) throws TransformerException { Locale locale = ( Locale ) getLocale ( transformer , contextNode ) . clone ( ) ; DecimalFormat formatter = null ; String digitGroupSepValue = ( null != m_groupingSeparator_avt ) ? m_groupingSeparator_avt . evaluate ( transformer . getXPathContext ( ) , contextNode , this ) : null ; if ( ( digitGroupSepValue != null ) && ( ! m_groupingSeparator_avt . isSimple ( ) ) && ( digitGroupSepValue . length ( ) != 1 ) ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_NAME , m_groupingSeparator_avt . getName ( ) } ) ; } String nDigitsPerGroupValue = ( null != m_groupingSize_avt ) ? m_groupingSize_avt . evaluate ( transformer . getXPathContext ( ) , contextNode , this ) : null ; if ( ( null != digitGroupSepValue ) && ( null != nDigitsPerGroupValue ) && ( digitGroupSepValue . length ( ) > 0 ) ) { try { formatter = ( DecimalFormat ) NumberFormat . getNumberInstance ( locale ) ; formatter . setGroupingSize ( Integer . valueOf ( nDigitsPerGroupValue ) . intValue ( ) ) ; DecimalFormatSymbols symbols = formatter . getDecimalFormatSymbols ( ) ; symbols . setGroupingSeparator ( digitGroupSepValue . charAt ( 0 ) ) ; formatter . setDecimalFormatSymbols ( symbols ) ; formatter . setGroupingUsed ( true ) ; } catch ( NumberFormatException ex ) { formatter . setGroupingUsed ( false ) ; } } return formatter ; } String formatNumberList ( TransformerImpl transformer , long [ ] list , int contextNode ) throws TransformerException { String numStr ; FastStringBuffer formattedNumber = StringBufferPool . get ( ) ; try { int nNumbers = list . length , numberWidth = 1 ; char numberType = '1' ; String formatToken , lastSepString = null , formatTokenString = null ; String lastSep = "." ; boolean isFirstToken = true ; String formatValue = ( null != m_format_avt ) ? m_format_avt . evaluate ( transformer . getXPathContext ( ) , contextNode , this ) : null ; if ( null == formatValue ) formatValue = "1" ; NumberFormatStringTokenizer formatTokenizer = new NumberFormatStringTokenizer ( formatValue ) ; for ( int i = 0 ; i < nNumbers ; i ++ ) { if ( formatTokenizer . hasMoreTokens ( ) ) { formatToken = formatTokenizer . nextToken ( ) ; if ( Character . isLetterOrDigit ( formatToken . charAt ( formatToken . length ( ) - 1 ) ) ) { numberWidth = formatToken . length ( ) ; numberType = formatToken . charAt ( numberWidth - 1 ) ; } else if ( formatTokenizer . isLetterOrDigitAhead ( ) ) { formatTokenString = formatToken ; while ( formatTokenizer . nextIsSep ( ) ) { formatToken = formatTokenizer . nextToken ( ) ; formatTokenString += formatToken ; } if ( ! isFirstToken ) lastSep = formatTokenString ; formatToken = formatTokenizer . nextToken ( ) ; numberWidth = formatToken . length ( ) ; numberType = formatToken . charAt ( numberWidth - 1 ) ; } else { lastSepString = formatToken ; while ( formatTokenizer . hasMoreTokens ( ) ) { formatToken = formatTokenizer . nextToken ( ) ; lastSepString += formatToken ; } } } if ( null != formatTokenString && isFirstToken ) { formattedNumber . append ( formatTokenString ) ; } else if ( null != lastSep && ! isFirstToken ) formattedNumber . append ( lastSep ) ; getFormattedNumber ( transformer , contextNode , numberType , numberWidth , list [ i ] , formattedNumber ) ; isFirstToken = false ; } while ( formatTokenizer . isLetterOrDigitAhead ( ) ) { formatTokenizer . nextToken ( ) ; } if ( lastSepString != null ) formattedNumber . append ( lastSepString ) ; while ( formatTokenizer . hasMoreTokens ( ) ) { formatToken = formatTokenizer . nextToken ( ) ; formattedNumber . append ( formatToken ) ; } numStr = formattedNumber . toString ( ) ; } finally { StringBufferPool . free ( formattedNumber ) ; } return numStr ; } private void getFormattedNumber ( TransformerImpl transformer , int contextNode , char numberType , int numberWidth , long listElement , FastStringBuffer formattedNumber ) throws javax . xml . transform . TransformerException { String letterVal = ( m_lettervalue_avt != null ) ? m_lettervalue_avt . evaluate ( transformer . getXPathContext ( ) , contextNode , this ) : null ; switch ( numberType ) { case 'A' : if ( m_alphaCountTable == null ) { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , getLocale ( transformer , contextNode ) ) ; char [ ] alphabet ; alphabet = ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) ; m_alphaCountTable = alphabet ; } int2alphaCount ( listElement , m_alphaCountTable , formattedNumber ) ; break ; case 'a' : if ( m_alphaCountTable == null ) { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , getLocale ( transformer , contextNode ) ) ; char [ ] alphabet ; alphabet = ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) ; m_alphaCountTable = alphabet ; } FastStringBuffer stringBuf = StringBufferPool . get ( ) ; try { int2alphaCount ( listElement , m_alphaCountTable , stringBuf ) ; formattedNumber . append ( stringBuf . toString ( ) . toLowerCase ( getLocale ( transformer , contextNode ) ) ) ; } finally { StringBufferPool . free ( stringBuf ) ; } break ; case 'I' : formattedNumber . append ( long2roman ( listElement , true ) ) ; break ; case 'i' : formattedNumber . append ( long2roman ( listElement , true ) . toLowerCase ( getLocale ( transformer , contextNode ) ) ) ; break ; case 0x3042 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "ja" , "JP" , "HA" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else formattedNumber . append ( int2singlealphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) ) ) ; break ; } case 0x3044 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "ja" , "JP" , "HI" ) ) ; if ( ( letterVal != null ) && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else formattedNumber . append ( int2singlealphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) ) ) ; break ; } case 0x30A2 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "ja" , "JP" , "A" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else formattedNumber . append ( int2singlealphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) ) ) ; break ; } case 0x30A4 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "ja" , "JP" , "I" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else formattedNumber . append ( int2singlealphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) ) ) ; break ; } case 0x4E00 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "zh" , "CN" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) { formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; } else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } case 0x58F9 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "zh" , "TW" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } case 0x0E51 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "th" , "" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } case 0x05D0 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "he" , "" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } case 0x10D0 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "ka" , "" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } case 0x03B1 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "el" , "" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } case 0x0430 : { XResourceBundle thisBundle ; thisBundle = ( XResourceBundle ) XResourceBundle . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . LANG_BUNDLE_NAME , new Locale ( "cy" , "" ) ) ; if ( letterVal != null && letterVal . equals ( Constants . ATTRVAL_TRADITIONAL ) ) formattedNumber . append ( tradAlphaCount ( listElement , thisBundle ) ) ; else int2alphaCount ( listElement , ( char [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_ALPHABET ) , formattedNumber ) ; break ; } default : DecimalFormat formatter = getNumberFormatter ( transformer , contextNode ) ; String padString = formatter == null ? String . valueOf ( 0 ) : formatter . format ( 0 ) ; String numString = formatter == null ? String . valueOf ( listElement ) : formatter . format ( listElement ) ; int nPadding = numberWidth - numString . length ( ) ; for ( int k = 0 ; k < nPadding ; k ++ ) { formattedNumber . append ( padString ) ; } formattedNumber . append ( numString ) ; } } String getZeroString ( ) { return "" + 0 ; } protected String int2singlealphaCount ( long val , char [ ] table ) { int radix = table . length ; if ( val > radix ) { return getZeroString ( ) ; } else return ( new Character ( table [ ( int ) val - 1 ] ) ) . toString ( ) ; } protected void int2alphaCount ( long val , char [ ] aTable , FastStringBuffer stringBuf ) { int radix = aTable . length ; char [ ] table = new char [ aTable . length ] ; int i ; for ( i = 0 ; i < aTable . length - 1 ; i ++ ) { table [ i + 1 ] = aTable [ i ] ; } table [ 0 ] = aTable [ i ] ; char buf [ ] = new char [ 100 ] ; int charPos ; charPos = buf . length - 1 ; int lookupIndex = 1 ; long correction = 0 ; do { correction = ( ( lookupIndex == 0 ) || ( correction != 0 && lookupIndex == radix - 1 ) ) ? ( radix - 1 ) : 0 ; lookupIndex = ( int ) ( val + correction ) % radix ; val = ( val / radix ) ; if ( lookupIndex == 0 && val == 0 ) break ; buf [ charPos -- ] = table [ lookupIndex ] ; } while ( val > 0 ) ; stringBuf . append ( buf , charPos + 1 , ( buf . length - charPos - 1 ) ) ; } protected String tradAlphaCount ( long val , XResourceBundle thisBundle ) { if ( val > Long . MAX_VALUE ) { this . error ( XSLTErrorResources . ER_NUMBER_TOO_BIG ) ; return XSLTErrorResources . ERROR_STRING ; } char [ ] table = null ; int lookupIndex = 1 ; char buf [ ] = new char [ 100 ] ; int charPos ; charPos = 0 ; int [ ] groups = ( int [ ] ) thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_NUMBERGROUPS ) ; String [ ] tables = ( String [ ] ) ( thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_NUM_TABLES ) ) ; String numbering = thisBundle . getString ( org . apache . xml . utils . res . XResourceBundle . LANG_NUMBERING ) ; if ( numbering . equals ( org . apache . xml . utils . res . XResourceBundle . LANG_MULT_ADD ) ) { String mult_order = thisBundle . getString ( org . apache . xml . utils . res . XResourceBundle . MULT_ORDER ) ; long [ ] multiplier = ( long [ ] ) ( thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_MULTIPLIER ) ) ; char [ ] zeroChar = ( char [ ] ) thisBundle . getObject ( "zero" ) ; int i = 0 ; while ( i < multiplier . length && val < multiplier [ i ] ) { i ++ ; } do { if ( i >= multiplier . length ) break ; if ( val < multiplier [ i ] ) { if ( zeroChar . length == 0 ) { i ++ ; } else { if ( buf [ charPos - 1 ] != zeroChar [ 0 ] ) buf [ charPos ++ ] = zeroChar [ 0 ] ; i ++ ; } } else if ( val >= multiplier [ i ] ) { long mult = val / multiplier [ i ] ; val = val % multiplier [ i ] ; int k = 0 ; while ( k < groups . length ) { lookupIndex = 1 ; if ( mult / groups [ k ] <= 0 ) k ++ ; else { char [ ] THEletters = ( char [ ] ) thisBundle . getObject ( tables [ k ] ) ; table = new char [ THEletters . length + 1 ] ; int j ; for ( j = 0 ; j < THEletters . length ; j ++ ) { table [ j + 1 ] = THEletters [ j ] ; } table [ 0 ] = THEletters [ j - 1 ] ; lookupIndex = ( int ) mult / groups [ k ] ; if ( lookupIndex == 0 && mult == 0 ) break ; char multiplierChar = ( ( char [ ] ) ( thisBundle . getObject ( org . apache . xml . utils . res . XResourceBundle . LANG_MULTIPLIER_CHAR ) ) ) [ i ] ; if ( lookupIndex < table . length ) { if ( mult_order . equals ( org . apache . xml . utils . res . XResourceBundle . MULT_PRECEDES ) ) { buf [ charPos ++ ] = multiplierChar ; buf [ charPos ++ ] = table [ lookupIndex ] ; } else { if ( lookupIndex == 1 && i == multiplier . length - 1 ) { } else buf [ charPos ++ ] = table [ lookupIndex ] ; buf [ charPos ++ ] = multiplierChar ; } break ; } else return XSLTErrorResources . ERROR_STRING ; } } i ++ ; } } while ( i < multiplier . length ) ; } int count = 0 ; String tableName ; while ( count < groups . length ) { if ( val / groups [ count ] <= 0 ) count ++ ; else { char [ ] theletters = ( char [ ] ) thisBundle . getObject ( tables [ count ] ) ; table = new char [ theletters . length + 1 ] ; int j ; for ( j = 0 ; j < theletters . length ; j ++ ) { table [ j + 1 ] = theletters [ j ] ; } table [ 0 ] = theletters [ j - 1 ] ; lookupIndex = ( int ) val / groups [ count ] ; val = val % groups [ count ] ; if ( lookupIndex == 0 && val == 0 ) break ; if ( lookupIndex < table . length ) { buf [ charPos ++ ] = table [ lookupIndex ] ; } else return XSLTErrorResources . ERROR_STRING ; count ++ ; } } return new String ( buf , 0 , charPos ) ; } protected String long2roman ( long val , boolean prefixesAreOK ) { if ( val <= 0 ) { return getZeroString ( ) ; } String roman = "" ; int place = 0 ; if ( val <= 3999L ) { do { while ( val >= m_romanConvertTable [ place ] . m_postValue ) { roman += m_romanConvertTable [ place ] . m_postLetter ; val -= m_romanConvertTable [ place ] . m_postValue ; } if ( prefixesAreOK ) { if ( val >= m_romanConvertTable [ place ] . m_preValue ) { roman += m_romanConvertTable [ place ] . m_preLetter ; val -= m_romanConvertTable [ place ] . m_preValue ; } } place ++ ; } while ( val > 0 ) ; } else { roman = XSLTErrorResources . ERROR_STRING ; } return roman ; } public void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) { if ( null != m_countMatchPattern ) m_countMatchPattern . getExpression ( ) . callVisitors ( m_countMatchPattern , visitor ) ; if ( null != m_fromMatchPattern ) m_fromMatchPattern . getExpression ( ) . callVisitors ( m_fromMatchPattern , visitor ) ; if ( null != m_valueExpr ) m_valueExpr . getExpression ( ) . callVisitors ( m_valueExpr , visitor ) ; if ( null != m_format_avt ) m_format_avt . callVisitors ( visitor ) ; if ( null != m_groupingSeparator_avt ) m_groupingSeparator_avt . callVisitors ( visitor ) ; if ( null != m_groupingSize_avt ) m_groupingSize_avt . callVisitors ( visitor ) ; if ( null != m_lang_avt ) m_lang_avt . callVisitors ( visitor ) ; if ( null != m_lettervalue_avt ) m_lettervalue_avt . callVisitors ( visitor ) ; } super . callChildVisitors ( visitor , callAttrs ) ; } class NumberFormatStringTokenizer { private int currentPosition ; private int maxPosition ; private String str ; public NumberFormatStringTokenizer ( String str ) { this . str = str ; maxPosition = str . length ( ) ; } public void reset ( ) { currentPosition = 0 ; } public String nextToken ( ) { if ( currentPosition >= maxPosition ) { throw new NoSuchElementException ( ) ; } int start = currentPosition ; while ( ( currentPosition < maxPosition ) && Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) { currentPosition ++ ; } if ( ( start == currentPosition ) && ( ! Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) ) { currentPosition ++ ; } return str . substring ( start , currentPosition ) ; } public boolean isLetterOrDigitAhead ( ) { int pos = currentPosition ; while ( pos < maxPosition ) { if ( Character . isLetterOrDigit ( str . charAt ( pos ) ) ) return true ; pos ++ ; } return false ; } public boolean nextIsSep ( ) { if ( Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) return false ; else return true ; } public boolean hasMoreTokens ( ) { return ( currentPosition >= maxPosition ) ? false : true ; } public int countTokens ( ) { int count = 0 ; int currpos = currentPosition ; while ( currpos < maxPosition ) { int start = currpos ; while ( ( currpos < maxPosition ) && Character . isLetterOrDigit ( str . charAt ( currpos ) ) ) { currpos ++ ; } if ( ( start == currpos ) && ( Character . isLetterOrDigit ( str . charAt ( currpos ) ) == false ) ) { currpos ++ ; } count ++ ; } return count ; } } } 	1	['42', '3', '0', '29', '135', '617', '5', '27', '27', '0.860310421', '2384', '1', '9', '0.830508475', '0.136298422', '2', '7', '55.5', '26', '2.0952', '4']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . utils . XMLChar ; final class ApplyTemplates extends Instruction { private Expression _select ; private Type _type = null ; private QName _modeName ; private String _functionName ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "ApplyTemplates" ) ; indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; if ( _modeName != null ) { indent ( indent + IndentIncrement ) ; Util . println ( "mode " + _modeName ) ; } } public boolean hasWithParams ( ) { return hasContents ( ) ; } public void parseContents ( Parser parser ) { final String select = getAttribute ( "select" ) ; final String mode = getAttribute ( "mode" ) ; if ( select . length ( ) > 0 ) { _select = parser . parseExpression ( this , "select" , null ) ; } if ( mode . length ( ) > 0 ) { if ( ! XMLChar . isValidQName ( mode ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , mode , this ) ; parser . reportError ( Constants . ERROR , err ) ; } _modeName = parser . getQNameIgnoreDefaultNs ( mode ) ; } _functionName = parser . getTopLevelStylesheet ( ) . getMode ( _modeName ) . functionName ( ) ; parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _select != null ) { _type = _select . typeCheck ( stable ) ; if ( _type instanceof NodeType || _type instanceof ReferenceType ) { _select = new CastExpr ( _select , Type . NodeSet ) ; _type = Type . NodeSet ; } if ( _type instanceof NodeSetType || _type instanceof ResultTreeType ) { typeCheckContents ( stable ) ; return Type . Void ; } throw new TypeCheckError ( this ) ; } else { typeCheckContents ( stable ) ; return Type . Void ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { boolean setStartNodeCalled = false ; final Stylesheet stylesheet = classGen . getStylesheet ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; final Vector sortObjects = new Vector ( ) ; final Enumeration children = elements ( ) ; while ( children . hasMoreElements ( ) ) { final Object child = children . nextElement ( ) ; if ( child instanceof Sort ) { sortObjects . addElement ( child ) ; } } if ( stylesheet . hasLocalParams ( ) || hasContents ( ) ) { il . append ( classGen . loadTranslet ( ) ) ; final int pushFrame = cpg . addMethodref ( TRANSLET_CLASS , PUSH_PARAM_FRAME , PUSH_PARAM_FRAME_SIG ) ; il . append ( new INVOKEVIRTUAL ( pushFrame ) ) ; translateContents ( classGen , methodGen ) ; } il . append ( classGen . loadTranslet ( ) ) ; if ( ( _type != null ) && ( _type instanceof ResultTreeType ) ) { if ( sortObjects . size ( ) > 0 ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . RESULT_TREE_SORT_ERR , this ) ; getParser ( ) . reportError ( WARNING , err ) ; } _select . translate ( classGen , methodGen ) ; _type . translateTo ( classGen , methodGen , Type . NodeSet ) ; } else { il . append ( methodGen . loadDOM ( ) ) ; if ( sortObjects . size ( ) > 0 ) { Sort . translateSortIterator ( classGen , methodGen , _select , sortObjects ) ; int setStartNode = cpg . addInterfaceMethodref ( NODE_ITERATOR , SET_START_NODE , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( setStartNode , 2 ) ) ; setStartNodeCalled = true ; } else { if ( _select == null ) Mode . compileGetChildren ( classGen , methodGen , current ) ; else _select . translate ( classGen , methodGen ) ; } } if ( _select != null && ! setStartNodeCalled ) { _select . startIterator ( classGen , methodGen ) ; } final String className = classGen . getStylesheet ( ) . getClassName ( ) ; il . append ( methodGen . loadHandler ( ) ) ; final String applyTemplatesSig = classGen . getApplyTemplatesSig ( ) ; final int applyTemplates = cpg . addMethodref ( className , _functionName , applyTemplatesSig ) ; il . append ( new INVOKEVIRTUAL ( applyTemplates ) ) ; if ( stylesheet . hasLocalParams ( ) || hasContents ( ) ) { il . append ( classGen . loadTranslet ( ) ) ; final int popFrame = cpg . addMethodref ( TRANSLET_CLASS , POP_PARAM_FRAME , POP_PARAM_FRAME_SIG ) ; il . append ( new INVOKEVIRTUAL ( popFrame ) ) ; } } } 	1	['6', '3', '0', '28', '60', '0', '3', '27', '5', '0.65', '375', '1', '3', '0.918032787', '0.305555556', '1', '5', '60.83333333', '13', '3.5', '1']
package org . apache . xpath . compiler ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . XPathProcessorException ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XString ; import org . apache . xpath . res . XPATHErrorResources ; public class XPathParser { static public final String CONTINUE_AFTER_FATAL_ERROR = "CONTINUE_AFTER_FATAL_ERROR" ; private OpMap m_ops ; transient String m_token ; transient char m_tokenChar = 0 ; int m_queueMark = 0 ; protected final static int FILTER_MATCH_FAILED = 0 ; protected final static int FILTER_MATCH_PRIMARY = 1 ; protected final static int FILTER_MATCH_PREDICATES = 2 ; public XPathParser ( ErrorListener errorListener , javax . xml . transform . SourceLocator sourceLocator ) { m_errorListener = errorListener ; m_sourceLocator = sourceLocator ; } PrefixResolver m_namespaceContext ; public void initXPath ( Compiler compiler , String expression , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { m_ops = compiler ; m_namespaceContext = namespaceContext ; Lexer lexer = new Lexer ( compiler , namespaceContext , this ) ; lexer . tokenize ( expression ) ; m_ops . setOp ( 0 , OpCodes . OP_XPATH ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , 2 ) ; try { nextToken ( ) ; Expr ( ) ; if ( null != m_token ) { String extraTokens = "" ; while ( null != m_token ) { extraTokens += "'" + m_token + "'" ; nextToken ( ) ; if ( null != m_token ) extraTokens += ", " ; } error ( XPATHErrorResources . ER_EXTRA_ILLEGAL_TOKENS , new Object [ ] { extraTokens } ) ; } } catch ( org . apache . xpath . XPathProcessorException e ) { if ( CONTINUE_AFTER_FATAL_ERROR . equals ( e . getMessage ( ) ) ) { initXPath ( compiler , "/.." , namespaceContext ) ; } else throw e ; } compiler . shrink ( ) ; } public void initMatchPattern ( Compiler compiler , String expression , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { m_ops = compiler ; m_namespaceContext = namespaceContext ; Lexer lexer = new Lexer ( compiler , namespaceContext , this ) ; lexer . tokenize ( expression ) ; m_ops . setOp ( 0 , OpCodes . OP_MATCHPATTERN ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , 2 ) ; nextToken ( ) ; Pattern ( ) ; if ( null != m_token ) { String extraTokens = "" ; while ( null != m_token ) { extraTokens += "'" + m_token + "'" ; nextToken ( ) ; if ( null != m_token ) extraTokens += ", " ; } error ( XPATHErrorResources . ER_EXTRA_ILLEGAL_TOKENS , new Object [ ] { extraTokens } ) ; } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ENDOP ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . shrink ( ) ; } private ErrorListener m_errorListener ; javax . xml . transform . SourceLocator m_sourceLocator ; public void setErrorHandler ( ErrorListener handler ) { m_errorListener = handler ; } public ErrorListener getErrorListener ( ) { return m_errorListener ; } final boolean tokenIs ( String s ) { return ( m_token != null ) ? ( m_token . equals ( s ) ) : ( s == null ) ; } final boolean tokenIs ( char c ) { return ( m_token != null ) ? ( m_tokenChar == c ) : false ; } final boolean lookahead ( char c , int n ) { int pos = ( m_queueMark + n ) ; boolean b ; if ( ( pos <= m_ops . getTokenQueueSize ( ) ) && ( pos > 0 ) && ( m_ops . getTokenQueueSize ( ) != 0 ) ) { String tok = ( ( String ) m_ops . m_tokenQueue . elementAt ( pos - 1 ) ) ; b = ( tok . length ( ) == 1 ) ? ( tok . charAt ( 0 ) == c ) : false ; } else { b = false ; } return b ; } private final boolean lookbehind ( char c , int n ) { boolean isToken ; int lookBehindPos = m_queueMark - ( n + 1 ) ; if ( lookBehindPos >= 0 ) { String lookbehind = ( String ) m_ops . m_tokenQueue . elementAt ( lookBehindPos ) ; if ( lookbehind . length ( ) == 1 ) { char c0 = ( lookbehind == null ) ? '|' : lookbehind . charAt ( 0 ) ; isToken = ( c0 == '|' ) ? false : ( c0 == c ) ; } else { isToken = false ; } } else { isToken = false ; } return isToken ; } private final boolean lookbehindHasToken ( int n ) { boolean hasToken ; if ( ( m_queueMark - n ) > 0 ) { String lookbehind = ( String ) m_ops . m_tokenQueue . elementAt ( m_queueMark - ( n - 1 ) ) ; char c0 = ( lookbehind == null ) ? '|' : lookbehind . charAt ( 0 ) ; hasToken = ( c0 == '|' ) ? false : true ; } else { hasToken = false ; } return hasToken ; } private final boolean lookahead ( String s , int n ) { boolean isToken ; if ( ( m_queueMark + n ) <= m_ops . getTokenQueueSize ( ) ) { String lookahead = ( String ) m_ops . m_tokenQueue . elementAt ( m_queueMark + ( n - 1 ) ) ; isToken = ( lookahead != null ) ? lookahead . equals ( s ) : ( s == null ) ; } else { isToken = ( null == s ) ; } return isToken ; } private final void nextToken ( ) { if ( m_queueMark < m_ops . getTokenQueueSize ( ) ) { m_token = ( String ) m_ops . m_tokenQueue . elementAt ( m_queueMark ++ ) ; m_tokenChar = m_token . charAt ( 0 ) ; } else { m_token = null ; m_tokenChar = 0 ; } } private final String getTokenRelative ( int i ) { String tok ; int relative = m_queueMark + i ; if ( ( relative > 0 ) && ( relative < m_ops . getTokenQueueSize ( ) ) ) { tok = ( String ) m_ops . m_tokenQueue . elementAt ( relative ) ; } else { tok = null ; } return tok ; } private final void prevToken ( ) { if ( m_queueMark > 0 ) { m_queueMark -- ; m_token = ( String ) m_ops . m_tokenQueue . elementAt ( m_queueMark ) ; m_tokenChar = m_token . charAt ( 0 ) ; } else { m_token = null ; m_tokenChar = 0 ; } } private final void consumeExpected ( String expected ) throws javax . xml . transform . TransformerException { if ( tokenIs ( expected ) ) { nextToken ( ) ; } else { error ( XPATHErrorResources . ER_EXPECTED_BUT_FOUND , new Object [ ] { expected , m_token } ) ; throw new XPathProcessorException ( CONTINUE_AFTER_FATAL_ERROR ) ; } } private final void consumeExpected ( char expected ) throws javax . xml . transform . TransformerException { if ( tokenIs ( expected ) ) { nextToken ( ) ; } else { error ( XPATHErrorResources . ER_EXPECTED_BUT_FOUND , new Object [ ] { String . valueOf ( expected ) , m_token } ) ; throw new XPathProcessorException ( CONTINUE_AFTER_FATAL_ERROR ) ; } } void warn ( String msg , Object [ ] args ) throws TransformerException { String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; ErrorListener ehandler = this . getErrorListener ( ) ; if ( null != ehandler ) { ehandler . warning ( new TransformerException ( fmsg , m_sourceLocator ) ) ; } else { System . err . println ( fmsg ) ; } } private void assertion ( boolean b , String msg ) { if ( ! b ) { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } void error ( String msg , Object [ ] args ) throws TransformerException { String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; ErrorListener ehandler = this . getErrorListener ( ) ; TransformerException te = new TransformerException ( fmsg , m_sourceLocator ) ; if ( null != ehandler ) { ehandler . fatalError ( te ) ; } else { throw te ; } } protected String dumpRemainingTokenQueue ( ) { int q = m_queueMark ; String returnMsg ; if ( q < m_ops . getTokenQueueSize ( ) ) { String msg = "\n Remaining tokens: (" ; while ( q < m_ops . getTokenQueueSize ( ) ) { String t = ( String ) m_ops . m_tokenQueue . elementAt ( q ++ ) ; msg += ( " '" + t + "'" ) ; } returnMsg = msg + ")" ; } else { returnMsg = "" ; } return returnMsg ; } final int getFunctionToken ( String key ) { int tok ; try { tok = ( ( Integer ) ( Keywords . m_functions . get ( key ) ) ) . intValue ( ) ; } catch ( NullPointerException npe ) { tok = - 1 ; } catch ( ClassCastException cce ) { tok = - 1 ; } return tok ; } void insertOp ( int pos , int length , int op ) { int totalLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; for ( int i = totalLen - 1 ; i >= pos ; i -- ) { m_ops . setOp ( i + length , m_ops . getOp ( i ) ) ; } m_ops . setOp ( pos , op ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , totalLen + length ) ; } void appendOp ( int length , int op ) { int totalLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; m_ops . setOp ( totalLen , op ) ; m_ops . setOp ( totalLen + OpMap . MAPINDEX_LENGTH , length ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , totalLen + length ) ; } protected void Expr ( ) throws javax . xml . transform . TransformerException { OrExpr ( ) ; } protected void OrExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; AndExpr ( ) ; if ( ( null != m_token ) && tokenIs ( "or" ) ) { nextToken ( ) ; insertOp ( opPos , 2 , OpCodes . OP_OR ) ; OrExpr ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } } protected void AndExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; EqualityExpr ( - 1 ) ; if ( ( null != m_token ) && tokenIs ( "and" ) ) { nextToken ( ) ; insertOp ( opPos , 2 , OpCodes . OP_AND ) ; AndExpr ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } } protected int EqualityExpr ( int addPos ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; if ( - 1 == addPos ) addPos = opPos ; RelationalExpr ( - 1 ) ; if ( null != m_token ) { if ( tokenIs ( '!' ) && lookahead ( '=' , 1 ) ) { nextToken ( ) ; nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_NOTEQUALS ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = EqualityExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } else if ( tokenIs ( '=' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_EQUALS ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = EqualityExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } } return addPos ; } protected int RelationalExpr ( int addPos ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; if ( - 1 == addPos ) addPos = opPos ; AdditiveExpr ( - 1 ) ; if ( null != m_token ) { if ( tokenIs ( '<' ) ) { nextToken ( ) ; if ( tokenIs ( '=' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_LTE ) ; } else { insertOp ( addPos , 2 , OpCodes . OP_LT ) ; } int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = RelationalExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } else if ( tokenIs ( '>' ) ) { nextToken ( ) ; if ( tokenIs ( '=' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_GTE ) ; } else { insertOp ( addPos , 2 , OpCodes . OP_GT ) ; } int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = RelationalExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } } return addPos ; } protected int AdditiveExpr ( int addPos ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; if ( - 1 == addPos ) addPos = opPos ; MultiplicativeExpr ( - 1 ) ; if ( null != m_token ) { if ( tokenIs ( '+' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_PLUS ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = AdditiveExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } else if ( tokenIs ( '-' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_MINUS ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = AdditiveExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } } return addPos ; } protected int MultiplicativeExpr ( int addPos ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; if ( - 1 == addPos ) addPos = opPos ; UnaryExpr ( ) ; if ( null != m_token ) { if ( tokenIs ( '*' ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_MULT ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = MultiplicativeExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } else if ( tokenIs ( "div" ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_DIV ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = MultiplicativeExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } else if ( tokenIs ( "mod" ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_MOD ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = MultiplicativeExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } else if ( tokenIs ( "quo" ) ) { nextToken ( ) ; insertOp ( addPos , 2 , OpCodes . OP_QUO ) ; int opPlusLeftHandLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - addPos ; addPos = MultiplicativeExpr ( addPos ) ; m_ops . setOp ( addPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( addPos + opPlusLeftHandLen + 1 ) + opPlusLeftHandLen ) ; addPos += 2 ; } } return addPos ; } protected void UnaryExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; boolean isNeg = false ; if ( m_tokenChar == '-' ) { nextToken ( ) ; appendOp ( 2 , OpCodes . OP_NEG ) ; isNeg = true ; } UnionExpr ( ) ; if ( isNeg ) m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected void StringExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_STRING ) ; Expr ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected void BooleanExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_BOOL ) ; Expr ( ) ; int opLen = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ; if ( opLen == 2 ) { error ( XPATHErrorResources . ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , null ) ; } m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , opLen ) ; } protected void NumberExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_NUMBER ) ; Expr ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected void UnionExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; boolean continueOrLoop = true ; boolean foundUnion = false ; do { PathExpr ( ) ; if ( tokenIs ( '|' ) ) { if ( false == foundUnion ) { foundUnion = true ; insertOp ( opPos , 2 , OpCodes . OP_UNION ) ; } nextToken ( ) ; } else { break ; } } while ( continueOrLoop ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected void PathExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; int filterExprMatch = FilterExpr ( ) ; if ( filterExprMatch != FILTER_MATCH_FAILED ) { boolean locationPathStarted = ( filterExprMatch == FILTER_MATCH_PREDICATES ) ; if ( tokenIs ( '/' ) ) { nextToken ( ) ; if ( ! locationPathStarted ) { insertOp ( opPos , 2 , OpCodes . OP_LOCATIONPATH ) ; locationPathStarted = true ; } if ( ! RelativeLocationPath ( ) ) { error ( XPATHErrorResources . ER_EXPECTED_REL_LOC_PATH , null ) ; } } if ( locationPathStarted ) { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ENDOP ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } } else { LocationPath ( ) ; } } protected int FilterExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; int filterMatch ; if ( PrimaryExpr ( ) ) { if ( tokenIs ( '[' ) ) { insertOp ( opPos , 2 , OpCodes . OP_LOCATIONPATH ) ; while ( tokenIs ( '[' ) ) { Predicate ( ) ; } filterMatch = FILTER_MATCH_PREDICATES ; } else { filterMatch = FILTER_MATCH_PRIMARY ; } } else { filterMatch = FILTER_MATCH_FAILED ; } return filterMatch ; } protected boolean PrimaryExpr ( ) throws javax . xml . transform . TransformerException { boolean matchFound ; int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; if ( ( m_tokenChar == '\'' ) || ( m_tokenChar == '"' ) ) { appendOp ( 2 , OpCodes . OP_LITERAL ) ; Literal ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; matchFound = true ; } else if ( m_tokenChar == '$' ) { nextToken ( ) ; appendOp ( 2 , OpCodes . OP_VARIABLE ) ; QName ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; matchFound = true ; } else if ( m_tokenChar == '(' ) { nextToken ( ) ; appendOp ( 2 , OpCodes . OP_GROUP ) ; Expr ( ) ; consumeExpected ( ')' ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; matchFound = true ; } else if ( ( null != m_token ) && ( ( ( '.' == m_tokenChar ) && ( m_token . length ( ) > 1 ) && Character . isDigit ( m_token . charAt ( 1 ) ) ) || Character . isDigit ( m_tokenChar ) ) ) { appendOp ( 2 , OpCodes . OP_NUMBERLIT ) ; Number ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; matchFound = true ; } else if ( lookahead ( '(' , 1 ) || ( lookahead ( ':' , 1 ) && lookahead ( '(' , 3 ) ) ) { matchFound = FunctionCall ( ) ; } else { matchFound = false ; } return matchFound ; } protected void Argument ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_ARGUMENT ) ; Expr ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected boolean FunctionCall ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; if ( lookahead ( ':' , 1 ) ) { appendOp ( 4 , OpCodes . OP_EXTFUNCTION ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH + 1 , m_queueMark - 1 ) ; nextToken ( ) ; consumeExpected ( ':' ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH + 2 , m_queueMark - 1 ) ; nextToken ( ) ; } else { int funcTok = getFunctionToken ( m_token ) ; if ( - 1 == funcTok ) { error ( XPATHErrorResources . ER_COULDNOT_FIND_FUNCTION , new Object [ ] { m_token } ) ; } switch ( funcTok ) { case OpCodes . NODETYPE_PI : case OpCodes . NODETYPE_COMMENT : case OpCodes . NODETYPE_TEXT : case OpCodes . NODETYPE_NODE : return false ; default : appendOp ( 3 , OpCodes . OP_FUNCTION ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH + 1 , funcTok ) ; } nextToken ( ) ; } consumeExpected ( '(' ) ; while ( ! tokenIs ( ')' ) && m_token != null ) { if ( tokenIs ( ',' ) ) { error ( XPATHErrorResources . ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , null ) ; } Argument ( ) ; if ( ! tokenIs ( ')' ) ) { consumeExpected ( ',' ) ; if ( tokenIs ( ')' ) ) { error ( XPATHErrorResources . ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , null ) ; } } } consumeExpected ( ')' ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ENDOP ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; return true ; } protected void LocationPath ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_LOCATIONPATH ) ; boolean seenSlash = tokenIs ( '/' ) ; if ( seenSlash ) { appendOp ( 4 , OpCodes . FROM_ROOT ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 2 , 4 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 1 , OpCodes . NODETYPE_ROOT ) ; nextToken ( ) ; } if ( m_token != null ) { if ( ! RelativeLocationPath ( ) && ! seenSlash ) { error ( XPATHErrorResources . ER_EXPECTED_LOC_PATH , new Object [ ] { m_token } ) ; } } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ENDOP ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected boolean RelativeLocationPath ( ) throws javax . xml . transform . TransformerException { if ( ! Step ( ) ) { return false ; } while ( tokenIs ( '/' ) ) { nextToken ( ) ; if ( ! Step ( ) ) { error ( XPATHErrorResources . ER_EXPECTED_LOC_STEP , null ) ; } } return true ; } protected boolean Step ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; boolean doubleSlash = tokenIs ( '/' ) ; if ( doubleSlash ) { nextToken ( ) ; appendOp ( 2 , OpCodes . FROM_DESCENDANTS_OR_SELF ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . NODETYPE_NODE ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH + 1 , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; } if ( tokenIs ( "." ) ) { nextToken ( ) ; if ( tokenIs ( '[' ) ) { error ( XPATHErrorResources . ER_PREDICATE_ILLEGAL_SYNTAX , null ) ; } appendOp ( 4 , OpCodes . FROM_SELF ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 2 , 4 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 1 , OpCodes . NODETYPE_NODE ) ; } else if ( tokenIs ( ".." ) ) { nextToken ( ) ; appendOp ( 4 , OpCodes . FROM_PARENT ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 2 , 4 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 1 , OpCodes . NODETYPE_NODE ) ; } else if ( tokenIs ( '*' ) || tokenIs ( '@' ) || tokenIs ( '_' ) || ( m_token != null && Character . isLetter ( m_token . charAt ( 0 ) ) ) ) { Basis ( ) ; while ( tokenIs ( '[' ) ) { Predicate ( ) ; } m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } else { if ( doubleSlash ) { error ( XPATHErrorResources . ER_EXPECTED_LOC_STEP , null ) ; } return false ; } return true ; } protected void Basis ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; int axesType ; if ( lookahead ( "::" , 1 ) ) { axesType = AxisName ( ) ; nextToken ( ) ; nextToken ( ) ; } else if ( tokenIs ( '@' ) ) { axesType = OpCodes . FROM_ATTRIBUTES ; appendOp ( 2 , axesType ) ; nextToken ( ) ; } else { axesType = OpCodes . FROM_CHILDREN ; appendOp ( 2 , axesType ) ; } m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; NodeTest ( axesType ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH + 1 , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected int AxisName ( ) throws javax . xml . transform . TransformerException { Object val = Keywords . m_axisnames . get ( m_token ) ; if ( null == val ) { error ( XPATHErrorResources . ER_ILLEGAL_AXIS_NAME , new Object [ ] { m_token } ) ; } int axesType = ( ( Integer ) val ) . intValue ( ) ; appendOp ( 2 , axesType ) ; return axesType ; } protected void NodeTest ( int axesType ) throws javax . xml . transform . TransformerException { if ( lookahead ( '(' , 1 ) ) { Object nodeTestOp = Keywords . m_nodetypes . get ( m_token ) ; if ( null == nodeTestOp ) { error ( XPATHErrorResources . ER_UNKNOWN_NODETYPE , new Object [ ] { m_token } ) ; } else { nextToken ( ) ; int nt = ( ( Integer ) nodeTestOp ) . intValue ( ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , nt ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; consumeExpected ( '(' ) ; if ( OpCodes . NODETYPE_PI == nt ) { if ( ! tokenIs ( ')' ) ) { Literal ( ) ; } } consumeExpected ( ')' ) ; } } else { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . NODENAME ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; if ( lookahead ( ':' , 1 ) ) { if ( tokenIs ( '*' ) ) { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ELEMWILDCARD ) ; } else { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , m_queueMark - 1 ) ; if ( ! Character . isLetter ( m_tokenChar ) && ! tokenIs ( '_' ) ) { error ( XPATHErrorResources . ER_EXPECTED_NODE_TEST , null ) ; } } nextToken ( ) ; consumeExpected ( ':' ) ; } else { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . EMPTY ) ; } m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; if ( tokenIs ( '*' ) ) { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ELEMWILDCARD ) ; } else { if ( OpCodes . FROM_NAMESPACE == axesType ) { String prefix = ( String ) this . m_ops . m_tokenQueue . elementAt ( m_queueMark - 1 ) ; String namespace = ( ( PrefixResolver ) m_namespaceContext ) . getNamespaceForPrefix ( prefix ) ; this . m_ops . m_tokenQueue . setElementAt ( namespace , m_queueMark - 1 ) ; } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , m_queueMark - 1 ) ; if ( ! Character . isLetter ( m_tokenChar ) && ! tokenIs ( '_' ) ) { error ( XPATHErrorResources . ER_EXPECTED_NODE_TEST , null ) ; } } m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; nextToken ( ) ; } } protected void Predicate ( ) throws javax . xml . transform . TransformerException { if ( tokenIs ( '[' ) ) { nextToken ( ) ; PredicateExpr ( ) ; consumeExpected ( ']' ) ; } } protected void PredicateExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_PREDICATE ) ; Expr ( ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ENDOP ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected void QName ( ) throws javax . xml . transform . TransformerException { if ( lookahead ( ':' , 1 ) ) { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , m_queueMark - 1 ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; nextToken ( ) ; consumeExpected ( ':' ) ; } else { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . EMPTY ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , m_queueMark - 1 ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; nextToken ( ) ; } protected void NCName ( ) { m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , m_queueMark - 1 ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; nextToken ( ) ; } protected void Literal ( ) throws javax . xml . transform . TransformerException { int last = m_token . length ( ) - 1 ; char c0 = m_tokenChar ; char cX = m_token . charAt ( last ) ; if ( ( ( c0 == '\"' ) && ( cX == '\"' ) ) || ( ( c0 == '\'' ) && ( cX == '\'' ) ) ) { int tokenQueuePos = m_queueMark - 1 ; m_ops . m_tokenQueue . setElementAt ( null , tokenQueuePos ) ; Object obj = new XString ( m_token . substring ( 1 , last ) ) ; m_ops . m_tokenQueue . setElementAt ( obj , tokenQueuePos ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , tokenQueuePos ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; nextToken ( ) ; } else { error ( XPATHErrorResources . ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , new Object [ ] { m_token } ) ; } } protected void Number ( ) throws javax . xml . transform . TransformerException { if ( null != m_token ) { double num ; try { if ( ( m_token . indexOf ( 'e' ) > - 1 ) || ( m_token . indexOf ( 'E' ) > - 1 ) ) throw new NumberFormatException ( ) ; num = Double . valueOf ( m_token ) . doubleValue ( ) ; } catch ( NumberFormatException nfe ) { num = 0.0 ; error ( XPATHErrorResources . ER_COULDNOT_BE_FORMATTED_TO_NUMBER , new Object [ ] { m_token } ) ; } m_ops . m_tokenQueue . setElementAt ( new XNumber ( num ) , m_queueMark - 1 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , m_queueMark - 1 ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; nextToken ( ) ; } } protected void Pattern ( ) throws javax . xml . transform . TransformerException { while ( true ) { LocationPathPattern ( ) ; if ( tokenIs ( '|' ) ) { nextToken ( ) ; } else { break ; } } } protected void LocationPathPattern ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; final int RELATIVE_PATH_NOT_PERMITTED = 0 ; final int RELATIVE_PATH_PERMITTED = 1 ; final int RELATIVE_PATH_REQUIRED = 2 ; int relativePathStatus = RELATIVE_PATH_NOT_PERMITTED ; appendOp ( 2 , OpCodes . OP_LOCATIONPATHPATTERN ) ; if ( lookahead ( '(' , 1 ) && ( tokenIs ( Keywords . FUNC_ID_STRING ) || tokenIs ( Keywords . FUNC_KEY_STRING ) ) ) { IdKeyPattern ( ) ; if ( tokenIs ( '/' ) ) { nextToken ( ) ; if ( tokenIs ( '/' ) ) { appendOp ( 4 , OpCodes . MATCH_ANY_ANCESTOR ) ; nextToken ( ) ; } else { appendOp ( 4 , OpCodes . MATCH_IMMEDIATE_ANCESTOR ) ; } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 2 , 4 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 1 , OpCodes . NODETYPE_FUNCTEST ) ; relativePathStatus = RELATIVE_PATH_REQUIRED ; } } else if ( tokenIs ( '/' ) ) { if ( lookahead ( '/' , 1 ) ) { appendOp ( 4 , OpCodes . MATCH_ANY_ANCESTOR ) ; nextToken ( ) ; relativePathStatus = RELATIVE_PATH_REQUIRED ; } else { appendOp ( 4 , OpCodes . FROM_ROOT ) ; relativePathStatus = RELATIVE_PATH_PERMITTED ; } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 2 , 4 ) ; m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - 1 , OpCodes . NODETYPE_ROOT ) ; nextToken ( ) ; } else { relativePathStatus = RELATIVE_PATH_REQUIRED ; } if ( relativePathStatus != RELATIVE_PATH_NOT_PERMITTED ) { if ( ! tokenIs ( '|' ) && ( null != m_token ) ) { RelativePathPattern ( ) ; } else if ( relativePathStatus == RELATIVE_PATH_REQUIRED ) { error ( XPATHErrorResources . ER_EXPECTED_REL_PATH_PATTERN , null ) ; } } m_ops . setOp ( m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) , OpCodes . ENDOP ) ; m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } protected void IdKeyPattern ( ) throws javax . xml . transform . TransformerException { FunctionCall ( ) ; } protected void RelativePathPattern ( ) throws javax . xml . transform . TransformerException { boolean trailingSlashConsumed = StepPattern ( false ) ; while ( tokenIs ( '/' ) ) { nextToken ( ) ; trailingSlashConsumed = StepPattern ( ! trailingSlashConsumed ) ; } } protected boolean StepPattern ( boolean isLeadingSlashPermitted ) throws javax . xml . transform . TransformerException { return AbbreviatedNodeTestStep ( isLeadingSlashPermitted ) ; } protected boolean AbbreviatedNodeTestStep ( boolean isLeadingSlashPermitted ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; int axesType ; int matchTypePos = - 1 ; if ( tokenIs ( '@' ) ) { axesType = OpCodes . MATCH_ATTRIBUTE ; appendOp ( 2 , axesType ) ; nextToken ( ) ; } else if ( this . lookahead ( "::" , 1 ) ) { if ( tokenIs ( "attribute" ) ) { axesType = OpCodes . MATCH_ATTRIBUTE ; appendOp ( 2 , axesType ) ; } else if ( tokenIs ( "child" ) ) { matchTypePos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; axesType = OpCodes . MATCH_IMMEDIATE_ANCESTOR ; appendOp ( 2 , axesType ) ; } else { axesType = - 1 ; this . error ( XPATHErrorResources . ER_AXES_NOT_ALLOWED , new Object [ ] { this . m_token } ) ; } nextToken ( ) ; nextToken ( ) ; } else if ( tokenIs ( '/' ) ) { if ( ! isLeadingSlashPermitted ) { error ( XPATHErrorResources . ER_EXPECTED_STEP_PATTERN , null ) ; } axesType = OpCodes . MATCH_ANY_ANCESTOR ; appendOp ( 2 , axesType ) ; nextToken ( ) ; } else { matchTypePos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; axesType = OpCodes . MATCH_IMMEDIATE_ANCESTOR ; appendOp ( 2 , axesType ) ; } m_ops . setOp ( OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) + 1 ) ; NodeTest ( axesType ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH + 1 , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; while ( tokenIs ( '[' ) ) { Predicate ( ) ; } boolean trailingSlashConsumed ; if ( ( matchTypePos > - 1 ) && tokenIs ( '/' ) && lookahead ( '/' , 1 ) ) { m_ops . setOp ( matchTypePos , OpCodes . MATCH_ANY_ANCESTOR ) ; nextToken ( ) ; trailingSlashConsumed = true ; } else { trailingSlashConsumed = false ; } m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; return trailingSlashConsumed ; } } 	1	['58', '1', '0', '12', '96', '0', '3', '10', '5', '0.679425837', '3337', '0.454545455', '2', '0', '0.163793103', '0', '0', '56.34482759', '6', '1.4828', '4']
package org . w3c . dom . xpath ; import org . w3c . dom . Node ; import org . w3c . dom . DOMException ; public interface XPathEvaluator { public XPathExpression createExpression ( String expression , XPathNSResolver resolver ) throws XPathException , DOMException ; public XPathNSResolver createNSResolver ( Node nodeResolver ) ; public Object evaluate ( String expression , Node contextNode , XPathNSResolver resolver , short type , Object result ) throws XPathException , DOMException ; } 	1	['3', '1', '0', '0', '3', '3', '0', '0', '3', '2', '3', '0', '0', '0', '0.611111111', '0', '0', '0', '1', '1', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_pl extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Błąd: Nie może być znaku '{' wewnątrz wyrażenia" } , { ER_ILLEGAL_ATTRIBUTE , "{0} ma niedozwolony atrybut {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode jest puste w xsl:apply-imports!" } , { ER_CANNOT_ADD , "Nie można dodać {0} do {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode jest puste w handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "{0} musi mieć atrybut name." } , { ER_TEMPLATE_NOT_FOUND , "Nie można znaleźć szablonu o nazwie {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Nie można przetłumaczyć AVT nazwy w xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} wymaga atrybutu: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} musi mieć atrybut ''test''." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Błędna wartość w atrybucie level: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Nazwą instrukcji przetwarzania nie może być 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Nazwa instrukcji przetwarzania musi być poprawną nazwą NCName {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} musi mieć atrybut match, jeśli ma mode." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} wymaga albo atrybutu name, albo match." } , { ER_CANT_RESOLVE_NSPREFIX , "Nie można rozstrzygnąć przedrostka przestrzeni nazw {0}" } , { ER_ILLEGAL_VALUE , "xml:space ma niepoprawną wartość {0}" } , { ER_NO_OWNERDOC , "Węzeł potomny nie ma dokumentu właściciela!" } , { ER_ELEMTEMPLATEELEM_ERR , "Błąd ElemTemplateElement: {0}" } , { ER_NULL_CHILD , "Próba dodania pustego elementu potomnego!" } , { ER_NEED_SELECT_ATTRIB , "{0} wymaga atrybutu select." } , { ER_NEED_TEST_ATTRIB , "xsl:when musi mieć atrybut 'test'." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param musi mieć atrybut 'name'." } , { ER_NO_CONTEXT_OWNERDOC , "Kontekst nie ma dokumentu właściciela!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Nie można utworzyć połączenia XML TransformerFactory: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: Proces nie wykonał się pomyślnie." } , { ER_NOT_SUCCESSFUL , "Xalan: nie wykonał się pomyślnie." } , { ER_ENCODING_NOT_SUPPORTED , "Nieobsługiwane kodowanie {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Nie można utworzyć TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key wymaga atrybutu 'name'!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key wymaga atrybutu 'match'!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key wymaga atrybutu 'use'!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} wymaga atrybutu ''elements''!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) atrybut {0} ''prefix'' jest nieobecny" } , { ER_BAD_STYLESHEET_URL , "Adres URL arkusza stylów jest błędny {0}" } , { ER_FILE_NOT_FOUND , "Nie znaleziono pliku arkusza stylów {0}" } , { ER_IOEXCEPTION , "Wystąpił wyjątek we/wy w pliku arkusza stylów {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Nie można znaleźć atrybutu href dla {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} zawiera siebie bezpośrednio lub pośrednio!" } , { ER_PROCESSINCLUDE_ERROR , "Błąd StylesheetHandler.processInclude {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) atrybut {0} ''lang'' jest nieobecny" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) źle umieszczony element {0}?? Nieobecny element pojemnika ''component''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Można wyprowadzić dane tylko do Element, DocumentFragment, Document lub PrintWriter." } , { ER_PROCESS_ERROR , "Błąd StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "Błąd UnImplNode: {0}" } , { ER_NO_SELECT_EXPRESSION , "Błąd! Nie znaleziono wyrażenia wyboru xpath (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Nie można szeregować XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "Nie podano danych wejściowych do arkusza stylów!" } , { ER_FAILED_PROCESS_STYLESHEET , "Nie powiodło się przetworzenie arkusza stylów!" } , { ER_COULDNT_PARSE_DOC , "Nie można zanalizować dokumentu {0}!" } , { ER_COULDNT_FIND_FRAGMENT , "Nie można znaleźć fragmentu {0}" } , { ER_NODE_NOT_ELEMENT , "Węzeł wskazywany przez identyfikator fragmentu nie był elementem {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each musi mieć albo atrybut match, albo name" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "templates musi mieć albo atrybut match, albo name" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Brak klonu fragmentu dokumentu!" } , { ER_CANT_CREATE_ITEM , "Nie można utworzyć elementu w wynikowym drzewie {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space w źródłowym pliku XML ma niedozwoloną wartość {0}" } , { ER_NO_XSLKEY_DECLARATION , "Nie ma deklaracji xsl:key dla {0}!" } , { ER_CANT_CREATE_URL , "Błąd! Nie można utworzyć adresu url dla {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions jest nieobsługiwane" } , { ER_PROCESSOR_ERROR , "Błąd XSLT TransformerFactory" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} jest niedozwolone wewnątrz arkusza stylów!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns nie jest już obsługiwane!  Użyj zamiast tego xsl:output." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space nie jest już obsługiwane!  Użyj zamiast tego xsl:strip-space lub xsl:preserve-space." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result nie jest już obsługiwane!  Użyj zamiast tego xsl:output." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} ma niedozwolony atrybut {1}" } , { ER_UNKNOWN_XSL_ELEM , "Nieznany element XSL {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort może być używane tylko z xsl:apply-templates lub xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) błędnie umieszczone xsl:when!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when bez nadrzędnego xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) błędnie umieszczone xsl:otherwise!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise bez nadrzędnego xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} jest niedozwolone wewnątrz szablonu!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) Nieznany przedrostek {1} rozszerzenia {0} przestrzeni nazw" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Importy mogą wystąpić tylko jako pierwsze elementy w arkuszu stylów!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} importuje siebie bezpośrednio lub pośrednio!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:space ma niedozwoloną wartość: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet było niepomyślne!" } , { ER_SAX_EXCEPTION , "Wyjątek SAX" } , { ER_XSLT_ERROR , "Błąd XSLT" } , { ER_CURRENCY_SIGN_ILLEGAL , "Znak waluty jest niedozwolony w ciągu znaków wzorca formatu" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Funkcja Document jest nieobsługiwana w arkuszu stylów DOM!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Nie można rozstrzygnąć przedrostka przelicznika bez przedrostka!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Rozszerzenie Redirect: Nie można pobrać nazwy pliku - atrybut file lub select musi zwrócić poprawny ciąg znaków." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Nie można zbudować FormatterListener w rozszerzeniu Redirect!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Przedrostek w exclude-result-prefixes jest niepoprawny: {0}" } , { ER_MISSING_NS_URI , "Nieobecny identyfikator URI przestrzeni nazw w podanym przedrostku" } , { ER_MISSING_ARG_FOR_OPTION , "Nieobecny argument opcji {0}" } , { ER_INVALID_OPTION , "Niepoprawna opcja {0}" } , { ER_MALFORMED_FORMAT_STRING , "Zniekształcony ciąg znaków formatu {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet wymaga atrybutu 'version'!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Atrybut {0} ma niedozwoloną wartość {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose wymaga xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports jest niedozwolone w xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Nie można użyć DTMLiaison w wyjściowym węźle DOM... przekaż zamiast tego org.apache.xpath.DOM2Helper!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Nie można użyć DTMLiaison w wejściowym węźle DOM... przekaż zamiast tego org.apache.xpath.DOM2Helper!" } , { ER_CALL_TO_EXT_FAILED , "Wywołanie elementu rozszerzenia nie powiodło się: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Przedrostek musi dać się przetłumaczyć na przestrzeń nazw: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Wykryto niepoprawny surogat UTF-16: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} użyło siebie, co wywoła nieskończoną pętlę." } , { ER_CANNOT_MIX_XERCESDOM , "Nie można mieszać wejścia innego niż Xerces-DOM z wyjściem Xerces-DOM!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "W ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Znaleziono więcej niż jeden szablon o nazwie {0}" } , { ER_INVALID_KEY_CALL , "Niepoprawne wywołanie funkcji: rekurencyjne wywołania key() są niedozwolone" } , { ER_REFERENCING_ITSELF , "Zmienna {0} odwołuje się do siebie bezpośrednio lub pośrednio!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Węzeł wejściowy nie może być pusty dla DOMSource dla newTemplates!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Nie znaleziono pliku klasy dla opcji {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Nie znaleziono wymaganego elementu {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream nie może być pusty" } , { ER_URI_CANNOT_BE_NULL , "Identyfikator URI nie może być pusty" } , { ER_FILE_CANNOT_BE_NULL , "Plik nie może być pusty" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource nie może być pusty" } , { ER_CANNOT_INIT_BSFMGR , "Nie można zainicjować menedżera BSF" } , { ER_CANNOT_CMPL_EXTENSN , "Nie można skompilować rozszerzenia" } , { ER_CANNOT_CREATE_EXTENSN , "Nie można utworzyć rozszerzenia {0} z powodu  {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "Wywołanie metody Instance do metody {0} wymaga instancji Object jako pierwszego argumentu" } , { ER_INVALID_ELEMENT_NAME , "Podano niepoprawną nazwę elementu {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Metoda nazwy elementu musi być statyczna {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Funkcja rozszerzenia {0} : {1} jest nieznana" } , { ER_MORE_MATCH_CONSTRUCTOR , "Więcej niż jedno najlepsze dopasowanie dla konstruktora {0}" } , { ER_MORE_MATCH_METHOD , "Więcej niż jedno najlepsze dopasowanie dla metody {0}" } , { ER_MORE_MATCH_ELEMENT , "Więcej niż jedno najlepsze dopasowanie dla metody elementu {0}" } , { ER_INVALID_CONTEXT_PASSED , "Przekazano niepoprawny kontekst do wyliczenia {0}" } , { ER_POOL_EXISTS , "Pula już istnieje" } , { ER_NO_DRIVER_NAME , "Nie podano nazwy sterownika" } , { ER_NO_URL , "Nie podano adresu URL" } , { ER_POOL_SIZE_LESSTHAN_ONE , "Wielkość puli jest mniejsza od jedności!" } , { ER_INVALID_DRIVER , "Podano niepoprawną nazwę sterownika!" } , { ER_NO_STYLESHEETROOT , "Nie znaleziono elementu głównego arkusza stylów!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Niedozwolona wartość xml:space" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode nie powiodło się" } , { ER_RESOURCE_COULD_NOT_LOAD , "Zasób [ {0} ] nie mógł załadować: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Wielkość bufora <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Nieznany błąd podczas wywoływania rozszerzenia" } , { ER_NO_NAMESPACE_DECL , "Przedrostek {0} nie ma odpowiadającej deklaracji przestrzeni nazw" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Zawartość elementu niedozwolona dla lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Arkusz stylów zarządził zakończenie" } , { ER_ONE_OR_TWO , "1 lub 2" } , { ER_TWO_OR_THREE , "2 lub 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Nie można załadować {0} (sprawdź CLASSPATH), używane są teraz wartości domyślne" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Nie można zainicjować domyślnych szablonów" } , { ER_RESULT_NULL , "Rezultat nie powinien być pusty" } , { ER_RESULT_COULD_NOT_BE_SET , "Nie można ustawić rezultatu" } , { ER_NO_OUTPUT_SPECIFIED , "Nie podano wyjścia" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Nie można przekształcić do rezultatu o typie {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Nie można przekształcić źródła o typie {0}" } , { ER_NULL_CONTENT_HANDLER , "Pusta procedura obsługi zawartości" } , { ER_NULL_ERROR_HANDLER , "Pusta procedura obsługi błędu" } , { ER_CANNOT_CALL_PARSE , "Nie można wywołać parse, jeśli nie ustawiono ContentHandler" } , { ER_NO_PARENT_FOR_FILTER , "Brak elementu nadrzędnego dla filtru" } , { ER_NO_STYLESHEET_IN_MEDIA , "Nie znaleziono arkusza stylów w {0}, nośnik= {1}" } , { ER_NO_STYLESHEET_PI , "Nie znaleziono instrukcji przetwarzania xml-stylesheet w {0}" } , { ER_NOT_SUPPORTED , "Nieobsługiwane: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Wartość właściwości {0} powinna być instancją typu Boolean" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "Nie można się dostać do zewnętrznego skryptu w {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "Nie można znaleźć zasobu [ {0} ].\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Nierozpoznana właściwość wyjściowa {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Nie powiodło się utworzenie instancji ElemLiteralResult" } , { ER_VALUE_SHOULD_BE_NUMBER , "Wartość {0} powinna zawierać liczbę możliwą do zanalizowania" } , { ER_VALUE_SHOULD_EQUAL , "Wartością {0} powinno być yes lub no" } , { ER_FAILED_CALLING_METHOD , "Niepowodzenie wywołania metody {0}" } , { ER_FAILED_CREATING_ELEMTMPL , "Nie powiodło się utworzenie instancji ElemTemplateElement" } , { ER_CHARS_NOT_ALLOWED , "W tym miejscu dokumentu znaki są niedozwolone" } , { ER_ATTR_NOT_ALLOWED , "Atrybut \"{0}\" nie jest dozwolony w elemencie {1}!" } , { ER_BAD_VALUE , "Błędna wartość {0} {1}" } , { ER_ATTRIB_VALUE_NOT_FOUND , "Nie znaleziono wartości atrybutu {0}" } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "Nie rozpoznano wartości atrybutu {0}" } , { ER_NULL_URI_NAMESPACE , "Próba wygenerowania przedrostka przestrzeni nazw z pustym identyfikatorem URI" } , { ER_NUMBER_TOO_BIG , "Próba sformatowania liczby większej niż największa liczba typu long integer" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Nie można znaleźć klasy sterownika SAX1 {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "Znaleziono klasę sterownika SAX1 {0}, ale nie można jej załadować" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "Klasa sterownika SAX1 {0} została załadowana, ale nie można utworzyć jej instancji" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "Klasa sterownika SAX1 {0} nie implementuje org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Właściwość systemowa org.xml.sax.parser nie została podana" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Argument analizatora nie może być pusty" } , { ER_FEATURE , "Opcja: {0}" } , { ER_PROPERTY , "Właściwość: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Pusty przelicznik encji" } , { ER_NULL_DTD_HANDLER , "Pusta procedura obsługi DTD" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Nie podano nazwy sterownika!" } , { ER_NO_URL_SPECIFIED , "Nie podano adresu URL!" } , { ER_POOLSIZE_LESS_THAN_ONE , "Wielkość puli jest mniejsza od 1!" } , { ER_INVALID_DRIVER_NAME , "Podano niepoprawną nazwę sterownika!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Błąd programisty! Wyrażenie nie ma elementu nadrzędnego ElemTemplateElement!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Asercja programisty w RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} jest niedozwolone na tej pozycji w arkuszu stylów!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Tekst złożony ze znaków innych niż odstępy jest niedozwolony na tej pozycji w arkuszu stylów!" } , { INVALID_TCHAR , "Niedozwolona wartość {1} użyta w atrybucie CHAR {0}.  Atrybut typu CHAR musi być pojedynczym znakiem!" } , { INVALID_QNAME , "Niedozwolona wartość {1} użyta w atrybucie QNAME {0}" } , { INVALID_ENUM , "Niedozwolona wartość {1} użyta w atrybucie ENUM {0}.  Poprawne wartości to: {2}." } , { INVALID_NMTOKEN , "Niedozwolona wartość {1} użyta w atrybucie NMTOKEN {0}" } , { INVALID_NCNAME , "Niedozwolona wartość {1} użyta w atrybucie NCNAME {0}" } , { INVALID_BOOLEAN , "Niedozwolona wartość {1} użyta w atrybucie boolowskim {0}" } , { INVALID_NUMBER , "Niedozwolona wartość {1} użyta w atrybucie liczbowym {0}" } , { ER_ARG_LITERAL , "Argument opcji {0} we wzorcu uzgadniania musi być literałem." } , { ER_DUPLICATE_GLOBAL_VAR , "Zduplikowana deklaracja zmiennej globalnej." } , { ER_DUPLICATE_VAR , "Zduplikowana deklaracja zmiennej." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template musi mieć atrybut name lub match (lub obydwa)" } , { ER_INVALID_PREFIX , "Przedrostek w exclude-result-prefixes jest niepoprawny: {0}" } , { ER_NO_ATTRIB_SET , "Zbiór atrybutów o nazwie {0} nie istnieje" } , { WG_FOUND_CURLYBRACE , "Znaleziono '}', ale nie jest otwarty żaden szablon atrybutów!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Ostrzeżenie: Atrybut count nie jest zgodny ze swym przodkiem w xsl:number! Cel = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Stara składnia: Nazwa atrybutu 'expr' została zmieniona na 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan nie obsługuje jeszcze nazwy lokalizacji w funkcji format-number." } , { WG_LOCALE_NOT_FOUND , "Ostrzeżenie: Nie można znaleźć ustawień narodowych dla xml:lang={0}" } , { WG_CANNOT_MAKE_URL_FROM , "Nie można utworzyć adresu URL z {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Nie można załadować żądanego dokumentu {0}" } , { WG_CANNOT_FIND_COLLATOR , "Nie można znaleźć Collator dla <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Stara składnia: Instrukcja functions powinna używać adresu url {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "Kodowanie nieobsługiwane: {0}, używane jest UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "Kodowanie nieobsługiwane: {0}, używane jest Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Znaleziono konflikty specyfiki {0}, używany będzie ostatni znaleziony w arkuszu stylów." } , { WG_PARSING_AND_PREPARING , "========= Analizowanie i przygotowywanie {0} ==========" } , { WG_ATTR_TEMPLATE , "Szablon atrybutu {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Konflikt zgodności pomiędzy xsl:strip-space oraz xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan nie obsługuje jeszcze atrybutu {0}!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Nie znaleziono deklaracji formatu dziesiętnego {0}" } , { WG_OLD_XSLT_NS , "Nieobecna lub niepoprawna przestrzeń nazw XSLT." } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Dozwolona jest tylko jedna domyślna deklaracja xsl:decimal-format." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "Nazwy xsl:decimal-format muszą być unikalne. Nazwa \"{0}\" została zduplikowana." } , { WG_ILLEGAL_ATTRIBUTE , "{0} ma niedozwolony atrybut {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Nie można przetłumaczyć przedrostka przestrzeni nazw {0}. Węzeł zostanie zignorowany." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet wymaga atrybutu 'version'!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Niedozwolona nazwa atrybutu {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Niedozwolona wartość atrybutu {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "Wynikający z drugiego argumentu funkcji document zestaw węzłów jest pusty. Zwracany jest pusty zestaw węzłów." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Wartością atrybutu 'name' nazwy xsl:processing-instruction nie może być 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Wartością atrybutu 'name' xsl:processing-instruction musi być poprawna nazwa NCName: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Nie można dodać atrybutu {0} po węzłach potomnych ani przed wyprodukowaniem elementu.  Atrybut zostanie zignorowany." } , { "ui_language" , "pl" } , { "help_language" , "pl" } , { "language" , "pl" } , { "BAD_CODE" , "Parametr createMessage był spoza zakresu" } , { "FORMAT_FAILED" , "Podczas wywołania messageFormat zgłoszony został wyjątek" } , { "version" , ">>>>>>> Wersja Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "tak" } , { "line" , "Wiersz: " } , { "column" , "Kolumna: " } , { "xsldone" , "XSLProcessor: gotowe" } , { "xslProc_option" , "Opcje wiersza komend klasy Process Xalan-J:" } , { "xslProc_option" , "Opcje wiersza komend klasy Process Xalan-J:" } , { "xslProc_invalid_xsltc_option" , "Opcja {0} jest nieobsługiwana w trybie XSLTC." } , { "xslProc_invalid_xalan_option" , "Opcji {0} można używać tylko razem z -XSLTC." } , { "xslProc_no_input" , "Błąd: Nie podano arkusza stylów lub wejściowego pliku xml. Wykonaj tę komendę bez żadnych opcji, aby zapoznać się z informacjami o składni." } , { "xslProc_common_options" , "-Wspólne opcje-" } , { "xslProc_xalan_options" , "-Opcje dla Xalan-" } , { "xslProc_xsltc_options" , "-Opcje dla XSLTC-" } , { "xslProc_return_to_continue" , "(naciśnij klawisz <enter>, aby kontynuować)" } , { "optionXSLTC" , "   [-XSLTC (użycie XSLTC do transformacji)]" } , { "optionIN" , "   [-IN wejściowyXMLURL]" } , { "optionXSL" , "   [-XSL URLTransformacjiXSL]" } , { "optionOUT" , "   [-OUT NazwaPlikuWyjściowego]" } , { "optionLXCIN" , "   [-LXCIN NazwaWejściowegoPlikuSkompilowanegoArkuszaStylów]" } , { "optionLXCOUT" , "   [-LXCOUT NazwaWyjściowegoPlikuSkompilowanegoArkuszaStylów]" } , { "optionPARSER" , "   [-PARSER pełna nazwa klasy połączenia analizatora]" } , { "optionE" , "   [-E (bez rozwijania referencji encji)]" } , { "optionV" , "   [-E (bez rozwijania referencji encji)]" } , { "optionQC" , "   [-QC (ciche ostrzeżenia o konfliktach wzorców)]" } , { "optionQ" , "   [-Q  (tryb cichy)]" } , { "optionLF" , "   [-LF (użycie tylko znaków wysuwu wiersza na wyjściu {domyślnie CR/LF})]" } , { "optionCR" , "   [-LF (użycie tylko znaków powrotu karetki na wyjściu {domyślnie CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (znaki o zmienionym znaczeniu {domyślne <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (liczba znaków wcięcia {domyślnie 0})]" } , { "optionTT" , "   [-TT (śledzenie szablonów podczas ich wywoływania)]" } , { "optionTG" , "   [-TG (śledzenie każdego zdarzenia generowania)]" } , { "optionTS" , "   [-TS (śledzenie każdego zdarzenia wyboru)]" } , { "optionTTC" , "   [-TTC (śledzenie szablonów potomnych podczas ich przetwarzania)]" } , { "optionTCLASS" , "   [-TCLASS (klasa TraceListener dla rozszerzeń śledzenia)]" } , { "optionVALIDATE" , "   [-VALIDATE (włączenie sprawdzania poprawności - domyślnie jest wyłączona)]" } , { "optionEDUMP" , "   [-EDUMP {opcjonalna nazwa pliku} (wykonywanie zrzutu stosu w przypadku wystąpienia błędu)]" } , { "optionXML" , "   [-XML (użycie formatera XML i dodanie nagłówka XML)]" } , { "optionTEXT" , "   [-TEXT (użycie prostego formatera tekstu)]" } , { "optionHTML" , "   [-HTML (użycie formatera HTML)]" } , { "optionPARAM" , "   [-PARAM nazwa wyrażenie (ustawienie parametru arkusza stylów)]" } , { "noParsermsg1" , "Proces XSL nie wykonał się pomyślnie." } , { "noParsermsg2" , "** Nie można znaleźć analizatora **" } , { "noParsermsg3" , "Sprawdź classpath." } , { "noParsermsg4" , "Jeśli nie masz analizatora XML dla języka Java firmy IBM, możesz go pobrać" } , { "noParsermsg5" , "z serwisu AlphaWorks firmy IBM: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER pełna nazwa klasy (URIResolver używany do tłumaczenia URI)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER pełna nazwa klasy (EntityResolver używany do tłumaczenia encji)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER pełna nazwa klasy (ContentHandler używany do szeregowania wyjścia)]" } , { "optionLINENUMBERS" , "    [-L użycie numerów wierszy w dokumentach źródłowych]" } , { "optionMEDIA" , "   [-MEDIA typ_nośnika (używaj atrybutu media w celu znalezienia arkusza stylów związanego z dokumentem)]" } , { "optionFLAVOR" , "   [-FLAVOR nazwa_posmaku (używaj jawnie s2s=SAX lub d2d=DOM w celu wykonania transformacji)]" } , { "optionDIAG" , "   [-DIAG (wyświetlenie całkowitego czasu trwania transformacji)]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL (żądanie przyrostowego budowania DTM poprzez ustawienie http://xml.apache.org/xalan/features/incremental true.)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE (żądanie braku optymalizowania arkuszy stylów poprzez ustawienie http://xml.apache.org/xalan/features/optimize false.)]" } , { "optionRL" , "   [-RL limit_rekurencji (określenie liczbowego limitu głębokości rekurencji w arkuszach stylów)]" } , { "optionXO" , "   [-XO [NazwaTransletu] (przypisanie nazwy wygenerowanemu transletowi)]" } , { "optionXD" , "   [-XD KatalogDocelowy (określenie katalogu docelowego dla transletu)]" } , { "optionXJ" , "   [-XJ plik_jar (pakowanie klas transletu do pliku jar o nazwie <plik_jar>)]" } , { "optionXP" , "   [-XP pakiet (określenie przedrostka nazwy pakietu dla wszystkich wygenerowanych klas transletu)]" } , { "optionXN" , "   [-XN (włączenie wstawiania szablonów)]" } , { "optionXX" , "   [-XX (włączenie dodatkowych diagnostycznych komunikatów wyjściowych)]" } , { "optionXT" , "   [-XT (użycie transletu do transformacji, jeśli to możliwe)]" } , { "diagTiming" , "--------- Transformacja {0} przez {1} zajęła {2} ms" } , { "recursionTooDeep" , "Zbyt głębokie zagnieżdżenie szablonów. zagnieżdżenie= {0}, szablon {1} {2}" } , { "nameIs" , "nazwą jest" } , { "matchPatternIs" , "wzorcem uzgadniania jest" } } ; public static final String BAD_CODE = "BŁĘDNY_KOD" ; public static final String FORMAT_FAILED = "FORMATOWANIE_NIE_POWIODŁO_SIĘ" ; public static final String ERROR_STRING = "nr błędu" ; public static final String ERROR_HEADER = "Błąd: " ; public static final String WARNING_HEADER = "Ostrzeżenie: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "WZORZEC " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "pl" , "PL" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_de extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Interner Fehler bei der Ausführung in ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Fehler bei der Ausführung von <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Ungültige Konvertierung von ''{0}'' nach ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "Die externe Funktion ''{0}'' wird nicht von XSLTC unterstützt." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Unbekannter Argumenttyp in Gleichheitsausdruck." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Ungültiger Argumenttyp ''{0}'' in Aufruf von ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Es wird versucht, die Zahl ''{0}'' mit Muster ''{1}'' zu formatieren." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Iterator ''{0}'' kann nicht geklont werden." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Iterator für Achse ''{0}'' wird nicht unterstützt." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Iterator für Achse ''{0}'' mit Typangabe wird nicht unterstützt." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Attribut ''{0}'' befindet sich nicht in einem Element." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Namensbereichsdeklaration ''{0}''=''{1}'' befindet sich nicht in einem Element." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "Der Namensbereich für Präfix ''{0}'' wurde nicht deklariert." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter wurde mit dem falschen Typ für das Dokumentobjektmodell der Quelle erstellt." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "Der von Ihnen verwendete SAX-Parser bearbeitet keine DTD-Deklarationsereignisse." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "Der von Ihnen verwendete SAX-Parser unterstützt keine XML-Namensbereiche." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "Der URI-Verweis ''{0}'' konnte nicht aufgelöst werden." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . w3c . dom . xpath ; import org . w3c . dom . Node ; import org . w3c . dom . DOMException ; public interface XPathResult { public static final short ANY_TYPE = 0 ; public static final short NUMBER_TYPE = 1 ; public static final short STRING_TYPE = 2 ; public static final short BOOLEAN_TYPE = 3 ; public static final short UNORDERED_NODE_ITERATOR_TYPE = 4 ; public static final short ORDERED_NODE_ITERATOR_TYPE = 5 ; public static final short UNORDERED_NODE_SNAPSHOT_TYPE = 6 ; public static final short ORDERED_NODE_SNAPSHOT_TYPE = 7 ; public static final short ANY_UNORDERED_NODE_TYPE = 8 ; public static final short FIRST_ORDERED_NODE_TYPE = 9 ; public short getResultType ( ) ; public double getNumberValue ( ) throws XPathException ; public String getStringValue ( ) throws XPathException ; public boolean getBooleanValue ( ) throws XPathException ; public Node getSingleNodeValue ( ) throws XPathException ; public boolean getInvalidIteratorState ( ) ; public int getSnapshotLength ( ) throws XPathException ; public Node iterateNext ( ) throws XPathException , DOMException ; public Node snapshotItem ( int index ) throws XPathException ; } 	1	['9', '1', '0', '0', '9', '36', '0', '0', '9', '1.125', '19', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '1']
package org . apache . xml . utils ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; public class PrefixResolverDefault implements PrefixResolver { Node m_context ; public PrefixResolverDefault ( Node xpathExpressionContext ) { m_context = xpathExpressionContext ; } public String getNamespaceForPrefix ( String prefix ) { return getNamespaceForPrefix ( prefix , m_context ) ; } public String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node namespaceContext ) { Node parent = namespaceContext ; String namespace = null ; if ( prefix . equals ( "xml" ) ) { namespace = Constants . S_XMLNAMESPACEURI ; } else { int type ; while ( ( null != parent ) && ( null == namespace ) && ( ( ( type = parent . getNodeType ( ) ) == Node . ELEMENT_NODE ) || ( type == Node . ENTITY_REFERENCE_NODE ) ) ) { if ( type == Node . ELEMENT_NODE ) { if ( parent . getNodeName ( ) . indexOf ( prefix + ":" ) == 0 ) return parent . getNamespaceURI ( ) ; NamedNodeMap nnm = parent . getAttributes ( ) ; for ( int i = 0 ; i < nnm . getLength ( ) ; i ++ ) { Node attr = nnm . item ( i ) ; String aname = attr . getNodeName ( ) ; boolean isPrefix = aname . startsWith ( "xmlns:" ) ; if ( isPrefix || aname . equals ( "xmlns" ) ) { int index = aname . indexOf ( ':' ) ; String p = isPrefix ? aname . substring ( index + 1 ) : "" ; if ( p . equals ( prefix ) ) { namespace = attr . getNodeValue ( ) ; break ; } } } } parent = parent . getParentNode ( ) ; } } return namespace ; } public String getBaseIdentifier ( ) { return null ; } public boolean handlesNullPrefixes ( ) { return false ; } } 	1	['5', '1', '1', '4', '22', '8', '3', '1', '5', '0.75', '122', '0', '0', '0', '0.6', '0', '0', '23.2', '13', '3.2', '1']
package org . apache . xml . utils ; public class SuballocatedByteVector { protected int m_blocksize ; protected int m_numblocks = 32 ; protected byte m_map [ ] [ ] ; protected int m_firstFree = 0 ; protected byte m_map0 [ ] ; public SuballocatedByteVector ( ) { this ( 2048 ) ; } public SuballocatedByteVector ( int blocksize ) { m_blocksize = blocksize ; m_map0 = new byte [ blocksize ] ; m_map = new byte [ m_numblocks ] [ ] ; m_map [ 0 ] = m_map0 ; } public SuballocatedByteVector ( int blocksize , int increaseSize ) { this ( blocksize ) ; } public int size ( ) { return m_firstFree ; } private void setSize ( int sz ) { if ( m_firstFree < sz ) m_firstFree = sz ; } public void addElement ( byte value ) { if ( m_firstFree < m_blocksize ) m_map0 [ m_firstFree ++ ] = value ; else { int index = m_firstFree / m_blocksize ; int offset = m_firstFree % m_blocksize ; ++ m_firstFree ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; byte [ ] [ ] newMap = new byte [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; block [ offset ] = value ; } } private void addElements ( byte value , int numberOfElements ) { if ( m_firstFree + numberOfElements < m_blocksize ) for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map0 [ m_firstFree ++ ] = value ; } else { int index = m_firstFree / m_blocksize ; int offset = m_firstFree % m_blocksize ; m_firstFree += numberOfElements ; while ( numberOfElements > 0 ) { if ( index >= m_map . length ) { int newsize = index + m_numblocks ; byte [ ] [ ] newMap = new byte [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; int copied = ( m_blocksize - offset < numberOfElements ) ? m_blocksize - offset : numberOfElements ; numberOfElements -= copied ; while ( copied -- > 0 ) block [ offset ++ ] = value ; ++ index ; offset = 0 ; } } } private void addElements ( int numberOfElements ) { int newlen = m_firstFree + numberOfElements ; if ( newlen > m_blocksize ) { int index = m_firstFree % m_blocksize ; int newindex = ( m_firstFree + numberOfElements ) % m_blocksize ; for ( int i = index + 1 ; i <= newindex ; ++ i ) m_map [ i ] = new byte [ m_blocksize ] ; } m_firstFree = newlen ; } private void insertElementAt ( byte value , int at ) { if ( at == m_firstFree ) addElement ( value ) ; else if ( at > m_firstFree ) { int index = at / m_blocksize ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; byte [ ] [ ] newMap = new byte [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; int offset = at % m_blocksize ; block [ offset ] = value ; m_firstFree = offset + 1 ; } else { int index = at / m_blocksize ; int maxindex = m_firstFree + 1 / m_blocksize ; ++ m_firstFree ; int offset = at % m_blocksize ; byte push ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; byte [ ] block = m_map [ index ] ; if ( null == block ) { push = 0 ; block = m_map [ index ] = new byte [ m_blocksize ] ; } else { push = block [ m_blocksize - 1 ] ; System . arraycopy ( block , offset , block , offset + 1 , copylen ) ; } block [ offset ] = value ; value = push ; offset = 0 ; ++ index ; } } } public void removeAllElements ( ) { m_firstFree = 0 ; } private boolean removeElement ( byte s ) { int at = indexOf ( s , 0 ) ; if ( at < 0 ) return false ; removeElementAt ( at ) ; return true ; } private void removeElementAt ( int at ) { if ( at < m_firstFree ) { int index = at / m_blocksize ; int maxindex = m_firstFree / m_blocksize ; int offset = at % m_blocksize ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; else System . arraycopy ( block , offset + 1 , block , offset , copylen ) ; if ( index < maxindex ) { byte [ ] next = m_map [ index + 1 ] ; if ( next != null ) block [ m_blocksize - 1 ] = ( next != null ) ? next [ 0 ] : 0 ; } else block [ m_blocksize - 1 ] = 0 ; offset = 0 ; ++ index ; } } -- m_firstFree ; } public void setElementAt ( byte value , int at ) { if ( at < m_blocksize ) { m_map0 [ at ] = value ; return ; } int index = at / m_blocksize ; int offset = at % m_blocksize ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; byte [ ] [ ] newMap = new byte [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } byte [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new byte [ m_blocksize ] ; block [ offset ] = value ; if ( at >= m_firstFree ) m_firstFree = at + 1 ; } public byte elementAt ( int i ) { if ( i < m_blocksize ) return m_map0 [ i ] ; return m_map [ i / m_blocksize ] [ i % m_blocksize ] ; } private boolean contains ( byte s ) { return ( indexOf ( s , 0 ) >= 0 ) ; } public int indexOf ( byte elem , int index ) { if ( index >= m_firstFree ) return - 1 ; int bindex = index / m_blocksize ; int boffset = index % m_blocksize ; int maxindex = m_firstFree / m_blocksize ; byte [ ] block ; for ( ; bindex < maxindex ; ++ bindex ) { block = m_map [ bindex ] ; if ( block != null ) for ( int offset = boffset ; offset < m_blocksize ; ++ offset ) if ( block [ offset ] == elem ) return offset + bindex * m_blocksize ; boffset = 0 ; } int maxoffset = m_firstFree % m_blocksize ; block = m_map [ maxindex ] ; for ( int offset = boffset ; offset < maxoffset ; ++ offset ) if ( block [ offset ] == elem ) return offset + maxindex * m_blocksize ; return - 1 ; } public int indexOf ( byte elem ) { return indexOf ( elem , 0 ) ; } private int lastIndexOf ( byte elem ) { int boffset = m_firstFree % m_blocksize ; for ( int index = m_firstFree / m_blocksize ; index >= 0 ; -- index ) { byte [ ] block = m_map [ index ] ; if ( block != null ) for ( int offset = boffset ; offset >= 0 ; -- offset ) if ( block [ offset ] == elem ) return offset + index * m_blocksize ; boffset = 0 ; } return - 1 ; } } 	1	['18', '1', '0', '0', '20', '3', '0', '0', '10', '0.329411765', '830', '1', '0', '0', '0.685185185', '0', '0', '44.83333333', '8', '3.1111', '1']
package org . apache . xalan . transformer ; import java . io . IOException ; import java . io . StringWriter ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . extensions . ExtensionsTable ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . serializer . Method ; import org . apache . xml . serializer . Serializer ; import org . apache . xml . serializer . SerializerFactory ; import org . apache . xalan . templates . AVT ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemAttributeSet ; import org . apache . xalan . templates . ElemForEach ; import org . apache . xalan . templates . ElemSort ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xalan . templates . ElemVariable ; import org . apache . xalan . templates . OutputProperties ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetComposed ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xalan . templates . XUnresolvedVariable ; import org . apache . xalan . trace . GenerateEvent ; import org . apache . xalan . trace . TraceManager ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . serializer . ToHTMLSAXHandler ; import org . apache . xml . serializer . ToSAXHandler ; import org . apache . xml . serializer . ToTextSAXHandler ; import org . apache . xml . serializer . ToTextStream ; import org . apache . xml . serializer . ToXMLSAXHandler ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . DOMBuilder ; import org . apache . xml . utils . NodeVector ; import org . apache . xml . utils . ObjectPool ; import org . apache . xml . utils . ObjectStack ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xml . utils . ThreadControllerWrapper ; import org . apache . xpath . Arg ; import org . apache . xpath . ExtensionsProvider ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . objects . XObject ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; public class TransformerImpl extends Transformer implements Runnable , DTMWSFilter , ExtensionsProvider , org . apache . xml . serializer . SerializerTrace { private Boolean m_reentryGuard = new Boolean ( true ) ; private java . io . FileOutputStream m_outputStream = null ; private boolean m_parserEventsOnMain = true ; private Thread m_transformThread ; private String m_urlOfSource = null ; private Result m_outputTarget = null ; private OutputProperties m_outputFormat ; ContentHandler m_inputContentHandler ; private ContentHandler m_outputContentHandler = null ; DocumentBuilder m_docBuilder = null ; private ObjectPool m_textResultHandlerObjectPool = new ObjectPool ( ToTextStream . class ) ; private ObjectPool m_stringWriterObjectPool = new ObjectPool ( StringWriter . class ) ; private OutputProperties m_textformat = new OutputProperties ( Method . TEXT ) ; ObjectStack m_currentTemplateElements = new ObjectStack ( XPathContext . RECURSIONLIMIT ) ; Stack m_currentMatchTemplates = new Stack ( ) ; NodeVector m_currentMatchedNodes = new NodeVector ( ) ; private StylesheetRoot m_stylesheetRoot = null ; private boolean m_quietConflictWarnings = true ; private XPathContext m_xcontext ; private StackGuard m_stackGuard ; private SerializationHandler m_serializationHandler ; private KeyManager m_keyManager = new KeyManager ( ) ; Stack m_attrSetStack = null ; CountersTable m_countersTable = null ; BoolStack m_currentTemplateRuleIsNull = new BoolStack ( ) ; ObjectStack m_currentFuncResult = new ObjectStack ( ) ; private MsgMgr m_msgMgr ; public static boolean S_DEBUG = false ; private ErrorListener m_errorHandler = new org . apache . xml . utils . DefaultErrorHandler ( ) ; private TraceManager m_traceManager = new TraceManager ( this ) ; private Exception m_exceptionThrown = null ; private Source m_xmlSource ; private int m_doc ; private boolean m_isTransformDone = false ; private boolean m_hasBeenReset = false ; private boolean m_shouldReset = true ; public void setShouldReset ( boolean shouldReset ) { m_shouldReset = shouldReset ; } private Stack m_modes = new Stack ( ) ; public TransformerImpl ( StylesheetRoot stylesheet ) { setStylesheet ( stylesheet ) ; setXPathContext ( new XPathContext ( this ) ) ; getXPathContext ( ) . setNamespaceContext ( stylesheet ) ; m_stackGuard = new StackGuard ( this ) ; } private ExtensionsTable m_extensionsTable = null ; public ExtensionsTable getExtensionsTable ( ) { return m_extensionsTable ; } void setExtensionsTable ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { try { if ( sroot . getExtensions ( ) != null ) m_extensionsTable = new ExtensionsTable ( sroot ) ; } catch ( javax . xml . transform . TransformerException te ) { te . printStackTrace ( ) ; } } public boolean functionAvailable ( String ns , String funcName ) throws javax . xml . transform . TransformerException { return getExtensionsTable ( ) . functionAvailable ( ns , funcName ) ; } public boolean elementAvailable ( String ns , String elemName ) throws javax . xml . transform . TransformerException { return getExtensionsTable ( ) . elementAvailable ( ns , elemName ) ; } public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey ) throws javax . xml . transform . TransformerException { return getExtensionsTable ( ) . extFunction ( ns , funcName , argVec , methodKey , getXPathContext ( ) . getExpressionContext ( ) ) ; } public Object extFunction ( FuncExtFunction extFunction , Vector argVec ) throws javax . xml . transform . TransformerException { return getExtensionsTable ( ) . extFunction ( extFunction , argVec , getXPathContext ( ) . getExpressionContext ( ) ) ; } public void reset ( ) { if ( ! m_hasBeenReset && m_shouldReset ) { m_hasBeenReset = true ; if ( this . m_outputStream != null ) { try { m_outputStream . close ( ) ; } catch ( java . io . IOException ioe ) { } } m_outputStream = null ; m_countersTable = null ; m_xcontext . reset ( ) ; m_xcontext . getVarStack ( ) . reset ( ) ; resetUserParameters ( ) ; m_currentTemplateElements . removeAllElements ( ) ; m_currentMatchTemplates . removeAllElements ( ) ; m_currentMatchedNodes . removeAllElements ( ) ; m_serializationHandler = null ; m_outputTarget = null ; m_keyManager = new KeyManager ( ) ; m_attrSetStack = null ; m_countersTable = null ; m_currentTemplateRuleIsNull = new BoolStack ( ) ; m_xmlSource = null ; m_doc = DTM . NULL ; m_isTransformDone = false ; m_transformThread = null ; m_xcontext . getSourceTreeManager ( ) . reset ( ) ; } } public boolean getProperty ( String property ) { return false ; } public void setProperty ( String property , Object value ) { } public boolean isParserEventsOnMain ( ) { return m_parserEventsOnMain ; } public Thread getTransformThread ( ) { return m_transformThread ; } public void setTransformThread ( Thread t ) { m_transformThread = t ; } private boolean m_hasTransformThreadErrorCatcher = false ; public boolean hasTransformThreadErrorCatcher ( ) { return m_hasTransformThreadErrorCatcher ; } public void transform ( Source source ) throws TransformerException { transform ( source , true ) ; } public void transform ( Source source , boolean shouldRelease ) throws TransformerException { try { if ( getXPathContext ( ) . getNamespaceContext ( ) == null ) { getXPathContext ( ) . setNamespaceContext ( getStylesheet ( ) ) ; } String base = source . getSystemId ( ) ; if ( null == base ) { base = m_stylesheetRoot . getBaseIdentifier ( ) ; } if ( null == base ) { String currentDir = "" ; try { currentDir = System . getProperty ( "user.dir" ) ; } catch ( SecurityException se ) { } if ( currentDir . startsWith ( java . io . File . separator ) ) base = "file://" + currentDir ; else base = "file:///" + currentDir ; base = base + java . io . File . separatorChar + source . getClass ( ) . getName ( ) ; } setBaseURLOfSource ( base ) ; DTMManager mgr = m_xcontext . getDTMManager ( ) ; if ( ( source instanceof StreamSource && source . getSystemId ( ) == null && ( ( StreamSource ) source ) . getInputStream ( ) == null && ( ( StreamSource ) source ) . getReader ( ) == null ) || ( source instanceof SAXSource && ( ( SAXSource ) source ) . getInputSource ( ) == null && ( ( SAXSource ) source ) . getXMLReader ( ) == null ) || ( source instanceof DOMSource && ( ( DOMSource ) source ) . getNode ( ) == null ) ) { try { DocumentBuilderFactory builderF = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = builderF . newDocumentBuilder ( ) ; String systemID = source . getSystemId ( ) ; source = new DOMSource ( builder . newDocument ( ) ) ; if ( systemID != null ) { source . setSystemId ( systemID ) ; } } catch ( ParserConfigurationException e ) { fatalError ( e ) ; } } DTM dtm = mgr . getDTM ( source , false , this , true , true ) ; dtm . setDocumentBaseURI ( base ) ; boolean hardDelete = true ; try { this . transformNode ( dtm . getDocument ( ) ) ; } finally { if ( shouldRelease ) mgr . release ( dtm , hardDelete ) ; } Exception e = getExceptionThrown ( ) ; if ( null != e ) { if ( e instanceof javax . xml . transform . TransformerException ) { throw ( javax . xml . transform . TransformerException ) e ; } else if ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) { fatalError ( ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ) ; } else { throw new javax . xml . transform . TransformerException ( e ) ; } } else if ( null != m_serializationHandler ) { m_serializationHandler . endDocument ( ) ; } } catch ( org . apache . xml . utils . WrappedRuntimeException wre ) { Throwable throwable = wre . getException ( ) ; while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } fatalError ( throwable ) ; } catch ( org . xml . sax . SAXParseException spe ) { fatalError ( spe ) ; } catch ( org . xml . sax . SAXException se ) { m_errorHandler . fatalError ( new TransformerException ( se ) ) ; } finally { m_hasTransformThreadErrorCatcher = false ; reset ( ) ; } } private void fatalError ( Throwable throwable ) throws TransformerException { if ( throwable instanceof org . xml . sax . SAXParseException ) m_errorHandler . fatalError ( new TransformerException ( throwable . getMessage ( ) , new SAXSourceLocator ( ( org . xml . sax . SAXParseException ) throwable ) ) ) ; else m_errorHandler . fatalError ( new TransformerException ( throwable ) ) ; } public String getBaseURLOfSource ( ) { return m_urlOfSource ; } public void setBaseURLOfSource ( String base ) { m_urlOfSource = base ; } public Result getOutputTarget ( ) { return m_outputTarget ; } public void setOutputTarget ( Result outputTarget ) { m_outputTarget = outputTarget ; } public String getOutputProperty ( String qnameString ) throws IllegalArgumentException { String value = null ; OutputProperties props = getOutputFormat ( ) ; value = props . getProperty ( qnameString ) ; if ( null == value ) { if ( ! OutputProperties . isLegalPropertyKey ( qnameString ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { qnameString } ) ) ; } return value ; } public String getOutputPropertyNoDefault ( String qnameString ) throws IllegalArgumentException { String value = null ; OutputProperties props = getOutputFormat ( ) ; value = ( String ) props . getProperties ( ) . get ( qnameString ) ; if ( null == value ) { if ( ! OutputProperties . isLegalPropertyKey ( qnameString ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { qnameString } ) ) ; } return value ; } public void setOutputProperty ( String name , String value ) throws IllegalArgumentException { synchronized ( m_reentryGuard ) { if ( null == m_outputFormat ) { m_outputFormat = ( OutputProperties ) getStylesheet ( ) . getOutputComposed ( ) . clone ( ) ; } if ( ! OutputProperties . isLegalPropertyKey ( name ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; m_outputFormat . setProperty ( name , value ) ; } } public void setOutputProperties ( Properties oformat ) throws IllegalArgumentException { synchronized ( m_reentryGuard ) { if ( null != oformat ) { String method = ( String ) oformat . get ( OutputKeys . METHOD ) ; if ( null != method ) m_outputFormat = new OutputProperties ( method ) ; else if ( m_outputFormat == null ) m_outputFormat = new OutputProperties ( ) ; m_outputFormat . copyFrom ( oformat ) ; m_outputFormat . copyFrom ( m_stylesheetRoot . getOutputProperties ( ) ) ; } else { m_outputFormat = null ; } } } public Properties getOutputProperties ( ) { return ( Properties ) getOutputFormat ( ) . getProperties ( ) . clone ( ) ; } public SerializationHandler createSerializationHandler ( Result outputTarget ) throws TransformerException { SerializationHandler xoh = createSerializationHandler ( outputTarget , getOutputFormat ( ) ) ; return xoh ; } public SerializationHandler createSerializationHandler ( Result outputTarget , OutputProperties format ) throws TransformerException { SerializationHandler xoh ; org . w3c . dom . Node outputNode = null ; if ( outputTarget instanceof DOMResult ) { outputNode = ( ( DOMResult ) outputTarget ) . getNode ( ) ; org . w3c . dom . Document doc ; short type ; if ( null != outputNode ) { type = outputNode . getNodeType ( ) ; doc = ( org . w3c . dom . Node . DOCUMENT_NODE == type ) ? ( org . w3c . dom . Document ) outputNode : outputNode . getOwnerDocument ( ) ; } else { doc = org . apache . xml . utils . DOMHelper . createDocument ( ) ; outputNode = doc ; type = outputNode . getNodeType ( ) ; ( ( DOMResult ) outputTarget ) . setNode ( outputNode ) ; } ContentHandler handler = ( org . w3c . dom . Node . DOCUMENT_FRAGMENT_NODE == type ) ? new DOMBuilder ( doc , ( org . w3c . dom . DocumentFragment ) outputNode ) : new DOMBuilder ( doc , outputNode ) ; String encoding = format . getProperty ( OutputKeys . ENCODING ) ; xoh = new ToXMLSAXHandler ( handler , ( LexicalHandler ) handler , encoding ) ; } else if ( outputTarget instanceof SAXResult ) { ContentHandler handler = ( ( SAXResult ) outputTarget ) . getHandler ( ) ; if ( null == handler ) throw new IllegalArgumentException ( "handler can not be null for a SAXResult" ) ; LexicalHandler lexHandler ; if ( handler instanceof LexicalHandler ) lexHandler = ( LexicalHandler ) handler ; else lexHandler = null ; String encoding = format . getProperty ( OutputKeys . ENCODING ) ; String method = format . getProperty ( OutputKeys . METHOD ) ; if ( org . apache . xml . serializer . Method . HTML . equals ( method ) ) { xoh = new ToHTMLSAXHandler ( handler , lexHandler , encoding ) ; } else if ( org . apache . xml . serializer . Method . TEXT . equals ( method ) ) { xoh = new ToTextSAXHandler ( handler , lexHandler , encoding ) ; } else { ToXMLSAXHandler toXMLSAXHandler = new ToXMLSAXHandler ( handler , lexHandler , encoding ) ; toXMLSAXHandler . setShouldOutputNSAttr ( false ) ; xoh = toXMLSAXHandler ; } String publicID = format . getProperty ( OutputKeys . DOCTYPE_PUBLIC ) ; String systemID = format . getProperty ( OutputKeys . DOCTYPE_SYSTEM ) ; if ( systemID != null ) xoh . setDoctypeSystem ( systemID ) ; if ( publicID != null ) xoh . setDoctypePublic ( publicID ) ; if ( handler instanceof TransformerClient ) { XalanTransformState state = new XalanTransformState ( ) ; ( ( TransformerClient ) handler ) . setTransformState ( state ) ; ( ( ToSAXHandler ) xoh ) . setTransformState ( state ) ; } } else if ( outputTarget instanceof StreamResult ) { StreamResult sresult = ( StreamResult ) outputTarget ; String method = format . getProperty ( OutputKeys . METHOD ) ; try { SerializationHandler serializer = ( SerializationHandler ) SerializerFactory . getSerializer ( format . getProperties ( ) ) ; if ( null != sresult . getWriter ( ) ) serializer . setWriter ( sresult . getWriter ( ) ) ; else if ( null != sresult . getOutputStream ( ) ) serializer . setOutputStream ( sresult . getOutputStream ( ) ) ; else if ( null != sresult . getSystemId ( ) ) { String fileURL = sresult . getSystemId ( ) ; if ( fileURL . startsWith ( "file:///" ) ) { if ( fileURL . substring ( 8 ) . indexOf ( ":" ) > 0 ) fileURL = fileURL . substring ( 8 ) ; else fileURL = fileURL . substring ( 7 ) ; } m_outputStream = new java . io . FileOutputStream ( fileURL ) ; serializer . setOutputStream ( m_outputStream ) ; xoh = serializer ; } else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_OUTPUT_SPECIFIED , null ) ) ; xoh = serializer ; } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } } else { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , new Object [ ] { outputTarget . getClass ( ) . getName ( ) } ) ) ; } xoh . setTransformer ( this ) ; SourceLocator srcLocator = getStylesheet ( ) ; xoh . setSourceLocator ( srcLocator ) ; return xoh ; } public void transform ( Source xmlSource , Result outputTarget ) throws TransformerException { transform ( xmlSource , outputTarget , true ) ; } public void transform ( Source xmlSource , Result outputTarget , boolean shouldRelease ) throws TransformerException { synchronized ( m_reentryGuard ) { SerializationHandler xoh = createSerializationHandler ( outputTarget ) ; this . setSerializationHandler ( xoh ) ; m_outputTarget = outputTarget ; transform ( xmlSource , shouldRelease ) ; } } public void transformNode ( int node , Result outputTarget ) throws TransformerException { SerializationHandler xoh = createSerializationHandler ( outputTarget ) ; this . setSerializationHandler ( xoh ) ; m_outputTarget = outputTarget ; transformNode ( node ) ; } public void transformNode ( int node ) throws TransformerException { setExtensionsTable ( getStylesheet ( ) ) ; synchronized ( m_serializationHandler ) { m_hasBeenReset = false ; XPathContext xctxt = getXPathContext ( ) ; DTM dtm = xctxt . getDTM ( node ) ; try { pushGlobalVars ( node ) ; StylesheetRoot stylesheet = this . getStylesheet ( ) ; int n = stylesheet . getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { StylesheetComposed imported = stylesheet . getGlobalImport ( i ) ; int includedCount = imported . getIncludeCountComposed ( ) ; for ( int j = - 1 ; j < includedCount ; j ++ ) { Stylesheet included = imported . getIncludeComposed ( j ) ; included . runtimeInit ( this ) ; for ( ElemTemplateElement child = included . getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { child . runtimeInit ( this ) ; } } } DTMIterator dtmIter = new org . apache . xpath . axes . SelfIteratorNoPredicate ( ) ; dtmIter . setRoot ( node , xctxt ) ; xctxt . pushContextNodeList ( dtmIter ) ; try { this . applyTemplateToNode ( null , null , node ) ; } finally { xctxt . popContextNodeList ( ) ; } if ( null != m_serializationHandler ) { m_serializationHandler . endDocument ( ) ; } } catch ( Exception se ) { while ( se instanceof org . apache . xml . utils . WrappedRuntimeException ) { Exception e = ( ( org . apache . xml . utils . WrappedRuntimeException ) se ) . getException ( ) ; if ( null != e ) se = e ; } if ( null != m_serializationHandler ) { try { if ( se instanceof org . xml . sax . SAXParseException ) m_serializationHandler . fatalError ( ( org . xml . sax . SAXParseException ) se ) ; else if ( se instanceof TransformerException ) { TransformerException te = ( ( TransformerException ) se ) ; SAXSourceLocator sl = new SAXSourceLocator ( te . getLocator ( ) ) ; m_serializationHandler . fatalError ( new org . xml . sax . SAXParseException ( te . getMessage ( ) , sl , te ) ) ; } else { m_serializationHandler . fatalError ( new org . xml . sax . SAXParseException ( se . getMessage ( ) , new SAXSourceLocator ( ) , se ) ) ; } } catch ( Exception e ) { } } if ( se instanceof TransformerException ) { m_errorHandler . fatalError ( ( TransformerException ) se ) ; } else if ( se instanceof org . xml . sax . SAXParseException ) { m_errorHandler . fatalError ( new TransformerException ( se . getMessage ( ) , new SAXSourceLocator ( ( org . xml . sax . SAXParseException ) se ) , se ) ) ; } else { m_errorHandler . fatalError ( new TransformerException ( se ) ) ; } } finally { this . reset ( ) ; } } } public ContentHandler getInputContentHandler ( ) { return getInputContentHandler ( false ) ; } public ContentHandler getInputContentHandler ( boolean doDocFrag ) { if ( null == m_inputContentHandler ) { m_inputContentHandler = new TransformerHandlerImpl ( this , doDocFrag , m_urlOfSource ) ; } return m_inputContentHandler ; } public DeclHandler getInputDeclHandler ( ) { if ( m_inputContentHandler instanceof DeclHandler ) return ( DeclHandler ) m_inputContentHandler ; else return null ; } public LexicalHandler getInputLexicalHandler ( ) { if ( m_inputContentHandler instanceof LexicalHandler ) return ( LexicalHandler ) m_inputContentHandler ; else return null ; } public void setOutputFormat ( OutputProperties oformat ) { m_outputFormat = oformat ; } public OutputProperties getOutputFormat ( ) { OutputProperties format = ( null == m_outputFormat ) ? getStylesheet ( ) . getOutputComposed ( ) : m_outputFormat ; return format ; } public void setParameter ( String name , String namespace , Object value ) { VariableStack varstack = getXPathContext ( ) . getVarStack ( ) ; QName qname = new QName ( namespace , name ) ; XObject xobject = XObject . create ( value , getXPathContext ( ) ) ; StylesheetRoot sroot = m_stylesheetRoot ; Vector vars = sroot . getVariablesAndParamsComposed ( ) ; int i = vars . size ( ) ; while ( -- i >= 0 ) { ElemVariable variable = ( ElemVariable ) vars . elementAt ( i ) ; if ( variable . getXSLToken ( ) == Constants . ELEMNAME_PARAMVARIABLE && variable . getName ( ) . equals ( qname ) ) { varstack . setGlobalVariable ( i , xobject ) ; } } } Vector m_userParams ; public void setParameter ( String name , Object value ) { if ( value == null ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_SET_PARAM_VALUE , new Object [ ] { name } ) ) ; } StringTokenizer tokenizer = new StringTokenizer ( name , "{}" , false ) ; try { String s1 = tokenizer . nextToken ( ) ; String s2 = tokenizer . hasMoreTokens ( ) ? tokenizer . nextToken ( ) : null ; if ( null == m_userParams ) m_userParams = new Vector ( ) ; if ( null == s2 ) { replaceOrPushUserParam ( new QName ( s1 ) , XObject . create ( value , getXPathContext ( ) ) ) ; setParameter ( s1 , null , value ) ; } else { replaceOrPushUserParam ( new QName ( s1 , s2 ) , XObject . create ( value , getXPathContext ( ) ) ) ; setParameter ( s2 , s1 , value ) ; } } catch ( java . util . NoSuchElementException nsee ) { } } private void replaceOrPushUserParam ( QName qname , XObject xval ) { int n = m_userParams . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Arg arg = ( Arg ) m_userParams . elementAt ( i ) ; if ( arg . getQName ( ) . equals ( qname ) ) { m_userParams . setElementAt ( new Arg ( qname , xval , true ) , i ) ; return ; } } m_userParams . addElement ( new Arg ( qname , xval , true ) ) ; } public Object getParameter ( String name ) { try { QName qname = QName . getQNameFromString ( name ) ; if ( null == m_userParams ) return null ; int n = m_userParams . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Arg arg = ( Arg ) m_userParams . elementAt ( i ) ; if ( arg . getQName ( ) . equals ( qname ) ) { return arg . getVal ( ) . object ( ) ; } } return null ; } catch ( java . util . NoSuchElementException nsee ) { return null ; } } private void resetUserParameters ( ) { try { if ( null == m_userParams ) return ; int n = m_userParams . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Arg arg = ( Arg ) m_userParams . elementAt ( i ) ; QName name = arg . getQName ( ) ; String s1 = name . getNamespace ( ) ; String s2 = name . getLocalPart ( ) ; setParameter ( s2 , s1 , arg . getVal ( ) . object ( ) ) ; } } catch ( java . util . NoSuchElementException nsee ) { } } public void setParameters ( Properties params ) { clearParameters ( ) ; Enumeration names = params . propertyNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = params . getProperty ( ( String ) names . nextElement ( ) ) ; StringTokenizer tokenizer = new StringTokenizer ( name , "{}" , false ) ; try { String s1 = tokenizer . nextToken ( ) ; String s2 = tokenizer . hasMoreTokens ( ) ? tokenizer . nextToken ( ) : null ; if ( null == s2 ) setParameter ( s1 , null , params . getProperty ( name ) ) ; else setParameter ( s2 , s1 , params . getProperty ( name ) ) ; } catch ( java . util . NoSuchElementException nsee ) { } } } public void clearParameters ( ) { synchronized ( m_reentryGuard ) { VariableStack varstack = new VariableStack ( ) ; m_xcontext . setVarStack ( varstack ) ; m_userParams = null ; } } protected void pushGlobalVars ( int contextNode ) throws TransformerException { XPathContext xctxt = m_xcontext ; VariableStack vs = xctxt . getVarStack ( ) ; StylesheetRoot sr = getStylesheet ( ) ; Vector vars = sr . getVariablesAndParamsComposed ( ) ; int i = vars . size ( ) ; vs . link ( i ) ; while ( -- i >= 0 ) { ElemVariable v = ( ElemVariable ) vars . elementAt ( i ) ; XObject xobj = new XUnresolvedVariable ( v , contextNode , this , vs . getStackFrame ( ) , 0 , true ) ; if ( null == vs . elementAt ( i ) ) vs . setGlobalVariable ( i , xobj ) ; } } public void setURIResolver ( URIResolver resolver ) { synchronized ( m_reentryGuard ) { m_xcontext . getSourceTreeManager ( ) . setURIResolver ( resolver ) ; } } public URIResolver getURIResolver ( ) { return m_xcontext . getSourceTreeManager ( ) . getURIResolver ( ) ; } public void setContentHandler ( ContentHandler handler ) { if ( handler == null ) { throw new NullPointerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NULL_CONTENT_HANDLER , null ) ) ; } else { m_outputContentHandler = handler ; if ( null == m_serializationHandler ) { ToXMLSAXHandler h = new ToXMLSAXHandler ( ) ; h . setContentHandler ( handler ) ; h . setTransformer ( this ) ; m_serializationHandler = h ; } else m_serializationHandler . setContentHandler ( handler ) ; } } public ContentHandler getContentHandler ( ) { return m_outputContentHandler ; } public int transformToRTF ( ElemTemplateElement templateParent ) throws TransformerException { DTM dtmFrag = m_xcontext . getRTFDTM ( ) ; return transformToRTF ( templateParent , dtmFrag ) ; } public int transformToGlobalRTF ( ElemTemplateElement templateParent ) throws TransformerException { DTM dtmFrag = m_xcontext . getGlobalRTFDTM ( ) ; return transformToRTF ( templateParent , dtmFrag ) ; } private int transformToRTF ( ElemTemplateElement templateParent , DTM dtmFrag ) throws TransformerException { XPathContext xctxt = m_xcontext ; ContentHandler rtfHandler = dtmFrag . getContentHandler ( ) ; int resultFragment ; SerializationHandler savedRTreeHandler = this . m_serializationHandler ; ToSAXHandler h = new ToXMLSAXHandler ( ) ; h . setContentHandler ( rtfHandler ) ; h . setTransformer ( this ) ; m_serializationHandler = h ; SerializationHandler rth = m_serializationHandler ; try { rth . startDocument ( ) ; rth . flushPending ( ) ; try { executeChildTemplates ( templateParent , true ) ; rth . flushPending ( ) ; resultFragment = dtmFrag . getDocument ( ) ; } finally { rth . endDocument ( ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { this . m_serializationHandler = savedRTreeHandler ; } return resultFragment ; } public ObjectPool getStringWriterPool ( ) { return m_stringWriterObjectPool ; } public String transformToString ( ElemTemplateElement elem ) throws TransformerException { ElemTemplateElement firstChild = elem . getFirstChildElem ( ) ; if ( null == firstChild ) return "" ; if ( elem . hasTextLitOnly ( ) && org . apache . xalan . processor . TransformerFactoryImpl . m_optimize ) { return ( ( ElemTextLiteral ) firstChild ) . getNodeValue ( ) ; } SerializationHandler savedRTreeHandler = this . m_serializationHandler ; StringWriter sw = ( StringWriter ) m_stringWriterObjectPool . getInstance ( ) ; m_serializationHandler = ( ToTextStream ) m_textResultHandlerObjectPool . getInstance ( ) ; if ( null == m_serializationHandler ) { Serializer serializer = org . apache . xml . serializer . SerializerFactory . getSerializer ( m_textformat . getProperties ( ) ) ; m_serializationHandler = ( SerializationHandler ) serializer ; } m_serializationHandler . setTransformer ( this ) ; m_serializationHandler . setWriter ( sw ) ; String result ; try { executeChildTemplates ( elem , true ) ; this . m_serializationHandler . endDocument ( ) ; result = sw . toString ( ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { sw . getBuffer ( ) . setLength ( 0 ) ; try { sw . close ( ) ; } catch ( Exception ioe ) { } m_stringWriterObjectPool . freeInstance ( sw ) ; m_serializationHandler . reset ( ) ; m_textResultHandlerObjectPool . freeInstance ( m_serializationHandler ) ; m_serializationHandler = savedRTreeHandler ; } return result ; } public boolean applyTemplateToNode ( ElemTemplateElement xslInstruction , ElemTemplate template , int child ) throws TransformerException { DTM dtm = m_xcontext . getDTM ( child ) ; short nodeType = dtm . getNodeType ( child ) ; boolean isDefaultTextRule = false ; boolean isApplyImports = false ; if ( null == template ) { int maxImportLevel , endImportLevel = 0 ; isApplyImports = ( ( xslInstruction == null ) ? false : xslInstruction . getXSLToken ( ) == Constants . ELEMNAME_APPLY_IMPORTS ) ; if ( isApplyImports ) { maxImportLevel = xslInstruction . getStylesheetComposed ( ) . getImportCountComposed ( ) - 1 ; endImportLevel = xslInstruction . getStylesheetComposed ( ) . getEndImportCountComposed ( ) ; } else { maxImportLevel = - 1 ; } if ( isApplyImports && ( maxImportLevel == - 1 ) ) { template = null ; } else { XPathContext xctxt = m_xcontext ; try { xctxt . pushNamespaceContext ( xslInstruction ) ; QName mode = this . getMode ( ) ; if ( isApplyImports ) template = m_stylesheetRoot . getTemplateComposed ( xctxt , child , mode , maxImportLevel , endImportLevel , m_quietConflictWarnings , dtm ) ; else template = m_stylesheetRoot . getTemplateComposed ( xctxt , child , mode , m_quietConflictWarnings , dtm ) ; } finally { xctxt . popNamespaceContext ( ) ; } } if ( null == template ) { switch ( nodeType ) { case DTM . DOCUMENT_FRAGMENT_NODE : case DTM . ELEMENT_NODE : template = m_stylesheetRoot . getDefaultRule ( ) ; break ; case DTM . CDATA_SECTION_NODE : case DTM . TEXT_NODE : case DTM . ATTRIBUTE_NODE : template = m_stylesheetRoot . getDefaultTextRule ( ) ; isDefaultTextRule = true ; break ; case DTM . DOCUMENT_NODE : template = m_stylesheetRoot . getDefaultRootRule ( ) ; break ; default : return false ; } } } try { pushElemTemplateElement ( template ) ; m_xcontext . pushCurrentNode ( child ) ; pushPairCurrentMatched ( template , child ) ; if ( ! isApplyImports ) { DTMIterator cnl = new org . apache . xpath . NodeSetDTM ( child , m_xcontext . getDTMManager ( ) ) ; m_xcontext . pushContextNodeList ( cnl ) ; } if ( isDefaultTextRule ) { switch ( nodeType ) { case DTM . CDATA_SECTION_NODE : case DTM . TEXT_NODE : ClonerToResultTree . cloneToResultTree ( child , nodeType , dtm , getResultTreeHandler ( ) , false ) ; break ; case DTM . ATTRIBUTE_NODE : dtm . dispatchCharactersEvents ( child , getResultTreeHandler ( ) , false ) ; break ; } } else { if ( TransformerImpl . S_DEBUG ) getTraceManager ( ) . fireTraceEvent ( template ) ; m_xcontext . setSAXLocator ( template ) ; m_xcontext . getVarStack ( ) . link ( template . m_frameSize ) ; executeChildTemplates ( template , true ) ; if ( TransformerImpl . S_DEBUG ) getTraceManager ( ) . fireTraceEndEvent ( template ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { if ( ! isDefaultTextRule ) m_xcontext . getVarStack ( ) . unlink ( ) ; m_xcontext . popCurrentNode ( ) ; if ( ! isApplyImports ) { m_xcontext . popContextNodeList ( ) ; popCurrentMatched ( ) ; } popElemTemplateElement ( ) ; } return true ; } public void executeChildTemplates ( ElemTemplateElement elem , org . w3c . dom . Node context , QName mode , ContentHandler handler ) throws TransformerException { XPathContext xctxt = m_xcontext ; try { if ( null != mode ) pushMode ( mode ) ; xctxt . pushCurrentNode ( xctxt . getDTMHandleFromNode ( context ) ) ; executeChildTemplates ( elem , handler ) ; } finally { xctxt . popCurrentNode ( ) ; if ( null != mode ) popMode ( ) ; } } public void executeChildTemplates ( ElemTemplateElement elem , boolean shouldAddAttrs ) throws TransformerException { ElemTemplateElement t = elem . getFirstChildElem ( ) ; if ( null == t ) return ; if ( elem . hasTextLitOnly ( ) && org . apache . xalan . processor . TransformerFactoryImpl . m_optimize ) { char [ ] chars = ( ( ElemTextLiteral ) t ) . getChars ( ) ; try { this . pushElemTemplateElement ( t ) ; m_serializationHandler . characters ( chars , 0 , chars . length ) ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } finally { this . popElemTemplateElement ( ) ; } return ; } XPathContext xctxt = m_xcontext ; xctxt . pushSAXLocatorNull ( ) ; int currentTemplateElementsTop = m_currentTemplateElements . size ( ) ; m_currentTemplateElements . push ( null ) ; try { for ( ; t != null ; t = t . getNextSiblingElem ( ) ) { if ( ! shouldAddAttrs && t . getXSLToken ( ) == Constants . ELEMNAME_ATTRIBUTE ) continue ; xctxt . setSAXLocator ( t ) ; m_currentTemplateElements . setElementAt ( t , currentTemplateElementsTop ) ; t . execute ( this ) ; } } catch ( RuntimeException re ) { TransformerException te = new TransformerException ( re ) ; te . setLocator ( t ) ; throw te ; } finally { m_currentTemplateElements . pop ( ) ; xctxt . popSAXLocator ( ) ; } } public void executeChildTemplates ( ElemTemplateElement elem , ContentHandler handler ) throws TransformerException { SerializationHandler xoh = this . getSerializationHandler ( ) ; SerializationHandler savedHandler = xoh ; try { xoh . flushPending ( ) ; LexicalHandler lex = null ; if ( handler instanceof LexicalHandler ) { lex = ( LexicalHandler ) handler ; } m_serializationHandler = new ToXMLSAXHandler ( handler , lex , savedHandler . getEncoding ( ) ) ; m_serializationHandler . setTransformer ( this ) ; executeChildTemplates ( elem , true ) ; } catch ( TransformerException e ) { throw e ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } finally { m_serializationHandler = savedHandler ; } } public Vector processSortKeys ( ElemForEach foreach , int sourceNodeContext ) throws TransformerException { Vector keys = null ; XPathContext xctxt = m_xcontext ; int nElems = foreach . getSortElemCount ( ) ; if ( nElems > 0 ) keys = new Vector ( ) ; for ( int i = 0 ; i < nElems ; i ++ ) { ElemSort sort = foreach . getSortElem ( i ) ; if ( TransformerImpl . S_DEBUG ) getTraceManager ( ) . fireTraceEvent ( sort ) ; String langString = ( null != sort . getLang ( ) ) ? sort . getLang ( ) . evaluate ( xctxt , sourceNodeContext , foreach ) : null ; String dataTypeString = sort . getDataType ( ) . evaluate ( xctxt , sourceNodeContext , foreach ) ; if ( dataTypeString . indexOf ( ":" ) >= 0 ) System . out . println ( "TODO: Need to write the hooks for QNAME sort data type" ) ; else if ( ! ( dataTypeString . equalsIgnoreCase ( Constants . ATTRVAL_DATATYPE_TEXT ) ) && ! ( dataTypeString . equalsIgnoreCase ( Constants . ATTRVAL_DATATYPE_NUMBER ) ) ) foreach . error ( XSLTErrorResources . ER_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_DATATYPE , dataTypeString } ) ; boolean treatAsNumbers = ( ( null != dataTypeString ) && dataTypeString . equals ( Constants . ATTRVAL_DATATYPE_NUMBER ) ) ? true : false ; String orderString = sort . getOrder ( ) . evaluate ( xctxt , sourceNodeContext , foreach ) ; if ( ! ( orderString . equalsIgnoreCase ( Constants . ATTRVAL_ORDER_ASCENDING ) ) && ! ( orderString . equalsIgnoreCase ( Constants . ATTRVAL_ORDER_DESCENDING ) ) ) foreach . error ( XSLTErrorResources . ER_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_ORDER , orderString } ) ; boolean descending = ( ( null != orderString ) && orderString . equals ( Constants . ATTRVAL_ORDER_DESCENDING ) ) ? true : false ; AVT caseOrder = sort . getCaseOrder ( ) ; boolean caseOrderUpper ; if ( null != caseOrder ) { String caseOrderString = caseOrder . evaluate ( xctxt , sourceNodeContext , foreach ) ; if ( ! ( caseOrderString . equalsIgnoreCase ( Constants . ATTRVAL_CASEORDER_UPPER ) ) && ! ( caseOrderString . equalsIgnoreCase ( Constants . ATTRVAL_CASEORDER_LOWER ) ) ) foreach . error ( XSLTErrorResources . ER_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_CASEORDER , caseOrderString } ) ; caseOrderUpper = ( ( null != caseOrderString ) && caseOrderString . equals ( Constants . ATTRVAL_CASEORDER_UPPER ) ) ? true : false ; } else { caseOrderUpper = false ; } keys . addElement ( new NodeSortKey ( this , sort . getSelect ( ) , treatAsNumbers , descending , langString , caseOrderUpper , foreach ) ) ; if ( TransformerImpl . S_DEBUG ) getTraceManager ( ) . fireTraceEndEvent ( sort ) ; } return keys ; } public Vector getElementCallstack ( ) { Vector elems = new Vector ( ) ; int nStackSize = m_currentTemplateElements . size ( ) ; for ( int i = 0 ; i < nStackSize ; i ++ ) { ElemTemplateElement elem = ( ElemTemplateElement ) m_currentTemplateElements . elementAt ( i ) ; if ( null != elem ) { elems . addElement ( elem ) ; } } return elems ; } public int getCurrentTemplateElementsCount ( ) { return m_currentTemplateElements . size ( ) ; } public ObjectStack getCurrentTemplateElements ( ) { return m_currentTemplateElements ; } public void pushElemTemplateElement ( ElemTemplateElement elem ) { m_currentTemplateElements . push ( elem ) ; } public void popElemTemplateElement ( ) { m_currentTemplateElements . pop ( ) ; } public void setCurrentElement ( ElemTemplateElement e ) { m_currentTemplateElements . setTop ( e ) ; } public ElemTemplateElement getCurrentElement ( ) { return ( m_currentTemplateElements . size ( ) > 0 ) ? ( ElemTemplateElement ) m_currentTemplateElements . peek ( ) : null ; } public int getCurrentNode ( ) { return m_xcontext . getCurrentNode ( ) ; } public Vector getTemplateCallstack ( ) { Vector elems = new Vector ( ) ; int nStackSize = m_currentTemplateElements . size ( ) ; for ( int i = 0 ; i < nStackSize ; i ++ ) { ElemTemplateElement elem = ( ElemTemplateElement ) m_currentTemplateElements . elementAt ( i ) ; if ( null != elem && ( elem . getXSLToken ( ) != Constants . ELEMNAME_TEMPLATE ) ) { elems . addElement ( elem ) ; } } return elems ; } public ElemTemplate getCurrentTemplate ( ) { ElemTemplateElement elem = getCurrentElement ( ) ; while ( ( null != elem ) && ( elem . getXSLToken ( ) != Constants . ELEMNAME_TEMPLATE ) ) { elem = elem . getParentElem ( ) ; } return ( ElemTemplate ) elem ; } public void pushPairCurrentMatched ( ElemTemplateElement template , int child ) { m_currentMatchTemplates . push ( template ) ; m_currentMatchedNodes . push ( child ) ; } public void popCurrentMatched ( ) { m_currentMatchTemplates . pop ( ) ; m_currentMatchedNodes . pop ( ) ; } public ElemTemplate getMatchedTemplate ( ) { return ( ElemTemplate ) m_currentMatchTemplates . peek ( ) ; } public int getMatchedNode ( ) { return m_currentMatchedNodes . peepTail ( ) ; } public DTMIterator getContextNodeList ( ) { try { DTMIterator cnl = m_xcontext . getContextNodeList ( ) ; return ( cnl == null ) ? null : ( DTMIterator ) cnl . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { return null ; } } public Transformer getTransformer ( ) { return this ; } public void setStylesheet ( StylesheetRoot stylesheetRoot ) { m_stylesheetRoot = stylesheetRoot ; } public final StylesheetRoot getStylesheet ( ) { return m_stylesheetRoot ; } public boolean getQuietConflictWarnings ( ) { return m_quietConflictWarnings ; } public void setQuietConflictWarnings ( boolean b ) { m_quietConflictWarnings = b ; } public void setXPathContext ( XPathContext xcontext ) { m_xcontext = xcontext ; } public final XPathContext getXPathContext ( ) { return m_xcontext ; } public StackGuard getStackGuard ( ) { return m_stackGuard ; } public int getRecursionLimit ( ) { return m_stackGuard . getRecursionLimit ( ) ; } public void setRecursionLimit ( int limit ) { m_stackGuard . setRecursionLimit ( limit ) ; } public SerializationHandler getResultTreeHandler ( ) { return m_serializationHandler ; } public SerializationHandler getSerializationHandler ( ) { return m_serializationHandler ; } public KeyManager getKeyManager ( ) { return m_keyManager ; } public boolean isRecursiveAttrSet ( ElemAttributeSet attrSet ) { if ( null == m_attrSetStack ) { m_attrSetStack = new Stack ( ) ; } if ( ! m_attrSetStack . empty ( ) ) { int loc = m_attrSetStack . search ( attrSet ) ; if ( loc > - 1 ) { return true ; } } return false ; } public void pushElemAttributeSet ( ElemAttributeSet attrSet ) { m_attrSetStack . push ( attrSet ) ; } public void popElemAttributeSet ( ) { m_attrSetStack . pop ( ) ; } public CountersTable getCountersTable ( ) { if ( null == m_countersTable ) m_countersTable = new CountersTable ( ) ; return m_countersTable ; } public boolean currentTemplateRuleIsNull ( ) { return ( ( ! m_currentTemplateRuleIsNull . isEmpty ( ) ) && ( m_currentTemplateRuleIsNull . peek ( ) == true ) ) ; } public void pushCurrentTemplateRuleIsNull ( boolean b ) { m_currentTemplateRuleIsNull . push ( b ) ; } public void popCurrentTemplateRuleIsNull ( ) { m_currentTemplateRuleIsNull . pop ( ) ; } public void pushCurrentFuncResult ( Object val ) { m_currentFuncResult . push ( val ) ; } public Object popCurrentFuncResult ( ) { return m_currentFuncResult . pop ( ) ; } public boolean currentFuncResultSeen ( ) { return ! m_currentFuncResult . empty ( ) && m_currentFuncResult . peek ( ) != null ; } public MsgMgr getMsgMgr ( ) { if ( null == m_msgMgr ) m_msgMgr = new MsgMgr ( this ) ; return m_msgMgr ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { synchronized ( m_reentryGuard ) { if ( listener == null ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NULL_ERROR_HANDLER , null ) ) ; m_errorHandler = listener ; } } public ErrorListener getErrorListener ( ) { return m_errorHandler ; } public TraceManager getTraceManager ( ) { return m_traceManager ; } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( "http://xml.org/trax/features/sax/input" . equals ( name ) ) return true ; else if ( "http://xml.org/trax/features/dom/input" . equals ( name ) ) return true ; throw new SAXNotRecognizedException ( name ) ; } public QName getMode ( ) { return m_modes . isEmpty ( ) ? null : ( QName ) m_modes . peek ( ) ; } public void pushMode ( QName mode ) { m_modes . push ( mode ) ; } public void popMode ( ) { m_modes . pop ( ) ; } public void runTransformThread ( int priority ) { Thread t = ThreadControllerWrapper . runThread ( this , priority ) ; this . setTransformThread ( t ) ; } public void runTransformThread ( ) { ThreadControllerWrapper . runThread ( this , - 1 ) ; } public static void runTransformThread ( Runnable runnable ) { ThreadControllerWrapper . runThread ( runnable , - 1 ) ; } public void waitTransformThread ( ) throws SAXException { Thread transformThread = this . getTransformThread ( ) ; if ( null != transformThread ) { try { ThreadControllerWrapper . waitThread ( transformThread , this ) ; if ( ! this . hasTransformThreadErrorCatcher ( ) ) { Exception e = this . getExceptionThrown ( ) ; if ( null != e ) { e . printStackTrace ( ) ; throw new org . xml . sax . SAXException ( e ) ; } } this . setTransformThread ( null ) ; } catch ( InterruptedException ie ) { } } } public Exception getExceptionThrown ( ) { return m_exceptionThrown ; } public void setExceptionThrown ( Exception e ) { m_exceptionThrown = e ; } public void setSourceTreeDocForThread ( int doc ) { m_doc = doc ; } public void setXMLSource ( Source source ) { m_xmlSource = source ; } public boolean isTransformDone ( ) { synchronized ( this ) { return m_isTransformDone ; } } public void setIsTransformDone ( boolean done ) { synchronized ( this ) { m_isTransformDone = done ; } } void postExceptionFromThread ( Exception e ) { m_isTransformDone = true ; m_exceptionThrown = e ; ; synchronized ( this ) { notifyAll ( ) ; } } public void run ( ) { m_hasBeenReset = false ; try { try { m_isTransformDone = false ; transformNode ( m_doc ) ; } catch ( Exception e ) { if ( null != m_transformThread ) postExceptionFromThread ( e ) ; else throw new RuntimeException ( e . getMessage ( ) ) ; } finally { m_isTransformDone = true ; if ( m_inputContentHandler instanceof TransformerHandlerImpl ) { ( ( TransformerHandlerImpl ) m_inputContentHandler ) . clearCoRoutine ( ) ; } } } catch ( Exception e ) { if ( null != m_transformThread ) postExceptionFromThread ( e ) ; else throw new RuntimeException ( e . getMessage ( ) ) ; } } public TransformSnapshot getSnapshot ( ) { return new TransformSnapshotImpl ( this ) ; } public void executeFromSnapshot ( TransformSnapshot ts ) throws TransformerException { ElemTemplateElement template = getMatchedTemplate ( ) ; int child = getMatchedNode ( ) ; pushElemTemplateElement ( template ) ; m_xcontext . pushCurrentNode ( child ) ; this . executeChildTemplates ( template , true ) ; } public void resetToStylesheet ( TransformSnapshot ts ) { ( ( TransformSnapshotImpl ) ts ) . apply ( this ) ; } public void stopTransformation ( ) { } public short getShouldStripSpace ( int elementHandle , DTM dtm ) { try { org . apache . xalan . templates . WhiteSpaceInfo info = m_stylesheetRoot . getWhiteSpaceInfo ( m_xcontext , elementHandle , dtm ) ; if ( null == info ) { return DTMWSFilter . INHERIT ; } else { return info . getShouldStripSpace ( ) ? DTMWSFilter . STRIP : DTMWSFilter . NOTSTRIP ; } } catch ( TransformerException se ) { return DTMWSFilter . INHERIT ; } } public void init ( ToXMLSAXHandler h , Transformer transformer , ContentHandler realHandler ) { h . setTransformer ( transformer ) ; h . setContentHandler ( realHandler ) ; } public void setSerializationHandler ( SerializationHandler xoh ) { m_serializationHandler = xoh ; } public void fireGenerateEvent ( int eventType , char [ ] ch , int start , int length ) { GenerateEvent ge = new GenerateEvent ( this , eventType , ch , start , length ) ; m_traceManager . fireGenerateEvent ( ge ) ; } public void fireGenerateEvent ( int eventType , String name , Attributes atts ) { GenerateEvent ge = new GenerateEvent ( this , eventType , name , atts ) ; m_traceManager . fireGenerateEvent ( ge ) ; } public void fireGenerateEvent ( int eventType , String name , String data ) { GenerateEvent ge = new GenerateEvent ( this , eventType , name , data ) ; m_traceManager . fireGenerateEvent ( ge ) ; } public void fireGenerateEvent ( int eventType , String data ) { GenerateEvent ge = new GenerateEvent ( this , eventType , data ) ; m_traceManager . fireGenerateEvent ( ge ) ; } public void fireGenerateEvent ( int eventType ) { GenerateEvent ge = new GenerateEvent ( this , eventType ) ; m_traceManager . fireGenerateEvent ( ge ) ; } public boolean hasTraceListeners ( ) { return m_traceManager . hasTraceListeners ( ) ; } } 	1	['133', '2', '0', '114', '409', '7774', '63', '68', '125', '0.944507576', '3531', '0.725', '17', '0.090277778', '0.052807487', '1', '2', '25.2481203', '5', '1.3383', '6']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; public abstract class LocationPathPattern extends Pattern { private Template _template ; private int _importPrecedence ; private double _priority = Double . NaN ; private int _position = 0 ; public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } public void setTemplate ( final Template template ) { _template = template ; _priority = template . getPriority ( ) ; _importPrecedence = template . getImportPrecedence ( ) ; _position = template . getPosition ( ) ; } public Template getTemplate ( ) { return _template ; } public final double getPriority ( ) { return Double . isNaN ( _priority ) ? getDefaultPriority ( ) : _priority ; } public double getDefaultPriority ( ) { return 0.5 ; } public boolean noSmallerThan ( LocationPathPattern other ) { if ( _importPrecedence > other . _importPrecedence ) { return true ; } else if ( _importPrecedence == other . _importPrecedence ) { if ( _priority > other . _priority ) { return true ; } else if ( _priority == other . _priority ) { if ( _position > other . _position ) { return true ; } } } return false ; } public abstract StepPattern getKernelPattern ( ) ; public abstract void reduceKernelPattern ( ) ; public abstract boolean isWildcard ( ) ; public int getAxis ( ) { final StepPattern sp = getKernelPattern ( ) ; return ( sp != null ) ? sp . getAxis ( ) : Axis . CHILD ; } public String toString ( ) { return "root()" ; } } 	1	['13', '4', '3', '13', '19', '64', '5', '8', '13', '0.854166667', '107', '1', '1', '0.878787879', '0.230769231', '2', '3', '6.923076923', '6', '1.4615', '1']
package org . apache . xalan . templates ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; public class ElemTemplate extends ElemTemplateElement { private String m_publicId ; private String m_systemId ; public String getPublicId ( ) { return m_publicId ; } public String getSystemId ( ) { return m_systemId ; } public void setLocaterInfo ( SourceLocator locator ) { m_publicId = locator . getPublicId ( ) ; m_systemId = locator . getSystemId ( ) ; super . setLocaterInfo ( locator ) ; } private Stylesheet m_stylesheet ; public StylesheetComposed getStylesheetComposed ( ) { return m_stylesheet . getStylesheetComposed ( ) ; } public Stylesheet getStylesheet ( ) { return m_stylesheet ; } public void setStylesheet ( Stylesheet sheet ) { m_stylesheet = sheet ; } public StylesheetRoot getStylesheetRoot ( ) { return m_stylesheet . getStylesheetRoot ( ) ; } private XPath m_matchPattern = null ; public void setMatch ( XPath v ) { m_matchPattern = v ; } public XPath getMatch ( ) { return m_matchPattern ; } private QName m_name = null ; public void setName ( QName v ) { m_name = v ; } public QName getName ( ) { return m_name ; } private QName m_mode ; public void setMode ( QName v ) { m_mode = v ; } public QName getMode ( ) { return m_mode ; } private double m_priority = XPath . MATCH_SCORE_NONE ; public void setPriority ( double v ) { m_priority = v ; } public double getPriority ( ) { return m_priority ; } public int getXSLToken ( ) { return Constants . ELEMNAME_TEMPLATE ; } public String getNodeName ( ) { return Constants . ELEMNAME_TEMPLATE_STRING ; } public int m_frameSize ; int m_inArgsSize ; private int [ ] m_argsQNameIDs ; public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_matchPattern ) m_matchPattern . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; cstate . resetStackFrameSize ( ) ; m_inArgsSize = 0 ; } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; super . endCompose ( sroot ) ; m_frameSize = cstate . getFrameSize ( ) ; cstate . resetStackFrameSize ( ) ; } public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext xctxt = transformer . getXPathContext ( ) ; transformer . getStackGuard ( ) . checkForInfinateLoop ( ) ; xctxt . pushRTFContext ( ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; transformer . executeChildTemplates ( this , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; xctxt . popRTFContext ( ) ; } public void recompose ( StylesheetRoot root ) { root . recomposeTemplates ( this ) ; } } 	1	['22', '3', '2', '27', '46', '189', '22', '11', '22', '0.942857143', '179', '0.8', '4', '0.903225806', '0.181818182', '2', '14', '6.681818182', '1', '0.9545', '2']
package org . apache . xalan . lib ; import javax . xml . transform . SourceLocator ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class NodeInfo { public static String systemId ( ExpressionContext context ) { Node contextNode = context . getContextNode ( ) ; int nodeHandler = ( ( DTMNodeProxy ) contextNode ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) contextNode ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getSystemId ( ) ; else return null ; } public static String systemId ( NodeList nodeList ) { if ( nodeList == null || nodeList . getLength ( ) == 0 ) return null ; Node node = nodeList . item ( 0 ) ; int nodeHandler = ( ( DTMNodeProxy ) node ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) node ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getSystemId ( ) ; else return null ; } public static String publicId ( ExpressionContext context ) { Node contextNode = context . getContextNode ( ) ; int nodeHandler = ( ( DTMNodeProxy ) contextNode ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) contextNode ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getPublicId ( ) ; else return null ; } public static String publicId ( NodeList nodeList ) { if ( nodeList == null || nodeList . getLength ( ) == 0 ) return null ; Node node = nodeList . item ( 0 ) ; int nodeHandler = ( ( DTMNodeProxy ) node ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) node ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getPublicId ( ) ; else return null ; } public static int lineNumber ( ExpressionContext context ) { Node contextNode = context . getContextNode ( ) ; int nodeHandler = ( ( DTMNodeProxy ) contextNode ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) contextNode ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getLineNumber ( ) ; else return - 1 ; } public static int lineNumber ( NodeList nodeList ) { if ( nodeList == null || nodeList . getLength ( ) == 0 ) return - 1 ; Node node = nodeList . item ( 0 ) ; int nodeHandler = ( ( DTMNodeProxy ) node ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) node ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getLineNumber ( ) ; else return - 1 ; } public static int columnNumber ( ExpressionContext context ) { Node contextNode = context . getContextNode ( ) ; int nodeHandler = ( ( DTMNodeProxy ) contextNode ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) contextNode ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getColumnNumber ( ) ; else return - 1 ; } public static int columnNumber ( NodeList nodeList ) { if ( nodeList == null || nodeList . getLength ( ) == 0 ) return - 1 ; Node node = nodeList . item ( 0 ) ; int nodeHandler = ( ( DTMNodeProxy ) node ) . getDTMNodeNumber ( ) ; SourceLocator locator = ( ( DTMNodeProxy ) node ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; if ( locator != null ) return locator . getColumnNumber ( ) ; else return - 1 ; } } 	1	['9', '1', '0', '3', '20', '36', '0', '3', '9', '2', '204', '0', '0', '0', '0.333333333', '0', '0', '21.66666667', '4', '2.6667', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Transformer ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; public class ToUnknownStream extends SerializerBase { private SerializationHandler m_handler ; private static final String EMPTYSTRING = "" ; private boolean m_wrapped_handler_not_initialized = false ; private String m_firstElementPrefix ; private String m_firstElementName ; private String m_firstElementURI ; private String m_firstElementLocalName = null ; private boolean m_firstTagNotEmitted = true ; private Vector m_namespaceURI = null ; private Vector m_namespacePrefix = null ; private boolean m_needToCallStartDocument = false ; private boolean m_setVersion_called = false ; private boolean m_setDoctypeSystem_called = false ; private boolean m_setDoctypePublic_called = false ; private boolean m_setMediaType_called = false ; public ToUnknownStream ( ) { m_handler = new ToXMLStream ( ) ; } public ContentHandler asContentHandler ( ) throws IOException { return this ; } public void close ( ) { m_handler . close ( ) ; } public Properties getOutputFormat ( ) { return m_handler . getOutputFormat ( ) ; } public OutputStream getOutputStream ( ) { return m_handler . getOutputStream ( ) ; } public Writer getWriter ( ) { return m_handler . getWriter ( ) ; } public boolean reset ( ) { return m_handler . reset ( ) ; } public void serialize ( Node node ) throws IOException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . serialize ( node ) ; } public boolean setEscaping ( boolean escape ) throws SAXException { return m_handler . setEscaping ( escape ) ; } public void setOutputFormat ( Properties format ) { m_handler . setOutputFormat ( format ) ; } public void setOutputStream ( OutputStream output ) { m_handler . setOutputStream ( output ) ; } public void setWriter ( Writer writer ) { m_handler . setWriter ( writer ) ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . addAttribute ( uri , localName , rawName , type , value ) ; } public void addAttribute ( String rawName , String value ) { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . addAttribute ( rawName , value ) ; } public void addUniqueAttribute ( String rawName , String value , int flags ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . addUniqueAttribute ( rawName , value , flags ) ; } public void characters ( String chars ) throws SAXException { final int length = chars . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * 2 + 1 ] ; } chars . getChars ( 0 , length , m_charsBuff , 0 ) ; this . characters ( m_charsBuff , 0 , length ) ; } public void endElement ( String elementName ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . endElement ( elementName ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { this . startPrefixMapping ( prefix , uri , true ) ; } public void namespaceAfterStartElement ( String prefix , String uri ) throws SAXException { if ( m_firstTagNotEmitted && m_firstElementURI == null && m_firstElementName != null ) { String prefix1 = getPrefixPart ( m_firstElementName ) ; if ( prefix1 == null && EMPTYSTRING . equals ( prefix ) ) { m_firstElementURI = uri ; } } startPrefixMapping ( prefix , uri , false ) ; } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { boolean pushed = false ; if ( m_firstTagNotEmitted ) { if ( m_firstElementName != null && shouldFlush ) { flush ( ) ; pushed = m_handler . startPrefixMapping ( prefix , uri , shouldFlush ) ; } else { if ( m_namespacePrefix == null ) { m_namespacePrefix = new Vector ( ) ; m_namespaceURI = new Vector ( ) ; } m_namespacePrefix . addElement ( prefix ) ; m_namespaceURI . addElement ( uri ) ; if ( m_firstElementURI == null ) { if ( prefix . equals ( m_firstElementPrefix ) ) m_firstElementURI = uri ; } } } else { pushed = m_handler . startPrefixMapping ( prefix , uri , shouldFlush ) ; } return pushed ; } public void setVersion ( String version ) { m_handler . setVersion ( version ) ; m_setVersion_called = true ; } public void startDocument ( ) throws SAXException { m_needToCallStartDocument = true ; } public void startElement ( String qName ) throws SAXException { this . startElement ( null , null , qName , null ) ; } public void startElement ( String namespaceURI , String localName , String qName ) throws SAXException { this . startElement ( namespaceURI , localName , qName , null ) ; } public void startElement ( String namespaceURI , String localName , String elementName , Attributes atts ) throws SAXException { if ( m_firstTagNotEmitted ) { if ( m_firstElementName != null ) { flush ( ) ; m_handler . startElement ( namespaceURI , localName , elementName , atts ) ; } else { m_wrapped_handler_not_initialized = true ; m_firstElementName = elementName ; m_firstElementPrefix = getPrefixPartUnknown ( elementName ) ; m_firstElementURI = namespaceURI ; m_firstElementLocalName = localName ; if ( m_tracer != null ) firePseudoElement ( elementName ) ; if ( atts != null ) super . addAttributes ( atts ) ; if ( atts != null ) flush ( ) ; } } else { m_handler . startElement ( namespaceURI , localName , elementName , atts ) ; } } public void comment ( String comment ) throws SAXException { if ( m_firstTagNotEmitted && m_firstElementName != null ) { emitFirstTag ( ) ; } else if ( m_needToCallStartDocument ) { m_handler . startDocument ( ) ; m_needToCallStartDocument = false ; } m_handler . comment ( comment ) ; } public String getDoctypePublic ( ) { return m_handler . getDoctypePublic ( ) ; } public String getDoctypeSystem ( ) { return m_handler . getDoctypeSystem ( ) ; } public String getEncoding ( ) { return m_handler . getEncoding ( ) ; } public boolean getIndent ( ) { return m_handler . getIndent ( ) ; } public int getIndentAmount ( ) { return m_handler . getIndentAmount ( ) ; } public String getMediaType ( ) { return m_handler . getMediaType ( ) ; } public boolean getOmitXMLDeclaration ( ) { return m_handler . getOmitXMLDeclaration ( ) ; } public String getStandalone ( ) { return m_handler . getStandalone ( ) ; } public String getVersion ( ) { return m_handler . getVersion ( ) ; } public void setDoctype ( String system , String pub ) { m_handler . setDoctypePublic ( pub ) ; m_handler . setDoctypeSystem ( system ) ; } public void setDoctypePublic ( String doctype ) { m_handler . setDoctypePublic ( doctype ) ; m_setDoctypePublic_called = true ; } public void setDoctypeSystem ( String doctype ) { m_handler . setDoctypeSystem ( doctype ) ; m_setDoctypeSystem_called = true ; } public void setEncoding ( String encoding ) { m_handler . setEncoding ( encoding ) ; } public void setIndent ( boolean indent ) { m_handler . setIndent ( indent ) ; } public void setIndentAmount ( int value ) { m_handler . setIndentAmount ( value ) ; } public void setMediaType ( String mediaType ) { m_handler . setMediaType ( mediaType ) ; m_setMediaType_called = true ; } public void setOmitXMLDeclaration ( boolean b ) { m_handler . setOmitXMLDeclaration ( b ) ; } public void setStandalone ( String standalone ) { m_handler . setStandalone ( standalone ) ; } public void attributeDecl ( String arg0 , String arg1 , String arg2 , String arg3 , String arg4 ) throws SAXException { m_handler . attributeDecl ( arg0 , arg1 , arg2 , arg3 , arg4 ) ; } public void elementDecl ( String arg0 , String arg1 ) throws SAXException { if ( m_firstTagNotEmitted ) { emitFirstTag ( ) ; } m_handler . elementDecl ( arg0 , arg1 ) ; } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . externalEntityDecl ( name , publicId , systemId ) ; } public void internalEntityDecl ( String arg0 , String arg1 ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . internalEntityDecl ( arg0 , arg1 ) ; } public void characters ( char [ ] characters , int offset , int length ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . characters ( characters , offset , length ) ; } public void endDocument ( ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . endDocument ( ) ; } public void endElement ( String namespaceURI , String localName , String qName ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; if ( namespaceURI == null && m_firstElementURI != null ) namespaceURI = m_firstElementURI ; if ( localName == null && m_firstElementLocalName != null ) localName = m_firstElementLocalName ; } m_handler . endElement ( namespaceURI , localName , qName ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { m_handler . endPrefixMapping ( prefix ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . ignorableWhitespace ( ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . processingInstruction ( target , data ) ; } public void setDocumentLocator ( Locator locator ) { m_handler . setDocumentLocator ( locator ) ; } public void skippedEntity ( String name ) throws SAXException { m_handler . skippedEntity ( name ) ; } public void comment ( char [ ] ch , int start , int length ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . comment ( ch , start , length ) ; } public void endCDATA ( ) throws SAXException { m_handler . endCDATA ( ) ; } public void endDTD ( ) throws SAXException { m_handler . endDTD ( ) ; } public void endEntity ( String name ) throws SAXException { if ( m_firstTagNotEmitted ) { emitFirstTag ( ) ; } m_handler . endEntity ( name ) ; } public void startCDATA ( ) throws SAXException { m_handler . startCDATA ( ) ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { m_handler . startDTD ( name , publicId , systemId ) ; } public void startEntity ( String name ) throws SAXException { m_handler . startEntity ( name ) ; } private void initStreamOutput ( ) throws SAXException { boolean firstElementIsHTML = isFirstElemHTML ( ) ; if ( firstElementIsHTML ) { SerializationHandler oldHandler = m_handler ; Properties htmlProperties = OutputPropertiesFactory . getDefaultMethodProperties ( Method . HTML ) ; Serializer serializer = SerializerFactory . getSerializer ( htmlProperties ) ; m_handler = ( SerializationHandler ) serializer ; Writer writer = oldHandler . getWriter ( ) ; if ( null != writer ) m_handler . setWriter ( writer ) ; else { OutputStream os = oldHandler . getOutputStream ( ) ; if ( null != os ) m_handler . setOutputStream ( os ) ; } m_handler . setVersion ( oldHandler . getVersion ( ) ) ; m_handler . setDoctypeSystem ( oldHandler . getDoctypeSystem ( ) ) ; m_handler . setDoctypePublic ( oldHandler . getDoctypePublic ( ) ) ; m_handler . setMediaType ( oldHandler . getMediaType ( ) ) ; m_handler . setTransformer ( oldHandler . getTransformer ( ) ) ; } if ( m_needToCallStartDocument ) { m_handler . startDocument ( ) ; m_needToCallStartDocument = false ; } m_wrapped_handler_not_initialized = false ; } private void emitFirstTag ( ) throws SAXException { if ( m_firstElementName != null ) { if ( m_wrapped_handler_not_initialized ) { initStreamOutput ( ) ; m_wrapped_handler_not_initialized = false ; } m_handler . startElement ( m_firstElementURI , null , m_firstElementName , m_attributes ) ; m_attributes = null ; if ( m_namespacePrefix != null ) { final int n = m_namespacePrefix . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final String prefix = ( String ) m_namespacePrefix . elementAt ( i ) ; final String uri = ( String ) m_namespaceURI . elementAt ( i ) ; m_handler . startPrefixMapping ( prefix , uri , false ) ; } m_namespacePrefix = null ; m_namespaceURI = null ; } m_firstTagNotEmitted = false ; } } private String getLocalNameUnknown ( String value ) { int idx = value . lastIndexOf ( ':' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; idx = value . lastIndexOf ( '@' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; return ( value ) ; } private String getPrefixPartUnknown ( String qname ) { final int index = qname . indexOf ( ':' ) ; return ( index > 0 ) ? qname . substring ( 0 , index ) : EMPTYSTRING ; } private boolean isFirstElemHTML ( ) { boolean isHTML ; isHTML = getLocalNameUnknown ( m_firstElementName ) . equalsIgnoreCase ( "html" ) ; if ( isHTML && m_firstElementURI != null && ! EMPTYSTRING . equals ( m_firstElementURI ) ) { isHTML = false ; } if ( isHTML && m_namespacePrefix != null ) { final int max = m_namespacePrefix . size ( ) ; for ( int i = 0 ; i < max ; i ++ ) { final String prefix = ( String ) m_namespacePrefix . elementAt ( i ) ; final String uri = ( String ) m_namespaceURI . elementAt ( i ) ; if ( m_firstElementPrefix != null && m_firstElementPrefix . equals ( prefix ) && ! EMPTYSTRING . equals ( uri ) ) { isHTML = false ; break ; } } } return isHTML ; } public DOMSerializer asDOMSerializer ( ) throws IOException { return m_handler . asDOMSerializer ( ) ; } public void setCdataSectionElements ( Vector URI_and_localNames ) { m_handler . setCdataSectionElements ( URI_and_localNames ) ; } public void addAttributes ( Attributes atts ) throws SAXException { m_handler . addAttributes ( atts ) ; } public NamespaceMappings getNamespaceMappings ( ) { NamespaceMappings mappings = null ; if ( m_handler != null ) { mappings = m_handler . getNamespaceMappings ( ) ; } return mappings ; } public void flushPending ( ) throws SAXException { flush ( ) ; m_handler . flushPending ( ) ; } private void flush ( ) { try { if ( m_firstTagNotEmitted ) { emitFirstTag ( ) ; } if ( m_needToCallStartDocument ) { m_handler . startDocument ( ) ; m_needToCallStartDocument = false ; } } catch ( SAXException e ) { throw new RuntimeException ( e . toString ( ) ) ; } } public String getPrefix ( String namespaceURI ) { return m_handler . getPrefix ( namespaceURI ) ; } public void entityReference ( String entityName ) throws SAXException { m_handler . entityReference ( entityName ) ; } public String getNamespaceURI ( String qname , boolean isElement ) { return m_handler . getNamespaceURI ( qname , isElement ) ; } public String getNamespaceURIFromPrefix ( String prefix ) { return m_handler . getNamespaceURIFromPrefix ( prefix ) ; } public void setTransformer ( Transformer t ) { m_handler . setTransformer ( t ) ; if ( ( t instanceof SerializerTrace ) && ( ( ( SerializerTrace ) t ) . hasTraceListeners ( ) ) ) { m_tracer = ( SerializerTrace ) t ; } else { m_tracer = null ; } } public Transformer getTransformer ( ) { return m_handler . getTransformer ( ) ; } public void setContentHandler ( ContentHandler ch ) { m_handler . setContentHandler ( ch ) ; } public void setSourceLocator ( SourceLocator locator ) { m_handler . setSourceLocator ( locator ) ; } protected void firePseudoElement ( String elementName ) { if ( m_tracer != null ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( '<' ) ; sb . append ( elementName ) ; char ch [ ] = sb . toString ( ) . toCharArray ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS , ch , 0 , ch . length ) ; } } } 	1	['83', '2', '0', '11', '178', '0', '1', '10', '76', '0.843089431', '1123', '1', '1', '0.514792899', '0.115662651', '2', '10', '12.34939759', '10', '1.2048', '3']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; public final class ResultTreeType extends Type { private final String _methodName ; protected ResultTreeType ( ) { _methodName = null ; } public ResultTreeType ( String methodName ) { _methodName = methodName ; } public String toString ( ) { return "result-tree" ; } public boolean identicalTo ( Type other ) { return ( other instanceof ResultTreeType ) ; } public String toSignature ( ) { return DOM_INTF_SIG ; } public org . apache . bcel . generic . Type toJCType ( ) { return Util . getJCRefType ( toSignature ( ) ) ; } public String getMethodName ( ) { return _methodName ; } public boolean implementedAsMethod ( ) { return _methodName != null ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . NodeSet ) { translateTo ( classGen , methodGen , ( NodeSetType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else if ( type == Type . Object ) { translateTo ( classGen , methodGen , ( ObjectType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( POP ) ; il . append ( ICONST_1 ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _methodName == null ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , "getStringValue" , "()" + STRING_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; } else { final String className = classGen . getClassName ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( DUP ) ; il . append ( new GETFIELD ( cpg . addFieldref ( className , "_dom" , DOM_INTF_SIG ) ) ) ; int index = cpg . addMethodref ( STRING_VALUE_HANDLER , "<init>" , "()V" ) ; il . append ( new NEW ( cpg . addClass ( STRING_VALUE_HANDLER ) ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( index ) ) ; final LocalVariableGen handler = methodGen . addLocalVariable ( "rt_to_string_handler" , Util . getJCRefType ( STRING_VALUE_HANDLER_SIG ) , null , null ) ; il . append ( new ASTORE ( handler . getIndex ( ) ) ) ; index = cpg . addMethodref ( className , _methodName , "(" + DOM_INTF_SIG + TRANSLET_OUTPUT_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; il . append ( new ALOAD ( handler . getIndex ( ) ) ) ; index = cpg . addMethodref ( STRING_VALUE_HANDLER , "getValue" , "()" + STRING_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { translateTo ( classGen , methodGen , Type . String ) ; Type . String . translateTo ( classGen , methodGen , Type . Real ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _methodName == null ) { il . append ( NOP ) ; } else { LocalVariableGen domBuilder , newDom ; final String className = classGen . getClassName ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , "getResultTreeFrag" , "(IZ)" + DOM_INTF_SIG ) ; il . append ( new PUSH ( cpg , RTF_INITIAL_SIZE ) ) ; il . append ( new PUSH ( cpg , false ) ) ; il . append ( new INVOKEINTERFACE ( index , 3 ) ) ; il . append ( DUP ) ; newDom = methodGen . addLocalVariable ( "rt_to_reference_dom" , Util . getJCRefType ( DOM_INTF_SIG ) , null , null ) ; il . append ( new CHECKCAST ( cpg . addClass ( DOM_INTF_SIG ) ) ) ; il . append ( new ASTORE ( newDom . getIndex ( ) ) ) ; index = cpg . addInterfaceMethodref ( DOM_INTF , "getOutputDomBuilder" , "()" + TRANSLET_OUTPUT_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; domBuilder = methodGen . addLocalVariable ( "rt_to_reference_handler" , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) , null , null ) ; il . append ( new ASTORE ( domBuilder . getIndex ( ) ) ) ; index = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "startDocument" , "()V" ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; index = cpg . addMethodref ( className , _methodName , "(" + DOM_INTF_SIG + TRANSLET_OUTPUT_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; il . append ( new ALOAD ( domBuilder . getIndex ( ) ) ) ; index = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "endDocument" , "()V" ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; il . append ( new ALOAD ( newDom . getIndex ( ) ) ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeSetType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( DUP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMES_INDEX , NAMES_INDEX_SIG ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , URIS_INDEX , URIS_INDEX_SIG ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , TYPES_INDEX , TYPES_INDEX_SIG ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMESPACE_INDEX , NAMESPACE_INDEX_SIG ) ) ) ; final int mapping = cpg . addInterfaceMethodref ( DOM_INTF , "setupMapping" , "([" + STRING_SIG + "[" + STRING_SIG + "[I" + "[" + STRING_SIG + ")V" ) ; il . append ( new INVOKEINTERFACE ( mapping , 5 ) ) ; il . append ( DUP ) ; final int iter = cpg . addInterfaceMethodref ( DOM_INTF , "getIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( iter , 1 ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ObjectType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; translateTo ( classGen , methodGen , Type . Boolean ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final String className = clazz . getName ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( className . equals ( "org.w3c.dom.Node" ) ) { translateTo ( classGen , methodGen , Type . NodeSet ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE , MAKE_NODE_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "org.w3c.dom.NodeList" ) ) { translateTo ( classGen , methodGen , Type . NodeSet ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE_LIST , MAKE_NODE_LIST_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "java.lang.Object" ) ) { il . append ( NOP ) ; } else if ( className . equals ( "java.lang.String" ) ) { translateTo ( classGen , methodGen , Type . String ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , className ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public String getClassName ( ) { return ( DOM_INTF ) ; } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	1	['22', '2', '0', '40', '59', '185', '9', '33', '21', '0.523809524', '751', '1', '0', '0.622641509', '0.199300699', '2', '4', '33.09090909', '7', '1.5909', '1']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xml . dtm . DTMAxisIterator ; public abstract class SingleNodeCounter extends NodeCounter { static private final int [ ] EmptyArray = new int [ ] { } ; DTMAxisIterator _countSiblings = null ; public SingleNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } public NodeCounter setStartNode ( int node ) { _node = node ; _nodeType = _document . getExpandedTypeID ( node ) ; _countSiblings = _document . getAxisIterator ( PRECEDINGSIBLING ) ; return this ; } public String getCounter ( ) { int result ; if ( _value != Integer . MIN_VALUE ) { result = _value ; } else { int next = _node ; result = 0 ; if ( ! matchesCount ( next ) ) { while ( ( next = _document . getParent ( next ) ) > END ) { if ( matchesCount ( next ) ) { break ; } if ( matchesFrom ( next ) ) { next = END ; break ; } } } if ( next != END ) { _countSiblings . setStartNode ( next ) ; do { if ( matchesCount ( next ) ) result ++ ; } while ( ( next = _countSiblings . next ( ) ) != END ) ; } else { return formatNumbers ( EmptyArray ) ; } } return formatNumbers ( result ) ; } public static NodeCounter getDefaultNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { return new DefaultSingleNodeCounter ( translet , document , iterator ) ; } static class DefaultSingleNodeCounter extends SingleNodeCounter { public DefaultSingleNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } public NodeCounter setStartNode ( int node ) { _node = node ; _nodeType = _document . getExpandedTypeID ( node ) ; _countSiblings = _document . getTypedAxisIterator ( PRECEDINGSIBLING , _document . getExpandedTypeID ( node ) ) ; return this ; } public String getCounter ( ) { int result ; if ( _value != Integer . MIN_VALUE ) { result = _value ; } else { int next ; result = 1 ; _countSiblings . setStartNode ( _node ) ; while ( ( next = _countSiblings . next ( ) ) != END ) { result ++ ; } } return formatNumbers ( result ) ; } } } 	1	['5', '2', '1', '5', '16', '2', '1', '5', '4', '0.625', '110', '0.5', '1', '0.823529412', '0.5', '1', '4', '20.6', '9', '2.2', '2']
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . PrefixResolverDefault ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class CachedXPathAPI { protected XPathContext xpathSupport ; public CachedXPathAPI ( ) { xpathSupport = new XPathContext ( ) ; } public CachedXPathAPI ( CachedXPathAPI priorXPathAPI ) { xpathSupport = priorXPathAPI . xpathSupport ; } public XPathContext getXPathContext ( ) { return this . xpathSupport ; } public Node selectSingleNode ( Node contextNode , String str ) throws TransformerException { return selectSingleNode ( contextNode , str , contextNode ) ; } public Node selectSingleNode ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { NodeIterator nl = selectNodeIterator ( contextNode , str , namespaceNode ) ; return nl . nextNode ( ) ; } public NodeIterator selectNodeIterator ( Node contextNode , String str ) throws TransformerException { return selectNodeIterator ( contextNode , str , contextNode ) ; } public NodeIterator selectNodeIterator ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XObject list = eval ( contextNode , str , namespaceNode ) ; return list . nodeset ( ) ; } public NodeList selectNodeList ( Node contextNode , String str ) throws TransformerException { return selectNodeList ( contextNode , str , contextNode ) ; } public NodeList selectNodeList ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XObject list = eval ( contextNode , str , namespaceNode ) ; return list . nodelist ( ) ; } public XObject eval ( Node contextNode , String str ) throws TransformerException { return eval ( contextNode , str , contextNode ) ; } public XObject eval ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { PrefixResolverDefault prefixResolver = new PrefixResolverDefault ( ( namespaceNode . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( ( Document ) namespaceNode ) . getDocumentElement ( ) : namespaceNode ) ; XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } public XObject eval ( Node contextNode , String str , PrefixResolver prefixResolver ) throws TransformerException { XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; XPathContext xpathSupport = new XPathContext ( ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } } 	1	['12', '1', '0', '5', '23', '54', '0', '5', '12', '0.454545455', '139', '1', '1', '0', '0.533333333', '0', '0', '10.5', '1', '0.8333', '2']
package org . apache . xalan . extensions ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . net . URL ; import java . net . URLConnection ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMNodeList ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xpath . XPathProcessorException ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . objects . XObject ; public class ExtensionHandlerGeneral extends ExtensionHandler { private String m_scriptSrc ; private String m_scriptSrcURL ; private Hashtable m_functions = new Hashtable ( ) ; private Hashtable m_elements = new Hashtable ( ) ; private Object m_engine ; private Method m_engineCall = null ; private static final String BSF_MANAGER = "com.ibm.bsf.BSFManager" ; private static final String BSF_ENGINE = "com.ibm.bsf.BSFEngine" ; private static final Integer NEG1INT = new Integer ( - 1 ) ; public ExtensionHandlerGeneral ( String namespaceUri , StringVector elemNames , StringVector funcNames , String scriptLang , String scriptSrcURL , String scriptSrc , String systemId ) throws TransformerException { super ( namespaceUri , scriptLang ) ; if ( elemNames != null ) { Object junk = new Object ( ) ; int n = elemNames . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String tok = elemNames . elementAt ( i ) ; m_elements . put ( tok , junk ) ; } } if ( funcNames != null ) { Object junk = new Object ( ) ; int n = funcNames . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String tok = funcNames . elementAt ( i ) ; m_functions . put ( tok , junk ) ; } } m_scriptSrcURL = scriptSrcURL ; m_scriptSrc = scriptSrc ; if ( m_scriptSrcURL != null ) { URL url = null ; try { url = new URL ( m_scriptSrcURL ) ; } catch ( java . net . MalformedURLException mue ) { int indexOfColon = m_scriptSrcURL . indexOf ( ':' ) ; int indexOfSlash = m_scriptSrcURL . indexOf ( '/' ) ; if ( ( indexOfColon != - 1 ) && ( indexOfSlash != - 1 ) && ( indexOfColon < indexOfSlash ) ) { url = null ; throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COULD_NOT_FIND_EXTERN_SCRIPT , new Object [ ] { m_scriptSrcURL } ) , mue ) ; } else { try { url = new URL ( new URL ( SystemIDResolver . getAbsoluteURI ( systemId ) ) , m_scriptSrcURL ) ; } catch ( java . net . MalformedURLException mue2 ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COULD_NOT_FIND_EXTERN_SCRIPT , new Object [ ] { m_scriptSrcURL } ) , mue2 ) ; } } } if ( url != null ) { try { URLConnection uc = url . openConnection ( ) ; InputStream is = uc . getInputStream ( ) ; byte [ ] bArray = new byte [ uc . getContentLength ( ) ] ; is . read ( bArray ) ; m_scriptSrc = new String ( bArray ) ; } catch ( IOException ioe ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_COULD_NOT_FIND_EXTERN_SCRIPT , new Object [ ] { m_scriptSrcURL } ) , ioe ) ; } } } Object manager = null ; try { manager = ObjectFactory . newInstance ( BSF_MANAGER , ObjectFactory . findClassLoader ( ) , true ) ; } catch ( ObjectFactory . ConfigurationError e ) { e . printStackTrace ( ) ; } if ( manager == null ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_INIT_BSFMGR , null ) ) ; } try { Method loadScriptingEngine = manager . getClass ( ) . getMethod ( "loadScriptingEngine" , new Class [ ] { String . class } ) ; m_engine = loadScriptingEngine . invoke ( manager , new Object [ ] { scriptLang } ) ; Method engineExec = m_engine . getClass ( ) . getMethod ( "exec" , new Class [ ] { String . class , Integer . TYPE , Integer . TYPE , Object . class } ) ; engineExec . invoke ( m_engine , new Object [ ] { "XalanScript" , NEG1INT , NEG1INT , m_scriptSrc } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_CMPL_EXTENSN , null ) , e ) ; } } public boolean isFunctionAvailable ( String function ) { return ( m_functions . get ( function ) != null ) ; } public boolean isElementAvailable ( String element ) { return ( m_elements . get ( element ) != null ) ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { Object [ ] argArray ; try { argArray = new Object [ args . size ( ) ] ; for ( int i = 0 ; i < argArray . length ; i ++ ) { Object o = args . elementAt ( i ) ; argArray [ i ] = ( o instanceof XObject ) ? ( ( XObject ) o ) . object ( ) : o ; o = argArray [ i ] ; if ( null != o && o instanceof DTMIterator ) { argArray [ i ] = new DTMNodeList ( ( DTMIterator ) o ) ; } } if ( m_engineCall == null ) { m_engineCall = m_engine . getClass ( ) . getMethod ( "call" , new Class [ ] { Object . class , String . class , Object [ ] . class } ) ; } return m_engineCall . invoke ( m_engine , new Object [ ] { null , funcName , argArray } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; String msg = e . getMessage ( ) ; if ( null != msg ) { if ( msg . startsWith ( "Stopping after fatal error:" ) ) { msg = msg . substring ( "Stopping after fatal error:" . length ( ) ) ; } throw new TransformerException ( e ) ; } else { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_CREATE_EXTENSN , new Object [ ] { funcName , e } ) ) ; } } } public Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException { return callFunction ( extFunction . getFunctionName ( ) , args , extFunction . getMethodKey ( ) , exprContext ) ; } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { Object result = null ; XSLProcessorContext xpc = new XSLProcessorContext ( transformer , stylesheetTree ) ; try { Vector argv = new Vector ( 2 ) ; argv . addElement ( xpc ) ; argv . addElement ( element ) ; result = callFunction ( localPart , argv , methodKey , transformer . getXPathContext ( ) . getExpressionContext ( ) ) ; } catch ( XPathProcessorException e ) { throw new TransformerException ( e . getMessage ( ) , e ) ; } if ( result != null ) { xpc . outputToResultTree ( stylesheetTree , result ) ; } } } 	1	['7', '2', '0', '17', '52', '13', '0', '17', '6', '0.87037037', '512', '1', '0', '0.545454545', '0.366666667', '0', '0', '70.85714286', '2', '1', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; public class WalkingIterator extends LocPathIterator implements ExpressionOwner { WalkingIterator ( Compiler compiler , int opPos , int analysis , boolean shouldLoadWalkers ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , shouldLoadWalkers ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; if ( shouldLoadWalkers ) { m_firstWalker = WalkerFactory . loadWalkers ( this , compiler , firstStepPos , 0 ) ; m_lastUsedWalker = m_firstWalker ; } } public WalkingIterator ( PrefixResolver nscontext ) { super ( nscontext ) ; } public int getAnalysisBits ( ) { int bits = 0 ; if ( null != m_firstWalker ) { AxesWalker walker = m_firstWalker ; while ( null != walker ) { int bit = walker . getAnalysisBits ( ) ; bits |= bit ; walker = walker . getNextWalker ( ) ; } } return bits ; } public Object clone ( ) throws CloneNotSupportedException { WalkingIterator clone = ( WalkingIterator ) super . clone ( ) ; if ( null != m_firstWalker ) { clone . m_firstWalker = m_firstWalker . cloneDeep ( clone , null ) ; } return clone ; } public void reset ( ) { super . reset ( ) ; if ( null != m_firstWalker ) { m_lastUsedWalker = m_firstWalker ; m_firstWalker . setRoot ( m_context ) ; } } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; if ( null != m_firstWalker ) { m_firstWalker . setRoot ( context ) ; m_lastUsedWalker = m_firstWalker ; } } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; if ( - 1 == m_stackFrame ) { return returnNextNode ( m_firstWalker . nextNode ( ) ) ; } else { VariableStack vars = m_execContext . getVarStack ( ) ; int savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( m_stackFrame ) ; int n = returnNextNode ( m_firstWalker . nextNode ( ) ) ; vars . setStackFrame ( savedStart ) ; return n ; } } public final AxesWalker getFirstWalker ( ) { return m_firstWalker ; } public final void setFirstWalker ( AxesWalker walker ) { m_firstWalker = walker ; } public final void setLastUsedWalker ( AxesWalker walker ) { m_lastUsedWalker = walker ; } public final AxesWalker getLastUsedWalker ( ) { return m_lastUsedWalker ; } public void detach ( ) { if ( m_allowDetach ) { AxesWalker walker = m_firstWalker ; while ( null != walker ) { walker . detach ( ) ; walker = walker . getNextWalker ( ) ; } m_lastUsedWalker = null ; super . detach ( ) ; } } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_predicateIndex = - 1 ; AxesWalker walker = m_firstWalker ; while ( null != walker ) { walker . fixupVariables ( vars , globalsSize ) ; walker = walker . getNextWalker ( ) ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitLocationPath ( owner , this ) ) { if ( null != m_firstWalker ) { m_firstWalker . callVisitors ( this , visitor ) ; } } } protected AxesWalker m_lastUsedWalker ; protected AxesWalker m_firstWalker ; public Expression getExpression ( ) { return m_firstWalker ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_firstWalker = ( AxesWalker ) exp ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; AxesWalker walker1 = m_firstWalker ; AxesWalker walker2 = ( ( WalkingIterator ) expr ) . m_firstWalker ; while ( ( null != walker1 ) && ( null != walker2 ) ) { if ( ! walker1 . deepEquals ( walker2 ) ) return false ; walker1 = walker1 . getNextWalker ( ) ; walker2 = walker2 . getNextWalker ( ) ; } if ( ( null != walker1 ) || ( null != walker2 ) ) return false ; return true ; } } 	1	['17', '5', '1', '17', '41', '0', '8', '11', '16', '0.4375', '281', '1', '2', '0.892857143', '0.165775401', '2', '9', '15.41176471', '7', '1.8824', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_hu extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Futásidejű belső hiba; helye: ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Futásidejű belső hiba <xsl:copy> végrehajtásakor." } , { BasisLibrary . DATA_CONVERSION_ERR , "Érvénytelen konverzió: ''{0}'' típusról ''{1}'' típusra." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "A(z) ''{0}'' külső függvényt nem támogatja az XSLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Ismeretlen argumentumtípus található az egyenlőségi kifejezésben." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Érvénytelen argumentumtípust (''{0}'') használt ''{1}'' hívásában." } , { BasisLibrary . FORMAT_NUMBER_ERR , "A(z) ''{0}'' számot ''{1}'' minta alapján akarta formázni." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Nem lehet klónozni a(z) ''{0}'' iterátort." } , { BasisLibrary . AXIS_SUPPORT_ERR , "A(z) ''{0}'' tengely iterátora nem támogatott." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "A tipizált ''{0}'' tengelyre iterátor nem támogatott." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "A(z) ''{0}'' attribútum kívül van az elemen." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "A(z) ''{0}''=''{1}'' névtér-deklaráció kívül esik az elemen." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "A(z) ''{0}'' előtag névtere nem definiált." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "Nem megfelelő típusú forrás DOM használatával jött létre a DOMAdapter." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "Az Ön által használt SAX elemző nem kezeli a DTD-deklarációs eseményeket." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "Az Ön által használt SAX elemző nem támogatja az XML névtereket." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "Nem lehet feloldani a(z) ''{0}'' URI hivatkozást." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xml . utils ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import org . apache . xml . utils . SystemIDResolver ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . helpers . DefaultHandler ; public class StylesheetPIHandler extends DefaultHandler { String m_baseID ; String m_media ; String m_title ; String m_charset ; Vector m_stylesheets = new Vector ( ) ; URIResolver m_uriResolver ; public void setURIResolver ( URIResolver resolver ) { m_uriResolver = resolver ; } public URIResolver getURIResolver ( ) { return m_uriResolver ; } public StylesheetPIHandler ( String baseID , String media , String title , String charset ) { m_baseID = baseID ; m_media = media ; m_title = title ; m_charset = charset ; } public Source getAssociatedStylesheet ( ) { int sz = m_stylesheets . size ( ) ; if ( sz > 0 ) { Source source = ( Source ) m_stylesheets . elementAt ( sz - 1 ) ; return source ; } else return null ; } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { if ( target . equals ( "xml-stylesheet" ) ) { String href = null ; String type = null ; String title = null ; String media = null ; String charset = null ; boolean alternate = false ; StringTokenizer tokenizer = new StringTokenizer ( data , " \t=\n" , true ) ; boolean lookedAhead = false ; Source source = null ; String token = "" ; while ( tokenizer . hasMoreTokens ( ) ) { if ( ! lookedAhead ) token = tokenizer . nextToken ( ) ; else lookedAhead = false ; if ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) continue ; String name = token ; if ( name . equals ( "type" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; type = token . substring ( 1 , token . length ( ) - 1 ) ; } else if ( name . equals ( "href" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; href = token ; if ( tokenizer . hasMoreTokens ( ) ) { token = tokenizer . nextToken ( ) ; while ( token . equals ( "=" ) && tokenizer . hasMoreTokens ( ) ) { href = href + token + tokenizer . nextToken ( ) ; if ( tokenizer . hasMoreTokens ( ) ) { token = tokenizer . nextToken ( ) ; lookedAhead = true ; } else { break ; } } } href = href . substring ( 1 , href . length ( ) - 1 ) ; try { if ( m_uriResolver != null ) { source = m_uriResolver . resolve ( href , m_baseID ) ; } else { href = SystemIDResolver . getAbsoluteURI ( href , m_baseID ) ; source = new SAXSource ( new InputSource ( href ) ) ; } } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else if ( name . equals ( "title" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; title = token . substring ( 1 , token . length ( ) - 1 ) ; } else if ( name . equals ( "media" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; media = token . substring ( 1 , token . length ( ) - 1 ) ; } else if ( name . equals ( "charset" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; charset = token . substring ( 1 , token . length ( ) - 1 ) ; } else if ( name . equals ( "alternate" ) ) { token = tokenizer . nextToken ( ) ; while ( tokenizer . hasMoreTokens ( ) && ( token . equals ( " " ) || token . equals ( "\t" ) || token . equals ( "=" ) ) ) token = tokenizer . nextToken ( ) ; alternate = token . substring ( 1 , token . length ( ) - 1 ) . equals ( "yes" ) ; } } if ( ( null != type ) && ( type . equals ( "text/xsl" ) || type . equals ( "text/xml" ) || type . equals ( "application/xml+xslt" ) ) && ( null != href ) ) { if ( null != m_media ) { if ( null != media ) { if ( ! media . equals ( m_media ) ) return ; } else return ; } if ( null != m_charset ) { if ( null != charset ) { if ( ! charset . equals ( m_charset ) ) return ; } else return ; } if ( null != m_title ) { if ( null != title ) { if ( ! title . equals ( m_title ) ) return ; } else return ; } m_stylesheets . addElement ( source ) ; } } } public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws org . xml . sax . SAXException { throw new StopParseException ( ) ; } public void setBaseId ( String baseId ) { m_baseID = baseId ; } public String getBaseId ( ) { return m_baseID ; } } 	1	['8', '2', '0', '4', '28', '6', '2', '2', '8', '0.761904762', '471', '0', '0', '0.708333333', '0.4375', '1', '1', '57.125', '2', '1', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_ru extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Ошибка: Скобка '{' недопустима в выражении" } , { ER_ILLEGAL_ATTRIBUTE , "Для {0} указан недопустимый атрибут: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "Пустой sourceNode в xsl:apply-imports!" } , { ER_CANNOT_ADD , "Не удалось добавить {0} в {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "Пустой sourceNode в handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "У {0} должен быть атрибут name" } , { ER_TEMPLATE_NOT_FOUND , "Указанный шаблон не найден: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Не удалось преобразовать имя AVT в xsl:call-template." } , { ER_REQUIRES_ATTRIB , "Для {0} должен быть указан атрибут: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "Для {0} должен быть задан атрибут ''test''." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Неверное значение атрибута уровня: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Имя processing-instruction не может быть равно 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Имя processing-instruction должно быть допустимым именем NCName: {0}" } , { ER_NEED_MATCH_ATTRIB , "Если для {0} определен режим, то необходим атрибут match." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "У {0} должен быть атрибут name или match." } , { ER_CANT_RESOLVE_NSPREFIX , "Не удалось преобразовать префикс пространства имен: {0}" } , { ER_ILLEGAL_VALUE , "В xml:space указано недопустимое значение: {0}" } , { ER_NO_OWNERDOC , "У дочернего узла нет документа-владельца!" } , { ER_ELEMTEMPLATEELEM_ERR , "Ошибка ElemTemplateElement: {0}" } , { ER_NULL_CHILD , "Попытка добавить пустого потомка!" } , { ER_NEED_SELECT_ATTRIB , "У {0} должен быть атрибут select." } , { ER_NEED_TEST_ATTRIB , "Для xsl:when должен быть задан атрибут 'test'." } , { ER_NEED_NAME_ATTRIB , "Для xsl:with-param должен быть задан атрибут 'name'. " } , { ER_NO_CONTEXT_OWNERDOC , "В контексте отсутствует документ-владелец!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Невозможно создать XML TransformerFactory Liaison: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: В процессе обнаружены ошибки." } , { ER_NOT_SUCCESSFUL , "Xalan: Ошибка." } , { ER_ENCODING_NOT_SUPPORTED , "Кодировка не поддерживается: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Невозможно создать TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "Для xsl:key необходим атрибут 'name'!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "Для xsl:key необходим атрибут 'match'!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "Для xsl:key необходим атрибут 'use'!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "Для (StylesheetHandler) {0} необходим атрибут ''elements''!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) У {0} отсутствует атрибут ''prefix''" } , { ER_BAD_STYLESHEET_URL , "Неверный URL таблицы стилей: {0}" } , { ER_FILE_NOT_FOUND , "Не найден файл таблицы стилей: {0}" } , { ER_IOEXCEPTION , "Исключительная ситуация ввода-вывода при обращении к файлу таблицы стилей: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Не найден атрибут href для {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} непосредственно или косвенно ссылается на себя!" } , { ER_PROCESSINCLUDE_ERROR , "Ошибка StylesheetHandler.processInclude, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) У {0} отсутствует атрибут ''lang''" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) Неверное положение элемента {0} ?? Отсутствует элемент контейнера ''component''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Вывод возможен только в следующие объекты: Element, DocumentFragment, Document или PrintWriter." } , { ER_PROCESS_ERROR , "Ошибка StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "Ошибка UnImplNode: {0}" } , { ER_NO_SELECT_EXPRESSION , "Ошибка! Не найдено выражение выбора xpath (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Не удалось сериализовать XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "Не указана исходная таблица стилей!" } , { ER_FAILED_PROCESS_STYLESHEET , "Ошибка при обработке таблицы стилей!" } , { ER_COULDNT_PARSE_DOC , "Не удалось проанализировать документ {0} !" } , { ER_COULDNT_FIND_FRAGMENT , "Не найден фрагмент: {0}" } , { ER_NODE_NOT_ELEMENT , "Узел, на который ссылается идентификатор фрагмента, не является элементом: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "У for-each должен быть атрибут match или name" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "У templates должен быть атрибут match или name" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Отсутствует копия фрагмента документа!" } , { ER_CANT_CREATE_ITEM , "Не удалось создать элемент дерева результатов: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "Задано недопустимое значение xml:space в исходном XML: {0}" } , { ER_NO_XSLKEY_DECLARATION , "Отсутствует объявление xsl:key для {0}!" } , { ER_CANT_CREATE_URL , "Ошибка! Не удалось создать URL для {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions не поддерживается" } , { ER_PROCESSOR_ERROR , "Ошибка XSLT TransformerFactory" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} недопустим в таблице стилей!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns больше не поддерживается! Используйте xsl:output." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space больше не поддерживается! Используйте xsl:strip-space или xsl:preserve-space." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result больше не поддерживается! Используйте xsl:output." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) Для {0} указан недопустимый атрибут: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Неизвестный элемент XSL: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort может применяться только с xsl:apply-templates или xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) Неверное положение xsl:when!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when не имеет предшествующего xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) Неверное положение xsl:otherwise!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise не имеет предшествующего xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} недопустим в шаблоне!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) Неизвестный префикс {1} пространства имен расширения {0}" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Imports допустим только в качестве первого элемента таблицы стилей!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} непосредственно или косвенно импортирует себя!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) Для xml:space указано недопустимое значение: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "Ошибка processStylesheet!" } , { ER_SAX_EXCEPTION , "Исключительная ситуация SAX" } , { ER_XSLT_ERROR , "Ошибка XSLT" } , { ER_CURRENCY_SIGN_ILLEGAL , "Символ денежной единицы недопустим в строке форматирования шаблона" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Функция документа не поддерживается в DOM таблицы стилей!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Не удалось преобразовать префикс преобразователя non-Prefix!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Расширение перенаправления: Не удалось получить имя файла - атрибут file или select должен возвращать допустимую строку." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Не удалось создать FormatterListener в расширении перенаправления!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Недопустимый префикс в exclude-result-prefixes: {0}" } , { ER_MISSING_NS_URI , "Для указанного префикса отсутствует URI пространства имен" } , { ER_MISSING_ARG_FOR_OPTION , "Отсутствует аргумент опции: {0}" } , { ER_INVALID_OPTION , "Недопустимая опция: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Неправильная строка форматирования: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "Для xsl:stylesheet необходим атрибут 'version'!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Атрибут: В {0} указано недопустимое значение: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "Для xsl:choose необходим xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports не допускается в xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Нельзя применять DTMLiaison для узла вывода DOM ... Используйте org.apache.xpath.DOM2Helper!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Нельзя применять DTMLiaison для узла ввода DOM ... Используйте org.apache.xpath.DOM2Helper!" } , { ER_CALL_TO_EXT_FAILED , "Ошибка при вызове элемента расширения: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Префикс должен обеспечивать преобразование в пространство имен: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Обнаружено недопустимое значение UTF-16: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} применяет себя, что приведет к образованию бесконечного цикла." } , { ER_CANNOT_MIX_XERCESDOM , "Нельзя одновременно применять ввод не-Xerces-DOM и вывод Xerces-DOM!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "В ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Обнаружено несколько шаблонов с заданным именем: {0}" } , { ER_INVALID_KEY_CALL , "Недопустимый вызов функции: рекурсивные вызовы key() недопустимы" } , { ER_REFERENCING_ITSELF , "Переменная {0} непосредственно или косвенно ссылается на себя!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Для DOMSource в newTemplates узел ввода не может быть пустым!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Не найден файл класса для опции {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Не найден обязательный элемент: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream не может быть пустым" } , { ER_URI_CANNOT_BE_NULL , "URI не может быть пустым" } , { ER_FILE_CANNOT_BE_NULL , "Файл не может быть пустым" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource не может быть пустым" } , { ER_CANNOT_INIT_BSFMGR , "Не удалось инициализировать администратор BSF" } , { ER_CANNOT_CMPL_EXTENSN , "Не удалось откомпилировать расширение" } , { ER_CANNOT_CREATE_EXTENSN , "Не удалось создать расширение: {0}, причина: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "При вызове в экземпляре метода {0} в первом аргументе должен быть передан экземпляр объекта" } , { ER_INVALID_ELEMENT_NAME , "Указано недопустимое имя элемента {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Метод name элемента должен быть статическим {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Неизвестная функция расширения {0} : {1}" } , { ER_MORE_MATCH_CONSTRUCTOR , "Несколько наилучших соответствий для конструктора {0}" } , { ER_MORE_MATCH_METHOD , "Несколько лучших соответствий для метода {0}" } , { ER_MORE_MATCH_ELEMENT , "Несколько лучших соответствий для метода элемента {0}" } , { ER_INVALID_CONTEXT_PASSED , "Для вычисления передан недопустимый контекст {0}" } , { ER_POOL_EXISTS , "Пул уже существует" } , { ER_NO_DRIVER_NAME , "Не указано имя драйвера" } , { ER_NO_URL , "Не указан URL" } , { ER_POOL_SIZE_LESSTHAN_ONE , "Размер пула меньше единицы!" } , { ER_INVALID_DRIVER , "Указано недопустимое имя драйвера!" } , { ER_NO_STYLESHEETROOT , "Не найден корневой элемент таблицы стилей!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Недопустимое значение xml:space" } , { ER_PROCESSFROMNODE_FAILED , "Ошибка processFromNode" } , { ER_RESOURCE_COULD_NOT_LOAD , "Не удалось загрузить ресурс [ {0} ]: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Размер буфера <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Неизвестная ошибка при вызове расширения" } , { ER_NO_NAMESPACE_DECL , "У префикса {0} отсутствует объявление соответствующего пространства имен" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Содержимое элемента недопустимо для lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Прервано в соответствии с таблицей стилей" } , { ER_ONE_OR_TWO , "1 или 2" } , { ER_TWO_OR_THREE , "2 или 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Не удалось загрузить {0} (проверьте настройку CLASSPATH), применяются значения по умолчанию" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Не удалось инициализировать шаблоны по умолчанию" } , { ER_RESULT_NULL , "Результат не должен быть пустым" } , { ER_RESULT_COULD_NOT_BE_SET , "Невозможно задать результат" } , { ER_NO_OUTPUT_SPECIFIED , "Не указан вывод" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Не удалось преобразовать к типу результата {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Не удалось преобразовать к типу результата {0}" } , { ER_NULL_CONTENT_HANDLER , "Пустой обработчик содержания" } , { ER_NULL_ERROR_HANDLER , "Пустой обработчик ошибки" } , { ER_CANNOT_CALL_PARSE , "Невозможно вызвать анализатор, если не задан ContentHandler" } , { ER_NO_PARENT_FOR_FILTER , "Не задан родительский объект фильтра" } , { ER_NO_STYLESHEET_IN_MEDIA , "В {0} не найдена таблица стилей, носитель={1}" } , { ER_NO_STYLESHEET_PI , "Не найден PI xml-stylesheet в {0}" } , { ER_NOT_SUPPORTED , "Не поддерживается: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Значение свойства {0} должно быть экземпляром Boolean" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "Невозможно получить внешний сценарий в {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "Ресурс [ {0} ] не найден.\n{1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Свойство вывода не распознано: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Не удалось создать элемент ElemLiteralResult" } , { ER_VALUE_SHOULD_BE_NUMBER , "Значение {0} должно быть анализируемым числом" } , { ER_VALUE_SHOULD_EQUAL , "В {0} должно быть указано значение yes или no" } , { ER_FAILED_CALLING_METHOD , "Ошибка при вызове метода {0}" } , { ER_FAILED_CREATING_ELEMTMPL , "Ошибка при создании экземпляра ElemTemplateElement" } , { ER_CHARS_NOT_ALLOWED , "Символы недопустимы в данной позиции документа" } , { ER_ATTR_NOT_ALLOWED , "Атрибут \"{0}\" недопустим в элементе {1}!" } , { ER_BAD_VALUE , "{0} неверное значение {1}" } , { ER_ATTRIB_VALUE_NOT_FOUND , "Значение атрибута {0} не найдено" } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "Значение атрибута {0} не распознано" } , { ER_NULL_URI_NAMESPACE , "Попытка создать префикс пространства имен с пустым URI" } , { ER_NUMBER_TOO_BIG , "Попытка отформатировать число больше максимально допустимого LongInteger" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Не удалось найти класс драйвера SAX1 {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "Класс драйвера SAX1 {0} обнаружен, но его загрузка невозможна" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "Класс драйвера SAX1 {0} загружен, но его инициализация невозможна" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "В классе драйвера SAX1 {0} не реализован org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Не задано системное свойство org.xml.sax.parser" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Аргумент анализатора не должен быть пустым" } , { ER_FEATURE , "Функция: {0}" } , { ER_PROPERTY , "Свойство: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Пустой преобразователь макроса" } , { ER_NULL_DTD_HANDLER , "Пустой дескриптор DTD" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Не указано имя драйвера!" } , { ER_NO_URL_SPECIFIED , "Не указан URL!" } , { ER_POOLSIZE_LESS_THAN_ONE , "Размер пула меньше 1!" } , { ER_INVALID_DRIVER_NAME , "Указано недопустимое имя драйвера!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Программная ошибка! У выражения нет родительского элемента ElemTemplateElement!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Программное предположение RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} недопустимо в данной позиции таблицы стилей!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Текст недопустим в данной позиции таблицы стилей!" } , { INVALID_TCHAR , "Недопустимое значение {1} атрибута CHAR: {0}. Атрибут типа CHAR должен содержать только 1 символ!" } , { INVALID_QNAME , "Недопустимое значение {1} атрибута QNAME: {0}" } , { INVALID_ENUM , "Недопустимое значение {1} атрибута ENUM: {0}. Допустимые значения: {2}." } , { INVALID_NMTOKEN , "Недопустимое значение {1} атрибута NMTOKEN: {0}. " } , { INVALID_NCNAME , "Недопустимое значение {1} атрибута NCNAME: {0}. " } , { INVALID_BOOLEAN , "Недопустимое значение {1} атрибута boolean: {0}. " } , { INVALID_NUMBER , "Недопустимое значение {1} атрибута number: {0}. " } , { ER_ARG_LITERAL , "Аргумент {0} в шаблоне сравнения должен быть литералом." } , { ER_DUPLICATE_GLOBAL_VAR , "Повторное объявление глобальной переменной." } , { ER_DUPLICATE_VAR , "Повторное объявление переменной." } , { ER_TEMPLATE_NAME_MATCH , "Для xsl:template должен быть задан атрибут name или match, либо оба этих атрибута" } , { ER_INVALID_PREFIX , "Недопустимый префикс в exclude-result-prefixes: {0}" } , { ER_NO_ATTRIB_SET , "attribute-set с именем {0} не существует" } , { WG_FOUND_CURLYBRACE , "Найдена закрывающая скобка '}', но открытые шаблоны атрибутов отсутствуют!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Предупреждение: Атрибут count не соответствует родительскому в xsl:number! Целевой = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Старый синтаксис: Имя атрибута 'expr' изменено на 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan еще не может обрабатывать имя локали в функции format-number." } , { WG_LOCALE_NOT_FOUND , "Предупреждение: Не найдена локаль для xml:lang={0}" } , { WG_CANNOT_MAKE_URL_FROM , "Невозможно создать URL из: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Не удалось загрузить запрошенный документ: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Не удалось найти Collator для <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Старый синтаксис: в инструкции functions не следует применять url {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "Кодировка не поддерживается: {0}, применяется UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "Кодировка не поддерживается: {0}, применяется Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Обнаружен конфликт спецификаций: Будет применяться последний обнаруженный в таблице стилей {0}." } , { WG_PARSING_AND_PREPARING , "========= Анализ и подготовка {0} ==========" } , { WG_ATTR_TEMPLATE , "Шаблон атрибута, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Конфликт соответствия xsl:strip-space и xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan еще не может обрабатывать атрибут {0}!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Не найдено объявление десятичного формата: {0}" } , { WG_OLD_XSLT_NS , "Отсутствует или неправильно задано пространство имен XSLT." } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Допустимо только одно объявление xsl:decimal-format по умолчанию." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "Имена xsl:decimal-format должны быть уникальными. Имя \"{0}\" повторяется." } , { WG_ILLEGAL_ATTRIBUTE , "Для {0} указан недопустимый атрибут: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Невозможно преобразовать префикс пространства имен: {0}. Узел будет проигнорирован." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "Для xsl:stylesheet необходим атрибут 'version'!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Недопустимое имя атрибута: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Недопустимое значение атрибута {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "Результирующий набор узлов из второго аргумента функции document пуст. Возврат пустого node-set." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Значение атрибута 'name' в имени xsl:processing-instruction не должно быть равно 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Значение атрибута 'name' в xsl:processing-instruction должно быть допустимым именем NCName: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Невозможно добавить атрибут {0} после дочерних узлов или перед созданием элемента. Атрибут будет проигнорирован. " } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "Параметр createMessage лежит вне допустимого диапазона" } , { "FORMAT_FAILED" , "Исключительная ситуация при вызове messageFormat" } , { "version" , ">>>>>>> Версия Xalan" } , { "version2" , "<<<<<<<" } , { "yes" , "да" } , { "line" , "Номер строки" } , { "column" , "Номер столбца" } , { "xsldone" , "XSLProcessor: выполнено" } , { "xslProc_option" , "Опции процесса командной строки Xalan-J:" } , { "xslProc_option" , "Опции процесса командной строки Xalan-J:" } , { "xslProc_invalid_xsltc_option" , "Опция {0} не поддерживается в режиме XSLTC." } , { "xslProc_invalid_xalan_option" , "Опция {0} может применяться только с -XSLTC." } , { "xslProc_no_input" , "Ошибка: Не указана таблица стилей или исходный файл xml. Для просмотра справки по использованию команды введите команду без параметров." } , { "xslProc_common_options" , "-Общие опции-" } , { "xslProc_xalan_options" , "-Опции Xalan-" } , { "xslProc_xsltc_options" , "-Опции XSLTC-" } , { "xslProc_return_to_continue" , "(Для продолжения нажмите <Enter>)" } , { "optionXSLTC" , "   [-XSLTC (для преобразования используйте XSLTC)]" } , { "optionIN" , "   [-IN inputXMLURL]" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER полное имя класса анализатора]" } , { "optionE" , "   [-E (Не разворачивать ссылки на макросы entity)]" } , { "optionV" , "   [-E (Не разворачивать ссылки на макросы entity)]" } , { "optionQC" , "   [-QC (Не показывать предупреждения о конфликтах шаблонов)]" } , { "optionQ" , "   [-Q  (Тихий режим)]" } , { "optionLF" , "   [-LF (Применять в выводе только LF {по умолчанию - CR/LF})]" } , { "optionCR" , "   [-CR (Применять в выводе только CR {по умолчанию - CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Символы, требующие Esc-последовательностей {по умолчанию - <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Число пробелов в отступе {по умолчанию - 0})]" } , { "optionTT" , "   [-TT (Трассировка вызываемых шаблонов.)]" } , { "optionTG" , "   [-TG (Трассировка событий создания.)]" } , { "optionTS" , "   [-TS (Трассировка событий выбора.)]" } , { "optionTTC" , "   [-TTC (Трассировка обрабатываемых дочерних объектов шаблонов.)]" } , { "optionTCLASS" , "   [-TCLASS (Класс TraceListener для трассировка расширений.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Включает проверку. По умолчанию проверка выключена.)]" } , { "optionEDUMP" , "   [-EDUMP {необязательное имя файла} (Дамп стека при ошибке.)]" } , { "optionXML" , "   [-XML (Применять форматирование XML и добавлять заголовок XML.)]" } , { "optionTEXT" , "   [-TEXT (Применять текстовое форматирование.)]" } , { "optionHTML" , "   [-HTML (Применять форматирование HTML.)]" } , { "optionPARAM" , "   [-PARAM имя выражение (Задать параметр таблицы стилей)]" } , { "noParsermsg1" , "В процессе XSL обнаружены ошибки." } , { "noParsermsg2" , "** Анализатор не найден **" } , { "noParsermsg3" , "Проверьте значение classpath." } , { "noParsermsg4" , "Если у вас нет анализатора XML Parser for Java фирмы IBM, вы можете загрузить его с сайта" } , { "noParsermsg5" , "IBM AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER имя класса (URIResolver для преобразования URL)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER имя класса (EntityResolver для преобразования макросов)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER имя класса (ContentHandler для сериализации вывода)]" } , { "optionLINENUMBERS" , "   [-L применять номера строк исходного документа]" } , { "optionMEDIA" , "   [-MEDIA тип-носит. (Применять атрибут носителя для поиска таблицы стилей.)]" } , { "optionFLAVOR" , "   [-FLAVOR имя-преобразования (Явно указать s2s=SAX или d2d=DOM.)]" } , { "optionDIAG" , "   [-DIAG (Печать отчета о времени преобразования в миллисекундах.)]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL (Запросить дополняющую модель DTM с помощью значения http://xml.apache.org/xalan/features/incremental true.)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE (Отключить оптимизацию таблицы стилей с помощью значения http://xml.apache.org/xalan/features/optimize false.)]" } , { "optionRL" , "   [-RL ограничение (Числовое ограничение глубины рекурсии таблиц стилей.)]" } , { "optionXO" , "   [-XO [имя-процедуры] (Присвоить имя созданной процедуре преобразования)]" } , { "optionXD" , "   [-XD целевой-каталог (Задает целевой каталог для процедуры преобразования)]" } , { "optionXJ" , "   [-XJ файл-jar (Упаковывает классы процедуры преобразования в <файл-jar>)]" } , { "optionXP" , "   [-XP пакет (Префикс имени пакета для всех созданных классов translet)]" } , { "optionXN" , "   [-XN (разрешает копирование шаблона)]" } , { "optionXX" , "   [-XX (включает вывод дополнительных отладочных сообщений)]" } , { "optionXT" , "   [-XT (по возможности применяет процедуру преобразования)]" } , { "diagTiming" , " --------- Преобразование {0} с помощью {1} заняло {2} мс" } , { "recursionTooDeep" , "Слишком большая вложенность шаблонов. Вложенность = {0}, шаблон {1} {2}" } , { "nameIs" , "имя" } , { "matchPatternIs" , "шаблон соответствия" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "Ошибка" ; public static final String ERROR_HEADER = "Ошибка:" ; public static final String WARNING_HEADER = "Предупреждение: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xpath . axes ; import java . util . Vector ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . NodeVector ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class NodeSequence extends XObject implements DTMIterator , Cloneable , PathComponent { protected int m_last = - 1 ; protected int m_next = 0 ; protected NodeVector getVector ( ) { return ( NodeVector ) m_obj ; } protected void SetVector ( NodeVector v ) { m_obj = v ; } public boolean hasCache ( ) { return ( m_obj != null ) ; } protected DTMIterator m_iter ; public final void setIter ( DTMIterator iter ) { m_iter = iter ; } public final DTMIterator getContainedIter ( ) { return m_iter ; } protected DTMManager m_dtmMgr ; public NodeSequence ( DTMIterator iter , int context , XPathContext xctxt , boolean shouldCacheNodes ) { setIter ( iter ) ; setRoot ( context , xctxt ) ; setShouldCacheNodes ( shouldCacheNodes ) ; } public NodeSequence ( Object nodeVector ) { super ( nodeVector ) ; if ( null != nodeVector ) { assertion ( nodeVector instanceof NodeVector , "Must have a NodeVector as the object for NodeSequence!" ) ; if ( nodeVector instanceof DTMIterator ) { setIter ( ( DTMIterator ) nodeVector ) ; m_last = ( ( DTMIterator ) nodeVector ) . getLength ( ) ; } } } public NodeSequence ( DTMManager dtmMgr ) { super ( new NodeVector ( ) ) ; m_last = 0 ; m_dtmMgr = dtmMgr ; } public NodeSequence ( ) { } public DTM getDTM ( int nodeHandle ) { DTMManager mgr = getDTMManager ( ) ; if ( null != mgr ) return getDTMManager ( ) . getDTM ( nodeHandle ) ; else { assertion ( false , "Can not get a DTM Unless a DTMManager has been set!" ) ; return null ; } } public DTMManager getDTMManager ( ) { return m_dtmMgr ; } public int getRoot ( ) { if ( null != m_iter ) return m_iter . getRoot ( ) ; else { return DTM . NULL ; } } public void setRoot ( int nodeHandle , Object environment ) { if ( null != m_iter ) { XPathContext xctxt = ( XPathContext ) environment ; m_dtmMgr = xctxt . getDTMManager ( ) ; m_iter . setRoot ( nodeHandle , environment ) ; if ( ! m_iter . isDocOrdered ( ) ) { if ( ! hasCache ( ) ) setShouldCacheNodes ( true ) ; runTo ( - 1 ) ; m_next = 0 ; } } else assertion ( false , "Can not setRoot on a non-iterated NodeSequence!" ) ; } public void reset ( ) { m_next = 0 ; } public int getWhatToShow ( ) { return hasCache ( ) ? ( DTMFilter . SHOW_ALL & ~ DTMFilter . SHOW_ENTITY_REFERENCE ) : m_iter . getWhatToShow ( ) ; } public boolean getExpandEntityReferences ( ) { if ( null != m_iter ) return m_iter . getExpandEntityReferences ( ) ; else return true ; } public int nextNode ( ) { NodeVector vec = getVector ( ) ; if ( null != vec ) { if ( m_next < vec . size ( ) ) { int next = vec . elementAt ( m_next ) ; m_next ++ ; return next ; } else if ( ( - 1 != m_last ) || ( null == m_iter ) ) { m_next ++ ; return DTM . NULL ; } } if ( null == m_iter ) return DTM . NULL ; int next = m_iter . nextNode ( ) ; if ( DTM . NULL != next ) { if ( hasCache ( ) ) { if ( m_iter . isDocOrdered ( ) ) { getVector ( ) . addElement ( next ) ; m_next ++ ; } else { int insertIndex = addNodeInDocOrder ( next ) ; if ( insertIndex >= 0 ) m_next ++ ; } } else m_next ++ ; } else { m_last = m_next ; m_next ++ ; } return next ; } public int previousNode ( ) { if ( hasCache ( ) ) { if ( m_next <= 0 ) return DTM . NULL ; else { m_next -- ; return item ( m_next ) ; } } else { int n = m_iter . previousNode ( ) ; m_next = m_iter . getCurrentPos ( ) ; return m_next ; } } public void detach ( ) { if ( null != m_iter ) m_iter . detach ( ) ; super . detach ( ) ; } public void allowDetachToRelease ( boolean allowRelease ) { if ( ( false == allowRelease ) && ! hasCache ( ) ) { setShouldCacheNodes ( true ) ; } if ( null != m_iter ) m_iter . allowDetachToRelease ( allowRelease ) ; super . allowDetachToRelease ( allowRelease ) ; } public int getCurrentNode ( ) { if ( hasCache ( ) ) { int currentIndex = m_next - 1 ; NodeVector vec = getVector ( ) ; if ( ( currentIndex >= 0 ) && ( currentIndex < vec . size ( ) ) ) return vec . elementAt ( currentIndex ) ; else return DTM . NULL ; } if ( null != m_iter ) { return m_iter . getCurrentNode ( ) ; } else return DTM . NULL ; } public boolean isFresh ( ) { return ( 0 == m_next ) ; } public void setShouldCacheNodes ( boolean b ) { if ( b ) { if ( ! hasCache ( ) ) { SetVector ( new NodeVector ( ) ) ; } } else SetVector ( null ) ; } public boolean isMutable ( ) { return hasCache ( ) ; } public int getCurrentPos ( ) { return m_next ; } public void runTo ( int index ) { int n ; if ( - 1 == index ) { int pos = m_next ; while ( DTM . NULL != ( n = nextNode ( ) ) ) ; m_next = pos ; } else if ( m_next == index ) { return ; } else if ( hasCache ( ) && m_next < getVector ( ) . size ( ) ) { m_next = index ; } else if ( ( null == getVector ( ) ) && ( index < m_next ) ) { while ( ( m_next >= index ) && DTM . NULL != ( n = previousNode ( ) ) ) ; } else { while ( ( m_next < index ) && DTM . NULL != ( n = nextNode ( ) ) ) ; } } public void setCurrentPos ( int i ) { runTo ( i ) ; } public int item ( int index ) { setCurrentPos ( index ) ; int n = nextNode ( ) ; m_next = index ; return n ; } public void setItem ( int node , int index ) { NodeVector vec = getVector ( ) ; if ( null != vec ) { vec . setElementAt ( node , index ) ; m_last = vec . size ( ) ; } else m_iter . setItem ( node , index ) ; } public int getLength ( ) { if ( hasCache ( ) ) { if ( m_iter instanceof NodeSetDTM ) { return m_iter . getLength ( ) ; } if ( - 1 == m_last ) { int pos = m_next ; runTo ( - 1 ) ; m_next = pos ; } return m_last ; } else { return ( - 1 == m_last ) ? ( m_last = m_iter . getLength ( ) ) : m_last ; } } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { NodeSequence seq = ( NodeSequence ) super . clone ( ) ; seq . m_next = 0 ; return seq ; } public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } public boolean isDocOrdered ( ) { if ( null != m_iter ) return m_iter . isDocOrdered ( ) ; else return true ; } public int getAxis ( ) { if ( null != m_iter ) return m_iter . getAxis ( ) ; else { assertion ( false , "Can not getAxis from a non-iterated node sequence!" ) ; return 0 ; } } public int getAnalysisBits ( ) { if ( ( null != m_iter ) && ( m_iter instanceof PathComponent ) ) return ( ( PathComponent ) m_iter ) . getAnalysisBits ( ) ; else return 0 ; } public void fixupVariables ( Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; } protected int addNodeInDocOrder ( int node ) { assertion ( hasCache ( ) , "addNodeInDocOrder must be done on a mutable sequence!" ) ; int insertIndex = - 1 ; NodeVector vec = getVector ( ) ; int size = vec . size ( ) , i ; for ( i = size - 1 ; i >= 0 ; i -- ) { int child = vec . elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } DTM dtm = m_dtmMgr . getDTM ( node ) ; if ( ! dtm . isNodeAfter ( node , child ) ) { break ; } } if ( i != - 2 ) { insertIndex = i + 1 ; vec . insertElementAt ( node , insertIndex ) ; } return insertIndex ; } } 	1	['37', '3', '1', '9', '68', '212', '1', '8', '34', '0.625', '711', '1', '2', '0.682692308', '0.171171171', '2', '9', '18.10810811', '12', '2.2973', '2']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_pt_BR extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "Mais de uma página de estilo definida no mesmo arquivo. " } , { ErrorMsg . TEMPLATE_REDEF_ERR , "O gabarito ''{0}'' já está definido nesta página de estilo." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "O gabarito ''{0}'' não está definido nesta página de estilo. " } , { ErrorMsg . VARIABLE_REDEF_ERR , "A variável ''{0}'' tem sua multiplicação definida no mesmo escopo. " } , { ErrorMsg . VARIABLE_UNDEF_ERR , "A variável ou parâmetro ''{0}'' não está definido. " } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "Impossível localizar a classe ''{0}''." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "Impossível localizar método externo ''{0}'' (deve ser público)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Impossível converter tipo de argumento/retorno na chamada do método para o método ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "Arquivo ou URI ''{0}'' não encontrado." } , { ErrorMsg . INVALID_URI_ERR , "URI inválido ''{0}''." } , { ErrorMsg . FILE_ACCESS_ERR , "Impossível abrir arquivo ou URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "Esperado elemento <xsl:stylesheet> ou <xsl:transform>." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Prefixo de namespace ''{0}'' não foi declarado." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Impossível resolver chamada para a função ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "O argumento para ''{0}'' deve ser uma cadeia literal." } , { ErrorMsg . XPATH_PARSER_ERR , "Erro ao analisar a expressão XPath ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "O atributo requerido ''{0}'' está ausente. " } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Caractere inválido ''{0}'' na expressão XPath. " } , { ErrorMsg . ILLEGAL_PI_ERR , "Atributo inválido ''{0}'' para instrução de processamento. " } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "Atributo ''{0}'' fora do elemento. " } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Atributo inválido ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Import/include circular. A página de estilo ''{0}'' já foi carregada. " } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Os fragmentos da árvore de resultados não podem ser ordenados (os elementos <xsl:sort> serão ignorados). Você deve ordenar os nós quando criar a árvore de resultados. " } , { ErrorMsg . SYMBOLS_REDEF_ERR , "A formatação decimal ''{0}'' já está definida. " } , { ErrorMsg . XSL_VERSION_ERR , "A versão de XSL ''{0}'' não é suportada por XSLTC." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Referência à variável/parâmetro circular em ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Operador desconhecido para expressão binária. " } , { ErrorMsg . ILLEGAL_ARG_ERR , "Argumentos inválidos para chamada de função. " } , { ErrorMsg . DOCUMENT_ARG_ERR , "O segundo argumento para a função document() deve ser um node-set." } , { ErrorMsg . MISSING_WHEN_ERR , "Pelo menos um elemento <xsl:when> é requerido em <xsl:choose>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "Apenas um elemento <xsl:otherwise> é permitido em <xsl:choose>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> somente pode ser utilizado em <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> somente pode ser utilizado em <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "Apenas os elementos <xsl:when> e <xsl:otherwise> são permitidos em <xsl:choose>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set> não possui o atributo 'name'." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Elemento filho inválido. " } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "Impossível chamar um elemento ''{0}''" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "Impossível chamar um atributo ''{0}''" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Dados de texto fora do elemento <xsl:stylesheet> de nível superior. " } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "Analisador JAXP não configurado corretamente " } , { ErrorMsg . INTERNAL_ERR , "Erro interno de XSLTC irrecuperável: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Elemento XSL não suportado ''{0}''." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "Extensão XSLTC não reconhecida ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "O documento de entrada não é uma página de estilo (o namespace XSL não está declarado no elemento root)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Não foi possível localizar o destino da página de estilo ''{0}''." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Não implementado: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "O documento de entrada não contém uma página de estilo XSL." } , { ErrorMsg . ELEMENT_PARSE_ERR , "Não foi possível analisar o elemento ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "O atributo use de <key> deve ser node, node-set, string ou number." } , { ErrorMsg . OUTPUT_VERSION_ERR , "A versão do documento XML de saída deve ser 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Operador desconhecido para expressão relacional " } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Tentando utilizar um conjunto de atributos não existente ''{0}''." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Impossível analisar gabarito de valor de atributo ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Tipo de dados desconhecido na assinatura para a classe ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "Impossível converter tipo de dados ''{0}'' em ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Este Gabarito não contém uma definição de classe translet válida. " } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Este Gabarito não contém uma classe com o nome ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Não foi possível carregar a classe translet ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Classe translet carregada, mas é impossível criar a instância de translet. " } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "Tentando definir ErrorListener para ''{0}'' como nulo " } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "Apenas StreamSource, SAXSource e DOMSource são suportados por XSLTC" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "O objeto Source passado para ''{0}'' não possui conteúdo. " } , { ErrorMsg . JAXP_COMPILE_ERR , "Não foi possível compilar a página de estilo " } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory não reconhece o atributo ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() deve ser chamado antes de startDocument()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformer não possui nenhum objeto translet encapsulado. " } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "Nenhuma rotina de tratamento de saída definida para o resultado de transformação. " } , { ErrorMsg . JAXP_NO_RESULT_ERR , "O objeto Result passado para ''{0}'' é inválido. " } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Tentando acessar a propriedade Transformer inválida ''{0}''." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Não foi possível criar o adaptador SAX2DOM: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() foi chamado sem systemId estar definido. " } , { ErrorMsg . COMPILE_STDIN_ERR , "A opção -i deve ser utilizada com a opção -o." } , { ErrorMsg . COMPILE_USAGE_STR , "RESUMO\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <saída>]\n      [-d <diretório>] [-j <arquivojar>] [-p <pacote>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <folha de estilo> | -i }\n\nOPÇÕES\n   -o <saída> atribui o nome <saída> ao translet\n gerado. Por padrão, o nome do translet\né obtido do nome <folha de estilo>. Esta opção\nserá ignorada se estiverem sendo compiladas várias páginas de estilo.\n   -d <diretório> especifica um diretório de destino para translet\n   -j <arquivo jar>   empacota classes translet em um arquivo jar do\nnome especificado como <arquivo jar>\n   -p <pacote>  especifica um prefixo de nome de pacote para todas as\nclasses translet geradas.\n   -n ativa a seqüência de gabaritos (melhor comportamento padrão\nna média).\n   -x ativa a saída de mensagem de depuração adicional\n  -s desativa a chamada de System.exit\n   -u interpreta argumentos <stylesheet> como URLs\n   -i força o compilador a ler a página de estilo de stdin\n   -v imprime a versão do compilador\n   -h imprime esta instrução de uso\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "RESUMO \n   java org.apache.xalan.xsltc.cmdline.Transform [-j <arquivo jar>]\n      [-x] [-s] [-n <iterações>] {-u <document_url> | <document>}\n      <classe> [<param1>=<valor1> ...]\n\n   utiliza a <classe> translet para transformar um documento XML \n  especificado como <documento>. A <classe> translet no\n  CLASSPATH do usuário ou no <arquivo jar> opcionalmente especificado.\nOPÇÕES\n   -j <arquivo jar> especifica um arquivo jar file a partir do qual será carregado o translet\n   -x ativa a saída de mensagem de depuração adicional\n   -s desativa a chamada de System.exit\n   -n <iterações> executa os horários de transformação <iterações> e\n exibe informações sobre criação de perfil\n   -u <url_de_documento> especifica o documento XML de entrada como uma URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> somente pode ser utilizado em <xsl:for-each> ou <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "A codificação de saída ''{0}'' não é suportada nesta JVM." } , { ErrorMsg . SYNTAX_ERR , "Erro de sintaxe em ''{0}''." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "Impossível localizar o construtor externo ''{0}''." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "O primeiro argumento para a função Java não estática ''{0}'' não é uma referência de objeto válida. " } , { ErrorMsg . TYPE_CHECK_ERR , "Erro ao verificar o tipo de expressão ''{0}''." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Erro ao verificar tipo de expressão em uma localização desconhecida. " } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "A opção da linha de comando ''{0}'' não é válida. " } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "A opção da linha de comando ''{0}'' não contém um argumento requerido. " } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "AVISO:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "AVISO:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "ERRO FATAL:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "ERRO FATAL:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "ERRO:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "ERRO:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Transformar utilizando translet ''{0}'' " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Transformar utilizando translet ''{0}'' de arquivo jar ''{1}''" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "Não foi possível criar uma instância da classe TransformerFactory ''{0}''." } , { ErrorMsg . COMPILER_ERROR_KEY , "Erros do compilador:" } , { ErrorMsg . COMPILER_WARNING_KEY , "Avisos do compilador:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Erros de translet:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_sk extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Chyba: Nie je možné mať vo výraze '{'" } , { ER_ILLEGAL_ATTRIBUTE , "{0} má neplatný atribút: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode je v xsl:apply-imports null!" } , { ER_CANNOT_ADD , "Nie je možné pridať {0} do {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode je null v handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "{0} musí mať atribút názvu." } , { ER_TEMPLATE_NOT_FOUND , "Nebolo možné nájsť vzor s názvom: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Nebolo možné rozlíšiť názov AVT v xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} vyžaduje atribút: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} musí mať atribút ''test''." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Nesprávna hodnota na atribúte úrovne: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "názov processing-instruction nemôže byť 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "názov inštrukcie spracovania musí byť platným NCName: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} musí mať porovnávací atribút, ak má režim." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} vyžaduje buď názov, alebo porovnávací atribút." } , { ER_CANT_RESOLVE_NSPREFIX , "Nie je možné rozlíšiť predponu názvového priestoru: {0}" } , { ER_ILLEGAL_VALUE , "xml:space má neplatnú hodnotu: {0}" } , { ER_NO_OWNERDOC , "Potomok uzla nemá dokument vlastníka!" } , { ER_ELEMTEMPLATEELEM_ERR , "Chyba ElemTemplateElement: {0}" } , { ER_NULL_CHILD , "Pokus o pridanie nulového potomka!" } , { ER_NEED_SELECT_ATTRIB , "{0} vyžaduje atribút výberu." } , { ER_NEED_TEST_ATTRIB , "xsl:when musí mať atribút 'test'." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param musí mať atribút 'name'." } , { ER_NO_CONTEXT_OWNERDOC , "kontext nemá dokument vlastníka!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Nebolo možné vytvoriť vzťah XML TransformerFactory: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: Proces bol neúspešný." } , { ER_NOT_SUCCESSFUL , "Xalan: bol neúspešný." } , { ER_ENCODING_NOT_SUPPORTED , "Kódovanie nie je podporované: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Nebolo možné vytvoriť TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key vyžaduje atribút 'name'!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key vyžaduje atribút 'match'!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key vyžaduje atribút 'use'!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} vyžaduje atribút ''elements''!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) Chýba ''prefix'' pre atribút {0}" } , { ER_BAD_STYLESHEET_URL , "URL štýlu dokumentu je nesprávna: {0}" } , { ER_FILE_NOT_FOUND , "Súbor štýlu dokumentu nebol nájdený: {0}" } , { ER_IOEXCEPTION , "V súbore štýlu dokumentu nastala vstupno-výstupná výnimka: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Nebolo možné nájsť atribút href pre {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} priamo, alebo nepriamo, obsahuje sám seba!" } , { ER_PROCESSINCLUDE_ERROR , "chyba StylesheetHandler.processInclude, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) Chýba ''lang'' pre atribút {0}" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) chybne umiestnený {0} element?? Chýba prvok kontajnera ''component''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Môže prevádzať výstup len do Element, DocumentFragment, Document, alebo PrintWriter." } , { ER_PROCESS_ERROR , "chyba StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "Chyba UnImplNode: {0}" } , { ER_NO_SELECT_EXPRESSION , "Chyba! Nenašiel sa výraz výberu xpath (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Nie je možné serializovať XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "Nebol zadaný vstup štýl dokumentu!" } , { ER_FAILED_PROCESS_STYLESHEET , "Zlyhalo spracovanie štýlu dokumentu!" } , { ER_COULDNT_PARSE_DOC , "Nebolo možné analyzovať dokument {0}!" } , { ER_COULDNT_FIND_FRAGMENT , "Nebolo možné nájsť fragment: {0}" } , { ER_NODE_NOT_ELEMENT , "Uzol, na ktorý ukazuje identifikátor fragmentu nebol elementom: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each musí mať buď porovnávací atribút, alebo atribút názvu" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "vzory musia mať buď porovnávacie atribúty, alebo atribúty názvov" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Žiadna kópia fragmentu dokumentu!" } , { ER_CANT_CREATE_ITEM , "Nie je možné vytvoriť položku vo výsledkovom strome: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space v zdrojovom XML má neplatnú hodnotu: {0}" } , { ER_NO_XSLKEY_DECLARATION , "Neexistuje žiadna deklarácia xsl:key pre {0}!" } , { ER_CANT_CREATE_URL , "Chyba! Nie je možné vytvoriť url pre: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions nie je podporované" } , { ER_PROCESSOR_ERROR , "Chyba XSLT TransformerFactory" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} nie je povolený vnútri štýlu dokumentu!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns už viac nie je podporovaný!  Použite namiesto toho xsl:output." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space už viac nie je podporovaný!  Použite namiesto toho xsl:strip-space alebo xsl:preserve-space." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result už viac nie je podporovaný!  Použite namiesto toho xsl:output." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} má neplatný atribút: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Neznámy element XSL: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort možno použiť len s xsl:apply-templates alebo xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when na nesprávnom mieste!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when nemá ako rodiča xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise na nesprávnom mieste!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise nemá ako rodiča xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} nie je povolený vnútri vzoru!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} prefix rozšíreného názvového priestoru {1} nie je známy" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Importy sa môžu vyskytnúť len ako prvé časti štýlu dokumentu!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} priamo, alebo nepriamo, importuje sám seba!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:space má neplatnú hodnotu: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet nebol úspešný!" } , { ER_SAX_EXCEPTION , "Výnimka SAX" } , { ER_XSLT_ERROR , "Chyba XSLT" } , { ER_CURRENCY_SIGN_ILLEGAL , "znak meny nie je povolený v reťazci formátu vzoru" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Funkcia dokumentu nie je podporovaná v štýle dokumentu DOM!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Nie je možné určiť prefix bezprefixového rozkladača!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Rozšírenie presmerovania: Nedal sa získať názov súboru - súbor alebo atribút výberu musí vrátiť platný reťazec." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Nie je možné vytvoriť FormatterListener v rozšírení Redirect!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Predpona v exclude-result-prefixes je neplatná: {0}" } , { ER_MISSING_NS_URI , "Chýbajúci názvový priestor URI pre zadaný prefix" } , { ER_MISSING_ARG_FOR_OPTION , "Chýbajúci argument pre voľbu: {0}" } , { ER_INVALID_OPTION , "Neplatná voľba. {0}" } , { ER_MALFORMED_FORMAT_STRING , "Chybne vytvorený reťazec formátu: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet si vyžaduje atribút 'version'!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Atribút: {0} má neplatnú hodnotu: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose vyžaduje xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports nie je povolený v xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Nemôže použiť DTMLiaison pre výstupný uzol DOM... namiesto neho odošlite org.apache.xpath.DOM2Helper!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Nemôže použiť DTMLiaison pre vstupný uzol DOM... namiesto neho odošlite org.apache.xpath.DOM2Helper!" } , { ER_CALL_TO_EXT_FAILED , "Volanie elementu rozšírenia zlyhalo: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Predpona sa musí rozlíšiť do názvového priestoru: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Bolo zistené neplatné nahradenie UTF-16: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} použil sám seba, čo spôsobí nekonečný cyklus." } , { ER_CANNOT_MIX_XERCESDOM , "Nie je možné miešať vstup iný, než Xerces-DOM s výstupom Xerces-DOM!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "V ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Našiel sa viac než jeden vzor s názvom: {0}" } , { ER_INVALID_KEY_CALL , "Neplatné volanie funkcie: rekurzívne volanie kľúča() nie je povolené" } , { ER_REFERENCING_ITSELF , "Premenná {0} sa priamo, alebo nepriamo, odkazuje sama na seba!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Vstupný uzol nemôže byť pre DOMSource pre newTemplates null!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Súbor triedy nebol pre voľbu {0} nájdený" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Požadovaný element sa nenašiel: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream nemôže byť null" } , { ER_URI_CANNOT_BE_NULL , "URI nemôže byť null" } , { ER_FILE_CANNOT_BE_NULL , "Súbor nemôže byť null" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource nemôže byť null" } , { ER_CANNOT_INIT_BSFMGR , "Nebolo možné inicializovať Správcu BSF" } , { ER_CANNOT_CMPL_EXTENSN , "Nebolo možné skompilovať príponu" } , { ER_CANNOT_CREATE_EXTENSN , "Nebolo možné vytvoriť rozšírenie: {0} z dôvodu: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "Volanie metódy metódou inštancie {0} vyžaduje ako prvý argument inštanciu objektu" } , { ER_INVALID_ELEMENT_NAME , "Bol zadaný neplatný názov súčasti {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Metóda názvu súčasti musí byť statická {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Rozšírenie funkcie {0} : {1} je neznáme" } , { ER_MORE_MATCH_CONSTRUCTOR , "Bola nájdená viac než jedna najlepšia zhoda s konštruktorom pre {0}" } , { ER_MORE_MATCH_METHOD , "Bola nájdená viac než jedna najlepšia zhoda pre metódu {0}" } , { ER_MORE_MATCH_ELEMENT , "Bola nájdená viac než jedna najlepšia zhoda pre metódu súčasti {0}" } , { ER_INVALID_CONTEXT_PASSED , "Bolo odoslaný neplatný kontext na zhodnotenie {0}" } , { ER_POOL_EXISTS , "Oblasť už existuje" } , { ER_NO_DRIVER_NAME , "Nebol zadaný žiaden názov ovládača" } , { ER_NO_URL , "Nebola zadaná žiadna URL" } , { ER_POOL_SIZE_LESSTHAN_ONE , "Veľkosť oblasti je menšia než jeden!" } , { ER_INVALID_DRIVER , "Bol zadaný neplatný názov ovládača!" } , { ER_NO_STYLESHEETROOT , "Nebol nájdený koreň štýlu dokumentu!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Neplatná hodnota pre xml:space" } , { ER_PROCESSFROMNODE_FAILED , "zlyhal processFromNode" } , { ER_RESOURCE_COULD_NOT_LOAD , "Prostriedok [ {0} ] sa nedal načítať: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Veľkosť vyrovnávacej pamäte <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Neznáma chyba počas volania prípony" } , { ER_NO_NAMESPACE_DECL , "Prefix {0} nemá zodpovedajúcu deklaráciu názvového priestoru" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Obsah elementu nie je povolený pre lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Ukončenie riadené štýlom dokumentu" } , { ER_ONE_OR_TWO , "1 alebo 2" } , { ER_TWO_OR_THREE , "2 alebo 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Nebolo možné zaviesť {0} (check CLASSPATH), teraz sú požité len predvolené štandardy" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Nie je možné inicializovať predvolené vzory" } , { ER_RESULT_NULL , "Výsledok by nemal byť null" } , { ER_RESULT_COULD_NOT_BE_SET , "Výsledkom nemôže byť množina" } , { ER_NO_OUTPUT_SPECIFIED , "Nie je zadaný žiaden výstup" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Výsledok typu {0} sa nedá transformovať" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Zdroj typu {0} sa nedá transformovať" } , { ER_NULL_CONTENT_HANDLER , "Nulový manipulačný program obsahu" } , { ER_NULL_ERROR_HANDLER , "Nulový chybový manipulačný program" } , { ER_CANNOT_CALL_PARSE , "nemôže byť volané analyzovanie, ak nebol nastavený ContentHandler" } , { ER_NO_PARENT_FOR_FILTER , "Žiaden rodič pre filter" } , { ER_NO_STYLESHEET_IN_MEDIA , "Nenašiel sa žiadny stylesheet v: {0}, médium= {1}" } , { ER_NO_STYLESHEET_PI , "Nenašiel sa žiadny xml-stylesheet PI v: {0}" } , { ER_NOT_SUPPORTED , "Nie je podporované: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Hodnota vlastnosti {0} by mala byť boolovská inštancia" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "Nie je možné dosiahnuť externý skript na {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "Prostriedok [ {0} ] nemohol byť nájdený.\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Výstupné vlastníctvo nebolo rozoznané: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Zlyhalo vytváranie inštancie ElemLiteralResult" } , { ER_VALUE_SHOULD_BE_NUMBER , "Hodnota pre {0} by mala obsahovať analyzovateľné číslo" } , { ER_VALUE_SHOULD_EQUAL , "Hodnota {0} by sa mala rovnať áno alebo nie" } , { ER_FAILED_CALLING_METHOD , "Zlyhalo volanie metódy {0}" } , { ER_FAILED_CREATING_ELEMTMPL , "Zlyhalo vytváranie inštancie ElemTemplateElement" } , { ER_CHARS_NOT_ALLOWED , "V tomto bode dokumentu nie sú znaky povolené" } , { ER_ATTR_NOT_ALLOWED , "Atribút \"{0}\" nie je povolený na súčasti {1}!" } , { ER_BAD_VALUE , "{0} zlá hodnota {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "Hodnota atribútu {0} nebola nájdená " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "Hodnota atribútu {0} nebola rozpoznaná " } , { ER_NULL_URI_NAMESPACE , "Pokus o vytvorenie prefixu názvového priestoru s nulovým URI" } , { ER_NUMBER_TOO_BIG , "Pokus o formátovanie čísla väčšieho, než je najdlhší dlhý celočíselný typ" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Nie je možné nájsť triedu ovládača SAX1 {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "Trieda ovládača SAX1 {0} bola nájdená, ale nemôže byť zavedená" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "Trieda ovládača SAX1 {0} bola zavedená, ale nemôže byť doložená príkladom" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "Trieda ovládača SAX1 {0} neimplementuje org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Systémová vlastnosť org.xml.sax.parser nie je zadaná" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Argument syntaktického analyzátora nesmie byť null" } , { ER_FEATURE , "Vlastnosť: {0}" } , { ER_PROPERTY , "Vlastníctvo: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Rozkladač nulových entít" } , { ER_NULL_DTD_HANDLER , "Nulový manipulačný program DTD" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Nie je zadaný žiaden názov ovládača!" } , { ER_NO_URL_SPECIFIED , "Nie je zadaná žiadna URL!" } , { ER_POOLSIZE_LESS_THAN_ONE , "Veľkosť oblasti je menšia než 1!" } , { ER_INVALID_DRIVER_NAME , "Je zadaný neplatný názov ovládača!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Programátorská chyba! expr nemá žiadneho rodiča ElemTemplateElement!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Tvrdenie programátora v RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} nie je na tejto pozícii predlohy so štýlmi povolené!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Text bez medzier nie je povolený na tejto pozícii predlohy so štýlmi!" } , { INVALID_TCHAR , "Neplatná hodnota: {1} používaný pre atribút CHAR: {0}.  Atribút typu CHAR musí byť len 1 znak!" } , { INVALID_QNAME , "Neplatná hodnota: {1} používaná pre atribút QNAME: {0}" } , { INVALID_ENUM , "Neplatná hodnota: {1} používaná pre atribút ENUM: {0}.  Platné hodnoty sú: {2}." } , { INVALID_NMTOKEN , "Neplatná hodnota: {1} používaná pre atribút NMTOKEN:{0} " } , { INVALID_NCNAME , "Neplatná hodnota: {1} používaná pre atribút NCNAME: {0} " } , { INVALID_BOOLEAN , "Neplatná hodnota: {1} používaná pre boolovský atribút: {0} " } , { INVALID_NUMBER , "Neplatná hodnota: {1} používaná pre atribút čísla: {0} " } , { ER_ARG_LITERAL , "Argument pre {0} v zhodnom vzore musí byť literálom." } , { ER_DUPLICATE_GLOBAL_VAR , "Duplicitná deklarácia globálnej premennej." } , { ER_DUPLICATE_VAR , "Duplicitná deklarácia premennej." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template musí mať názov alebo atribút zhody (alebo oboje)" } , { ER_INVALID_PREFIX , "Predpona v exclude-result-prefixes je neplatná: {0}" } , { ER_NO_ATTRIB_SET , "pomenovaná sada atribútov {0} neexistuje" } , { WG_FOUND_CURLYBRACE , "Bol nájdený znak '}', ale nie otvorený žiaden vzor atribútu!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Upozornenie: atribút počtu sa nezhoduje s predchodcom v xsl:number! Cieľ = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Stará syntax: Názov atribútu 'expr' bol zmenený na 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan zatiaľ nespracováva názov umiestnenia vo funkcii format-number." } , { WG_LOCALE_NOT_FOUND , "Upozornenie: Nebolo možné nájsť umiestnenie pre xml:lang={0}" } , { WG_CANNOT_MAKE_URL_FROM , "Nie je možné vytvoriť URL z: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Nie je možné zaviesť požadovaný doc: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Nebolo možné nájsť porovnávač pre <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Stará syntax: inštrukcia funkcií by mala používať url {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "Kódovanie nie je podporované: {0}, používa UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "Kódovanie nie je podporované: {0}, používa Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Boli zistené konflikty špecifickosti: {0}, naposledy nájdená v štýle dokumentu bude použitá." } , { WG_PARSING_AND_PREPARING , "========= Analýza a príprava {0} ==========" } , { WG_ATTR_TEMPLATE , "Attr vzor, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Konflikt zhodnosti medzi xsl:strip-space a xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan zatiaľ nespracúva atribút {0}!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Pre desiatkový formát sa nenašla žiadna deklarácia: {0}" } , { WG_OLD_XSLT_NS , "Chýbajúci, alebo nesprávny názvový priestor XSLT. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Povolená je len jedna štandardná deklarácia xsl:decimal-format." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "Názvy xsl:decimal-format musia byť jedinečné. Názov \"{0}\" bol zopakovaný." } , { WG_ILLEGAL_ATTRIBUTE , "{0} má neplatný atribút: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Nebolo možné rozlíšiť predponu názvového priestoru: {0}. Uzol bude ignorovaný." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet si vyžaduje atribút 'version'!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Neplatný názov atribútu: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Neplatná hodnota používaná pre atribút {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "Výsledná množina uzlov z druhého argumentu funkcie dokumentu je prázdna. Vráťte prázdnu množinu uzlov." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Hodnota atribútu 'name' názvu xsl:processing-instruction nesmie byť 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Hodnota atribútu 'name' xsl:processing-instruction musí byť platným NCName: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Nie je možné pridať atribút {0} po uzloch potomka alebo pred vytvorením elementu.  Atribút bude ignorovaný." } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "Parameter na createMessage bol mimo ohraničenia" } , { "FORMAT_FAILED" , "Výnimka počas volania messageFormat" } , { "version" , ">>>>>>> Verzia Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "áno" } , { "line" , "Riadok #" } , { "column" , "Stĺpec #" } , { "xsldone" , "XSLProcessor: vykonané" } , { "xslProc_option" , "Voľby triedy procesu príkazového riadka Xalan-J:" } , { "xslProc_option" , "Voľby triedy Process príkazového riadka Xalan-J:" } , { "xslProc_invalid_xsltc_option" , "Voľba {0} nie je podporovaná v režime XSLTC." } , { "xslProc_invalid_xalan_option" , "Voľbu {0} možno použiť len spolu s -XSLTC." } , { "xslProc_no_input" , "Chyba: nie je uvedený žiadny štýl dokumentu, ani vstupný xml. Spustite tento príkaz bez akejkoľvek voľby pre inštrukcie použitia." } , { "xslProc_common_options" , "-Bežné voľby-" } , { "xslProc_xalan_options" , "-Voľby pre Xalan-" } , { "xslProc_xsltc_options" , "-Voľby pre XSLTC-" } , { "xslProc_return_to_continue" , "(pokračujte stlačením klávesu <return>)" } , { "optionXSLTC" , "   [-XSLTC (použite XSLTC na transformáciu)]" } , { "optionIN" , "   [-IN inputXMLURL]" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER plne kvalifikovaný názov triedy sprostredkovateľa syntaktického analyzátora]" } , { "optionE" , "   [-E (Nerozvinie odkazy na entity)]" } , { "optionV" , "   [-E (Nerozvinie odkazy na entity)]" } , { "optionQC" , "   [-QC (Varovania pri konfliktoch Quiet Pattern)]" } , { "optionQ" , "   [-Q  (Tichý režim)]" } , { "optionLF" , "   [-LF (Znaky pre posun riadka použiť len vo výstupe {default is CR/LF})]" } , { "optionCR" , "   [-CR (Znaky návratu vozíka použiť len vo výstupe {default is CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Ktoré znaky majú mať zmenený význam {default is <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Riadi počet medzier odsadenia {default is 0})]" } , { "optionTT" , "   [-TT (Sledovanie, ako sú volané vzory.)]" } , { "optionTG" , "   [-TG (Sledovanie udalostí každej generácie.)]" } , { "optionTS" , "   [-TS (Sledovanie udalostí každého výberu.)]" } , { "optionTTC" , "   [-TTC (Sledovanie ako sú vytváraní potomkovia vzorov.)]" } , { "optionTCLASS" , "   [-TCLASS (Trieda TraceListener pre prípony sledovania.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Určuje, či má dochádzať k overovaniu.  Overovanie je štandardne vypnuté.)]" } , { "optionEDUMP" , "   [-EDUMP {optional filename} (Vytvoriť výpis zásobníka pri chybe.)]" } , { "optionXML" , "   [-XML (Použije formátor XML a pridá hlavičku XML.)]" } , { "optionTEXT" , "   [-TEXT (Jednoduchý textový formátor.)]" } , { "optionHTML" , "   [-HTML (Použije formátor HTML.)]" } , { "optionPARAM" , "   [-PARAM názov (nastaví parameter štýlu dokumentu)]" } , { "noParsermsg1" , "Proces XSL nebol úspešný." } , { "noParsermsg2" , "** Nebolo možné nájsť syntaktický analyzátor **" } , { "noParsermsg3" , "Skontroluje, prosím, svoju classpath." } , { "noParsermsg4" , "Ak nemáte Syntaktický analyzátor XML pre jazyk Java od firmy IBM, môžete si ho stiahnuť z" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER plný názov triedy (URIResolver bude použitý na určovanie URI)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER plný názov triedy (EntityResolver bude použitý na určenie entít)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER plný názov triedy (ContentHandler bude použitý na serializáciu výstupu)]" } , { "optionLINENUMBERS" , "   [-L použije čísla riadkov pre zdrojový dokument]" } , { "optionMEDIA" , "   [-MEDIA mediaType (použiť atribút média na nájdenie štýlu hárka, priradeného k dokumentu.)]" } , { "optionFLAVOR" , "   [-FLAVOR flavorName (Explicitne použiť s2s=SAX alebo d2d=DOM na vykonanie transformácie.)] " } , { "optionDIAG" , "   [-DIAG (Vytlačiť celkový čas transformácie v milisekundách.)]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL (žiadosť o inkrementálnu konštrukciu DTM nastavením http://xml.apache.org/xalan/features/incremental true.)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE (žiadosť o vypnutie optimalizácie štýlu hárkov nastavením http://xml.apache.org/xalan/features/optimize false.)]" } , { "optionRL" , "   [-RL recursionlimit (nastaviť číselný limit pre hĺbku rekurzie štýlov hárkov.)]" } , { "optionXO" , "   [-XO [transletName] (priraďuje názov ku generovanému transletu)]" } , { "optionXD" , "   [-XD destinationDirectory (uvádza cieľový adresár pre translet)]" } , { "optionXJ" , "   [-XJ jarfile (pakuje triedy transletu do súboru jar s názvom <jarfile>)]" } , { "optionXP" , "   [-XP package (uvádza predponu názvu balíka pre všetky generované triedy transletu)]" } , { "optionXN" , "   [-XN (povoľuje zoradenie vzorov do riadka)]" } , { "optionXX" , "   [-XX (zapína ďalší výstup správ ladenia)]" } , { "optionXT" , "   [-XT (ak je to možné, použite translet na transformáciu)]" } , { "diagTiming" , " --------- Transformácia z {0} cez {1} trvala {2} ms" } , { "recursionTooDeep" , "Vnorenie vzoru je príliš hlboké. vnorenie = {0}, vzor {1} {2}" } , { "nameIs" , "názov je" } , { "matchPatternIs" , "vzor zhody je" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Chyba: " ; public static final String WARNING_HEADER = "Upozornenie: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_no extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Intern programfeil i ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Programfeil under utføing av <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Ugyldig konvertering av ''{0}'' fra ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "Ekstern funksjon ''{0}'' er ikke støttet av XSLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Ugyldig argument i EQUALITY uttrykk." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Ugyldig argument ''{0}'' i kall til ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Forsøk på å formattere nummer ''{0}'' med ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Kan ikke klone iterator ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Iterator for axis ''{0}'' er ikke stèttet." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Iterator for typet axis ''{0}'' er ikke stèttet." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Attributt ''{0}'' utenfor element." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Navnedeklarasjon ''{0}''=''{1}'' utenfor element." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "Prefix ''{0}'' er ikke deklartert." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "Forsøk på å instansiere DOMAdapter med feil type DOM." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '195', '1', '0', '0.974358974', '1', '0', '0', '63.66666667', '1', '0.3333', '1']
package org . apache . xml . utils . res ; public class XResources_el extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "el" } , { "help_language" , "el" } , { "language" , "el" } , { "alphabet" , new char [ ] { 0x03b1 , 0x03b2 , 0x03b3 , 0x03b4 , 0x03b5 , 0x03b6 , 0x03b7 , 0x03b8 , 0x03b9 , 0x03ba , 0x03bb , 0x03bc , 0x03bd , 0x03be , 0x03bf , 0x03c0 , 0x03c1 , 0x03c2 , 0x03c3 , 0x03c4 , 0x03c5 , 0x03c6 , 0x03c7 , 0x03c8 , 0x03c9 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "precedes" } , { "numberGroups" , new int [ ] { 100 , 10 , 1 } } , { "multiplier" , new long [ ] { 1000 } } , { "multiplierChar" , new char [ ] { 0x03d9 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x03b1 , 0x03b2 , 0x03b3 , 0x03b4 , 0x03b5 , 0x03db , 0x03b6 , 0x03b7 , 0x03b8 } } , { "tens" , new char [ ] { 0x03b9 , 0x03ba , 0x03bb , 0x03bc , 0x03bd , 0x03be , 0x03bf , 0x03c0 , 0x03df } } , { "hundreds" , new char [ ] { 0x03c1 , 0x03c2 , 0x03c4 , 0x03c5 , 0x03c6 , 0x03c7 , 0x03c8 , 0x03c9 , 0x03e1 } } , { "tables" , new String [ ] { "hundreds" , "tens" , "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '575', '0', '0', '0.976190476', '1', '0', '0', '190.3333333', '1', '0.3333', '1']
package org . apache . xalan . templates ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemCallTemplate extends ElemForEach { public QName m_templateName = null ; public void setName ( QName name ) { m_templateName = name ; } public QName getName ( ) { return m_templateName ; } private ElemTemplate m_template = null ; public int getXSLToken ( ) { return Constants . ELEMNAME_CALLTEMPLATE ; } public String getNodeName ( ) { return Constants . ELEMNAME_CALLTEMPLATE_STRING ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; int length = getParamElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { ElemWithParam ewp = getParamElem ( i ) ; ewp . compose ( sroot ) ; } if ( ( null != m_templateName ) && ( null == m_template ) ) { m_template = this . getStylesheetRoot ( ) . getTemplateComposed ( m_templateName ) ; if ( null == m_template ) { String themsg = XSLMessages . createMessage ( XSLTErrorResources . ER_ELEMTEMPLATEELEM_ERR , new Object [ ] { m_templateName } ) ; throw new TransformerException ( themsg , this ) ; } length = getParamElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { ElemWithParam ewp = getParamElem ( i ) ; ewp . m_index = - 1 ; int etePos = 0 ; for ( ElemTemplateElement ete = m_template . getFirstChildElem ( ) ; null != ete ; ete = ete . getNextSiblingElem ( ) ) { if ( ete . getXSLToken ( ) == Constants . ELEMNAME_PARAMVARIABLE ) { ElemParam ep = ( ElemParam ) ete ; if ( ep . getName ( ) . equals ( ewp . getName ( ) ) ) { ewp . m_index = etePos ; } } else break ; etePos ++ ; } } } } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { int length = getParamElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { ElemWithParam ewp = getParamElem ( i ) ; ewp . endCompose ( sroot ) ; } super . endCompose ( sroot ) ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; if ( null != m_template ) { XPathContext xctxt = transformer . getXPathContext ( ) ; VariableStack vars = xctxt . getVarStack ( ) ; int thisframe = vars . getStackFrame ( ) ; int nextFrame = vars . link ( m_template . m_frameSize ) ; if ( m_template . m_inArgsSize > 0 ) { vars . clearLocalSlots ( 0 , m_template . m_inArgsSize ) ; if ( null != m_paramElems ) { int currentNode = xctxt . getCurrentNode ( ) ; vars . setStackFrame ( thisframe ) ; int size = m_paramElems . length ; for ( int i = 0 ; i < size ; i ++ ) { ElemWithParam ewp = m_paramElems [ i ] ; if ( ewp . m_index >= 0 ) { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( ewp ) ; XObject obj = ewp . getValue ( transformer , currentNode ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( ewp ) ; vars . setLocalVariable ( ewp . m_index , obj , nextFrame ) ; } } vars . setStackFrame ( nextFrame ) ; } } SourceLocator savedLocator = xctxt . getSAXLocator ( ) ; try { xctxt . setSAXLocator ( m_template ) ; transformer . pushElemTemplateElement ( m_template ) ; m_template . execute ( transformer ) ; } finally { transformer . popElemTemplateElement ( ) ; xctxt . setSAXLocator ( savedLocator ) ; vars . unlink ( thisframe ) ; } } else { transformer . getMsgMgr ( ) . error ( this , XSLTErrorResources . ER_TEMPLATE_NOT_FOUND , new Object [ ] { m_templateName } ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } protected ElemWithParam [ ] m_paramElems = null ; public int getParamElemCount ( ) { return ( m_paramElems == null ) ? 0 : m_paramElems . length ; } public ElemWithParam getParamElem ( int i ) { return m_paramElems [ i ] ; } public void setParamElem ( ElemWithParam ParamElem ) { if ( null == m_paramElems ) { m_paramElems = new ElemWithParam [ 1 ] ; m_paramElems [ 0 ] = ParamElem ; } else { int length = m_paramElems . length ; ElemWithParam [ ] ewp = new ElemWithParam [ length + 1 ] ; System . arraycopy ( m_paramElems , 0 , ewp , 0 , length ) ; m_paramElems = ewp ; ewp [ length ] = ParamElem ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; if ( Constants . ELEMNAME_WITHPARAM == type ) { setParamElem ( ( ElemWithParam ) newChild ) ; } return super . appendChild ( newChild ) ; } public void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['13', '4', '1', '17', '51', '40', '2', '15', '13', '0.638888889', '379', '0.666666667', '3', '0.946902655', '0.188034188', '4', '11', '27.92307692', '2', '1.1538', '2']
package org . apache . xml . utils . res ; public class XResources_fr extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "fr" } , { "help_language" , "fr" } , { "language" , "fr" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '314', '0', '0', '0.976190476', '1', '0', '0', '103.3333333', '1', '0.3333', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . text . MessageFormat ; import java . util . Locale ; import java . util . ResourceBundle ; import org . apache . xalan . xsltc . compiler . Stylesheet ; import org . apache . xalan . xsltc . compiler . SyntaxTreeNode ; public final class ErrorMsg { private String _code ; private int _line ; private String _message = null ; private String _url = null ; Object [ ] _params = null ; public static final String MULTIPLE_STYLESHEET_ERR = "MULTIPLE_STYLESHEET_ERR" ; public static final String TEMPLATE_REDEF_ERR = "TEMPLATE_REDEF_ERR" ; public static final String TEMPLATE_UNDEF_ERR = "TEMPLATE_UNDEF_ERR" ; public static final String VARIABLE_REDEF_ERR = "VARIABLE_REDEF_ERR" ; public static final String VARIABLE_UNDEF_ERR = "VARIABLE_UNDEF_ERR" ; public static final String CLASS_NOT_FOUND_ERR = "CLASS_NOT_FOUND_ERR" ; public static final String METHOD_NOT_FOUND_ERR = "METHOD_NOT_FOUND_ERR" ; public static final String ARGUMENT_CONVERSION_ERR = "ARGUMENT_CONVERSION_ERR" ; public static final String FILE_NOT_FOUND_ERR = "FILE_NOT_FOUND_ERR" ; public static final String INVALID_URI_ERR = "INVALID_URI_ERR" ; public static final String FILE_ACCESS_ERR = "FILE_ACCESS_ERR" ; public static final String MISSING_ROOT_ERR = "MISSING_ROOT_ERR" ; public static final String NAMESPACE_UNDEF_ERR = "NAMESPACE_UNDEF_ERR" ; public static final String FUNCTION_RESOLVE_ERR = "FUNCTION_RESOLVE_ERR" ; public static final String NEED_LITERAL_ERR = "NEED_LITERAL_ERR" ; public static final String XPATH_PARSER_ERR = "XPATH_PARSER_ERR" ; public static final String REQUIRED_ATTR_ERR = "REQUIRED_ATTR_ERR" ; public static final String ILLEGAL_CHAR_ERR = "ILLEGAL_CHAR_ERR" ; public static final String ILLEGAL_PI_ERR = "ILLEGAL_PI_ERR" ; public static final String STRAY_ATTRIBUTE_ERR = "STRAY_ATTRIBUTE_ERR" ; public static final String ILLEGAL_ATTRIBUTE_ERR = "ILLEGAL_ATTRIBUTE_ERR" ; public static final String CIRCULAR_INCLUDE_ERR = "CIRCULAR_INCLUDE_ERR" ; public static final String RESULT_TREE_SORT_ERR = "RESULT_TREE_SORT_ERR" ; public static final String SYMBOLS_REDEF_ERR = "SYMBOLS_REDEF_ERR" ; public static final String XSL_VERSION_ERR = "XSL_VERSION_ERR" ; public static final String CIRCULAR_VARIABLE_ERR = "CIRCULAR_VARIABLE_ERR" ; public static final String ILLEGAL_BINARY_OP_ERR = "ILLEGAL_BINARY_OP_ERR" ; public static final String ILLEGAL_ARG_ERR = "ILLEGAL_ARG_ERR" ; public static final String DOCUMENT_ARG_ERR = "DOCUMENT_ARG_ERR" ; public static final String MISSING_WHEN_ERR = "MISSING_WHEN_ERR" ; public static final String MULTIPLE_OTHERWISE_ERR = "MULTIPLE_OTHERWISE_ERR" ; public static final String STRAY_OTHERWISE_ERR = "STRAY_OTHERWISE_ERR" ; public static final String STRAY_WHEN_ERR = "STRAY_WHEN_ERR" ; public static final String WHEN_ELEMENT_ERR = "WHEN_ELEMENT_ERR" ; public static final String UNNAMED_ATTRIBSET_ERR = "UNNAMED_ATTRIBSET_ERR" ; public static final String ILLEGAL_CHILD_ERR = "ILLEGAL_CHILD_ERR" ; public static final String ILLEGAL_ELEM_NAME_ERR = "ILLEGAL_ELEM_NAME_ERR" ; public static final String ILLEGAL_ATTR_NAME_ERR = "ILLEGAL_ATTR_NAME_ERR" ; public static final String ILLEGAL_TEXT_NODE_ERR = "ILLEGAL_TEXT_NODE_ERR" ; public static final String SAX_PARSER_CONFIG_ERR = "SAX_PARSER_CONFIG_ERR" ; public static final String INTERNAL_ERR = "INTERNAL_ERR" ; public static final String UNSUPPORTED_XSL_ERR = "UNSUPPORTED_XSL_ERR" ; public static final String UNSUPPORTED_EXT_ERR = "UNSUPPORTED_EXT_ERR" ; public static final String MISSING_XSLT_URI_ERR = "MISSING_XSLT_URI_ERR" ; public static final String MISSING_XSLT_TARGET_ERR = "MISSING_XSLT_TARGET_ERR" ; public static final String NOT_IMPLEMENTED_ERR = "NOT_IMPLEMENTED_ERR" ; public static final String NOT_STYLESHEET_ERR = "NOT_STYLESHEET_ERR" ; public static final String ELEMENT_PARSE_ERR = "ELEMENT_PARSE_ERR" ; public static final String KEY_USE_ATTR_ERR = "KEY_USE_ATTR_ERR" ; public static final String OUTPUT_VERSION_ERR = "OUTPUT_VERSION_ERR" ; public static final String ILLEGAL_RELAT_OP_ERR = "ILLEGAL_RELAT_OP_ERR" ; public static final String ATTRIBSET_UNDEF_ERR = "ATTRIBSET_UNDEF_ERR" ; public static final String ATTR_VAL_TEMPLATE_ERR = "ATTR_VAL_TEMPLATE_ERR" ; public static final String UNKNOWN_SIG_TYPE_ERR = "UNKNOWN_SIG_TYPE_ERR" ; public static final String DATA_CONVERSION_ERR = "DATA_CONVERSION_ERR" ; public static final String NO_TRANSLET_CLASS_ERR = "NO_TRANSLET_CLASS_ERR" ; public static final String NO_MAIN_TRANSLET_ERR = "NO_MAIN_TRANSLET_ERR" ; public static final String TRANSLET_CLASS_ERR = "TRANSLET_CLASS_ERR" ; public static final String TRANSLET_OBJECT_ERR = "TRANSLET_OBJECT_ERR" ; public static final String ERROR_LISTENER_NULL_ERR = "ERROR_LISTENER_NULL_ERR" ; public static final String JAXP_UNKNOWN_SOURCE_ERR = "JAXP_UNKNOWN_SOURCE_ERR" ; public static final String JAXP_NO_SOURCE_ERR = "JAXP_NO_SOURCE_ERR" ; public static final String JAXP_COMPILE_ERR = "JAXP_COMPILE_ERR" ; public static final String JAXP_INVALID_ATTR_ERR = "JAXP_INVALID_ATTR_ERR" ; public static final String JAXP_SET_RESULT_ERR = "JAXP_SET_RESULT_ERR" ; public static final String JAXP_NO_TRANSLET_ERR = "JAXP_NO_TRANSLET_ERR" ; public static final String JAXP_NO_HANDLER_ERR = "JAXP_NO_HANDLER_ERR" ; public static final String JAXP_NO_RESULT_ERR = "JAXP_NO_RESULT_ERR" ; public static final String JAXP_UNKNOWN_PROP_ERR = "JAXP_UNKNOWN_PROP_ERR" ; public static final String SAX2DOM_ADAPTER_ERR = "SAX2DOM_ADAPTER_ERR" ; public static final String XSLTC_SOURCE_ERR = "XSLTC_SOURCE_ERR" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String JAXP_INVALID_SET_PARAM_VALUE = "JAXP_INVALID_SET_PARAM_VALUE" ; public static final String COMPILE_STDIN_ERR = "COMPILE_STDIN_ERR" ; public static final String COMPILE_USAGE_STR = "COMPILE_USAGE_STR" ; public static final String TRANSFORM_USAGE_STR = "TRANSFORM_USAGE_STR" ; public static final String STRAY_SORT_ERR = "STRAY_SORT_ERR" ; public static final String UNSUPPORTED_ENCODING = "UNSUPPORTED_ENCODING" ; public static final String SYNTAX_ERR = "SYNTAX_ERR" ; public static final String CONSTRUCTOR_NOT_FOUND = "CONSTRUCTOR_NOT_FOUND" ; public static final String NO_JAVA_FUNCT_THIS_REF = "NO_JAVA_FUNCT_THIS_REF" ; public static final String TYPE_CHECK_ERR = "TYPE_CHECK_ERR" ; public static final String TYPE_CHECK_UNK_LOC_ERR = "TYPE_CHECK_UNK_LOC_ERR" ; public static final String ILLEGAL_CMDLINE_OPTION_ERR = "ILLEGAL_CMDLINE_OPTION_ERR" ; public static final String CMDLINE_OPT_MISSING_ARG_ERR = "CMDLINE_OPT_MISSING_ARG_ERR" ; public static final String WARNING_PLUS_WRAPPED_MSG = "WARNING_PLUS_WRAPPED_MSG" ; public static final String WARNING_MSG = "WARNING_MSG" ; public static final String FATAL_ERR_PLUS_WRAPPED_MSG = "FATAL_ERR_PLUS_WRAPPED_MSG" ; public static final String FATAL_ERR_MSG = "FATAL_ERR_MSG" ; public static final String ERROR_PLUS_WRAPPED_MSG = "ERROR_PLUS_WRAPPED_MSG" ; public static final String ERROR_MSG = "ERROR_MSG" ; public static final String TRANSFORM_WITH_TRANSLET_STR = "TRANSFORM_WITH_TRANSLET_STR" ; public static final String TRANSFORM_WITH_JAR_STR = "TRANSFORM_WITH_JAR_STR" ; public static final String COULD_NOT_CREATE_TRANS_FACT = "COULD_NOT_CREATE_TRANS_FACT" ; public static final String TRANSLET_NAME_JAVA_CONFLICT = "TRANSLET_NAME_JAVA_CONFLICT" ; public static final String INVALID_QNAME_ERR = "INVALID_QNAME_ERR" ; public static final String INVALID_NCNAME_ERR = "INVALID_NCNAME_ERR" ; public static final String INVALID_METHOD_IN_OUTPUT = "INVALID_METHOD_IN_OUTPUT" ; private static ResourceBundle _bundle ; public final static String ERROR_MESSAGES_KEY = "ERROR_MESSAGES_KEY" ; public final static String COMPILER_ERROR_KEY = "COMPILER_ERROR_KEY" ; public final static String COMPILER_WARNING_KEY = "COMPILER_WARNING_KEY" ; public final static String RUNTIME_ERROR_KEY = "RUNTIME_ERROR_KEY" ; static { _bundle = ResourceBundle . getBundle ( "org.apache.xalan.xsltc.compiler.util.ErrorMessages" , Locale . getDefault ( ) ) ; } public ErrorMsg ( String code ) { _code = code ; _line = 0 ; } public ErrorMsg ( Throwable e ) { _code = null ; _message = e . getMessage ( ) ; _line = 0 ; } public ErrorMsg ( String message , int line ) { _code = null ; _message = message ; _line = line ; } public ErrorMsg ( String code , int line , Object param ) { _code = code ; _line = line ; _params = new Object [ ] { param } ; } public ErrorMsg ( String code , Object param ) { this ( code ) ; _params = new Object [ 1 ] ; _params [ 0 ] = param ; } public ErrorMsg ( String code , Object param1 , Object param2 ) { this ( code ) ; _params = new Object [ 2 ] ; _params [ 0 ] = param1 ; _params [ 1 ] = param2 ; } public ErrorMsg ( String code , SyntaxTreeNode node ) { _code = code ; _url = getFileName ( node ) ; _line = node . getLineNumber ( ) ; } public ErrorMsg ( String code , Object param1 , SyntaxTreeNode node ) { _code = code ; _url = getFileName ( node ) ; _line = node . getLineNumber ( ) ; _params = new Object [ 1 ] ; _params [ 0 ] = param1 ; } public ErrorMsg ( String code , Object param1 , Object param2 , SyntaxTreeNode node ) { _code = code ; _url = getFileName ( node ) ; _line = node . getLineNumber ( ) ; _params = new Object [ 2 ] ; _params [ 0 ] = param1 ; _params [ 1 ] = param2 ; } private String getFileName ( SyntaxTreeNode node ) { Stylesheet stylesheet = node . getStylesheet ( ) ; if ( stylesheet != null ) return stylesheet . getSystemId ( ) ; else return null ; } private String formatLine ( ) { StringBuffer result = new StringBuffer ( ) ; if ( _url != null ) { result . append ( _url ) ; result . append ( ": " ) ; } if ( _line > 0 ) { result . append ( "line " ) ; result . append ( Integer . toString ( _line ) ) ; result . append ( ": " ) ; } return result . toString ( ) ; } public String toString ( ) { String suffix = ( _params == null ) ? ( null != _code ? new String ( getErrorMessage ( ) ) : _message ) : MessageFormat . format ( getErrorMessage ( ) , _params ) ; return formatLine ( ) + suffix ; } public String toString ( Object obj ) { Object params [ ] = new Object [ 1 ] ; params [ 0 ] = obj . toString ( ) ; String suffix = MessageFormat . format ( getErrorMessage ( ) , params ) ; return formatLine ( ) + suffix ; } public String toString ( Object obj0 , Object obj1 ) { Object params [ ] = new Object [ 2 ] ; params [ 0 ] = obj0 . toString ( ) ; params [ 1 ] = obj1 . toString ( ) ; String suffix = MessageFormat . format ( getErrorMessage ( ) , params ) ; return formatLine ( ) + suffix ; } private String getErrorMessage ( ) { return _bundle . getString ( _code ) ; } } 	1	['16', '1', '0', '60', '34', '0', '60', '2', '12', '1.027160494', '476', '0.046296296', '0', '0', '0.411111111', '0', '0', '22', '3', '0.6875', '2']
package org . apache . xalan . transformer ; import java . io . IOException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Templates ; import javax . xml . transform . TransformerConfigurationException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLFilterImpl ; import org . xml . sax . helpers . XMLReaderFactory ; public class TrAXFilter extends XMLFilterImpl { private Templates m_templates ; private TransformerImpl m_transformer ; public TrAXFilter ( Templates templates ) throws TransformerConfigurationException { m_templates = templates ; m_transformer = ( TransformerImpl ) templates . newTransformer ( ) ; } public TransformerImpl getTransformer ( ) { return m_transformer ; } public void setParent ( XMLReader parent ) { super . setParent ( parent ) ; if ( null != parent . getContentHandler ( ) ) this . setContentHandler ( parent . getContentHandler ( ) ) ; setupParse ( ) ; } public void parse ( InputSource input ) throws org . xml . sax . SAXException , IOException { if ( null == getParent ( ) ) { XMLReader reader = null ; try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } XMLReader parent ; if ( reader == null ) parent = XMLReaderFactory . createXMLReader ( ) ; else parent = reader ; try { parent . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } setParent ( parent ) ; } else { setupParse ( ) ; } if ( null == m_transformer . getContentHandler ( ) ) { throw new org . xml . sax . SAXException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_CALL_PARSE , null ) ) ; } getParent ( ) . parse ( input ) ; Exception e = m_transformer . getExceptionThrown ( ) ; if ( null != e ) { if ( e instanceof org . xml . sax . SAXException ) throw ( org . xml . sax . SAXException ) e ; else throw new org . xml . sax . SAXException ( e ) ; } } public void parse ( String systemId ) throws org . xml . sax . SAXException , IOException { parse ( new InputSource ( systemId ) ) ; } private void setupParse ( ) { XMLReader p = getParent ( ) ; if ( p == null ) { throw new NullPointerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_PARENT_FOR_FILTER , null ) ) ; } ContentHandler ch = m_transformer . getInputContentHandler ( ) ; p . setContentHandler ( ch ) ; p . setEntityResolver ( this ) ; p . setDTDHandler ( this ) ; p . setErrorHandler ( this ) ; } public void setContentHandler ( ContentHandler handler ) { m_transformer . setContentHandler ( handler ) ; } public void setErrorListener ( ErrorListener handler ) { m_transformer . setErrorListener ( handler ) ; } } 	1	['8', '2', '0', '3', '35', '0', '1', '2', '7', '0.5', '172', '1', '1', '0.829268293', '0.25', '1', '6', '20.25', '2', '1.125', '2']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_zh_TW extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "錯誤：表示式內不能有 '{'" } , { ER_ILLEGAL_ATTRIBUTE , "{0} 含有不合法的屬性：{1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "在 xsl:apply-imports 中，sourceNode 是空值！" } , { ER_CANNOT_ADD , "不能新增 {0} 到 {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "在 handleApplyTemplatesInstruction 中，sourceNode 是空值！" } , { ER_NO_NAME_ATTRIB , "{0} 必須有名稱屬性。" } , { ER_TEMPLATE_NOT_FOUND , "找不到指名為：{0} 的範本" } , { ER_CANT_RESOLVE_NAME_AVT , "無法解析 xsl:call-template 中的名稱 AVT。" } , { ER_REQUIRES_ATTRIB , "{0} 需要屬性：{1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} 必須有 ''test'' 屬性。" } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "層次屬性：{0} 包含不正確的值" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "processing-instruction 名稱不能是 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "processing-instruction 名稱必須是有效的 NCName：{0}" } , { ER_NEED_MATCH_ATTRIB , "{0} 如果有模式，必須有符合屬性。" } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} 需要名稱或符合屬性。" } , { ER_CANT_RESOLVE_NSPREFIX , "無法解析名稱空間字首：{0}" } , { ER_ILLEGAL_VALUE , "xml:space 含有不合法的值：{0}" } , { ER_NO_OWNERDOC , "子節點沒有擁有者文件！" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement 錯誤：{0}" } , { ER_NULL_CHILD , "嘗試新增空值子項元件！" } , { ER_NEED_SELECT_ATTRIB , "{0} 需要選取屬性。" } , { ER_NEED_TEST_ATTRIB , "xsl:when 必須有 'test' 屬性。" } , { ER_NEED_NAME_ATTRIB , "xsl:with-param 必須有 'name' 屬性。" } , { ER_NO_CONTEXT_OWNERDOC , "環境定義沒有擁有者文件！" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "無法建立 XML TransformerFactory Liaison：{0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: 程序沒有順利完成。" } , { ER_NOT_SUCCESSFUL , "Xalan: 不成功。" } , { ER_ENCODING_NOT_SUPPORTED , "不支援編碼：{0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "無法建立 TraceListener：{0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key 需要 'name' 屬性！" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key 需要 'match' 屬性！" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key 需要 'use' 屬性！" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} 需要 ''elements'' 屬性！" } , { ER_MISSING_PREFIX_ATTRIB , "遺漏 (StylesheetHandler) {0} 屬性 ''prefix''" } , { ER_BAD_STYLESHEET_URL , "樣式表 URL 不正確：{0}" } , { ER_FILE_NOT_FOUND , "找不到樣式表檔案：{0}" } , { ER_IOEXCEPTION , "樣式表檔案：{0} 發生 IO 異常" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) 找不到 {0} 的 href 屬性" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} 直接或間接包含自己！" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude 錯誤，{0}" } , { ER_MISSING_LANG_ATTRIB , "遺漏 (StylesheetHandler) {0} 屬性 ''lang''" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) 放置錯誤的 {0} 元素？？遺漏儲存器元素 ''component''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "只能輸出至 Element、DocumentFragment、Document 或 PrintWriter。" } , { ER_PROCESS_ERROR , "StylesheetRoot.process 錯誤" } , { ER_UNIMPLNODE_ERROR , "UnImplNode 錯誤：{0}" } , { ER_NO_SELECT_EXPRESSION , "錯誤！沒有找到 xpath select 表示式 (-select)。" } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "無法序列化 XSLProcessor！" } , { ER_NO_INPUT_STYLESHEET , "沒有指定樣式表輸入！" } , { ER_FAILED_PROCESS_STYLESHEET , "無法處理樣式表！" } , { ER_COULDNT_PARSE_DOC , "無法剖析 {0} 文件！" } , { ER_COULDNT_FIND_FRAGMENT , "找不到片段：{0}" } , { ER_NODE_NOT_ELEMENT , "片段 ID 所指向的節點不是元素：{0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each 必須有 match 或 name 屬性" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "templates 必須有 match 或 name 屬性" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "文件片段沒有複製！" } , { ER_CANT_CREATE_ITEM , "無法在結果樹：{0} 中建立項目" } , { ER_XMLSPACE_ILLEGAL_VALUE , "原始檔 XML 中的 xml:space 含有不合法的值：{0}" } , { ER_NO_XSLKEY_DECLARATION , "{0} 沒有 xsl:key 宣告！" } , { ER_CANT_CREATE_URL , "錯誤！無法針對：{0} 建立 URL" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions 不受支援" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory 錯誤" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} 不允許在樣式表內！" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns 不再受支援！請改用 xsl:output。" } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space 不再受支援！請改用 xsl:strip-space 或 xsl:preserve-space。" } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result 不再受支援！請改用 xsl:output。" } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} 含有不合法的屬性：{1}" } , { ER_UNKNOWN_XSL_ELEM , "不明 XSL 元素：{0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort 只能和 xsl:apply-templates 或 xsl:for-each 一起使用。" } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) 放置錯誤的 xsl:when！" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when 的母項不是 xsl:choose！" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) 放置錯誤的 xsl:otherwise！" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise 的母項不是 xsl:choose！" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "在範本內不允許 (StylesheetHandler) {0}！" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} 延伸項目名稱空間字首 {1} 不明" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Imports 只能出現在樣式表中作為第一個元素！" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} 正在直接或間接匯入自己！" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:space 有不合法的值：{0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet 不成功！" } , { ER_SAX_EXCEPTION , "SAX 異常" } , { ER_XSLT_ERROR , "XSLT 錯誤" } , { ER_CURRENCY_SIGN_ILLEGAL , "在格式型樣字串中不允許貨幣符號" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "在樣式表 DOM 中不支援文件函數！" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "無法解析非字首解析器的字首！" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "重新導向延伸項目：無法取得檔案名稱 - file 或 select 屬性必須傳回有效字串。" } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "無法在重新導向延伸項目中建立 FormatterListener！" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "exclude-result-prefixes 中的字首無效：{0}" } , { ER_MISSING_NS_URI , "遺漏指定的字首的名稱空間 URI" } , { ER_MISSING_ARG_FOR_OPTION , "遺漏選項：{0} 的引數" } , { ER_INVALID_OPTION , "選項：{0} 無效" } , { ER_MALFORMED_FORMAT_STRING , "不正確的格式字串：{0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet 需要 'version' 屬性！" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "屬性：{0} 含有不合法的值：{1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose 需要有 xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports 不容許出現在 xsl:for-each 中" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "無法使用輸出 DOM 節點的 DTMLiaison ... 改傳遞 org.apache.xpath.DOM2Helper！" } , { ER_CANT_USE_DTM_FOR_INPUT , "無法使用輸入 DOM 節點的 DTMLiaison ... 改傳遞 org.apache.xpath.DOM2Helper！" } , { ER_CALL_TO_EXT_FAILED , "呼叫延伸項目元素失敗：{0}" } , { ER_PREFIX_MUST_RESOLVE , "字首必須解析為名稱空間：{0}" } , { ER_INVALID_UTF16_SURROGATE , "偵測到無效的 UTF-16 代理：{0}?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} 自我使用，將造成無限迴圈。" } , { ER_CANNOT_MIX_XERCESDOM , "無法混合非 Xerces-DOM 輸入與 Xerces-DOM 輸出！" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "位於 ElemTemplateElement.readObject：{0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "找到不止一個名稱為：{0} 的範本" } , { ER_INVALID_KEY_CALL , "無效的函數呼叫：不允許 recursive key() 呼叫" } , { ER_REFERENCING_ITSELF , "變數 {0} 直接或間接參照自己！" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "對 newTemplates 的 DOMSource 而言，輸入節點不可為空值！" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "找不到選項 {0} 的類別檔案" } , { ER_REQUIRED_ELEM_NOT_FOUND , "找不到必要的元素：{0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream 不可為空值" } , { ER_URI_CANNOT_BE_NULL , "URI 不可為空值" } , { ER_FILE_CANNOT_BE_NULL , "檔案不可為空值" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource 不可為空值" } , { ER_CANNOT_INIT_BSFMGR , "無法起始設定 BSF 管理程式" } , { ER_CANNOT_CMPL_EXTENSN , "無法編譯延伸項目" } , { ER_CANNOT_CREATE_EXTENSN , "無法建立延伸項目：{0} 因為：{1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "呼叫方法 {0} 的實例方法需要物件實例作為第一個引數" } , { ER_INVALID_ELEMENT_NAME , "指定無效的元素名稱 {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "元素名稱方法必須是靜態 {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "延伸項目函數 {0} ： {1} 不明" } , { ER_MORE_MATCH_CONSTRUCTOR , "{0} 的最符合建構元不止一個" } , { ER_MORE_MATCH_METHOD , "方法 {0} 的最符合建構元不止一個" } , { ER_MORE_MATCH_ELEMENT , "元素方法 {0} 的最符合建構元不止一個" } , { ER_INVALID_CONTEXT_PASSED , "傳遞到評估 {0} 的環境定義無效" } , { ER_POOL_EXISTS , "儲存池已存在" } , { ER_NO_DRIVER_NAME , "未指定驅動程式名稱" } , { ER_NO_URL , "未指定 URL" } , { ER_POOL_SIZE_LESSTHAN_ONE , "儲存池大小小於 1！" } , { ER_INVALID_DRIVER , "指定的驅動程式名稱無效！" } , { ER_NO_STYLESHEETROOT , "找不到樣式表根目錄！" } , { ER_ILLEGAL_XMLSPACE_VALUE , "xml:space 的值不合法" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode 失敗" } , { ER_RESOURCE_COULD_NOT_LOAD , "無法載入資源 [ {0} ]：{1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "緩衝區大小 <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "呼叫延伸項目時發生不明錯誤" } , { ER_NO_NAMESPACE_DECL , "字首 {0} 沒有對應的名稱空間宣告" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "lang=javaclass {0} 不允許元素內容" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "樣式表導向終止" } , { ER_ONE_OR_TWO , "1 或 2" } , { ER_TWO_OR_THREE , "2 或 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "無法載入 {0}（檢查 CLASSPATH），現在只使用預設值" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "無法起始設定預設範本" } , { ER_RESULT_NULL , "結果不應為空值" } , { ER_RESULT_COULD_NOT_BE_SET , "無法設定結果" } , { ER_NO_OUTPUT_SPECIFIED , "沒有指定輸出" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "無法轉換成類型 {0} 的結果" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "無法轉換類型 {0} 的原始檔" } , { ER_NULL_CONTENT_HANDLER , "空值內容處理程式" } , { ER_NULL_ERROR_HANDLER , "空值錯誤處理程式" } , { ER_CANNOT_CALL_PARSE , "如果未設定 ContentHandler 則無法呼叫 parse" } , { ER_NO_PARENT_FOR_FILTER , "過濾器沒有母項" } , { ER_NO_STYLESHEET_IN_MEDIA , "在：{0}，media= {1} 中沒有樣式表" } , { ER_NO_STYLESHEET_PI , "在：{0} 中找不到 xml-stylesheet PI" } , { ER_NOT_SUPPORTED , "不支援：{0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "內容 {0} 的值應為 Boolean 實例" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "無法在 {0} 取得外部 Script" } , { ER_RESOURCE_COULD_NOT_FIND , "找不到資源 [ {0} ]。\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "未能辨識輸出內容：{0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "建立 ElemLiteralResult 實例失敗" } , { ER_VALUE_SHOULD_BE_NUMBER , "{0} 的值應該包含可剖析的數字" } , { ER_VALUE_SHOULD_EQUAL , "{0} 的值應等於 yes 或 no" } , { ER_FAILED_CALLING_METHOD , "呼叫 {0} 方法失敗" } , { ER_FAILED_CREATING_ELEMTMPL , "建立 ElemTemplateElement 實例失敗" } , { ER_CHARS_NOT_ALLOWED , "文件此點不允許字元" } , { ER_ATTR_NOT_ALLOWED , "\"{0}\" 屬性在 {1} 元素上不允許！" } , { ER_BAD_VALUE , "{0} 不正確的值 {1}" } , { ER_ATTRIB_VALUE_NOT_FOUND , "找不到 {0} 屬性值" } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "不能辨識 {0} 屬性值" } , { ER_NULL_URI_NAMESPACE , "嘗試用空值 URI 產生名稱空間字首" } , { ER_NUMBER_TOO_BIG , "嘗試格式化大於最大長整數 (Long integer) 的數字" } , { ER_CANNOT_FIND_SAX1_DRIVER , "找不到 SAX1 驅動程式類別 {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "找到 SAX1 驅動程式類別 {0}，但無法載入" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "已載入 SAX1 驅動程式類別 {0}，但無法實例化" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1 驅動程式類別 {0} 不能在 org.xml.sax.Parser 實作" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "無法指定系統內容 org.xml.sax.parser" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "剖析器引數不可為空值" } , { ER_FEATURE , "功能：{0}" } , { ER_PROPERTY , "內容：{0}" } , { ER_NULL_ENTITY_RESOLVER , "空值實體解析器" } , { ER_NULL_DTD_HANDLER , "空值 DTD 處理程式" } , { ER_NO_DRIVER_NAME_SPECIFIED , "未指定驅動程式名稱！" } , { ER_NO_URL_SPECIFIED , "未指定 URL！" } , { ER_POOLSIZE_LESS_THAN_ONE , "儲存池小於 1！" } , { ER_INVALID_DRIVER_NAME , "指定的驅動程式名稱無效！" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "程式設計師的錯誤！expr 沒有 ElemTemplateElement 母項！" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "程式設計師對於 RedundentExprEliminator 的假設(assertion)：{0}" } , { ER_NOT_ALLOWED_IN_POSITION , "在此樣式表中，此位置不可以是 {0}。" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "在此樣式表中，此位置不可以是非空白字元！" } , { INVALID_TCHAR , "CHAR 屬性：{0} 使用的值：{1} 不合法。CHAR 類型的屬性只能有一個字元！" } , { INVALID_QNAME , "QNAME 屬性：{0} 使用的值：{1} 不合法" } , { INVALID_ENUM , "ENUM 屬性：{0} 使用的值：{1} 不合法。有效的值為：{2}。" } , { INVALID_NMTOKEN , "NMTOKEN 屬性：{0} 使用的值：{1} 不合法" } , { INVALID_NCNAME , "NCNAME 屬性：{0} 使用的值：{1} 不合法" } , { INVALID_BOOLEAN , "Boolean 屬性：{0} 使用的值：{1} 不合法" } , { INVALID_NUMBER , "Number 屬性：{0} 使用的值：{1} 不合法" } , { ER_ARG_LITERAL , "比對型樣中的 ''{0}'' 的引數必須是文字。" } , { ER_DUPLICATE_GLOBAL_VAR , "廣域變數宣告重複。" } , { ER_DUPLICATE_VAR , "變數宣告重複。" } , { ER_TEMPLATE_NAME_MATCH , "xsl:template 必須有名稱或相符的屬性（或兩者）" } , { ER_INVALID_PREFIX , "exclude-result-prefixes 中的字首無效：{0}" } , { ER_NO_ATTRIB_SET , "attribute-set 名稱 {0} 不存在" } , { WG_FOUND_CURLYBRACE , "找到 '}' 但沒有開啟屬性範本！" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "警告：count 屬性不符合 xsl:number 中的被繼承者！目標 = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "舊語法：'expr' 屬性的名稱已變更為 'select'。" } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan 尚未處理 format-number 函數中的語言環境名稱。" } , { WG_LOCALE_NOT_FOUND , "警告：找不到 xml:lang={0} 的語言環境" } , { WG_CANNOT_MAKE_URL_FROM , "無法從：{0} 產生 URL" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "無法載入所要求的文件：{0}" } , { WG_CANNOT_FIND_COLLATOR , "找不到 <sort xml:lang={0} 的理序器" } , { WG_FUNCTIONS_SHOULD_USE_URL , "舊語法：函數指令應使用 {0} 的 URL" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "不支援編碼：{0}，請使用 UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "不支援編碼：{0}，請使用 Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "找到特定衝突：{0} 將使用在樣式表中找到的最後一個。" } , { WG_PARSING_AND_PREPARING , "========= 剖析與準備 {0} ==========" } , { WG_ATTR_TEMPLATE , "屬性範本，{0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "在 xsl:strip-space 和 xsl:preserve-space 之間有比對衝突" } , { WG_ATTRIB_NOT_HANDLED , "Xalan 尚未處理 {0} 屬性！" } , { WG_NO_DECIMALFORMAT_DECLARATION , "找不到十進位格式的宣告：{0}" } , { WG_OLD_XSLT_NS , "XSLT 名稱空間遺漏或不正確。" } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "僅允許一個預設 xsl:decimal-format 宣告。" } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format 名稱必須是唯一的。名稱 \"{0}\" 已重複。" } , { WG_ILLEGAL_ATTRIBUTE , "{0} 含有不合法的屬性：{1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "無法解析名稱空間字首：{0}。節點將被忽略。" } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet 需要 'version' 屬性！" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "不合法屬性名稱：{0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "屬性 {0} 使用了不合法值：{1}" } , { WG_EMPTY_SECOND_ARG , "從文件函數第二個引數產生的節點集是空值。傳回空的節點集。" } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "xsl:processing-instruction 名稱的 'name' 屬性值不可以是 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "xsl:processing-instruction 的 'name' 屬性值必須是有效的 NCName：{0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "在產生子項節點之後，或在產生元素之前，不可新增屬性 {0}。屬性會被忽略。" } , { "ui_language" , "zh" } , { "help_language" , "zh" } , { "language" , "zh" } , { "BAD_CODE" , "createMessage 的參數超出界限" } , { "FORMAT_FAILED" , "在 messageFormat 呼叫期間擲出異常" } , { "version" , ">>>>>>> Xalan 版本" } , { "version2" , "<<<<<<<" } , { "yes" , "yes" } , { "line" , "行號" } , { "column" , "欄號" } , { "xsldone" , "XSLProcessor：完成" } , { "xslProc_option" , "Xalan-J 指令行 Process 類別選項：" } , { "xslProc_option" , "Xalan-J 指令行 Process 類別選項:" } , { "xslProc_invalid_xsltc_option" , "XSLTC 模式不支援選項 {0}。" } , { "xslProc_invalid_xalan_option" , "選項 {0} 只能和 -XSLTC 一起使用。" } , { "xslProc_no_input" , "錯誤：未指定樣式表或輸入 xml。執行此指令時不要包含任何選項，即可取得用法指示。" } , { "xslProc_common_options" , "-一般選項-" } , { "xslProc_xalan_options" , "-Xalan 的選項-" } , { "xslProc_xsltc_options" , "-XSLTC 的選項-" } , { "xslProc_return_to_continue" , "(按 <return> 繼續)" } , { "optionXSLTC" , "[-XSLTC (使用 XSLTC 進行轉換)]" } , { "optionIN" , "[-IN inputXMLURL]" } , { "optionXSL" , "[-XSL XSLTransformationURL]" } , { "optionOUT" , "[-OUT outputFileName]" } , { "optionLXCIN" , "[-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "[-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "[-PARSER fully qualified class name of parser liaison]" } , { "optionE" , "   [-E（不展開實體參照）]" } , { "optionV" , "   [-E（不展開實體參照）]" } , { "optionQC" , "   [-QC（無聲型樣衝突警告）]" } , { "optionQ" , "   [-Q （無聲模式）]" } , { "optionLF" , "   [-LF（只在輸出上使用輸出 {預設是 CR/LF}）]" } , { "optionCR" , "   [-LF（只在輸出上使用回車 {預設是 CR/LF}）]" } , { "optionESCAPE" , "[-ESCAPE（要跳出的字元 {預設是 <>&\"\'\\r\\n}]" } , { "optionINDENT" , "[-INDENT（控制要內縮的空格數 {預設是 0}）]" } , { "optionTT" , "   [-TT（在被呼叫時追蹤範本。）]" } , { "optionTG" , "   [-TG（追蹤每一個產生事件。）]" } , { "optionTS" , "   [-TS（追蹤每一個選取事件。）]" } , { "optionTTC" , "   [-TTC（在被處理時追蹤範本子項元件。）]" } , { "optionTCLASS" , "   [-TCLASS（追蹤延伸項目的 TraceListener 類別。）]" } , { "optionVALIDATE" , "[-VALIDATE（設定是否發生驗證。依預設驗證是關閉的。）]" } , { "optionEDUMP" , "[-EDUMP {選用的檔案名稱}（發生錯誤時執行 stackdump）]" } , { "optionXML" , "   [-XML（使用 XML 格式製作器及新增 XML 標頭。）]" } , { "optionTEXT" , "   [-TEXT（使用簡易文字格式化程式。）]" } , { "optionHTML" , "   [-HTML（使用 HTML 格式製作器。）]" } , { "optionPARAM" , "   [-PARAM 名稱表示式（設定樣式表參數）]" } , { "noParsermsg1" , "XSL 程序沒有順利完成。" } , { "noParsermsg2" , "** 找不到剖析器 **" } , { "noParsermsg3" , "請檢查類別路徑。" } , { "noParsermsg4" , "如果您沒有 IBM 的 XML Parser for Java，可自以下網址下載" } , { "noParsermsg5" , "IBM 的 AlphaWorks：http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "[-URIRESOLVER 完整的類別名稱（URIResolver 用來解析 URI）]" } , { "optionENTITYRESOLVER" , "[-ENTITYRESOLVER 完整的類別名稱（EntityResolver 用來解析實體）]" } , { "optionCONTENTHANDLER" , "[-CONTENTHANDLER 完整的類別名稱（ContentHandler 用來序列化輸出）]" } , { "optionLINENUMBERS" , "[-L 使用原始文件的行號]" } , { "optionMEDIA" , "   [-MEDIA mediaType（使用媒體屬性尋找與文件相關聯的樣式表。）]" } , { "optionFLAVOR" , "   [-FLAVOR flavorName（明確使用 s2s=SAX 或 d2d=DOM 來執行轉換。）] " } , { "optionDIAG" , "   [-DIAG (列印轉換花費的毫秒數。）]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL（設定 http://xml.apache.org/xalan/features/incremental 為 true，要求漸進式 DTM 建構。）]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE（設定 http://xml.apache.org/xalan/features/optimize 為 false，不要求執行樣式表最佳化處理程序。）]" } , { "optionRL" , "   [-RL recursionlimit（主張對樣式表遞迴深度實施數值限制。）]" } , { "optionXO" , "[-XO [transletName] (指定名稱給產生的 translet)]" } , { "optionXD" , "[-XD destinationDirectory (指定 translet 的目標目錄)]" } , { "optionXJ" , "[-XJ jarfile (將 translet 類別封裝在檔名為 <jarfile> 的 jar 檔案中)]" } , { "optionXP" , "[-XP package (指定所產生的所有 translet 類別之套件名稱字首)]" } , { "optionXN" , "[-XN (啟用範本列入)]" } , { "optionXX" , "[-XX (開啟額外的除錯訊息輸出)]" } , { "optionXT" , "[-XT (可能的話，使用 translet 進行轉換)]" } , { "diagTiming" , "--------- 透過 {1} 耗費 {2} 毫秒轉換 {0}" } , { "recursionTooDeep" , "範本巢狀結構太深。巢狀 = {0}，範本 {1} {2}" } , { "nameIs" , "名稱為" } , { "matchPatternIs" , "比對型樣為" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "錯誤：" ; public static final String WARNING_HEADER = "警告：" ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "zh" , "TW" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLMessages { protected Locale fLocale = Locale . getDefault ( ) ; private static ListResourceBundle XMLBundle = null ; private static final String XML_ERROR_RESOURCES = "org.apache.xml.res.XMLErrorResources" ; protected static String BAD_CODE = "BAD_CODE" ; protected static String FORMAT_FAILED = "FORMAT_FAILED" ; public void setLocale ( Locale locale ) { fLocale = locale ; } public Locale getLocale ( ) { return fLocale ; } public static final String createXMLMessage ( String msgKey , Object args [ ] ) { if ( XMLBundle == null ) XMLBundle = loadResourceBundle ( XML_ERROR_RESOURCES ) ; if ( XMLBundle != null ) { return createMsg ( XMLBundle , msgKey , args ) ; } else return "Could not load any resource bundles." ; } public static final String createMsg ( ListResourceBundle fResourceBundle , String msgKey , Object args [ ] ) { String fmsg = null ; boolean throwex = false ; String msg = null ; if ( msgKey != null ) msg = fResourceBundle . getString ( msgKey ) ; if ( msg == null ) { msg = fResourceBundle . getString ( BAD_CODE ) ; throwex = true ; } if ( args != null ) { try { int n = args . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( null == args [ i ] ) args [ i ] = "" ; } fmsg = java . text . MessageFormat . format ( msg , args ) ; } catch ( Exception e ) { fmsg = fResourceBundle . getString ( FORMAT_FAILED ) ; fmsg += " " + msg ; } } else fmsg = msg ; if ( throwex ) { throw new RuntimeException ( fmsg ) ; } return fmsg ; } public static ListResourceBundle loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; try { return ( ListResourceBundle ) ResourceBundle . getBundle ( className , locale ) ; } catch ( MissingResourceException e ) { try { return ( ListResourceBundle ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." + className , className , "" ) ; } } } protected static String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['8', '1', '1', '34', '22', '18', '34', '0', '6', '0.828571429', '183', '1', '0', '0', '0.314285714', '0', '0', '21.25', '7', '1.875', '2']
package org . apache . xml . utils . res ; public class XResources_he extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "he" } , { "help_language" , "he" } , { "language" , "he" } , { "alphabet" , new char [ ] { 0x05D0 , 0x05D1 , 0x05D2 , 0x05D3 , 0x05D4 , 0x05D5 , 0x05D6 , 0x05D7 , 0x05D8 , 0x05D9 , 0x05DA , 0x05DB , 0x05DC , 0x05DD , 0x05DE , 0x05DF , 0x05E0 , 0x05E1 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "RightToLeft" } , { "numbering" , "additive" } , { "numberGroups" , new int [ ] { 10 , 1 } } , { "digits" , new char [ ] { 0x05D0 , 0x05D1 , 0x05D2 , 0x05D3 , 0x05D4 , 0x05D5 , 0x05D6 , 0x05D7 , 0x05D8 } } , { "tens" , new char [ ] { 0x05D9 , 0x05DA , 0x05DB , 0x05DC , 0x05DD , 0x05DE , 0x05DF , 0x05E0 , 0x05E1 } } , { "tables" , new String [ ] { "tens" , "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '426', '0', '0', '0.976190476', '1', '0', '0', '140.6666667', '1', '0.3333', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IF_ICMPNE ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . SIPUSH ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MultiHashtable ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; final class CastExpr extends Expression { private final Expression _left ; static private MultiHashtable InternalTypeMap = new MultiHashtable ( ) ; static { InternalTypeMap . put ( Type . Boolean , Type . Boolean ) ; InternalTypeMap . put ( Type . Boolean , Type . Real ) ; InternalTypeMap . put ( Type . Boolean , Type . String ) ; InternalTypeMap . put ( Type . Boolean , Type . Reference ) ; InternalTypeMap . put ( Type . Boolean , Type . Object ) ; InternalTypeMap . put ( Type . Real , Type . Real ) ; InternalTypeMap . put ( Type . Real , Type . Int ) ; InternalTypeMap . put ( Type . Real , Type . Boolean ) ; InternalTypeMap . put ( Type . Real , Type . String ) ; InternalTypeMap . put ( Type . Real , Type . Reference ) ; InternalTypeMap . put ( Type . Real , Type . Object ) ; InternalTypeMap . put ( Type . Int , Type . Int ) ; InternalTypeMap . put ( Type . Int , Type . Real ) ; InternalTypeMap . put ( Type . Int , Type . Boolean ) ; InternalTypeMap . put ( Type . Int , Type . String ) ; InternalTypeMap . put ( Type . Int , Type . Reference ) ; InternalTypeMap . put ( Type . Int , Type . Object ) ; InternalTypeMap . put ( Type . String , Type . String ) ; InternalTypeMap . put ( Type . String , Type . Boolean ) ; InternalTypeMap . put ( Type . String , Type . Real ) ; InternalTypeMap . put ( Type . String , Type . Reference ) ; InternalTypeMap . put ( Type . String , Type . Object ) ; InternalTypeMap . put ( Type . String , Type . ObjectString ) ; InternalTypeMap . put ( Type . NodeSet , Type . NodeSet ) ; InternalTypeMap . put ( Type . NodeSet , Type . Boolean ) ; InternalTypeMap . put ( Type . NodeSet , Type . Real ) ; InternalTypeMap . put ( Type . NodeSet , Type . String ) ; InternalTypeMap . put ( Type . NodeSet , Type . Node ) ; InternalTypeMap . put ( Type . NodeSet , Type . Reference ) ; InternalTypeMap . put ( Type . NodeSet , Type . Object ) ; InternalTypeMap . put ( Type . Node , Type . Node ) ; InternalTypeMap . put ( Type . Node , Type . Boolean ) ; InternalTypeMap . put ( Type . Node , Type . Real ) ; InternalTypeMap . put ( Type . Node , Type . String ) ; InternalTypeMap . put ( Type . Node , Type . NodeSet ) ; InternalTypeMap . put ( Type . Node , Type . Reference ) ; InternalTypeMap . put ( Type . Node , Type . Object ) ; InternalTypeMap . put ( Type . ResultTree , Type . ResultTree ) ; InternalTypeMap . put ( Type . ResultTree , Type . Boolean ) ; InternalTypeMap . put ( Type . ResultTree , Type . Real ) ; InternalTypeMap . put ( Type . ResultTree , Type . String ) ; InternalTypeMap . put ( Type . ResultTree , Type . NodeSet ) ; InternalTypeMap . put ( Type . ResultTree , Type . Reference ) ; InternalTypeMap . put ( Type . ResultTree , Type . Object ) ; InternalTypeMap . put ( Type . Reference , Type . Reference ) ; InternalTypeMap . put ( Type . Reference , Type . Boolean ) ; InternalTypeMap . put ( Type . Reference , Type . Int ) ; InternalTypeMap . put ( Type . Reference , Type . Real ) ; InternalTypeMap . put ( Type . Reference , Type . String ) ; InternalTypeMap . put ( Type . Reference , Type . Node ) ; InternalTypeMap . put ( Type . Reference , Type . NodeSet ) ; InternalTypeMap . put ( Type . Reference , Type . ResultTree ) ; InternalTypeMap . put ( Type . Reference , Type . Object ) ; InternalTypeMap . put ( Type . Object , Type . String ) ; InternalTypeMap . put ( Type . ObjectString , Type . String ) ; InternalTypeMap . put ( Type . Void , Type . String ) ; } private boolean _typeTest = false ; public CastExpr ( Expression left , Type type ) throws TypeCheckError { _left = left ; _type = type ; if ( ( _left instanceof Step ) && ( _type == Type . Boolean ) ) { Step step = ( Step ) _left ; if ( ( step . getAxis ( ) == Axis . SELF ) && ( step . getNodeType ( ) != - 1 ) ) _typeTest = true ; } setParser ( left . getParser ( ) ) ; setParent ( left . getParent ( ) ) ; left . setParent ( this ) ; typeCheck ( left . getParser ( ) . getSymbolTable ( ) ) ; } public Expression getExpr ( ) { return _left ; } public boolean hasPositionCall ( ) { return ( _left . hasPositionCall ( ) ) ; } public boolean hasLastCall ( ) { return ( _left . hasLastCall ( ) ) ; } public String toString ( ) { return "cast(" + _left + ", " + _type + ")" ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type tleft = _left . getType ( ) ; if ( tleft == null ) { tleft = _left . typeCheck ( stable ) ; } if ( tleft instanceof NodeType ) { tleft = Type . Node ; } else if ( tleft instanceof ResultTreeType ) { tleft = Type . ResultTree ; } if ( InternalTypeMap . maps ( tleft , _type ) != null ) { return _type ; } throw new TypeCheckError ( new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , tleft . toString ( ) , _type . toString ( ) ) ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { FlowList fl ; final Type ltype = _left . getType ( ) ; if ( _typeTest ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int idx = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; il . append ( new SIPUSH ( ( short ) ( ( Step ) _left ) . getNodeType ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( idx , 2 ) ) ; _falseList . add ( il . append ( new IF_ICMPNE ( null ) ) ) ; } else { _left . translate ( classGen , methodGen ) ; if ( _type != ltype ) { _left . startIterator ( classGen , methodGen ) ; if ( _type instanceof BooleanType ) { fl = ltype . translateToDesynthesized ( classGen , methodGen , _type ) ; if ( fl != null ) { _falseList . append ( fl ) ; } } else { ltype . translateTo ( classGen , methodGen , _type ) ; } } } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Type ltype = _left . getType ( ) ; _left . translate ( classGen , methodGen ) ; if ( _type . identicalTo ( ltype ) == false ) { _left . startIterator ( classGen , methodGen ) ; ltype . translateTo ( classGen , methodGen , _type ) ; } } } 	1	['9', '3', '0', '57', '49', '0', '34', '24', '8', '0.583333333', '546', '1', '2', '0.91025641', '0.3125', '2', '8', '59.33333333', '5', '1.3333', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_NAME_CANT_START_WITH_COLON = "ER_NAME_CANT_START_WITH_COLON" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final String ER_ILLEGAL_CHARACTER = "ER_ILLEGAL_CHARACTER" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Function not supported!" } , { ER_CANNOT_OVERWRITE_CAUSE , "Cannot overwrite cause" } , { ER_NO_DEFAULT_IMPL , "No default implementation found " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) not currently supported" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Offset bigger than slot" } , { ER_COROUTINE_NOT_AVAIL , "Coroutine not available, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager received co_exit() request" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() failed" } , { ER_COROUTINE_PARAM , "Coroutine parameter error ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: Parser doTerminate answers {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "parse may not be called while parsing" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: typed iterator for axis  {0} not implemented" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Error: iterator for axis {0} not implemented " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Iterator clone not supported" } , { ER_UNKNOWN_AXIS_TYPE , "Unknown axis traversal type: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Axis traverser not supported: {0}" } , { ER_NO_DTMIDS_AVAIL , "No more DTM IDs are available" } , { ER_NOT_SUPPORTED , "Not supported: {0}" } , { ER_NODE_NON_NULL , "Node must be non-null for getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "Could not resolve the node to a handle" } , { ER_STARTPARSE_WHILE_PARSING , "startParse may not be called while parsing" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse needs a non-null SAXParser" } , { ER_COULD_NOT_INIT_PARSER , "could not initialize parser with" } , { ER_EXCEPTION_CREATING_POOL , "exception creating new instance for pool" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Path contains invalid escape sequence" } , { ER_SCHEME_REQUIRED , "Scheme is required!" } , { ER_NO_SCHEME_IN_URI , "No scheme found in URI: {0}" } , { ER_NO_SCHEME_INURI , "No scheme found in URI" } , { ER_PATH_INVALID_CHAR , "Path contains invalid character: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Cannot set scheme from null string" } , { ER_SCHEME_NOT_CONFORMANT , "The scheme is not conformant." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Host is not a well formed address" } , { ER_PORT_WHEN_HOST_NULL , "Port cannot be set when host is null" } , { ER_INVALID_PORT , "Invalid port number" } , { ER_FRAG_FOR_GENERIC_URI , "Fragment can only be set for a generic URI" } , { ER_FRAG_WHEN_PATH_NULL , "Fragment cannot be set when path is null" } , { ER_FRAG_INVALID_CHAR , "Fragment contains invalid character" } , { ER_PARSER_IN_USE , "Parser is already in use" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Cannot change {0} {1} while parsing" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Self-causation not permitted" } , { ER_NO_USERINFO_IF_NO_HOST , "Userinfo may not be specified if host is not specified" } , { ER_NO_PORT_IF_NO_HOST , "Port may not be specified if host is not specified" } , { ER_NO_QUERY_STRING_IN_PATH , "Query string cannot be specified in path and query string" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Fragment cannot be specified in both the path and fragment" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Cannot initialize URI with empty parameters" } , { ER_METHOD_NOT_SUPPORTED , "Method not yet supported " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter not currently restartable" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader not before startParse request" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Axis traverser not supported: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler created with null PrintWriter!" } , { ER_SYSTEMID_UNKNOWN , "SystemId Unknown" } , { ER_LOCATION_UNKNOWN , "Location of error unknown" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() not supported in XPathContext!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Attribute child does not have an owner document!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Attribute child does not have an owner document element!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Warning: can't output text before document element!  Ignoring..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Can't have more than one root on a DOM!" } , { ER_ARG_LOCALNAME_NULL , "Argument 'localName' is null" } , { ER_ARG_LOCALNAME_INVALID , "Localname in QNAME should be a valid NCName" } , { ER_ARG_PREFIX_INVALID , "Prefix in QNAME should be a valid NCName" } , { ER_NAME_CANT_START_WITH_COLON , "Name cannot start with a colon" } , { "BAD_CODE" , "Parameter to createMessage was out of bounds" } , { "FORMAT_FAILED" , "Exception thrown during messageFormat call" } , { "line" , "Line #" } , { "column" , "Column #" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "The serializer class ''{0}'' does not implement org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "The resource [ {0} ] could not be found.\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "The resource [ {0} ] could not load: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Buffer size <=0" } , { ER_INVALID_UTF16_SURROGATE , "Invalid UTF-16 surrogate detected: {0} ?" } , { ER_OIERROR , "IO error" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Cannot add attribute {0} after child nodes or before an element is produced.  Attribute will be ignored." } , { ER_NAMESPACE_PREFIX , "Namespace for prefix ''{0}'' has not been declared." } , { ER_STRAY_ATTRIBUTE , "Attribute ''{0}'' outside of element." } , { ER_STRAY_NAMESPACE , "Namespace declaration ''{0}''=''{1}'' outside of element." } , { ER_COULD_NOT_LOAD_RESOURCE , "Could not load ''{0}'' (check CLASSPATH), now using just the defaults" } , { ER_ILLEGAL_CHARACTER , "Attempt to output character of integral value {0} that is not represented in specified output encoding of {1}." } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "Could not load the propery file ''{0}'' for output method ''{1}'' (check CLASSPATH)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '2', '18', '16', '8', '18', '0', '3', '1.24375', '1199', '0', '0', '0.926829268', '0.333333333', '0', '0', '222.8', '2', '0.8', '2']
package org . apache . xml . utils . res ; public class XResources_ja_JP_I extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "alphabet" , new char [ ] { 0x30a4 , 0x30ed , 0x30cf , 0x30cb , 0x30db , 0x30d8 , 0x30c8 , 0x30c1 , 0x30ea , 0x30cc , 0x30eb , 0x30f2 , 0x30ef , 0x30ab , 0x30e8 , 0x30bf , 0x30ec , 0x30bd , 0x30c4 , 0x30cd , 0x30ca , 0x30e9 , 0x30e0 , 0x30a6 , 0x30f0 , 0x30ce , 0x30aa , 0x30af , 0x30e4 , 0x30de , 0x30b1 , 0x30d5 , 0x30b3 , 0x30a8 , 0x30c6 , 0x30a2 , 0x30b5 , 0x30ad , 0x30e6 , 0x30e1 , 0x30df , 0x30b7 , 0x30f1 , 0x30d2 , 0x30e2 , 0x30bb , 0x30b9 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "multiplier" , new long [ ] { Long . MAX_VALUE , Long . MAX_VALUE , 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4EAC , 0x5146 , 0x5104 , 0x4E07 , 0x5343 , 0x767e , 0x5341 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x4E00 , 0x4E8C , 0x4E09 , 0x56DB , 0x4E94 , 0x516D , 0x4E03 , 0x516B , 0x4E5D } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '595', '0', '0', '0.976190476', '1', '0', '0', '197', '1', '0.3333', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_fr extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Erreur : '{' interdit dans une expression" } , { ER_ILLEGAL_ATTRIBUTE , "{0} comporte un attribut incorrect : {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode est vide dans xsl:apply-imports !" } , { ER_CANNOT_ADD , "Impossible d''ajouter {0} à {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode est vide dans handleApplyTemplatesInstruction !" } , { ER_NO_NAME_ATTRIB , "{0} doit posséder un attribut de nom." } , { ER_TEMPLATE_NOT_FOUND , "Impossible de trouver le modèle : {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Impossible de convertir l'AVT du nom dans xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} requiert l''attribut : {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} doit posséder un attribut ''test''." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Valeur erronée dans l''attribut de niveau : {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Le nom de l'instruction de traitement ne peut être ''xml''" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Le nom de l''instruction de traitement doit être un NCName valide : {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} doit posséder un attribut de correspondance s''il possède un mode." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} requiert un nom ou un attribut de correspondance." } , { ER_CANT_RESOLVE_NSPREFIX , "Impossible de résoudre le préfixe de l''espace de noms : {0}" } , { ER_ILLEGAL_VALUE , "xml:space comporte une valeur non valide : {0}" } , { ER_NO_OWNERDOC , "Le noeud enfant ne possède pas de document propriétaire !" } , { ER_ELEMTEMPLATEELEM_ERR , "Erreur de ElemTemplateElement : {0}" } , { ER_NULL_CHILD , "Tentative d'ajout d'un enfant vide !" } , { ER_NEED_SELECT_ATTRIB , "{0} requiert un attribut de sélection." } , { ER_NEED_TEST_ATTRIB , "xsl:when doit posséder un attribut ''test''." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param doit posséder un attribut ''name''." } , { ER_NO_CONTEXT_OWNERDOC , "Le contexte ne possède pas de document propriétaire !" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Impossible de créer XML TransformerFactory Liaison : {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Echec du processus Xalan." } , { ER_NOT_SUCCESSFUL , "Echec de Xalan." } , { ER_ENCODING_NOT_SUPPORTED , "Encodage non pris en charge : {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Impossible de créer TraceListener : {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key requiert un attribut ''name'' !" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key requiert un attribut ''match'' !" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key requiert un attribut ''use'' !" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} requiert un attribut ''elements'' !" } , { ER_MISSING_PREFIX_ATTRIB , "L''attribut ''prefix'' de (StylesheetHandler) {0} est manquant" } , { ER_BAD_STYLESHEET_URL , "URL de la feuille de style erroné : {0}" } , { ER_FILE_NOT_FOUND , "Fichier de la feuille de style introuvable : {0}" } , { ER_IOEXCEPTION , "Exception d''E-S avec le fichier de la feuille de style : {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Impossible de trouver d''attribut href pour {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} est directement ou indirectement inclus dans lui-même !" } , { ER_PROCESSINCLUDE_ERROR , "Erreur de StylesheetHandler.processInclude, {0}" } , { ER_MISSING_LANG_ATTRIB , "L''attribut ''lang'' de (StylesheetHandler) {0} est manquant" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) position de l''élément {0} inadéquate ? Elément ''component'' de conteneur manquant" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Seule sortie possible vers Element, DocumentFragment, Document ou PrintWriter." } , { ER_PROCESS_ERROR , "Erreur de StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "Erreur de UnImplNode : {0}" } , { ER_NO_SELECT_EXPRESSION , "Erreur ! Impossible de trouver l'expression de sélection xpath (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Impossible de sérialiser un XSLProcessor !" } , { ER_NO_INPUT_STYLESHEET , "Entrée de feuille de style non spécifiée !" } , { ER_FAILED_PROCESS_STYLESHEET , "Impossible de traiter la feuille de style !" } , { ER_COULDNT_PARSE_DOC , "Impossible d''analyser le document {0} !" } , { ER_COULDNT_FIND_FRAGMENT , "Impossible de trouver le fragment : {0}" } , { ER_NODE_NOT_ELEMENT , "Le noeud désigné par l''identificateur de fragment n''est pas un élément : {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each doit posséder un attribut de correspondance ou de nom" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "Les modèles doivent posséder un attribut de correspondance ou de nom" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Pas de clone dans un fragment de document !" } , { ER_CANT_CREATE_ITEM , "Impossible de créer l''élément dans l''arborescence de résultats : {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space du source XML possède une valeur incorrecte : {0}" } , { ER_NO_XSLKEY_DECLARATION , "Aucune déclaration xsl:key pour {0} !" } , { ER_CANT_CREATE_URL , "Erreur ! Impossible de créer une URL pour : {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions n'est pas pris en charge" } , { ER_PROCESSOR_ERROR , "Erreur TransformerFactory de XSLT" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} n''est pas pris en charge dans une feuille de style !" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns n'est plus pris en charge !  Préférez xsl:output." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space n'est plus pris en charge !  Préférez xsl:strip-space ou xsl:preserve-space." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result n'est plus pris en charge !  Préférez xsl:output." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} comporte un attribut incorrect : {1}" } , { ER_UNKNOWN_XSL_ELEM , "Elément XSL inconnu : {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort ne peut être utilisé qu'avec xsl:apply-templates ou xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when ne figure pas à la bonne position !" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when sans rapport avec xsl:choose !" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise ne figure pas à la bonne position !" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise sans rapport avec xsl:choose !" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} n''est pas admis dans un modèle !" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} préfixe de l''espace de noms de l''extension {1} inconnu" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Les importations peuvent être effectuées uniquement en tant que premiers éléments de la feuille de style !" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} s''importe lui-même directement ou indirectement !" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:space possède une valeur incorrecte : {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "Echec de processStylesheet !" } , { ER_SAX_EXCEPTION , "Exception SAX" } , { ER_XSLT_ERROR , "Erreur XSLT" } , { ER_CURRENCY_SIGN_ILLEGAL , "Tout symbole monétaire est interdit dans une chaîne de motif de correspondance" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Fonction de document non prise en charge dans le DOM de la feuille de style !" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Impossible de résoudre le préfixe du solveur !" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Extension de redirection : Impossible d'extraire le nom du fichier - l'attribut de fichier ou de sélection doit retourner une chaîne valide. " } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Impossible de créer FormatterListener dans une extension Redirect !" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Préfixe de exclude-result-prefixes non valide : {0}" } , { ER_MISSING_NS_URI , "URI de l'espace de noms manquant pour le préfixe indiqué" } , { ER_MISSING_ARG_FOR_OPTION , "Argument manquant pour l''option : {0}" } , { ER_INVALID_OPTION , "Option incorrecte : {0}" } , { ER_MALFORMED_FORMAT_STRING , "Chaîne de format mal formée : {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet requiert un attribut ''version'' !" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "L''attribut : {0} possède une valeur non valide : {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose requiert xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports interdit dans un xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Impossible d'utiliser DTMLiaison pour un noeud de DOM en sortie... Transmettez org.apache.xpath.DOM2Helper à la place !" } , { ER_CANT_USE_DTM_FOR_INPUT , "Impossible d'utiliser DTMLiaison pour un noeud de DOM en entrée... Transmettez org.apache.xpath.DOM2Helper à la place !" } , { ER_CALL_TO_EXT_FAILED , "Echec de l''appel de l''élément d'extension : {0}" } , { ER_PREFIX_MUST_RESOLVE , "Le préfixe doit se convertir en espace de noms : {0}" } , { ER_INVALID_UTF16_SURROGATE , "Substitut UTF-16 non valide détecté : {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} s''utilise lui-même, ce qui provoque une boucle infinie." } , { ER_CANNOT_MIX_XERCESDOM , "Impossible de mélanger une entrée autre que Xerces-DOM avec une sortie Xerces-DOM !" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "Dans ElemTemplateElement.readObject : {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Plusieurs modèles s''appellent : {0}" } , { ER_INVALID_KEY_CALL , "Appel de fonction non valide : appels de key() récursifs interdits" } , { ER_REFERENCING_ITSELF , "La variable {0} fait référence à elle-même directement ou indirectement !" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Le noeud d'entrée ne peut être vide pour un DOMSource de newTemplates !" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Fichier de classe introuvable pour l''option {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Elément requis introuvable : {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream ne doit pas être vide" } , { ER_URI_CANNOT_BE_NULL , "L'URI ne doit pas être vide" } , { ER_FILE_CANNOT_BE_NULL , "Le fichier ne doit pas être vide" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource ne doit pas être vide" } , { ER_CANNOT_INIT_BSFMGR , "Impossible d'initialiser le gestionnaire de BSF" } , { ER_CANNOT_CMPL_EXTENSN , "Impossible de compiler l'extension" } , { ER_CANNOT_CREATE_EXTENSN , "Impossible de créer l''extension : {0} en raison de : {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "L''appel de la méthode d''instance de la méthode {0} requiert une instance d''Object comme premier argument " } , { ER_INVALID_ELEMENT_NAME , "Nom d''élément non valide spécifié {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "La méthode de nom d''élément doit être statique {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "La fonction d''extension {0} : {1} est inconnue" } , { ER_MORE_MATCH_CONSTRUCTOR , "Plusieurs occurrences proches pour le constructeur de {0}" } , { ER_MORE_MATCH_METHOD , "Plusieurs occurrences proches pour la méthode {0}" } , { ER_MORE_MATCH_ELEMENT , "Plusieurs occurrences proches pour la méthode d''élément {0}" } , { ER_INVALID_CONTEXT_PASSED , "Contexte non valide transmis transmis pour évaluer {0}" } , { ER_POOL_EXISTS , "Pool déjà existant" } , { ER_NO_DRIVER_NAME , "Aucun nom de périphérique indiqué" } , { ER_NO_URL , "Aucune URL spécifiée" } , { ER_POOL_SIZE_LESSTHAN_ONE , "La taille du pool est inférieure à 1 !" } , { ER_INVALID_DRIVER , "Nom de pilote non valide spécifié !" } , { ER_NO_STYLESHEETROOT , "Impossible de trouver la racine de la feuille de style !" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Valeur incorrecte pour xml:space" } , { ER_PROCESSFROMNODE_FAILED , "Echec de processFromNode" } , { ER_RESOURCE_COULD_NOT_LOAD , "La ressource [ {0} ] n''a pas pu charger : {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Taille du tampon <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Erreur inconnue lors de l'appel de l'extension" } , { ER_NO_NAMESPACE_DECL , "Le préfixe {0} ne possède pas de déclaration d''espace de noms correspondante" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Contenu d''élément interdit pour lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "La feuille de style a provoqué l'arrêt" } , { ER_ONE_OR_TWO , "1 ou 2" } , { ER_TWO_OR_THREE , "2 ou 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Impossible de charger {0} (vérifier CLASSPATH), les valeurs par défaut sont donc employées" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Impossible d'initialiser les modèles par défaut" } , { ER_RESULT_NULL , "Le résultat doit être vide" } , { ER_RESULT_COULD_NOT_BE_SET , "Le résultat ne peut être défini" } , { ER_NO_OUTPUT_SPECIFIED , "Aucune sortie spécifiée" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Transformation impossible vers un résultat de type {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Transformation impossible vers une source de type {0}" } , { ER_NULL_CONTENT_HANDLER , "Gestionnaire de contenu vide" } , { ER_NULL_ERROR_HANDLER , "Gestionnaire d'erreurs vide" } , { ER_CANNOT_CALL_PARSE , "L'analyse ne peut être appelée si le ContentHandler n'a pas été défini" } , { ER_NO_PARENT_FOR_FILTER , "Pas de parent pour le filtre" } , { ER_NO_STYLESHEET_IN_MEDIA , "Aucune feuille de style dans : {0}, support = {1}" } , { ER_NO_STYLESHEET_PI , "Pas de PI xml-stylesheet dans : {0}" } , { ER_NOT_SUPPORTED , "Non pris en charge : {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "La valeur de la propriété {0} doit être une instance booléenne" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "Impossible d''extraire le script externe à {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "La ressource [ {0} ] est introuvable.\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Propriété de sortie non identifiée : {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Impossible de créer une instance de ElemLiteralResult" } , { ER_VALUE_SHOULD_BE_NUMBER , "La valeur de {0} doit contenir un nombre analysable" } , { ER_VALUE_SHOULD_EQUAL , "La valeur de {0} doit être oui ou non" } , { ER_FAILED_CALLING_METHOD , "Echec de l''appel de la méthode {0}" } , { ER_FAILED_CREATING_ELEMTMPL , "Echec de la création de l'instance de ElemTemplateElement" } , { ER_CHARS_NOT_ALLOWED , "La présence de caractères n'est pas admise à cet endroit du document" } , { ER_ATTR_NOT_ALLOWED , "L''attribut \"{0}\" n''est pas admis sur l''élément {1} !" } , { ER_BAD_VALUE , "{0} valeur erronée {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "Impossible de trouver la valeur de l''attribut {0}" } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "Valeur de l''attribut {0} non identifiée" } , { ER_NULL_URI_NAMESPACE , "Tentative de création d'un préfixe d'espace de noms avec un URI vide" } , { ER_NUMBER_TOO_BIG , "Tentative de formatage d'un nombre supérieur à l'entier Long le plus élevé" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Impossible de trouver la classe {0} du pilote SAX1" } , { ER_SAX1_DRIVER_NOT_LOADED , "Classe {0} du pilote SAX1 trouvée mais non chargée" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "Classe {0} du pilote SAX1 trouvée mais non instanciée" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "La classe {0} du pilote SAX1 n''implémente pas org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Propriété système org.xml.sax.parser non spécifiée" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "L'argument de l'analyseur ne doit pas être vide" } , { ER_FEATURE , "Fonction : {0}" } , { ER_PROPERTY , "Propriété : {0}" } , { ER_NULL_ENTITY_RESOLVER , "Solveur d'entité vide" } , { ER_NULL_DTD_HANDLER , "Gestionnaire de DT vide" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Aucun nom de pilote spécifié !" } , { ER_NO_URL_SPECIFIED , "Aucune URL spécifiée !" } , { ER_POOLSIZE_LESS_THAN_ONE , "La taille du pool est inférieure à 1 !" } , { ER_INVALID_DRIVER_NAME , "Nom de pilote non valide spécifié !" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Erreur de programme ! expr n'a pas de parent ElemTemplateElement !" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Assertion du programmeur dans RundundentExprEliminator : {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} ne peut pas figurer à cette position dans la feuille de style !" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Seul de l'espace est accepté à cette position dans la feuille de style !" } , { INVALID_TCHAR , "Valeur incorrecte : {1} utilisée pour l''attribut CHAR : {0}.  Un attribut de type CHAR ne peut comporter qu''un 1 seul caractère !" } , { INVALID_QNAME , "Valeur incorrecte : {1} utilisée pour l''attribut QNAME : {0}" } , { INVALID_ENUM , "Valeur incorrecte : {1} utilisée pour l''attribut ENUM : {0}.  Les valeurs autorisées sont : {2}." } , { INVALID_NMTOKEN , "Valeur incorrecte : {1} utilisée pour l''attribut NMTOKEN : {0}. " } , { INVALID_NCNAME , "Valeur incorrecte : {1} utilisée pour l''attribut NCNAME : {0}. " } , { INVALID_BOOLEAN , "Valeur incorrecte : {1} utilisée pour l''attribut booléen : {0}. " } , { INVALID_NUMBER , "Valeur incorrecte : {1} utilisée pour l''attribut number : {0}. " } , { ER_ARG_LITERAL , "L''argument de {0} dans le motif de correspondance doit être un littéral." } , { ER_DUPLICATE_GLOBAL_VAR , "Déclaration de variable globale en double." } , { ER_DUPLICATE_VAR , "Déclaration de variable en double." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template doit comporter un attribut name et/ou match" } , { ER_INVALID_PREFIX , "Préfixe de exclude-result-prefixes non valide : {0}" } , { ER_NO_ATTRIB_SET , "attribute-set {0} n''existe pas" } , { WG_FOUND_CURLYBRACE , "Une accolade ('}') a été trouvée alors qu'aucun modèle d'attribut n'est ouvert !" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Avertissement : L''attribut de count n''a pas d''ascendant dans xsl:number ! Cible = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Syntaxe obsolète : Le nom de l'attribut ''expr'' a été remplacé par ''select''." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan ne gère pas encore le nom d'environnement local de la fonction format-number." } , { WG_LOCALE_NOT_FOUND , "Avertissement : Impossible de trouver un environnement local pour xml:lang={0}" } , { WG_CANNOT_MAKE_URL_FROM , "Impossible de créer l''URL à partir de : {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Impossible de charger le document demandé : {0}" } , { WG_CANNOT_FIND_COLLATOR , "Impossible de trouver une fonction de regroupement pour <sort xml:lang= {0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Syntaxe obsolète : L''instruction de fonction doit utiliser une URL {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "encodage non pris en charge : {0}, en utilisant UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "encodage non pris en charge : {0}, en utilisant Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Conflits de spécificités trouvés : {0} La dernière de la feuille de style sera employée." } , { WG_PARSING_AND_PREPARING , "========= Analyse et préparation de {0} ==========" } , { WG_ATTR_TEMPLATE , "Modèle d''attribut, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Conflit de correspondances entre xsl:strip-space et xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan ne gère pas encore l''attribut {0} !" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Pas de déclaration pour le format décimal : {0}" } , { WG_OLD_XSLT_NS , "Espace de noms XSLT manquant ou incorrect. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Une seule déclaration xsl:decimal-format par défaut est admise." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "Les noms xsl:decimal-format doivent être uniques. Le nom \"{0}\" a été dupliqué." } , { WG_ILLEGAL_ATTRIBUTE , "{0} comporte un attribut incorrect : {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Impossible de convertir le préfixe de l''espace de noms : {0}. Le noeud n'est pas traité." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet requiert un attribut 'version' !" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Nom d''attribut incorrect : {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Valeur incorrecte pour l''attribut {0} : {1}" } , { WG_EMPTY_SECOND_ARG , "L'ensemble de noeuds résultant du second argument de la fonction du document est vide. Un ensemble de noeuds vide est retourné." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "La valeur de l'attribut ''name'' de xsl:processing-instruction doit être différente de ''xml''" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "La valeur de l''attribut ''name'' de xsl:processing-instruction doit être un nom NCName valide : {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Ajout impossible de l''attribut {0} après des noeuds enfants ou avant la production d''un élément.  L''attribut est ignoré." } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "Le paramètre de createMessage se trouve hors limites" } , { "FORMAT_FAILED" , "Exception soulevée lors de l'appel de messageFormat" } , { "version" , ">>>>>>> Version de Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "oui" } , { "line" , "Ligne #" } , { "column" , "Colonne #" } , { "xsldone" , "XSLProcessor : terminé" } , { "xslProc_option" , "Options de classe Process de ligne de commande Xalan-J :" } , { "xslProc_option" , "Options de classe Process de ligne de commande Xalan-J:" } , { "xslProc_invalid_xsltc_option" , "L''option {0} n''est pas prise en charge en mode XSLTC." } , { "xslProc_invalid_xalan_option" , "L''option {0} s''utilise uniquement avec -XSLTC." } , { "xslProc_no_input" , "Erreur : Aucun xml de feuille de style ou d'entrée n'est spécifié. Exécutez cette commande sans option pour les instructions d'utilisation." } , { "xslProc_common_options" , "-Options courantes-" } , { "xslProc_xalan_options" , "-Options pour Xalan-" } , { "xslProc_xsltc_options" , "-Options pour XSLTC-" } , { "xslProc_return_to_continue" , "(appuyez sur <Retour> pour continuer)" } , { "optionXSLTC" , "   [-XSLTC (utilisez XSLTC pour la transformation)]" } , { "optionIN" , "   [-IN inputXMLURL]" } , { "optionXSL" , "   [-XSL URLXSLTransformation]" } , { "optionOUT" , "   [-OUT nomFichierSortie]" } , { "optionLXCIN" , "   [-LXCIN NomFichierFeuilleDeStylesCompiléEntrée]" } , { "optionLXCOUT" , "   [-LXCOUT NomFichierFeuilleDeStylesCompiléSortie]" } , { "optionPARSER" , "   [-PARSER nom de classe pleinement qualifié pour la liaison de l'analyseur]" } , { "optionE" , "   [-E (Ne pas développer les réf. d'entité)]" } , { "optionV" , "   [-E (Ne pas développer les réf. d'entité)]" } , { "optionQC" , "   [-QC (Avertissements brefs de conflits de motifs)]" } , { "optionQ" , "   [-Q  (Mode bref)]" } , { "optionLF" , "   [-LF (Utilise des sauts de ligne uniquement dans la sortie {CR/LF par défaut})]" } , { "optionCR" , "   [-LF (Utilise des retours chariot uniquement dans la sortie {CR/LF par défaut})]" } , { "optionESCAPE" , "   [-ESCAPE (Caractères d'échappement {<>&\"\''\\r\\n par défaut}]" } , { "optionINDENT" , "   [-INDENT (Nombre d'espaces pour le retrait {par défaut 0})]" } , { "optionTT" , "   [-TT (Contrôle les appels de modèles - fonction de trace.)]" } , { "optionTG" , "   [-TG (Contrôle chaque événement de génération - fonction de trace.)]" } , { "optionTS" , "   [-TS (Contrôle chaque événement de sélection - fonction de trace.)]" } , { "optionTTC" , "   [-TTC (Contrôle les enfants du modèle lors de leur traitement - fonction de trace.)]" } , { "optionTCLASS" , "   [-TCLASS (Classe TraceListener pour les extensions de trace.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Indique si la validation se produit.  La validation est désactivée par défaut.)]" } , { "optionEDUMP" , "   [-EDUMP {nom de fichier optionnel} (Crée un vidage de pile en cas d'erreur.)]" } , { "optionXML" , "   [-XML (Utilise un formateur XML et ajoute un en-tête XML.)]" } , { "optionTEXT" , "   [-TEXT (Utilise un formateur de texte simple.)]" } , { "optionHTML" , "   [-HTML (Utilise un formateur HTML.)]" } , { "optionPARAM" , "[-PARAM nom expression (Définit un paramètre de feuille de style)]" } , { "noParsermsg1" , "Echec du processus XSL." } , { "noParsermsg2" , "** Analyseur introuvable **" } , { "noParsermsg3" , "Vérifiez le chemin d'accès des classes." } , { "noParsermsg4" , "XML Parser for Java disponible en téléchargement sur le site" } , { "noParsermsg5" , "AlphaWorks de IBM : http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER nom de classe complet (Les URI sont résolus par URIResolver)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER nom de classe complet (Les URI sont résolus par EntityResolver)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER nom de classe complet (La sérialisation de la sortie est effectuée par ContentHandler)]" } , { "optionLINENUMBERS" , "   [-L utilisation des numéros de ligne pour le document source]" } , { "optionMEDIA" , "[-MEDIA type_de_support (Utilise un attribut de support pour trouver la feuille de styles associée à un document.)]" } , { "optionFLAVOR" , "   [-FLAVOR sax_ou_dom (effectue la transformation à l'aide de SAX (s2s) ou de DOM (d2d).)] " } , { "optionDIAG" , "   [-DIAG (affiche la durée globale de la transformation - en millisecondes.)]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL (construction incrémentielle du DTM en définissant http://xml.apache.org/xalan/features/incremental true.)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE (pas de traitement d'optimisation des feuilles de styles en définissant http://xml.apache.org/xalan/features/optimize false.)]" } , { "optionRL" , "   [-RL récursivité_maxi (limite de la profondeur de la récursivité pour les feuilles de styles.)]" } , { "optionXO" , "   [-XO [nom_translet] (assignation du nom au translet généré)]" } , { "optionXD" , "   [-XD répertoire_cible (spécification d'un répertoire de destination pour translet)]" } , { "optionXJ" , "   [-XJ fichier_jar (réunion des classes translet dans un fichier jar appelé <fichier_jar>)]" } , { "optionXP" , "   [-XP module (spécification d'un préfixe de nom de module pour toutes les classes translet générées)]" } , { "optionXN" , "   [-XN (activation de la mise en ligne de modèle)]" } , { "optionXX" , "   [-XX (activation du débogage supplémentaire de sortie de message)]" } , { "optionXT" , "   [-XT (utilisation de translet pour la transformation si possible)]" } , { "diagTiming" , " --------- La transformation de {0} via {1} a pris {2} ms" } , { "recursionTooDeep" , "Trop grande imbrication de modèle. imbrication = {0}, modèle {1} {2}" } , { "nameIs" , "le nom est" } , { "matchPatternIs" , "le motif de correspondance est" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Erreur : " ; public static final String WARNING_HEADER = "Avertissement : " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemFallback extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_FALLBACK ; } public String getNodeName ( ) { return Constants . ELEMNAME_FALLBACK_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { } public void executeFallback ( TransformerImpl transformer ) throws TransformerException { int parentElemType = m_parentNode . getXSLToken ( ) ; if ( Constants . ELEMNAME_EXTENSIONCALL == parentElemType || Constants . ELEMNAME_UNDEFINED == parentElemType ) { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; transformer . executeChildTemplates ( this , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } else { System . out . println ( "Error!  parent of xsl:fallback must be an extension or unknown element!" ) ; } } } 	1	['5', '3', '0', '6', '12', '10', '3', '3', '5', '2', '44', '0', '0', '0.98', '0.7', '2', '4', '7.8', '1', '0.8', '2']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_ko extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "''{0}''의 런타임 내부 오류" } , { BasisLibrary . RUN_TIME_COPY_ERR , "<xsl:copy> 실행시 런타임 오류가 발생했습니다." } , { BasisLibrary . DATA_CONVERSION_ERR , "''{0}''에서 ''{1}''의 변환이 올바르지 않습니다." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "XSLTC에서 ''{0}'' 외부 함수를 지원하지 않습니다." } , { BasisLibrary . EQUALITY_EXPR_ERR , "등식에 알 수 없는 인수 유형이 있습니다." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "''{1}''에 대한 호출에서 잘못된 인수 유형 ''{0}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "''{1}'' 패턴을 사용하여 ''{0}'' 숫자 포맷을 시도 중입니다." } , { BasisLibrary . ITERATOR_CLONE_ERR , "''{0}'' 반복기를 복제할 수 없습니다." } , { BasisLibrary . AXIS_SUPPORT_ERR , "''{0}'' 축에 대한 반복기가 지원되지 않습니다." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "''{0}'' 유형화된 축에 대한 반복기가 지원되지 않습니다." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "''{0}'' 속성이 요소의 외부에 있습니다." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "''{0}''=''{1}'' 이름 공간 선언이 요소의 외부에 있습니다." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "''{0}'' 접두부에 대한 이름 공간이 선언되지 않았습니다." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "Source DOM의 잘못된 유형을 사용하여 DOMAdapter가 작성되었습니다." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "사용 중인 SAX 구문 분석기가 DTD 선언 이벤트를 처리하지 않습니다." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "사용 중인 SAX 구문 분석기가 XML 이름 공간을 지원하지 않습니다." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "''{0}'' URI 참조를 분석할 수 없습니다." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xalan . serialize ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . serializer . NamespaceMappings ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . xml . sax . SAXException ; public class SerializerUtils { public static void addAttribute ( SerializationHandler handler , int attr ) throws TransformerException { TransformerImpl transformer = ( TransformerImpl ) handler . getTransformer ( ) ; DTM dtm = transformer . getXPathContext ( ) . getDTM ( attr ) ; if ( SerializerUtils . isDefinedNSDecl ( handler , attr , dtm ) ) return ; String ns = dtm . getNamespaceURI ( attr ) ; if ( ns == null ) ns = "" ; try { handler . addAttribute ( ns , dtm . getLocalName ( attr ) , dtm . getNodeName ( attr ) , "CDATA" , dtm . getNodeValue ( attr ) ) ; } catch ( SAXException e ) { } } public static void addAttributes ( SerializationHandler handler , int src ) throws TransformerException { TransformerImpl transformer = ( TransformerImpl ) handler . getTransformer ( ) ; DTM dtm = transformer . getXPathContext ( ) . getDTM ( src ) ; for ( int node = dtm . getFirstAttribute ( src ) ; DTM . NULL != node ; node = dtm . getNextAttribute ( node ) ) { addAttribute ( handler , node ) ; } } public static void outputResultTreeFragment ( SerializationHandler handler , XObject obj , XPathContext support ) throws org . xml . sax . SAXException { int doc = obj . rtf ( ) ; DTM dtm = support . getDTM ( doc ) ; if ( null != dtm ) { for ( int n = dtm . getFirstChild ( doc ) ; DTM . NULL != n ; n = dtm . getNextSibling ( n ) ) { handler . flushPending ( ) ; if ( dtm . getNamespaceURI ( n ) == null ) handler . startPrefixMapping ( "" , "" ) ; dtm . dispatchToEvents ( n , handler ) ; } } } public static void processNSDecls ( SerializationHandler handler , int src , int type , DTM dtm ) throws TransformerException { try { if ( type == DTM . ELEMENT_NODE ) { for ( int namespace = dtm . getFirstNamespaceNode ( src , true ) ; DTM . NULL != namespace ; namespace = dtm . getNextNamespaceNode ( src , namespace , true ) ) { String prefix = dtm . getNodeNameX ( namespace ) ; String desturi = handler . getNamespaceURIFromPrefix ( prefix ) ; String srcURI = dtm . getNodeValue ( namespace ) ; if ( ! srcURI . equalsIgnoreCase ( desturi ) ) { handler . startPrefixMapping ( prefix , srcURI , false ) ; } } } else if ( type == DTM . NAMESPACE_NODE ) { String prefix = dtm . getNodeNameX ( src ) ; String desturi = handler . getNamespaceURIFromPrefix ( prefix ) ; String srcURI = dtm . getNodeValue ( src ) ; if ( ! srcURI . equalsIgnoreCase ( desturi ) ) { handler . startPrefixMapping ( prefix , srcURI , false ) ; } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } public static boolean isDefinedNSDecl ( SerializationHandler serializer , int attr , DTM dtm ) { if ( DTM . NAMESPACE_NODE == dtm . getNodeType ( attr ) ) { String prefix = dtm . getNodeNameX ( attr ) ; String uri = serializer . getNamespaceURIFromPrefix ( prefix ) ; if ( ( null != uri ) && uri . equals ( dtm . getStringValue ( attr ) ) ) return true ; } return false ; } public static void ensureNamespaceDeclDeclared ( SerializationHandler handler , DTM dtm , int namespace ) throws org . xml . sax . SAXException { String uri = dtm . getNodeValue ( namespace ) ; String prefix = dtm . getNodeNameX ( namespace ) ; if ( ( uri != null && uri . length ( ) > 0 ) && ( null != prefix ) ) { String foundURI ; NamespaceMappings ns = handler . getNamespaceMappings ( ) ; if ( ns != null ) { foundURI = ns . lookupNamespace ( prefix ) ; if ( ( null == foundURI ) || ! foundURI . equals ( uri ) ) { handler . startPrefixMapping ( prefix , uri , false ) ; } } } } } 	1	['7', '1', '0', '12', '37', '21', '5', '7', '7', '2', '250', '0', '0', '0', '0.404761905', '0', '0', '34.71428571', '4', '1.2857', '3']
package org . apache . xalan . processor ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetComposed ; import org . apache . xalan . templates . StylesheetRoot ; import org . xml . sax . Attributes ; class ProcessorStylesheetElement extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { super . startElement ( handler , uri , localName , rawName , attributes ) ; try { int stylesheetType = handler . getStylesheetType ( ) ; Stylesheet stylesheet ; if ( stylesheetType == StylesheetHandler . STYPE_ROOT ) { try { stylesheet = new StylesheetRoot ( handler . getSchema ( ) , handler . getStylesheetProcessor ( ) . getErrorListener ( ) ) ; } catch ( TransformerConfigurationException tfe ) { throw new TransformerException ( tfe ) ; } } else { Stylesheet parent = handler . getStylesheet ( ) ; if ( stylesheetType == StylesheetHandler . STYPE_IMPORT ) { StylesheetComposed sc = new StylesheetComposed ( parent ) ; parent . setImport ( sc ) ; stylesheet = sc ; } else { stylesheet = new Stylesheet ( parent ) ; parent . setInclude ( stylesheet ) ; } } stylesheet . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; stylesheet . setLocaterInfo ( handler . getLocator ( ) ) ; stylesheet . setPrefixes ( handler . getNamespaceSupport ( ) ) ; handler . pushStylesheet ( stylesheet ) ; setPropertiesFromAttributes ( handler , rawName , attributes , handler . getStylesheet ( ) ) ; handler . pushElemTemplateElement ( handler . getStylesheet ( ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { super . endElement ( handler , uri , localName , rawName ) ; handler . popElemTemplateElement ( ) ; handler . popStylesheet ( ) ; } } 	1	['3', '4', '0', '9', '29', '3', '2', '9', '2', '2', '107', '0', '0', '0.990566038', '0.666666667', '1', '1', '34.66666667', '1', '0.6667', '2']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_hu extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Hiba: Nem lehet '{' a kifejezéseken belül" } , { ER_ILLEGAL_ATTRIBUTE , "A(z) {0}-nak érvénytelen attribútuma van: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "A sourceNode értéke null az xsl:apply-imports metódusban!" } , { ER_CANNOT_ADD , "Nem lehet a(z) {0}-t felvenni a(z) {1}-ba" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "A sourceNode null a handleApplyTemplatesInstruction-ban!" } , { ER_NO_NAME_ATTRIB , "A(z) {0}-nak kell legyen name attribútuma." } , { ER_TEMPLATE_NOT_FOUND , "Nem található {0} nevű sablon" } , { ER_CANT_RESOLVE_NAME_AVT , "Nem lehet feloldani a név AVT-t az xsl:call-template-ben." } , { ER_REQUIRES_ATTRIB , "{0}-nek attribútum szükséges: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0}-nek kell legyen ''test'' attribútuma." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Rossz érték a level attribútumban: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "A feldolgozási utasítás neve nem lehet 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "A feldolgozási utasítás neve érvényes NCName kell legyen: {0}" } , { ER_NEED_MATCH_ATTRIB , "A(z) {0}-nek kell legyen illeszkedési attribútuma, ha van módja." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "A(z) {0}-nak kell vagy név vagy illeszkedési attribútum." } , { ER_CANT_RESOLVE_NSPREFIX , "Nem lehet feloldani a névtér előtagot: {0}" } , { ER_ILLEGAL_VALUE , "Az xml:space értéke érvénytelen: {0}" } , { ER_NO_OWNERDOC , "A leszármazott csomópontnak nincs tulajdonos dokumentuma!" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement hiba: {0}" } , { ER_NULL_CHILD , "Kísérlet null leszármazott felvételére!" } , { ER_NEED_SELECT_ATTRIB , "A(z) {0}-nak kell kiválasztási attribútum." } , { ER_NEED_TEST_ATTRIB , "Az xsl:when-nek kell legyen 'test' attribútuma." } , { ER_NEED_NAME_ATTRIB , "Az xsl:param-nak kell legyen 'name' attribútuma." } , { ER_NO_CONTEXT_OWNERDOC , "A környezetnek nincs tulajdonos dokumentuma!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Nem lehet XML TransformerFactory Liaison-t létrehozni: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "A Xalan processz sikertelen volt." } , { ER_NOT_SUCCESSFUL , "Xalan: sikertelen volt." } , { ER_ENCODING_NOT_SUPPORTED , "A kódolás nem támogatott: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Nem lehet TraceListener-t létrehozni: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "Az xsl:key-nek kell legyen 'name' attribútuma!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "Az xsl:key-nek kell legyen 'match' attribútuma!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "Az xsl:key-nek kell legyen 'use' attribútuma!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) A(z) {0}-nek kell legyen egy ''elements'' attribútuma!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) A(z) {0}-nek hiányzik a ''prefix'' attribútuma" } , { ER_BAD_STYLESHEET_URL , "A stíluslap URL rossz: {0}" } , { ER_FILE_NOT_FOUND , "A stíluslap fájl nem található: {0}" } , { ER_IOEXCEPTION , "IO kivétel történt a stíluslap fájlnál: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) A(z) {0} href attribútuma nem található" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) A(z) {0} közvetlenül vagy közvetetten tartalmazza saját magát!" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude hiba, {0}" } , { ER_MISSING_LANG_ATTRIB , "(stylesheetHandler) A(z) {0}-nek hiányzik a ''lang'' attribútuma" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) Rosszul elhelyezett {0} elem?? hiányzik a 'component' tárolóelem" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Csak egy Element-be, DocumentFragment-be, Document-be vagy PrintWriter-be lehet kimenetet küldeni." } , { ER_PROCESS_ERROR , "StylesheetRoot.process hiba" } , { ER_UNIMPLNODE_ERROR , "UnImplNode hiba: {0}" } , { ER_NO_SELECT_EXPRESSION , "Hiba! Az xpath kiválasztási kifejezés nem található (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Nem lehet sorbarakni az XSLProcessor-t!" } , { ER_NO_INPUT_STYLESHEET , "Nem adott meg stíluslap bemenetet!" } , { ER_FAILED_PROCESS_STYLESHEET , "Nem sikerült feldolgozni a stíluslapot!" } , { ER_COULDNT_PARSE_DOC , "Nem lehet elemezni a(z) {0} dokumentumot!" } , { ER_COULDNT_FIND_FRAGMENT , "Nem található a darab: {0}" } , { ER_NODE_NOT_ELEMENT , "A darab azonosító által mutatott csomópont nem elem: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "A for-each-nek legalább egy match vagy egy name attribútuma kell legyen" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "A sablonoknak vagy match vagy name attribútumuk kell legyen" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Nincs klónja egy dokumentumdarabnak!" } , { ER_CANT_CREATE_ITEM , "Nem lehet elemet létrehozni az eredményfában: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "Az xml:space-nek a forrás XML-ben tiltott értéke van: {0}" } , { ER_NO_XSLKEY_DECLARATION , "Nincs xsl:key deklaráció a(z) {0}-hoz!" } , { ER_CANT_CREATE_URL , "Hiba! Nem lehet URL-t létrehozni ehhez: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "Az xsl:functions nem támogatott" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory hiba" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) A(z) {0} nem megengedett a stíluslapon belül!" } , { ER_RESULTNS_NOT_SUPPORTED , "A result-ns többé már nem támogatott!  Használja inkább az xsl:output-ot." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "A default-space többé már nem támogatott!  Használja inkább az xsl:strip-space-t vagy az  xsl:preserve-space-t." } , { ER_INDENTRESULT_NOT_SUPPORTED , "Az indent-result többé már nem támogatott!  Használja inkább az xsl:output-ot." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) A(z) {0}-nak tiltott attribútuma van: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Ismeretlen XSL elem: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) Az xsl:sort csak az xsl:apply-templates-szel vagy xsl:for-each-el együtt használható." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) Rosszul elhelyezett xsl:when!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) Az xsl:when szülője nem xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) Rosszul elhelyezett xsl:otherwise!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) Az xsl:otherwise szülője nem xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) A(z) {0} nem megengedett sablonok belsejében!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) A(z) {0} kiterjesztés névtér előtag {1} ismeretlen" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Az importálások csak a stíluslap első elemei lehetnek!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) A(z) {0} közvetlenül vagy közvetve tartalmazza saját magát!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:space értéke nem megengedett: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "A processStylesheet sikertelen volt!" } , { ER_SAX_EXCEPTION , "SAX kivétel" } , { ER_XSLT_ERROR , "XSLT hiba" } , { ER_CURRENCY_SIGN_ILLEGAL , "A pénzjel nem megengedett a formátum minta karakterláncban" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "A document funkció nem támogatott a Stylesheet DOM-ban!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Nem lehet feloldani az előtagot egy nem-előtag feloldónak!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Átirányítás kiterjesztés: Nem lehet megkapni a fájlnevet - a file vagy select attribútumnak egy érvényes karakterláncot kell visszaadnia." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Nem lehet FormatterListener-t építeni az átirányítás kiterjesztésben!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Az előtag az exclude-result-prefixes-ben nem érvényes: {0}" } , { ER_MISSING_NS_URI , "Hiányzik a megadott előtag névtér URI-ja" } , { ER_MISSING_ARG_FOR_OPTION , "Hiányzik az opció argumentuma: {0}" } , { ER_INVALID_OPTION , "Érvénytelen opció: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Rossz formátumú karakterlánc: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "Az xsl:stylesheet-nek kell legyen 'version' attribútuma!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "A(z) {0} attibútum értéke érvénytelen: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "Az xsl:choose-hoz egy xsl:when szükséges" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "Az xsl:apply-imports nem megengedett xsl:for-each-en belül" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Nem használhat DTMLiaison-t kimeneti DOM csomópontként... adjon át inkább egy org.apache.xpath.DOM2Helper-t!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Nem használhat DTMLiaison-t bemeneti DOM csomópontként... adjon át inkább egy org.apache.xpath.DOM2Helper-t!" } , { ER_CALL_TO_EXT_FAILED , "A kiterjesztés-elem meghívása sikertelen volt: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Az előtagnak egy névtérre kell feloldódnia: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Érvénytelen UTF-16 helyettesítés: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "A(z) {0} xsl:attribute-set-et saját magával használta, ami végtelen ciklust eredményez." } , { ER_CANNOT_MIX_XERCESDOM , "Nem keverheti a nem Xerces-DOM bemenetet a Xerces-DOM kimenettel!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "Az ElemTemplateElement.readObject metódusban: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Egynél több '{0}' nevű sablont találtam" } , { ER_INVALID_KEY_CALL , "Érvénytelen függvényhívás: rekurzív key() hívások nem megengedettek" } , { ER_REFERENCING_ITSELF , "A(z) {0} változó közvetlenül vagy közvetve önmagára hivatkozik!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "A bemeneti csomópont nem lehet null egy DOMSource-ban a newTemplates-hez!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Az osztály fájl nem található a(z) {0} opcióhoz" } , { ER_REQUIRED_ELEM_NOT_FOUND , "A szükséges elem nem található: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "Az InputStream nem lehet null" } , { ER_URI_CANNOT_BE_NULL , "Az URI nem lehet null" } , { ER_FILE_CANNOT_BE_NULL , "A fájl nem lehet null" } , { ER_SOURCE_CANNOT_BE_NULL , "Az InputSource nem lehet null" } , { ER_CANNOT_INIT_BSFMGR , "Nem lehet inicializálni a BSF kezelőt" } , { ER_CANNOT_CMPL_EXTENSN , "Nem lehet lefordítani a kiterjesztést" } , { ER_CANNOT_CREATE_EXTENSN , "Nem lehet létrehozni a kiterjesztést ({0}) {1} miatt" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "Az {0} metódus példány metódushívásához szükség van egy objektumpéldányra első argumentumként" } , { ER_INVALID_ELEMENT_NAME , "Érvénytelen elemnevet adott meg {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Az elemnév metódus statikus {0} kell legyen" } , { ER_EXTENSION_FUNC_UNKNOWN , "{0} kiterjesztés funkció : A(z) {1} ismeretlen" } , { ER_MORE_MATCH_CONSTRUCTOR , "Több legjobb illeszkedés a(z) {0} konstruktorára" } , { ER_MORE_MATCH_METHOD , "Több legjobb illeszkedés a(z) {0} metódusra" } , { ER_MORE_MATCH_ELEMENT , "Több legjobb illeszkedés a(z) {0} elem metódusra" } , { ER_INVALID_CONTEXT_PASSED , "Érvénytelen környzetet adott át a(z) {0} kiértékeléséhez" } , { ER_POOL_EXISTS , "A tároló már létezik" } , { ER_NO_DRIVER_NAME , "Nem adott meg meghajtónevet" } , { ER_NO_URL , "Nem adott meg URL-t" } , { ER_POOL_SIZE_LESSTHAN_ONE , "A tároló mérete egynél kisebb!" } , { ER_INVALID_DRIVER , "Érvénytelen meghajtónevet adott meg!" } , { ER_NO_STYLESHEETROOT , "Nem található a stíluslap gyökere!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Tiltott érték az xml:space-hez" } , { ER_PROCESSFROMNODE_FAILED , "A processFromNode nem sikerült" } , { ER_RESOURCE_COULD_NOT_LOAD , "Az erőforrást [ {0} ] nem lehet betölteni: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Pufferméret <= 0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Ismeretlen hiba a kiterjesztés hívásánál" } , { ER_NO_NAMESPACE_DECL , "A(z) {0} előtaghoz nem tartozik névtér deklaráció" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Elem tartalom nem megengedett a(z) {0} lang=javaclass-hoz" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Stíluslap által irányított leállás" } , { ER_ONE_OR_TWO , "1 vagy 2" } , { ER_TWO_OR_THREE , "2 vagy 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Nem lehet betölteni a(z) {0}-t (ellenőrizze a CLASSPATH-t), most csak az alapértelmezéseket használjuk" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Nem lehet inicializálni az alapértelmezett sablonokat" } , { ER_RESULT_NULL , "Az eredmény nem lehet null" } , { ER_RESULT_COULD_NOT_BE_SET , "Nem lehet beállítani az eredményt" } , { ER_NO_OUTPUT_SPECIFIED , "Nem adott meg kimenetet" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Nem alakítható át {0} típusú eredménnyé" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Nem alakítható át {0} típusú forrássá" } , { ER_NULL_CONTENT_HANDLER , "Null tartalomkezelő" } , { ER_NULL_ERROR_HANDLER , "Null hibakezelő" } , { ER_CANNOT_CALL_PARSE , "A parse nem hívható meg, ha a ContentHandler-t nem állította be" } , { ER_NO_PARENT_FOR_FILTER , "A szűrőnek nincs szülője" } , { ER_NO_STYLESHEET_IN_MEDIA , "Nincs stíluslap ebben: {0}, adathordozó: {1}" } , { ER_NO_STYLESHEET_PI , "Nem található xml-stylesheet PI itt: {0}" } , { ER_NOT_SUPPORTED , "Nem támogatott: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "A(z) {0} tulajdonság értéke Boolean példány kell legyen" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "Nem lehet eljutni a külső parancsfájlhoz a(z) {0}-n" } , { ER_RESOURCE_COULD_NOT_FIND , "A(z) [ {0} ] erőforrás nem található.\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "A kimeneti tulajdonság nem felismerhető: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Nem sikerült ElemLiteralResult példányt létrehozni" } , { ER_VALUE_SHOULD_BE_NUMBER , "A(z) {0} tulajdonság értéke értelmezhető szám kell legyen" } , { ER_VALUE_SHOULD_EQUAL , "A(z) {0} értéke igen vagy nem kell legyen" } , { ER_FAILED_CALLING_METHOD , "Nem sikerült meghívni a(z) {0} metódust" } , { ER_FAILED_CREATING_ELEMTMPL , "Nem sikerült ElemTemplateElement példányt létrehozni" } , { ER_CHARS_NOT_ALLOWED , "Karakterek nem megengedettek a dokumentumnak ezen a pontján" } , { ER_ATTR_NOT_ALLOWED , "A(z) \"{0}\" attribútum nem megengedett a(z) {1} elemhez!" } , { ER_BAD_VALUE , "{0} rossz érték {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "{0} attribútum érték nem található " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "{0} attribútum érték ismeretlen " } , { ER_NULL_URI_NAMESPACE , "Kísérlet egy névtér előtag létrehozására null URI-val" } , { ER_NUMBER_TOO_BIG , "Kísérlet egy szám megformázására, ami nagyobb, mint a legnagyobb Long egész" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Nem található a(z) {0} SAX1 meghajtóosztály" } , { ER_SAX1_DRIVER_NOT_LOADED , "A(z) {0} SAX1 meghajtóosztály megvan, de nem törlthető be" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "A(z) {0} SAX1 meghajtóosztály betöltve, de nem lehet példányt létrehozni belőle" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "A(z) {0} SAX1 meghajtóosztály nem implementálja az org.xml.sax.Parser-t" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Nem adta meg az org.xml.sax.parser rendszertulajdonságot" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Az elemző argumentuma nem lehet null" } , { ER_FEATURE , "Képesség: {0}" } , { ER_PROPERTY , "Tulajdonság: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Null entitás feloldó" } , { ER_NULL_DTD_HANDLER , "Null DTD kezelő" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Nem adott meg meghajtónevet!" } , { ER_NO_URL_SPECIFIED , "Nem adott meg URL-t!" } , { ER_POOLSIZE_LESS_THAN_ONE , "A tároló mérete 1-nél kisebb!" } , { ER_INVALID_DRIVER_NAME , "Érvénytelen meghajtónevet adott meg!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Programozói hiba! A kifejezésnek nincs ElemTemplateElement szülője!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Programozói értesítés RundundentExprEliminator hívásban: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} nem engedélyezett a stíluslap ezen helyén!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Nem-szeparátor szöveg nem megengedett a stíluslap ezen helyén!" } , { INVALID_TCHAR , "Tiltott értéket használt a(z) {0} attribútumhoz: {1}.  A CHAR típusú attribútum csak 1 karakter lehet!" } , { INVALID_QNAME , "Tiltott értéket használt a(z) {0} CHAR attribútumhoz: {1}." } , { INVALID_ENUM , "Tiltott értéket használt a(z) {0} ENUM attribútumhoz: {1}.  Az érvényes értékek: {2}." } , { INVALID_NMTOKEN , "Tiltott értéket használt a(z) {0} NMTOKEN attribútumhoz: {1}. " } , { INVALID_NCNAME , "Tiltott értéket használt a(z) {0} NCNAME attribútumhoz: {1}. " } , { INVALID_BOOLEAN , "Tiltott értéket használt a(z) {0} logikai attribútumhoz: {1}. " } , { INVALID_NUMBER , "Tiltott értéket használt a(z) {0} szám attribútumhoz: {1}. " } , { ER_ARG_LITERAL , "A(z) {0} argumentuma az illeszkedési mintában egy literál kell legyen." } , { ER_DUPLICATE_GLOBAL_VAR , "Kétszer szerepel a globális változó-deklaráció." } , { ER_DUPLICATE_VAR , "Kétszer szerepel a változó-deklaráció." } , { ER_TEMPLATE_NAME_MATCH , "Az xsl:template-nek kell legyen neve vagy illeszkedési attribútuma (vagy mindkettő)" } , { ER_INVALID_PREFIX , "Az előtag az exclude-result-prefixes-ben nem érvényes: {0}" } , { ER_NO_ATTRIB_SET , "A(z) {0} nevű attribute-set nem létezik" } , { WG_FOUND_CURLYBRACE , "'}'-t találtunk, de nincs attribútumsablon megnyitva!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Figyelmeztetés: A count attribútum nem felel meg a egy felmenőnek az xsl:number-ben! Cél = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Régi szintaktika: Az 'expr' attribútum neve 'select'-re változott." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Az Xalan még nem kezeli a locale nevet a format-number függvényben." } , { WG_LOCALE_NOT_FOUND , "Figyelmeztetés: Nem található az xml:lang={0} értékhez tartozó locale" } , { WG_CANNOT_MAKE_URL_FROM , "Nem készíthető URL ebből: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "A kér dokumentum nem tölthető be: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Nem található Collator a <sort xml:lang={0}-hez" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Régi szintaktika: a functions utasítás {0} URL-t kell használjon" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "a kódolás nem támogatott: {0}, UTF-8-at használunk" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "a kódolás nem támogatott: {0}, Java {1}-t használunk" } , { WG_SPECIFICITY_CONFLICTS , "Specifikussági konfliktust találtunk: {0} A stíluslapon legutoljára megtaláltat használjuk." } , { WG_PARSING_AND_PREPARING , "========= {0} elemzése és előkészítése ==========" } , { WG_ATTR_TEMPLATE , "Attr sablon, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Illesztési konfliktus az xsl:strip-space és az xsl:preserve-space között" } , { WG_ATTRIB_NOT_HANDLED , "A Xalan még nem kezeli a(z) {0} attribútumot!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Nem találtuk meg a deklarációt a decimális formátumhoz: {0}" } , { WG_OLD_XSLT_NS , "Hiányzó vagy helytelen XSLT névtér. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Csak az alapértelmezett xsl:decimal-format deklaráció megengedett." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "Az xsl:decimal-format neveknek egyedieknek kell lenniük. A(z) \"{0}\" név meg lett ismételve." } , { WG_ILLEGAL_ATTRIBUTE , "A(z) {0}-nak érvénytelen attribútuma van: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Nem lehet feloldani a névtér előtagot: {0}. A csomópont figyelmen kívül marad." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "Az xsl:stylesheet-nek kell legyen 'version' attribútuma!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Nem megengedett attribútumnév: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Tiltott értéket használt a(z) {0} attribútumhoz: {1}" } , { WG_EMPTY_SECOND_ARG , "A document függvény második argumentumából előálló csomóponthalmaz üres. Üres node-készletetet adok vissza." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "A(z) xsl:processing-instruction  név 'name' attribútuma nem lehet 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "A(z) xsl:processing-instruction  név 'name' attribútuma érvényes NCName kell legyen: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Nem lehet {0} attribútumat felvenni a gyermek node-ok után vagy mielőtt egy elem létrejönne.  Az attribútum figyelmen kívül marad." } , { "ui_language" , "hu" } , { "help_language" , "hu" } , { "language" , "hu" } , { "BAD_CODE" , "A createMessage paramétere nincs a megfelelő tartományban" } , { "FORMAT_FAILED" , "Kivétel történt a messageFormat hívás alatt" } , { "version" , ">>>>>>> Xalan verzió " } , { "version2" , "<<<<<<<" } , { "yes" , "igen" } , { "line" , "Sor #" } , { "column" , "Oszlop #" } , { "xsldone" , "XSLProcessor: kész" } , { "xslProc_option" , "Xalan-J parancssori Process osztály opciók:" } , { "xslProc_option" , "Xalan-J parancssori Process osztály opciók:" } , { "xslProc_invalid_xsltc_option" , "A(z) {0} opció nem támogatott XSLTC módban." } , { "xslProc_invalid_xalan_option" , "A(z) {0} opció csak -XSLTC-vel együtt használható." } , { "xslProc_no_input" , "Hiba: Nem adott meg stíluslapot vagy bemeneti xml-t. Futtassa ezt a parancsot kapcsolók nélkül a használati utasítások megjelenítésére." } , { "xslProc_common_options" , "-Általános opciók-" } , { "xslProc_xalan_options" , "-Xalan opciók-" } , { "xslProc_xsltc_options" , "-XSLTC opciók-" } , { "xslProc_return_to_continue" , "(nyomja la a <return> gombot a folytatáshoz)" } , { "optionXSLTC" , "   [-XSLTC (XSLTC-t használ a transzformáláshoz)]" } , { "optionIN" , "   [-IN bemenetiXMLURL]" } , { "optionXSL" , "   [-XSL XSLTranszformációsURL]" } , { "optionOUT" , "   [-OUT kimenetiFájlnév]" } , { "optionLXCIN" , "   [-LXCIN lefordítottStílislapFájlnévBe]" } , { "optionLXCOUT" , "   [-LXCOUT lefordítottStíluslapFájlnévKi]" } , { "optionPARSER" , "   [-PARSER az elemzőkapcsolat teljesen meghatározott osztályneve]" } , { "optionE" , "   [-E (Nem bontja ki az entitás hivatkozásokat)]" } , { "optionV" , "   [-E (Nem bontja ki az entitás hivatkozásokat)]" } , { "optionQC" , "   [-QC (Csendes mintakonfliktus figyelmeztetések)]" } , { "optionQ" , "   [-Q  (Csendes mód)]" } , { "optionLF" , "   [-LF (A soremeléseket csak kimenet esetén használja {alapértelmezés: CR/LF})]" } , { "optionCR" , "   [-CR (A kocsivissza karaktert csak kimenet esetén használja {alapértelmezés: CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Mely karaktereket kell escape-elni {alapértelmezés: <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Meghatározza, hogy hány szóközzel kell beljebb kezdeni {alapértelmezés: 0})]" } , { "optionTT" , "   [-TT (Nyomköveti a sablonokat, ahogy azokat meghívják.)]" } , { "optionTG" , "   [-TG (Nyomköveti az összes generálási eseményt.)]" } , { "optionTS" , "   [-TS (Nyomköveti az összes kiválasztási eseményt.)]" } , { "optionTTC" , "   [-TTC (Nyomköveti a sablon-leszármazottakat, ahogy azokat feldolgozzák.)]" } , { "optionTCLASS" , "   [-TCLASS (TraceListener osztály a nyomkövetési kiterjesztésekhez.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Beállítja, hogy legyen-e érvényességvizsgálat.  Alapértelmezésben nincs érvényességvizsgálat.)]" } , { "optionEDUMP" , "   [-EDUMP {opcionális fájlnév} (Hibánál stackdump-ot hajt végre.)]" } , { "optionXML" , "   [-XML (XML formázó használata és XML fejléc hozzáadása.)]" } , { "optionTEXT" , "   [-TEXT (Egyszerű szövegformázó használata.)]" } , { "optionHTML" , "   [-HTML (HTML formázó használata.)]" } , { "optionPARAM" , "   [-PARAM név kifejezés (Beállít egy stíluslap paramétert)]" } , { "noParsermsg1" , "Az XSL processz sikertelen volt." } , { "noParsermsg2" , "** Az elemző nem található **" } , { "noParsermsg3" , "Kérem, ellenőrizze az osztály elérési utat." } , { "noParsermsg4" , "Ha önnek nincs meg az IBM Java XML elemzője, akkor letöltheti az" } , { "noParsermsg5" , "az IBM AlphaWorks weblapról: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER teljes osztálynév (az URIResolver fogja feloldani az URI-kat)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER teljes osztálynév (az EntityResolver fogja feloldani az entitásokat)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER teljes osztálynév (a ContentHandler fogja sorosítani a kimenetet)]" } , { "optionLINENUMBERS" , "   [-L sorszámokat használ a forrásdokumentumhoz]" } , { "optionMEDIA" , "[-MEDIA adathordozóTípus (a media attribútum segítségével megkeresi a dokumentumhoz tartozó stíluslapot.)]" } , { "optionFLAVOR" , "[-FLAVOR ízlésNév (Explicit használja az s2s=SAX-ot vagy d2d=DOM-ot a transzformációhoz.)]" } , { "optionDIAG" , "[-DIAG (Kiírja, hogy összesen hány ezredmásodpercig tartott a transzformáció.)]" } , { "optionINCREMENTAL" , "[-INCREMENTAL (növekményes DTM létrehozást igényel a http://xml.apache.org/xalan/features/incremental igazra állításával.)]" } , { "optionNOOPTIMIMIZE" , "[-NOOPTIMIMIZE (nem igényel stíluslap optimizálást a http://xml.apache.org/xalan/features/optimize hamisra állítását.)]" } , { "optionRL" , "[-RL rekurziókorlát (numerikusan korlátozza a stílislap rekurzió mélységét.)]" } , { "optionXO" , "   [-XO [transletNeve] (a nevet rendeli a generált translethez)]" } , { "optionXD" , "   [-XD célAlkönyvtár (a translet cél-alkönyvtára)]" } , { "optionXJ" , "   [-XJ jarfájl (a translet osztályokat a megadott <jarfájl>-ba csomagolja)]" } , { "optionXP" , "   [-XP csomag (megadja a generált translet osztályok név-prefixét)]" } , { "optionXN" , "   [-XN (engedélyezi a template inlining optimalizálást)]" } , { "optionXX" , "   [-XX (bekapcsolja a további hibakeresési kimenetet)]" } , { "optionXT" , "   [-XT (translet-et használt az átalakításhoz, ha lehet)]" } , { "diagTiming" , "--------- A(z) {0} tarnszformációa a(z) {1}-el {2} ms-ig tartott" } , { "recursionTooDeep" , "A sablonon egymásba ágyazása túl mély. Beágyazás = {0}, sablon: {1} {2}" } , { "nameIs" , "A név:" } , { "matchPatternIs" , "Az illeszkedési minta:" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Hiba: " ; public static final String WARNING_HEADER = "Figyelmeztetés: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MINTA " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "hu" , "HU" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xalan . trace ; import java . lang . reflect . Method ; import java . util . TooManyListenersException ; import java . util . Vector ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; public class TraceManager { private TransformerImpl m_transformer ; public TraceManager ( TransformerImpl transformer ) { m_transformer = transformer ; } private Vector m_traceListeners = null ; public void addTraceListener ( TraceListener tl ) throws TooManyListenersException { TransformerImpl . S_DEBUG = true ; if ( null == m_traceListeners ) m_traceListeners = new Vector ( ) ; m_traceListeners . addElement ( tl ) ; } public void removeTraceListener ( TraceListener tl ) { if ( null != m_traceListeners ) { m_traceListeners . removeElement ( tl ) ; if ( 0 == m_traceListeners . size ( ) ) m_traceListeners = null ; } } public void fireGenerateEvent ( GenerateEvent te ) { if ( null != m_traceListeners ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; tl . generated ( te ) ; } } } public boolean hasTraceListeners ( ) { return ( null != m_traceListeners ) ; } public void fireTraceEvent ( ElemTemplateElement styleNode ) { if ( hasTraceListeners ( ) ) { int sourceNode = m_transformer . getXPathContext ( ) . getCurrentNode ( ) ; Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireTraceEvent ( new TracerEvent ( m_transformer , source , m_transformer . getMode ( ) , styleNode ) ) ; } } public void fireTraceEndEvent ( ElemTemplateElement styleNode ) { if ( hasTraceListeners ( ) ) { int sourceNode = m_transformer . getXPathContext ( ) . getCurrentNode ( ) ; Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireTraceEndEvent ( new TracerEvent ( m_transformer , source , m_transformer . getMode ( ) , styleNode ) ) ; } } public void fireTraceEndEvent ( TracerEvent te ) { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; if ( tl instanceof TraceListenerEx2 ) { ( ( TraceListenerEx2 ) tl ) . traceEnd ( te ) ; } } } } public void fireTraceEvent ( TracerEvent te ) { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; tl . trace ( te ) ; } } } public void fireSelectedEvent ( int sourceNode , ElemTemplateElement styleNode , String attributeName , XPath xpath , XObject selection ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireSelectedEvent ( new SelectionEvent ( m_transformer , source , styleNode , attributeName , xpath , selection ) ) ; } } public void fireSelectedEndEvent ( int sourceNode , ElemTemplateElement styleNode , String attributeName , XPath xpath , XObject selection ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { Node source = m_transformer . getXPathContext ( ) . getDTM ( sourceNode ) . getNode ( sourceNode ) ; fireSelectedEndEvent ( new EndSelectionEvent ( m_transformer , source , styleNode , attributeName , xpath , selection ) ) ; } } public void fireSelectedEndEvent ( EndSelectionEvent se ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; if ( tl instanceof TraceListenerEx ) ( ( TraceListenerEx ) tl ) . selectEnd ( se ) ; } } } public void fireSelectedEvent ( SelectionEvent se ) throws javax . xml . transform . TransformerException { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; tl . selected ( se ) ; } } } public void fireExtensionEndEvent ( Method method , Object instance , Object [ ] arguments ) { ExtensionEvent ee = new ExtensionEvent ( m_transformer , method , instance , arguments ) ; if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; if ( tl instanceof TraceListenerEx3 ) { ( ( TraceListenerEx3 ) tl ) . extensionEnd ( ee ) ; } } } } public void fireExtensionEvent ( Method method , Object instance , Object [ ] arguments ) { ExtensionEvent ee = new ExtensionEvent ( m_transformer , method , instance , arguments ) ; if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; if ( tl instanceof TraceListenerEx3 ) { ( ( TraceListenerEx3 ) tl ) . extension ( ee ) ; } } } } public void fireExtensionEndEvent ( ExtensionEvent ee ) { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; if ( tl instanceof TraceListenerEx3 ) { ( ( TraceListenerEx3 ) tl ) . extensionEnd ( ee ) ; } } } } public void fireExtensionEvent ( ExtensionEvent ee ) { if ( hasTraceListeners ( ) ) { int nListeners = m_traceListeners . size ( ) ; for ( int i = 0 ; i < nListeners ; i ++ ) { TraceListener tl = ( TraceListener ) m_traceListeners . elementAt ( i ) ; if ( tl instanceof TraceListenerEx3 ) { ( ( TraceListenerEx3 ) tl ) . extension ( ee ) ; } } } } } 	1	['17', '1', '0', '45', '39', '0', '30', '16', '17', '0.3125', '435', '1', '1', '0', '0.165441176', '0', '0', '24.47058824', '4', '2.3529', '2']
package org . apache . xalan . xsltc . dom ; import java . net . URL ; import java . net . MalformedURLException ; import java . util . Enumeration ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMSource ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMEnhancedForDTM ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . ref . DTMAxisIterNodeList ; import org . apache . xml . dtm . ref . DTMDefaultBase ; import org . apache . xml . dtm . ref . EmptyIterator ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . apache . xml . dtm . ref . sax2dtm . SAX2DTM2 ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . serializer . ToXMLSAXHandler ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . utils . SystemIDResolver ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Entity ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public final class SAXImpl extends SAX2DTM2 implements DOMEnhancedForDTM , DOMBuilder { private int _uriCount = 0 ; private int _prefixCount = 0 ; private int [ ] _xmlSpaceStack ; private int _idx = 1 ; private boolean _preserve = false ; private static final String XML_STRING = "xml:" ; private static final String XML_PREFIX = "xml" ; private static final String XMLSPACE_STRING = "xml:space" ; private static final String PRESERVE_STRING = "preserve" ; private static final String XMLNS_PREFIX = "xmlns" ; private static final String XML_URI = "http://www.w3.org/XML/1998/namespace" ; private boolean _escaping = true ; private boolean _disableEscaping = false ; private int _textNodeToProcess = DTM . NULL ; private final static String EMPTYSTRING = "" ; private final static DTMAxisIterator EMPTYITERATOR = EmptyIterator . getInstance ( ) ; private int _namesSize = - 1 ; private Hashtable _nsIndex = new Hashtable ( ) ; private int _size = 0 ; private BitArray _dontEscape = null ; private String _documentURI = null ; static private int _documentURIIndex = 0 ; private Document _document ; private Hashtable _node2Ids = null ; private boolean _hasDOMSource = false ; private XSLTCDTMManager _dtmManager ; private Node [ ] _nodes ; private NodeList [ ] _nodeLists ; private final static String XML_LANG_ATTRIBUTE = "http://www.w3.org/XML/1998/namespace:@lang" ; public void setDocumentURI ( String uri ) { if ( uri != null ) { setDocumentBaseURI ( SystemIDResolver . getAbsoluteURI ( uri ) ) ; } } public String getDocumentURI ( ) { String baseURI = getDocumentBaseURI ( ) ; return ( baseURI != null ) ? baseURI : "rtf" + _documentURIIndex ++ ; } public String getDocumentURI ( int node ) { return getDocumentURI ( ) ; } public void setupMapping ( String [ ] names , String [ ] urisArray , int [ ] typesArray , String [ ] namespaces ) { } public String lookupNamespace ( int node , String prefix ) throws TransletException { int anode , nsnode ; final AncestorIterator ancestors = new AncestorIterator ( ) ; if ( isElement ( node ) ) { ancestors . includeSelf ( ) ; } ancestors . setStartNode ( node ) ; while ( ( anode = ancestors . next ( ) ) != DTM . NULL ) { final NamespaceIterator namespaces = new NamespaceIterator ( ) ; namespaces . setStartNode ( anode ) ; while ( ( nsnode = namespaces . next ( ) ) != DTM . NULL ) { if ( getLocalName ( nsnode ) . equals ( prefix ) ) { return getNodeValue ( nsnode ) ; } } } BasisLibrary . runTimeError ( BasisLibrary . NAMESPACE_PREFIX_ERR , prefix ) ; return null ; } public boolean isElement ( final int node ) { return getNodeType ( node ) == DTM . ELEMENT_NODE ; } public boolean isAttribute ( final int node ) { return getNodeType ( node ) == DTM . ATTRIBUTE_NODE ; } public int getSize ( ) { return getNumberOfNodes ( ) ; } public void setFilter ( StripFilter filter ) { } public boolean lessThan ( int node1 , int node2 ) { if ( node1 == DTM . NULL ) { return false ; } if ( node2 == DTM . NULL ) { return true ; } return ( node1 < node2 ) ; } public Node makeNode ( int index ) { if ( _nodes == null ) { _nodes = new Node [ _namesSize ] ; } int nodeID = makeNodeIdentity ( index ) ; if ( nodeID < 0 ) { return null ; } else if ( nodeID < _nodes . length ) { return ( _nodes [ nodeID ] != null ) ? _nodes [ nodeID ] : ( _nodes [ nodeID ] = new DTMNodeProxy ( ( DTM ) this , index ) ) ; } else { return new DTMNodeProxy ( ( DTM ) this , index ) ; } } public Node makeNode ( DTMAxisIterator iter ) { return makeNode ( iter . next ( ) ) ; } public NodeList makeNodeList ( int index ) { if ( _nodeLists == null ) { _nodeLists = new NodeList [ _namesSize ] ; } int nodeID = makeNodeIdentity ( index ) ; if ( nodeID < 0 ) { return null ; } else if ( nodeID < _nodeLists . length ) { return ( _nodeLists [ nodeID ] != null ) ? _nodeLists [ nodeID ] : ( _nodeLists [ nodeID ] = new DTMAxisIterNodeList ( this , new SingletonIterator ( index ) ) ) ; } else { return new DTMAxisIterNodeList ( this , new SingletonIterator ( index ) ) ; } } public NodeList makeNodeList ( DTMAxisIterator iter ) { return new DTMAxisIterNodeList ( this , iter ) ; } public class TypedNamespaceIterator extends NamespaceIterator { private String _nsPrefix ; public TypedNamespaceIterator ( int nodeType ) { super ( ) ; if ( m_expandedNameTable != null ) { _nsPrefix = m_expandedNameTable . getLocalName ( nodeType ) ; } } public int next ( ) { if ( ( _nsPrefix == null ) || ( _nsPrefix . length ( ) == 0 ) ) { return ( END ) ; } int node = END ; for ( node = super . next ( ) ; node != END ; node = super . next ( ) ) { if ( _nsPrefix . compareTo ( getLocalName ( node ) ) == 0 ) { return returnNode ( node ) ; } } return ( END ) ; } } private final class NodeValueIterator extends InternalAxisIteratorBase { private DTMAxisIterator _source ; private String _value ; private boolean _op ; private final boolean _isReverse ; private int _returnType = RETURN_PARENT ; public NodeValueIterator ( DTMAxisIterator source , int returnType , String value , boolean op ) { _source = source ; _returnType = returnType ; _value = value ; _op = op ; _isReverse = source . isReverse ( ) ; } public boolean isReverse ( ) { return _isReverse ; } public DTMAxisIterator cloneIterator ( ) { try { NodeValueIterator clone = ( NodeValueIterator ) super . clone ( ) ; clone . _isRestartable = false ; clone . _source = _source . cloneIterator ( ) ; clone . _value = _value ; clone . _op = _op ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public int next ( ) { int node ; while ( ( node = _source . next ( ) ) != END ) { String val = getStringValueX ( node ) ; if ( _value . equals ( val ) == _op ) { if ( _returnType == RETURN_CURRENT ) { return returnNode ( node ) ; } else { return returnNode ( getParent ( node ) ) ; } } } return END ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; return resetPosition ( ) ; } return this ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iterator , int type , String value , boolean op ) { return ( DTMAxisIterator ) ( new NodeValueIterator ( iterator , type , value , op ) ) ; } public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) { return new DupFilterIterator ( source ) ; } public DTMAxisIterator getIterator ( ) { return new SingletonIterator ( getDocument ( ) ) ; } public int getNSType ( int node ) { String s = getNamespaceURI ( node ) ; if ( s == null ) { return 0 ; } int eType = getIdForNamespace ( s ) ; return ( ( Integer ) _nsIndex . get ( new Integer ( eType ) ) ) . intValue ( ) ; } public int getNamespaceType ( final int node ) { return super . getNamespaceType ( node ) ; } private int [ ] setupMapping ( String [ ] names , String [ ] uris , int [ ] types , int nNames ) { final int [ ] result = new int [ m_expandedNameTable . getSize ( ) ] ; for ( int i = 0 ; i < nNames ; i ++ ) { int type = m_expandedNameTable . getExpandedTypeID ( uris [ i ] , names [ i ] , types [ i ] , false ) ; result [ type ] = type ; } return result ; } public int getGeneralizedType ( final String name ) { return getGeneralizedType ( name , true ) ; } public int getGeneralizedType ( final String name , boolean searchOnly ) { String lName , ns = null ; int index = - 1 ; int code ; if ( ( index = name . lastIndexOf ( ":" ) ) > - 1 ) { ns = name . substring ( 0 , index ) ; } int lNameStartIdx = index + 1 ; if ( name . charAt ( lNameStartIdx ) == '@' ) { code = DTM . ATTRIBUTE_NODE ; lNameStartIdx ++ ; } else { code = DTM . ELEMENT_NODE ; } lName = ( lNameStartIdx == 0 ) ? name : name . substring ( lNameStartIdx ) ; return m_expandedNameTable . getExpandedTypeID ( ns , lName , code , searchOnly ) ; } public short [ ] getMapping ( String [ ] names , String [ ] uris , int [ ] types ) { if ( _namesSize < 0 ) { return getMapping2 ( names , uris , types ) ; } int i ; final int namesLength = names . length ; final int exLength = m_expandedNameTable . getSize ( ) ; final short [ ] result = new short [ exLength ] ; for ( i = 0 ; i < DTM . NTYPES ; i ++ ) { result [ i ] = ( short ) i ; } for ( i = NTYPES ; i < exLength ; i ++ ) { result [ i ] = m_expandedNameTable . getType ( i ) ; } for ( i = 0 ; i < namesLength ; i ++ ) { int genType = m_expandedNameTable . getExpandedTypeID ( uris [ i ] , names [ i ] , types [ i ] , true ) ; if ( genType >= 0 && genType < exLength ) { result [ genType ] = ( short ) ( i + DTM . NTYPES ) ; } } return result ; } public int [ ] getReverseMapping ( String [ ] names , String [ ] uris , int [ ] types ) { int i ; final int [ ] result = new int [ names . length + DTM . NTYPES ] ; for ( i = 0 ; i < DTM . NTYPES ; i ++ ) { result [ i ] = i ; } for ( i = 0 ; i < names . length ; i ++ ) { int type = m_expandedNameTable . getExpandedTypeID ( uris [ i ] , names [ i ] , types [ i ] , true ) ; result [ i + DTM . NTYPES ] = type ; } return ( result ) ; } private short [ ] getMapping2 ( String [ ] names , String [ ] uris , int [ ] types ) { int i ; final int namesLength = names . length ; final int exLength = m_expandedNameTable . getSize ( ) ; int [ ] generalizedTypes = null ; if ( namesLength > 0 ) { generalizedTypes = new int [ namesLength ] ; } int resultLength = exLength ; for ( i = 0 ; i < namesLength ; i ++ ) { generalizedTypes [ i ] = m_expandedNameTable . getExpandedTypeID ( uris [ i ] , names [ i ] , types [ i ] , false ) ; if ( _namesSize < 0 && generalizedTypes [ i ] >= resultLength ) { resultLength = generalizedTypes [ i ] + 1 ; } } final short [ ] result = new short [ resultLength ] ; for ( i = 0 ; i < DTM . NTYPES ; i ++ ) { result [ i ] = ( short ) i ; } for ( i = NTYPES ; i < exLength ; i ++ ) { result [ i ] = m_expandedNameTable . getType ( i ) ; } for ( i = 0 ; i < namesLength ; i ++ ) { int genType = generalizedTypes [ i ] ; if ( genType >= 0 && genType < resultLength ) { result [ genType ] = ( short ) ( i + DTM . NTYPES ) ; } } return ( result ) ; } public short [ ] getNamespaceMapping ( String [ ] namespaces ) { int i ; final int nsLength = namespaces . length ; final int mappingLength = _uriCount ; final short [ ] result = new short [ mappingLength ] ; for ( i = 0 ; i < mappingLength ; i ++ ) { result [ i ] = ( short ) ( - 1 ) ; } for ( i = 0 ; i < nsLength ; i ++ ) { int eType = getIdForNamespace ( namespaces [ i ] ) ; Integer type = ( Integer ) _nsIndex . get ( new Integer ( eType ) ) ; if ( type != null ) { result [ type . intValue ( ) ] = ( short ) i ; } } return ( result ) ; } public short [ ] getReverseNamespaceMapping ( String [ ] namespaces ) { int i ; final int length = namespaces . length ; final short [ ] result = new short [ length ] ; for ( i = 0 ; i < length ; i ++ ) { int eType = getIdForNamespace ( namespaces [ i ] ) ; Integer type = ( Integer ) _nsIndex . get ( new Integer ( eType ) ) ; result [ i ] = ( type == null ) ? - 1 : type . shortValue ( ) ; } return result ; } public SAXImpl ( XSLTCDTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , boolean buildIdIndex ) { this ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , DEFAULT_BLOCKSIZE , buildIdIndex , false ) ; } public SAXImpl ( XSLTCDTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean buildIdIndex , boolean newNameTable ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , false , buildIdIndex , newNameTable ) ; _dtmManager = mgr ; _size = blocksize ; _xmlSpaceStack = new int [ blocksize <= 64 ? 4 : 64 ] ; _xmlSpaceStack [ 0 ] = DTMDefaultBase . ROOTNODE ; if ( source instanceof DOMSource ) { _hasDOMSource = true ; DOMSource domsrc = ( DOMSource ) source ; Node node = domsrc . getNode ( ) ; if ( node instanceof Document ) { _document = ( Document ) node ; } else { _document = node . getOwnerDocument ( ) ; } _node2Ids = new Hashtable ( ) ; } } public void migrateTo ( DTMManager manager ) { super . migrateTo ( manager ) ; if ( manager instanceof XSLTCDTMManager ) { _dtmManager = ( XSLTCDTMManager ) manager ; } } public int getElementById ( String idString ) { Node node = _document . getElementById ( idString ) ; if ( node != null ) { Integer id = ( Integer ) _node2Ids . get ( node ) ; return ( id != null ) ? id . intValue ( ) : DTM . NULL ; } else { return DTM . NULL ; } } public boolean hasDOMSource ( ) { return _hasDOMSource ; } private void xmlSpaceDefine ( String val , final int node ) { final boolean setting = val . equals ( PRESERVE_STRING ) ; if ( setting != _preserve ) { _xmlSpaceStack [ _idx ++ ] = node ; _preserve = setting ; } } private void xmlSpaceRevert ( final int node ) { if ( node == _xmlSpaceStack [ _idx - 1 ] ) { _idx -- ; _preserve = ! _preserve ; } } protected boolean getShouldStripWhitespace ( ) { return _preserve ? false : super . getShouldStripWhitespace ( ) ; } private void handleTextEscaping ( ) { if ( _disableEscaping && _textNodeToProcess != DTM . NULL && _type ( _textNodeToProcess ) == DTM . TEXT_NODE ) { if ( _dontEscape == null ) { _dontEscape = new BitArray ( _size ) ; } if ( _textNodeToProcess >= _dontEscape . size ( ) ) { _dontEscape . resize ( _dontEscape . size ( ) * 2 ) ; } _dontEscape . setBit ( _textNodeToProcess ) ; _disableEscaping = false ; } _textNodeToProcess = DTM . NULL ; } public void characters ( char [ ] ch , int start , int length ) throws SAXException { super . characters ( ch , start , length ) ; _disableEscaping = ! _escaping ; _textNodeToProcess = getNumberOfNodes ( ) ; } public void startDocument ( ) throws SAXException { super . startDocument ( ) ; _nsIndex . put ( new Integer ( 0 ) , new Integer ( _uriCount ++ ) ) ; definePrefixAndUri ( XML_PREFIX , XML_URI ) ; } public void endDocument ( ) throws SAXException { super . endDocument ( ) ; handleTextEscaping ( ) ; _namesSize = m_expandedNameTable . getSize ( ) ; } public void startElement ( String uri , String localName , String qname , Attributes attributes , Node node ) throws SAXException { this . startElement ( uri , localName , qname , attributes ) ; if ( m_buildIdIndex ) { _node2Ids . put ( node , new Integer ( m_parents . peek ( ) ) ) ; } } public void startElement ( String uri , String localName , String qname , Attributes attributes ) throws SAXException { super . startElement ( uri , localName , qname , attributes ) ; handleTextEscaping ( ) ; if ( m_wsfilter != null ) { final int index = attributes . getIndex ( XMLSPACE_STRING ) ; if ( index >= 0 ) { xmlSpaceDefine ( attributes . getValue ( index ) , m_parents . peek ( ) ) ; } } } public void endElement ( String namespaceURI , String localName , String qname ) throws SAXException { super . endElement ( namespaceURI , localName , qname ) ; handleTextEscaping ( ) ; if ( m_wsfilter != null ) { xmlSpaceRevert ( m_previous ) ; } } public void processingInstruction ( String target , String data ) throws SAXException { super . processingInstruction ( target , data ) ; handleTextEscaping ( ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { super . ignorableWhitespace ( ch , start , length ) ; _textNodeToProcess = getNumberOfNodes ( ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { super . startPrefixMapping ( prefix , uri ) ; handleTextEscaping ( ) ; definePrefixAndUri ( prefix , uri ) ; } private void definePrefixAndUri ( String prefix , String uri ) throws SAXException { Integer eType = new Integer ( getIdForNamespace ( uri ) ) ; if ( ( Integer ) _nsIndex . get ( eType ) == null ) { _nsIndex . put ( eType , new Integer ( _uriCount ++ ) ) ; } } public void comment ( char [ ] ch , int start , int length ) throws SAXException { super . comment ( ch , start , length ) ; handleTextEscaping ( ) ; } public boolean setEscaping ( boolean value ) { final boolean temp = _escaping ; _escaping = value ; return temp ; } public void print ( int node , int level ) { switch ( getNodeType ( node ) ) { case DTM . ROOT_NODE : case DTM . DOCUMENT_NODE : print ( getFirstChild ( node ) , level ) ; break ; case DTM . TEXT_NODE : case DTM . COMMENT_NODE : case DTM . PROCESSING_INSTRUCTION_NODE : System . out . print ( getStringValueX ( node ) ) ; break ; default : final String name = getNodeName ( node ) ; System . out . print ( "<" + name ) ; for ( int a = getFirstAttribute ( node ) ; a != DTM . NULL ; a = getNextAttribute ( a ) ) { System . out . print ( "\n" + getNodeName ( a ) + "=\"" + getStringValueX ( a ) + "\"" ) ; } System . out . print ( '>' ) ; for ( int child = getFirstChild ( node ) ; child != DTM . NULL ; child = getNextSibling ( child ) ) { print ( child , level + 1 ) ; } System . out . println ( "</" + name + '>' ) ; break ; } } public String getNodeName ( final int node ) { int nodeh = node ; final short type = getNodeType ( nodeh ) ; switch ( type ) { case DTM . ROOT_NODE : case DTM . DOCUMENT_NODE : case DTM . TEXT_NODE : case DTM . COMMENT_NODE : return EMPTYSTRING ; case DTM . NAMESPACE_NODE : return this . getLocalName ( nodeh ) ; default : return super . getNodeName ( nodeh ) ; } } public String getNamespaceName ( final int node ) { if ( node == DTM . NULL ) { return "" ; } String s ; return ( s = getNamespaceURI ( node ) ) == null ? EMPTYSTRING : s ; } public int getAttributeNode ( final int type , final int element ) { for ( int attr = getFirstAttribute ( element ) ; attr != DTM . NULL ; attr = getNextAttribute ( attr ) ) { if ( getExpandedTypeID ( attr ) == type ) return attr ; } return DTM . NULL ; } public String getAttributeValue ( final int type , final int element ) { final int attr = getAttributeNode ( type , element ) ; return ( attr != DTM . NULL ) ? getStringValueX ( attr ) : EMPTYSTRING ; } public String getAttributeValue ( final String name , final int element ) { return getAttributeValue ( getGeneralizedType ( name ) , element ) ; } public DTMAxisIterator getChildren ( final int node ) { return ( new ChildrenIterator ( ) ) . setStartNode ( node ) ; } public DTMAxisIterator getTypedChildren ( final int type ) { return ( new TypedChildrenIterator ( type ) ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { switch ( axis ) { case Axis . SELF : return new SingletonIterator ( ) ; case Axis . CHILD : return new ChildrenIterator ( ) ; case Axis . PARENT : return new ParentIterator ( ) ; case Axis . ANCESTOR : return new AncestorIterator ( ) ; case Axis . ANCESTORORSELF : return ( new AncestorIterator ( ) ) . includeSelf ( ) ; case Axis . ATTRIBUTE : return new AttributeIterator ( ) ; case Axis . DESCENDANT : return new DescendantIterator ( ) ; case Axis . DESCENDANTORSELF : return ( new DescendantIterator ( ) ) . includeSelf ( ) ; case Axis . FOLLOWING : return new FollowingIterator ( ) ; case Axis . PRECEDING : return new PrecedingIterator ( ) ; case Axis . FOLLOWINGSIBLING : return new FollowingSiblingIterator ( ) ; case Axis . PRECEDINGSIBLING : return new PrecedingSiblingIterator ( ) ; case Axis . NAMESPACE : return new NamespaceIterator ( ) ; default : BasisLibrary . runTimeError ( BasisLibrary . AXIS_SUPPORT_ERR , Axis . names [ axis ] ) ; } return null ; } public DTMAxisIterator getTypedAxisIterator ( int axis , int type ) { if ( axis == Axis . CHILD ) { return new TypedChildrenIterator ( type ) ; } if ( type == NO_TYPE ) { return ( EMPTYITERATOR ) ; } switch ( axis ) { case Axis . SELF : return new TypedSingletonIterator ( type ) ; case Axis . CHILD : return new TypedChildrenIterator ( type ) ; case Axis . PARENT : return new ParentIterator ( ) . setNodeType ( type ) ; case Axis . ANCESTOR : return new TypedAncestorIterator ( type ) ; case Axis . ANCESTORORSELF : return ( new TypedAncestorIterator ( type ) ) . includeSelf ( ) ; case Axis . ATTRIBUTE : return new TypedAttributeIterator ( type ) ; case Axis . DESCENDANT : return new TypedDescendantIterator ( type ) ; case Axis . DESCENDANTORSELF : return ( new TypedDescendantIterator ( type ) ) . includeSelf ( ) ; case Axis . FOLLOWING : return new TypedFollowingIterator ( type ) ; case Axis . PRECEDING : return new TypedPrecedingIterator ( type ) ; case Axis . FOLLOWINGSIBLING : return new TypedFollowingSiblingIterator ( type ) ; case Axis . PRECEDINGSIBLING : return new TypedPrecedingSiblingIterator ( type ) ; case Axis . NAMESPACE : return new TypedNamespaceIterator ( type ) ; default : BasisLibrary . runTimeError ( BasisLibrary . TYPED_AXIS_SUPPORT_ERR , Axis . names [ axis ] ) ; } return null ; } public DTMAxisIterator getNamespaceAxisIterator ( int axis , int ns ) { DTMAxisIterator iterator = null ; if ( ns == NO_TYPE ) { return EMPTYITERATOR ; } else { switch ( axis ) { case Axis . CHILD : return new NamespaceChildrenIterator ( ns ) ; case Axis . ATTRIBUTE : return new NamespaceAttributeIterator ( ns ) ; default : return new NamespaceWildcardIterator ( axis , ns ) ; } } } public final class NamespaceWildcardIterator extends InternalAxisIteratorBase { protected int m_nsType ; protected DTMAxisIterator m_baseIterator ; public NamespaceWildcardIterator ( int axis , int nsType ) { m_nsType = nsType ; switch ( axis ) { case Axis . ATTRIBUTE : { m_baseIterator = getAxisIterator ( axis ) ; } case Axis . NAMESPACE : { m_baseIterator = getAxisIterator ( axis ) ; } default : { m_baseIterator = getTypedAxisIterator ( axis , DTM . ELEMENT_NODE ) ; } } } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = node ; m_baseIterator . setStartNode ( node ) ; resetPosition ( ) ; } return this ; } public int next ( ) { int node ; while ( ( node = m_baseIterator . next ( ) ) != END ) { if ( getNSType ( node ) == m_nsType ) { return returnNode ( node ) ; } } return END ; } public DTMAxisIterator cloneIterator ( ) { try { DTMAxisIterator nestedClone = m_baseIterator . cloneIterator ( ) ; NamespaceWildcardIterator clone = ( NamespaceWildcardIterator ) super . clone ( ) ; clone . m_baseIterator = nestedClone ; clone . m_nsType = m_nsType ; clone . _isRestartable = false ; return clone ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public boolean isReverse ( ) { return m_baseIterator . isReverse ( ) ; } public void setMark ( ) { m_baseIterator . setMark ( ) ; } public void gotoMark ( ) { m_baseIterator . gotoMark ( ) ; } } public final class NamespaceChildrenIterator extends InternalAxisIteratorBase { private final int _nsType ; public NamespaceChildrenIterator ( final int type ) { _nsType = type ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) { node = getDocument ( ) ; } if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : NOTPROCESSED ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode != DTM . NULL ) { for ( int node = ( NOTPROCESSED == _currentNode ) ? _firstch ( makeNodeIdentity ( _startNode ) ) : _nextsib ( _currentNode ) ; node != END ; node = _nextsib ( node ) ) { int nodeHandle = makeNodeHandle ( node ) ; if ( getNSType ( nodeHandle ) == _nsType ) { _currentNode = node ; return returnNode ( nodeHandle ) ; } } } return END ; } } public final class NamespaceAttributeIterator extends InternalAxisIteratorBase { private final int _nsType ; public NamespaceAttributeIterator ( int nsType ) { super ( ) ; _nsType = nsType ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) { node = getDocument ( ) ; } if ( _isRestartable ) { int nsType = _nsType ; _startNode = node ; for ( node = getFirstAttribute ( node ) ; node != END ; node = getNextAttribute ( node ) ) { if ( getNSType ( node ) == nsType ) { break ; } } _currentNode = node ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; int nsType = _nsType ; int nextNode ; if ( node == END ) { return END ; } for ( nextNode = getNextAttribute ( node ) ; nextNode != END ; nextNode = getNextAttribute ( nextNode ) ) { if ( getNSType ( nextNode ) == nsType ) { break ; } } _currentNode = nextNode ; return returnNode ( node ) ; } } public DTMAxisIterator getTypedDescendantIterator ( int type ) { return new TypedDescendantIterator ( type ) ; } public DTMAxisIterator getNthDescendant ( int type , int n , boolean includeself ) { DTMAxisIterator source = ( DTMAxisIterator ) new TypedDescendantIterator ( type ) ; return new NthDescendantIterator ( n ) ; } public void characters ( final int node , SerializationHandler handler ) throws TransletException { if ( node != DTM . NULL ) { try { dispatchCharactersEvents ( node , handler , false ) ; } catch ( SAXException e ) { throw new TransletException ( e ) ; } } } public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException { int node ; while ( ( node = nodes . next ( ) ) != DTM . NULL ) { copy ( node , handler ) ; } } public void copy ( SerializationHandler handler ) throws TransletException { copy ( getDocument ( ) , handler ) ; } public void copy ( final int node , SerializationHandler handler ) throws TransletException { copy ( node , handler , false ) ; } private final void copy ( final int node , SerializationHandler handler , boolean isChild ) throws TransletException { int nodeID = makeNodeIdentity ( node ) ; int eType = _exptype2 ( nodeID ) ; int type = _exptype2Type ( eType ) ; try { switch ( type ) { case DTM . ROOT_NODE : case DTM . DOCUMENT_NODE : for ( int c = _firstch2 ( nodeID ) ; c != DTM . NULL ; c = _nextsib2 ( c ) ) { copy ( makeNodeHandle ( c ) , handler , true ) ; } break ; case DTM . PROCESSING_INSTRUCTION_NODE : copyPI ( node , handler ) ; break ; case DTM . COMMENT_NODE : handler . comment ( getStringValueX ( node ) ) ; break ; case DTM . TEXT_NODE : boolean oldEscapeSetting = false ; boolean escapeBit = false ; if ( _dontEscape != null ) { escapeBit = _dontEscape . getBit ( getNodeIdent ( node ) ) ; if ( escapeBit ) { oldEscapeSetting = handler . setEscaping ( false ) ; } } copyTextNode ( nodeID , handler ) ; if ( escapeBit ) { handler . setEscaping ( oldEscapeSetting ) ; } break ; case DTM . ATTRIBUTE_NODE : copyAttribute ( nodeID , eType , handler ) ; break ; case DTM . NAMESPACE_NODE : handler . namespaceAfterStartElement ( getNodeNameX ( node ) , getNodeValue ( node ) ) ; break ; default : if ( type == DTM . ELEMENT_NODE ) { final String name = copyElement ( nodeID , eType , handler ) ; copyNS ( nodeID , handler , ! isChild ) ; copyAttributes ( nodeID , handler ) ; for ( int c = _firstch2 ( nodeID ) ; c != DTM . NULL ; c = _nextsib2 ( c ) ) { copy ( makeNodeHandle ( c ) , handler , true ) ; } handler . endElement ( name ) ; } else { final String uri = getNamespaceName ( node ) ; if ( uri . length ( ) != 0 ) { final String prefix = getPrefix ( node ) ; handler . namespaceAfterStartElement ( prefix , uri ) ; } handler . addAttribute ( getNodeName ( node ) , getNodeValue ( node ) ) ; } break ; } } catch ( Exception e ) { throw new TransletException ( e ) ; } } private void copyPI ( final int node , SerializationHandler handler ) throws TransletException { final String target = getNodeName ( node ) ; final String value = getStringValueX ( node ) ; try { handler . processingInstruction ( target , value ) ; } catch ( Exception e ) { throw new TransletException ( e ) ; } } public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException { int nodeID = makeNodeIdentity ( node ) ; int exptype = _exptype2 ( nodeID ) ; int type = _exptype2Type ( exptype ) ; try { switch ( type ) { case DTM . ELEMENT_NODE : final String name = copyElement ( nodeID , exptype , handler ) ; copyNS ( nodeID , handler , true ) ; return name ; case DTM . ROOT_NODE : case DTM . DOCUMENT_NODE : return EMPTYSTRING ; case DTM . TEXT_NODE : copyTextNode ( nodeID , handler ) ; return null ; case DTM . PROCESSING_INSTRUCTION_NODE : copyPI ( node , handler ) ; return null ; case DTM . COMMENT_NODE : handler . comment ( getStringValueX ( node ) ) ; return null ; case DTM . NAMESPACE_NODE : handler . namespaceAfterStartElement ( getNodeNameX ( node ) , getNodeValue ( node ) ) ; return null ; case DTM . ATTRIBUTE_NODE : copyAttribute ( nodeID , exptype , handler ) ; return null ; default : final String uri1 = getNamespaceName ( node ) ; if ( uri1 . length ( ) != 0 ) { final String prefix = getPrefix ( node ) ; handler . namespaceAfterStartElement ( prefix , uri1 ) ; } handler . addAttribute ( getNodeName ( node ) , getNodeValue ( node ) ) ; return null ; } } catch ( Exception e ) { throw new TransletException ( e ) ; } } public String getLanguage ( int node ) { int parent = node ; while ( DTM . NULL != parent ) { if ( DTM . ELEMENT_NODE == getNodeType ( parent ) ) { int langAttr = getAttributeNode ( parent , "http://www.w3.org/XML/1998/namespace" , "lang" ) ; if ( DTM . NULL != langAttr ) { return getNodeValue ( langAttr ) ; } } parent = getParent ( parent ) ; } return ( null ) ; } public DOMBuilder getBuilder ( ) { return this ; } public SerializationHandler getOutputDomBuilder ( ) { return new ToXMLSAXHandler ( this , "UTF-8" ) ; } public DOM getResultTreeFrag ( int initSize , int rtfType ) { return getResultTreeFrag ( initSize , rtfType , true ) ; } public DOM getResultTreeFrag ( int initSize , int rtfType , boolean addToManager ) { if ( rtfType == DOM . SIMPLE_RTF ) { if ( addToManager ) { int dtmPos = _dtmManager . getFirstFreeDTMID ( ) ; SimpleResultTreeImpl rtf = new SimpleResultTreeImpl ( _dtmManager , dtmPos << DTMManager . IDENT_DTM_NODE_BITS ) ; _dtmManager . addDTM ( rtf , dtmPos , 0 ) ; return rtf ; } else { return new SimpleResultTreeImpl ( _dtmManager , 0 ) ; } } else if ( rtfType == DOM . ADAPTIVE_RTF ) { if ( addToManager ) { int dtmPos = _dtmManager . getFirstFreeDTMID ( ) ; AdaptiveResultTreeImpl rtf = new AdaptiveResultTreeImpl ( _dtmManager , dtmPos << DTMManager . IDENT_DTM_NODE_BITS , m_wsfilter , initSize , m_buildIdIndex ) ; _dtmManager . addDTM ( rtf , dtmPos , 0 ) ; return rtf ; } else { return new AdaptiveResultTreeImpl ( _dtmManager , 0 , m_wsfilter , initSize , m_buildIdIndex ) ; } } else { return ( DOM ) _dtmManager . getDTM ( null , true , m_wsfilter , true , false , false , initSize , m_buildIdIndex ) ; } } public Hashtable getElementsWithIDs ( ) { if ( m_idAttributes == null ) { return null ; } Enumeration idValues = m_idAttributes . keys ( ) ; if ( ! idValues . hasMoreElements ( ) ) { return null ; } Hashtable idAttrsTable = new Hashtable ( ) ; while ( idValues . hasMoreElements ( ) ) { Object idValue = idValues . nextElement ( ) ; idAttrsTable . put ( idValue , m_idAttributes . get ( idValue ) ) ; } return idAttrsTable ; } public String getUnparsedEntityURI ( String name ) { if ( _document != null ) { String uri = "" ; DocumentType doctype = _document . getDoctype ( ) ; if ( doctype != null ) { NamedNodeMap entities = doctype . getEntities ( ) ; if ( entities == null ) { return uri ; } Entity entity = ( Entity ) entities . getNamedItem ( name ) ; if ( entity == null ) { return uri ; } String notationName = entity . getNotationName ( ) ; if ( notationName != null ) { uri = entity . getSystemId ( ) ; if ( uri == null ) { uri = entity . getPublicId ( ) ; } } } return uri ; } else { return super . getUnparsedEntityURI ( name ) ; } } } 	1	['81', '6', '0', '58', '232', '3062', '11', '54', '66', '0.962931034', '2222', '1', '5', '0.721428571', '0.129166667', '3', '8', '26.07407407', '10', '2.037', '1']
package org . apache . xml . utils . res ; public class XResources_de extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "de" } , { "help_language" , "de" } , { "language" , "de" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '314', '0', '0', '0.976190476', '1', '0', '0', '103.3333333', '1', '0.3333', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_ko extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "오류: 표현식에 '{'가 올 수 없음" } , { ER_ILLEGAL_ATTRIBUTE , "{0}에 유효하지 않은 속성 {1}이(가) 있음" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "xsl:apply-imports에서 sourceNode가 널(null)입니다!" } , { ER_CANNOT_ADD , "{1}에 {0}을(를) 추가할 수 없음" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "handleApplyTemplatesInstruction에서 sourceNode가 널(null)입니다!" } , { ER_NO_NAME_ATTRIB , "{0}에 이름 속성이 있어야 합니다." } , { ER_TEMPLATE_NOT_FOUND , "{0} 이름의 템플리트를 찾을 수 없습니다." } , { ER_CANT_RESOLVE_NAME_AVT , "xsl:call-template에 있는 이름 AVT를 분석할 수 없습니다." } , { ER_REQUIRES_ATTRIB , "{0}은(는) {1} 속성을 필요로 함" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0}에 ''test'' 속성이 있어야 합니다. " } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "{0} 레벨 속성에 잘못된 값이 있음" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "처리 명령어 이름은 'xml'이 될 수 없음" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "처리 명령어 이름은 올바른 NCName이어야 함: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0}에 모드가 있으면 일치 속성이 있어야 합니다." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0}에 이름 또는 일치 속성이 필요합니다." } , { ER_CANT_RESOLVE_NSPREFIX , "이름 공간 접두부를 분석할 수 없습니다: {0}" } , { ER_ILLEGAL_VALUE , "xml:space에 잘못된 값이 있습니다: {0}" } , { ER_NO_OWNERDOC , "하위 노드에 소유자 문서가 없습니다!" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement 오류: {0}" } , { ER_NULL_CHILD , "널(null) 하위를 추가하려고 시도 중입니다!" } , { ER_NEED_SELECT_ATTRIB , "{0}에 선택적 속성이 필요합니다." } , { ER_NEED_TEST_ATTRIB , "xsl:when에 'test' 속성이 있어야 합니다." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param에 'name' 속성이 있어야 합니다." } , { ER_NO_CONTEXT_OWNERDOC , "문맥에 소유자 문서가 없습니다!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "XML TransformerFactory Liaison을 작성할 수 없습니다: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: 프로세스가 실패했습니다." } , { ER_NOT_SUCCESSFUL , "Xalan:이 실패했습니다." } , { ER_ENCODING_NOT_SUPPORTED , "인코딩이 지원되지 않음: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "TraceListener를 작성할 수 없음: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key에 'name' 속성이 필요합니다!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key에 'match' 속성이 필요합니다!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key에 'use' 속성이 필요합니다!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0}에 ''elements'' 속성이 필요합니다!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} 속성 ''prefix''가 누락되었음" } , { ER_BAD_STYLESHEET_URL , "스타일 시트 URL이 잘못되었음: {0}" } , { ER_FILE_NOT_FOUND , "스타일 시트 파일을 찾을 수 없습니다: {0}" } , { ER_IOEXCEPTION , "스타일 시트 파일에 입출력 예외가 있습니다: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) {0}의 href 속성을 찾을 수 없습니다." } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0}이(가) 직접 또는 간접으로 자신을 포함합니다!" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude 오류, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} 속성 ''lang''이 누락되었음" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) {0} 요소가 잘못된 위치에 있음?? 누락된 컨테이너 요소 ''component''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Element, DocumentFragment, Document 또는 PrintWriter로만 출력할 수 있습니다." } , { ER_PROCESS_ERROR , "StylesheetRoot.process 오류" } , { ER_UNIMPLNODE_ERROR , "UnImplNode 오류: {0}" } , { ER_NO_SELECT_EXPRESSION , "오류! xpath 선택 표현식(-select)을 찾을 수 없습니다." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "XSLProcessor를 직렬화할 수 없습니다!" } , { ER_NO_INPUT_STYLESHEET , "스타일 시트 입력을 지정하지 않았습니다!" } , { ER_FAILED_PROCESS_STYLESHEET , "스타일 시트를 처리하는 데 실패했습니다!" } , { ER_COULDNT_PARSE_DOC , "{0} 문서를 구문 분석할 수 없습니다!" } , { ER_COULDNT_FIND_FRAGMENT , "단편을 찾을 수 없습니다: {0}" } , { ER_NODE_NOT_ELEMENT , "단편 ID가 가리키는 노드가 요소가 아닙니다: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each에는 일치 또는 이름 속성이 있어야 합니다." } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "템플리트에는 일치 또는 이름 속성이 있어야 합니다." } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "문서 단편의 복제본이 없습니다!" } , { ER_CANT_CREATE_ITEM , "결과 트리에 항목을 작성할 수 없습니다.: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "원본 XML의 xml:space에 유효하지 않은 값이 있습니다.: {0}" } , { ER_NO_XSLKEY_DECLARATION , "{0}에 대한 xsl:key 선언이 없습니다!" } , { ER_CANT_CREATE_URL , "오류! url을 작성할 수 없습니다.: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions가 지원되지 않습니다." } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory 오류" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) 스타일 시트 내에 {0}이(가) 허용되지 않습니다!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns가 더 이상 지원되지 않습니다!  대신 xsl:output을 사용하십시오." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space가 더 이상 지원되지 않습니다!  대신 xsl:strip-space 또는 xsl:preserve-space를 사용하십시오." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result가 더 이상 지원되지 않습니다!  대신 xsl:output을 사용하십시오." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0}에 유효하지 않은 속성이 있음: {1}" } , { ER_UNKNOWN_XSL_ELEM , "알 수 없는 XSL 요소: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort는 xsl:apply-templates 또는 xsl:for-each와 함께만 사용될 수 있습니다." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when이 잘못된 위치에 놓여 있습니다!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when이 xsl:choose의 상위에 있지 않습니다!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise가 잘못된 위치에 놓여 있습니다!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise가 xsl:choose의 상위에 있지 않습니다!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) 템플리트 내에 {0}이(가) 허용되지 않습니다!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} 확장자 이름 공간 접두부 {1}을(를) 알 수 없습니다." } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) 가져오기는 스타일 시트에서 첫 번째 요소로만 나타날 수 있습니다!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0}이(가) 직접 또는 간접으로 자신을 가져옵니다!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:공간에 유효하지 않은 값이 있음: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet에 실패했습니다!" } , { ER_SAX_EXCEPTION , "SAX 예외" } , { ER_XSLT_ERROR , "XSLT 오류" } , { ER_CURRENCY_SIGN_ILLEGAL , "포맷 패턴 문자열에 통화 부호가 허용되지 않음" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "스타일 시트 DOM에서 Document 함수가 지원되지 않습니다!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "비 접두부 분석자의 접두부를 분석할 수 없습니다!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Redirect extension: 파일 이름을 가져올 수 없습니다. 파일 또는 선택적 속성은 올바른 문자열을 리턴해야 합니다. " } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "경로 재지정 확장에 FormatterListener를 빌드할 수 없습니다!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "exclude-result-prefixes에 있는 접두부가 올바르지 않습니다: {0}" } , { ER_MISSING_NS_URI , "지정된 접두부의 이름 공간 URI가 누락되었습니다." } , { ER_MISSING_ARG_FOR_OPTION , "옵션의 인수가 누락되었습니다: {0}" } , { ER_INVALID_OPTION , "잘못된 옵션: {0}" } , { ER_MALFORMED_FORMAT_STRING , "잘못 형식화된 포맷 문자열: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet에 'version' 속성이 필요합니다!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "속성: {0}에 유효하지 않은 값이 있음: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose에 xsl:when이 필요함" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports는 xsl:for-each에 허용되지 않음" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "출력 DOM 노드에 DTMLiaison을 사용할 수 없습니다. 대신 org.apache.xpath.DOM2Helper를 전달하십시오!" } , { ER_CANT_USE_DTM_FOR_INPUT , "입력 DOM 노드에 DTMLiaison을 사용할 수 없습니다. 대신 org.apache.xpath.DOM2Helper를 전달하십시오!" } , { ER_CALL_TO_EXT_FAILED , "확장자 요소 호출에 실패함: {0}" } , { ER_PREFIX_MUST_RESOLVE , "접두부는 이름 공간으로 분석되어야 합니다: {0}" } , { ER_INVALID_UTF16_SURROGATE , "잘못된 UTF-16 대리자가 발견되었습니다: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0}이(가) 자신을 사용했으므로 무한 루프를 초래합니다." } , { ER_CANNOT_MIX_XERCESDOM , "비 Xerces-DOM 입력과 Xerces-DOM 출력을 혼합할 수 없습니다!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "ElemTemplateElement.readObject에서: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "{0} 이름의 템플리트가 둘 이상입니다." } , { ER_INVALID_KEY_CALL , "잘못된 함수 호출: recursive key() 호출이 허용되지 않음" } , { ER_REFERENCING_ITSELF , "{0} 변수가 직접 또는 간접으로 자신을 참조합니다!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "newTemplates의 DOMSource에 대한 입력 노드는 널(null)이 될 수 없습니다!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "{0} 옵션에 대한 클래스 파일이 없음" } , { ER_REQUIRED_ELEM_NOT_FOUND , "필수 요소를 찾을 수 없습니다: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream은 널(null)이 될 수 없습니다." } , { ER_URI_CANNOT_BE_NULL , "URI은 널(null)이 될 수 없습니다." } , { ER_FILE_CANNOT_BE_NULL , "파일은 널(null)이 될 수 없습니다." } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource는 널(null)이 될 수 없습니다." } , { ER_CANNOT_INIT_BSFMGR , "BSF 관리자를 초기화할 수 없습니다." } , { ER_CANNOT_CMPL_EXTENSN , "확장자를 컴파일할 수 없습니다." } , { ER_CANNOT_CREATE_EXTENSN , "확장자를 작성할 수 없습니다.: {0} 원인: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "{0} 메소드에 대한 인스턴스 메소드 호출은 첫 번째 인수로 오브젝트 인스턴스를 필요로 합니다." } , { ER_INVALID_ELEMENT_NAME , "잘못된 요소 이름이 지정되었습니다: {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "요소 이름 메소드는 static이어야 합니다: {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "확장자 함수 {0} : {1}을(를) 알 수 없습니다." } , { ER_MORE_MATCH_CONSTRUCTOR , "{0}에 대한 생성자에 가장 일치하는 것이 없습니다." } , { ER_MORE_MATCH_METHOD , "{0} 메소드에 가장 일치하는 것이 없습니다." } , { ER_MORE_MATCH_ELEMENT , "{0} 요소 메소드에 가장 일치하는 것이 없습니다." } , { ER_INVALID_CONTEXT_PASSED , "{0}을(를) 평가하는 데 잘못된 문맥이 전달되었습니다." } , { ER_POOL_EXISTS , "풀이 이미 있습니다." } , { ER_NO_DRIVER_NAME , "드라이버 이름을 지정하지 않았습니다." } , { ER_NO_URL , "URL을 지정하지 않았습니다." } , { ER_POOL_SIZE_LESSTHAN_ONE , "풀 크기가 1 미만입니다!" } , { ER_INVALID_DRIVER , "잘못된 드라이버 이름을 지정했습니다!" } , { ER_NO_STYLESHEETROOT , "스타일 시트 루트를 찾을 수 없습니다!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "xml:space에 대해 유효하지 않은 값" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode가 실패했습니다." } , { ER_RESOURCE_COULD_NOT_LOAD , "[ {0} ] 자원이 {1} \n {2} \t {3}을 로드할 수 없습니다." } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "버퍼 크기 <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "확장자 호출 시 알 수 없는 오류" } , { ER_NO_NAMESPACE_DECL , "{0} 접두부에 해당하는 이름 공간 선언이 없습니다." } , { ER_ELEM_CONTENT_NOT_ALLOWED , "lang=javaclass {0}에 대해 요소 컨텐츠가 허용되지 않습니다." } , { ER_STYLESHEET_DIRECTED_TERMINATION , "스타일 시트가 종료를 지시했습니다." } , { ER_ONE_OR_TWO , "1 또는 2" } , { ER_TWO_OR_THREE , "2 또는 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "{0}(check CLASSPATH)을(를) 로드할 수 없으므로, 현재 기본값만을 사용 중입니다." } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "기본 템플리트를 초기화할 수 없습니다." } , { ER_RESULT_NULL , "결과는 널(null)이 될 수 없습니다." } , { ER_RESULT_COULD_NOT_BE_SET , "결과를 설정할 수 없습니다." } , { ER_NO_OUTPUT_SPECIFIED , "출력을 지정하지 않았습니다." } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "{0} 유형의 결과로 변환할 수 없습니다." } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "{0} 유형의 소스로 변환할 수 없습니다." } , { ER_NULL_CONTENT_HANDLER , "널(null) 컨텐츠 핸들러" } , { ER_NULL_ERROR_HANDLER , "널(null) 오류 핸들러" } , { ER_CANNOT_CALL_PARSE , "ContentHandler를 설정하지 않은 경우에는 parse를 호출할 수 없습니다." } , { ER_NO_PARENT_FOR_FILTER , "상위 필터가 없습니다." } , { ER_NO_STYLESHEET_IN_MEDIA , "{0}에 스타일 시트가 없습니다. 매체= {1}" } , { ER_NO_STYLESHEET_PI , "{0}에 xml-스타일 시트 PI가 없습니다." } , { ER_NOT_SUPPORTED , "지원되지 않음: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "{0} 특성값은 부울 인스턴스이어야 합니다." } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "{0}에 있는 외부 스크립트에 도달할 수 없습니다." } , { ER_RESOURCE_COULD_NOT_FIND , "[ {0} ] 자원을 찾을 수 없습니다.\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "출력 특성이 인식되지 않습니다: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "ElemLiteralResult 인스턴스 작성에 실패했습니다." } , { ER_VALUE_SHOULD_BE_NUMBER , "{0}에 대한 값에 구문 분석 가능한 숫자가 있어야 합니다." } , { ER_VALUE_SHOULD_EQUAL , "{0}의 값은 yes 또는 no여야 합니다." } , { ER_FAILED_CALLING_METHOD , "{0} 메소드 호출에 실패했습니다." } , { ER_FAILED_CREATING_ELEMTMPL , "ElemTemplateElement 인스턴스 작성에 실패했습니다." } , { ER_CHARS_NOT_ALLOWED , "문서의 이 지점에 문자가 허용되지 않습니다." } , { ER_ATTR_NOT_ALLOWED , "{1} 요소에 \"{0}\" 속성이 허용되지 않습니다!" } , { ER_BAD_VALUE , "{0} 잘못된 값 {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "{0} 속성값이 없습니다. " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "{0} 속성값이 인식되지 않습니다. " } , { ER_NULL_URI_NAMESPACE , "널(null) URI로 이름 공간 접두부를 생성하려고 시도 중입니다." } , { ER_NUMBER_TOO_BIG , "최대로 긴 정수보다 큰 숫자를 포맷하려고 시도 중입니다." } , { ER_CANNOT_FIND_SAX1_DRIVER , "SAX1 드라이버 클래스 {0}을(를) 찾을 수 없습니다." } , { ER_SAX1_DRIVER_NOT_LOADED , "SAX1 드라이버 클래스 {0}이(가) 있으나 로드할 수 없습니다." } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "SAX1 드라이버 클래스 {0}을(를) 로드했으나 인스턴스화할 수 없습니다." } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1 드라이버 클래스 {0}이(가) org.xml.sax.Parser를 구현하지 않았습니다." } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "시스템 특성 org.xml.sax.parser를 지정하지 않았습니다." } , { ER_PARSER_ARG_CANNOT_BE_NULL , "구문 분석기 인수는 널(null)이 될 수 없습니다." } , { ER_FEATURE , "특성: {0}" } , { ER_PROPERTY , "특성: {0}" } , { ER_NULL_ENTITY_RESOLVER , "널(null) 엔티티 분석기" } , { ER_NULL_DTD_HANDLER , "널(null) DTD 핸들러" } , { ER_NO_DRIVER_NAME_SPECIFIED , "드라이버 이름을 지정하지 않았습니다!" } , { ER_NO_URL_SPECIFIED , "URL을 지정하지 않았습니다!" } , { ER_POOLSIZE_LESS_THAN_ONE , "풀 크기가 1 미만입니다!" } , { ER_INVALID_DRIVER_NAME , "잘못된 드라이버 이름을 지정했습니다!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "프로그래머 오류! expr에 ElemTemplateElement 상위가 없습니다!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "RundundentExprEliminator에 프로그래머의 단언문: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0}은(는) 스타일 시트의 이 위치에서 허용되지 않습니다!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Non-whitespace 텍스트는 스타일 시트의 이 위치에서 허용되지 않습니다!" } , { INVALID_TCHAR , "{0} CHAR 속성에 대해 사용된 {1} 값이 유효하지 않습니다. CHAR 유형의 속성은 1 문자이어야 합니다!" } , { INVALID_QNAME , "{0} QNAME 속성에 대해 사용된 {1} 값이 유효하지 않습니다." } , { INVALID_ENUM , "{0} ENUM 속성에 대해 사용된 {1} 값이 유효하지 않습니다. 올바른 값은 {2}입니다." } , { INVALID_NMTOKEN , "{0} NMTOKEN 속성에 대해 사용된 {1} 값이 유효하지 않습니다. " } , { INVALID_NCNAME , "{0} NCNAME 속성에 대해 사용된 {1} 값이 유효하지 않습니다. " } , { INVALID_BOOLEAN , "{0} 부울 속성에 대해 사용된 {1} 값이 유효하지 않습니다. " } , { INVALID_NUMBER , "{0} 숫자 속성에 대해 사용된 {1} 값이 유효하지 않습니다. " } , { ER_ARG_LITERAL , "일치 패턴에서 {0}에 대한 인수는 리터럴이어야 합니다." } , { ER_DUPLICATE_GLOBAL_VAR , "중복 글로벌 변수 선언입니다." } , { ER_DUPLICATE_VAR , "중복 변수 선언입니다." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template에 이름 또는 일치 속성(또는 둘 다)이 있어야 합니다." } , { ER_INVALID_PREFIX , "exclude-result-prefixes에 있는 접두부가 올바르지 않습니다: {0}" } , { ER_NO_ATTRIB_SET , "이름이 {0}인 attribute-set가 없습니다." } , { WG_FOUND_CURLYBRACE , "'}'가 발견되었으나 열린 속성 템플리트가 없습니다!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "경고: 계수 속성이 xsl:number의 상위 요소와 일치하지 않습니다! 대상 = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "이전 구문: 'expr' 속성의 이름이 'select'로 변경되었습니다." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan이 아직 format-number 함수에 있는 로케일 이름을 처리하지 않습니다." } , { WG_LOCALE_NOT_FOUND , "경고: xml:lang={0}에 대한 로케일을 찾을 수 없습니다." } , { WG_CANNOT_MAKE_URL_FROM , "{0}에서 URL을 작성할 수 없습니다." } , { WG_CANNOT_LOAD_REQUESTED_DOC , "요청된 문서 {0}을(를) 로드할 수 없습니다." } , { WG_CANNOT_FIND_COLLATOR , "<sort xml:lang={0}에 대한 Collator를 찾을 수 없습니다." } , { WG_FUNCTIONS_SHOULD_USE_URL , "이전 구문: 함수 명령어는 {0}의 url을 사용해야 합니다." } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "인코딩이 지원되지 않습니다: {0}, UTF-8 사용" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "인코딩이 지원되지 않습니다: {0}, Java {1} 사용" } , { WG_SPECIFICITY_CONFLICTS , "특성 충돌이 발견되었습니다: {0} 스타일 시트에서 마지막으로 발견된 것이 사용됩니다." } , { WG_PARSING_AND_PREPARING , "========= 구문 분석 및 준비 {0} ==========" } , { WG_ATTR_TEMPLATE , "Attr 템플리트, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "xsl:strip-space 및 xsl:preserve-space 사이의 일치 충돌" } , { WG_ATTRIB_NOT_HANDLED , "Xalan이 아직 {0} 속성을 처리하지 않습니다!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "10진수 포맷에 대한 선언이 없습니다: {0}" } , { WG_OLD_XSLT_NS , "XSLT 이름 공간이 누락되었거나 올바르지 않습니다. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "하나의 기본 xsl:decimal-format 선언만 허용됩니다." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format 이름이 고유해야 합니다. \"{0}\" 이름이 중복되었습니다." } , { WG_ILLEGAL_ATTRIBUTE , "{0}에 유효하지 않은 속성 {1}이(가) 있습니다." } , { WG_COULD_NOT_RESOLVE_PREFIX , "이름 공간 접두부를 분석할 수 없습니다: {0}. 노드가 무시됩니다." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet에 'version' 속성이 필요합니다!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "유효하지 않은 속성 이름: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "{0} 속성에 대해 사용된 유효하지 않은 값: {1}" } , { WG_EMPTY_SECOND_ARG , "document 함수 두 번째 인수로부터의 결과 nodeset가 비어 있습니다. 빈 노드 세트를 리턴하십시오. " } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "xsl:processing-instruction의 'name' 속성값은 'xml'일 수 없습니다." } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "xsl:processing-instruction의 'name' 속성값이 올바른 NCName이어야 합니다: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "하위 노드가 생성된 이후 또는 요소가 작성되기 이전에 {0} 속성을 추가할 수 없습니다. 속성이 무시됩니다." } , { "ui_language" , "ko" } , { "help_language" , "ko" } , { "language" , "ko" } , { "BAD_CODE" , "createMessage에 대한 매개변수가 범위를 벗어납니다." } , { "FORMAT_FAILED" , "messageFormat 호출 중 예외 발생" } , { "version" , ">>>>>>> Xalan 버전 " } , { "version2" , "<<<<<<<" } , { "yes" , "예" } , { "line" , "행 #" } , { "column" , "열 #" } , { "xsldone" , "XSLProcessor: 완료" } , { "xslProc_option" , "Xalan-J 명령행 프로세스 클래스 옵션:" } , { "xslProc_option" , "Xalan-J 명령행 프로세스 클래스 옵션:" } , { "xslProc_invalid_xsltc_option" , "{0} 옵션이 XSLTC 모드에서 지원되지 않습니다." } , { "xslProc_invalid_xalan_option" , "{0} 옵션은 -XSLTC로만 사용될 수 있습니다." } , { "xslProc_no_input" , "오류: 지정된 스타일 시트 또는 입력 xml이 없습니다. 사용법 명령어에 대한 옵션 없이 이 명령을 실행하십시오." } , { "xslProc_common_options" , "-일반 옵션-" } , { "xslProc_xalan_options" , "-Xalan에 대한 옵션-" } , { "xslProc_xsltc_options" , "-XSLTC에 대한 옵션-" } , { "xslProc_return_to_continue" , "(계속하려면 Enter 키를 누르십시오)" } , { "optionXSLTC" , "[-XSLTC (변환에 대해 XSLTC 사용)]" } , { "optionIN" , "[-IN inputXMLURL]" } , { "optionXSL" , "[-XSL XSLTransformationURL]" } , { "optionOUT" , "[-OUT outputFileName]" } , { "optionLXCIN" , "[-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "[-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "[-PARSER 구문 분석기 liaison의 완전한 클래스 이름]" } , { "optionE" , "[-V (엔티티 ref를 펼치지 않음)]" } , { "optionV" , "[-V (엔티티 ref를 펼치지 않음)]" } , { "optionQC" , "[-QC (자동 패턴 충돌 경고)]" } , { "optionQ" , "[-Q  (자동 모드)]" } , { "optionLF" , "[-LF (출력에서만 줄바꾸기 사용 {기본값은 CR/LF 입니다})]" } , { "optionCR" , "[-CR (출력에서만 캐리지 리턴 사용 {기본값은 CR/LF 입니다})]" } , { "optionESCAPE" , "[-ESCAPE (에스케이프할 문자 {기본값은 <>&\"\'\\r\\n 입니다}]" } , { "optionINDENT" , "[-INDENT (들여쓰기할 공백 수 제어 {기본값은 0 입니다})]" } , { "optionTT" , "[-TT (템플리트 호출 시 템플리트 추적.)]" } , { "optionTG" , "[-TG (각 생성 이벤트 추적.)]" } , { "optionTS" , "[-TS (각 선택 이벤트 추적.)]" } , { "optionTTC" , "[-TTC (하위 템플리트 처리 시 하위 템플리트 추적.)]" } , { "optionTCLASS" , "[-TCLASS (추적 확장자에 대한 TraceListener 클래스.)]" } , { "optionVALIDATE" , "[-VALIDATE (유효성 검증 발생 여부 설정.  기본적으로는 유효성 검증이 off로 설정됨.)]" } , { "optionEDUMP" , "[-EDUMP {optional filename} (오류 시 stackdump 수행.)]" } , { "optionXML" , "[-XML (XML 포맷터를 사용하고 XML 머리글 추가.)]" } , { "optionTEXT" , "[-TEXT (단순 텍스트 포맷터 사용.)]" } , { "optionHTML" , "[-HTML (HTML 포맷터 사용.)]" } , { "optionPARAM" , "[-PARAM name expression (스타일 시트 매개변수 설정)]" } , { "noParsermsg1" , "XSL 프로세스가 실패했습니다." } , { "noParsermsg2" , "** 구문 분석기를 찾을 수 없음 **" } , { "noParsermsg3" , "클래스 경로를 점검하십시오." } , { "noParsermsg4" , "Java용 IBM XML 구문 분석기가 없으면" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml 에서 다운로드 할 수 있습니다." } , { "optionURIRESOLVER" , "[-URIRESOLVER full class name (URIResolver를 사용하여 URI 분석)]" } , { "optionENTITYRESOLVER" , "[-ENTITYRESOLVER full class name (EntityResolver를 사용하여 엔티티 분석)]" } , { "optionCONTENTHANDLER" , "[-CONTENTHANDLER full class name (ContentHandler를 사용하여 출력 직렬화)]" } , { "optionLINENUMBERS" , "[-L 소스 문서에 행 번호 사용]" } , { "optionMEDIA" , "   [-MEDIA mediaType(매체 속성을 사용하여 문서와 연관된 스타일 시트 찾기.)]" } , { "optionFLAVOR" , "   [-FLAVOR flavorName(명시적으로 s2s=SAX 또는 d2d=DOM을 사용하여 변환 수행.)] " } , { "optionDIAG" , "   [-DIAG(변환에 소요된 전체 밀리초 인쇄.)]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL(http://xml.apache.org/xalan/features/incremental을 true로 설정하여 증분 DTM 구성 요청.)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE(http://xml.apache.org/xalan/features/optimize를 false로 설정하여 스타일 시트 최적화 처리를 요청 안함.)]" } , { "optionRL" , "   [-RL recursionlimit(스타일 시트 반복 정도에 대한 숫자 한계 단언.)]" } , { "optionXO" , "[-XO [transletName](생성된 translet에 이름 지정)]" } , { "optionXD" , "[-XD destinationDirectory(translet에 대해 대상 디렉토리 지정)]" } , { "optionXJ" , "[-XJ jarfile(이름이 <jarfile>인 jar 파일로 translet 클래스 패키지)]" } , { "optionXP" , "[-XP package(생성된 모든 translet 클래스에 대해 패키지 이름 접두부 지정)]" } , { "optionXN" , "[-XN(템플리트 인라이닝 사용 가능)]" } , { "optionXX" , "[-XX(추가 디버깅 메시지 출력 켜기)]" } , { "optionXT" , "[-XT(가능한 경우, translet을 사용하여 변환)]" } , { "diagTiming" , "--------- {1}을(를) 통한 {0} 변환에 {2}ms가 소요되었음" } , { "recursionTooDeep" , "템플리트 중첩이 너무 많습니다. 중첩 = {0}, 템플리트 {1} {2}" } , { "nameIs" , "이름은" } , { "matchPatternIs" , "일치 패턴은" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "오류: " ; public static final String WARNING_HEADER = "경고: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "ko" , "KR" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xml . utils . res ; public class XResources_cy extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "cy" } , { "help_language" , "cy" } , { "language" , "cy" } , { "alphabet" , new char [ ] { 0x0430 , 0x0432 , 0x0433 , 0x0434 , 0x0435 , 0x0437 , 0x0438 , 0x0439 , 0x04A9 , 0x0457 , 0x043A , 0x043B , 0x043C , 0x043D , 0x046F , 0x043E , 0x043F , 0x0447 , 0x0440 , 0x0441 , 0x0442 , 0x0443 , 0x0444 , 0x0445 , 0x0470 , 0x0460 , 0x0446 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "precedes" } , { "numberGroups" , new int [ ] { 100 , 10 , 1 } } , { "multiplier" , new long [ ] { 1000 } } , { "multiplierChar" , new char [ ] { 0x03D9 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x0430 , 0x0432 , 0x0433 , 0x0434 , 0x0435 , 0x0437 , 0x0438 , 0x0439 , 0x04A9 } } , { "tens" , new char [ ] { 0x0457 , 0x043A , 0x043B , 0x043C , 0x043D , 0x046F , 0x043E , 0x043F , 0x0447 } } , { "hundreds" , new char [ ] { 0x0440 , 0x0441 , 0x0442 , 0x0443 , 0x0444 , 0x0445 , 0x0470 , 0x0460 , 0x0446 } } , { "tables" , new String [ ] { "hundreds" , "tens" , "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '583', '0', '0', '0.976190476', '1', '0', '0', '193', '1', '0.3333', '1']
package org . apache . xml . serializer ; import java . util . Properties ; public class OutputPropertyUtils { public static boolean getBooleanProperty ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null == s || ! s . equals ( "yes" ) ) return false ; else return true ; } public static int getIntProperty ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null == s ) return 0 ; else return Integer . parseInt ( s ) ; } } 	1	['3', '1', '0', '3', '7', '3', '3', '0', '3', '2', '33', '0', '0', '0', '0.555555556', '0', '0', '10', '3', '1.6667', '1']
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . IntStack ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . helpers . AttributesImpl ; public class XSLTElementProcessor extends ElemTemplateElement { XSLTElementProcessor ( ) { } private IntStack m_savedLastOrder ; private XSLTElementDef m_elemDef ; XSLTElementDef getElemDef ( ) { return m_elemDef ; } void setElemDef ( XSLTElementDef def ) { m_elemDef = def ; } public InputSource resolveEntity ( StylesheetHandler handler , String publicId , String systemId ) throws org . xml . sax . SAXException { return null ; } public void notationDecl ( StylesheetHandler handler , String name , String publicId , String systemId ) { } public void unparsedEntityDecl ( StylesheetHandler handler , String name , String publicId , String systemId , String notationName ) { } public void startNonText ( StylesheetHandler handler ) throws org . xml . sax . SAXException { } public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { if ( m_savedLastOrder == null ) m_savedLastOrder = new IntStack ( ) ; m_savedLastOrder . push ( getElemDef ( ) . getLastOrder ( ) ) ; getElemDef ( ) . setLastOrder ( - 1 ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { if ( m_savedLastOrder != null && ! m_savedLastOrder . empty ( ) ) getElemDef ( ) . setLastOrder ( m_savedLastOrder . pop ( ) ) ; if ( ! getElemDef ( ) . getRequiredFound ( ) ) handler . error ( XSLTErrorResources . ER_REQUIRED_ELEM_NOT_FOUND , new Object [ ] { getElemDef ( ) . getRequiredElem ( ) } , null ) ; } public void characters ( StylesheetHandler handler , char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { handler . error ( XSLTErrorResources . ER_CHARS_NOT_ALLOWED , null , null ) ; } public void ignorableWhitespace ( StylesheetHandler handler , char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { } public void processingInstruction ( StylesheetHandler handler , String target , String data ) throws org . xml . sax . SAXException { } public void skippedEntity ( StylesheetHandler handler , String name ) throws org . xml . sax . SAXException { } void setPropertiesFromAttributes ( StylesheetHandler handler , String rawName , Attributes attributes , ElemTemplateElement target ) throws org . xml . sax . SAXException { setPropertiesFromAttributes ( handler , rawName , attributes , target , true ) ; } Attributes setPropertiesFromAttributes ( StylesheetHandler handler , String rawName , Attributes attributes , ElemTemplateElement target , boolean throwError ) throws org . xml . sax . SAXException { XSLTElementDef def = getElemDef ( ) ; AttributesImpl undefines = null ; boolean isCompatibleMode = ( ( null != handler . getStylesheet ( ) && handler . getStylesheet ( ) . getCompatibleMode ( ) ) || ! throwError ) ; if ( isCompatibleMode ) undefines = new AttributesImpl ( ) ; Vector processedDefs = new Vector ( ) ; Vector errorDefs = new Vector ( ) ; int nAttrs = attributes . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { String attrUri = attributes . getURI ( i ) ; if ( ( null != attrUri ) && ( attrUri . length ( ) == 0 ) && ( attributes . getQName ( i ) . startsWith ( "xmlns:" ) || attributes . getQName ( i ) . equals ( "xmlns" ) ) ) { attrUri = org . apache . xalan . templates . Constants . S_XMLNAMESPACEURI ; } String attrLocalName = attributes . getLocalName ( i ) ; XSLTAttributeDef attrDef = def . getAttributeDef ( attrUri , attrLocalName ) ; if ( null == attrDef ) { if ( ! isCompatibleMode ) { handler . error ( XSLTErrorResources . ER_ATTR_NOT_ALLOWED , new Object [ ] { attributes . getQName ( i ) , rawName } , null ) ; } else { undefines . addAttribute ( attrUri , attrLocalName , attributes . getQName ( i ) , attributes . getType ( i ) , attributes . getValue ( i ) ) ; } } else { boolean success = attrDef . setAttrValue ( handler , attrUri , attrLocalName , attributes . getQName ( i ) , attributes . getValue ( i ) , target ) ; if ( success ) processedDefs . addElement ( attrDef ) ; else errorDefs . addElement ( attrDef ) ; } } XSLTAttributeDef [ ] attrDefs = def . getAttributes ( ) ; int nAttrDefs = attrDefs . length ; for ( int i = 0 ; i < nAttrDefs ; i ++ ) { XSLTAttributeDef attrDef = attrDefs [ i ] ; String defVal = attrDef . getDefault ( ) ; if ( null != defVal ) { if ( ! processedDefs . contains ( attrDef ) ) { attrDef . setDefAttrValue ( handler , target ) ; } } if ( attrDef . getRequired ( ) ) { if ( ( ! processedDefs . contains ( attrDef ) ) && ( ! errorDefs . contains ( attrDef ) ) ) handler . error ( XSLMessages . createMessage ( XSLTErrorResources . ER_REQUIRES_ATTRIB , new Object [ ] { rawName , attrDef . getName ( ) } ) , null ) ; } } return undefines ; } } 	1	['15', '3', '11', '21', '50', '101', '16', '7', '10', '0.821428571', '294', '1', '2', '0.933333333', '0.348148148', '0', '0', '18.46666667', '1', '0.9333', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . XMLChar ; import org . apache . xpath . XPathContext ; public class ElemPI extends ElemTemplateElement { private AVT m_name_atv = null ; public void setName ( AVT v ) { m_name_atv = v ; } public AVT getName ( ) { return m_name_atv ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_name_atv ) m_name_atv . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_PI ; } public String getNodeName ( ) { return Constants . ELEMNAME_PI_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; String piName = m_name_atv == null ? null : m_name_atv . evaluate ( xctxt , sourceNode , this ) ; if ( piName == null ) return ; if ( piName . equalsIgnoreCase ( "xml" ) ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , new Object [ ] { Constants . ATTRNAME_NAME , piName } ) ; return ; } else if ( ( ! m_name_atv . isSimple ( ) ) && ( ! XMLChar . isValidNCName ( piName ) ) ) { transformer . getMsgMgr ( ) . warn ( this , XSLTErrorResources . WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , new Object [ ] { Constants . ATTRNAME_NAME , piName } ) ; return ; } String data = transformer . transformToString ( this ) ; try { transformer . getResultTreeHandler ( ) . processingInstruction ( piName , data ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEXTLITERALRESULT : case Constants . ELEMNAME_APPLY_TEMPLATES : case Constants . ELEMNAME_APPLY_IMPORTS : case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_FOREACH : case Constants . ELEMNAME_VALUEOF : case Constants . ELEMNAME_COPY_OF : case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_CHOOSE : case Constants . ELEMNAME_IF : case Constants . ELEMNAME_TEXT : case Constants . ELEMNAME_COPY : case Constants . ELEMNAME_VARIABLE : case Constants . ELEMNAME_MESSAGE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } } 	1	['8', '3', '0', '12', '33', '8', '1', '11', '8', '0.428571429', '163', '1', '1', '0.965517241', '0.3', '2', '5', '19.25', '16', '2.75', '3']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . * ; import javax . xml . transform . Source ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public abstract class DTMDefaultBaseTraversers extends DTMDefaultBase { public DTMDefaultBaseTraversers ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing ) ; } public DTMDefaultBaseTraversers ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib , boolean newNameTable ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , usePrevsib , newNameTable ) ; } public DTMAxisTraverser getAxisTraverser ( final int axis ) { DTMAxisTraverser traverser ; if ( null == m_traversers ) { m_traversers = new DTMAxisTraverser [ Axis . names . length ] ; traverser = null ; } else { traverser = m_traversers [ axis ] ; if ( traverser != null ) return traverser ; } switch ( axis ) { case Axis . ANCESTOR : traverser = new AncestorTraverser ( ) ; break ; case Axis . ANCESTORORSELF : traverser = new AncestorOrSelfTraverser ( ) ; break ; case Axis . ATTRIBUTE : traverser = new AttributeTraverser ( ) ; break ; case Axis . CHILD : traverser = new ChildTraverser ( ) ; break ; case Axis . DESCENDANT : traverser = new DescendantTraverser ( ) ; break ; case Axis . DESCENDANTORSELF : traverser = new DescendantOrSelfTraverser ( ) ; break ; case Axis . FOLLOWING : traverser = new FollowingTraverser ( ) ; break ; case Axis . FOLLOWINGSIBLING : traverser = new FollowingSiblingTraverser ( ) ; break ; case Axis . NAMESPACE : traverser = new NamespaceTraverser ( ) ; break ; case Axis . NAMESPACEDECLS : traverser = new NamespaceDeclsTraverser ( ) ; break ; case Axis . PARENT : traverser = new ParentTraverser ( ) ; break ; case Axis . PRECEDING : traverser = new PrecedingTraverser ( ) ; break ; case Axis . PRECEDINGSIBLING : traverser = new PrecedingSiblingTraverser ( ) ; break ; case Axis . SELF : traverser = new SelfTraverser ( ) ; break ; case Axis . ALL : traverser = new AllFromRootTraverser ( ) ; break ; case Axis . ALLFROMNODE : traverser = new AllFromNodeTraverser ( ) ; break ; case Axis . PRECEDINGANDANCESTOR : traverser = new PrecedingAndAncestorTraverser ( ) ; break ; case Axis . DESCENDANTSFROMROOT : traverser = new DescendantFromRootTraverser ( ) ; break ; case Axis . DESCENDANTSORSELFFROMROOT : traverser = new DescendantOrSelfFromRootTraverser ( ) ; break ; case Axis . ROOT : traverser = new RootTraverser ( ) ; break ; case Axis . FILTEREDLIST : return null ; default : throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_UNKNOWN_AXIS_TYPE , new Object [ ] { Integer . toString ( axis ) } ) ) ; } if ( null == traverser ) throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_AXIS_TRAVERSER_NOT_SUPPORTED , new Object [ ] { Axis . names [ axis ] } ) ) ; m_traversers [ axis ] = traverser ; return traverser ; } private class AncestorTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return getParent ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { current = makeNodeIdentity ( current ) ; while ( DTM . NULL != ( current = m_parent . elementAt ( current ) ) ) { if ( m_exptype . elementAt ( current ) == expandedTypeID ) return makeNodeHandle ( current ) ; } return NULL ; } } private class AncestorOrSelfTraverser extends AncestorTraverser { public int first ( int context ) { return context ; } public int first ( int context , int expandedTypeID ) { return ( getExpandedTypeID ( context ) == expandedTypeID ) ? context : next ( context , context , expandedTypeID ) ; } } private class AttributeTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return ( context == current ) ? getFirstAttribute ( context ) : getNextAttribute ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { current = ( context == current ) ? getFirstAttribute ( context ) : getNextAttribute ( current ) ; do { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } while ( DTM . NULL != ( current = getNextAttribute ( current ) ) ) ; return NULL ; } } private class ChildTraverser extends DTMAxisTraverser { protected int getNextIndexed ( int axisRoot , int nextPotential , int expandedTypeID ) { int nsIndex = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; int lnIndex = m_expandedNameTable . getLocalNameID ( expandedTypeID ) ; for ( ; ; ) { int nextID = findElementFromIndex ( nsIndex , lnIndex , nextPotential ) ; if ( NOTPROCESSED != nextID ) { int parentID = m_parent . elementAt ( nextID ) ; if ( parentID == axisRoot ) return nextID ; if ( parentID < axisRoot ) return NULL ; do { parentID = m_parent . elementAt ( parentID ) ; if ( parentID < axisRoot ) return NULL ; } while ( parentID > axisRoot ) ; nextPotential = nextID + 1 ; continue ; } nextNode ( ) ; if ( ! ( m_nextsib . elementAt ( axisRoot ) == NOTPROCESSED ) ) break ; } return DTM . NULL ; } public int first ( int context ) { return getFirstChild ( context ) ; } public int first ( int context , int expandedTypeID ) { if ( true ) { int identity = makeNodeIdentity ( context ) ; int firstMatch = getNextIndexed ( identity , _firstch ( identity ) , expandedTypeID ) ; return makeNodeHandle ( firstMatch ) ; } else { for ( int current = _firstch ( makeNodeIdentity ( context ) ) ; DTM . NULL != current ; current = _nextsib ( current ) ) { if ( m_exptype . elementAt ( current ) == expandedTypeID ) return makeNodeHandle ( current ) ; } return NULL ; } } public int next ( int context , int current ) { return getNextSibling ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { for ( current = _nextsib ( makeNodeIdentity ( current ) ) ; DTM . NULL != current ; current = _nextsib ( current ) ) { if ( m_exptype . elementAt ( current ) == expandedTypeID ) return makeNodeHandle ( current ) ; } return NULL ; } } private abstract class IndexedDTMAxisTraverser extends DTMAxisTraverser { protected final boolean isIndexed ( int expandedTypeID ) { return ( m_indexing && ExpandedNameTable . ELEMENT == m_expandedNameTable . getType ( expandedTypeID ) ) ; } protected abstract boolean isAfterAxis ( int axisRoot , int identity ) ; protected abstract boolean axisHasBeenProcessed ( int axisRoot ) ; protected int getNextIndexed ( int axisRoot , int nextPotential , int expandedTypeID ) { int nsIndex = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; int lnIndex = m_expandedNameTable . getLocalNameID ( expandedTypeID ) ; while ( true ) { int next = findElementFromIndex ( nsIndex , lnIndex , nextPotential ) ; if ( NOTPROCESSED != next ) { if ( isAfterAxis ( axisRoot , next ) ) return NULL ; return next ; } else if ( axisHasBeenProcessed ( axisRoot ) ) break ; nextNode ( ) ; } return DTM . NULL ; } } private class DescendantTraverser extends IndexedDTMAxisTraverser { protected int getFirstPotential ( int identity ) { return identity + 1 ; } protected boolean axisHasBeenProcessed ( int axisRoot ) { return ! ( m_nextsib . elementAt ( axisRoot ) == NOTPROCESSED ) ; } protected int getSubtreeRoot ( int handle ) { return makeNodeIdentity ( handle ) ; } protected boolean isDescendant ( int subtreeRootIdentity , int identity ) { return _parent ( identity ) >= subtreeRootIdentity ; } protected boolean isAfterAxis ( int axisRoot , int identity ) { do { if ( identity == axisRoot ) return false ; identity = m_parent . elementAt ( identity ) ; } while ( identity >= axisRoot ) ; return true ; } public int first ( int context , int expandedTypeID ) { if ( isIndexed ( expandedTypeID ) ) { int identity = getSubtreeRoot ( context ) ; int firstPotential = getFirstPotential ( identity ) ; return makeNodeHandle ( getNextIndexed ( identity , firstPotential , expandedTypeID ) ) ; } return next ( context , context , expandedTypeID ) ; } public int next ( int context , int current ) { int subtreeRootIdent = getSubtreeRoot ( context ) ; for ( current = makeNodeIdentity ( current ) + 1 ; ; current ++ ) { int type = _type ( current ) ; if ( ! isDescendant ( subtreeRootIdent , current ) ) return NULL ; if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) continue ; return makeNodeHandle ( current ) ; } } public int next ( int context , int current , int expandedTypeID ) { int subtreeRootIdent = getSubtreeRoot ( context ) ; current = makeNodeIdentity ( current ) + 1 ; if ( isIndexed ( expandedTypeID ) ) { return makeNodeHandle ( getNextIndexed ( subtreeRootIdent , current , expandedTypeID ) ) ; } for ( ; ; current ++ ) { int exptype = _exptype ( current ) ; if ( ! isDescendant ( subtreeRootIdent , current ) ) return NULL ; if ( exptype != expandedTypeID ) continue ; return makeNodeHandle ( current ) ; } } } private class DescendantOrSelfTraverser extends DescendantTraverser { protected int getFirstPotential ( int identity ) { return identity ; } public int first ( int context ) { return context ; } } private class AllFromNodeTraverser extends DescendantOrSelfTraverser { public int next ( int context , int current ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) + 1 ; ; current ++ ) { _exptype ( current ) ; if ( ! isDescendant ( subtreeRootIdent , current ) ) return NULL ; return makeNodeHandle ( current ) ; } } } private class FollowingTraverser extends DescendantTraverser { public int first ( int context ) { context = makeNodeIdentity ( context ) ; int first ; int type = _type ( context ) ; if ( ( DTM . ATTRIBUTE_NODE == type ) || ( DTM . NAMESPACE_NODE == type ) ) { context = _parent ( context ) ; first = _firstch ( context ) ; if ( NULL != first ) return makeNodeHandle ( first ) ; } do { first = _nextsib ( context ) ; if ( NULL == first ) context = _parent ( context ) ; } while ( NULL == first && NULL != context ) ; return makeNodeHandle ( first ) ; } public int first ( int context , int expandedTypeID ) { int first ; int type = getNodeType ( context ) ; if ( ( DTM . ATTRIBUTE_NODE == type ) || ( DTM . NAMESPACE_NODE == type ) ) { context = getParent ( context ) ; first = getFirstChild ( context ) ; if ( NULL != first ) { if ( getExpandedTypeID ( first ) == expandedTypeID ) return first ; else return next ( context , first , expandedTypeID ) ; } } do { first = getNextSibling ( context ) ; if ( NULL == first ) context = getParent ( context ) ; else { if ( getExpandedTypeID ( first ) == expandedTypeID ) return first ; else return next ( context , first , expandedTypeID ) ; } } while ( NULL == first && NULL != context ) ; return first ; } public int next ( int context , int current ) { current = makeNodeIdentity ( current ) ; while ( true ) { current ++ ; int type = _type ( current ) ; if ( NULL == type ) return NULL ; if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) continue ; return makeNodeHandle ( current ) ; } } public int next ( int context , int current , int expandedTypeID ) { current = makeNodeIdentity ( current ) ; while ( true ) { current ++ ; int etype = _exptype ( current ) ; if ( NULL == etype ) return NULL ; if ( etype != expandedTypeID ) continue ; return makeNodeHandle ( current ) ; } } } private class FollowingSiblingTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return getNextSibling ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { while ( DTM . NULL != ( current = getNextSibling ( current ) ) ) { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } return NULL ; } } private class NamespaceDeclsTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return ( context == current ) ? getFirstNamespaceNode ( context , false ) : getNextNamespaceNode ( context , current , false ) ; } public int next ( int context , int current , int expandedTypeID ) { current = ( context == current ) ? getFirstNamespaceNode ( context , false ) : getNextNamespaceNode ( context , current , false ) ; do { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } while ( DTM . NULL != ( current = getNextNamespaceNode ( context , current , false ) ) ) ; return NULL ; } } private class NamespaceTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return ( context == current ) ? getFirstNamespaceNode ( context , true ) : getNextNamespaceNode ( context , current , true ) ; } public int next ( int context , int current , int expandedTypeID ) { current = ( context == current ) ? getFirstNamespaceNode ( context , true ) : getNextNamespaceNode ( context , current , true ) ; do { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } while ( DTM . NULL != ( current = getNextNamespaceNode ( context , current , true ) ) ) ; return NULL ; } } private class ParentTraverser extends DTMAxisTraverser { public int first ( int context ) { return getParent ( context ) ; } public int first ( int current , int expandedTypeID ) { current = makeNodeIdentity ( current ) ; while ( NULL != ( current = m_parent . elementAt ( current ) ) ) { if ( m_exptype . elementAt ( current ) == expandedTypeID ) return makeNodeHandle ( current ) ; } return NULL ; } public int next ( int context , int current ) { return NULL ; } public int next ( int context , int current , int expandedTypeID ) { return NULL ; } } private class PrecedingTraverser extends DTMAxisTraverser { protected boolean isAncestor ( int contextIdent , int currentIdent ) { for ( contextIdent = m_parent . elementAt ( contextIdent ) ; DTM . NULL != contextIdent ; contextIdent = m_parent . elementAt ( contextIdent ) ) { if ( contextIdent == currentIdent ) return true ; } return false ; } public int next ( int context , int current ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) - 1 ; current >= 0 ; current -- ) { short type = _type ( current ) ; if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type || isAncestor ( subtreeRootIdent , current ) ) continue ; return makeNodeHandle ( current ) ; } return NULL ; } public int next ( int context , int current , int expandedTypeID ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) - 1 ; current >= 0 ; current -- ) { int exptype = m_exptype . elementAt ( current ) ; if ( exptype != expandedTypeID || isAncestor ( subtreeRootIdent , current ) ) continue ; return makeNodeHandle ( current ) ; } return NULL ; } } private class PrecedingAndAncestorTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) - 1 ; current >= 0 ; current -- ) { short type = _type ( current ) ; if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) continue ; return makeNodeHandle ( current ) ; } return NULL ; } public int next ( int context , int current , int expandedTypeID ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) - 1 ; current >= 0 ; current -- ) { int exptype = m_exptype . elementAt ( current ) ; if ( exptype != expandedTypeID ) continue ; return makeNodeHandle ( current ) ; } return NULL ; } } private class PrecedingSiblingTraverser extends DTMAxisTraverser { public int next ( int context , int current ) { return getPreviousSibling ( current ) ; } public int next ( int context , int current , int expandedTypeID ) { while ( DTM . NULL != ( current = getPreviousSibling ( current ) ) ) { if ( getExpandedTypeID ( current ) == expandedTypeID ) return current ; } return NULL ; } } private class SelfTraverser extends DTMAxisTraverser { public int first ( int context ) { return context ; } public int first ( int context , int expandedTypeID ) { return ( getExpandedTypeID ( context ) == expandedTypeID ) ? context : NULL ; } public int next ( int context , int current ) { return NULL ; } public int next ( int context , int current , int expandedTypeID ) { return NULL ; } } private class AllFromRootTraverser extends AllFromNodeTraverser { public int first ( int context ) { return getDocumentRoot ( context ) ; } public int first ( int context , int expandedTypeID ) { return ( getExpandedTypeID ( getDocumentRoot ( context ) ) == expandedTypeID ) ? context : next ( context , context , expandedTypeID ) ; } public int next ( int context , int current ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) + 1 ; ; current ++ ) { int type = _type ( current ) ; if ( type == NULL ) return NULL ; return makeNodeHandle ( current ) ; } } public int next ( int context , int current , int expandedTypeID ) { int subtreeRootIdent = makeNodeIdentity ( context ) ; for ( current = makeNodeIdentity ( current ) + 1 ; ; current ++ ) { int exptype = _exptype ( current ) ; if ( exptype == NULL ) return NULL ; if ( exptype != expandedTypeID ) continue ; return makeNodeHandle ( current ) ; } } } private class RootTraverser extends AllFromRootTraverser { public int first ( int context , int expandedTypeID ) { int root = getDocumentRoot ( context ) ; return ( getExpandedTypeID ( root ) == expandedTypeID ) ? root : NULL ; } public int next ( int context , int current ) { return NULL ; } public int next ( int context , int current , int expandedTypeID ) { return NULL ; } } private class DescendantOrSelfFromRootTraverser extends DescendantTraverser { protected int getFirstPotential ( int identity ) { return identity ; } protected int getSubtreeRoot ( int handle ) { return makeNodeIdentity ( getDocument ( ) ) ; } public int first ( int context ) { return getDocumentRoot ( context ) ; } public int first ( int context , int expandedTypeID ) { if ( isIndexed ( expandedTypeID ) ) { int identity = 0 ; int firstPotential = getFirstPotential ( identity ) ; return makeNodeHandle ( getNextIndexed ( identity , firstPotential , expandedTypeID ) ) ; } int root = first ( context ) ; return next ( root , root , expandedTypeID ) ; } } private class DescendantFromRootTraverser extends DescendantTraverser { protected int getFirstPotential ( int identity ) { return _firstch ( 0 ) ; } protected int getSubtreeRoot ( int handle ) { return 0 ; } public int first ( int context ) { return makeNodeHandle ( _firstch ( 0 ) ) ; } public int first ( int context , int expandedTypeID ) { if ( isIndexed ( expandedTypeID ) ) { int identity = 0 ; int firstPotential = getFirstPotential ( identity ) ; return makeNodeHandle ( getNextIndexed ( identity , firstPotential , expandedTypeID ) ) ; } int root = getDocumentRoot ( context ) ; return next ( root , root , expandedTypeID ) ; } } } 	1	['3', '2', '1', '31', '28', '3', '22', '29', '3', '2', '226', '0', '0', '0.989130435', '0.761904762', '0', '0', '74.33333333', '5', '1.6667', '2']
package org . apache . xml . utils ; import java . io . Serializable ; import org . apache . xml . dtm . DTM ; public class NodeVector implements Serializable , Cloneable { private int m_blocksize ; private int m_map [ ] ; protected int m_firstFree = 0 ; private int m_mapSize ; public NodeVector ( ) { m_blocksize = 32 ; m_mapSize = 0 ; } public NodeVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = 0 ; } public Object clone ( ) throws CloneNotSupportedException { NodeVector clone = ( NodeVector ) super . clone ( ) ; if ( ( null != this . m_map ) && ( this . m_map == clone . m_map ) ) { clone . m_map = new int [ this . m_map . length ] ; System . arraycopy ( this . m_map , 0 , clone . m_map , 0 , this . m_map . length ) ; } return clone ; } public int size ( ) { return m_firstFree ; } public void addElement ( int value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final void push ( int value ) { int ff = m_firstFree ; if ( ( ff + 1 ) >= m_mapSize ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , ff + 1 ) ; m_map = newMap ; } } m_map [ ff ] = value ; ff ++ ; m_firstFree = ff ; } public final int pop ( ) { m_firstFree -- ; int n = m_map [ m_firstFree ] ; m_map [ m_firstFree ] = DTM . NULL ; return n ; } public final int popAndTop ( ) { m_firstFree -- ; m_map [ m_firstFree ] = DTM . NULL ; return ( m_firstFree == 0 ) ? DTM . NULL : m_map [ m_firstFree - 1 ] ; } public final void popQuick ( ) { m_firstFree -- ; m_map [ m_firstFree ] = DTM . NULL ; } public final int peepOrNull ( ) { return ( ( null != m_map ) && ( m_firstFree > 0 ) ) ? m_map [ m_firstFree - 1 ] : DTM . NULL ; } public final void pushPair ( int v1 , int v2 ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { if ( ( m_firstFree + 2 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree ) ; m_map = newMap ; } } m_map [ m_firstFree ] = v1 ; m_map [ m_firstFree + 1 ] = v2 ; m_firstFree += 2 ; } public final void popPair ( ) { m_firstFree -= 2 ; m_map [ m_firstFree ] = DTM . NULL ; m_map [ m_firstFree + 1 ] = DTM . NULL ; } public final void setTail ( int n ) { m_map [ m_firstFree - 1 ] = n ; } public final void setTailSub1 ( int n ) { m_map [ m_firstFree - 2 ] = n ; } public final int peepTail ( ) { return m_map [ m_firstFree - 1 ] ; } public final int peepTailSub1 ( ) { return m_map [ m_firstFree - 2 ] ; } public void insertInOrder ( int value ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( value < m_map [ i ] ) { insertElementAt ( value , i ) ; return ; } } addElement ( value ) ; } public void insertElementAt ( int value , int at ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } else if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } if ( at <= ( m_firstFree - 1 ) ) { System . arraycopy ( m_map , at , m_map , at + 1 , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; } public void appendNodes ( NodeVector nodes ) { int nNodes = nodes . size ( ) ; if ( null == m_map ) { m_mapSize = nNodes + m_blocksize ; m_map = new int [ m_mapSize ] ; } else if ( ( m_firstFree + nNodes ) >= m_mapSize ) { m_mapSize += ( nNodes + m_blocksize ) ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + nNodes ) ; m_map = newMap ; } System . arraycopy ( nodes . m_map , 0 , m_map , m_firstFree , nNodes ) ; m_firstFree += nNodes ; } public void removeAllElements ( ) { if ( null == m_map ) return ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { m_map [ i ] = DTM . NULL ; } m_firstFree = 0 ; } public void RemoveAllNoClear ( ) { if ( null == m_map ) return ; m_firstFree = 0 ; } public boolean removeElement ( int s ) { if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == s ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = DTM . NULL ; m_firstFree -- ; return true ; } } return false ; } public void removeElementAt ( int i ) { if ( null == m_map ) return ; if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = DTM . NULL ; } public void setElementAt ( int node , int index ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapSize = m_blocksize ; } if ( index == - 1 ) addElement ( node ) ; m_map [ index ] = node ; } public int elementAt ( int i ) { if ( null == m_map ) return DTM . NULL ; return m_map [ i ] ; } public boolean contains ( int s ) { if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == s ) return true ; } return false ; } public int indexOf ( int elem , int index ) { if ( null == m_map ) return - 1 ; for ( int i = index ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == elem ) return i ; } return - 1 ; } public int indexOf ( int elem ) { if ( null == m_map ) return - 1 ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { int node = m_map [ i ] ; if ( node == elem ) return i ; } return - 1 ; } public void sort ( int a [ ] , int lo0 , int hi0 ) throws Exception { int lo = lo0 ; int hi = hi0 ; if ( lo >= hi ) { return ; } else if ( lo == hi - 1 ) { if ( a [ lo ] > a [ hi ] ) { int T = a [ lo ] ; a [ lo ] = a [ hi ] ; a [ hi ] = T ; } return ; } int pivot = a [ ( lo + hi ) / 2 ] ; a [ ( lo + hi ) / 2 ] = a [ hi ] ; a [ hi ] = pivot ; while ( lo < hi ) { while ( a [ lo ] <= pivot && lo < hi ) { lo ++ ; } while ( pivot <= a [ hi ] && lo < hi ) { hi -- ; } if ( lo < hi ) { int T = a [ lo ] ; a [ lo ] = a [ hi ] ; a [ hi ] = T ; } } a [ hi0 ] = a [ hi ] ; a [ hi ] = pivot ; sort ( a , lo0 , lo - 1 ) ; sort ( a , hi + 1 , hi0 ) ; } public void sort ( ) throws Exception { sort ( m_map , 0 , m_firstFree - 1 ) ; } } 	1	['30', '1', '1', '9', '33', '0', '9', '0', '30', '0.422413793', '933', '1', '0', '0', '0.4', '0', '0', '29.96666667', '5', '2.1667', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; public class ExpandedNameTable { private ExtendedType [ ] m_extendedTypes ; private static int m_initialSize = 128 ; private int m_nextType ; public static final int ELEMENT = ( ( int ) DTM . ELEMENT_NODE ) ; public static final int ATTRIBUTE = ( ( int ) DTM . ATTRIBUTE_NODE ) ; public static final int TEXT = ( ( int ) DTM . TEXT_NODE ) ; public static final int CDATA_SECTION = ( ( int ) DTM . CDATA_SECTION_NODE ) ; public static final int ENTITY_REFERENCE = ( ( int ) DTM . ENTITY_REFERENCE_NODE ) ; public static final int ENTITY = ( ( int ) DTM . ENTITY_NODE ) ; public static final int PROCESSING_INSTRUCTION = ( ( int ) DTM . PROCESSING_INSTRUCTION_NODE ) ; public static final int COMMENT = ( ( int ) DTM . COMMENT_NODE ) ; public static final int DOCUMENT = ( ( int ) DTM . DOCUMENT_NODE ) ; public static final int DOCUMENT_TYPE = ( ( int ) DTM . DOCUMENT_TYPE_NODE ) ; public static final int DOCUMENT_FRAGMENT = ( ( int ) DTM . DOCUMENT_FRAGMENT_NODE ) ; public static final int NOTATION = ( ( int ) DTM . NOTATION_NODE ) ; public static final int NAMESPACE = ( ( int ) DTM . NAMESPACE_NODE ) ; ExtendedType hashET = new ExtendedType ( - 1 , "" , "" ) ; private static ExtendedType [ ] m_defaultExtendedTypes ; private static float m_loadFactor = 0.75f ; private static int m_initialCapacity = 203 ; private int m_capacity ; private int m_threshold ; private HashEntry [ ] m_table ; static { m_defaultExtendedTypes = new ExtendedType [ DTM . NTYPES ] ; for ( int i = 0 ; i < DTM . NTYPES ; i ++ ) { m_defaultExtendedTypes [ i ] = new ExtendedType ( i , "" , "" ) ; } } public ExpandedNameTable ( ) { m_capacity = m_initialCapacity ; m_threshold = ( int ) ( m_capacity * m_loadFactor ) ; m_table = new HashEntry [ m_capacity ] ; initExtendedTypes ( ) ; } private void initExtendedTypes ( ) { m_extendedTypes = new ExtendedType [ m_initialSize ] ; for ( int i = 0 ; i < DTM . NTYPES ; i ++ ) { m_extendedTypes [ i ] = m_defaultExtendedTypes [ i ] ; m_table [ i ] = new HashEntry ( m_defaultExtendedTypes [ i ] , i , i , null ) ; } m_nextType = DTM . NTYPES ; } public int getExpandedTypeID ( String namespace , String localName , int type ) { return getExpandedTypeID ( namespace , localName , type , false ) ; } public int getExpandedTypeID ( String namespace , String localName , int type , boolean searchOnly ) { if ( null == namespace ) namespace = "" ; if ( null == localName ) localName = "" ; int hash = type + namespace . hashCode ( ) + localName . hashCode ( ) ; hashET . redefine ( type , namespace , localName , hash ) ; int index = hash % m_capacity ; if ( index < 0 ) index = - index ; for ( HashEntry e = m_table [ index ] ; e != null ; e = e . next ) { if ( e . hash == hash && e . key . equals ( hashET ) ) return e . value ; } if ( searchOnly ) { return DTM . NULL ; } if ( m_nextType > m_threshold ) { rehash ( ) ; index = hash % m_capacity ; if ( index < 0 ) index = - index ; } ExtendedType newET = new ExtendedType ( type , namespace , localName , hash ) ; if ( m_extendedTypes . length == m_nextType ) { ExtendedType [ ] newArray = new ExtendedType [ m_extendedTypes . length * 2 ] ; System . arraycopy ( m_extendedTypes , 0 , newArray , 0 , m_extendedTypes . length ) ; m_extendedTypes = newArray ; } m_extendedTypes [ m_nextType ] = newET ; HashEntry entry = new HashEntry ( newET , m_nextType , hash , m_table [ index ] ) ; m_table [ index ] = entry ; return m_nextType ++ ; } private void rehash ( ) { int oldCapacity = m_capacity ; HashEntry [ ] oldTable = m_table ; int newCapacity = 2 * oldCapacity + 1 ; m_capacity = newCapacity ; m_threshold = ( int ) ( newCapacity * m_loadFactor ) ; m_table = new HashEntry [ newCapacity ] ; for ( int i = oldCapacity - 1 ; i >= 0 ; i -- ) { for ( HashEntry old = oldTable [ i ] ; old != null ; ) { HashEntry e = old ; old = old . next ; int newIndex = e . hash % newCapacity ; if ( newIndex < 0 ) newIndex = - newIndex ; e . next = m_table [ newIndex ] ; m_table [ newIndex ] = e ; } } } public int getExpandedTypeID ( int type ) { return type ; } public String getLocalName ( int ExpandedNameID ) { return m_extendedTypes [ ExpandedNameID ] . getLocalName ( ) ; } public final int getLocalNameID ( int ExpandedNameID ) { if ( m_extendedTypes [ ExpandedNameID ] . getLocalName ( ) . equals ( "" ) ) return 0 ; else return ExpandedNameID ; } public String getNamespace ( int ExpandedNameID ) { String namespace = m_extendedTypes [ ExpandedNameID ] . getNamespace ( ) ; return ( namespace . equals ( "" ) ? null : namespace ) ; } public final int getNamespaceID ( int ExpandedNameID ) { if ( m_extendedTypes [ ExpandedNameID ] . getNamespace ( ) . equals ( "" ) ) return 0 ; else return ExpandedNameID ; } public final short getType ( int ExpandedNameID ) { return ( short ) m_extendedTypes [ ExpandedNameID ] . getNodeType ( ) ; } public int getSize ( ) { return m_nextType ; } public ExtendedType [ ] getExtendedTypes ( ) { return m_extendedTypes ; } private static final class HashEntry { ExtendedType key ; int value ; int hash ; HashEntry next ; protected HashEntry ( ExtendedType key , int value , int hash , HashEntry next ) { this . key = key ; this . value = value ; this . hash = hash ; this . next = next ; } } } 	1	['14', '1', '0', '24', '26', '15', '22', '2', '11', '0.933110368', '405', '0.391304348', '4', '0', '0.461538462', '0', '0', '26.28571429', '11', '2.0714', '1']
package org . apache . xalan . xsltc . compiler ; import java . io . BufferedOutputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Map ; import java . util . Properties ; import java . util . Vector ; import java . util . jar . JarEntry ; import java . util . jar . JarOutputStream ; import java . util . jar . Manifest ; import org . apache . bcel . classfile . JavaClass ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . dtm . DTM ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; public final class XSLTC { private Parser _parser ; private XMLReader _reader = null ; private SourceLoader _loader = null ; private Stylesheet _stylesheet ; private int _modeSerial = 1 ; private int _stylesheetSerial = 1 ; private int _stepPatternSerial = 1 ; private int _helperClassSerial = 0 ; private int _attributeSetSerial = 0 ; private int [ ] _numberFieldIndexes ; private int _nextGType ; private Vector _namesIndex ; private Hashtable _elements ; private Hashtable _attributes ; private int _nextNSType ; private Vector _namespaceIndex ; private Hashtable _namespaces ; private Hashtable _namespacePrefixes ; private Vector m_characterData ; public static final int FILE_OUTPUT = 0 ; public static final int JAR_OUTPUT = 1 ; public static final int BYTEARRAY_OUTPUT = 2 ; public static final int CLASSLOADER_OUTPUT = 3 ; public static final int BYTEARRAY_AND_FILE_OUTPUT = 4 ; public static final int BYTEARRAY_AND_JAR_OUTPUT = 5 ; private boolean _debug = false ; private String _jarFileName = null ; private String _className = null ; private String _packageName = null ; private File _destDir = null ; private int _outputType = FILE_OUTPUT ; private Vector _classes ; private Vector _bcelClasses ; private boolean _callsNodeset = false ; private boolean _multiDocument = false ; private boolean _hasIdCall = false ; private boolean _templateInlining = false ; public XSLTC ( ) { _parser = new Parser ( this ) ; } public Parser getParser ( ) { return _parser ; } public void setOutputType ( int type ) { _outputType = type ; } public Properties getOutputProperties ( ) { return _parser . getOutputProperties ( ) ; } public void init ( ) { reset ( ) ; _reader = null ; _classes = new Vector ( ) ; _bcelClasses = new Vector ( ) ; } private void reset ( ) { _nextGType = DTM . NTYPES ; _elements = new Hashtable ( ) ; _attributes = new Hashtable ( ) ; _namespaces = new Hashtable ( ) ; _namespaces . put ( "" , new Integer ( _nextNSType ) ) ; _namesIndex = new Vector ( 128 ) ; _namespaceIndex = new Vector ( 32 ) ; _namespacePrefixes = new Hashtable ( ) ; _stylesheet = null ; _parser . init ( ) ; _modeSerial = 1 ; _stylesheetSerial = 1 ; _stepPatternSerial = 1 ; _helperClassSerial = 0 ; _attributeSetSerial = 0 ; _multiDocument = false ; _hasIdCall = false ; _numberFieldIndexes = new int [ ] { - 1 , - 1 , - 1 } ; } public void setSourceLoader ( SourceLoader loader ) { _loader = loader ; } public void setTemplateInlining ( boolean templateInlining ) { _templateInlining = templateInlining ; } public void setPIParameters ( String media , String title , String charset ) { _parser . setPIParameters ( media , title , charset ) ; } public boolean compile ( URL url ) { try { final InputStream stream = url . openStream ( ) ; final InputSource input = new InputSource ( stream ) ; input . setSystemId ( url . toString ( ) ) ; return compile ( input , _className ) ; } catch ( IOException e ) { _parser . reportError ( Constants . FATAL , new ErrorMsg ( e ) ) ; return false ; } } public boolean compile ( URL url , String name ) { try { final InputStream stream = url . openStream ( ) ; final InputSource input = new InputSource ( stream ) ; input . setSystemId ( url . toString ( ) ) ; return compile ( input , name ) ; } catch ( IOException e ) { _parser . reportError ( Constants . FATAL , new ErrorMsg ( e ) ) ; return false ; } } public boolean compile ( InputStream stream , String name ) { final InputSource input = new InputSource ( stream ) ; input . setSystemId ( name ) ; return compile ( input , name ) ; } public boolean compile ( InputSource input , String name ) { try { reset ( ) ; String systemId = null ; if ( input != null ) { systemId = input . getSystemId ( ) ; } if ( _className == null ) { if ( name != null ) { setClassName ( name ) ; } else if ( systemId != null && ! systemId . equals ( "" ) ) { setClassName ( Util . baseName ( systemId ) ) ; } if ( _className == null || _className . length ( ) == 0 ) { setClassName ( "GregorSamsa" ) ; } } SyntaxTreeNode element = null ; if ( _reader == null ) { element = _parser . parse ( input ) ; } else { element = _parser . parse ( _reader , input ) ; } if ( ( ! _parser . errorsFound ( ) ) && ( element != null ) ) { _stylesheet = _parser . makeStylesheet ( element ) ; _stylesheet . setSourceLoader ( _loader ) ; _stylesheet . setSystemId ( systemId ) ; _stylesheet . setParentStylesheet ( null ) ; _stylesheet . setTemplateInlining ( _templateInlining ) ; _parser . setCurrentStylesheet ( _stylesheet ) ; _parser . createAST ( _stylesheet ) ; } if ( ( ! _parser . errorsFound ( ) ) && ( _stylesheet != null ) ) { _stylesheet . setCallsNodeset ( _callsNodeset ) ; _stylesheet . setMultiDocument ( _multiDocument ) ; _stylesheet . setHasIdCall ( _hasIdCall ) ; synchronized ( getClass ( ) ) { _stylesheet . translate ( ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; _parser . reportError ( Constants . FATAL , new ErrorMsg ( e ) ) ; } catch ( Error e ) { if ( _debug ) e . printStackTrace ( ) ; _parser . reportError ( Constants . FATAL , new ErrorMsg ( e ) ) ; } finally { _reader = null ; } return ! _parser . errorsFound ( ) ; } public boolean compile ( Vector stylesheets ) { final int count = stylesheets . size ( ) ; if ( count == 0 ) return true ; if ( count == 1 ) { final Object url = stylesheets . firstElement ( ) ; if ( url instanceof URL ) return compile ( ( URL ) url ) ; else return false ; } else { final Enumeration urls = stylesheets . elements ( ) ; while ( urls . hasMoreElements ( ) ) { _className = null ; final Object url = urls . nextElement ( ) ; if ( url instanceof URL ) { if ( ! compile ( ( URL ) url ) ) return false ; } } } return true ; } public byte [ ] [ ] getBytecodes ( ) { final int count = _classes . size ( ) ; final byte [ ] [ ] result = new byte [ count ] [ 1 ] ; for ( int i = 0 ; i < count ; i ++ ) result [ i ] = ( byte [ ] ) _classes . elementAt ( i ) ; return result ; } public byte [ ] [ ] compile ( String name , InputSource input , int outputType ) { _outputType = outputType ; if ( compile ( input , name ) ) return getBytecodes ( ) ; else return null ; } public byte [ ] [ ] compile ( String name , InputSource input ) { return compile ( name , input , BYTEARRAY_OUTPUT ) ; } public void setXMLReader ( XMLReader reader ) { _reader = reader ; } public XMLReader getXMLReader ( ) { return _reader ; } public Vector getErrors ( ) { return _parser . getErrors ( ) ; } public Vector getWarnings ( ) { return _parser . getWarnings ( ) ; } public void printErrors ( ) { _parser . printErrors ( ) ; } public void printWarnings ( ) { _parser . printWarnings ( ) ; } protected void setMultiDocument ( boolean flag ) { _multiDocument = flag ; } public boolean isMultiDocument ( ) { return _multiDocument ; } protected void setCallsNodeset ( boolean flag ) { if ( flag ) setMultiDocument ( flag ) ; _callsNodeset = flag ; } public boolean callsNodeset ( ) { return _callsNodeset ; } protected void setHasIdCall ( boolean flag ) { _hasIdCall = flag ; } public boolean hasIdCall ( ) { return _hasIdCall ; } public void setClassName ( String className ) { final String base = Util . baseName ( className ) ; final String noext = Util . noExtName ( base ) ; String name = Util . toJavaName ( noext ) ; if ( _packageName == null ) _className = name ; else _className = _packageName + '.' + name ; } public String getClassName ( ) { return _className ; } private String classFileName ( final String className ) { return className . replace ( '.' , File . separatorChar ) + ".class" ; } private File getOutputFile ( String className ) { if ( _destDir != null ) return new File ( _destDir , classFileName ( className ) ) ; else return new File ( classFileName ( className ) ) ; } public boolean setDestDirectory ( String dstDirName ) { final File dir = new File ( dstDirName ) ; if ( dir . exists ( ) || dir . mkdirs ( ) ) { _destDir = dir ; return true ; } else { _destDir = null ; return false ; } } public void setPackageName ( String packageName ) { _packageName = packageName ; if ( _className != null ) setClassName ( _className ) ; } public void setJarFileName ( String jarFileName ) { final String JAR_EXT = ".jar" ; if ( jarFileName . endsWith ( JAR_EXT ) ) _jarFileName = jarFileName ; else _jarFileName = jarFileName + JAR_EXT ; _outputType = JAR_OUTPUT ; } public String getJarFileName ( ) { return _jarFileName ; } public void setStylesheet ( Stylesheet stylesheet ) { if ( _stylesheet == null ) _stylesheet = stylesheet ; } public Stylesheet getStylesheet ( ) { return _stylesheet ; } public int registerAttribute ( QName name ) { Integer code = ( Integer ) _attributes . get ( name . toString ( ) ) ; if ( code == null ) { code = new Integer ( _nextGType ++ ) ; _attributes . put ( name . toString ( ) , code ) ; final String uri = name . getNamespace ( ) ; final String local = "@" + name . getLocalPart ( ) ; if ( ( uri != null ) && ( ! uri . equals ( "" ) ) ) _namesIndex . addElement ( uri + ":" + local ) ; else _namesIndex . addElement ( local ) ; if ( name . getLocalPart ( ) . equals ( "*" ) ) { registerNamespace ( name . getNamespace ( ) ) ; } } return code . intValue ( ) ; } public int registerElement ( QName name ) { Integer code = ( Integer ) _elements . get ( name . toString ( ) ) ; if ( code == null ) { _elements . put ( name . toString ( ) , code = new Integer ( _nextGType ++ ) ) ; _namesIndex . addElement ( name . toString ( ) ) ; } if ( name . getLocalPart ( ) . equals ( "*" ) ) { registerNamespace ( name . getNamespace ( ) ) ; } return code . intValue ( ) ; } public int registerNamespacePrefix ( QName name ) { Integer code = ( Integer ) _namespacePrefixes . get ( name . toString ( ) ) ; if ( code == null ) { code = new Integer ( _nextGType ++ ) ; _namespacePrefixes . put ( name . toString ( ) , code ) ; final String uri = name . getNamespace ( ) ; if ( ( uri != null ) && ( ! uri . equals ( "" ) ) ) { _namesIndex . addElement ( "?" ) ; } else { _namesIndex . addElement ( "?" + name . getLocalPart ( ) ) ; } } return code . intValue ( ) ; } public int registerNamespace ( String namespaceURI ) { Integer code = ( Integer ) _namespaces . get ( namespaceURI ) ; if ( code == null ) { code = new Integer ( _nextNSType ++ ) ; _namespaces . put ( namespaceURI , code ) ; _namespaceIndex . addElement ( namespaceURI ) ; } return code . intValue ( ) ; } public int nextModeSerial ( ) { return _modeSerial ++ ; } public int nextStylesheetSerial ( ) { return _stylesheetSerial ++ ; } public int nextStepPatternSerial ( ) { return _stepPatternSerial ++ ; } public int [ ] getNumberFieldIndexes ( ) { return _numberFieldIndexes ; } public int nextHelperClassSerial ( ) { return _helperClassSerial ++ ; } public int nextAttributeSetSerial ( ) { return _attributeSetSerial ++ ; } public Vector getNamesIndex ( ) { return _namesIndex ; } public Vector getNamespaceIndex ( ) { return _namespaceIndex ; } public String getHelperClassName ( ) { return getClassName ( ) + '$' + _helperClassSerial ++ ; } public void dumpClass ( JavaClass clazz ) { if ( _outputType == FILE_OUTPUT || _outputType == BYTEARRAY_AND_FILE_OUTPUT ) { File outFile = getOutputFile ( clazz . getClassName ( ) ) ; String parentDir = outFile . getParent ( ) ; if ( parentDir != null ) { File parentFile = new File ( parentDir ) ; if ( ! parentFile . exists ( ) ) parentFile . mkdirs ( ) ; } } try { switch ( _outputType ) { case FILE_OUTPUT : clazz . dump ( new BufferedOutputStream ( new FileOutputStream ( getOutputFile ( clazz . getClassName ( ) ) ) ) ) ; break ; case JAR_OUTPUT : _bcelClasses . addElement ( clazz ) ; break ; case BYTEARRAY_OUTPUT : case BYTEARRAY_AND_FILE_OUTPUT : case BYTEARRAY_AND_JAR_OUTPUT : case CLASSLOADER_OUTPUT : ByteArrayOutputStream out = new ByteArrayOutputStream ( 2048 ) ; clazz . dump ( out ) ; _classes . addElement ( out . toByteArray ( ) ) ; if ( _outputType == BYTEARRAY_AND_FILE_OUTPUT ) clazz . dump ( new BufferedOutputStream ( new FileOutputStream ( getOutputFile ( clazz . getClassName ( ) ) ) ) ) ; else if ( _outputType == BYTEARRAY_AND_JAR_OUTPUT ) _bcelClasses . addElement ( clazz ) ; break ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } private String entryName ( File f ) throws IOException { return f . getName ( ) . replace ( File . separatorChar , '/' ) ; } public void outputToJar ( ) throws IOException { final Manifest manifest = new Manifest ( ) ; final java . util . jar . Attributes atrs = manifest . getMainAttributes ( ) ; atrs . put ( java . util . jar . Attributes . Name . MANIFEST_VERSION , "1.2" ) ; final Map map = manifest . getEntries ( ) ; Enumeration classes = _bcelClasses . elements ( ) ; final String now = ( new Date ( ) ) . toString ( ) ; final java . util . jar . Attributes . Name dateAttr = new java . util . jar . Attributes . Name ( "Date" ) ; while ( classes . hasMoreElements ( ) ) { final JavaClass clazz = ( JavaClass ) classes . nextElement ( ) ; final String className = clazz . getClassName ( ) . replace ( '.' , '/' ) ; final java . util . jar . Attributes attr = new java . util . jar . Attributes ( ) ; attr . put ( dateAttr , now ) ; map . put ( className + ".class" , attr ) ; } final File jarFile = new File ( _destDir , _jarFileName ) ; final JarOutputStream jos = new JarOutputStream ( new FileOutputStream ( jarFile ) , manifest ) ; classes = _bcelClasses . elements ( ) ; while ( classes . hasMoreElements ( ) ) { final JavaClass clazz = ( JavaClass ) classes . nextElement ( ) ; final String className = clazz . getClassName ( ) . replace ( '.' , '/' ) ; jos . putNextEntry ( new JarEntry ( className + ".class" ) ) ; final ByteArrayOutputStream out = new ByteArrayOutputStream ( 2048 ) ; clazz . dump ( out ) ; out . writeTo ( jos ) ; } jos . close ( ) ; } public void setDebug ( boolean debug ) { _debug = debug ; } public boolean debug ( ) { return _debug ; } public String getCharacterData ( int index ) { return ( ( StringBuffer ) m_characterData . elementAt ( index ) ) . toString ( ) ; } public int getCharacterDataCount ( ) { return ( m_characterData != null ) ? m_characterData . size ( ) : 0 ; } public int addCharacterData ( String newData ) { StringBuffer currData ; if ( m_characterData == null ) { m_characterData = new Vector ( ) ; currData = new StringBuffer ( ) ; m_characterData . addElement ( currData ) ; } else { currData = ( StringBuffer ) m_characterData . elementAt ( m_characterData . size ( ) - 1 ) ; } if ( newData . length ( ) + currData . length ( ) > 21845 ) { currData = new StringBuffer ( ) ; m_characterData . addElement ( currData ) ; } int newDataOffset = currData . length ( ) ; currData . append ( newData ) ; return newDataOffset ; } } 	1	['60', '1', '0', '25', '152', '1408', '21', '8', '53', '0.903344022', '1394', '0.837837838', '3', '0', '0.11547619', '0', '0', '21.61666667', '15', '1.75', '2']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . OpCodes ; import org . apache . xpath . objects . XNodeSet ; public class FilterExprWalker extends AxesWalker { public FilterExprWalker ( WalkingIterator locPathIterator ) { super ( locPathIterator , Axis . FILTEREDLIST ) ; } public void init ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { super . init ( compiler , opPos , stepType ) ; switch ( stepType ) { case OpCodes . OP_FUNCTION : case OpCodes . OP_EXTFUNCTION : m_mustHardReset = true ; case OpCodes . OP_GROUP : case OpCodes . OP_VARIABLE : m_expr = compiler . compile ( opPos ) ; m_expr . exprSetParent ( this ) ; if ( m_expr instanceof org . apache . xpath . operations . Variable ) { m_canDetachNodeset = false ; } break ; default : m_expr = compiler . compile ( opPos + 2 ) ; m_expr . exprSetParent ( this ) ; } } public void detach ( ) { super . detach ( ) ; if ( m_canDetachNodeset ) { m_exprObj . detach ( ) ; } m_exprObj = null ; } public void setRoot ( int root ) { super . setRoot ( root ) ; m_exprObj = FilterExprIteratorSimple . executeFilterExpr ( root , m_lpi . getXPathContext ( ) , m_lpi . getPrefixResolver ( ) , m_lpi . getIsTopLevel ( ) , m_lpi . m_stackFrame , m_expr ) ; } public Object clone ( ) throws CloneNotSupportedException { FilterExprWalker clone = ( FilterExprWalker ) super . clone ( ) ; if ( null != m_exprObj ) clone . m_exprObj = ( XNodeSet ) m_exprObj . clone ( ) ; return clone ; } public short acceptNode ( int n ) { try { if ( getPredicateCount ( ) > 0 ) { countProximityPosition ( 0 ) ; if ( ! executePredicates ( n , m_lpi . getXPathContext ( ) ) ) return DTMIterator . FILTER_SKIP ; } return DTMIterator . FILTER_ACCEPT ; } catch ( javax . xml . transform . TransformerException se ) { throw new RuntimeException ( se . getMessage ( ) ) ; } } public int getNextNode ( ) { if ( null != m_exprObj ) { int next = m_exprObj . nextNode ( ) ; return next ; } else return DTM . NULL ; } public int getLastPos ( XPathContext xctxt ) { return m_exprObj . getLength ( ) ; } private Expression m_expr ; transient private XNodeSet m_exprObj ; private boolean m_mustHardReset = false ; private boolean m_canDetachNodeset = true ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; m_expr . fixupVariables ( vars , globalsSize ) ; } public Expression getInnerExpression ( ) { return m_expr ; } public void setInnerExpression ( Expression expr ) { expr . exprSetParent ( this ) ; m_expr = expr ; } public int getAnalysisBits ( ) { if ( null != m_expr && m_expr instanceof PathComponent ) { return ( ( PathComponent ) m_expr ) . getAnalysisBits ( ) ; } return WalkerFactory . BIT_FILTER ; } public boolean isDocOrdered ( ) { return m_exprObj . isDocOrdered ( ) ; } public int getAxis ( ) { return m_exprObj . getAxis ( ) ; } class filterExprOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_expr ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FilterExprWalker . this ) ; m_expr = exp ; } } public void callPredicateVisitors ( XPathVisitor visitor ) { m_expr . callVisitors ( new filterExprOwner ( ) , visitor ) ; super . callPredicateVisitors ( visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; FilterExprWalker walker = ( FilterExprWalker ) expr ; if ( ! m_expr . deepEquals ( walker . m_expr ) ) return false ; return true ; } } 	1	['18', '5', '0', '19', '48', '13', '5', '15', '16', '0.735294118', '244', '1', '2', '0.858333333', '0.185185185', '4', '14', '12.33333333', '3', '1.3889', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_it extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "Più fogli di stile definiti nello stesso file. " } , { ErrorMsg . TEMPLATE_REDEF_ERR , "Maschera ''{0}'' già definita in questo foglio di stile. " } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "Maschera ''{0}'' non definita in questo foglio di stile. " } , { ErrorMsg . VARIABLE_REDEF_ERR , "Variabile ''{0}'' definita più volte nello stesso ambito. " } , { ErrorMsg . VARIABLE_UNDEF_ERR , "Variabile o parametro ''{0}'' non definito. " } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "Impossibile trovare la classe ''{0}''." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "Impossibile trovare il metodo esterno ''{0}'' (deve essere public)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Impossibile convertire il tipo di argomento/ritorno nella chiamata nel metodo ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "File o URI ''{0}'' non trovato. " } , { ErrorMsg . INVALID_URI_ERR , "URI ''{0}'' non valido. " } , { ErrorMsg . FILE_ACCESS_ERR , "Impossibile aprire il file o l''URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "Era previsto l'elemento <xsl:stylesheet> o <xsl:transform>. " } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Il prefisso dello spazio nome ''{0}'' non è dichiarato. " } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Impossibile risolvere la chiamata alla funzione ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "L''argomento di ''{0}'' deve essere una stringa letterale. " } , { ErrorMsg . XPATH_PARSER_ERR , "Errore durante l''analisi dell''espressione XPath ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Attributo ''{0}'' richiesto mancante. " } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Carattere non valido ''{0}'' nell''espressione XPath. " } , { ErrorMsg . ILLEGAL_PI_ERR , "Nome ''{0}'' non valido per l''istruzione di elaborazione. " } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "Attributo ''{0}'' al di fuori dell''elemento. " } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Attributo ''{0}'' non valido. " } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Import/include circolare. Foglio di lavoro ''{0}'' già caricato. " } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Impossibile ordinare i frammenti della struttura ad albero dei risultati (elementi <xsl:sort> ignorati). E' necessario ordinare i nodi quando si crea la struttura ad albero dei risultati. " } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Formattazione decimale ''{0}'' già definita. " } , { ErrorMsg . XSL_VERSION_ERR , "Versione XSL ''{0}'' non supportata da XSLTC." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Riferimento variabile/parametro circolare in ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Operatore sconosciuto per l'espressione binaria. " } , { ErrorMsg . ILLEGAL_ARG_ERR , "Argomento(i) non valido(i) per la chiamata alla funzione. " } , { ErrorMsg . DOCUMENT_ARG_ERR , "Il secondo argomento di una funzione document() deve essere una serie di nodi. " } , { ErrorMsg . MISSING_WHEN_ERR , "E' necessario almeno un elemento <xsl:when> in <xsl:choose>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "Solo un elemento <xsl:otherwise> consentito in <xsl:choose>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> può essere utilizzato solo all'interno di <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> può essere utilizzato solo all'interno di <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "Solo gli elementi <xsl:when> e <xsl:otherwise> sono consentiti in <xsl:choose>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set> non contiene l'attributo 'name'. " } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Elemento secondario non valido. " } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "Impossibile assegnare il nome ''{0}'' ad un elemento " } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "Impossibile assegnare il nome ''{0}'' ad un attributo " } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Dati di testo al di fuori dell'elemento <xsl:stylesheet> di livello superiore. " } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "Parser JAXP non configurato correttamente " } , { ErrorMsg . INTERNAL_ERR , "Errore XSLTC interno non recuperabile: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Elemento XSL ''{0}'' non supportato." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "Estensione XSLTC ''{0}'' non riconosciuta." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "Il documento di immissione non è un foglio di stile (lo spazio nomi XSL non è dichiarato nell'elemento root). " } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Impossibile trovare la destinazione del foglio di stile ''{0}''." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Non implementato: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "Il documento di immissione non contiene un foglio di stile XSL. " } , { ErrorMsg . ELEMENT_PARSE_ERR , "Impossibile analizzare l''elemento ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "L'attributo use di <key> deve essere node, node-set, string o number." } , { ErrorMsg . OUTPUT_VERSION_ERR , "La versione del documento XML di emissione deve essere 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Operatore sconosciuto per l'espressione relazionale " } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Tentativo di utilizzare una serie di attributi ''{0}'' non esistente." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Impossibile analizzare la maschera del valore dell''attributo ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Tipo di dati sconosciuto nella firma per la classe ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "Impossibile convertire il tipo di dati ''{0}'' in ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Questa Templates non contiene una definizione di classe translet valida. " } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Questa Templates non contiene una classe con il nome ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Impossibile caricare la classe translet ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Classe translet caricata, ma non è possibile creare l'istanza translet. " } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "Tentativo di impostazione di ErrorListener per ''{0}'' su null" } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "Solo StreamSource, SAXSource e DOMSource sono supportati da XSLTC" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "L''oggetto Source passato a ''{0}'' non ha contenuto. " } , { ErrorMsg . JAXP_COMPILE_ERR , "Impossibile compilare il foglio di stile " } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory non riconosce l''attributo ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() deve essere richiamato prima di startDocument()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformer non dispone di un oggetto translet incapsulato. " } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "Nessun programma di gestione dell'emissione definito per il risultato della trasformazione. " } , { ErrorMsg . JAXP_NO_RESULT_ERR , "Oggetto Result passato a ''{0}'' non valido. " } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Tentativo di accesso ad una proprietà Transformer non valida ''{0}''." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Impossibile creare l''adattatore SAX2DOM: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() richiamato senza che sia impostato un systemId (identificativo di sistema). " } , { ErrorMsg . COMPILE_STDIN_ERR , "L'opzione -i deve essere utilizzata con l'opzione -o. " } , { ErrorMsg . COMPILE_USAGE_STR , "SINTESI\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]\n      [-d <directory>] [-j <jarfile>] [-p <package>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }\n\nOPZIONI\n   -o <output>    assegna il nome <output> al translet\n generato. Per impostazione predefinita, il nome translet\n                  viene preso dal nome <stylesheet>. Questa opzione\n                  viene ignorata se vengono compilati più fogli di stile.\n   -d <directory> specifica una directory di destinazione per il translet\n   -j <jarfile>   raggruppa le classi translet in un file jar del\n                  nome specificato come <jarfile>\n   -p <package>   specifica un prefisso del nome pacchetto per tutte le classi\n                  translet generate.\n   -n             abilita l'allineamento della maschera (funzionamento predefinito migliore\n                  in media).\n   -x             attiva ulteriori emissioni dei messaggi di debug\n   -s             disabilita la chiamata a System.exit\n   -u             interpreta gli argomenti <stylesheet> come URL\n   -i             impone al programma di compilazione di leggere il foglio di stile da stdin\n   -v             stampa la versione del programma di compilazione\n   -h             stampa queste istruzioni sull'utilizzo\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SINTASSI\n   java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]\n      [-x] [-s] [-n <iterazioni>] {-u <document_url> | <document>}\n      <classe> [<param1>=<valore1> ...]\n\n   utilizza il translet <classe> per convertire un documento XML \n   specificato come <documento>. Il translet <classe> si trova \n   nella istruzione CLASSPATH dell'utente o nel <jarfile> eventualmente specificato.\nOPZIONI\n   -j <jarfile>    specifica un jarfile da cui caricare il translet\n   -x              attiva ulteriori emissioni dei messaggi di debug\n   -s              disabilita la chiamata a System.exit\n   -n <iterazioni> esegue la trasformazione <iterazioni> volte e\n                   visualizza informazioni relative al profilo\n   -u <document_url> specifica il documento di immissione XML come URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> può essere utilizzato solo all'interno di <xsl:for-each> o <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "Codifica di emissione ''{0}'' non supportata in questa JVM." } , { ErrorMsg . SYNTAX_ERR , "Errore di sintassi in ''{0}''." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "Impossibile trovare il costruttore esterno ''{0}''." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "Il primo argomento della funzione Java non statica ''{0}'' non è un riferimento ad un oggetto valido. " } , { ErrorMsg . TYPE_CHECK_ERR , "Errore durante la verifica del tipo di espressione ''{0}''." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Errore durante la verifica del tipo di espressione in una posizione sconosciuta. " } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "Opzione della riga comandi ''{0}'' non valida. " } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "Manca un argomento obbligatorio per l''opzione della riga comandi ''{0}''. " } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "ATTENZIONE:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "ATTENZIONE:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "ERRORE GRAVE:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "ERRORE GRAVE:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "ERRORE:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "ERRORE:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Trasformazione utilizzando il translet ''{0}'' " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Trasformazione utilizzando il translet ''{0}'' dal file jar ''{1}''" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "Impossibile creare un''istanza della classe TransformerFactory ''{0}''." } , { ErrorMsg . COMPILER_ERROR_KEY , "Errori del programma di compilazione: " } , { ErrorMsg . COMPILER_WARNING_KEY , "Messaggi di avvertenza del programma di compilazione:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Errori del translet:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xalan . xsltc . cmdline ; import java . io . FileNotFoundException ; import java . net . MalformedURLException ; import java . net . UnknownHostException ; import java . util . Vector ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . sax . SAXSource ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . DOMEnhancedForDTM ; import org . apache . xalan . xsltc . dom . XSLTCDTMManager ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . runtime . Constants ; import org . apache . xalan . xsltc . runtime . Parameter ; import org . apache . xalan . xsltc . runtime . output . TransletOutputHandlerFactory ; import org . apache . xml . serializer . SerializationHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xalan . xsltc . dom . DOMWSFilter ; final public class Transform { private SerializationHandler _handler ; private String _fileName ; private String _className ; private String _jarFileSrc ; private boolean _isJarFileSpecified = false ; private Vector _params = null ; private boolean _uri , _debug ; private int _iterations ; private static boolean _allowExit = true ; public Transform ( String className , String fileName , boolean uri , boolean debug , int iterations ) { _fileName = fileName ; _className = className ; _uri = uri ; _debug = debug ; _iterations = iterations ; } public String getFileName ( ) { return _fileName ; } public String getClassName ( ) { return _className ; } public void setParameters ( Vector params ) { _params = params ; } private void setJarFileInputSrc ( boolean flag , String jarFile ) { _isJarFileSpecified = flag ; _jarFileSrc = jarFile ; } private void doTransform ( ) { try { final Class clazz = ObjectFactory . findProviderClass ( _className , ObjectFactory . findClassLoader ( ) , true ) ; final AbstractTranslet translet = ( AbstractTranslet ) clazz . newInstance ( ) ; translet . postInitialization ( ) ; final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { factory . setFeature ( Constants . NAMESPACE_FEATURE , true ) ; } catch ( Exception e ) { factory . setNamespaceAware ( true ) ; } final SAXParser parser = factory . newSAXParser ( ) ; final XMLReader reader = parser . getXMLReader ( ) ; XSLTCDTMManager dtmManager = ( XSLTCDTMManager ) XSLTCDTMManager . getDTMManagerClass ( ) . newInstance ( ) ; DTMWSFilter wsfilter ; if ( translet != null && translet instanceof StripFilter ) { wsfilter = new DOMWSFilter ( translet ) ; } else { wsfilter = null ; } final DOMEnhancedForDTM dom = ( DOMEnhancedForDTM ) dtmManager . getDTM ( new SAXSource ( reader , new InputSource ( _fileName ) ) , false , wsfilter , true , false , translet . hasIdCall ( ) ) ; dom . setDocumentURI ( _fileName ) ; translet . prepassDocument ( dom ) ; int n = _params . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Parameter param = ( Parameter ) _params . elementAt ( i ) ; translet . addParameter ( param . _name , param . _value ) ; } TransletOutputHandlerFactory tohFactory = TransletOutputHandlerFactory . newInstance ( ) ; tohFactory . setOutputType ( TransletOutputHandlerFactory . STREAM ) ; tohFactory . setEncoding ( translet . _encoding ) ; tohFactory . setOutputMethod ( translet . _method ) ; if ( _iterations == - 1 ) { translet . transform ( dom , tohFactory . getSerializationHandler ( ) ) ; } else if ( _iterations > 0 ) { long mm = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < _iterations ; i ++ ) { translet . transform ( dom , tohFactory . getSerializationHandler ( ) ) ; } mm = System . currentTimeMillis ( ) - mm ; System . err . println ( "\n<!--" ) ; System . err . println ( "  transform  = " + ( ( ( double ) mm ) / ( ( double ) _iterations ) ) + " ms" ) ; System . err . println ( "  throughput = " + ( 1000.0 / ( ( ( double ) mm ) / ( ( double ) _iterations ) ) ) + " tps" ) ; System . err . println ( "-->" ) ; } } catch ( TransletException e ) { if ( _debug ) e . printStackTrace ( ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + e . getMessage ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( RuntimeException e ) { if ( _debug ) e . printStackTrace ( ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + e . getMessage ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( FileNotFoundException e ) { if ( _debug ) e . printStackTrace ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . FILE_NOT_FOUND_ERR , _fileName ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + err . toString ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( MalformedURLException e ) { if ( _debug ) e . printStackTrace ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_URI_ERR , _fileName ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + err . toString ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( ClassNotFoundException e ) { if ( _debug ) e . printStackTrace ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + err . toString ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( UnknownHostException e ) { if ( _debug ) e . printStackTrace ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_URI_ERR , _fileName ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + err . toString ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( SAXException e ) { Exception ex = e . getException ( ) ; if ( _debug ) { if ( ex != null ) ex . printStackTrace ( ) ; e . printStackTrace ( ) ; } System . err . print ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) ) ; if ( ex != null ) System . err . println ( ex . getMessage ( ) ) ; else System . err . println ( e . getMessage ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } catch ( Exception e ) { if ( _debug ) e . printStackTrace ( ) ; System . err . println ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + e . getMessage ( ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } } public static void printUsage ( ) { System . err . println ( new ErrorMsg ( ErrorMsg . TRANSFORM_USAGE_STR ) ) ; if ( _allowExit ) System . exit ( - 1 ) ; } public static void main ( String [ ] args ) { try { if ( args . length > 0 ) { int i ; int iterations = - 1 ; boolean uri = false , debug = false ; boolean isJarFileSpecified = false ; String jarFile = null ; for ( i = 0 ; i < args . length && args [ i ] . charAt ( 0 ) == '-' ; i ++ ) { if ( args [ i ] . equals ( "-u" ) ) { uri = true ; } else if ( args [ i ] . equals ( "-x" ) ) { debug = true ; } else if ( args [ i ] . equals ( "-s" ) ) { _allowExit = false ; } else if ( args [ i ] . equals ( "-j" ) ) { isJarFileSpecified = true ; jarFile = args [ ++ i ] ; } else if ( args [ i ] . equals ( "-n" ) ) { try { iterations = Integer . parseInt ( args [ ++ i ] ) ; } catch ( NumberFormatException e ) { } } else { printUsage ( ) ; } } if ( args . length - i < 2 ) printUsage ( ) ; Transform handler = new Transform ( args [ i + 1 ] , args [ i ] , uri , debug , iterations ) ; handler . setJarFileInputSrc ( isJarFileSpecified , jarFile ) ; Vector params = new Vector ( ) ; for ( i += 2 ; i < args . length ; i ++ ) { final int equal = args [ i ] . indexOf ( '=' ) ; if ( equal > 0 ) { final String name = args [ i ] . substring ( 0 , equal ) ; final String value = args [ i ] . substring ( equal + 1 ) ; params . addElement ( new Parameter ( name , value ) ) ; } else { printUsage ( ) ; } } if ( i == args . length ) { handler . setParameters ( params ) ; handler . doTransform ( ) ; if ( _allowExit ) System . exit ( 0 ) ; } } else { printUsage ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } 	1	['9', '1', '0', '14', '71', '8', '0', '14', '6', '0.7625', '670', '1', '1', '0', '0.270833333', '0', '0', '72.33333333', '17', '3.8889', '1']
package org . apache . xml . serializer ; import java . io . BufferedReader ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . UnsupportedEncodingException ; import java . net . URL ; import java . util . Hashtable ; import java . util . PropertyResourceBundle ; import java . util . Enumeration ; import java . util . ResourceBundle ; import javax . xml . transform . TransformerException ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . CharKey ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . WrappedRuntimeException ; class CharInfo { private Hashtable m_charToEntityRef = new Hashtable ( ) ; public static String HTML_ENTITIES_RESOURCE = "org.apache.xml.serializer.HTMLEntities" ; public static String XML_ENTITIES_RESOURCE = "org.apache.xml.serializer.XMLEntities" ; public static final char S_HORIZONAL_TAB = 0x09 ; public static final char S_LINEFEED = 0x0A ; public static char S_CARRIAGERETURN = 0x0D ; final boolean onlyQuotAmpLtGt ; private static final int ASCII_MAX = 128 ; private boolean [ ] isSpecialAttrASCII = new boolean [ ASCII_MAX ] ; private boolean [ ] isSpecialTextASCII = new boolean [ ASCII_MAX ] ; private boolean [ ] isCleanTextASCII = new boolean [ ASCII_MAX ] ; private int array_of_bits [ ] = createEmptySetOfIntegers ( 65535 ) ; private static final int SHIFT_PER_WORD = 5 ; private static final int LOW_ORDER_BITMASK = 0x1f ; private int firstWordNotUsed ; private CharInfo ( String entitiesResource , String method ) { this ( entitiesResource , method , false ) ; } private CharInfo ( String entitiesResource , String method , boolean internal ) { ResourceBundle entities = null ; boolean noExtraEntities = true ; if ( internal ) { try { entities = PropertyResourceBundle . getBundle ( entitiesResource ) ; } catch ( Exception e ) { } } if ( entities != null ) { Enumeration keys = entities . getKeys ( ) ; while ( keys . hasMoreElements ( ) ) { String name = ( String ) keys . nextElement ( ) ; String value = entities . getString ( name ) ; int code = Integer . parseInt ( value ) ; defineEntity ( name , ( char ) code ) ; if ( extraEntity ( code ) ) noExtraEntities = false ; } set ( S_LINEFEED ) ; set ( S_CARRIAGERETURN ) ; } else { InputStream is = null ; try { if ( internal ) { is = CharInfo . class . getResourceAsStream ( entitiesResource ) ; } else { ClassLoader cl = ObjectFactory . findClassLoader ( ) ; if ( cl == null ) { is = ClassLoader . getSystemResourceAsStream ( entitiesResource ) ; } else { is = cl . getResourceAsStream ( entitiesResource ) ; } if ( is == null ) { try { URL url = new URL ( entitiesResource ) ; is = url . openStream ( ) ; } catch ( Exception e ) { } } } if ( is == null ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_RESOURCE_COULD_NOT_FIND , new Object [ ] { entitiesResource , entitiesResource } ) ) ; } BufferedReader reader ; try { reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( UnsupportedEncodingException e ) { reader = new BufferedReader ( new InputStreamReader ( is ) ) ; } String line = reader . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 || line . charAt ( 0 ) == '#' ) { line = reader . readLine ( ) ; continue ; } int index = line . indexOf ( ' ' ) ; if ( index > 1 ) { String name = line . substring ( 0 , index ) ; ++ index ; if ( index < line . length ( ) ) { String value = line . substring ( index ) ; index = value . indexOf ( ' ' ) ; if ( index > 0 ) { value = value . substring ( 0 , index ) ; } int code = Integer . parseInt ( value ) ; defineEntity ( name , ( char ) code ) ; if ( extraEntity ( code ) ) noExtraEntities = false ; } } line = reader . readLine ( ) ; } is . close ( ) ; set ( S_LINEFEED ) ; set ( S_CARRIAGERETURN ) ; } catch ( Exception e ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_RESOURCE_COULD_NOT_LOAD , new Object [ ] { entitiesResource , e . toString ( ) , entitiesResource , e . toString ( ) } ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( Exception except ) { } } } } for ( int ch = 0 ; ch < ASCII_MAX ; ch ++ ) if ( ( ( ( 0x20 <= ch || ( 0x0A == ch || 0x0D == ch || 0x09 == ch ) ) ) && ( ! get ( ch ) ) ) || ( '"' == ch ) ) { isCleanTextASCII [ ch ] = true ; isSpecialTextASCII [ ch ] = false ; } else { isCleanTextASCII [ ch ] = false ; isSpecialTextASCII [ ch ] = true ; } if ( Method . XML . equals ( method ) ) { set ( S_HORIZONAL_TAB ) ; } onlyQuotAmpLtGt = noExtraEntities ; for ( int i = 0 ; i < ASCII_MAX ; i ++ ) isSpecialAttrASCII [ i ] = get ( i ) ; } private void defineEntity ( String name , char value ) { CharKey character = new CharKey ( value ) ; m_charToEntityRef . put ( character , name ) ; set ( value ) ; } private CharKey m_charKey = new CharKey ( ) ; synchronized public String getEntityNameForChar ( char value ) { m_charKey . setChar ( value ) ; return ( String ) m_charToEntityRef . get ( m_charKey ) ; } public final boolean isSpecialAttrChar ( int value ) { if ( value < ASCII_MAX ) return isSpecialAttrASCII [ value ] ; return get ( value ) ; } public final boolean isSpecialTextChar ( int value ) { if ( value < ASCII_MAX ) return isSpecialTextASCII [ value ] ; return get ( value ) ; } public final boolean isTextASCIIClean ( int value ) { return isCleanTextASCII [ value ] ; } public static CharInfo getCharInfo ( String entitiesFileName , String method ) { CharInfo charInfo = ( CharInfo ) m_getCharInfoCache . get ( entitiesFileName ) ; if ( charInfo != null ) { return charInfo ; } try { charInfo = new CharInfo ( entitiesFileName , method , true ) ; m_getCharInfoCache . put ( entitiesFileName , charInfo ) ; return charInfo ; } catch ( Exception e ) { } try { return new CharInfo ( entitiesFileName , method ) ; } catch ( Exception e ) { } String absoluteEntitiesFileName ; if ( entitiesFileName . indexOf ( ':' ) < 0 ) { absoluteEntitiesFileName = SystemIDResolver . getAbsoluteURIFromRelative ( entitiesFileName ) ; } else { try { absoluteEntitiesFileName = SystemIDResolver . getAbsoluteURI ( entitiesFileName , null ) ; } catch ( TransformerException te ) { throw new WrappedRuntimeException ( te ) ; } } return new CharInfo ( absoluteEntitiesFileName , method , false ) ; } private static Hashtable m_getCharInfoCache = new Hashtable ( ) ; private static int arrayIndex ( int i ) { return ( i > > SHIFT_PER_WORD ) ; } private static int bit ( int i ) { int ret = ( 1 << ( i & LOW_ORDER_BITMASK ) ) ; return ret ; } private int [ ] createEmptySetOfIntegers ( int max ) { firstWordNotUsed = 0 ; int [ ] arr = new int [ arrayIndex ( max - 1 ) + 1 ] ; return arr ; } private final void set ( int i ) { int j = ( i > > SHIFT_PER_WORD ) ; int k = j + 1 ; if ( firstWordNotUsed < k ) firstWordNotUsed = k ; array_of_bits [ j ] |= ( 1 << ( i & LOW_ORDER_BITMASK ) ) ; } private final boolean get ( int i ) { boolean in_the_set = false ; int j = ( i > > SHIFT_PER_WORD ) ; if ( j < firstWordNotUsed ) in_the_set = ( array_of_bits [ j ] & ( 1 << ( i & LOW_ORDER_BITMASK ) ) ) != 0 ; return in_the_set ; } private boolean extraEntity ( int entityValue ) { boolean extra = false ; if ( entityValue < 128 ) { switch ( entityValue ) { case 34 : case 38 : case 60 : case 62 : break ; default : extra = true ; } } return extra ; } } 	1	['15', '1', '0', '8', '51', '79', '3', '5', '5', '0.869747899', '591', '0.647058824', '1', '0', '0.385714286', '0', '0', '37.26666667', '7', '1.6667', '2']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . AttributeSetMethodGenerator ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . utils . XMLChar ; final class AttributeSet extends TopLevelElement { private static final String AttributeSetPrefix = "$as$" ; private QName _name ; private UseAttributeSets _useSets ; private AttributeSet _mergeSet ; private String _method ; private boolean _ignore = false ; public QName getName ( ) { return _name ; } public String getMethodName ( ) { return _method ; } public void ignore ( ) { _ignore = true ; } public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; if ( ! XMLChar . isValidQName ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , name , this ) ; parser . reportError ( Constants . ERROR , err ) ; } _name = parser . getQNameIgnoreDefaultNs ( name ) ; if ( ( _name == null ) || ( _name . equals ( EMPTYSTRING ) ) ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNNAMED_ATTRIBSET_ERR , this ) ; parser . reportError ( Constants . ERROR , msg ) ; } final String useSets = getAttribute ( "use-attribute-sets" ) ; if ( useSets . length ( ) > 0 ) { if ( ! Util . isValidQNames ( useSets ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , useSets , this ) ; parser . reportError ( Constants . ERROR , err ) ; } _useSets = new UseAttributeSets ( useSets , parser ) ; } final Vector contents = getContents ( ) ; final int count = contents . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( child instanceof XslAttribute ) { parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; } else if ( child instanceof Text ) { } else { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_CHILD_ERR , this ) ; parser . reportError ( Constants . ERROR , msg ) ; } } parser . getSymbolTable ( ) . setCurrentNode ( this ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _ignore ) return ( Type . Void ) ; _mergeSet = stable . addAttributeSet ( this ) ; _method = AttributeSetPrefix + getXSLTC ( ) . nextAttributeSetSerial ( ) ; if ( _useSets != null ) _useSets . typeCheck ( stable ) ; typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _ignore ) return ; methodGen = new AttributeSetMethodGenerator ( _method , classGen ) ; if ( _mergeSet != null ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final String methodName = _mergeSet . getMethodName ( ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; final int method = cpg . addMethodref ( classGen . getClassName ( ) , methodName , ATTR_SET_SIG ) ; il . append ( new INVOKESPECIAL ( method ) ) ; } if ( _useSets != null ) _useSets . translate ( classGen , methodGen ) ; final Enumeration attributes = elements ( ) ; while ( attributes . hasMoreElements ( ) ) { SyntaxTreeNode element = ( SyntaxTreeNode ) attributes . nextElement ( ) ; if ( element instanceof XslAttribute ) { final XslAttribute attribute = ( XslAttribute ) element ; attribute . translate ( classGen , methodGen ) ; } } final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( RETURN ) ; methodGen . stripAttributes ( true ) ; methodGen . setMaxLocals ( ) ; methodGen . setMaxStack ( ) ; methodGen . removeNOPs ( ) ; classGen . addMethod ( methodGen . getMethod ( ) ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( "attribute-set: " ) ; final Enumeration attributes = elements ( ) ; while ( attributes . hasMoreElements ( ) ) { final XslAttribute attribute = ( XslAttribute ) attributes . nextElement ( ) ; buf . append ( attribute ) ; } return ( buf . toString ( ) ) ; } } 	1	['8', '3', '0', '26', '59', '6', '3', '25', '7', '0.80952381', '314', '1', '3', '0.895522388', '0.3', '2', '5', '37.5', '9', '2.5', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_ja extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "複数のスタイルシートが同じファイル内に定義されています。" } , { ErrorMsg . TEMPLATE_REDEF_ERR , "テンプレート ''{0}'' はこのスタイルシート内にすでに定義されています。" } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "テンプレート ''{0}'' はこのスタイルシート内に定義されていません。" } , { ErrorMsg . VARIABLE_REDEF_ERR , "変数 ''{0}'' は同じ有効範囲内に複数回定義されています。" } , { ErrorMsg . VARIABLE_UNDEF_ERR , "変数またはパラメーター ''{0}'' が未定義です。" } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "クラス ''{0}'' が見つかりません。" } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "外部メソッド ''{0}'' が見つかりません (public でなければなりません)。" } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "引き数/戻りタイプをメソッド ''{0}'' への呼び出しで変換できません" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "ファイルまたは URI ''{0}'' が見つかりません。" } , { ErrorMsg . INVALID_URI_ERR , "無効な URI ''{0}'' です。" } , { ErrorMsg . FILE_ACCESS_ERR , "ファイルまたは URI ''{0}'' をオープンできません。" } , { ErrorMsg . MISSING_ROOT_ERR , "<xsl:stylesheet> または <xsl:transform> エレメントが必要でした。" } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "ネーム・スペース接頭部 ''{0}'' が宣言されていません。" } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "関数 ''{0}'' への呼び出しを解決できません。" } , { ErrorMsg . NEED_LITERAL_ERR , "''{0}'' への引き数はリテラル・ストリングでなければなりません。" } , { ErrorMsg . XPATH_PARSER_ERR , "XPath 式 ''{0}'' を構文解析中にエラーが発生しました。" } , { ErrorMsg . REQUIRED_ATTR_ERR , "必須属性 ''{0}'' がありません。" } , { ErrorMsg . ILLEGAL_CHAR_ERR , "XPath 式内の文字 ''{0}'' が正しくありません。" } , { ErrorMsg . ILLEGAL_PI_ERR , "命令の処理のための名前 ''{0}'' が正しくありません。" } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "属性 ''{0}'' がエレメントの外側です。" } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "属性 ''{0}'' が正しくありません。" } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "import/include が相互依存しています。 スタイル・シート ''{0}'' はすでにロードされています。" } , { ErrorMsg . RESULT_TREE_SORT_ERR , "結果ツリー・フラグメントをソートできません (<xsl:sort> エレメントは無視されます)。 このノードは結果ツリーの作成時にソートしなければなりません。" } , { ErrorMsg . SYMBOLS_REDEF_ERR , "10 進数フォーマット設定 ''{0}'' はすでに定義されています。" } , { ErrorMsg . XSL_VERSION_ERR , "XSL バージョン ''{0}'' は XSLTC によりサポートされていません。" } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "''{0}'' 内の変数/パラメーターの参照が相互依存しています。" } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "2 進式の演算子が不明です。" } , { ErrorMsg . ILLEGAL_ARG_ERR , "関数呼び出しの引き数 (1 つ以上) が正しくありません。" } , { ErrorMsg . DOCUMENT_ARG_ERR , "document() 関数への 2 つ目の引き数はノード・セットでなければなりません。" } , { ErrorMsg . MISSING_WHEN_ERR , "少なくとも 1 つの <xsl:when> エレメントが <xsl:choose> 内に必要です。" } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "<xsl:choose> で許可されている <xsl:otherwise> エレメントは 1 つだけです。" } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> を使用できるのは <xsl:choose> 内だけです。" } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> を使用できるのは <xsl:choose> 内だけです。" } , { ErrorMsg . WHEN_ELEMENT_ERR , "<xsl:choose> で許可されているのは <xsl:when> および <xsl:otherwise> エレメントだけです。" } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set> に 'name' 属性がありません。" } , { ErrorMsg . ILLEGAL_CHILD_ERR , "子エレメントが正しくありません。" } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "エレメント ''{0}'' は呼び出せません" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "属性 ''{0}'' は呼び出せません" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "テキスト・データが最上位の <xsl:stylesheet> エレメントの外側にあります。" } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "JAXP パーサーは正しく構成されていません" } , { ErrorMsg . INTERNAL_ERR , "リカバリー不能 XSLTC 内部エラー: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "XSL エレメント ''{0}'' はサポートされていません。" } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "XSLTC 拡張 ''{0}'' は認識されていません。" } , { ErrorMsg . MISSING_XSLT_URI_ERR , "入力文書はスタイルシートではありません (XSL ネーム・スペースはルート・エレメント内で宣言されていません)。" } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "スタイルシート・ターゲット ''{0}'' が見つかりませんでした。" } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "''{0}'' がインプリメントされていません。" } , { ErrorMsg . NOT_STYLESHEET_ERR , "入力文書には XSL スタイルシートが入っていません。" } , { ErrorMsg . ELEMENT_PARSE_ERR , "エレメント ''{0}'' を構文解析できませんでした" } , { ErrorMsg . KEY_USE_ATTR_ERR , "<key> の use 属性は node、node-set、string、または number でなければなりません。" } , { ErrorMsg . OUTPUT_VERSION_ERR , "出力 XML 文書のバージョンは 1.0 になっているはずです" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "関係式の演算子が不明です" } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "存在していない属性セット ''{0}'' を使用しようとしています。" } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "属性値テンプレート ''{0}'' を構文解析できません。" } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "クラス ''{0}'' のシグニチャー内のデータ・タイプが不明です。" } , { ErrorMsg . DATA_CONVERSION_ERR , "データ・タイプ ''{0}'' を ''{1}'' に変換できません。" } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "このテンプレートには有効な translet クラス定義が入っていません。" } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "このテンプレートには名前が ''{0}'' のクラスは入っていません。" } , { ErrorMsg . TRANSLET_CLASS_ERR , "translet クラス ''{0}'' をロードできませんでした。" } , { ErrorMsg . TRANSLET_OBJECT_ERR , "translet クラスがロードされましたが、translet インスタンスを作成できません。" } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "''{0}'' の ErrorListener をヌルに設定しようとしています" } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "XSLTC がサポートしているのは StreamSource、SAXSource、および DOMSource だけです" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "''{0}'' に渡されたソース・オブジェクトにはコンテンツがありません。" } , { ErrorMsg . JAXP_COMPILE_ERR , "スタイルシートをコンパイルできませんでした" } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory は属性 ''{0}'' を認識しません。" } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() は startDocument() の前に呼び出されていなければなりません。" } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "変換プログラムにはカプセル化された translet オブジェクトがありません。" } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "変換結果の出力ハンドラーが定義されていません。" } , { ErrorMsg . JAXP_NO_RESULT_ERR , "''{0}'' に渡された結果オブジェクトが無効です。" } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "無効な Transformer プロパティー ''{0}'' にアクセスしようとしています。" } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "SAX2DOM アダプター: ''{0}'' を作成できませんでした。" } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() が systemId を設定しないで呼び出されています。" } , { ErrorMsg . COMPILE_STDIN_ERR , "-i オプションは -o オプションと一緒に使用しなければなりません。" } , { ErrorMsg . COMPILE_USAGE_STR , "SYNOPSIS\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]\n      [-d <directory>] [-j <jarfile>] [-p <package>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }\n\nオプション\n -o <output>    名前 <output> を生成後の translet に割り当て\n                ます。 デフォルトでは、translet 名は <stylesheet>\n                名からとられます。 このオプションは複数のスタイルシートを\n                コンパイルする場合は無視されます。\n   -d <directory> translet の宛先ディレクトリーを指定します\n -j <jarfile>   translet クラスを <jarfile> として指定された\n                名前の jar ファイルにパッケージします\n -p <package>   生成後のすべての translet クラスにパッケージ名\n                接頭部を指定します。\n   -n             テンプレートのインライン化を使用可能にします (テンプレートのイン\n                ライン化で平均として良好なパフォーマンスを得ることができます)。\n   -x             追加のデバッグ・メッセージ出力をオンにします\n -s             System.exit の呼び出しを使用不可にします\n -u             <stylesheet> 引き数を URL として解釈します\n -i             コンパイラーがスタイルシートを標準入力から読み取ることを強制します\n -v             コンパイラーのバージョンを印刷します\n -h             この使用法ステートメントを印刷します\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SYNOPSIS \n   java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]\n [-x] [-s] [-n <iterations>] {-u <document_url> | <document>}\n <class> [<param1>=<value1> ...]\n \n translet <class> を使用して <document> として指定された\n XML 文書を変換します。 translet <class> はユーザーの CLASSPATH\n またはオプションで指定される <jarfile> に入っています。\nオプション\n -j <jarfile>      translet のロード元の jarfile を指定します\n -x                追加のデバッグ・メッセージ出力をオンにします\n -s                System.exit の呼び出しを使用不可にします\n -n <iterations>   変換を <iterations> 回実行し\n                   プロファイル情報を表示します\n -u <document_url> XML 入力文書を URL として指定します\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> を使用できるのは <xsl:for-each> または <xsl:apply-templates> 内だけです。" } , { ErrorMsg . UNSUPPORTED_ENCODING , "出力エンコード ''{0}'' はこの JVM ではサポートされていません。" } , { ErrorMsg . SYNTAX_ERR , "''{0}'' 内に構文エラーがあります。" } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "外部コンストラクター ''{0}'' が見つかりません。" } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "非 static Java 関数 ''{0}'' への先頭引き数は有効なオブジェクト参照子でありません。" } , { ErrorMsg . TYPE_CHECK_ERR , "式 ''{0}'' のタイプを検査中にエラーが発生しました。" } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "不明なロケーションで式のタイプを検査中にエラーが発生しました。" } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "コマンド行オプション ''{0}'' が無効です。" } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "コマンド行オプション ''{0}'' に必須属性がありません。" } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "警告:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "警告:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "致命的エラー:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "致命的エラー:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "エラー:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "エラー:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "translet ''{0}'' を使用する変換 " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "jar ファイル ''{1}'' からの translet ''{0}'' を使用する変換" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "TransformerFactory クラス ''{0}'' のインスタンスを作成できませんでした。" } , { ErrorMsg . COMPILER_ERROR_KEY , "コンパイラー・エラー:" } , { ErrorMsg . COMPILER_WARNING_KEY , "コンパイラー警告:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Translet エラー:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xalan . templates ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; public class ElemUse extends ElemTemplateElement { private QName m_attributeSetsNames [ ] = null ; public void setUseAttributeSets ( Vector v ) { int n = v . size ( ) ; m_attributeSetsNames = new QName [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { m_attributeSetsNames [ i ] = ( QName ) v . elementAt ( i ) ; } } public void setUseAttributeSets ( QName [ ] v ) { m_attributeSetsNames = v ; } public QName [ ] getUseAttributeSets ( ) { return m_attributeSetsNames ; } public void applyAttrSets ( TransformerImpl transformer , StylesheetRoot stylesheet ) throws TransformerException { applyAttrSets ( transformer , stylesheet , m_attributeSetsNames ) ; } private void applyAttrSets ( TransformerImpl transformer , StylesheetRoot stylesheet , QName attributeSetsNames [ ] ) throws TransformerException { if ( null != attributeSetsNames ) { int nNames = attributeSetsNames . length ; for ( int i = 0 ; i < nNames ; i ++ ) { QName qname = attributeSetsNames [ i ] ; Vector attrSets = stylesheet . getAttributeSetComposed ( qname ) ; if ( null != attrSets ) { int nSets = attrSets . size ( ) ; for ( int k = nSets - 1 ; k >= 0 ; k -- ) { ElemAttributeSet attrSet = ( ElemAttributeSet ) attrSets . elementAt ( k ) ; attrSet . execute ( transformer ) ; } } else { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_ATTRIB_SET , new Object [ ] { qname } ) , this ) ; } } } } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( null != m_attributeSetsNames ) { applyAttrSets ( transformer , getStylesheetRoot ( ) , m_attributeSetsNames ) ; } } } 	1	['7', '3', '4', '9', '15', '0', '4', '6', '6', '0.166666667', '121', '1', '1', '0.97029703', '0.428571429', '0', '0', '16.14285714', '2', '1', '1']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; public class Function3Args extends Function2Args { Expression m_arg2 ; public Expression getArg2 ( ) { return m_arg2 ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_arg2 ) m_arg2 . fixupVariables ( vars , globalsSize ) ; } public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { if ( argNum < 2 ) super . setArg ( arg , argNum ) ; else if ( 2 == argNum ) { m_arg2 = arg ; arg . exprSetParent ( this ) ; } else reportWrongNumberArgs ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum != 3 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "three" , null ) ) ; } public boolean canTraverseOutsideSubtree ( ) { return super . canTraverseOutsideSubtree ( ) ? true : m_arg2 . canTraverseOutsideSubtree ( ) ; } class Arg2Owner implements ExpressionOwner { public Expression getExpression ( ) { return m_arg2 ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( Function3Args . this ) ; m_arg2 = exp ; } } public void callArgVisitors ( XPathVisitor visitor ) { super . callArgVisitors ( visitor ) ; if ( null != m_arg2 ) m_arg2 . callVisitors ( new Arg2Owner ( ) , visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( null != m_arg2 ) { if ( null == ( ( Function3Args ) expr ) . m_arg2 ) return false ; if ( ! m_arg2 . deepEquals ( ( ( Function3Args ) expr ) . m_arg2 ) ) return false ; } else if ( null != ( ( Function3Args ) expr ) . m_arg2 ) return false ; return true ; } } 	1	['9', '5', '4', '12', '23', '6', '5', '8', '8', '0.375', '124', '0', '1', '0.875', '0.355555556', '4', '15', '12.66666667', '6', '1.7778', '1']
package org . apache . xml . utils ; import java . io . IOException ; import java . io . Serializable ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public class URI implements Serializable { public static class MalformedURIException extends IOException { public MalformedURIException ( ) { super ( ) ; } public MalformedURIException ( String p_msg ) { super ( p_msg ) ; } } private static final String RESERVED_CHARACTERS = ";/?:@&=+$," ; private static final String MARK_CHARACTERS = "-_.!~*'() " ; private static final String SCHEME_CHARACTERS = "+-." ; private static final String USERINFO_CHARACTERS = ";:&=+$," ; private String m_scheme = null ; private String m_userinfo = null ; private String m_host = null ; private int m_port = - 1 ; private String m_path = null ; private String m_queryString = null ; private String m_fragment = null ; private static boolean DEBUG = false ; public URI ( ) { } public URI ( URI p_other ) { initialize ( p_other ) ; } public URI ( String p_uriSpec ) throws MalformedURIException { this ( ( URI ) null , p_uriSpec ) ; } public URI ( URI p_base , String p_uriSpec ) throws MalformedURIException { initialize ( p_base , p_uriSpec ) ; } public URI ( String p_scheme , String p_schemeSpecificPart ) throws MalformedURIException { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( "Cannot construct URI with null/empty scheme!" ) ; } if ( p_schemeSpecificPart == null || p_schemeSpecificPart . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( "Cannot construct URI with null/empty scheme-specific part!" ) ; } setScheme ( p_scheme ) ; setPath ( p_schemeSpecificPart ) ; } public URI ( String p_scheme , String p_host , String p_path , String p_queryString , String p_fragment ) throws MalformedURIException { this ( p_scheme , null , p_host , - 1 , p_path , p_queryString , p_fragment ) ; } public URI ( String p_scheme , String p_userinfo , String p_host , int p_port , String p_path , String p_queryString , String p_fragment ) throws MalformedURIException { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SCHEME_REQUIRED , null ) ) ; } if ( p_host == null ) { if ( p_userinfo != null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_USERINFO_IF_NO_HOST , null ) ) ; } if ( p_port != - 1 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_PORT_IF_NO_HOST , null ) ) ; } } if ( p_path != null ) { if ( p_path . indexOf ( '?' ) != - 1 && p_queryString != null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_QUERY_STRING_IN_PATH , null ) ) ; } if ( p_path . indexOf ( '#' ) != - 1 && p_fragment != null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_FRAGMENT_STRING_IN_PATH , null ) ) ; } } setScheme ( p_scheme ) ; setHost ( p_host ) ; setPort ( p_port ) ; setUserinfo ( p_userinfo ) ; setPath ( p_path ) ; setQueryString ( p_queryString ) ; setFragment ( p_fragment ) ; } private void initialize ( URI p_other ) { m_scheme = p_other . getScheme ( ) ; m_userinfo = p_other . getUserinfo ( ) ; m_host = p_other . getHost ( ) ; m_port = p_other . getPort ( ) ; m_path = p_other . getPath ( ) ; m_queryString = p_other . getQueryString ( ) ; m_fragment = p_other . getFragment ( ) ; } private void initialize ( URI p_base , String p_uriSpec ) throws MalformedURIException { if ( p_base == null && ( p_uriSpec == null || p_uriSpec . trim ( ) . length ( ) == 0 ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CANNOT_INIT_URI_EMPTY_PARMS , null ) ) ; } if ( p_uriSpec == null || p_uriSpec . trim ( ) . length ( ) == 0 ) { initialize ( p_base ) ; return ; } String uriSpec = p_uriSpec . trim ( ) ; int uriSpecLen = uriSpec . length ( ) ; int index = 0 ; int colonIndex = uriSpec . indexOf ( ':' ) ; if ( colonIndex < 0 ) { if ( p_base == null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_SCHEME_IN_URI , new Object [ ] { uriSpec } ) ) ; } } else { initializeScheme ( uriSpec ) ; uriSpec = uriSpec . substring ( colonIndex + 1 ) ; uriSpecLen = uriSpec . length ( ) ; } if ( ( ( index + 1 ) < uriSpecLen ) && ( uriSpec . substring ( index ) . startsWith ( "//" ) ) ) { index += 2 ; int startPos = index ; char testChar = '\0' ; while ( index < uriSpecLen ) { testChar = uriSpec . charAt ( index ) ; if ( testChar == '/' || testChar == '?' || testChar == '#' ) { break ; } index ++ ; } if ( index > startPos ) { initializeAuthority ( uriSpec . substring ( startPos , index ) ) ; } else { m_host = "" ; } } initializePath ( uriSpec . substring ( index ) ) ; if ( p_base != null ) { if ( m_path . length ( ) == 0 && m_scheme == null && m_host == null ) { m_scheme = p_base . getScheme ( ) ; m_userinfo = p_base . getUserinfo ( ) ; m_host = p_base . getHost ( ) ; m_port = p_base . getPort ( ) ; m_path = p_base . getPath ( ) ; if ( m_queryString == null ) { m_queryString = p_base . getQueryString ( ) ; } return ; } if ( m_scheme == null ) { m_scheme = p_base . getScheme ( ) ; } if ( m_host == null ) { m_userinfo = p_base . getUserinfo ( ) ; m_host = p_base . getHost ( ) ; m_port = p_base . getPort ( ) ; } else { return ; } if ( m_path . length ( ) > 0 && m_path . startsWith ( "/" ) ) { return ; } String path = new String ( ) ; String basePath = p_base . getPath ( ) ; if ( basePath != null ) { int lastSlash = basePath . lastIndexOf ( '/' ) ; if ( lastSlash != - 1 ) { path = basePath . substring ( 0 , lastSlash + 1 ) ; } } path = path . concat ( m_path ) ; index = - 1 ; while ( ( index = path . indexOf ( "/./" ) ) != - 1 ) { path = path . substring ( 0 , index + 1 ) . concat ( path . substring ( index + 3 ) ) ; } if ( path . endsWith ( "/." ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } index = - 1 ; int segIndex = - 1 ; String tempString = null ; while ( ( index = path . indexOf ( "/../" ) ) > 0 ) { tempString = path . substring ( 0 , path . indexOf ( "/../" ) ) ; segIndex = tempString . lastIndexOf ( '/' ) ; if ( segIndex != - 1 ) { if ( ! tempString . substring ( segIndex ++ ) . equals ( ".." ) ) { path = path . substring ( 0 , segIndex ) . concat ( path . substring ( index + 4 ) ) ; } } } if ( path . endsWith ( "/.." ) ) { tempString = path . substring ( 0 , path . length ( ) - 3 ) ; segIndex = tempString . lastIndexOf ( '/' ) ; if ( segIndex != - 1 ) { path = path . substring ( 0 , segIndex + 1 ) ; } } m_path = path ; } } private void initializeScheme ( String p_uriSpec ) throws MalformedURIException { int uriSpecLen = p_uriSpec . length ( ) ; int index = 0 ; String scheme = null ; char testChar = '\0' ; while ( index < uriSpecLen ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == ':' || testChar == '/' || testChar == '?' || testChar == '#' ) { break ; } index ++ ; } scheme = p_uriSpec . substring ( 0 , index ) ; if ( scheme . length ( ) == 0 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_SCHEME_INURI , null ) ) ; } else { setScheme ( scheme ) ; } } private void initializeAuthority ( String p_uriSpec ) throws MalformedURIException { int index = 0 ; int start = 0 ; int end = p_uriSpec . length ( ) ; char testChar = '\0' ; String userinfo = null ; if ( p_uriSpec . indexOf ( '@' , start ) != - 1 ) { while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '@' ) { break ; } index ++ ; } userinfo = p_uriSpec . substring ( start , index ) ; index ++ ; } String host = null ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == ':' ) { break ; } index ++ ; } host = p_uriSpec . substring ( start , index ) ; int port = - 1 ; if ( host . length ( ) > 0 ) { if ( testChar == ':' ) { index ++ ; start = index ; while ( index < end ) { index ++ ; } String portStr = p_uriSpec . substring ( start , index ) ; if ( portStr . length ( ) > 0 ) { for ( int i = 0 ; i < portStr . length ( ) ; i ++ ) { if ( ! isDigit ( portStr . charAt ( i ) ) ) { throw new MalformedURIException ( portStr + " is invalid. Port should only contain digits!" ) ; } } try { port = Integer . parseInt ( portStr ) ; } catch ( NumberFormatException nfe ) { } } } } setHost ( host ) ; setPort ( port ) ; setUserinfo ( userinfo ) ; } private void initializePath ( String p_uriSpec ) throws MalformedURIException { if ( p_uriSpec == null ) { throw new MalformedURIException ( "Cannot initialize path from null string!" ) ; } int index = 0 ; int start = 0 ; int end = p_uriSpec . length ( ) ; char testChar = '\0' ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '?' || testChar == '#' ) { break ; } if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , null ) ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { if ( '\\' != testChar ) throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PATH_INVALID_CHAR , new Object [ ] { String . valueOf ( testChar ) } ) ) ; } index ++ ; } m_path = p_uriSpec . substring ( start , index ) ; if ( testChar == '?' ) { index ++ ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '#' ) { break ; } if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Query string contains invalid escape sequence!" ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { throw new MalformedURIException ( "Query string contains invalid character:" + testChar ) ; } index ++ ; } m_queryString = p_uriSpec . substring ( start , index ) ; } if ( testChar == '#' ) { index ++ ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Fragment contains invalid escape sequence!" ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { throw new MalformedURIException ( "Fragment contains invalid character:" + testChar ) ; } index ++ ; } m_fragment = p_uriSpec . substring ( start , index ) ; } } public String getScheme ( ) { return m_scheme ; } public String getSchemeSpecificPart ( ) { StringBuffer schemespec = new StringBuffer ( ) ; if ( m_userinfo != null || m_host != null || m_port != - 1 ) { schemespec . append ( "//" ) ; } if ( m_userinfo != null ) { schemespec . append ( m_userinfo ) ; schemespec . append ( '@' ) ; } if ( m_host != null ) { schemespec . append ( m_host ) ; } if ( m_port != - 1 ) { schemespec . append ( ':' ) ; schemespec . append ( m_port ) ; } if ( m_path != null ) { schemespec . append ( ( m_path ) ) ; } if ( m_queryString != null ) { schemespec . append ( '?' ) ; schemespec . append ( m_queryString ) ; } if ( m_fragment != null ) { schemespec . append ( '#' ) ; schemespec . append ( m_fragment ) ; } return schemespec . toString ( ) ; } public String getUserinfo ( ) { return m_userinfo ; } public String getHost ( ) { return m_host ; } public int getPort ( ) { return m_port ; } public String getPath ( boolean p_includeQueryString , boolean p_includeFragment ) { StringBuffer pathString = new StringBuffer ( m_path ) ; if ( p_includeQueryString && m_queryString != null ) { pathString . append ( '?' ) ; pathString . append ( m_queryString ) ; } if ( p_includeFragment && m_fragment != null ) { pathString . append ( '#' ) ; pathString . append ( m_fragment ) ; } return pathString . toString ( ) ; } public String getPath ( ) { return m_path ; } public String getQueryString ( ) { return m_queryString ; } public String getFragment ( ) { return m_fragment ; } public void setScheme ( String p_scheme ) throws MalformedURIException { if ( p_scheme == null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SCHEME_FROM_NULL_STRING , null ) ) ; } if ( ! isConformantSchemeName ( p_scheme ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SCHEME_NOT_CONFORMANT , null ) ) ; } m_scheme = p_scheme . toLowerCase ( ) ; } public void setUserinfo ( String p_userinfo ) throws MalformedURIException { if ( p_userinfo == null ) { m_userinfo = null ; } else { if ( m_host == null ) { throw new MalformedURIException ( "Userinfo cannot be set when host is null!" ) ; } int index = 0 ; int end = p_userinfo . length ( ) ; char testChar = '\0' ; while ( index < end ) { testChar = p_userinfo . charAt ( index ) ; if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Userinfo contains invalid escape sequence!" ) ; } } else if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { throw new MalformedURIException ( "Userinfo contains invalid character:" + testChar ) ; } index ++ ; } } m_userinfo = p_userinfo ; } public void setHost ( String p_host ) throws MalformedURIException { if ( p_host == null || p_host . trim ( ) . length ( ) == 0 ) { m_host = p_host ; m_userinfo = null ; m_port = - 1 ; } else if ( ! isWellFormedAddress ( p_host ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_HOST_ADDRESS_NOT_WELLFORMED , null ) ) ; } m_host = p_host ; } public void setPort ( int p_port ) throws MalformedURIException { if ( p_port >= 0 && p_port <= 65535 ) { if ( m_host == null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PORT_WHEN_HOST_NULL , null ) ) ; } } else if ( p_port != - 1 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_PORT , null ) ) ; } m_port = p_port ; } public void setPath ( String p_path ) throws MalformedURIException { if ( p_path == null ) { m_path = null ; m_queryString = null ; m_fragment = null ; } else { initializePath ( p_path ) ; } } public void appendPath ( String p_addToPath ) throws MalformedURIException { if ( p_addToPath == null || p_addToPath . trim ( ) . length ( ) == 0 ) { return ; } if ( ! isURIString ( p_addToPath ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PATH_INVALID_CHAR , new Object [ ] { p_addToPath } ) ) ; } if ( m_path == null || m_path . trim ( ) . length ( ) == 0 ) { if ( p_addToPath . startsWith ( "/" ) ) { m_path = p_addToPath ; } else { m_path = "/" + p_addToPath ; } } else if ( m_path . endsWith ( "/" ) ) { if ( p_addToPath . startsWith ( "/" ) ) { m_path = m_path . concat ( p_addToPath . substring ( 1 ) ) ; } else { m_path = m_path . concat ( p_addToPath ) ; } } else { if ( p_addToPath . startsWith ( "/" ) ) { m_path = m_path . concat ( p_addToPath ) ; } else { m_path = m_path . concat ( "/" + p_addToPath ) ; } } } public void setQueryString ( String p_queryString ) throws MalformedURIException { if ( p_queryString == null ) { m_queryString = null ; } else if ( ! isGenericURI ( ) ) { throw new MalformedURIException ( "Query string can only be set for a generic URI!" ) ; } else if ( getPath ( ) == null ) { throw new MalformedURIException ( "Query string cannot be set when path is null!" ) ; } else if ( ! isURIString ( p_queryString ) ) { throw new MalformedURIException ( "Query string contains invalid character!" ) ; } else { m_queryString = p_queryString ; } } public void setFragment ( String p_fragment ) throws MalformedURIException { if ( p_fragment == null ) { m_fragment = null ; } else if ( ! isGenericURI ( ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_FRAG_FOR_GENERIC_URI , null ) ) ; } else if ( getPath ( ) == null ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_FRAG_WHEN_PATH_NULL , null ) ) ; } else if ( ! isURIString ( p_fragment ) ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_FRAG_INVALID_CHAR , null ) ) ; } else { m_fragment = p_fragment ; } } public boolean equals ( Object p_test ) { if ( p_test instanceof URI ) { URI testURI = ( URI ) p_test ; if ( ( ( m_scheme == null && testURI . m_scheme == null ) || ( m_scheme != null && testURI . m_scheme != null && m_scheme . equals ( testURI . m_scheme ) ) ) && ( ( m_userinfo == null && testURI . m_userinfo == null ) || ( m_userinfo != null && testURI . m_userinfo != null && m_userinfo . equals ( testURI . m_userinfo ) ) ) && ( ( m_host == null && testURI . m_host == null ) || ( m_host != null && testURI . m_host != null && m_host . equals ( testURI . m_host ) ) ) && m_port == testURI . m_port && ( ( m_path == null && testURI . m_path == null ) || ( m_path != null && testURI . m_path != null && m_path . equals ( testURI . m_path ) ) ) && ( ( m_queryString == null && testURI . m_queryString == null ) || ( m_queryString != null && testURI . m_queryString != null && m_queryString . equals ( testURI . m_queryString ) ) ) && ( ( m_fragment == null && testURI . m_fragment == null ) || ( m_fragment != null && testURI . m_fragment != null && m_fragment . equals ( testURI . m_fragment ) ) ) ) { return true ; } } return false ; } public String toString ( ) { StringBuffer uriSpecString = new StringBuffer ( ) ; if ( m_scheme != null ) { uriSpecString . append ( m_scheme ) ; uriSpecString . append ( ':' ) ; } uriSpecString . append ( getSchemeSpecificPart ( ) ) ; return uriSpecString . toString ( ) ; } public boolean isGenericURI ( ) { return ( m_host != null ) ; } public static boolean isConformantSchemeName ( String p_scheme ) { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { return false ; } if ( ! isAlpha ( p_scheme . charAt ( 0 ) ) ) { return false ; } char testChar ; for ( int i = 1 ; i < p_scheme . length ( ) ; i ++ ) { testChar = p_scheme . charAt ( i ) ; if ( ! isAlphanum ( testChar ) && SCHEME_CHARACTERS . indexOf ( testChar ) == - 1 ) { return false ; } } return true ; } public static boolean isWellFormedAddress ( String p_address ) { if ( p_address == null ) { return false ; } String address = p_address . trim ( ) ; int addrLength = address . length ( ) ; if ( addrLength == 0 || addrLength > 255 ) { return false ; } if ( address . startsWith ( "." ) || address . startsWith ( "-" ) ) { return false ; } int index = address . lastIndexOf ( '.' ) ; if ( address . endsWith ( "." ) ) { index = address . substring ( 0 , index ) . lastIndexOf ( '.' ) ; } if ( index + 1 < addrLength && isDigit ( p_address . charAt ( index + 1 ) ) ) { char testChar ; int numDots = 0 ; for ( int i = 0 ; i < addrLength ; i ++ ) { testChar = address . charAt ( i ) ; if ( testChar == '.' ) { if ( ! isDigit ( address . charAt ( i - 1 ) ) || ( i + 1 < addrLength && ! isDigit ( address . charAt ( i + 1 ) ) ) ) { return false ; } numDots ++ ; } else if ( ! isDigit ( testChar ) ) { return false ; } } if ( numDots != 3 ) { return false ; } } else { char testChar ; for ( int i = 0 ; i < addrLength ; i ++ ) { testChar = address . charAt ( i ) ; if ( testChar == '.' ) { if ( ! isAlphanum ( address . charAt ( i - 1 ) ) ) { return false ; } if ( i + 1 < addrLength && ! isAlphanum ( address . charAt ( i + 1 ) ) ) { return false ; } } else if ( ! isAlphanum ( testChar ) && testChar != '-' ) { return false ; } } } return true ; } private static boolean isDigit ( char p_char ) { return p_char >= '0' && p_char <= '9' ; } private static boolean isHex ( char p_char ) { return ( isDigit ( p_char ) || ( p_char >= 'a' && p_char <= 'f' ) || ( p_char >= 'A' && p_char <= 'F' ) ) ; } private static boolean isAlpha ( char p_char ) { return ( ( p_char >= 'a' && p_char <= 'z' ) || ( p_char >= 'A' && p_char <= 'Z' ) ) ; } private static boolean isAlphanum ( char p_char ) { return ( isAlpha ( p_char ) || isDigit ( p_char ) ) ; } private static boolean isReservedCharacter ( char p_char ) { return RESERVED_CHARACTERS . indexOf ( p_char ) != - 1 ; } private static boolean isUnreservedCharacter ( char p_char ) { return ( isAlphanum ( p_char ) || MARK_CHARACTERS . indexOf ( p_char ) != - 1 ) ; } private static boolean isURIString ( String p_uric ) { if ( p_uric == null ) { return false ; } int end = p_uric . length ( ) ; char testChar = '\0' ; for ( int i = 0 ; i < end ; i ++ ) { testChar = p_uric . charAt ( i ) ; if ( testChar == '%' ) { if ( i + 2 >= end || ! isHex ( p_uric . charAt ( i + 1 ) ) || ! isHex ( p_uric . charAt ( i + 2 ) ) ) { return false ; } else { i += 2 ; continue ; } } if ( isReservedCharacter ( testChar ) || isUnreservedCharacter ( testChar ) ) { continue ; } else { return false ; } } return true ; } } 	1	['42', '1', '0', '3', '72', '375', '1', '2', '29', '0.780487805', '2044', '1', '0', '0', '0.226480836', '0', '0', '47.38095238', '33', '3.1429', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_ru extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Внутренняя ошибка времени выполнения в ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Ошибка времени выполнения при обработке <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Недопустимое преобразование из ''{0}'' в ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "Внешняя функция ''{0}'' не поддерживается XSLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Неизвестный тип аргумента в выражении равенства." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Недопустимый тип аргумента ''{0}'' в вызове ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Попытка отформатировать число ''{0}'' с помощью шаблона ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Невозможно создать копию итератора ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Итератор для оси ''{0}'' не поддерживается." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Итератор для типизированной оси ''{0}'' не поддерживается." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Атрибут ''{0}'' вне элемента." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Объявление пространства имен ''{0}''=''{1}'' вне элемента." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "Пространство имен для префикса ''{0}'' не объявлено." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter создан с неправильным типом исходного DOM." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "Применяемый анализатор SAX не обрабатывает события объявления DTD." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "Применяемый анализатор SAX не поддерживает пространства имен XML." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "Невозможно обработать ссылку на URI ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . Properties ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Transformer ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . TreeWalker ; import org . apache . xml . utils . WrappedRuntimeException ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . SAXException ; abstract public class ToStream extends SerializerBase { private static final String COMMENT_BEGIN = "<!--" ; private static final String COMMENT_END = "-->" ; protected BoolStack m_disableOutputEscapingStates = new BoolStack ( ) ; boolean m_triedToGetConverter = false ; java . lang . reflect . Method m_canConvertMeth ; Object m_charToByteConverter = null ; protected BoolStack m_preserves = new BoolStack ( ) ; protected boolean m_ispreserve = false ; protected boolean m_isprevtext = false ; protected int m_maxCharacter = Encodings . getLastPrintable ( ) ; protected final char [ ] m_lineSep = System . getProperty ( "line.separator" ) . toCharArray ( ) ; protected boolean m_lineSepUse = true ; protected final int m_lineSepLen = m_lineSep . length ; protected CharInfo m_charInfo ; boolean m_shouldFlush = true ; protected boolean m_spaceBeforeClose = false ; boolean m_startNewLine ; protected boolean m_inDoctype = false ; boolean m_isUTF8 = false ; protected Properties m_format ; protected boolean m_cdataStartCalled = false ; public ToStream ( ) { } protected void closeCDATA ( ) throws org . xml . sax . SAXException { try { m_writer . write ( CDATA_DELIMITER_CLOSE ) ; m_cdataTagOpen = false ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void serialize ( Node node ) throws IOException { try { TreeWalker walker = new TreeWalker ( this , new org . apache . xml . utils . DOM2Helper ( ) ) ; walker . traverse ( node ) ; } catch ( org . xml . sax . SAXException se ) { throw new WrappedRuntimeException ( se ) ; } } static final boolean isUTF16Surrogate ( char c ) { return ( c & 0xFC00 ) == 0xD800 ; } private boolean m_escaping = true ; protected final void flushWriter ( ) throws org . xml . sax . SAXException { final java . io . Writer writer = m_writer ; if ( null != writer ) { try { if ( writer instanceof WriterToUTF8Buffered ) { if ( m_shouldFlush ) ( ( WriterToUTF8Buffered ) writer ) . flush ( ) ; else ( ( WriterToUTF8Buffered ) writer ) . flushBuffer ( ) ; } if ( writer instanceof WriterToASCI ) { if ( m_shouldFlush ) writer . flush ( ) ; } else { writer . flush ( ) ; } } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( ioe ) ; } } } public OutputStream getOutputStream ( ) { if ( m_writer instanceof WriterToUTF8Buffered ) return ( ( WriterToUTF8Buffered ) m_writer ) . getOutputStream ( ) ; if ( m_writer instanceof WriterToASCI ) return ( ( WriterToASCI ) m_writer ) . getOutputStream ( ) ; else return null ; } public void elementDecl ( String name , String model ) throws SAXException { if ( m_inExternalDTD ) return ; try { final java . io . Writer writer = m_writer ; if ( m_needToOutputDocTypeDecl ) { outputDocTypeDecl ( m_elemContext . m_elementName , false ) ; m_needToOutputDocTypeDecl = false ; } if ( m_inDoctype ) { writer . write ( " [" ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_inDoctype = false ; } writer . write ( "<!ELEMENT " ) ; writer . write ( name ) ; writer . write ( ' ' ) ; writer . write ( model ) ; writer . write ( '>' ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( m_inExternalDTD ) return ; try { if ( m_needToOutputDocTypeDecl ) { outputDocTypeDecl ( m_elemContext . m_elementName , false ) ; m_needToOutputDocTypeDecl = false ; } if ( m_inDoctype ) { final java . io . Writer writer = m_writer ; writer . write ( " [" ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_inDoctype = false ; } outputEntityDecl ( name , value ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } void outputEntityDecl ( String name , String value ) throws IOException { final java . io . Writer writer = m_writer ; writer . write ( "<!ENTITY " ) ; writer . write ( name ) ; writer . write ( " \"" ) ; writer . write ( value ) ; writer . write ( "\">" ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } protected final void outputLineSep ( ) throws IOException { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } public void setOutputFormat ( Properties format ) { boolean shouldFlush = m_shouldFlush ; init ( m_writer , format , false , false ) ; m_shouldFlush = shouldFlush ; } private synchronized void init ( Writer writer , Properties format , boolean defaultProperties , boolean shouldFlush ) { m_shouldFlush = shouldFlush ; if ( m_tracer != null && ! ( writer instanceof SerializerTraceWriter ) ) m_writer = new SerializerTraceWriter ( writer , m_tracer ) ; else m_writer = writer ; m_format = format ; setCdataSectionElements ( OutputKeys . CDATA_SECTION_ELEMENTS , format ) ; setIndentAmount ( OutputPropertyUtils . getIntProperty ( OutputPropertiesFactory . S_KEY_INDENT_AMOUNT , format ) ) ; setIndent ( OutputPropertyUtils . getBooleanProperty ( OutputKeys . INDENT , format ) ) ; boolean shouldNotWriteXMLHeader = OutputPropertyUtils . getBooleanProperty ( OutputKeys . OMIT_XML_DECLARATION , format ) ; setOmitXMLDeclaration ( shouldNotWriteXMLHeader ) ; setDoctypeSystem ( format . getProperty ( OutputKeys . DOCTYPE_SYSTEM ) ) ; String doctypePublic = format . getProperty ( OutputKeys . DOCTYPE_PUBLIC ) ; setDoctypePublic ( doctypePublic ) ; if ( format . get ( OutputKeys . STANDALONE ) != null ) { String val = format . getProperty ( OutputKeys . STANDALONE ) ; if ( defaultProperties ) setStandaloneInternal ( val ) ; else setStandalone ( val ) ; } setMediaType ( format . getProperty ( OutputKeys . MEDIA_TYPE ) ) ; if ( null != doctypePublic ) { if ( doctypePublic . startsWith ( "-//W3C//DTD XHTML" ) ) m_spaceBeforeClose = true ; } String encoding = getEncoding ( ) ; if ( null == encoding ) { encoding = Encodings . getMimeEncoding ( format . getProperty ( OutputKeys . ENCODING ) ) ; setEncoding ( encoding ) ; } m_isUTF8 = encoding . equals ( Encodings . DEFAULT_MIME_ENCODING ) ; m_maxCharacter = Encodings . getLastPrintable ( encoding ) ; String entitiesFileName = ( String ) format . get ( OutputPropertiesFactory . S_KEY_ENTITIES ) ; if ( null != entitiesFileName ) { String method = ( String ) format . get ( OutputKeys . METHOD ) ; m_charInfo = CharInfo . getCharInfo ( entitiesFileName , method ) ; } } private synchronized void init ( Writer writer , Properties format ) { init ( writer , format , false , false ) ; } protected synchronized void init ( OutputStream output , Properties format , boolean defaultProperties ) throws UnsupportedEncodingException { String encoding = getEncoding ( ) ; if ( encoding == null ) { encoding = Encodings . getMimeEncoding ( format . getProperty ( OutputKeys . ENCODING ) ) ; setEncoding ( encoding ) ; } if ( encoding . equalsIgnoreCase ( "UTF-8" ) ) { m_isUTF8 = true ; init ( new WriterToUTF8Buffered ( output ) , format , defaultProperties , true ) ; } else if ( encoding . equals ( "WINDOWS-1250" ) || encoding . equals ( "US-ASCII" ) || encoding . equals ( "ASCII" ) ) { init ( new WriterToASCI ( output ) , format , defaultProperties , true ) ; } else { Writer osw ; try { osw = Encodings . getWriter ( output , encoding ) ; } catch ( UnsupportedEncodingException uee ) { System . out . println ( "Warning: encoding \"" + encoding + "\" not supported" + ", using " + Encodings . DEFAULT_MIME_ENCODING ) ; encoding = Encodings . DEFAULT_MIME_ENCODING ; setEncoding ( encoding ) ; osw = Encodings . getWriter ( output , encoding ) ; } m_maxCharacter = Encodings . getLastPrintable ( encoding ) ; init ( osw , format , defaultProperties , true ) ; } } public Properties getOutputFormat ( ) { return m_format ; } public void setWriter ( Writer writer ) { if ( m_tracer != null && ! ( writer instanceof SerializerTraceWriter ) ) m_writer = new SerializerTraceWriter ( writer , m_tracer ) ; else m_writer = writer ; } public boolean setLineSepUse ( boolean use_sytem_line_break ) { boolean oldValue = m_lineSepUse ; m_lineSepUse = use_sytem_line_break ; return oldValue ; } public void setOutputStream ( OutputStream output ) { try { Properties format ; if ( null == m_format ) format = OutputPropertiesFactory . getDefaultMethodProperties ( Method . XML ) ; else format = m_format ; init ( output , format , true ) ; } catch ( UnsupportedEncodingException uee ) { } } public boolean setEscaping ( boolean escape ) { final boolean temp = m_escaping ; m_escaping = escape ; return temp ; } protected void indent ( int depth ) throws IOException { if ( m_startNewLine ) outputLineSep ( ) ; if ( m_indentAmount > 0 ) printSpace ( depth * m_indentAmount ) ; } protected void indent ( ) throws IOException { indent ( m_elemContext . m_currentElemDepth ) ; } private void printSpace ( int n ) throws IOException { final java . io . Writer writer = m_writer ; for ( int i = 0 ; i < n ; i ++ ) { writer . write ( ' ' ) ; } } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( m_inExternalDTD ) return ; try { final java . io . Writer writer = m_writer ; if ( m_needToOutputDocTypeDecl ) { outputDocTypeDecl ( m_elemContext . m_elementName , false ) ; m_needToOutputDocTypeDecl = false ; } if ( m_inDoctype ) { writer . write ( " [" ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_inDoctype = false ; } writer . write ( "<!ATTLIST " ) ; writer . write ( eName ) ; writer . write ( ' ' ) ; writer . write ( aName ) ; writer . write ( ' ' ) ; writer . write ( type ) ; if ( valueDefault != null ) { writer . write ( ' ' ) ; writer . write ( valueDefault ) ; } writer . write ( '>' ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public Writer getWriter ( ) { return m_writer ; } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { } protected boolean escapingNotNeeded ( char ch ) { if ( ch < 127 ) { if ( ch >= 0x20 || ( 0x0A == ch || 0x0D == ch || 0x09 == ch ) ) return true ; else return false ; } if ( null == m_charToByteConverter && false == m_triedToGetConverter ) { m_triedToGetConverter = true ; try { m_charToByteConverter = Encodings . getCharToByteConverter ( getEncoding ( ) ) ; if ( null != m_charToByteConverter ) { Class argsTypes [ ] = new Class [ 1 ] ; argsTypes [ 0 ] = Character . TYPE ; Class convClass = m_charToByteConverter . getClass ( ) ; m_canConvertMeth = convClass . getMethod ( "canConvert" , argsTypes ) ; } } catch ( Exception e ) { System . err . println ( "Warning: " + e . getMessage ( ) ) ; } } if ( null != m_charToByteConverter ) { try { Object args [ ] = new Object [ 1 ] ; args [ 0 ] = new Character ( ch ) ; Boolean bool = ( Boolean ) m_canConvertMeth . invoke ( m_charToByteConverter , args ) ; return bool . booleanValue ( ) ? ! Character . isISOControl ( ch ) : false ; } catch ( java . lang . reflect . InvocationTargetException ite ) { System . err . println ( "Warning: InvocationTargetException in canConvert!" ) ; } catch ( java . lang . IllegalAccessException iae ) { System . err . println ( "Warning: IllegalAccessException in canConvert!" ) ; } } return ( ch <= m_maxCharacter ) ; } protected void writeUTF16Surrogate ( char c , char ch [ ] , int i , int end ) throws IOException { int surrogateValue = getURF16SurrogateValue ( c , ch , i , end ) ; final java . io . Writer writer = m_writer ; writer . write ( '&' ) ; writer . write ( '#' ) ; writer . write ( Integer . toString ( surrogateValue ) ) ; writer . write ( ';' ) ; } int getURF16SurrogateValue ( char c , char ch [ ] , int i , int end ) throws IOException { int next ; if ( i + 1 >= end ) { throw new IOException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ( int ) c ) } ) ) ; } else { next = ch [ ++ i ] ; if ( ! ( 0xdc00 <= next && next < 0xe000 ) ) throw new IOException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ( int ) c ) + " " + Integer . toHexString ( next ) } ) ) ; next = ( ( c - 0xd800 ) << 10 ) + next - 0xdc00 + 0x00010000 ; } return next ; } protected int accumDefaultEntity ( java . io . Writer writer , char ch , int i , char [ ] chars , int len , boolean fromTextNode , boolean escLF ) throws IOException { if ( ! escLF && CharInfo . S_LINEFEED == ch ) { writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else { if ( ( fromTextNode && m_charInfo . isSpecialTextChar ( ch ) ) || ( ! fromTextNode && m_charInfo . isSpecialAttrChar ( ch ) ) ) { String entityRef = m_charInfo . getEntityNameForChar ( ch ) ; if ( null != entityRef ) { writer . write ( '&' ) ; writer . write ( entityRef ) ; writer . write ( ';' ) ; } else return i ; } else return i ; } return i + 1 ; } void writeNormalizedChars ( char ch [ ] , int start , int length , boolean isCData , boolean useSystemLineSeparator ) throws IOException , org . xml . sax . SAXException { final java . io . Writer writer = m_writer ; int end = start + length ; for ( int i = start ; i < end ; i ++ ) { char c = ch [ i ] ; if ( CharInfo . S_LINEFEED == c && useSystemLineSeparator ) { writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else if ( isCData && ( ! escapingNotNeeded ( c ) ) ) { if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( isUTF16Surrogate ( c ) ) { writeUTF16Surrogate ( c , ch , i , end ) ; i ++ ; } else { writer . write ( "&#" ) ; String intStr = Integer . toString ( ( int ) c ) ; writer . write ( intStr ) ; writer . write ( ';' ) ; } } else if ( isCData && ( ( i < ( end - 2 ) ) && ( ']' == c ) && ( ']' == ch [ i + 1 ] ) && ( '>' == ch [ i + 2 ] ) ) ) { writer . write ( CDATA_CONTINUE ) ; i += 2 ; } else { if ( escapingNotNeeded ( c ) ) { if ( isCData && ! m_cdataTagOpen ) { writer . write ( CDATA_DELIMITER_OPEN ) ; m_cdataTagOpen = true ; } writer . write ( c ) ; } else if ( isUTF16Surrogate ( c ) ) { if ( m_cdataTagOpen ) closeCDATA ( ) ; writeUTF16Surrogate ( c , ch , i , end ) ; i ++ ; } else { if ( m_cdataTagOpen ) closeCDATA ( ) ; writer . write ( "&#" ) ; String intStr = Integer . toString ( ( int ) c ) ; writer . write ( intStr ) ; writer . write ( ';' ) ; } } } } public void endNonEscaping ( ) throws org . xml . sax . SAXException { m_disableOutputEscapingStates . pop ( ) ; } public void startNonEscaping ( ) throws org . xml . sax . SAXException { m_disableOutputEscapingStates . push ( true ) ; } protected void cdata ( char ch [ ] , int start , final int length ) throws org . xml . sax . SAXException { try { final int old_start = start ; if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } m_ispreserve = true ; if ( shouldIndent ( ) ) indent ( ) ; boolean writeCDataBrackets = ( ( ( length >= 1 ) && escapingNotNeeded ( ch [ start ] ) ) ) ; if ( writeCDataBrackets && ! m_cdataTagOpen ) { m_writer . write ( CDATA_DELIMITER_OPEN ) ; m_cdataTagOpen = true ; } if ( isEscapingDisabled ( ) ) { charactersRaw ( ch , start , length ) ; } else writeNormalizedChars ( ch , start , length , true , m_lineSepUse ) ; if ( writeCDataBrackets ) { if ( ch [ start + length - 1 ] == ']' ) closeCDATA ( ) ; } if ( m_tracer != null ) super . fireCDATAEvent ( ch , old_start , length ) ; } catch ( IOException ioe ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OIERROR , null ) , ioe ) ; } } private boolean isEscapingDisabled ( ) { return m_disableOutputEscapingStates . peekOrFalse ( ) ; } protected void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; try { if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } m_ispreserve = true ; m_writer . write ( ch , start , length ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void characters ( final char chars [ ] , final int start , final int length ) throws org . xml . sax . SAXException { if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } else if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; } if ( m_cdataStartCalled || m_elemContext . m_isCdataSection ) { cdata ( chars , start , length ) ; return ; } if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( m_disableOutputEscapingStates . peekOrFalse ( ) || ( ! m_escaping ) ) { charactersRaw ( chars , start , length ) ; if ( m_tracer != null ) super . fireCharEvent ( chars , start , length ) ; return ; } if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } try { int i ; char ch1 ; int startClean ; final int end = start + length ; int lastDirty = start - 1 ; for ( i = start ; ( ( i < end ) && ( ( ch1 = chars [ i ] ) == 0x20 || ( ch1 == 0xA && m_lineSepUse ) || ch1 == 0xD || ch1 == 0x09 ) ) ; i ++ ) { if ( ! m_charInfo . isTextASCIIClean ( ch1 ) ) { lastDirty = processDirty ( chars , end , i , ch1 , lastDirty , true ) ; i = lastDirty ; } } if ( i < end ) m_ispreserve = true ; for ( ; i < end ; i ++ ) { { char ch2 ; while ( i < end && ( ( ch2 = chars [ i ] ) < 127 ) && m_charInfo . isTextASCIIClean ( ch2 ) ) i ++ ; if ( i == end ) break ; } final char ch = chars [ i ] ; if ( ( escapingNotNeeded ( ch ) && ( ! m_charInfo . isSpecialTextChar ( ch ) ) ) || ( '"' == ch ) ) { ; } else { lastDirty = processDirty ( chars , end , i , ch , lastDirty , true ) ; i = lastDirty ; } } startClean = lastDirty + 1 ; if ( i > startClean ) { int lengthClean = i - startClean ; m_writer . write ( chars , startClean , lengthClean ) ; } m_isprevtext = true ; } catch ( IOException e ) { throw new SAXException ( e ) ; } if ( m_tracer != null ) super . fireCharEvent ( chars , start , length ) ; } private int processDirty ( char [ ] chars , int end , int i , char ch , int lastDirty , boolean fromTextNode ) throws IOException { int startClean = lastDirty + 1 ; if ( i > startClean ) { int lengthClean = i - startClean ; m_writer . write ( chars , startClean , lengthClean ) ; } if ( CharInfo . S_LINEFEED == ch && fromTextNode ) { m_writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else { startClean = accumDefaultEscape ( m_writer , ( char ) ch , i , chars , end , fromTextNode , false ) ; i = startClean - 1 ; } return i ; } public void characters ( String s ) throws org . xml . sax . SAXException { final int length = s . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * 2 + 1 ] ; } s . getChars ( 0 , length , m_charsBuff , 0 ) ; characters ( m_charsBuff , 0 , length ) ; } protected int accumDefaultEscape ( Writer writer , char ch , int i , char [ ] chars , int len , boolean fromTextNode , boolean escLF ) throws IOException { int pos = accumDefaultEntity ( writer , ch , i , chars , len , fromTextNode , escLF ) ; if ( i == pos ) { if ( 0xd800 <= ch && ch < 0xdc00 ) { int next ; if ( i + 1 >= len ) { throw new IOException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) } ) ) ; } else { next = chars [ ++ i ] ; if ( ! ( 0xdc00 <= next && next < 0xe000 ) ) throw new IOException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) + " " + Integer . toHexString ( next ) } ) ) ; next = ( ( ch - 0xd800 ) << 10 ) + next - 0xdc00 + 0x00010000 ; } writer . write ( "&#" ) ; writer . write ( Integer . toString ( next ) ) ; writer . write ( ';' ) ; pos += 2 ; } else { if ( ! escapingNotNeeded ( ch ) || ( ( fromTextNode && m_charInfo . isSpecialTextChar ( ch ) ) || ( ! fromTextNode && m_charInfo . isSpecialAttrChar ( ch ) ) ) ) { writer . write ( "&#" ) ; writer . write ( Integer . toString ( ch ) ) ; writer . write ( ';' ) ; } else { writer . write ( ch ) ; } pos ++ ; } } return pos ; } public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } else if ( m_cdataTagOpen ) closeCDATA ( ) ; try { if ( ( true == m_needToOutputDocTypeDecl ) && ( null != getDoctypeSystem ( ) ) ) { outputDocTypeDecl ( name , true ) ; } m_needToOutputDocTypeDecl = false ; if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } if ( namespaceURI != null ) ensurePrefixIsDeclared ( namespaceURI , name ) ; m_ispreserve = false ; if ( shouldIndent ( ) && m_startNewLine ) { indent ( ) ; } m_startNewLine = true ; final java . io . Writer writer = m_writer ; writer . write ( '<' ) ; writer . write ( name ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } if ( atts != null ) addAttributes ( atts ) ; m_elemContext = m_elemContext . push ( namespaceURI , localName , name ) ; m_isprevtext = false ; if ( m_tracer != null ) firePseudoAttributes ( ) ; } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { startElement ( elementNamespaceURI , elementLocalName , elementName , null ) ; } public void startElement ( String elementName ) throws SAXException { startElement ( null , null , elementName , null ) ; } void outputDocTypeDecl ( String name , boolean closeDecl ) throws SAXException { if ( m_cdataTagOpen ) closeCDATA ( ) ; try { final java . io . Writer writer = m_writer ; writer . write ( "<!DOCTYPE " ) ; writer . write ( name ) ; String doctypePublic = getDoctypePublic ( ) ; if ( null != doctypePublic ) { writer . write ( " PUBLIC \"" ) ; writer . write ( doctypePublic ) ; writer . write ( '\"' ) ; } String doctypeSystem = getDoctypeSystem ( ) ; if ( null != doctypeSystem ) { if ( null == doctypePublic ) writer . write ( " SYSTEM \"" ) ; else writer . write ( " \"" ) ; writer . write ( doctypeSystem ) ; if ( closeDecl ) { writer . write ( "\">" ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; closeDecl = false ; } else writer . write ( '\"' ) ; } boolean dothis = false ; if ( dothis ) { if ( closeDecl ) { writer . write ( '>' ) ; writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } } } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void processAttributes ( java . io . Writer writer , int nAttrs ) throws IOException , SAXException { String encoding = getEncoding ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { final String name = m_attributes . getQName ( i ) ; final String value = m_attributes . getValue ( i ) ; writer . write ( ' ' ) ; writer . write ( name ) ; writer . write ( "=\"" ) ; writeAttrString ( writer , value , encoding ) ; writer . write ( '\"' ) ; } } public void writeAttrString ( Writer writer , String string , String encoding ) throws IOException { final int len = string . length ( ) ; if ( len > m_attrBuff . length ) { m_attrBuff = new char [ len * 2 + 1 ] ; } string . getChars ( 0 , len , m_attrBuff , 0 ) ; final char [ ] stringChars = m_attrBuff ; for ( int i = 0 ; i < len ; i ++ ) { char ch = stringChars [ i ] ; if ( escapingNotNeeded ( ch ) && ( ! m_charInfo . isSpecialAttrChar ( ch ) ) ) { writer . write ( ch ) ; } else { accumDefaultEscape ( writer , ch , i , stringChars , len , false , true ) ; } } } public void endElement ( String namespaceURI , String localName , String name ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; m_prefixMap . popNamespaces ( m_elemContext . m_currentElemDepth , null ) ; try { final java . io . Writer writer = m_writer ; if ( m_elemContext . m_startTagOpen ) { if ( m_tracer != null ) super . fireStartElem ( m_elemContext . m_elementName ) ; int nAttrs = m_attributes . getLength ( ) ; if ( nAttrs > 0 ) { processAttributes ( m_writer , nAttrs ) ; m_attributes . clear ( ) ; } if ( m_spaceBeforeClose ) writer . write ( " />" ) ; else writer . write ( "/>" ) ; } else { if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( shouldIndent ( ) ) indent ( m_elemContext . m_currentElemDepth - 1 ) ; writer . write ( '<' ) ; writer . write ( '/' ) ; writer . write ( name ) ; writer . write ( '>' ) ; } } catch ( IOException e ) { throw new SAXException ( e ) ; } if ( ! m_elemContext . m_startTagOpen && m_doIndent ) { m_ispreserve = m_preserves . isEmpty ( ) ? false : m_preserves . pop ( ) ; } m_isprevtext = false ; if ( m_tracer != null ) super . fireEndElem ( name ) ; m_elemContext = m_elemContext . m_prev ; } public void endElement ( String name ) throws org . xml . sax . SAXException { endElement ( null , null , name ) ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { startPrefixMapping ( prefix , uri , true ) ; } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws org . xml . sax . SAXException { boolean pushed ; int pushDepth ; if ( shouldFlush ) { flushPending ( ) ; pushDepth = m_elemContext . m_currentElemDepth + 1 ; } else { pushDepth = m_elemContext . m_currentElemDepth ; } pushed = m_prefixMap . pushNamespace ( prefix , uri , pushDepth ) ; if ( pushed ) { String name ; if ( EMPTYSTRING . equals ( prefix ) ) { name = "xmlns" ; addAttributeAlways ( XMLNS_URI , prefix , name , "CDATA" , uri ) ; } else { if ( ! EMPTYSTRING . equals ( uri ) ) { name = "xmlns:" + prefix ; addAttributeAlways ( XMLNS_URI , prefix , name , "CDATA" , uri ) ; } } } return pushed ; } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { int start_old = start ; if ( m_inEntityRef ) return ; if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } else if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } try { if ( shouldIndent ( ) ) indent ( ) ; final int limit = start + length ; boolean wasDash = false ; if ( m_cdataTagOpen ) closeCDATA ( ) ; final java . io . Writer writer = m_writer ; writer . write ( COMMENT_BEGIN ) ; for ( int i = start ; i < limit ; i ++ ) { if ( wasDash && ch [ i ] == '-' ) { writer . write ( ch , start , i - start ) ; writer . write ( " -" ) ; start = i + 1 ; } wasDash = ( ch [ i ] == '-' ) ; } if ( length > 0 ) { final int remainingChars = ( limit - start ) ; if ( remainingChars > 0 ) writer . write ( ch , start , remainingChars ) ; if ( ch [ limit - 1 ] == '-' ) writer . write ( ' ' ) ; } writer . write ( COMMENT_END ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } m_startNewLine = true ; if ( m_tracer != null ) super . fireCommentEvent ( ch , start_old , length ) ; } public void endCDATA ( ) throws org . xml . sax . SAXException { if ( m_cdataTagOpen ) closeCDATA ( ) ; m_cdataStartCalled = false ; } public void endDTD ( ) throws org . xml . sax . SAXException { try { if ( m_needToOutputDocTypeDecl ) { outputDocTypeDecl ( m_elemContext . m_elementName , false ) ; m_needToOutputDocTypeDecl = false ; } final java . io . Writer writer = m_writer ; if ( ! m_inDoctype ) writer . write ( "]>" ) ; else { writer . write ( '>' ) ; } writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( 0 == length ) return ; characters ( ch , start , length ) ; } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { } public void startCDATA ( ) throws org . xml . sax . SAXException { m_cdataStartCalled = true ; } public void startEntity ( String name ) throws org . xml . sax . SAXException { if ( name . equals ( "[dtd]" ) ) m_inExternalDTD = true ; m_inEntityRef = true ; } protected void closeStartTag ( ) throws SAXException { if ( m_elemContext . m_startTagOpen ) { try { if ( m_tracer != null ) super . fireStartElem ( m_elemContext . m_elementName ) ; int nAttrs = m_attributes . getLength ( ) ; if ( nAttrs > 0 ) { processAttributes ( m_writer , nAttrs ) ; m_attributes . clear ( ) ; } m_writer . write ( '>' ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } if ( m_cdataSectionElements != null ) m_elemContext . m_isCdataSection = isCdataSection ( ) ; if ( m_doIndent ) { m_isprevtext = false ; m_preserves . push ( m_ispreserve ) ; } } } public void startDTD ( String name , String publicId , String systemId ) throws org . xml . sax . SAXException { setDoctypeSystem ( systemId ) ; setDoctypePublic ( publicId ) ; m_elemContext . m_elementName = name ; m_inDoctype = true ; } public int getIndentAmount ( ) { return m_indentAmount ; } public void setIndentAmount ( int m_indentAmount ) { this . m_indentAmount = m_indentAmount ; } protected boolean shouldIndent ( ) { return m_doIndent && ( ! m_ispreserve && ! m_isprevtext ) ; } private void setCdataSectionElements ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null != s ) { Vector v = new Vector ( ) ; int l = s . length ( ) ; boolean inCurly = false ; FastStringBuffer buf = new FastStringBuffer ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char c = s . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! inCurly ) { if ( buf . length ( ) > 0 ) { addCdataSectionElement ( buf . toString ( ) , v ) ; buf . reset ( ) ; } continue ; } } else if ( '{' == c ) inCurly = true ; else if ( '}' == c ) inCurly = false ; buf . append ( c ) ; } if ( buf . length ( ) > 0 ) { addCdataSectionElement ( buf . toString ( ) , v ) ; buf . reset ( ) ; } setCdataSectionElements ( v ) ; } } private void addCdataSectionElement ( String URI_and_localName , Vector v ) { StringTokenizer tokenizer = new StringTokenizer ( URI_and_localName , "{}" , false ) ; QName qname ; String s1 = tokenizer . nextToken ( ) ; String s2 = tokenizer . hasMoreTokens ( ) ? tokenizer . nextToken ( ) : null ; if ( null == s2 ) { v . addElement ( null ) ; v . addElement ( s1 ) ; } else { v . addElement ( s1 ) ; v . addElement ( s2 ) ; } } public void setCdataSectionElements ( Vector URI_and_localNames ) { m_cdataSectionElements = URI_and_localNames ; } protected String ensureAttributesNamespaceIsDeclared ( String ns , String localName , String rawName ) throws org . xml . sax . SAXException { if ( ns != null && ns . length ( ) > 0 ) { int index = 0 ; String prefixFromRawName = ( index = rawName . indexOf ( ":" ) ) < 0 ? "" : rawName . substring ( 0 , index ) ; if ( index > 0 ) { String uri = m_prefixMap . lookupNamespace ( prefixFromRawName ) ; if ( uri != null && uri . equals ( ns ) ) { return null ; } else { this . startPrefixMapping ( prefixFromRawName , ns , false ) ; this . addAttribute ( "http://www.w3.org/2000/xmlns/" , prefixFromRawName , "xmlns:" + prefixFromRawName , "CDATA" , ns ) ; return prefixFromRawName ; } } else { String prefix = m_prefixMap . lookupPrefix ( ns ) ; if ( prefix == null ) { prefix = m_prefixMap . generateNextPrefix ( ) ; this . startPrefixMapping ( prefix , ns , false ) ; this . addAttribute ( "http://www.w3.org/2000/xmlns/" , prefix , "xmlns:" + prefix , "CDATA" , ns ) ; } return prefix ; } } return null ; } void ensurePrefixIsDeclared ( String ns , String rawName ) throws org . xml . sax . SAXException { if ( ns != null && ns . length ( ) > 0 ) { int index ; String prefix = ( index = rawName . indexOf ( ":" ) ) < 0 ? "" : rawName . substring ( 0 , index ) ; if ( null != prefix ) { String foundURI = m_prefixMap . lookupNamespace ( prefix ) ; if ( ( null == foundURI ) || ! foundURI . equals ( ns ) ) { this . startPrefixMapping ( prefix , ns ) ; this . addAttributeAlways ( "http://www.w3.org/2000/xmlns/" , prefix , "xmlns" + ( prefix . length ( ) == 0 ? "" : ":" ) + prefix , "CDATA" , ns ) ; } } } } public void flushPending ( ) throws SAXException { if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } if ( m_cdataTagOpen ) { closeCDATA ( ) ; m_cdataTagOpen = false ; } } public void setContentHandler ( ContentHandler ch ) { } public void addAttributeAlways ( String uri , String localName , String rawName , String type , String value ) { int index ; index = m_attributes . getIndex ( rawName ) ; if ( index >= 0 ) { String old_value = null ; if ( m_tracer != null ) { old_value = m_attributes . getValue ( index ) ; if ( value . equals ( old_value ) ) old_value = null ; } m_attributes . setValue ( index , value ) ; if ( old_value != null ) firePseudoAttributes ( ) ; } else { m_attributes . addAttribute ( uri , localName , rawName , type , value ) ; if ( m_tracer != null ) firePseudoAttributes ( ) ; } } protected void firePseudoAttributes ( ) { if ( m_tracer != null ) { try { m_writer . flush ( ) ; StringBuffer sb = new StringBuffer ( ) ; int nAttrs = m_attributes . getLength ( ) ; if ( nAttrs > 0 ) { java . io . Writer writer = new ToStream . WritertoStringBuffer ( sb ) ; processAttributes ( writer , nAttrs ) ; } sb . append ( '>' ) ; char ch [ ] = sb . toString ( ) . toCharArray ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS , ch , 0 , ch . length ) ; } catch ( IOException ioe ) { } catch ( SAXException se ) { } } } private class WritertoStringBuffer extends java . io . Writer { final private StringBuffer m_stringbuf ; WritertoStringBuffer ( StringBuffer sb ) { m_stringbuf = sb ; } public void write ( char [ ] arg0 , int arg1 , int arg2 ) throws IOException { m_stringbuf . append ( arg0 , arg1 , arg2 ) ; } public void flush ( ) throws IOException { } public void close ( ) throws IOException { } public void write ( int i ) { m_stringbuf . append ( ( char ) i ) ; } public void write ( String s ) { m_stringbuf . append ( s ) ; } } public void setTransformer ( Transformer transformer ) { super . setTransformer ( transformer ) ; if ( m_tracer != null && ! ( m_writer instanceof SerializerTraceWriter ) ) m_writer = new SerializerTraceWriter ( m_writer , m_tracer ) ; } public boolean reset ( ) { boolean wasReset = false ; if ( super . reset ( ) ) { resetToStream ( ) ; wasReset = true ; } return wasReset ; } private void resetToStream ( ) { this . m_canConvertMeth = null ; this . m_cdataStartCalled = false ; this . m_charToByteConverter = null ; this . m_disableOutputEscapingStates . clear ( ) ; this . m_escaping = true ; this . m_inDoctype = false ; this . m_ispreserve = false ; this . m_ispreserve = false ; this . m_isprevtext = false ; this . m_isUTF8 = false ; this . m_maxCharacter = Encodings . getLastPrintable ( ) ; this . m_preserves . clear ( ) ; this . m_shouldFlush = true ; this . m_spaceBeforeClose = false ; this . m_startNewLine = false ; this . m_triedToGetConverter = false ; this . m_lineSepUse = true ; } } 	1	['74', '2', '3', '23', '189', '1615', '4', '20', '44', '0.855541719', '3057', '0.727272727', '3', '0.54375', '0.154440154', '2', '12', '40.01351351', '12', '1.6216', '9']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMEnhancedForDTM ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMWSFilter ; public class DOMWSFilter implements DTMWSFilter { private AbstractTranslet m_translet ; private StripFilter m_filter ; private Hashtable m_mappings ; private DTM m_currentDTM ; private short [ ] m_currentMapping ; public DOMWSFilter ( AbstractTranslet translet ) { m_translet = translet ; m_mappings = new Hashtable ( ) ; if ( translet instanceof StripFilter ) { m_filter = ( StripFilter ) translet ; } } public short getShouldStripSpace ( int node , DTM dtm ) { if ( m_filter != null && dtm instanceof DOM ) { DOM dom = ( DOM ) dtm ; int type = 0 ; if ( dtm instanceof DOMEnhancedForDTM ) { DOMEnhancedForDTM mappableDOM = ( DOMEnhancedForDTM ) dtm ; short [ ] mapping ; if ( dtm == m_currentDTM ) { mapping = m_currentMapping ; } else { mapping = ( short [ ] ) m_mappings . get ( dtm ) ; if ( mapping == null ) { mapping = mappableDOM . getMapping ( m_translet . getNamesArray ( ) , m_translet . getUrisArray ( ) , m_translet . getTypesArray ( ) ) ; m_mappings . put ( dtm , mapping ) ; m_currentDTM = dtm ; m_currentMapping = mapping ; } } int expType = mappableDOM . getExpandedTypeID ( node ) ; if ( expType >= 0 && expType < mapping . length ) type = mapping [ expType ] ; else type = - 1 ; } else { return INHERIT ; } if ( m_filter . stripSpace ( dom , node , type ) ) { return STRIP ; } else { return NOTSTRIP ; } } else { return NOTSTRIP ; } } } 	1	['2', '1', '0', '11', '12', '0', '4', '7', '2', '0.4', '116', '1', '4', '0', '0.625', '0', '0', '54.5', '9', '4.5', '1']
package org . apache . xml . utils . res ; public class XResources_zh_CN extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "zh" } , { "help_language" , "zh" } , { "language" , "zh" } , { "alphabet" , new char [ ] { 0xff21 , 0xff22 , 0xff23 , 0xff24 , 0xff25 , 0xff26 , 0xff27 , 0xff28 , 0xff29 , 0xff2a , 0xff2b , 0xff2c , 0xff2d , 0xff2e , 0xff2f , 0xff30 , 0xff31 , 0xff32 , 0xff33 , 0xff34 , 0xff35 , 0xff36 , 0xff37 , 0xff38 , 0xff39 , 0xff3a } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "zero" , new char [ ] { 0x96f6 } } , { "multiplier" , new long [ ] { 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4ebf , 0x4e07 , 0x5343 , 0x767e , 0x5341 } } , { "digits" , new char [ ] { 0x4e00 , 0x4e8c , 0x4e09 , 0x56db , 0x4e94 , 0x516d , 0x4e03 , 0x516b , 0x4e5d } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '499', '0', '0', '0.976190476', '1', '0', '0', '165', '1', '0.3333', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; public class ElemApplyImport extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_APPLY_IMPORTS ; } public String getNodeName ( ) { return Constants . ELEMNAME_APPLY_IMPORTS_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( transformer . currentTemplateRuleIsNull ( ) ) { transformer . getMsgMgr ( ) . error ( this , XSLTErrorResources . ER_NO_APPLY_IMPORT_IN_FOR_EACH ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; int sourceNode = transformer . getXPathContext ( ) . getCurrentNode ( ) ; if ( DTM . NULL != sourceNode ) { transformer . applyTemplateToNode ( this , null , sourceNode ) ; } else { transformer . getMsgMgr ( ) . error ( this , XSLTErrorResources . ER_NULL_SOURCENODE_APPLYIMPORTS ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; return null ; } } 	1	['5', '3', '0', '7', '17', '10', '1', '6', '5', '2', '69', '0', '0', '0.98', '0.466666667', '2', '6', '12.8', '1', '0.8', '2']
package org . apache . xpath ; import java . lang . reflect . Method ; import java . util . Stack ; import java . util . Vector ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . ref . sax2dtm . SAX2RTFDTM ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . NodeVector ; import org . apache . xml . utils . ObjectStack ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . apache . xpath . res . XPATHErrorResources ; import org . xml . sax . XMLReader ; public class XPathContext extends DTMManager { IntStack m_last_pushed_rtfdtm = new IntStack ( ) ; private Vector m_rtfdtm_stack = null ; private int m_which_rtfdtm = - 1 ; private SAX2RTFDTM m_global_rtfdtm = null ; protected DTMManager m_dtmManager = DTMManager . newInstance ( org . apache . xpath . objects . XMLStringFactoryImpl . getFactory ( ) ) ; public DTMManager getDTMManager ( ) { return m_dtmManager ; } public DTM getDTM ( javax . xml . transform . Source source , boolean unique , DTMWSFilter wsfilter , boolean incremental , boolean doIndexing ) { return m_dtmManager . getDTM ( source , unique , wsfilter , incremental , doIndexing ) ; } public DTM getDTM ( int nodeHandle ) { return m_dtmManager . getDTM ( nodeHandle ) ; } public int getDTMHandleFromNode ( org . w3c . dom . Node node ) { return m_dtmManager . getDTMHandleFromNode ( node ) ; } public int getDTMIdentity ( DTM dtm ) { return m_dtmManager . getDTMIdentity ( dtm ) ; } public DTM createDocumentFragment ( ) { return m_dtmManager . createDocumentFragment ( ) ; } public boolean release ( DTM dtm , boolean shouldHardDelete ) { if ( m_rtfdtm_stack != null && m_rtfdtm_stack . contains ( dtm ) ) { return false ; } return m_dtmManager . release ( dtm , shouldHardDelete ) ; } public DTMIterator createDTMIterator ( Object xpathCompiler , int pos ) { return m_dtmManager . createDTMIterator ( xpathCompiler , pos ) ; } public DTMIterator createDTMIterator ( String xpathString , PrefixResolver presolver ) { return m_dtmManager . createDTMIterator ( xpathString , presolver ) ; } public DTMIterator createDTMIterator ( int whatToShow , DTMFilter filter , boolean entityReferenceExpansion ) { return m_dtmManager . createDTMIterator ( whatToShow , filter , entityReferenceExpansion ) ; } public DTMIterator createDTMIterator ( int node ) { DTMIterator iter = new org . apache . xpath . axes . OneStepIteratorForward ( Axis . SELF ) ; iter . setRoot ( node , this ) ; return iter ; } public XPathContext ( ) { m_prefixResolvers . push ( null ) ; m_currentNodes . push ( DTM . NULL ) ; m_currentExpressionNodes . push ( DTM . NULL ) ; m_saxLocations . push ( null ) ; } public XPathContext ( Object owner ) { m_owner = owner ; try { m_ownerGetErrorListener = m_owner . getClass ( ) . getMethod ( "getErrorListener" , new Class [ ] { } ) ; } catch ( NoSuchMethodException nsme ) { } m_prefixResolvers . push ( null ) ; m_currentNodes . push ( DTM . NULL ) ; m_currentExpressionNodes . push ( DTM . NULL ) ; m_saxLocations . push ( null ) ; } public void reset ( ) { if ( m_rtfdtm_stack != null ) for ( java . util . Enumeration e = m_rtfdtm_stack . elements ( ) ; e . hasMoreElements ( ) ; ) m_dtmManager . release ( ( DTM ) e . nextElement ( ) , true ) ; m_rtfdtm_stack = null ; m_which_rtfdtm = - 1 ; if ( m_global_rtfdtm != null ) m_dtmManager . release ( m_global_rtfdtm , true ) ; m_global_rtfdtm = null ; m_dtmManager = DTMManager . newInstance ( org . apache . xpath . objects . XMLStringFactoryImpl . getFactory ( ) ) ; m_saxLocations . removeAllElements ( ) ; m_axesIteratorStack . removeAllElements ( ) ; m_contextNodeLists . removeAllElements ( ) ; m_currentExpressionNodes . removeAllElements ( ) ; m_currentNodes . removeAllElements ( ) ; m_iteratorRoots . RemoveAllNoClear ( ) ; m_predicatePos . removeAllElements ( ) ; m_predicateRoots . RemoveAllNoClear ( ) ; m_prefixResolvers . removeAllElements ( ) ; m_prefixResolvers . push ( null ) ; m_currentNodes . push ( DTM . NULL ) ; m_currentExpressionNodes . push ( DTM . NULL ) ; m_saxLocations . push ( null ) ; } ObjectStack m_saxLocations = new ObjectStack ( RECURSIONLIMIT ) ; public void setSAXLocator ( SourceLocator location ) { m_saxLocations . setTop ( location ) ; } public void pushSAXLocator ( SourceLocator location ) { m_saxLocations . push ( location ) ; } public void pushSAXLocatorNull ( ) { m_saxLocations . push ( null ) ; } public void popSAXLocator ( ) { m_saxLocations . pop ( ) ; } public SourceLocator getSAXLocator ( ) { return ( SourceLocator ) m_saxLocations . peek ( ) ; } private Object m_owner ; private Method m_ownerGetErrorListener ; public Object getOwnerObject ( ) { return m_owner ; } private VariableStack m_variableStacks = new VariableStack ( ) ; public final VariableStack getVarStack ( ) { return m_variableStacks ; } public final void setVarStack ( VariableStack varStack ) { m_variableStacks = varStack ; } private SourceTreeManager m_sourceTreeManager = new SourceTreeManager ( ) ; public final SourceTreeManager getSourceTreeManager ( ) { return m_sourceTreeManager ; } public void setSourceTreeManager ( SourceTreeManager mgr ) { m_sourceTreeManager = mgr ; } private ErrorListener m_errorListener ; private ErrorListener m_defaultErrorListener ; public final ErrorListener getErrorListener ( ) { if ( null != m_errorListener ) return m_errorListener ; ErrorListener retval = null ; try { if ( null != m_ownerGetErrorListener ) retval = ( ErrorListener ) m_ownerGetErrorListener . invoke ( m_owner , new Object [ ] { } ) ; } catch ( Exception e ) { } if ( null == retval ) { if ( null == m_defaultErrorListener ) m_defaultErrorListener = new org . apache . xml . utils . DefaultErrorHandler ( ) ; retval = m_defaultErrorListener ; } return retval ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( listener == null ) throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_ERROR_HANDLER , null ) ) ; m_errorListener = listener ; } private URIResolver m_uriResolver ; public final URIResolver getURIResolver ( ) { return m_uriResolver ; } public void setURIResolver ( URIResolver resolver ) { m_uriResolver = resolver ; } public XMLReader m_primaryReader ; public final XMLReader getPrimaryReader ( ) { return m_primaryReader ; } public void setPrimaryReader ( XMLReader reader ) { m_primaryReader = reader ; } private void assertion ( boolean b , String msg ) throws javax . xml . transform . TransformerException { if ( ! b ) { ErrorListener errorHandler = getErrorListener ( ) ; if ( errorHandler != null ) { errorHandler . fatalError ( new TransformerException ( XSLMessages . createMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) , ( SAXSourceLocator ) this . getSAXLocator ( ) ) ) ; } } } private Stack m_contextNodeLists = new Stack ( ) ; public Stack getContextNodeListsStack ( ) { return m_contextNodeLists ; } public void setContextNodeListsStack ( Stack s ) { m_contextNodeLists = s ; } public final DTMIterator getContextNodeList ( ) { if ( m_contextNodeLists . size ( ) > 0 ) return ( DTMIterator ) m_contextNodeLists . peek ( ) ; else return null ; } public final void pushContextNodeList ( DTMIterator nl ) { m_contextNodeLists . push ( nl ) ; } public final void popContextNodeList ( ) { if ( m_contextNodeLists . isEmpty ( ) ) System . err . println ( "Warning: popContextNodeList when stack is empty!" ) ; else m_contextNodeLists . pop ( ) ; } public static final int RECURSIONLIMIT = ( 1024 * 4 ) ; private IntStack m_currentNodes = new IntStack ( RECURSIONLIMIT ) ; public IntStack getCurrentNodeStack ( ) { return m_currentNodes ; } public void setCurrentNodeStack ( IntStack nv ) { m_currentNodes = nv ; } public final int getCurrentNode ( ) { return m_currentNodes . peek ( ) ; } public final void pushCurrentNodeAndExpression ( int cn , int en ) { m_currentNodes . push ( cn ) ; m_currentExpressionNodes . push ( cn ) ; } public final void popCurrentNodeAndExpression ( ) { m_currentNodes . quickPop ( 1 ) ; m_currentExpressionNodes . quickPop ( 1 ) ; } public final void pushExpressionState ( int cn , int en , PrefixResolver nc ) { m_currentNodes . push ( cn ) ; m_currentExpressionNodes . push ( cn ) ; m_prefixResolvers . push ( nc ) ; } public final void popExpressionState ( ) { m_currentNodes . quickPop ( 1 ) ; m_currentExpressionNodes . quickPop ( 1 ) ; m_prefixResolvers . pop ( ) ; } public final void pushCurrentNode ( int n ) { m_currentNodes . push ( n ) ; } public final void popCurrentNode ( ) { m_currentNodes . quickPop ( 1 ) ; } public final void pushPredicateRoot ( int n ) { m_predicateRoots . push ( n ) ; } public final void popPredicateRoot ( ) { m_predicateRoots . popQuick ( ) ; } public final int getPredicateRoot ( ) { return m_predicateRoots . peepOrNull ( ) ; } public final void pushIteratorRoot ( int n ) { m_iteratorRoots . push ( n ) ; } public final void popIteratorRoot ( ) { m_iteratorRoots . popQuick ( ) ; } public final int getIteratorRoot ( ) { return m_iteratorRoots . peepOrNull ( ) ; } private NodeVector m_iteratorRoots = new NodeVector ( ) ; private NodeVector m_predicateRoots = new NodeVector ( ) ; private IntStack m_currentExpressionNodes = new IntStack ( RECURSIONLIMIT ) ; public IntStack getCurrentExpressionNodeStack ( ) { return m_currentExpressionNodes ; } public void setCurrentExpressionNodeStack ( IntStack nv ) { m_currentExpressionNodes = nv ; } private IntStack m_predicatePos = new IntStack ( ) ; public final int getPredicatePos ( ) { return m_predicatePos . peek ( ) ; } public final void pushPredicatePos ( int n ) { m_predicatePos . push ( n ) ; } public final void popPredicatePos ( ) { m_predicatePos . pop ( ) ; } public final int getCurrentExpressionNode ( ) { return m_currentExpressionNodes . peek ( ) ; } public final void pushCurrentExpressionNode ( int n ) { m_currentExpressionNodes . push ( n ) ; } public final void popCurrentExpressionNode ( ) { m_currentExpressionNodes . quickPop ( 1 ) ; } private ObjectStack m_prefixResolvers = new ObjectStack ( RECURSIONLIMIT ) ; public final PrefixResolver getNamespaceContext ( ) { return ( PrefixResolver ) m_prefixResolvers . peek ( ) ; } public final void setNamespaceContext ( PrefixResolver pr ) { m_prefixResolvers . setTop ( pr ) ; } public final void pushNamespaceContext ( PrefixResolver pr ) { m_prefixResolvers . push ( pr ) ; } public final void pushNamespaceContextNull ( ) { m_prefixResolvers . push ( null ) ; } public final void popNamespaceContext ( ) { m_prefixResolvers . pop ( ) ; } private Stack m_axesIteratorStack = new Stack ( ) ; public Stack getAxesIteratorStackStacks ( ) { return m_axesIteratorStack ; } public void setAxesIteratorStackStacks ( Stack s ) { m_axesIteratorStack = s ; } public final void pushSubContextList ( SubContextList iter ) { m_axesIteratorStack . push ( iter ) ; } public final void popSubContextList ( ) { m_axesIteratorStack . pop ( ) ; } public SubContextList getSubContextList ( ) { return m_axesIteratorStack . isEmpty ( ) ? null : ( SubContextList ) m_axesIteratorStack . peek ( ) ; } public org . apache . xpath . axes . SubContextList getCurrentNodeList ( ) { return m_axesIteratorStack . isEmpty ( ) ? null : ( SubContextList ) m_axesIteratorStack . elementAt ( 0 ) ; } public final int getContextNode ( ) { return this . getCurrentNode ( ) ; } public final DTMIterator getContextNodes ( ) { try { DTMIterator cnl = getContextNodeList ( ) ; if ( null != cnl ) return cnl . cloneWithReset ( ) ; else return null ; } catch ( CloneNotSupportedException cnse ) { return null ; } } XPathExpressionContext expressionContext = new XPathExpressionContext ( ) ; public ExpressionContext getExpressionContext ( ) { return expressionContext ; } public class XPathExpressionContext implements ExpressionContext { public XPathContext getXPathContext ( ) { return XPathContext . this ; } public DTMManager getDTMManager ( ) { return m_dtmManager ; } public org . w3c . dom . Node getContextNode ( ) { int context = getCurrentNode ( ) ; return getDTM ( context ) . getNode ( context ) ; } public org . w3c . dom . traversal . NodeIterator getContextNodes ( ) { return new org . apache . xml . dtm . ref . DTMNodeIterator ( getContextNodeList ( ) ) ; } public ErrorListener getErrorListener ( ) { return XPathContext . this . getErrorListener ( ) ; } public double toNumber ( org . w3c . dom . Node n ) { int nodeHandle = getDTMHandleFromNode ( n ) ; DTM dtm = getDTM ( nodeHandle ) ; XString xobj = ( XString ) dtm . getStringValue ( nodeHandle ) ; return xobj . num ( ) ; } public String toString ( org . w3c . dom . Node n ) { int nodeHandle = getDTMHandleFromNode ( n ) ; DTM dtm = getDTM ( nodeHandle ) ; XMLString strVal = dtm . getStringValue ( nodeHandle ) ; return strVal . toString ( ) ; } public final XObject getVariableOrParam ( org . apache . xml . utils . QName qname ) throws javax . xml . transform . TransformerException { return m_variableStacks . getVariableOrParam ( XPathContext . this , qname ) ; } } public DTM getGlobalRTFDTM ( ) { if ( m_global_rtfdtm == null || m_global_rtfdtm . isTreeIncomplete ( ) ) { m_global_rtfdtm = ( SAX2RTFDTM ) m_dtmManager . getDTM ( null , true , null , false , false ) ; } return m_global_rtfdtm ; } public DTM getRTFDTM ( ) { SAX2RTFDTM rtfdtm ; if ( m_rtfdtm_stack == null ) { m_rtfdtm_stack = new Vector ( ) ; rtfdtm = ( SAX2RTFDTM ) m_dtmManager . getDTM ( null , true , null , false , false ) ; m_rtfdtm_stack . addElement ( rtfdtm ) ; ++ m_which_rtfdtm ; } else if ( m_which_rtfdtm < 0 ) { rtfdtm = ( SAX2RTFDTM ) m_rtfdtm_stack . elementAt ( ++ m_which_rtfdtm ) ; } else { rtfdtm = ( SAX2RTFDTM ) m_rtfdtm_stack . elementAt ( m_which_rtfdtm ) ; if ( rtfdtm . isTreeIncomplete ( ) ) { if ( ++ m_which_rtfdtm < m_rtfdtm_stack . size ( ) ) rtfdtm = ( SAX2RTFDTM ) m_rtfdtm_stack . elementAt ( m_which_rtfdtm ) ; else { rtfdtm = ( SAX2RTFDTM ) m_dtmManager . getDTM ( null , true , null , false , false ) ; m_rtfdtm_stack . addElement ( rtfdtm ) ; } } } return rtfdtm ; } public void pushRTFContext ( ) { m_last_pushed_rtfdtm . push ( m_which_rtfdtm ) ; if ( null != m_rtfdtm_stack ) ( ( SAX2RTFDTM ) ( getRTFDTM ( ) ) ) . pushRewindMark ( ) ; } public void popRTFContext ( ) { int previous = m_last_pushed_rtfdtm . pop ( ) ; if ( null == m_rtfdtm_stack ) return ; if ( m_which_rtfdtm == previous ) { if ( previous >= 0 ) { boolean isEmpty = ( ( SAX2RTFDTM ) ( m_rtfdtm_stack . elementAt ( previous ) ) ) . popRewindMark ( ) ; } } else while ( m_which_rtfdtm != previous ) { boolean isEmpty = ( ( SAX2RTFDTM ) ( m_rtfdtm_stack . elementAt ( m_which_rtfdtm ) ) ) . popRewindMark ( ) ; -- m_which_rtfdtm ; } } } 	1	['78', '2', '0', '168', '143', '2203', '152', '21', '76', '0.93452381', '1065', '0.791666667', '13', '0.2', '0.06993007', '0', '0', '12.34615385', '5', '1.2821', '2']
package org . apache . xalan . processor ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemTemplateElement ; import org . xml . sax . Attributes ; public class ProcessorTemplateElem extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { super . startElement ( handler , uri , localName , rawName , attributes ) ; try { XSLTElementDef def = getElemDef ( ) ; Class classObject = def . getClassObject ( ) ; ElemTemplateElement elem = null ; try { elem = ( ElemTemplateElement ) classObject . newInstance ( ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; elem . setLocaterInfo ( handler . getLocator ( ) ) ; elem . setPrefixes ( handler . getNamespaceSupport ( ) ) ; } catch ( InstantiationException ie ) { handler . error ( XSLTErrorResources . ER_FAILED_CREATING_ELEMTMPL , null , ie ) ; } catch ( IllegalAccessException iae ) { handler . error ( XSLTErrorResources . ER_FAILED_CREATING_ELEMTMPL , null , iae ) ; } setPropertiesFromAttributes ( handler , rawName , attributes , elem ) ; appendAndPush ( handler , elem ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; if ( null != parent ) { parent . appendChild ( elem ) ; handler . pushElemTemplateElement ( elem ) ; } } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { super . endElement ( handler , uri , localName , rawName ) ; handler . popElemTemplateElement ( ) . setEndLocaterInfo ( handler . getLocator ( ) ) ; } } 	1	['4', '4', '7', '13', '24', '6', '8', '5', '3', '2', '96', '0', '0', '0.985915493', '0.55', '1', '2', '23', '1', '0.75', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_zh_CN extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "同一文件中定义了多个样式表。" } , { ErrorMsg . TEMPLATE_REDEF_ERR , "此样式表中已经定义了模板“{0}”。" } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "此样式表中未定义模板“{0}”。" } , { ErrorMsg . VARIABLE_REDEF_ERR , "同一作用域中多次定义了变量“{0}”。" } , { ErrorMsg . VARIABLE_UNDEF_ERR , "未定义变量或参数“{0}”。" } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "找不到类“{0}”。" } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "找不到外部方法“{0}”（必须是 public）。" } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "无法将调用中的自变量／返回类型转换为方法“{0}”" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "找不到文件或 URI“{0}”。" } , { ErrorMsg . INVALID_URI_ERR , "URI“{0}”无效。" } , { ErrorMsg . FILE_ACCESS_ERR , "无法打开文件或 URI“{0}”。" } , { ErrorMsg . MISSING_ROOT_ERR , "期望出现 <xsl:stylesheet> 或 <xsl:transform> 元素。" } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "未说明名称空间前缀“{0}”。" } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "无法解析对函数“{0}”的调用。" } , { ErrorMsg . NEED_LITERAL_ERR , "“{0}”的自变量必须是文字字符串。" } , { ErrorMsg . XPATH_PARSER_ERR , "分析 XPath 表达式“{0}”时出错。" } , { ErrorMsg . REQUIRED_ATTR_ERR , "缺少必需的属性“{0}”。" } , { ErrorMsg . ILLEGAL_CHAR_ERR , "XPath 表达式中的字符“{0}”非法。" } , { ErrorMsg . ILLEGAL_PI_ERR , "处理指令的名称“{0}”非法。" } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "属性“{0}”在元素外。" } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "属性“{0}”非法。" } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "循环 import／include。已装入样式表“{0}”。" } , { ErrorMsg . RESULT_TREE_SORT_ERR , "无法排序结果树片段（<xsl:sort> 元素被忽略）。必须在创建结果树时对节点进行排序。" } , { ErrorMsg . SYMBOLS_REDEF_ERR , "已经定义了十进制格式的“{0}”。" } , { ErrorMsg . XSL_VERSION_ERR , "XSLTC 不支持 XSL 版本“{0}”。" } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "“{0}”中存在循环变量／参数引用。" } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "二进制表达式的运算符未知。" } , { ErrorMsg . ILLEGAL_ARG_ERR , "函数调用的自变量非法。" } , { ErrorMsg . DOCUMENT_ARG_ERR , "函数 document() 的第二个自变量必须是节点集。" } , { ErrorMsg . MISSING_WHEN_ERR , "<xsl:choose> 中至少要有一个 <xsl:when> 元素。" } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "<xsl:choose> 中只允许有一个 <xsl:otherwise> 元素。" } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> 只能在 <xsl:choose> 中使用。" } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> 只能在 <xsl:choose> 中使用。" } , { ErrorMsg . WHEN_ELEMENT_ERR , "<xsl:choose> 中只允许使用 <xsl:when> 和 <xsl:otherwise>。" } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set> 缺少“name”属性。" } , { ErrorMsg . ILLEGAL_CHILD_ERR , "子元素非法。" } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "不能调用元素“{0}”" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "不能调用属性“{0}”" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "文本数据在顶级 <xsl:stylesheet> 元素外。" } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "JAXP 解析器没有正确配置" } , { ErrorMsg . INTERNAL_ERR , "不可恢复的 XSLTC 内部错误：“{0}”" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "不受支持的 XSL 元素“{0}”。" } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "未被识别的 XSLTC 扩展名“{0}”。" } , { ErrorMsg . MISSING_XSLT_URI_ERR , "输入文档不是样式表（XSL 名称空间没有在根元素中说明）。" } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "找不到样式表目标“{0}”。" } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "没有实现：“{0}”。" } , { ErrorMsg . NOT_STYLESHEET_ERR , "输入文档不包含 XSL 样式表。" } , { ErrorMsg . ELEMENT_PARSE_ERR , "无法分析元素“{0}”" } , { ErrorMsg . KEY_USE_ATTR_ERR , "<key> 的 use 属性必须是 node、node-set、string 或 number。" } , { ErrorMsg . OUTPUT_VERSION_ERR , "输出 XML 文档的版本应当是 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "关系表达式的运算符未知" } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "试图使用不存在的属性集“{0}”。" } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "无法分析属性值模板“{0}”。" } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "类“{0}”的签名中的数据类型未知。" } , { ErrorMsg . DATA_CONVERSION_ERR , "无法将数据类型“{0}”转换成“{1}”。" } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "此 Templates 不包含有效的 translet 类定义。" } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "此 Templates 不包含名为“{0}”的类。" } , { ErrorMsg . TRANSLET_CLASS_ERR , "无法装入 translet 类“{0}”。" } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Translet 类已装入，但无法创建 translet 实例。" } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "试图将“{0}”的 ErrorListener 设置为 null" } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "XSLTC 只支持 StreamSource、SAXSource 和 DOMSource" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "传递给“{0}”的 Source 对象没有内容。" } , { ErrorMsg . JAXP_COMPILE_ERR , "无法编译样式表" } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory 无法识别属性“{0}”。" } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() 必须在 startDocument() 之前调用。" } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformer 没有封装的 translet 对象。" } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "没有为转换结果定义输出处理程序。" } , { ErrorMsg . JAXP_NO_RESULT_ERR , "传递给“{0}”的 Result 对象无效。" } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "试图访问无效的 Transformer 属性“{0}”。" } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "无法创建 SAX2DOM 适配器：“{0}”。" } , { ErrorMsg . XSLTC_SOURCE_ERR , "没有设置 systemId 就调用 XSLTCSource.build()。" } , { ErrorMsg . COMPILE_STDIN_ERR , "-i 选项必须与 -o 选项一起使用。" } , { ErrorMsg . COMPILE_USAGE_STR , "SYNOPSIS\n java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]\n [-d <directory>] [-j <jarfile>] [-p <package>]\n [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }\n\n OPTIONS\n -o <output>    将名称 <output> 指定给生成的 translet。\n缺省情况下，translet 名称\n 来自 <stylesheet> 的名称。\n 如果编译多个样式表，则忽略此选项。\n-d <directory> 指定 translet 的目标目录\n -j <jarfile>   将 translet 类封装成命名为 <jarfile>\n 的 jar 文件\n -p <package>   为所有生成的 translet 类\n指定软件包名称前缀。\n-n             启用模板内嵌（平均缺省\n行为更佳）。\n-x             打开额外的调试消息输出\n -s             禁止调用 System.exit\n -u             将 <stylesheet> 自变量解释为 URL\n -i             强制编译器从 stdin 读入样式表\n -v             打印编译器的版本\n -h             打印此用法语句\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SYNOPSIS \n java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]\n [-x] [-s] [-n <iterations>] {-u <document_url> | <document>}\n <class> [<param1>=<value1> ...]\n\n 使用 translet <class> 来转换指定为 <document> 的\nXML 文档。translet <class> 要么在\n 用户的 CLASSPATH 中，要么在任意指定的 <jarfile> 中。\n选项\n -j <jarfile>    指定装入 translet 的 jarfile\n -x              打开附加的调试消息输出\n -s              禁止调用 System.exit\n -n <iterations> 运行转换过程 <iterations> 次并\n 显示概要分析信息\n -u <document_url> 将 XML 输入文档指定为 URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> 只能在 <xsl:for-each> 或 <xsl:apply-templates> 中使用。" } , { ErrorMsg . UNSUPPORTED_ENCODING , "此 JVM 不支持输出编码“{0}”。" } , { ErrorMsg . SYNTAX_ERR , "“{0}”中的语法错误。" } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "找不到外部构造函数“{0}”。" } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "非 static Java 函数“{0}”的第一个自变量不是有效的对象参考。" } , { ErrorMsg . TYPE_CHECK_ERR , "检查表达式“{0}”的类型时出错。" } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "检查未知位置的表达式类型时出错。" } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "命令行选项“{0}”无效。" } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "命令行选项“{0}”缺少必需的自变量。" } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "警告：“{0}”\n       ：{1}" } , { ErrorMsg . WARNING_MSG , "警告：“{0}”" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "致命错误：“{0}”\n           ：{1}" } , { ErrorMsg . FATAL_ERR_MSG , "致命错误：“{0}”" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "错误：“{0}”\n     ：{1}" } , { ErrorMsg . ERROR_MSG , "错误：“{0}”" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "使用 translet“{0}”转换" } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "使用 translet“{0}”从 jar 文件“{1}”转换" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "无法创建 TransformerFactory 类“{0}”的实例。" } , { ErrorMsg . COMPILER_ERROR_KEY , "编译器错误：" } , { ErrorMsg . COMPILER_WARNING_KEY , "编译器警告：" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Translet 错误：" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_pl extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "W jednym pliku zdefiniowano więcej niż jeden arkusz stylów." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "Szablon ''{0}'' został już zdefiniowany w tym arkuszu stylów." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "Szablon ''{0}'' nie został zdefiniowany w tym arkuszu stylów." } , { ErrorMsg . VARIABLE_REDEF_ERR , "Zmienna ''{0}'' została wielokrotnie zdefiniowana w tym samym zasięgu." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "Niezdefiniowana zmienna lub niezdefiniowany parametr ''{0}''." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "Nie można znaleźć klasy ''{0}''." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "Nie można znaleźć metody zewnętrznej ''{0}'' (musi być publiczna)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Nie można przekształcić typu argumentu/zwracanej wartości w wywołaniu metody ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "Nie znaleziono pliku lub identyfikatora URI ''{0}''." } , { ErrorMsg . INVALID_URI_ERR , "Niepoprawny identyfikator URI ''{0}''." } , { ErrorMsg . FILE_ACCESS_ERR , "Nie można otworzyć pliku lub identyfikatora URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "Oczekiwano elementu <xsl:stylesheet> lub <xsl:transform>." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Niezadeklarowany przedrostek przestrzeni nazw ''{0}''." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Nie można znaleźć wywołania funkcji ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "Argument ''{0}'' musi być stałym ciągiem znaków (literałem)." } , { ErrorMsg . XPATH_PARSER_ERR , "Błąd podczas analizy wyrażenia XPath ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Wymagany atrybut ''{0}'' jest nieobecny." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Niedozwolony znak ''{0}'' w wyrażeniu XPath." } , { ErrorMsg . ILLEGAL_PI_ERR , "Niedozwolona nazwa ''{0}'' instrukcji przetwarzania." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "Atrybut ''{0}'' poza elementem." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Niedozwolony atrybut ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Cykliczny import/include. Arkusz stylów ''{0}'' został już załadowany." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Nie można posortować drzewa rezultatów (elementy <xsl:sort> są ignorowane). Trzeba posortować węzły podczas tworzenia drzewa rezultatów." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Formatowanie dziesiętne ''{0}'' zostało już zdefiniowane." } , { ErrorMsg . XSL_VERSION_ERR , "Wersja ''{0}'' XSL nie jest obsługiwana przez XSLTC." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Cykliczne odwołanie do zmiennej/parametru w ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Nieznany operator wyrażenia dwuargumentowego." } , { ErrorMsg . ILLEGAL_ARG_ERR , "Niedozwolone argumenty w wywołaniu funkcji." } , { ErrorMsg . DOCUMENT_ARG_ERR , "Drugim argumentem funkcji document() musi być zbiór węzłów." } , { ErrorMsg . MISSING_WHEN_ERR , "W <xsl:choose> wymagany jest przynajmniej jeden element <xsl:when>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "W <xsl:choose> dozwolony jest tylko jeden element <xsl:otherwise>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "Elementu <xsl:otherwise> można użyć tylko wewnątrz <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "Elementu <xsl:when> można użyć tylko wewnątrz <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "Tylko elementy <xsl:when> i <xsl:otherwise> są dozwolone w <xsl:choose>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set> nie ma atrybutu 'name'." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Niedozwolony element potomny." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "Nie można wywołać elementu ''{0}''" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "Nie można wywołać atrybutu ''{0}''" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Dane tekstowe poza elementami <xsl:stylesheet> najwyższego poziomu." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "Analizator składni JAXP nie został poprawnie skonfigurowany." } , { ErrorMsg . INTERNAL_ERR , "Nienaprawialny błąd wewnętrzny XSLTC: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Nieobsługiwany element XSL ''{0}''." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "Nierozpoznane rozszerzenie XSLTC ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "Dokument wejściowy nie jest arkuszem stylów (przestrzeń nazw XSL nie została zadeklarowana w elemencie głównym)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Nie można znaleźć docelowego arkusza stylów ''{0}''." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Niezaimplementowane: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "Dokument wejściowy nie zawiera arkusza stylów XSL." } , { ErrorMsg . ELEMENT_PARSE_ERR , "Nie można zanalizować elementu ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "Wartością atrybutu use elementu <key> musi być: node, node-set, string lub number." } , { ErrorMsg . OUTPUT_VERSION_ERR , "Wyjściowy dokument XML powinien mieć wersję 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Nieznany operator wyrażenia relacyjnego" } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Próba użycia nieistniejącego zbioru atrybutów''{0}''." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Nie można zanalizować szablonu wartości atrybutu ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Nieznany typ danych w podpisie klasy ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "Nie można przekształcić typu danych ''{0}'' w ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Klasa Templates nie zawiera poprawnej definicji klasy transletu." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Klasa Templates nie zawiera klasy o nazwie ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Nie można załadować klasy transletu o nazwie ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Załadowano klasę transletu, ale nie można utworzyć jego instancji." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "Próba ustawienia interfejsu ErrorListener obiektu ''{0}'' na wartość null" } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "Tylko StreamSource, SAXSource i DOMSource są obsługiwane przez XSLTC" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "Obiekt klasy Source przekazany do ''{0}'' nie ma zawartości." } , { ErrorMsg . JAXP_COMPILE_ERR , "Nie można skompilować arkusza stylów." } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "Klasa TransformerFactory nie rozpoznaje atrybutu ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "Przed wywołaniem metody startDocument() należy wywołać metodę setResult()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Obiekt Transformer nie zawiera referencji do obiektu transletu." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "Nie zdefiniowano procedury obsługi wyjścia rezultatów transformacji." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "Obiekt Result przekazany do metody ''{0}'' jest niepoprawny." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Próba dostępu do niepoprawnej właściwości obiektu Transformer ''{0}''." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Nie można utworzyć adaptera SAX2DOM: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "Metoda XSLTCSource.build() została wywołana bez ustawienia wartości systemId." } , { ErrorMsg . COMPILE_STDIN_ERR , "Z opcją -o trzeba użyć także opcji -i." } , { ErrorMsg . COMPILE_USAGE_STR , "SKŁADNIA\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <wyjście>]\n      [-d <katalog>] [-j <plik_jar>] [-p <pakiet>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <arkusz_stylów> | -i }\n\nOPCJE\n   -o <wyjście>    przydzielenie nazwy <wyjście> do wygenerowanego\n                  transletu. Domyślnie nazwa transletu\n                  jest brana z nazwy <arkusza_stylów>. Opcja ta\n                  jest ignorowana w przypadku kompilowania wielu arkuszy stylów.\n   -d <katalog> określa katalog docelowy transletu\n   -j <plik_jar>   pakowanie klas transletu do pliku jar o nazwie\n                  określonej jako <plik_jar>\n   -p <pakiet>    określenie przedrostka nazwy pakietu dla wszystkich wygenerowanych\n                  klas transletów.\n   -n             włączenie wstawiania szablonów (zachowanie domyślne\n                  zwykle lepsze).\n   -x             włączenie dodatkowych wyjściowych komunikatów diagnostycznych\n   -s             wyłączenie wywoływania System.exit\n   -u             interpretowanie argumentów <arkusz_stylów> jako adresów URL\n   -i             wymuszenie odczytywania arkuszy stylów ze stdin\n   -v             prints the version of the compiler\n   -h             wyświetlenie informacji o składni\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SKŁADNIA \n   java org.apache.xalan.xsltc.cmdline.Transform [-j <plik_jar>]\n      [-x] [-s] [-n <iteracje>] {-u <adres_url_dokumentu> | <dokument>}\n      <klasa> [<param1>=<wartość1> ...]\n\n   użycie <klasy> transletu do transformacji dokumentu \n   XML podanego jako <dokument>. <klasa> transletu znajduje się w\n   ścieżce CLASSPATH użytkownika lub w opcjonalnie podanym pliku <plik_jar>.\nOPCJE\n   -j <plik_jar>    określenie pliku jar, z którego ładowany będzie translet\n   -x              włączenie dodatkowych wyjściowych komunikatów diagnostycznych\n   -s              wyłączenie wywołania System.exit\n   -n <iteracje> wykonanie transformacji <iteracje> liczbę razy\n                   wyświetlenie informacji o profilowaniu\n   -u <adres_url_dokumentu> określenie wejściowego dokumentu XML jako adresu URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "Elementu <xsl:sort> można użyć tylko wewnątrz <xsl:for-each> lub <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "Kodowanie wyjściowe ''{0}'' nie jest obsługiwane przez tę maszynę wirtualną języka Java." } , { ErrorMsg . SYNTAX_ERR , "Błąd składniowy w ''{0}''." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "Nie można znaleźć zewnętrznego konstruktora ''{0}''." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "Pierwszy argument niestatycznej funkcji języka Java ''{0}'' nie jest poprawną referencją obiektu." } , { ErrorMsg . TYPE_CHECK_ERR , "Błąd podczas sprawdzania typu wyrażenia ''{0}''." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Błąd podczas sprawdzania wyrażenia w nieznanym położeniu." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "Niepoprawna opcja wiersza komend ''{0}''." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "W opcji wiersza komend ''{0}'' brakuje wymaganego argumentu." } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "OSTRZEŻENIE:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "OSTRZEŻENIE:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "BŁĄD KRYTYCZNY:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "BŁĄD KRYTYCZNY:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "BŁĄD:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "BŁĄD:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Transform używa transletu ''{0}'' " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Transform używa transletu ''{0}'' z pliku jar ''{1}''" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "Nie można utworzyć instancji klasy TransformerFactory ''{0}''." } , { ErrorMsg . COMPILER_ERROR_KEY , "Błędy kompilatora:" } , { ErrorMsg . COMPILER_WARNING_KEY , "Ostrzeżenia kompilatora:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Błędy transletu:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . * ; import javax . xml . transform . Source ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public abstract class DTMDefaultBaseIterators extends DTMDefaultBaseTraversers { public DTMDefaultBaseIterators ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing ) ; } public DTMDefaultBaseIterators ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib , boolean newNameTable ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , usePrevsib , newNameTable ) ; } public DTMAxisIterator getTypedAxisIterator ( int axis , int type ) { DTMAxisIterator iterator = null ; { switch ( axis ) { case Axis . SELF : iterator = new TypedSingletonIterator ( type ) ; break ; case Axis . CHILD : iterator = new TypedChildrenIterator ( type ) ; break ; case Axis . PARENT : return ( new ParentIterator ( ) . setNodeType ( type ) ) ; case Axis . ANCESTOR : return ( new TypedAncestorIterator ( type ) ) ; case Axis . ANCESTORORSELF : return ( ( new TypedAncestorIterator ( type ) ) . includeSelf ( ) ) ; case Axis . ATTRIBUTE : return ( new TypedAttributeIterator ( type ) ) ; case Axis . DESCENDANT : iterator = new TypedDescendantIterator ( type ) ; break ; case Axis . DESCENDANTORSELF : iterator = ( new TypedDescendantIterator ( type ) ) . includeSelf ( ) ; break ; case Axis . FOLLOWING : iterator = new TypedFollowingIterator ( type ) ; break ; case Axis . PRECEDING : iterator = new TypedPrecedingIterator ( type ) ; break ; case Axis . FOLLOWINGSIBLING : iterator = new TypedFollowingSiblingIterator ( type ) ; break ; case Axis . PRECEDINGSIBLING : iterator = new TypedPrecedingSiblingIterator ( type ) ; break ; case Axis . NAMESPACE : iterator = new TypedNamespaceIterator ( type ) ; break ; case Axis . ROOT : iterator = new TypedRootIterator ( type ) ; break ; default : throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , new Object [ ] { Axis . names [ axis ] } ) ) ; } } return ( iterator ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { DTMAxisIterator iterator = null ; switch ( axis ) { case Axis . SELF : iterator = new SingletonIterator ( ) ; break ; case Axis . CHILD : iterator = new ChildrenIterator ( ) ; break ; case Axis . PARENT : return ( new ParentIterator ( ) ) ; case Axis . ANCESTOR : return ( new AncestorIterator ( ) ) ; case Axis . ANCESTORORSELF : return ( ( new AncestorIterator ( ) ) . includeSelf ( ) ) ; case Axis . ATTRIBUTE : return ( new AttributeIterator ( ) ) ; case Axis . DESCENDANT : iterator = new DescendantIterator ( ) ; break ; case Axis . DESCENDANTORSELF : iterator = ( new DescendantIterator ( ) ) . includeSelf ( ) ; break ; case Axis . FOLLOWING : iterator = new FollowingIterator ( ) ; break ; case Axis . PRECEDING : iterator = new PrecedingIterator ( ) ; break ; case Axis . FOLLOWINGSIBLING : iterator = new FollowingSiblingIterator ( ) ; break ; case Axis . PRECEDINGSIBLING : iterator = new PrecedingSiblingIterator ( ) ; break ; case Axis . NAMESPACE : iterator = new NamespaceIterator ( ) ; break ; case Axis . ROOT : iterator = new RootIterator ( ) ; break ; default : throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_AXIS_NOT_IMPLEMENTED , new Object [ ] { Axis . names [ axis ] } ) ) ; } return ( iterator ) ; } public abstract class InternalAxisIteratorBase extends DTMAxisIteratorBase { protected int _currentNode ; public void setMark ( ) { _markedNode = _currentNode ; } public void gotoMark ( ) { _currentNode = _markedNode ; } } public final class ChildrenIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : _firstch ( makeNodeIdentity ( node ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode != NULL ) { int node = _currentNode ; _currentNode = _nextsib ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } return END ; } } public final class ParentIterator extends InternalAxisIteratorBase { private int _nodeType = - 1 ; public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getParent ( node ) ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator setNodeType ( final int type ) { _nodeType = type ; return this ; } public int next ( ) { int result = _currentNode ; if ( _nodeType >= DTM . NTYPES ) { if ( _nodeType != getExpandedTypeID ( _currentNode ) ) { result = END ; } } else if ( _nodeType != NULL ) { if ( _nodeType != getNodeType ( _currentNode ) ) { result = END ; } } _currentNode = END ; return returnNode ( result ) ; } } public final class TypedChildrenIterator extends InternalAxisIteratorBase { private final int _nodeType ; public TypedChildrenIterator ( int nodeType ) { _nodeType = nodeType ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : _firstch ( makeNodeIdentity ( _startNode ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int eType ; int node = _currentNode ; int nodeType = _nodeType ; if ( nodeType >= DTM . NTYPES ) { while ( node != DTM . NULL && _exptype ( node ) != nodeType ) { node = _nextsib ( node ) ; } } else { while ( node != DTM . NULL ) { eType = _exptype ( node ) ; if ( eType < DTM . NTYPES ) { if ( eType == nodeType ) { break ; } } else if ( m_expandedNameTable . getType ( eType ) == nodeType ) { break ; } node = _nextsib ( node ) ; } } if ( node == DTM . NULL ) { _currentNode = DTM . NULL ; return DTM . NULL ; } else { _currentNode = _nextsib ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } } public final class NamespaceChildrenIterator extends InternalAxisIteratorBase { private final int _nsType ; public NamespaceChildrenIterator ( final int type ) { _nsType = type ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : NOTPROCESSED ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode != DTM . NULL ) { for ( int node = ( NOTPROCESSED == _currentNode ) ? _firstch ( makeNodeIdentity ( _startNode ) ) : _nextsib ( _currentNode ) ; node != END ; node = _nextsib ( node ) ) { if ( m_expandedNameTable . getNamespaceID ( _exptype ( node ) ) == _nsType ) { _currentNode = node ; return returnNode ( node ) ; } } } return END ; } } public class NamespaceIterator extends InternalAxisIteratorBase { public NamespaceIterator ( ) { super ( ) ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getFirstNamespaceNode ( node , true ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; if ( DTM . NULL != node ) _currentNode = getNextNamespaceNode ( _startNode , node , true ) ; return returnNode ( node ) ; } } public class TypedNamespaceIterator extends NamespaceIterator { private final int _nodeType ; public TypedNamespaceIterator ( int nodeType ) { super ( ) ; _nodeType = nodeType ; } public int next ( ) { int node ; for ( node = _currentNode ; node != END ; node = getNextNamespaceNode ( _startNode , node , true ) ) { if ( getExpandedTypeID ( node ) == _nodeType || getNodeType ( node ) == _nodeType || getNamespaceType ( node ) == _nodeType ) { _currentNode = node ; return returnNode ( node ) ; } } return ( _currentNode = END ) ; } } public class RootIterator extends InternalAxisIteratorBase { public RootIterator ( ) { super ( ) ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = getDocumentRoot ( node ) ; _currentNode = NULL ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _startNode == _currentNode ) return NULL ; _currentNode = _startNode ; return returnNode ( _startNode ) ; } } public class TypedRootIterator extends RootIterator { private final int _nodeType ; public TypedRootIterator ( int nodeType ) { super ( ) ; _nodeType = nodeType ; } public int next ( ) { if ( _startNode == _currentNode ) return NULL ; int nodeType = _nodeType ; int node = _startNode ; int expType = getExpandedTypeID ( node ) ; _currentNode = node ; if ( nodeType >= DTM . NTYPES ) { if ( nodeType == expType ) { return returnNode ( node ) ; } } else { if ( expType < DTM . NTYPES ) { if ( expType == nodeType ) { return returnNode ( node ) ; } } else { if ( m_expandedNameTable . getType ( expType ) == nodeType ) { return returnNode ( node ) ; } } } return END ; } } public final class NamespaceAttributeIterator extends InternalAxisIteratorBase { private final int _nsType ; public NamespaceAttributeIterator ( int nsType ) { super ( ) ; _nsType = nsType ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getFirstNamespaceNode ( node , false ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; if ( DTM . NULL != node ) _currentNode = getNextNamespaceNode ( _startNode , node , false ) ; return returnNode ( node ) ; } } public class FollowingSiblingIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = makeNodeIdentity ( node ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { _currentNode = ( _currentNode == DTM . NULL ) ? DTM . NULL : _nextsib ( _currentNode ) ; return returnNode ( makeNodeHandle ( _currentNode ) ) ; } } public final class TypedFollowingSiblingIterator extends FollowingSiblingIterator { private final int _nodeType ; public TypedFollowingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { if ( _currentNode == DTM . NULL ) { return DTM . NULL ; } int node = _currentNode ; int eType ; int nodeType = _nodeType ; if ( nodeType >= DTM . NTYPES ) { do { node = _nextsib ( node ) ; } while ( node != DTM . NULL && _exptype ( node ) != nodeType ) ; } else { while ( ( node = _nextsib ( node ) ) != DTM . NULL ) { eType = _exptype ( node ) ; if ( eType < DTM . NTYPES ) { if ( eType == nodeType ) { break ; } } else if ( m_expandedNameTable . getType ( eType ) == nodeType ) { break ; } } } _currentNode = node ; return ( _currentNode == DTM . NULL ) ? DTM . NULL : returnNode ( makeNodeHandle ( _currentNode ) ) ; } } public final class AttributeIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getFirstAttributeIdentity ( makeNodeIdentity ( node ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _currentNode ; if ( node != NULL ) { _currentNode = getNextAttributeIdentity ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } return NULL ; } } public final class TypedAttributeIterator extends InternalAxisIteratorBase { private final int _nodeType ; public TypedAttributeIterator ( int nodeType ) { _nodeType = nodeType ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = node ; _currentNode = getTypedAttribute ( node , _nodeType ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _currentNode ; _currentNode = NULL ; return returnNode ( node ) ; } } public class PrecedingSiblingIterator extends InternalAxisIteratorBase { protected int _startNodeID ; public boolean isReverse ( ) { return true ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; node = _startNodeID = makeNodeIdentity ( node ) ; if ( node == NULL ) { _currentNode = node ; return resetPosition ( ) ; } int type = m_expandedNameTable . getType ( _exptype ( node ) ) ; if ( ExpandedNameTable . ATTRIBUTE == type || ExpandedNameTable . NAMESPACE == type ) { _currentNode = node ; } else { _currentNode = _parent ( node ) ; if ( NULL != _currentNode ) _currentNode = _firstch ( _currentNode ) ; else _currentNode = node ; } return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode == _startNodeID || _currentNode == DTM . NULL ) { return NULL ; } else { final int node = _currentNode ; _currentNode = _nextsib ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } } public final class TypedPrecedingSiblingIterator extends PrecedingSiblingIterator { private final int _nodeType ; public TypedPrecedingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node = _currentNode ; int expType ; int nodeType = _nodeType ; int startID = _startNodeID ; if ( nodeType >= DTM . NTYPES ) { while ( node != NULL && node != startID && _exptype ( node ) != nodeType ) { node = _nextsib ( node ) ; } } else { while ( node != NULL && node != startID ) { expType = _exptype ( node ) ; if ( expType < DTM . NTYPES ) { if ( expType == nodeType ) { break ; } } else { if ( m_expandedNameTable . getType ( expType ) == nodeType ) { break ; } } node = _nextsib ( node ) ; } } if ( node == DTM . NULL || node == _startNodeID ) { _currentNode = NULL ; return NULL ; } else { _currentNode = _nextsib ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } } public class PrecedingIterator extends InternalAxisIteratorBase { private final int _maxAncestors = 8 ; protected int [ ] _stack = new int [ _maxAncestors ] ; protected int _sp , _oldsp ; protected int _markedsp , _markedNode , _markedDescendant ; public boolean isReverse ( ) { return true ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final PrecedingIterator clone = ( PrecedingIterator ) super . clone ( ) ; final int [ ] stackCopy = new int [ _stack . length ] ; System . arraycopy ( _stack , 0 , stackCopy , 0 , _stack . length ) ; clone . _stack = stackCopy ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { node = makeNodeIdentity ( node ) ; int parent , index ; if ( _type ( node ) == DTM . ATTRIBUTE_NODE ) node = _parent ( node ) ; _startNode = node ; _stack [ index = 0 ] = node ; parent = node ; while ( ( parent = _parent ( parent ) ) != NULL ) { if ( ++ index == _stack . length ) { final int [ ] stack = new int [ index + 4 ] ; System . arraycopy ( _stack , 0 , stack , 0 , index ) ; _stack = stack ; } _stack [ index ] = parent ; } if ( index > 0 ) -- index ; _currentNode = _stack [ index ] ; _oldsp = _sp = index ; return resetPosition ( ) ; } return this ; } public int next ( ) { for ( ++ _currentNode ; _sp >= 0 ; ++ _currentNode ) { if ( _currentNode < _stack [ _sp ] ) { if ( _type ( _currentNode ) != ATTRIBUTE_NODE && _type ( _currentNode ) != NAMESPACE_NODE ) return returnNode ( makeNodeHandle ( _currentNode ) ) ; } else -- _sp ; } return NULL ; } public DTMAxisIterator reset ( ) { _sp = _oldsp ; return resetPosition ( ) ; } public void setMark ( ) { _markedsp = _sp ; _markedNode = _currentNode ; _markedDescendant = _stack [ 0 ] ; } public void gotoMark ( ) { _sp = _markedsp ; _currentNode = _markedNode ; } } public final class TypedPrecedingIterator extends PrecedingIterator { private final int _nodeType ; public TypedPrecedingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node = _currentNode ; int nodeType = _nodeType ; if ( nodeType >= DTM . NTYPES ) { while ( true ) { node = node + 1 ; if ( _sp < 0 ) { node = NULL ; break ; } else if ( node >= _stack [ _sp ] ) { if ( -- _sp < 0 ) { node = NULL ; break ; } } else if ( _exptype ( node ) == nodeType ) { break ; } } } else { int expType ; while ( true ) { node = node + 1 ; if ( _sp < 0 ) { node = NULL ; break ; } else if ( node >= _stack [ _sp ] ) { if ( -- _sp < 0 ) { node = NULL ; break ; } } else { expType = _exptype ( node ) ; if ( expType < DTM . NTYPES ) { if ( expType == nodeType ) { break ; } } else { if ( m_expandedNameTable . getType ( expType ) == nodeType ) { break ; } } } } } _currentNode = node ; return ( node == NULL ) ? NULL : returnNode ( makeNodeHandle ( node ) ) ; } } public class FollowingIterator extends InternalAxisIteratorBase { DTMAxisTraverser m_traverser ; public FollowingIterator ( ) { m_traverser = getAxisTraverser ( Axis . FOLLOWING ) ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = m_traverser . first ( node ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; _currentNode = m_traverser . next ( _startNode , _currentNode ) ; return returnNode ( node ) ; } } public final class TypedFollowingIterator extends FollowingIterator { private final int _nodeType ; public TypedFollowingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node ; do { node = _currentNode ; _currentNode = m_traverser . next ( _startNode , _currentNode ) ; } while ( node != DTM . NULL && ( getExpandedTypeID ( node ) != _nodeType && getNodeType ( node ) != _nodeType ) ) ; return ( node == DTM . NULL ? DTM . NULL : returnNode ( node ) ) ; } } public class AncestorIterator extends InternalAxisIteratorBase { org . apache . xml . utils . NodeVector m_ancestors = new org . apache . xml . utils . NodeVector ( ) ; int m_ancestorsPos ; int m_markedPos ; int m_realStartNode ; public int getStartNode ( ) { return m_realStartNode ; } public final boolean isReverse ( ) { return true ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final AncestorIterator clone = ( AncestorIterator ) super . clone ( ) ; clone . _startNode = _startNode ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; m_realStartNode = node ; if ( _isRestartable ) { int nodeID = makeNodeIdentity ( node ) ; if ( ! _includeSelf && node != DTM . NULL ) { nodeID = _parent ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } _startNode = node ; while ( nodeID != END ) { m_ancestors . addElement ( node ) ; nodeID = _parent ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } m_ancestorsPos = m_ancestors . size ( ) - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { m_ancestorsPos = m_ancestors . size ( ) - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; return resetPosition ( ) ; } public int next ( ) { int next = _currentNode ; int pos = -- m_ancestorsPos ; _currentNode = ( pos >= 0 ) ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; return returnNode ( next ) ; } public void setMark ( ) { m_markedPos = m_ancestorsPos ; } public void gotoMark ( ) { m_ancestorsPos = m_markedPos ; _currentNode = m_ancestorsPos >= 0 ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; } } public final class TypedAncestorIterator extends AncestorIterator { private final int _nodeType ; public TypedAncestorIterator ( int type ) { _nodeType = type ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; m_realStartNode = node ; if ( _isRestartable ) { int nodeID = makeNodeIdentity ( node ) ; int nodeType = _nodeType ; if ( ! _includeSelf && node != DTM . NULL ) { nodeID = _parent ( nodeID ) ; } _startNode = node ; if ( nodeType >= DTM . NTYPES ) { while ( nodeID != END ) { int eType = _exptype ( nodeID ) ; if ( eType == nodeType ) { m_ancestors . addElement ( makeNodeHandle ( nodeID ) ) ; } nodeID = _parent ( nodeID ) ; } } else { while ( nodeID != END ) { int eType = _exptype ( nodeID ) ; if ( ( eType >= DTM . NTYPES && m_expandedNameTable . getType ( eType ) == nodeType ) || ( eType < DTM . NTYPES && eType == nodeType ) ) { m_ancestors . addElement ( makeNodeHandle ( nodeID ) ) ; } nodeID = _parent ( nodeID ) ; } } m_ancestorsPos = m_ancestors . size ( ) - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors . elementAt ( m_ancestorsPos ) : DTM . NULL ; return resetPosition ( ) ; } return this ; } } public class DescendantIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { node = makeNodeIdentity ( node ) ; _startNode = node ; if ( _includeSelf ) node -- ; _currentNode = node ; return resetPosition ( ) ; } return this ; } protected boolean isDescendant ( int identity ) { return ( _parent ( identity ) >= _startNode ) || ( _startNode == identity ) ; } public int next ( ) { if ( _startNode == NULL ) { return NULL ; } if ( _includeSelf && ( _currentNode + 1 ) == _startNode ) return returnNode ( makeNodeHandle ( ++ _currentNode ) ) ; int node = _currentNode ; int type ; do { node ++ ; type = _type ( node ) ; if ( NULL == type || ! isDescendant ( node ) ) { _currentNode = NULL ; return END ; } } while ( ATTRIBUTE_NODE == type || TEXT_NODE == type || NAMESPACE_NODE == type ) ; _currentNode = node ; return returnNode ( makeNodeHandle ( node ) ) ; } public DTMAxisIterator reset ( ) { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( makeNodeHandle ( _startNode ) ) ; _isRestartable = temp ; return this ; } } public final class TypedDescendantIterator extends DescendantIterator { private final int _nodeType ; public TypedDescendantIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { int node ; int type ; if ( _startNode == NULL ) { return NULL ; } node = _currentNode ; do { node ++ ; type = _type ( node ) ; if ( NULL == type || ! isDescendant ( node ) ) { _currentNode = NULL ; return END ; } } while ( type != _nodeType && _exptype ( node ) != _nodeType ) ; _currentNode = node ; return returnNode ( makeNodeHandle ( node ) ) ; } } public class NthDescendantIterator extends DescendantIterator { int _pos ; public NthDescendantIterator ( int pos ) { _pos = pos ; } public int next ( ) { int node ; while ( ( node = super . next ( ) ) != END ) { node = makeNodeIdentity ( node ) ; int parent = _parent ( node ) ; int child = _firstch ( parent ) ; int pos = 0 ; do { int type = _type ( child ) ; if ( ELEMENT_NODE == type ) pos ++ ; } while ( ( pos < _pos ) && ( child = _nextsib ( child ) ) != END ) ; if ( node == child ) return node ; } return ( END ) ; } } public class SingletonIterator extends InternalAxisIteratorBase { private boolean _isConstant ; public SingletonIterator ( ) { this ( Integer . MIN_VALUE , false ) ; } public SingletonIterator ( int node ) { this ( node , false ) ; } public SingletonIterator ( int node , boolean constant ) { _currentNode = _startNode = node ; _isConstant = constant ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isConstant ) { _currentNode = _startNode ; return resetPosition ( ) ; } else if ( _isRestartable ) { if ( _currentNode == Integer . MIN_VALUE ) { _currentNode = _startNode = node ; } return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { if ( _isConstant ) { _currentNode = _startNode ; return resetPosition ( ) ; } else { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( _startNode ) ; _isRestartable = temp ; } return this ; } public int next ( ) { final int result = _currentNode ; _currentNode = END ; return returnNode ( result ) ; } } public final class TypedSingletonIterator extends SingletonIterator { private final int _nodeType ; public TypedSingletonIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { final int result = _currentNode ; int nodeType = _nodeType ; _currentNode = END ; if ( nodeType >= DTM . NTYPES ) { if ( getExpandedTypeID ( result ) == nodeType ) { return returnNode ( result ) ; } } else { if ( getNodeType ( result ) == nodeType ) { return returnNode ( result ) ; } } return NULL ; } } } 	1	['4', '3', '3', '57', '36', '6', '49', '31', '4', '2', '244', '0', '0', '0.978723404', '0.642857143', '0', '0', '60', '2', '1', '2']
package org . apache . xalan . processor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . AVT ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . StringToIntTable ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . XMLChar ; import org . apache . xpath . XPath ; public class XSLTAttributeDef { static final int FATAL = 0 ; static final int ERROR = 1 ; static final int WARNING = 2 ; XSLTAttributeDef ( String namespace , String name , int type , boolean required , boolean supportsAVT , int errorType ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = type ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; } XSLTAttributeDef ( String namespace , String name , int type , boolean supportsAVT , int errorType , String defaultVal ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = type ; this . m_required = false ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; this . m_default = defaultVal ; } XSLTAttributeDef ( String namespace , String name , boolean required , boolean supportsAVT , boolean prefixedQNameValAllowed , int errorType , String k1 , int v1 , String k2 , int v2 ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = prefixedQNameValAllowed ? this . T_ENUM_OR_PQNAME : this . T_ENUM ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; m_enums = new StringToIntTable ( 2 ) ; m_enums . put ( k1 , v1 ) ; m_enums . put ( k2 , v2 ) ; } XSLTAttributeDef ( String namespace , String name , boolean required , boolean supportsAVT , boolean prefixedQNameValAllowed , int errorType , String k1 , int v1 , String k2 , int v2 , String k3 , int v3 ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = prefixedQNameValAllowed ? this . T_ENUM_OR_PQNAME : this . T_ENUM ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; m_enums = new StringToIntTable ( 3 ) ; m_enums . put ( k1 , v1 ) ; m_enums . put ( k2 , v2 ) ; m_enums . put ( k3 , v3 ) ; } XSLTAttributeDef ( String namespace , String name , boolean required , boolean supportsAVT , boolean prefixedQNameValAllowed , int errorType , String k1 , int v1 , String k2 , int v2 , String k3 , int v3 , String k4 , int v4 ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = prefixedQNameValAllowed ? this . T_ENUM_OR_PQNAME : this . T_ENUM ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; m_enums = new StringToIntTable ( 4 ) ; m_enums . put ( k1 , v1 ) ; m_enums . put ( k2 , v2 ) ; m_enums . put ( k3 , v3 ) ; m_enums . put ( k4 , v4 ) ; } static final int T_CDATA = 1 , T_URL = 2 , T_AVT = 3 , T_PATTERN = 4 , T_EXPR = 5 , T_CHAR = 6 , T_NUMBER = 7 , T_YESNO = 8 , T_QNAME = 9 , T_QNAMES = 10 , T_ENUM = 11 , T_SIMPLEPATTERNLIST = 12 , T_NMTOKEN = 13 , T_STRINGLIST = 14 , T_PREFIX_URLLIST = 15 , T_ENUM_OR_PQNAME = 16 , T_NCNAME = 17 , T_AVT_QNAME = 18 , T_QNAMES_RESOLVE_NULL = 19 , T_PREFIXLIST = 20 ; static XSLTAttributeDef m_foreignAttr = new XSLTAttributeDef ( "*" , "*" , XSLTAttributeDef . T_CDATA , false , false , WARNING ) ; static String S_FOREIGNATTR_SETTER = "setForeignAttr" ; private String m_namespace ; String getNamespace ( ) { return m_namespace ; } private String m_name ; String getName ( ) { return m_name ; } private int m_type ; int getType ( ) { return m_type ; } private StringToIntTable m_enums ; private int getEnum ( String key ) { return m_enums . get ( key ) ; } private String [ ] getEnumNames ( ) { return m_enums . keys ( ) ; } private String m_default ; String getDefault ( ) { return m_default ; } void setDefault ( String def ) { m_default = def ; } private boolean m_required ; boolean getRequired ( ) { return m_required ; } private boolean m_supportsAVT ; boolean getSupportsAVT ( ) { return m_supportsAVT ; } int m_errorType = this . WARNING ; int getErrorType ( ) { return m_errorType ; } String m_setterString = null ; public String getSetterMethodName ( ) { if ( null == m_setterString ) { if ( m_foreignAttr == this ) { return S_FOREIGNATTR_SETTER ; } else if ( m_name . equals ( "*" ) ) { m_setterString = "addLiteralResultAttribute" ; return m_setterString ; } StringBuffer outBuf = new StringBuffer ( ) ; outBuf . append ( "set" ) ; if ( ( m_namespace != null ) && m_namespace . equals ( Constants . S_XMLNAMESPACEURI ) ) { outBuf . append ( "Xml" ) ; } int n = m_name . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char c = m_name . charAt ( i ) ; if ( '-' == c ) { i ++ ; c = m_name . charAt ( i ) ; c = Character . toUpperCase ( c ) ; } else if ( 0 == i ) { c = Character . toUpperCase ( c ) ; } outBuf . append ( c ) ; } m_setterString = outBuf . toString ( ) ; } return m_setterString ; } AVT processAVT ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } Object processCDATA ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { return value ; } } Object processCHAR ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ( avt . isSimple ( ) ) && ( value . length ( ) != 1 ) ) { handleError ( handler , XSLTErrorResources . INVALID_TCHAR , new Object [ ] { name , value } , null ) ; return null ; } return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { if ( value . length ( ) != 1 ) { handleError ( handler , XSLTErrorResources . INVALID_TCHAR , new Object [ ] { name , value } , null ) ; return null ; } return new Character ( value . charAt ( 0 ) ) ; } } Object processENUM ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { AVT avt = null ; if ( getSupportsAVT ( ) ) { try { avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ! avt . isSimple ( ) ) return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } int retVal = this . getEnum ( value ) ; if ( retVal == StringToIntTable . INVALID_KEY ) { StringBuffer enumNamesList = getListOfEnums ( ) ; handleError ( handler , XSLTErrorResources . INVALID_ENUM , new Object [ ] { name , value , enumNamesList . toString ( ) } , null ) ; return null ; } if ( getSupportsAVT ( ) ) return avt ; else return new Integer ( retVal ) ; } Object processENUM_OR_PQNAME ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { Object objToReturn = null ; if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ! avt . isSimple ( ) ) return avt ; else objToReturn = avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } int key = this . getEnum ( value ) ; if ( key != StringToIntTable . INVALID_KEY ) { if ( objToReturn == null ) objToReturn = new Integer ( key ) ; } else { try { QName qname = new QName ( value , handler , true ) ; if ( objToReturn == null ) objToReturn = qname ; if ( qname . getPrefix ( ) == null ) { StringBuffer enumNamesList = getListOfEnums ( ) ; enumNamesList . append ( " <qname-but-not-ncname>" ) ; handleError ( handler , XSLTErrorResources . INVALID_ENUM , new Object [ ] { name , value , enumNamesList . toString ( ) } , null ) ; return null ; } } catch ( IllegalArgumentException ie ) { StringBuffer enumNamesList = getListOfEnums ( ) ; enumNamesList . append ( " <qname-but-not-ncname>" ) ; handleError ( handler , XSLTErrorResources . INVALID_ENUM , new Object [ ] { name , value , enumNamesList . toString ( ) } , ie ) ; return null ; } catch ( RuntimeException re ) { StringBuffer enumNamesList = getListOfEnums ( ) ; enumNamesList . append ( " <qname-but-not-ncname>" ) ; handleError ( handler , XSLTErrorResources . INVALID_ENUM , new Object [ ] { name , value , enumNamesList . toString ( ) } , re ) ; return null ; } } return objToReturn ; } Object processEXPR ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { XPath expr = handler . createXPath ( value , owner ) ; return expr ; } catch ( TransformerException te ) { org . xml . sax . SAXException se = new org . xml . sax . SAXException ( te ) ; throw new org . xml . sax . SAXException ( te ) ; } } Object processNMTOKEN ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ( avt . isSimple ( ) ) && ( ! XMLChar . isValidNmtoken ( value ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_NMTOKEN , new Object [ ] { name , value } , null ) ; return null ; } return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { if ( ! XMLChar . isValidNmtoken ( value ) ) { handleError ( handler , XSLTErrorResources . INVALID_NMTOKEN , new Object [ ] { name , value } , null ) ; return null ; } } return value ; } Object processPATTERN ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { XPath pattern = handler . createMatchPatternXPath ( value , owner ) ; return pattern ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } Object processNUMBER ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { Double val ; AVT avt = null ; try { avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( avt . isSimple ( ) ) { val = Double . valueOf ( value ) ; } } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } catch ( NumberFormatException nfe ) { handleError ( handler , XSLTErrorResources . INVALID_NUMBER , new Object [ ] { name , value } , nfe ) ; return null ; } return avt ; } else { try { return Double . valueOf ( value ) ; } catch ( NumberFormatException nfe ) { handleError ( handler , XSLTErrorResources . INVALID_NUMBER , new Object [ ] { name , value } , nfe ) ; return null ; } } } Object processQNAME ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { QName qname = new QName ( value , handler , true ) ; return qname ; } catch ( IllegalArgumentException ie ) { handleError ( handler , XSLTErrorResources . INVALID_QNAME , new Object [ ] { name , value } , ie ) ; return null ; } catch ( RuntimeException re ) { handleError ( handler , XSLTErrorResources . INVALID_QNAME , new Object [ ] { name , value } , re ) ; return null ; } } Object processAVT_QNAME ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { AVT avt = null ; try { avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( avt . isSimple ( ) ) { int indexOfNSSep = value . indexOf ( ':' ) ; if ( indexOfNSSep >= 0 ) { String prefix = value . substring ( 0 , indexOfNSSep ) ; if ( ! XMLChar . isValidNCName ( prefix ) ) { handleError ( handler , XSLTErrorResources . INVALID_QNAME , new Object [ ] { name , value } , null ) ; return null ; } } String localName = ( indexOfNSSep < 0 ) ? value : value . substring ( indexOfNSSep + 1 ) ; if ( ( localName == null ) || ( localName . length ( ) == 0 ) || ( ! XMLChar . isValidNCName ( localName ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_QNAME , new Object [ ] { name , value } , null ) ; return null ; } } } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } return avt ; } Object processNCNAME ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { AVT avt = null ; try { avt = new AVT ( handler , uri , name , rawName , value , owner ) ; if ( ( avt . isSimple ( ) ) && ( ! XMLChar . isValidNCName ( value ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_NCNAME , new Object [ ] { name , value } , null ) ; return null ; } return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { if ( ! XMLChar . isValidNCName ( value ) ) { handleError ( handler , XSLTErrorResources . INVALID_NCNAME , new Object [ ] { name , value } , null ) ; return null ; } return value ; } } Vector processQNAMES ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nQNames = tokenizer . countTokens ( ) ; Vector qnames = new Vector ( nQNames ) ; for ( int i = 0 ; i < nQNames ; i ++ ) { qnames . addElement ( new QName ( tokenizer . nextToken ( ) , handler ) ) ; } return qnames ; } final Vector processQNAMESRNU ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nQNames = tokenizer . countTokens ( ) ; Vector qnames = new Vector ( nQNames ) ; String defaultURI = handler . getNamespaceForPrefix ( "" ) ; for ( int i = 0 ; i < nQNames ; i ++ ) { String tok = tokenizer . nextToken ( ) ; if ( tok . indexOf ( ':' ) == - 1 ) { qnames . addElement ( new QName ( defaultURI , tok ) ) ; } else { qnames . addElement ( new QName ( tok , handler ) ) ; } } return qnames ; } Vector processSIMPLEPATTERNLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nPatterns = tokenizer . countTokens ( ) ; Vector patterns = new Vector ( nPatterns ) ; for ( int i = 0 ; i < nPatterns ; i ++ ) { XPath pattern = handler . createMatchPatternXPath ( tokenizer . nextToken ( ) , owner ) ; patterns . addElement ( pattern ) ; } return patterns ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } StringVector processSTRINGLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value ) { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nStrings = tokenizer . countTokens ( ) ; StringVector strings = new StringVector ( nStrings ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { strings . addElement ( tokenizer . nextToken ( ) ) ; } return strings ; } StringVector processPREFIX_URLLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nStrings = tokenizer . countTokens ( ) ; StringVector strings = new StringVector ( nStrings ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { String prefix = tokenizer . nextToken ( ) ; String url = handler . getNamespaceForPrefix ( prefix ) ; if ( url != null ) strings . addElement ( url ) ; else throw new org . xml . sax . SAXException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANT_RESOLVE_NSPREFIX , new Object [ ] { prefix } ) ) ; } return strings ; } StringVector processPREFIX_LIST ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { StringTokenizer tokenizer = new StringTokenizer ( value , " \t\n\r\f" ) ; int nStrings = tokenizer . countTokens ( ) ; StringVector strings = new StringVector ( nStrings ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { String prefix = tokenizer . nextToken ( ) ; String url = handler . getNamespaceForPrefix ( prefix ) ; if ( prefix . equals ( Constants . ATTRVAL_DEFAULT_PREFIX ) || url != null ) strings . addElement ( prefix ) ; else throw new org . xml . sax . SAXException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANT_RESOLVE_NSPREFIX , new Object [ ] { prefix } ) ) ; } return strings ; } Object processURL ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { if ( getSupportsAVT ( ) ) { try { AVT avt = new AVT ( handler , uri , name , rawName , value , owner ) ; return avt ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else { return value ; } } private Boolean processYESNO ( StylesheetHandler handler , String uri , String name , String rawName , String value ) throws org . xml . sax . SAXException { if ( ! ( value . equals ( "yes" ) || value . equals ( "no" ) ) ) { handleError ( handler , XSLTErrorResources . INVALID_BOOLEAN , new Object [ ] { name , value } , null ) ; return null ; } return new Boolean ( value . equals ( "yes" ) ? true : false ) ; } Object processValue ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { int type = getType ( ) ; Object processedValue = null ; switch ( type ) { case T_AVT : processedValue = processAVT ( handler , uri , name , rawName , value , owner ) ; break ; case T_CDATA : processedValue = processCDATA ( handler , uri , name , rawName , value , owner ) ; break ; case T_CHAR : processedValue = processCHAR ( handler , uri , name , rawName , value , owner ) ; break ; case T_ENUM : processedValue = processENUM ( handler , uri , name , rawName , value , owner ) ; break ; case T_EXPR : processedValue = processEXPR ( handler , uri , name , rawName , value , owner ) ; break ; case T_NMTOKEN : processedValue = processNMTOKEN ( handler , uri , name , rawName , value , owner ) ; break ; case T_PATTERN : processedValue = processPATTERN ( handler , uri , name , rawName , value , owner ) ; break ; case T_NUMBER : processedValue = processNUMBER ( handler , uri , name , rawName , value , owner ) ; break ; case T_QNAME : processedValue = processQNAME ( handler , uri , name , rawName , value , owner ) ; break ; case T_QNAMES : processedValue = processQNAMES ( handler , uri , name , rawName , value ) ; break ; case T_QNAMES_RESOLVE_NULL : processedValue = processQNAMESRNU ( handler , uri , name , rawName , value ) ; break ; case T_SIMPLEPATTERNLIST : processedValue = processSIMPLEPATTERNLIST ( handler , uri , name , rawName , value , owner ) ; break ; case T_URL : processedValue = processURL ( handler , uri , name , rawName , value , owner ) ; break ; case T_YESNO : processedValue = processYESNO ( handler , uri , name , rawName , value ) ; break ; case T_STRINGLIST : processedValue = processSTRINGLIST ( handler , uri , name , rawName , value ) ; break ; case T_PREFIX_URLLIST : processedValue = processPREFIX_URLLIST ( handler , uri , name , rawName , value ) ; break ; case T_ENUM_OR_PQNAME : processedValue = processENUM_OR_PQNAME ( handler , uri , name , rawName , value , owner ) ; break ; case T_NCNAME : processedValue = processNCNAME ( handler , uri , name , rawName , value , owner ) ; break ; case T_AVT_QNAME : processedValue = processAVT_QNAME ( handler , uri , name , rawName , value , owner ) ; break ; case T_PREFIXLIST : processedValue = processPREFIX_LIST ( handler , uri , name , rawName , value ) ; break ; default : } return processedValue ; } void setDefAttrValue ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { setAttrValue ( handler , this . getNamespace ( ) , this . getName ( ) , this . getName ( ) , this . getDefault ( ) , elem ) ; } private Class getPrimativeClass ( Object obj ) { if ( obj instanceof XPath ) return XPath . class ; Class cl = obj . getClass ( ) ; if ( cl == Double . class ) { cl = double . class ; } if ( cl == Float . class ) { cl = float . class ; } else if ( cl == Boolean . class ) { cl = boolean . class ; } else if ( cl == Byte . class ) { cl = byte . class ; } else if ( cl == Character . class ) { cl = char . class ; } else if ( cl == Short . class ) { cl = short . class ; } else if ( cl == Integer . class ) { cl = int . class ; } else if ( cl == Long . class ) { cl = long . class ; } return cl ; } private StringBuffer getListOfEnums ( ) { StringBuffer enumNamesList = new StringBuffer ( ) ; String [ ] enumValues = this . getEnumNames ( ) ; for ( int i = 0 ; i < enumValues . length ; i ++ ) { if ( i > 0 ) { enumNamesList . append ( ' ' ) ; } enumNamesList . append ( enumValues [ i ] ) ; } return enumNamesList ; } boolean setAttrValue ( StylesheetHandler handler , String attrUri , String attrLocalName , String attrRawName , String attrValue , ElemTemplateElement elem ) throws org . xml . sax . SAXException { if ( attrRawName . equals ( "xmlns" ) || attrRawName . startsWith ( "xmlns:" ) ) return true ; String setterString = getSetterMethodName ( ) ; if ( null != setterString ) { try { Method meth ; Object [ ] args ; if ( setterString . equals ( S_FOREIGNATTR_SETTER ) ) { if ( attrUri == null ) attrUri = "" ; Class sclass = attrUri . getClass ( ) ; Class [ ] argTypes = new Class [ ] { sclass , sclass , sclass , sclass } ; meth = elem . getClass ( ) . getMethod ( setterString , argTypes ) ; args = new Object [ ] { attrUri , attrLocalName , attrRawName , attrValue } ; } else { Object value = processValue ( handler , attrUri , attrLocalName , attrRawName , attrValue , elem ) ; if ( null == value ) return false ; Class [ ] argTypes = new Class [ ] { getPrimativeClass ( value ) } ; try { meth = elem . getClass ( ) . getMethod ( setterString , argTypes ) ; } catch ( NoSuchMethodException nsme ) { Class cl = ( ( Object ) value ) . getClass ( ) ; argTypes [ 0 ] = cl ; meth = elem . getClass ( ) . getMethod ( setterString , argTypes ) ; } args = new Object [ ] { value } ; } meth . invoke ( elem , args ) ; } catch ( NoSuchMethodException nsme ) { if ( ! setterString . equals ( S_FOREIGNATTR_SETTER ) ) { handler . error ( XSLTErrorResources . ER_FAILED_CALLING_METHOD , new Object [ ] { setterString } , nsme ) ; return false ; } } catch ( IllegalAccessException iae ) { handler . error ( XSLTErrorResources . ER_FAILED_CALLING_METHOD , new Object [ ] { setterString } , iae ) ; return false ; } catch ( InvocationTargetException nsme ) { handleError ( handler , XSLTErrorResources . WG_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { Constants . ATTRNAME_NAME , getName ( ) } , nsme ) ; return false ; } } return true ; } private void handleError ( StylesheetHandler handler , String msg , Object [ ] args , Exception exc ) throws org . xml . sax . SAXException { switch ( getErrorType ( ) ) { case ( FATAL ) : case ( ERROR ) : handler . error ( msg , args , exc ) ; break ; case ( WARNING ) : handler . warn ( msg , args ) ; default : break ; } } } 	1	['43', '1', '0', '14', '90', '783', '4', '10', '1', '0.960784314', '1949', '0.205882353', '2', '0', '0.333333333', '0', '0', '43.53488372', '10', '1.3256', '2']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETSTATIC ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Text extends Instruction { private String _text ; private boolean _escaping = true ; private boolean _ignore = false ; private boolean _textElement = false ; public Text ( ) { _textElement = true ; } public Text ( String text ) { _text = text ; } protected String getText ( ) { return _text ; } protected void setText ( String text ) { if ( _text == null ) _text = text ; else _text = _text + text ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Text" ) ; indent ( indent + IndentIncrement ) ; Util . println ( _text ) ; } public void parseContents ( Parser parser ) { final String str = getAttribute ( "disable-output-escaping" ) ; if ( ( str != null ) && ( str . equals ( "yes" ) ) ) _escaping = false ; parseChildren ( parser ) ; if ( _text == null ) { if ( _textElement ) { _text = EMPTYSTRING ; } else { _ignore = true ; } } else if ( _textElement ) { if ( _text . length ( ) == 0 ) _ignore = true ; } else if ( getParent ( ) instanceof LiteralElement ) { LiteralElement element = ( LiteralElement ) getParent ( ) ; String space = element . getAttribute ( "xml:space" ) ; if ( ( space == null ) || ( ! space . equals ( "preserve" ) ) ) if ( _text . trim ( ) . length ( ) == 0 ) _ignore = true ; } else { if ( _text . trim ( ) . length ( ) == 0 ) _ignore = true ; } } public void ignore ( ) { _ignore = true ; } public boolean isIgnore ( ) { return _ignore ; } public boolean isTextElement ( ) { return _textElement ; } protected boolean contextDependent ( ) { return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( ! _ignore ) { final int esc = cpg . addInterfaceMethodref ( OUTPUT_HANDLER , "setEscaping" , "(Z)Z" ) ; if ( ! _escaping ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , false ) ) ; il . append ( new INVOKEINTERFACE ( esc , 2 ) ) ; } il . append ( methodGen . loadHandler ( ) ) ; if ( ! canLoadAsArrayOffsetLength ( ) ) { final int characters = cpg . addInterfaceMethodref ( OUTPUT_HANDLER , "characters" , "(" + STRING_SIG + ")V" ) ; il . append ( new PUSH ( cpg , _text ) ) ; il . append ( new INVOKEINTERFACE ( characters , 2 ) ) ; } else { final int characters = cpg . addInterfaceMethodref ( OUTPUT_HANDLER , "characters" , "([CII)V" ) ; loadAsArrayOffsetLength ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( characters , 4 ) ) ; } if ( ! _escaping ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( esc , 2 ) ) ; il . append ( POP ) ; } } translateContents ( classGen , methodGen ) ; } public boolean canLoadAsArrayOffsetLength ( ) { return ( _text . length ( ) <= 21845 ) ; } public void loadAsArrayOffsetLength ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final int offset = xsltc . addCharacterData ( _text ) ; final int length = _text . length ( ) ; String charDataFieldName = STATIC_CHAR_DATA_FIELD + ( xsltc . getCharacterDataCount ( ) - 1 ) ; il . append ( new GETSTATIC ( cpg . addFieldref ( xsltc . getClassName ( ) , charDataFieldName , STATIC_CHAR_DATA_FIELD_SIG ) ) ) ; il . append ( new PUSH ( cpg , offset ) ) ; il . append ( new PUSH ( cpg , _text . length ( ) ) ) ; } } 	1	['13', '3', '0', '22', '45', '0', '8', '17', '10', '0.625', '361', '1', '0', '0.835820896', '0.269230769', '2', '6', '26.46153846', '10', '2', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . utils . IntVector ; import org . w3c . dom . Node ; public class DTMAxisIterNodeList extends DTMNodeListBase { private DTM m_dtm ; private DTMAxisIterator m_iter ; private IntVector m_cachedNodes ; private int m_last = - 1 ; private DTMAxisIterNodeList ( ) { } public DTMAxisIterNodeList ( DTM dtm , DTMAxisIterator dtmAxisIterator ) { if ( dtmAxisIterator == null ) { m_last = 0 ; } else { m_cachedNodes = new IntVector ( ) ; m_dtm = dtm ; } m_iter = dtmAxisIterator ; } public DTMAxisIterator getDTMAxisIterator ( ) { return m_iter ; } public Node item ( int index ) { if ( m_iter != null ) { int node ; int count = m_cachedNodes . size ( ) ; if ( count > index ) { node = m_cachedNodes . elementAt ( index ) ; return m_dtm . getNode ( node ) ; } else if ( m_last == - 1 ) { while ( ( ( node = m_iter . next ( ) ) != DTMAxisIterator . END ) && count <= index ) { m_cachedNodes . addElement ( node ) ; count ++ ; } if ( node == DTMAxisIterator . END ) { m_last = count ; } else { return m_dtm . getNode ( node ) ; } } } return null ; } public int getLength ( ) { if ( m_last == - 1 ) { int node ; while ( ( node = m_iter . next ( ) ) != DTMAxisIterator . END ) { m_cachedNodes . addElement ( node ) ; } m_last = m_cachedNodes . size ( ) ; } return m_last ; } } 	1	['5', '2', '0', '5', '12', '0', '1', '4', '4', '0.4375', '119', '1', '3', '0.4', '0.4', '0', '0', '22', '7', '2.2', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Transformer ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class EmptySerializer implements SerializationHandler { protected static final String ERR = "EmptySerializer method not over-ridden" ; private static void throwUnimplementedException ( ) { return ; } public ContentHandler asContentHandler ( ) throws IOException { throwUnimplementedException ( ) ; return null ; } public void setContentHandler ( ContentHandler ch ) { throwUnimplementedException ( ) ; } public void close ( ) { throwUnimplementedException ( ) ; } public Properties getOutputFormat ( ) { throwUnimplementedException ( ) ; return null ; } public OutputStream getOutputStream ( ) { throwUnimplementedException ( ) ; return null ; } public Writer getWriter ( ) { throwUnimplementedException ( ) ; return null ; } public boolean reset ( ) { throwUnimplementedException ( ) ; return false ; } public void serialize ( Node node ) throws IOException { throwUnimplementedException ( ) ; } public void setCdataSectionElements ( Vector URI_and_localNames ) { throwUnimplementedException ( ) ; } public boolean setEscaping ( boolean escape ) throws SAXException { throwUnimplementedException ( ) ; return false ; } public void setIndent ( boolean indent ) { throwUnimplementedException ( ) ; } public void setIndentAmount ( int spaces ) { throwUnimplementedException ( ) ; } public void setOutputFormat ( Properties format ) { throwUnimplementedException ( ) ; } public void setOutputStream ( OutputStream output ) { throwUnimplementedException ( ) ; } public void setVersion ( String version ) { throwUnimplementedException ( ) ; } public void setWriter ( Writer writer ) { throwUnimplementedException ( ) ; } public void setTransformer ( Transformer transformer ) { throwUnimplementedException ( ) ; } public Transformer getTransformer ( ) { throwUnimplementedException ( ) ; return null ; } public void flushPending ( ) throws SAXException { throwUnimplementedException ( ) ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { throwUnimplementedException ( ) ; } public void addAttributes ( Attributes atts ) throws SAXException { throwUnimplementedException ( ) ; } public void addAttribute ( String name , String value ) { throwUnimplementedException ( ) ; } public void characters ( String chars ) throws SAXException { throwUnimplementedException ( ) ; } public void endElement ( String elemName ) throws SAXException { throwUnimplementedException ( ) ; } public void startDocument ( ) throws SAXException { throwUnimplementedException ( ) ; } public void startElement ( String uri , String localName , String qName ) throws SAXException { throwUnimplementedException ( ) ; } public void startElement ( String qName ) throws SAXException { throwUnimplementedException ( ) ; } public void namespaceAfterStartElement ( String uri , String prefix ) throws SAXException { throwUnimplementedException ( ) ; } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { throwUnimplementedException ( ) ; return false ; } public void entityReference ( String entityName ) throws SAXException { throwUnimplementedException ( ) ; } public NamespaceMappings getNamespaceMappings ( ) { throwUnimplementedException ( ) ; return null ; } public String getPrefix ( String uri ) { throwUnimplementedException ( ) ; return null ; } public String getNamespaceURI ( String name , boolean isElement ) { throwUnimplementedException ( ) ; return null ; } public String getNamespaceURIFromPrefix ( String prefix ) { throwUnimplementedException ( ) ; return null ; } public void setDocumentLocator ( Locator arg0 ) { throwUnimplementedException ( ) ; } public void endDocument ( ) throws SAXException { throwUnimplementedException ( ) ; } public void startPrefixMapping ( String arg0 , String arg1 ) throws SAXException { throwUnimplementedException ( ) ; } public void endPrefixMapping ( String arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void startElement ( String arg0 , String arg1 , String arg2 , Attributes arg3 ) throws SAXException { throwUnimplementedException ( ) ; } public void endElement ( String arg0 , String arg1 , String arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void characters ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void ignorableWhitespace ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void processingInstruction ( String arg0 , String arg1 ) throws SAXException { throwUnimplementedException ( ) ; } public void skippedEntity ( String arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void comment ( String comment ) throws SAXException { throwUnimplementedException ( ) ; } public void startDTD ( String arg0 , String arg1 , String arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void endDTD ( ) throws SAXException { throwUnimplementedException ( ) ; } public void startEntity ( String arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void endEntity ( String arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void startCDATA ( ) throws SAXException { throwUnimplementedException ( ) ; } public void endCDATA ( ) throws SAXException { throwUnimplementedException ( ) ; } public void comment ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public String getDoctypePublic ( ) { throwUnimplementedException ( ) ; return null ; } public String getDoctypeSystem ( ) { throwUnimplementedException ( ) ; return null ; } public String getEncoding ( ) { throwUnimplementedException ( ) ; return null ; } public boolean getIndent ( ) { throwUnimplementedException ( ) ; return false ; } public int getIndentAmount ( ) { throwUnimplementedException ( ) ; return 0 ; } public String getMediaType ( ) { throwUnimplementedException ( ) ; return null ; } public boolean getOmitXMLDeclaration ( ) { throwUnimplementedException ( ) ; return false ; } public String getStandalone ( ) { throwUnimplementedException ( ) ; return null ; } public String getVersion ( ) { throwUnimplementedException ( ) ; return null ; } public void setCdataSectionElements ( Hashtable h ) throws Exception { throwUnimplementedException ( ) ; } public void setDoctype ( String system , String pub ) { throwUnimplementedException ( ) ; } public void setDoctypePublic ( String doctype ) { throwUnimplementedException ( ) ; } public void setDoctypeSystem ( String doctype ) { throwUnimplementedException ( ) ; } public void setEncoding ( String encoding ) { throwUnimplementedException ( ) ; } public void setMediaType ( String mediatype ) { throwUnimplementedException ( ) ; } public void setOmitXMLDeclaration ( boolean b ) { throwUnimplementedException ( ) ; } public void setStandalone ( String standalone ) { throwUnimplementedException ( ) ; } public void elementDecl ( String arg0 , String arg1 ) throws SAXException { throwUnimplementedException ( ) ; } public void attributeDecl ( String arg0 , String arg1 , String arg2 , String arg3 , String arg4 ) throws SAXException { throwUnimplementedException ( ) ; } public void internalEntityDecl ( String arg0 , String arg1 ) throws SAXException { throwUnimplementedException ( ) ; } public void externalEntityDecl ( String arg0 , String arg1 , String arg2 ) throws SAXException { throwUnimplementedException ( ) ; } public void warning ( SAXParseException arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void error ( SAXParseException arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public void fatalError ( SAXParseException arg0 ) throws SAXException { throwUnimplementedException ( ) ; } public DOMSerializer asDOMSerializer ( ) throws IOException { throwUnimplementedException ( ) ; return null ; } public void setNamespaceMappings ( NamespaceMappings mappings ) { throwUnimplementedException ( ) ; } public void setSourceLocator ( SourceLocator locator ) { throwUnimplementedException ( ) ; } public void addUniqueAttribute ( String name , String value , int flags ) throws SAXException { throwUnimplementedException ( ) ; } } 	1	['82', '1', '2', '5', '83', '3321', '2', '3', '81', '1.012345679', '269', '1', '0', '0', '0.097560976', '0', '0', '2.268292683', '1', '0.9878', '4']
package org . apache . xalan . templates ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . QName ; import org . apache . xpath . Expression ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . PsuedoNames ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xpath . patterns . UnionPattern ; public class TemplateList implements java . io . Serializable { public TemplateList ( ) { super ( ) ; } public void setTemplate ( ElemTemplate template ) { XPath matchXPath = template . getMatch ( ) ; if ( null == template . getName ( ) && null == matchXPath ) { template . error ( XSLTErrorResources . ER_NEED_NAME_OR_MATCH_ATTRIB , new Object [ ] { "xsl:template" } ) ; } if ( null != template . getName ( ) ) { ElemTemplate existingTemplate = ( ElemTemplate ) m_namedTemplates . get ( template . getName ( ) ) ; if ( null == existingTemplate ) { m_namedTemplates . put ( template . getName ( ) , template ) ; } else { int existingPrecedence = existingTemplate . getStylesheetComposed ( ) . getImportCountComposed ( ) ; int newPrecedence = template . getStylesheetComposed ( ) . getImportCountComposed ( ) ; if ( newPrecedence > existingPrecedence ) { m_namedTemplates . put ( template . getName ( ) , template ) ; } else if ( newPrecedence == existingPrecedence ) template . error ( XSLTErrorResources . ER_DUPLICATE_NAMED_TEMPLATE , new Object [ ] { template . getName ( ) } ) ; } } if ( null != matchXPath ) { Expression matchExpr = matchXPath . getExpression ( ) ; if ( matchExpr instanceof StepPattern ) { insertPatternInTable ( ( StepPattern ) matchExpr , template ) ; } else if ( matchExpr instanceof UnionPattern ) { UnionPattern upat = ( UnionPattern ) matchExpr ; StepPattern [ ] pats = upat . getPatterns ( ) ; int n = pats . length ; for ( int i = 0 ; i < n ; i ++ ) { insertPatternInTable ( pats [ i ] , template ) ; } } else { } } } static boolean DEBUG = false ; void dumpAssociationTables ( ) { Enumeration associations = m_patternTable . elements ( ) ; while ( associations . hasMoreElements ( ) ) { TemplateSubPatternAssociation head = ( TemplateSubPatternAssociation ) associations . nextElement ( ) ; while ( null != head ) { System . out . print ( "(" + head . getTargetString ( ) + ", " + head . getPattern ( ) + ")" ) ; head = head . getNext ( ) ; } System . out . println ( "\n....." ) ; } TemplateSubPatternAssociation head = m_wildCardPatterns ; System . out . print ( "wild card list: " ) ; while ( null != head ) { System . out . print ( "(" + head . getTargetString ( ) + ", " + head . getPattern ( ) + ")" ) ; head = head . getNext ( ) ; } System . out . println ( "\n....." ) ; } public void compose ( StylesheetRoot sroot ) { if ( DEBUG ) { System . out . println ( "Before wildcard insert..." ) ; dumpAssociationTables ( ) ; } if ( null != m_wildCardPatterns ) { Enumeration associations = m_patternTable . elements ( ) ; while ( associations . hasMoreElements ( ) ) { TemplateSubPatternAssociation head = ( TemplateSubPatternAssociation ) associations . nextElement ( ) ; TemplateSubPatternAssociation wild = m_wildCardPatterns ; while ( null != wild ) { try { head = insertAssociationIntoList ( head , ( TemplateSubPatternAssociation ) wild . clone ( ) , true ) ; } catch ( CloneNotSupportedException cnse ) { } wild = wild . getNext ( ) ; } } } if ( DEBUG ) { System . out . println ( "After wildcard insert..." ) ; dumpAssociationTables ( ) ; } } private TemplateSubPatternAssociation insertAssociationIntoList ( TemplateSubPatternAssociation head , TemplateSubPatternAssociation item , boolean isWildCardInsert ) { double priority = getPriorityOrScore ( item ) ; double workPriority ; int importLevel = item . getImportLevel ( ) ; int docOrder = item . getDocOrderPos ( ) ; TemplateSubPatternAssociation insertPoint = head ; TemplateSubPatternAssociation next ; boolean insertBefore ; while ( true ) { next = insertPoint . getNext ( ) ; if ( null == next ) break ; else { workPriority = getPriorityOrScore ( next ) ; if ( importLevel > next . getImportLevel ( ) ) break ; else if ( importLevel < next . getImportLevel ( ) ) insertPoint = next ; else if ( priority > workPriority ) break ; else if ( priority < workPriority ) insertPoint = next ; else if ( docOrder >= next . getDocOrderPos ( ) ) break ; else insertPoint = next ; } } if ( ( null == next ) || ( insertPoint == head ) ) { workPriority = getPriorityOrScore ( insertPoint ) ; if ( importLevel > insertPoint . getImportLevel ( ) ) insertBefore = true ; else if ( importLevel < insertPoint . getImportLevel ( ) ) insertBefore = false ; else if ( priority > workPriority ) insertBefore = true ; else if ( priority < workPriority ) insertBefore = false ; else if ( docOrder >= insertPoint . getDocOrderPos ( ) ) insertBefore = true ; else insertBefore = false ; } else insertBefore = false ; if ( isWildCardInsert ) { if ( insertBefore ) { item . setNext ( insertPoint ) ; String key = insertPoint . getTargetString ( ) ; item . setTargetString ( key ) ; putHead ( key , item ) ; return item ; } else { item . setNext ( next ) ; insertPoint . setNext ( item ) ; return head ; } } else { if ( insertBefore ) { item . setNext ( insertPoint ) ; if ( insertPoint . isWild ( ) || item . isWild ( ) ) m_wildCardPatterns = item ; else putHead ( item . getTargetString ( ) , item ) ; return item ; } else { item . setNext ( next ) ; insertPoint . setNext ( item ) ; return head ; } } } private void insertPatternInTable ( StepPattern pattern , ElemTemplate template ) { String target = pattern . getTargetString ( ) ; if ( null != target ) { String pstring = template . getMatch ( ) . getPatternString ( ) ; TemplateSubPatternAssociation association = new TemplateSubPatternAssociation ( template , pattern , pstring ) ; boolean isWildCard = association . isWild ( ) ; TemplateSubPatternAssociation head = isWildCard ? m_wildCardPatterns : getHead ( target ) ; if ( null == head ) { if ( isWildCard ) m_wildCardPatterns = association ; else putHead ( target , association ) ; } else { insertAssociationIntoList ( head , association , false ) ; } } } private double getPriorityOrScore ( TemplateSubPatternAssociation matchPat ) { double priority = matchPat . getTemplate ( ) . getPriority ( ) ; if ( priority == XPath . MATCH_SCORE_NONE ) { Expression ex = matchPat . getStepPattern ( ) ; if ( ex instanceof NodeTest ) { return ( ( NodeTest ) ex ) . getDefaultScore ( ) ; } } return priority ; } public ElemTemplate getTemplate ( QName qname ) { return ( ElemTemplate ) m_namedTemplates . get ( qname ) ; } public TemplateSubPatternAssociation getHead ( XPathContext xctxt , int targetNode , DTM dtm ) { short targetNodeType = dtm . getNodeType ( targetNode ) ; TemplateSubPatternAssociation head ; switch ( targetNodeType ) { case DTM . ELEMENT_NODE : case DTM . ATTRIBUTE_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getLocalName ( targetNode ) ) ; break ; case DTM . TEXT_NODE : case DTM . CDATA_SECTION_NODE : head = m_textPatterns ; break ; case DTM . ENTITY_REFERENCE_NODE : case DTM . ENTITY_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getNodeName ( targetNode ) ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getLocalName ( targetNode ) ) ; break ; case DTM . COMMENT_NODE : head = m_commentPatterns ; break ; case DTM . DOCUMENT_NODE : case DTM . DOCUMENT_FRAGMENT_NODE : head = m_docPatterns ; break ; case DTM . NOTATION_NODE : default : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getNodeName ( targetNode ) ) ; } return ( null == head ) ? m_wildCardPatterns : head ; } public ElemTemplate getTemplateFast ( XPathContext xctxt , int targetNode , int expTypeID , QName mode , int maxImportLevel , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { TemplateSubPatternAssociation head ; switch ( dtm . getNodeType ( targetNode ) ) { case DTM . ELEMENT_NODE : case DTM . ATTRIBUTE_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getLocalNameFromExpandedNameID ( expTypeID ) ) ; break ; case DTM . TEXT_NODE : case DTM . CDATA_SECTION_NODE : head = m_textPatterns ; break ; case DTM . ENTITY_REFERENCE_NODE : case DTM . ENTITY_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getNodeName ( targetNode ) ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getLocalName ( targetNode ) ) ; break ; case DTM . COMMENT_NODE : head = m_commentPatterns ; break ; case DTM . DOCUMENT_NODE : case DTM . DOCUMENT_FRAGMENT_NODE : head = m_docPatterns ; break ; case DTM . NOTATION_NODE : default : head = ( TemplateSubPatternAssociation ) m_patternTable . get ( dtm . getNodeName ( targetNode ) ) ; } if ( null == head ) { head = m_wildCardPatterns ; if ( null == head ) return null ; } xctxt . pushNamespaceContextNull ( ) ; try { do { if ( ( maxImportLevel > - 1 ) && ( head . getImportLevel ( ) > maxImportLevel ) ) { continue ; } ElemTemplate template = head . getTemplate ( ) ; xctxt . setNamespaceContext ( template ) ; if ( ( head . m_stepPattern . execute ( xctxt , targetNode , dtm , expTypeID ) != NodeTest . SCORE_NONE ) && head . matchMode ( mode ) ) { if ( quietConflictWarnings ) checkConflicts ( head , xctxt , targetNode , mode ) ; return template ; } } while ( null != ( head = head . getNext ( ) ) ) ; } finally { xctxt . popNamespaceContext ( ) ; } return null ; } public ElemTemplate getTemplate ( XPathContext xctxt , int targetNode , QName mode , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { TemplateSubPatternAssociation head = getHead ( xctxt , targetNode , dtm ) ; if ( null != head ) { xctxt . pushNamespaceContextNull ( ) ; xctxt . pushCurrentNodeAndExpression ( targetNode , targetNode ) ; try { do { ElemTemplate template = head . getTemplate ( ) ; xctxt . setNamespaceContext ( template ) ; if ( ( head . m_stepPattern . execute ( xctxt , targetNode ) != NodeTest . SCORE_NONE ) && head . matchMode ( mode ) ) { if ( quietConflictWarnings ) checkConflicts ( head , xctxt , targetNode , mode ) ; return template ; } } while ( null != ( head = head . getNext ( ) ) ) ; } finally { xctxt . popCurrentNodeAndExpression ( ) ; xctxt . popNamespaceContext ( ) ; } } return null ; } public ElemTemplate getTemplate ( XPathContext xctxt , int targetNode , QName mode , int maxImportLevel , int endImportLevel , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { TemplateSubPatternAssociation head = getHead ( xctxt , targetNode , dtm ) ; if ( null != head ) { xctxt . pushNamespaceContextNull ( ) ; xctxt . pushCurrentNodeAndExpression ( targetNode , targetNode ) ; try { do { if ( ( maxImportLevel > - 1 ) && ( head . getImportLevel ( ) > maxImportLevel ) ) { continue ; } if ( head . getImportLevel ( ) <= maxImportLevel - endImportLevel ) return null ; ElemTemplate template = head . getTemplate ( ) ; xctxt . setNamespaceContext ( template ) ; if ( ( head . m_stepPattern . execute ( xctxt , targetNode ) != NodeTest . SCORE_NONE ) && head . matchMode ( mode ) ) { if ( quietConflictWarnings ) checkConflicts ( head , xctxt , targetNode , mode ) ; return template ; } } while ( null != ( head = head . getNext ( ) ) ) ; } finally { xctxt . popCurrentNodeAndExpression ( ) ; xctxt . popNamespaceContext ( ) ; } } return null ; } public TemplateWalker getWalker ( ) { return new TemplateWalker ( ) ; } private void checkConflicts ( TemplateSubPatternAssociation head , XPathContext xctxt , int targetNode , QName mode ) { } private void addObjectIfNotFound ( Object obj , Vector v ) { int n = v . size ( ) ; boolean addIt = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( v . elementAt ( i ) == obj ) { addIt = false ; break ; } } if ( addIt ) { v . addElement ( obj ) ; } } private Hashtable m_namedTemplates = new Hashtable ( 89 ) ; private Hashtable m_patternTable = new Hashtable ( 89 ) ; private TemplateSubPatternAssociation m_wildCardPatterns = null ; private TemplateSubPatternAssociation m_textPatterns = null ; private TemplateSubPatternAssociation m_docPatterns = null ; private TemplateSubPatternAssociation m_commentPatterns = null ; private Hashtable getNamedTemplates ( ) { return m_namedTemplates ; } private void setNamedTemplates ( Hashtable v ) { m_namedTemplates = v ; } private TemplateSubPatternAssociation getHead ( String key ) { return ( TemplateSubPatternAssociation ) m_patternTable . get ( key ) ; } private void putHead ( String key , TemplateSubPatternAssociation assoc ) { if ( key . equals ( PsuedoNames . PSEUDONAME_TEXT ) ) m_textPatterns = assoc ; else if ( key . equals ( PsuedoNames . PSEUDONAME_ROOT ) ) m_docPatterns = assoc ; else if ( key . equals ( PsuedoNames . PSEUDONAME_COMMENT ) ) m_commentPatterns = assoc ; m_patternTable . put ( key , assoc ) ; } public class TemplateWalker { private Enumeration hashIterator ; private boolean inPatterns ; private TemplateSubPatternAssociation curPattern ; private Hashtable m_compilerCache = new Hashtable ( ) ; private TemplateWalker ( ) { hashIterator = m_patternTable . elements ( ) ; inPatterns = true ; curPattern = null ; } public ElemTemplate next ( ) { ElemTemplate retValue = null ; ElemTemplate ct ; while ( true ) { if ( inPatterns ) { if ( null != curPattern ) curPattern = curPattern . getNext ( ) ; if ( null != curPattern ) retValue = curPattern . getTemplate ( ) ; else { if ( hashIterator . hasMoreElements ( ) ) { curPattern = ( TemplateSubPatternAssociation ) hashIterator . nextElement ( ) ; retValue = curPattern . getTemplate ( ) ; } else { inPatterns = false ; hashIterator = m_namedTemplates . elements ( ) ; } } } if ( ! inPatterns ) { if ( hashIterator . hasMoreElements ( ) ) retValue = ( ElemTemplate ) hashIterator . nextElement ( ) ; else return null ; } ct = ( ElemTemplate ) m_compilerCache . get ( new Integer ( retValue . getUid ( ) ) ) ; if ( null == ct ) { m_compilerCache . put ( new Integer ( retValue . getUid ( ) ) , retValue ) ; return retValue ; } } } } } 	1	['22', '1', '0', '18', '74', '121', '3', '17', '9', '0.680272109', '959', '0.857142857', '4', '0', '0.180952381', '0', '0', '42.27272727', '19', '3.1364', '2']
package org . apache . xml . dtm ; import javax . xml . transform . SourceLocator ; public class DTMConfigurationException extends DTMException { public DTMConfigurationException ( ) { super ( "Configuration Error" ) ; } public DTMConfigurationException ( String msg ) { super ( msg ) ; } public DTMConfigurationException ( Throwable e ) { super ( e ) ; } public DTMConfigurationException ( String msg , Throwable e ) { super ( msg , e ) ; } public DTMConfigurationException ( String message , SourceLocator locator ) { super ( message , locator ) ; } public DTMConfigurationException ( String message , SourceLocator locator , Throwable e ) { super ( message , locator , e ) ; } } 	1	['6', '5', '0', '2', '11', '15', '1', '1', '6', '2', '34', '0', '0', '1', '0.625', '0', '0', '4.666666667', '0', '0', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_ko extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "하나 이상의 스타일 시트가 동일한 파일에서 정의되었습니다." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "''{0}'' 템플리트가 이미 이 스타일 시트에서 정의되었습니다." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "''{0}'' 템플리트가 이 스타일 시트에서 정의되지 않았습니다." } , { ErrorMsg . VARIABLE_REDEF_ERR , "''{0}'' 변수가 동일한 범위 안에서 여러 번 정의되었습니다." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "''{0}'' 매개변수 또는 변수가 정의되지 않았습니다." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "''{0}'' 클래스를 찾을 수 없습니다." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "''{0}'' 외부 메소드를 찾을 수 없습니다(public이어야 합니다)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "''{0}'' 메소드로의 호출에서 인수/리턴 유형을 변환할 수 없습니다." } , { ErrorMsg . FILE_NOT_FOUND_ERR , "''{0}'' URI 또는 파일을 찾을 수 없습니다." } , { ErrorMsg . INVALID_URI_ERR , "''{0}'' URI가 올바르지 않습니다." } , { ErrorMsg . FILE_ACCESS_ERR , "''{0}'' URI 또는 파일을 열 수 없습니다." } , { ErrorMsg . MISSING_ROOT_ERR , "<xsl:stylesheet> 또는 <xsl:transform> 요소가 예상됩니다." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "''{0}'' 이름 공간 접두부가 선언되지 않았습니다." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "''{0}'' 함수에 대한 호출을 분석할 수 없습니다." } , { ErrorMsg . NEED_LITERAL_ERR , "''{0}''에 대한 인수는 리터럴 문자열이어야 합니다." } , { ErrorMsg . XPATH_PARSER_ERR , "''{0}'' XPath 표현식 구문 분석 중 오류가 발생했습니다." } , { ErrorMsg . REQUIRED_ATTR_ERR , "''{0}'' 필수 속성이 누락되었습니다." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "XPath 표현식의 ''{0}'' 문자가 유효하지 않습니다." } , { ErrorMsg . ILLEGAL_PI_ERR , "처리 명령어에 대한 ''{0}'' 이름이 유효하지 않습니다." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "''{0}'' 속성이 요소의 외부에 있습니다." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "''{0}'' 속성이 유효하지 않습니다." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "import/include 가 순환됩니다. ''{0}'' 스타일 시트가 이미 로드되었습니다." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "결과 트리 단편을 정렬할 수 없습니다(<xsl:sort> 요소가 무시됩니다). 결과 트리를 작성할 때 노드를 정렬해야 합니다." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "''{0}'' 10진수 포맷팅이 이미 정의되어 있습니다." } , { ErrorMsg . XSL_VERSION_ERR , "XSLTC에서 ''{0}'' XSL 버전을 지원하지 않습니다." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "''{0}''에서 변수/매개변수 참조가 순환됩니다." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "2진 표현식에 대한 연산자를 알 수 없습니다." } , { ErrorMsg . ILLEGAL_ARG_ERR , "함수 호출에 대한 인수가 유효하지 않습니다." } , { ErrorMsg . DOCUMENT_ARG_ERR , "document() 함수에 대한 두 번째 인수는 node-set여야 합니다." } , { ErrorMsg . MISSING_WHEN_ERR , "<xsl:choose>에 최소 하나의 <xsl:when> 요소가 필요합니다." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "<xsl:choose>에 하나의 <xsl:otherwise> 요소만이 허용됩니다." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise>는 <xsl:choose>에서만 사용될 수 있습니다." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when>은 <xsl:choose>에서만 사용될 수 있습니다." } , { ErrorMsg . WHEN_ELEMENT_ERR , "<xsl:when> 및 <xsl:otherwise> 요소만이 <xsl:choose>에서 허용됩니다." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set>이 'name' 속성에서 누락되었습니다." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "하위 요소가 유효하지 않습니다." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "''{0}'' 요소를 호출할 수 없습니다." } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "''{0}'' 속성을 호출할 수 없습니다." } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "텍스트 데이터가 최상위 레벨 <xsl:stylesheet> 요소의 외부에 있습니다." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "JAXP 구문 분석기가 제대로 구성되지 않았습니다." } , { ErrorMsg . INTERNAL_ERR , "복구할 수 없는 XSLTC-내부 오류: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "''{0}'' XSL 요소가 지원되지 않습니다." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "''{0}'' XSLTC 확장자를 인식할 수 없습니다." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "입력 문서는 스타일 시트가 아닙니다(XSL 이름 공간이 루트 요소에서 선언되지 않았습니다)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "''{0}'' 스타일 시트 대상을 찾을 수 없습니다." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "구현되지 않았음: ''{0}''" } , { ErrorMsg . NOT_STYLESHEET_ERR , "입력 문서에 XSL 스타일 시트가 포함되지 않았습니다." } , { ErrorMsg . ELEMENT_PARSE_ERR , "''{0}'' 요소를 구문 분석할 수 없습니다." } , { ErrorMsg . KEY_USE_ATTR_ERR , "<key>의 use 속성은 node, node-set, string 또는 number여야 합니다." } , { ErrorMsg . OUTPUT_VERSION_ERR , "출력 XML 문서 버전은 1.0이어야 합니다." } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "관계식에 대한 연산자를 알 수 없습니다." } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "존재하지 않는 속성 세트 ''{0}'' 사용을 시도 중입니다." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "''{0}'' 속성값 템플리트를 구문 분석할 수 없습니다." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "''{0}'' 클래스에 대한 서명에 알 수 없는 데이터 유형이 있습니다." } , { ErrorMsg . DATA_CONVERSION_ERR , "데이터 유형을 ''{0}''에서 ''{1}''(으)로 변환할 수 없습니다." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "이 Templates에는 올바른 translet 클래스 정의가 포함되어 있지 않습니다." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "이 Templates에는 ''{0}'' 이름인 클래스가 포함되어 있지 않습니다." } , { ErrorMsg . TRANSLET_CLASS_ERR , "''{0}'' translet 클래스를 로드할 수 없습니다." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "translet 클래스는 로드되었지만 translet 인스턴스를 작성할 수 없습니다." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "''{0}''에 대한 ErrorListener를 널(null)로 설정하려고 시도 중입니다." } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "XSLTC에서 StreamSource, SAXSource 및 DOMSource만을 지원합니다." } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "''{0}''(으)로 패스된 Source 오브젝트에 컨텐츠가 없습니다." } , { ErrorMsg . JAXP_COMPILE_ERR , "스타일 시트를 컴파일할 수 없습니다." } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory ''{0}'' 속성을 인식할 수 없습니다." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult()는 startDocument()에 앞서 호출되어야 합니다." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformer에 요약된 translet 오브젝트가 없습니다." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "변환 결과에 대한 출력 핸들러가 정의되지 않았습니다." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "''{0}''(으)로 패스된 Result 오브젝트가 올바르지 않습니다." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "''{0}'' 잘못된 Transformer 특성에 액세스를 시도 중입니다." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "SAX2DOM ''{0}'' 어댑터를 작성할 수 없습니다." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build()가 설정된 시스템 ID 없이 호출되었습니다." } , { ErrorMsg . COMPILE_STDIN_ERR , "-i 옵션은 -o 옵션과 함께 사용되어야 합니다." } , { ErrorMsg . COMPILE_USAGE_STR , "SYNOPSIS\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]\n      [-d <directory>] [-j <jarfile>] [-p <package>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }\n\n옵션\n   -o <output>은   생성된 translet에 이름 <output>을 지정합니다.\n                   translet 이름은 기본값으로\n                   <stylesheet> 이름에서 가져옵니다. 이 옵션은\n                   다중 스타일 시트 컴파일 중인 경우 무시됩니다.\n   -d <directory>는 translet의 대상 디렉토리를 지정합니다. \n   -j <jarfile>는  <jarfile>로 지정된 \n                   jar 파일의 이름으로 translet 클래스를 패키지합니다. \n   -p <package>는  생성된 모든 \n                   translet 클래스의 패키지 이름의 접두부를 지정합니다.\n   -n은            템플리트 인라이닝(평균보다 좋은 \n                   성능을 생성)을 사용 가능하게 합니다.\n   -x는            추가 디버깅 메시지 출력을 시작합니다.\n   -s는            System.exit 호출을 사용 불가능하게 합니다.\n   -u는            <stylesheet> 인수를 URL로 해석합니다.\n   -i는            stdin으로부터 스타일 시트를 읽을 수 있도록\n                   컴파일러를 강제 실행합니다.\n   -v는            컴파일러의 버전을 인쇄합니다.\n   -h는            사용법 명령문을 인쇄합니다.\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SYNOPSIS \n   java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]\n      [-x] [-s] [-n <iterations>] {-u <document_url> | <document>}\n      <class> [<param1>=<value1> ...]\n\n   translet <class>를 사용하여 <document>로 지정된 XML 문서를 \n   변환합니다. translet <class> 는 \n   사용자의 CLASSPATH 나 선택적으로 지정된  <jarfile> 내에 있습니다.\n옵션\n   -j <jarfile>는     로드할 translet로부터 jarfile을 지정합니다.\n   -x는               추가 디버깅 메시지 출력을 시작합니다.\n   -s는               System.exit 호출을 사용 불가능하게 합니다.\n   -n <iterations>은  <iterations> 횟수로 변환을 실행하며\n                      프로파일링 정보를 표시합니다.\n   -u <document_url>는 XML 입력 문서를 URL로 지정합니다.\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort>는 <xsl:for-each> 또는 <xsl:apply-templates>에서만 사용될 수 있습니다." } , { ErrorMsg . UNSUPPORTED_ENCODING , "이 JVM에서 ''{0}'' 출력 인코딩을 지원하지 않습니다." } , { ErrorMsg . SYNTAX_ERR , "''{0}''에 구문 오류가 있습니다." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "''{0}'' 외부 구성자를 찾을 수 없습니다." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "non-static Java 함수 ''{0}''의 첫 번째 인수가 올바른 오브젝트 참조가 아닙니다." } , { ErrorMsg . TYPE_CHECK_ERR , "''{0}'' 표현식의 유형을 검사하는 중 오류가 발생했습니다." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "알 수 없는 위치에서 표현식의 유형을 검사하는 중 오류가 발생했습니다." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "''{0}'' 명령행 옵션이 올바르지 않습니다." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "''{0}'' 명령행 옵션에 필수 인수가 누락되었습니다." } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "경고:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "경고:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "심각한 오류:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "심각한 오류:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "오류:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "오류:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "''{0}'' translet을 사용하여 변환 " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "''{1}'' jar 파일에서 ''{0}'' translet을 사용하여 변환" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "TransformerFactory 클래스 ''{0}''의 인스턴스를 작성할 수 없습니다." } , { ErrorMsg . COMPILER_ERROR_KEY , "컴파일러 오류:" } , { ErrorMsg . COMPILER_WARNING_KEY , "컴파일러 경고:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Translet 오류:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xpath . patterns ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XObject ; public class UnionPattern extends Expression { private StepPattern [ ] m_patterns ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { for ( int i = 0 ; i < m_patterns . length ; i ++ ) { m_patterns [ i ] . fixupVariables ( vars , globalsSize ) ; } } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_patterns ) { int n = m_patterns . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( m_patterns [ i ] . canTraverseOutsideSubtree ( ) ) return true ; } } return false ; } public void setPatterns ( StepPattern [ ] patterns ) { m_patterns = patterns ; if ( null != patterns ) { for ( int i = 0 ; i < patterns . length ; i ++ ) { patterns [ i ] . exprSetParent ( this ) ; } } } public StepPattern [ ] getPatterns ( ) { return m_patterns ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject bestScore = null ; int n = m_patterns . length ; for ( int i = 0 ; i < n ; i ++ ) { XObject score = m_patterns [ i ] . execute ( xctxt ) ; if ( score != NodeTest . SCORE_NONE ) { if ( null == bestScore ) bestScore = score ; else if ( score . num ( ) > bestScore . num ( ) ) bestScore = score ; } } if ( null == bestScore ) { bestScore = NodeTest . SCORE_NONE ; } return bestScore ; } class UnionPathPartOwner implements ExpressionOwner { int m_index ; UnionPathPartOwner ( int index ) { m_index = index ; } public Expression getExpression ( ) { return m_patterns [ m_index ] ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( UnionPattern . this ) ; m_patterns [ m_index ] = ( StepPattern ) exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { visitor . visitUnionPattern ( owner , this ) ; if ( null != m_patterns ) { int n = m_patterns . length ; for ( int i = 0 ; i < n ; i ++ ) { m_patterns [ i ] . callVisitors ( new UnionPathPartOwner ( i ) , visitor ) ; } } } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; UnionPattern up = ( UnionPattern ) expr ; if ( null != m_patterns ) { int n = m_patterns . length ; if ( ( null == up . m_patterns ) || ( up . m_patterns . length != n ) ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m_patterns [ i ] . deepEquals ( up . m_patterns [ i ] ) ) return false ; } } else if ( up . m_patterns != null ) return false ; return true ; } } 	1	['9', '2', '0', '12', '20', '0', '4', '10', '8', '0.125', '212', '1', '1', '0.789473684', '0.197530864', '1', '7', '22.44444444', '7', '2.4444', '1']
package org . apache . xalan . transformer ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . KeyDeclaration ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class KeyTable { private int m_docKey ; private Vector m_keyDeclarations ; private Hashtable m_refsTable = null ; public int getDocKey ( ) { return m_docKey ; } private XNodeSet m_keyNodes ; KeyIterator getKeyIterator ( ) { return ( KeyIterator ) ( m_keyNodes . getContainedIter ( ) ) ; } public KeyTable ( int doc , PrefixResolver nscontext , QName name , Vector keyDeclarations , XPathContext xctxt ) throws javax . xml . transform . TransformerException { m_docKey = doc ; m_keyDeclarations = keyDeclarations ; KeyIterator ki = new KeyIterator ( name , keyDeclarations ) ; m_keyNodes = new XNodeSet ( ki ) ; m_keyNodes . allowDetachToRelease ( false ) ; m_keyNodes . setRoot ( doc , xctxt ) ; } public XNodeSet getNodeSetDTMByKey ( QName name , XMLString ref ) { XNodeSet refNodes = ( XNodeSet ) getRefsTable ( ) . get ( ref ) ; try { if ( refNodes != null ) { refNodes = ( XNodeSet ) refNodes . cloneWithReset ( ) ; } } catch ( CloneNotSupportedException e ) { refNodes = null ; } if ( refNodes == null ) { KeyIterator ki = ( KeyIterator ) ( m_keyNodes ) . getContainedIter ( ) ; XPathContext xctxt = ki . getXPathContext ( ) ; refNodes = new XNodeSet ( xctxt . getDTMManager ( ) ) { public void setRoot ( int nodeHandle , Object environment ) { } } ; refNodes . reset ( ) ; } return refNodes ; } public QName getKeyTableName ( ) { return getKeyIterator ( ) . getName ( ) ; } private KeyDeclaration getKeyDeclaration ( ) { int nDeclarations = m_keyDeclarations . size ( ) ; for ( int i = 0 ; i < nDeclarations ; i ++ ) { KeyDeclaration kd = ( KeyDeclaration ) m_keyDeclarations . elementAt ( i ) ; if ( kd . getName ( ) . equals ( getKeyTableName ( ) ) ) { return kd ; } } return null ; } private Hashtable getRefsTable ( ) { if ( m_refsTable == null ) { m_refsTable = new Hashtable ( 89 ) ; KeyIterator ki = ( KeyIterator ) ( m_keyNodes ) . getContainedIter ( ) ; XPathContext xctxt = ki . getXPathContext ( ) ; KeyDeclaration keyDeclaration = getKeyDeclaration ( ) ; int currentNode ; m_keyNodes . reset ( ) ; while ( DTM . NULL != ( currentNode = m_keyNodes . nextNode ( ) ) ) { try { XObject xuse = keyDeclaration . getUse ( ) . execute ( xctxt , currentNode , ki . getPrefixResolver ( ) ) ; if ( xuse . getType ( ) != xuse . CLASS_NODESET ) { XMLString exprResult = xuse . xstr ( ) ; addValueInRefsTable ( xctxt , exprResult , currentNode ) ; } else { DTMIterator i = ( ( XNodeSet ) xuse ) . iterRaw ( ) ; int currentNodeInUseClause ; while ( DTM . NULL != ( currentNodeInUseClause = i . nextNode ( ) ) ) { DTM dtm = xctxt . getDTM ( currentNodeInUseClause ) ; XMLString exprResult = dtm . getStringValue ( currentNodeInUseClause ) ; addValueInRefsTable ( xctxt , exprResult , currentNode ) ; } } } catch ( TransformerException te ) { throw new WrappedRuntimeException ( te ) ; } } } return m_refsTable ; } private void addValueInRefsTable ( XPathContext xctxt , XMLString ref , int node ) { XNodeSet nodes = ( XNodeSet ) m_refsTable . get ( ref ) ; if ( nodes == null ) { nodes = new XNodeSet ( node , xctxt . getDTMManager ( ) ) ; nodes . nextNode ( ) ; m_refsTable . put ( ref , nodes ) ; } else { if ( nodes . getCurrentNode ( ) != node ) { nodes . mutableNodeset ( ) . addNode ( node ) ; nodes . nextNode ( ) ; } } } } 	1	['8', '1', '0', '16', '42', '8', '2', '15', '4', '0.607142857', '246', '1', '1', '0', '0.321428571', '0', '0', '29.25', '4', '1.875', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_zh_TW extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "''{0}'' 發生執行時期內部錯誤" } , { BasisLibrary . RUN_TIME_COPY_ERR , "執行 <xsl:copy> 時，發生執行時期錯誤。" } , { BasisLibrary . DATA_CONVERSION_ERR , "無法將 ''{0}'' 轉換為 ''{1}''。" } , { BasisLibrary . EXTERNAL_FUNC_ERR , "XSLTC 不支援外部函數 ''{0}''。" } , { BasisLibrary . EQUALITY_EXPR_ERR , "相等表示式中包含不明的引數類型。" } , { BasisLibrary . INVALID_ARGUMENT_ERR , "在呼叫 ''{1}'' 中的引數類型 ''{0}'' 無效" } , { BasisLibrary . FORMAT_NUMBER_ERR , "嘗試使用型樣 ''{1}'' 格式化數字 ''{0}''。" } , { BasisLibrary . ITERATOR_CLONE_ERR , "無法複製重複項目 ''{0}''。" } , { BasisLibrary . AXIS_SUPPORT_ERR , "軸 ''{0}'' 的重複項目未受支援。" } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "輸入軸 ''{0}'' 的重複項目未受支援。" } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "屬性 ''{0}'' 超出元素外。" } , { BasisLibrary . STRAY_NAMESPACE_ERR , "名稱空間宣告 ''{0}''=''{1}'' 超出元素外。" } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "字首 ''{0}'' 的名稱空間尚未宣告。" } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "建立 DOMAdapter 時使用的原始檔 DOM 類型錯誤。" } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "您使用的 SAX 剖析器無法處理 DTD 宣告事件。" } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "您使用的 SAX 剖析器不支援 XML 名稱空間。" } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "無法解析 URI 參照 ''{0}''。" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_pt_BR extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Erro interno de tempo de execução em ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Erro de tempo de execução ao executar <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Conversão inválida de ''{0}'' em ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "Função externa ''{0}'' não suportada por XSLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Tipo de argumento desconhecido na expressão de igualdade. " } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Tipo de argumento inválido ''{0}'' na chamada para ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Tentando formatar o número ''{0}'' utilizando o padrão ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Impossível clonar iterador ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Iterador para eixo ''{0}'' não suportado. " } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Iterador para eixo digitado ''{0}'' não suportado. " } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Atributo ''{0}'' fora do elemento. " } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Declaração de namespace ''{0}''=''{1}'' fora do elemento. " } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "Namespace para prefixo ''{0}'' não foi declarado. " } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter criado utilizando tipo incorreto de DOM de origem." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "O analisador SAX que está sendo utilizado não trata de eventos de declaração de DTD." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "O analisador SAX que está sendo utilizado não possui suporte para Namespaces XML." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "Impossível resolver a referência de URI ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFGE ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . utils . XMLChar ; final class Key extends TopLevelElement { private QName _name ; private Pattern _match ; private Expression _use ; private Type _useType ; public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; if ( ! XMLChar . isValidQName ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , name , this ) ; parser . reportError ( Constants . ERROR , err ) ; } _name = parser . getQNameIgnoreDefaultNs ( name ) ; _match = parser . parsePattern ( this , "match" , null ) ; _use = parser . parseExpression ( this , "use" , null ) ; if ( _name == null ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "name" ) ; return ; } if ( _match . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "match" ) ; return ; } if ( _use . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "use" ) ; return ; } } public String getName ( ) { return _name . toString ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _match . typeCheck ( stable ) ; _useType = _use . typeCheck ( stable ) ; if ( _useType instanceof StringType == false && _useType instanceof NodeSetType == false ) { _use = new CastExpr ( _use , Type . String ) ; } return Type . Void ; } public void traverseNodeSet ( ClassGenerator classGen , MethodGenerator methodGen , int buildKeyIndex ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNodeValue = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE , "(I)" + STRING_SIG ) ; final int getNodeIdent = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeIdent" , "(I)" + NODE_SIG ) ; final int keyDom = cpg . addMethodref ( TRANSLET_CLASS , "setKeyIndexDom" , "(" + STRING_SIG + DOM_INTF_SIG + ")V" ) ; final LocalVariableGen parentNode = methodGen . addLocalVariable ( "parentNode" , Util . getJCRefType ( "I" ) , il . getEnd ( ) , null ) ; il . append ( new ISTORE ( parentNode . getIndex ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( parentNode . getIndex ( ) ) ) ; il . append ( new INVOKEINTERFACE ( getNodeIdent , 2 ) ) ; il . append ( new ISTORE ( parentNode . getIndex ( ) ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; _use . translate ( classGen , methodGen ) ; _use . startIterator ( classGen , methodGen ) ; il . append ( methodGen . storeIterator ( ) ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , _name . toString ( ) ) ) ; il . append ( new ILOAD ( parentNode . getIndex ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( getNodeValue , 2 ) ) ; il . append ( new INVOKEVIRTUAL ( buildKeyIndex ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , getName ( ) ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEVIRTUAL ( keyDom ) ) ; nextNode . setTarget ( il . append ( methodGen . loadIterator ( ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFGE ( loop ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; final int key = cpg . addMethodref ( TRANSLET_CLASS , "buildKeyIndex" , "(" + STRING_SIG + "I" + OBJECT_SIG + ")V" ) ; final int keyDom = cpg . addMethodref ( TRANSLET_CLASS , "setKeyIndexDom" , "(" + STRING_SIG + DOM_INTF_SIG + ")V" ) ; final int getNodeIdent = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeIdent" , "(I)" + NODE_SIG ) ; final int git = cpg . addInterfaceMethodref ( DOM_INTF , "getAxisIterator" , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , Axis . DESCENDANT ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . setStartNode ( ) ) ; il . append ( methodGen . storeIterator ( ) ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; _match . translate ( classGen , methodGen ) ; _match . synthesize ( classGen , methodGen ) ; final BranchHandle skipNode = il . append ( new IFEQ ( null ) ) ; if ( _useType instanceof NodeSetType ) { il . append ( methodGen . loadCurrentNode ( ) ) ; traverseNodeSet ( classGen , methodGen , key ) ; } else { il . append ( classGen . loadTranslet ( ) ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _name . toString ( ) ) ) ; il . append ( DUP_X1 ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; _use . translate ( classGen , methodGen ) ; il . append ( SWAP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( getNodeIdent , 2 ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEVIRTUAL ( key ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEVIRTUAL ( keyDom ) ) ; } final InstructionHandle skip = il . append ( NOP ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFGT ( loop ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; nextNode . setTarget ( skip ) ; skipNode . setTarget ( skip ) ; } } 	1	['6', '3', '0', '37', '56', '0', '1', '36', '5', '0.55', '586', '1', '4', '0.923076923', '0.361111111', '2', '5', '96', '5', '1.6667', '2']
package org . apache . xalan . xsltc . runtime ; import java . io . FileWriter ; import java . text . DecimalFormat ; import java . text . DecimalFormatSymbols ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Vector ; import javax . xml . transform . Templates ; import org . apache . xml . dtm . DTM ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMCache ; import org . apache . xalan . xsltc . DOMEnhancedForDTM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . dom . DOMAdapter ; import org . apache . xalan . xsltc . dom . KeyIndex ; import org . apache . xalan . xsltc . runtime . output . TransletOutputHandlerFactory ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . serializer . SerializationHandler ; public abstract class AbstractTranslet implements Translet { public String _version = "1.0" ; public String _method = null ; public String _encoding = "UTF-8" ; public boolean _omitHeader = false ; public String _standalone = null ; public String _doctypePublic = null ; public String _doctypeSystem = null ; public boolean _indent = false ; public String _mediaType = null ; public Vector _cdata = null ; public static final int FIRST_TRANSLET_VERSION = 100 ; public static final int VER_SPLIT_NAMES_ARRAY = 101 ; public static final int CURRENT_TRANSLET_VERSION = VER_SPLIT_NAMES_ARRAY ; protected int transletVersion = FIRST_TRANSLET_VERSION ; protected String [ ] namesArray ; protected String [ ] urisArray ; protected int [ ] typesArray ; protected String [ ] namespaceArray ; protected Templates _templates = null ; protected boolean _hasIdCall = false ; protected StringValueHandler stringValueHandler = new StringValueHandler ( ) ; private final static String EMPTYSTRING = "" ; private final static String ID_INDEX_NAME = "##id" ; public void printInternalState ( ) { System . out . println ( "-------------------------------------" ) ; System . out . println ( "AbstractTranslet this = " + this ) ; System . out . println ( "pbase = " + pbase ) ; System . out . println ( "vframe = " + pframe ) ; System . out . println ( "paramsStack.size() = " + paramsStack . size ( ) ) ; System . out . println ( "namesArray.size = " + namesArray . length ) ; System . out . println ( "namespaceArray.size = " + namespaceArray . length ) ; System . out . println ( "" ) ; System . out . println ( "Total memory = " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; } public final DOMAdapter makeDOMAdapter ( DOM dom ) throws TransletException { return new DOMAdapter ( dom , namesArray , urisArray , typesArray , namespaceArray ) ; } protected int pbase = 0 , pframe = 0 ; protected ArrayList paramsStack = new ArrayList ( ) ; public final void pushParamFrame ( ) { paramsStack . add ( pframe , new Integer ( pbase ) ) ; pbase = ++ pframe ; } public final void popParamFrame ( ) { if ( pbase > 0 ) { final int oldpbase = ( ( Integer ) paramsStack . get ( -- pbase ) ) . intValue ( ) ; for ( int i = pframe - 1 ; i >= pbase ; i -- ) { paramsStack . remove ( i ) ; } pframe = pbase ; pbase = oldpbase ; } } public final Object addParameter ( String name , Object value ) { name = BasisLibrary . mapQNameToJavaName ( name ) ; return addParameter ( name , value , false ) ; } public final Object addParameter ( String name , Object value , boolean isDefault ) { for ( int i = pframe - 1 ; i >= pbase ; i -- ) { final Parameter param = ( Parameter ) paramsStack . get ( i ) ; if ( param . _name . equals ( name ) ) { if ( param . _isDefault || ! isDefault ) { param . _value = value ; param . _isDefault = isDefault ; return value ; } return param . _value ; } } paramsStack . add ( pframe ++ , new Parameter ( name , value , isDefault ) ) ; return value ; } public void clearParameters ( ) { pbase = pframe = 0 ; paramsStack . clear ( ) ; } public final Object getParameter ( String name ) { name = BasisLibrary . mapQNameToJavaName ( name ) ; for ( int i = pframe - 1 ; i >= pbase ; i -- ) { final Parameter param = ( Parameter ) paramsStack . get ( i ) ; if ( param . _name . equals ( name ) ) return param . _value ; } return null ; } private MessageHandler _msgHandler = null ; public final void setMessageHandler ( MessageHandler handler ) { _msgHandler = handler ; } public final void displayMessage ( String msg ) { if ( _msgHandler == null ) { System . err . println ( msg ) ; } else { _msgHandler . displayMessage ( msg ) ; } } public Hashtable _formatSymbols = null ; public void addDecimalFormat ( String name , DecimalFormatSymbols symbols ) { if ( _formatSymbols == null ) _formatSymbols = new Hashtable ( ) ; if ( name == null ) name = EMPTYSTRING ; final DecimalFormat df = new DecimalFormat ( ) ; if ( symbols != null ) { df . setDecimalFormatSymbols ( symbols ) ; } _formatSymbols . put ( name , df ) ; } public final DecimalFormat getDecimalFormat ( String name ) { if ( _formatSymbols != null ) { if ( name == null ) name = EMPTYSTRING ; DecimalFormat df = ( DecimalFormat ) _formatSymbols . get ( name ) ; if ( df == null ) df = ( DecimalFormat ) _formatSymbols . get ( EMPTYSTRING ) ; return df ; } return ( null ) ; } public final void prepassDocument ( DOM document ) { setIndexSize ( document . getSize ( ) ) ; buildIDIndex ( document ) ; } private final void buildIDIndex ( DOM document ) { if ( document instanceof DOMEnhancedForDTM ) { DOMEnhancedForDTM enhancedDOM = ( DOMEnhancedForDTM ) document ; if ( enhancedDOM . hasDOMSource ( ) ) { buildKeyIndex ( ID_INDEX_NAME , document ) ; return ; } else { final Hashtable elementsByID = enhancedDOM . getElementsWithIDs ( ) ; if ( elementsByID == null ) { return ; } final Enumeration idValues = elementsByID . keys ( ) ; boolean hasIDValues = false ; while ( idValues . hasMoreElements ( ) ) { final Object idValue = idValues . nextElement ( ) ; final int element = ( ( Integer ) elementsByID . get ( idValue ) ) . intValue ( ) ; buildKeyIndex ( ID_INDEX_NAME , element , idValue ) ; hasIDValues = true ; } if ( hasIDValues ) { setKeyIndexDom ( ID_INDEX_NAME , document ) ; } } } } public final void postInitialization ( ) { if ( transletVersion < VER_SPLIT_NAMES_ARRAY ) { int arraySize = namesArray . length ; String [ ] newURIsArray = new String [ arraySize ] ; String [ ] newNamesArray = new String [ arraySize ] ; int [ ] newTypesArray = new int [ arraySize ] ; for ( int i = 0 ; i < arraySize ; i ++ ) { String name = namesArray [ i ] ; int colonIndex = name . lastIndexOf ( ':' ) ; int lNameStartIdx = colonIndex + 1 ; if ( colonIndex > - 1 ) { newURIsArray [ i ] = name . substring ( 0 , colonIndex ) ; } if ( name . charAt ( lNameStartIdx ) == '@' ) { lNameStartIdx ++ ; newTypesArray [ i ] = DTM . ATTRIBUTE_NODE ; } else if ( name . charAt ( lNameStartIdx ) == '?' ) { lNameStartIdx ++ ; newTypesArray [ i ] = DTM . NAMESPACE_NODE ; } else { newTypesArray [ i ] = DTM . ELEMENT_NODE ; } newNamesArray [ i ] = ( lNameStartIdx == 0 ) ? name : name . substring ( lNameStartIdx ) ; } namesArray = newNamesArray ; urisArray = newURIsArray ; typesArray = newTypesArray ; } if ( transletVersion > CURRENT_TRANSLET_VERSION ) { BasisLibrary . runTimeError ( BasisLibrary . UNKNOWN_TRANSLET_VERSION_ERR , this . getClass ( ) . getName ( ) ) ; } } private Hashtable _keyIndexes = null ; private KeyIndex _emptyKeyIndex = null ; private int _indexSize = 0 ; public void setIndexSize ( int size ) { if ( size > _indexSize ) _indexSize = size ; } public KeyIndex createKeyIndex ( ) { return ( new KeyIndex ( _indexSize ) ) ; } public void buildKeyIndex ( String name , int node , Object value ) { if ( _keyIndexes == null ) _keyIndexes = new Hashtable ( ) ; KeyIndex index = ( KeyIndex ) _keyIndexes . get ( name ) ; if ( index == null ) { _keyIndexes . put ( name , index = new KeyIndex ( _indexSize ) ) ; } index . add ( value , node ) ; } public void buildKeyIndex ( String name , DOM dom ) { if ( _keyIndexes == null ) _keyIndexes = new Hashtable ( ) ; KeyIndex index = ( KeyIndex ) _keyIndexes . get ( name ) ; if ( index == null ) { _keyIndexes . put ( name , index = new KeyIndex ( _indexSize ) ) ; } index . setDom ( dom ) ; } public KeyIndex getKeyIndex ( String name ) { if ( _keyIndexes == null ) { return ( _emptyKeyIndex != null ) ? _emptyKeyIndex : ( _emptyKeyIndex = new KeyIndex ( 1 ) ) ; } final KeyIndex index = ( KeyIndex ) _keyIndexes . get ( name ) ; if ( index == null ) { return ( _emptyKeyIndex != null ) ? _emptyKeyIndex : ( _emptyKeyIndex = new KeyIndex ( 1 ) ) ; } return ( index ) ; } public void buildKeys ( DOM document , DTMAxisIterator iterator , SerializationHandler handler , int root ) throws TransletException { } public void setKeyIndexDom ( String name , DOM document ) { getKeyIndex ( name ) . setDom ( document ) ; } private DOMCache _domCache = null ; public void setDOMCache ( DOMCache cache ) { _domCache = cache ; } public DOMCache getDOMCache ( ) { return ( _domCache ) ; } public SerializationHandler openOutputHandler ( String filename , boolean append ) throws TransletException { try { final TransletOutputHandlerFactory factory = TransletOutputHandlerFactory . newInstance ( ) ; factory . setEncoding ( _encoding ) ; factory . setOutputMethod ( _method ) ; factory . setWriter ( new FileWriter ( filename , append ) ) ; factory . setOutputType ( TransletOutputHandlerFactory . STREAM ) ; final SerializationHandler handler = factory . getSerializationHandler ( ) ; transferOutputSettings ( handler ) ; handler . startDocument ( ) ; return handler ; } catch ( Exception e ) { throw new TransletException ( e ) ; } } public SerializationHandler openOutputHandler ( String filename ) throws TransletException { return openOutputHandler ( filename , false ) ; } public void closeOutputHandler ( SerializationHandler handler ) { try { handler . endDocument ( ) ; handler . close ( ) ; } catch ( Exception e ) { } } public abstract void transform ( DOM document , DTMAxisIterator iterator , SerializationHandler handler ) throws TransletException ; public final void transform ( DOM document , SerializationHandler handler ) throws TransletException { transform ( document , document . getIterator ( ) , handler ) ; } public final void characters ( final String string , SerializationHandler handler ) throws TransletException { if ( string != null ) { try { handler . characters ( string ) ; } catch ( Exception e ) { throw new TransletException ( e ) ; } } } public void addCdataElement ( String name ) { if ( _cdata == null ) { _cdata = new Vector ( ) ; } int lastColon = name . lastIndexOf ( ':' ) ; if ( lastColon > 0 ) { String uri = name . substring ( 0 , lastColon ) ; String localName = name . substring ( lastColon + 1 ) ; _cdata . addElement ( uri ) ; _cdata . addElement ( localName ) ; } else { _cdata . addElement ( null ) ; _cdata . addElement ( name ) ; } } protected void transferOutputSettings ( SerializationHandler handler ) { if ( _method != null ) { if ( _method . equals ( "xml" ) ) { if ( _standalone != null ) { handler . setStandalone ( _standalone ) ; } if ( _omitHeader ) { handler . setOmitXMLDeclaration ( true ) ; } handler . setCdataSectionElements ( _cdata ) ; if ( _version != null ) { handler . setVersion ( _version ) ; } handler . setIndent ( _indent ) ; if ( _doctypeSystem != null ) { handler . setDoctype ( _doctypeSystem , _doctypePublic ) ; } } else if ( _method . equals ( "html" ) ) { handler . setIndent ( _indent ) ; handler . setDoctype ( _doctypeSystem , _doctypePublic ) ; if ( _mediaType != null ) { handler . setMediaType ( _mediaType ) ; } } } else { handler . setCdataSectionElements ( _cdata ) ; if ( _version != null ) { handler . setVersion ( _version ) ; } if ( _standalone != null ) { handler . setStandalone ( _standalone ) ; } if ( _omitHeader ) { handler . setOmitXMLDeclaration ( true ) ; } handler . setIndent ( _indent ) ; handler . setDoctype ( _doctypeSystem , _doctypePublic ) ; } } private Hashtable _auxClasses = null ; public void addAuxiliaryClass ( Class auxClass ) { if ( _auxClasses == null ) _auxClasses = new Hashtable ( ) ; _auxClasses . put ( auxClass . getName ( ) , auxClass ) ; } public void setAuxiliaryClasses ( Hashtable auxClasses ) { _auxClasses = auxClasses ; } public Class getAuxiliaryClass ( String className ) { if ( _auxClasses == null ) return null ; return ( ( Class ) _auxClasses . get ( className ) ) ; } public String [ ] getNamesArray ( ) { return namesArray ; } public String [ ] getUrisArray ( ) { return urisArray ; } public int [ ] getTypesArray ( ) { return typesArray ; } public String [ ] getNamespaceArray ( ) { return namespaceArray ; } public boolean hasIdCall ( ) { return _hasIdCall ; } public Templates getTemplates ( ) { return _templates ; } public void setTemplates ( Templates templates ) { _templates = templates ; } } 	1	['43', '1', '0', '28', '110', '761', '13', '15', '41', '0.941558442', '1052', '0.575757576', '7', '0', '0.146179402', '0', '0', '22.69767442', '12', '2.1628', '2']
package org . apache . xml . dtm ; public abstract class DTMAxisTraverser { public int first ( int context ) { return next ( context , context ) ; } public int first ( int context , int extendedTypeID ) { return next ( context , context , extendedTypeID ) ; } public abstract int next ( int context , int current ) ; public abstract int next ( int context , int current , int extendedTypeID ) ; } 	1	['5', '1', '12', '31', '6', '10', '31', '0', '5', '2', '19', '0', '0', '0', '0.9', '0', '0', '2.8', '1', '0.8', '1']
package org . apache . xpath . objects ; public class XBooleanStatic extends XBoolean { boolean m_val ; public XBooleanStatic ( boolean b ) { super ( b ) ; m_val = b ; } public boolean equals ( XObject obj2 ) { try { return m_val == obj2 . bool ( ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } } 	1	['2', '4', '0', '4', '5', '0', '2', '3', '2', '0', '25', '0', '0', '0.987341772', '0.666666667', '2', '3', '11', '2', '1', '1']
package org . apache . xalan . lib . sql ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintStream ; import javax . xml . transform . SourceLocator ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMDefaultBaseIterators ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . StringBufferPool ; import org . apache . xml . utils . SuballocatedIntVector ; import org . apache . xml . utils . XMLString ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; public class DTMDocument extends DTMDefaultBaseIterators { public interface CharacterNodeHandler { public void characters ( Node node ) throws org . xml . sax . SAXException ; } private boolean DEBUG = false ; protected static final String S_NAMESPACE = "http://xml.apache.org/xalan/SQLExtension" ; protected static final String S_ATTRIB_NOT_SUPPORTED = "Not Supported" ; protected static final String S_ISTRUE = "true" ; protected static final String S_ISFALSE = "false" ; protected static final String S_DOCUMENT = "#root" ; protected static final String S_TEXT_NODE = "#text" ; protected static final String S_ELEMENT_NODE = "#element" ; protected int m_Document_TypeID = 0 ; protected int m_TextNode_TypeID = 0 ; protected ObjectArray m_ObjectArray = new ObjectArray ( ) ; protected SuballocatedIntVector m_attribute ; protected int m_DocumentIdx ; public DTMDocument ( DTMManager mgr , int ident ) { super ( mgr , null , ident , null , mgr . getXMLStringFactory ( ) , true ) ; m_attribute = new SuballocatedIntVector ( DEFAULT_BLOCKSIZE ) ; } private int allocateNodeObject ( Object o ) { m_size ++ ; return m_ObjectArray . append ( o ) ; } protected int addElementWithData ( Object o , int level , int extendedType , int parent , int prevsib ) { int elementIdx = addElement ( level , extendedType , parent , prevsib ) ; int data = allocateNodeObject ( o ) ; m_firstch . setElementAt ( data , elementIdx ) ; m_exptype . setElementAt ( m_TextNode_TypeID , data ) ; m_parent . setElementAt ( elementIdx , data ) ; m_prevsib . setElementAt ( DTM . NULL , data ) ; m_nextsib . setElementAt ( DTM . NULL , data ) ; m_attribute . setElementAt ( DTM . NULL , data ) ; m_firstch . setElementAt ( DTM . NULL , data ) ; return elementIdx ; } protected int addElement ( int level , int extendedType , int parent , int prevsib ) { int node = DTM . NULL ; try { node = allocateNodeObject ( S_ELEMENT_NODE ) ; m_exptype . setElementAt ( extendedType , node ) ; m_nextsib . setElementAt ( DTM . NULL , node ) ; m_prevsib . setElementAt ( prevsib , node ) ; m_parent . setElementAt ( parent , node ) ; m_firstch . setElementAt ( DTM . NULL , node ) ; m_attribute . setElementAt ( DTM . NULL , node ) ; if ( prevsib != DTM . NULL ) { if ( m_nextsib . elementAt ( prevsib ) != DTM . NULL ) m_nextsib . setElementAt ( m_nextsib . elementAt ( prevsib ) , node ) ; m_nextsib . setElementAt ( node , prevsib ) ; } if ( ( parent != DTM . NULL ) && ( m_prevsib . elementAt ( node ) == DTM . NULL ) ) { m_firstch . setElementAt ( node , parent ) ; } } catch ( Exception e ) { error ( "Error in addElement: " + e . getMessage ( ) ) ; } return node ; } protected int addAttributeToNode ( Object o , int extendedType , int pnode ) { int attrib = DTM . NULL ; int prevsib = DTM . NULL ; int lastattrib = DTM . NULL ; int value = DTM . NULL ; try { attrib = allocateNodeObject ( o ) ; m_attribute . setElementAt ( DTM . NULL , attrib ) ; m_exptype . setElementAt ( extendedType , attrib ) ; m_nextsib . setElementAt ( DTM . NULL , attrib ) ; m_prevsib . setElementAt ( DTM . NULL , attrib ) ; m_parent . setElementAt ( pnode , attrib ) ; m_firstch . setElementAt ( DTM . NULL , attrib ) ; if ( m_attribute . elementAt ( pnode ) != DTM . NULL ) { lastattrib = m_attribute . elementAt ( pnode ) ; m_nextsib . setElementAt ( lastattrib , attrib ) ; m_prevsib . setElementAt ( attrib , lastattrib ) ; } m_attribute . setElementAt ( attrib , pnode ) ; } catch ( Exception e ) { error ( "Error in addAttributeToNode: " + e . getMessage ( ) ) ; } return attrib ; } protected void cloneAttributeFromNode ( int toNode , int fromNode ) { try { if ( m_attribute . elementAt ( toNode ) != DTM . NULL ) { error ( "Cloneing Attributes, where from Node already had addtibures assigned" ) ; } m_attribute . setElementAt ( m_attribute . elementAt ( fromNode ) , toNode ) ; } catch ( Exception e ) { error ( "Cloning attributes" ) ; } } public int getFirstAttribute ( int parm1 ) { if ( DEBUG ) System . out . println ( "getFirstAttribute(" + parm1 + ")" ) ; int nodeIdx = makeNodeIdentity ( parm1 ) ; if ( nodeIdx != DTM . NULL ) { int attribIdx = m_attribute . elementAt ( nodeIdx ) ; return makeNodeHandle ( attribIdx ) ; } else return DTM . NULL ; } public String getNodeValue ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNodeValue(" + parm1 + ")" ) ; try { Object o = m_ObjectArray . getAt ( makeNodeIdentity ( parm1 ) ) ; if ( o != null && o != S_ELEMENT_NODE ) { return o . toString ( ) ; } else { return "" ; } } catch ( Exception e ) { error ( "Getting String Value" ) ; return null ; } } public XMLString getStringValue ( int nodeHandle ) { int nodeIdx = makeNodeIdentity ( nodeHandle ) ; if ( DEBUG ) System . out . println ( "getStringValue(" + nodeIdx + ")" ) ; Object o = m_ObjectArray . getAt ( nodeIdx ) ; if ( o == S_ELEMENT_NODE ) { FastStringBuffer buf = StringBufferPool . get ( ) ; String s ; try { getNodeData ( nodeIdx , buf ) ; s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; } finally { StringBufferPool . free ( buf ) ; } return m_xstrf . newstr ( s ) ; } else if ( o != null ) { return m_xstrf . newstr ( o . toString ( ) ) ; } else return ( m_xstrf . emptystr ( ) ) ; } protected void getNodeData ( int nodeIdx , FastStringBuffer buf ) { for ( int child = _firstch ( nodeIdx ) ; child != DTM . NULL ; child = _nextsib ( child ) ) { Object o = m_ObjectArray . getAt ( child ) ; if ( o == S_ELEMENT_NODE ) getNodeData ( child , buf ) ; else if ( o != null ) buf . append ( o . toString ( ) ) ; } } public int getNextAttribute ( int parm1 ) { int nodeIdx = makeNodeIdentity ( parm1 ) ; if ( DEBUG ) System . out . println ( "getNextAttribute(" + nodeIdx + ")" ) ; if ( nodeIdx != DTM . NULL ) return makeNodeHandle ( m_nextsib . elementAt ( nodeIdx ) ) ; else return DTM . NULL ; } protected int getNumberOfNodes ( ) { if ( DEBUG ) System . out . println ( "getNumberOfNodes()" ) ; return m_size ; } protected boolean nextNode ( ) { if ( DEBUG ) System . out . println ( "nextNode()" ) ; return false ; } protected void createExpandedNameTable ( ) { m_Document_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_DOCUMENT , DTM . DOCUMENT_NODE ) ; m_TextNode_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_TEXT_NODE , DTM . TEXT_NODE ) ; } public void dumpDTM ( ) { try { File f = new File ( "DTMDump.txt" ) ; System . err . println ( "Dumping... " + f . getAbsolutePath ( ) ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( f ) ) ; while ( nextNode ( ) ) { } int nRecords = m_size ; ps . println ( "Total nodes: " + nRecords ) ; for ( int i = 0 ; i < nRecords ; i ++ ) { ps . println ( "=========== " + i + " ===========" ) ; ps . println ( "NodeName: " + getNodeName ( makeNodeHandle ( i ) ) ) ; ps . println ( "NodeNameX: " + getNodeNameX ( makeNodeHandle ( i ) ) ) ; ps . println ( "LocalName: " + getLocalName ( makeNodeHandle ( i ) ) ) ; ps . println ( "NamespaceURI: " + getNamespaceURI ( makeNodeHandle ( i ) ) ) ; ps . println ( "Prefix: " + getPrefix ( makeNodeHandle ( i ) ) ) ; int exTypeID = getExpandedTypeID ( makeNodeHandle ( i ) ) ; ps . println ( "Expanded Type ID: " + Integer . toHexString ( exTypeID ) ) ; int type = getNodeType ( makeNodeHandle ( i ) ) ; String typestring ; switch ( type ) { case DTM . ATTRIBUTE_NODE : typestring = "ATTRIBUTE_NODE" ; break ; case DTM . CDATA_SECTION_NODE : typestring = "CDATA_SECTION_NODE" ; break ; case DTM . COMMENT_NODE : typestring = "COMMENT_NODE" ; break ; case DTM . DOCUMENT_FRAGMENT_NODE : typestring = "DOCUMENT_FRAGMENT_NODE" ; break ; case DTM . DOCUMENT_NODE : typestring = "DOCUMENT_NODE" ; break ; case DTM . DOCUMENT_TYPE_NODE : typestring = "DOCUMENT_NODE" ; break ; case DTM . ELEMENT_NODE : typestring = "ELEMENT_NODE" ; break ; case DTM . ENTITY_NODE : typestring = "ENTITY_NODE" ; break ; case DTM . ENTITY_REFERENCE_NODE : typestring = "ENTITY_REFERENCE_NODE" ; break ; case DTM . NAMESPACE_NODE : typestring = "NAMESPACE_NODE" ; break ; case DTM . NOTATION_NODE : typestring = "NOTATION_NODE" ; break ; case DTM . NULL : typestring = "NULL" ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : typestring = "PROCESSING_INSTRUCTION_NODE" ; break ; case DTM . TEXT_NODE : typestring = "TEXT_NODE" ; break ; default : typestring = "Unknown!" ; break ; } ps . println ( "Type: " + typestring ) ; int firstChild = _firstch ( i ) ; if ( DTM . NULL == firstChild ) ps . println ( "First child: DTM.NULL" ) ; else if ( NOTPROCESSED == firstChild ) ps . println ( "First child: NOTPROCESSED" ) ; else ps . println ( "First child: " + firstChild ) ; int prevSibling = _prevsib ( i ) ; if ( DTM . NULL == prevSibling ) ps . println ( "Prev sibling: DTM.NULL" ) ; else if ( NOTPROCESSED == prevSibling ) ps . println ( "Prev sibling: NOTPROCESSED" ) ; else ps . println ( "Prev sibling: " + prevSibling ) ; int nextSibling = _nextsib ( i ) ; if ( DTM . NULL == nextSibling ) ps . println ( "Next sibling: DTM.NULL" ) ; else if ( NOTPROCESSED == nextSibling ) ps . println ( "Next sibling: NOTPROCESSED" ) ; else ps . println ( "Next sibling: " + nextSibling ) ; int parent = _parent ( i ) ; if ( DTM . NULL == parent ) ps . println ( "Parent: DTM.NULL" ) ; else if ( NOTPROCESSED == parent ) ps . println ( "Parent: NOTPROCESSED" ) ; else ps . println ( "Parent: " + parent ) ; int level = _level ( i ) ; ps . println ( "Level: " + level ) ; ps . println ( "Node Value: " + getNodeValue ( i ) ) ; ps . println ( "String Value: " + getStringValue ( i ) ) ; ps . println ( "First Attribute Node: " + m_attribute . elementAt ( i ) ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( System . err ) ; System . exit ( - 1 ) ; } } protected static void dispatchNodeData ( Node node , ContentHandler ch , int depth ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { dispatchNodeData ( child , ch , depth + 1 ) ; } } break ; case Node . PROCESSING_INSTRUCTION_NODE : case Node . COMMENT_NODE : if ( 0 != depth ) break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : case Node . ATTRIBUTE_NODE : String str = node . getNodeValue ( ) ; if ( ch instanceof CharacterNodeHandler ) { ( ( CharacterNodeHandler ) ch ) . characters ( node ) ; } else { ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } break ; default : break ; } } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { return null ; } protected int getNextNodeIdentity ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNextNodeIdenty(" + parm1 + ")" ) ; return DTM . NULL ; } public int getAttributeNode ( int parm1 , String parm2 , String parm3 ) { if ( DEBUG ) { System . out . println ( "getAttributeNode(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } return DTM . NULL ; } public String getLocalName ( int parm1 ) { int exID = getExpandedTypeID ( parm1 ) ; if ( DEBUG ) { DEBUG = false ; System . out . print ( "getLocalName(" + parm1 + ") -> " ) ; System . out . println ( "..." + getLocalNameFromExpandedNameID ( exID ) ) ; DEBUG = true ; } return getLocalNameFromExpandedNameID ( exID ) ; } public String getNodeName ( int parm1 ) { int exID = getExpandedTypeID ( parm1 ) ; if ( DEBUG ) { DEBUG = false ; System . out . print ( "getLocalName(" + parm1 + ") -> " ) ; System . out . println ( "..." + getLocalNameFromExpandedNameID ( exID ) ) ; DEBUG = true ; } return getLocalNameFromExpandedNameID ( exID ) ; } public boolean isAttributeSpecified ( int parm1 ) { if ( DEBUG ) System . out . println ( "isAttributeSpecified(" + parm1 + ")" ) ; return false ; } public String getUnparsedEntityURI ( String parm1 ) { if ( DEBUG ) System . out . println ( "getUnparsedEntityURI(" + parm1 + ")" ) ; return "" ; } public DTDHandler getDTDHandler ( ) { if ( DEBUG ) System . out . println ( "getDTDHandler()" ) ; return null ; } public String getPrefix ( int parm1 ) { if ( DEBUG ) System . out . println ( "getPrefix(" + parm1 + ")" ) ; return "" ; } public EntityResolver getEntityResolver ( ) { if ( DEBUG ) System . out . println ( "getEntityResolver()" ) ; return null ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { if ( DEBUG ) System . out . println ( "get_DTD_PubId()" ) ; return "" ; } public LexicalHandler getLexicalHandler ( ) { if ( DEBUG ) System . out . println ( "getLexicalHandler()" ) ; return null ; } public boolean needsTwoThreads ( ) { if ( DEBUG ) System . out . println ( "needsTwoThreads()" ) ; return false ; } public ContentHandler getContentHandler ( ) { if ( DEBUG ) System . out . println ( "getContentHandler()" ) ; return null ; } public void dispatchToEvents ( int parm1 , ContentHandler parm2 ) throws org . xml . sax . SAXException { if ( DEBUG ) { System . out . println ( "dispathcToEvents(" + parm1 + "," + parm2 + ")" ) ; } return ; } public String getNamespaceURI ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNamespaceURI(" + parm1 + ")" ) ; return "" ; } public void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { if ( DEBUG ) { System . out . println ( "dispatchCharacterEvents(" + nodeHandle + "," + ch + "," + normalize + ")" ) ; } if ( normalize ) { XMLString str = getStringValue ( nodeHandle ) ; str = str . fixWhiteSpace ( true , true , false ) ; str . dispatchCharactersEvents ( ch ) ; } else { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; dispatchNodeData ( node , ch , 0 ) ; } } public boolean supportsPreStripping ( ) { if ( DEBUG ) System . out . println ( "supportsPreStripping()" ) ; return super . supportsPreStripping ( ) ; } protected int _exptype ( int parm1 ) { if ( DEBUG ) System . out . println ( "_exptype(" + parm1 + ")" ) ; return super . _exptype ( parm1 ) ; } protected SuballocatedIntVector findNamespaceContext ( int parm1 ) { if ( DEBUG ) System . out . println ( "SuballocatedIntVector(" + parm1 + ")" ) ; return super . findNamespaceContext ( parm1 ) ; } protected int _prevsib ( int parm1 ) { if ( DEBUG ) System . out . println ( "_prevsib(" + parm1 + ")" ) ; return super . _prevsib ( parm1 ) ; } protected short _type ( int parm1 ) { if ( DEBUG ) System . out . println ( "_type(" + parm1 + ")" ) ; return super . _type ( parm1 ) ; } public Node getNode ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNode(" + parm1 + ")" ) ; return super . getNode ( parm1 ) ; } public int getPreviousSibling ( int parm1 ) { if ( DEBUG ) System . out . println ( "getPrevSib(" + parm1 + ")" ) ; return super . getPreviousSibling ( parm1 ) ; } public String getDocumentStandalone ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDOcStandAlone(" + parm1 + ")" ) ; return super . getDocumentStandalone ( parm1 ) ; } public String getNodeNameX ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNodeNameX(" + parm1 + ")" ) ; return getNodeName ( parm1 ) ; } public void setFeature ( String parm1 , boolean parm2 ) { if ( DEBUG ) { System . out . println ( "setFeature(" + parm1 + "," + parm2 + ")" ) ; } super . setFeature ( parm1 , parm2 ) ; } protected int _parent ( int parm1 ) { if ( DEBUG ) System . out . println ( "_parent(" + parm1 + ")" ) ; return super . _parent ( parm1 ) ; } protected void indexNode ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "indexNode(" + parm1 + "," + parm2 + ")" ) ; super . indexNode ( parm1 , parm2 ) ; } protected boolean getShouldStripWhitespace ( ) { if ( DEBUG ) System . out . println ( "getShouldStripWS()" ) ; return super . getShouldStripWhitespace ( ) ; } protected void popShouldStripWhitespace ( ) { if ( DEBUG ) System . out . println ( "popShouldStripWS()" ) ; super . popShouldStripWhitespace ( ) ; } public boolean isNodeAfter ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "isNodeAfter(" + parm1 + "," + parm2 + ")" ) ; return super . isNodeAfter ( parm1 , parm2 ) ; } public int getNamespaceType ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNamespaceType(" + parm1 + ")" ) ; return super . getNamespaceType ( parm1 ) ; } protected int _level ( int parm1 ) { if ( DEBUG ) System . out . println ( "_level(" + parm1 + ")" ) ; return super . _level ( parm1 ) ; } protected void pushShouldStripWhitespace ( boolean parm1 ) { if ( DEBUG ) System . out . println ( "push_ShouldStripWS(" + parm1 + ")" ) ; super . pushShouldStripWhitespace ( parm1 ) ; } public String getDocumentVersion ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDocVer(" + parm1 + ")" ) ; return super . getDocumentVersion ( parm1 ) ; } public boolean isSupported ( String parm1 , String parm2 ) { if ( DEBUG ) System . out . println ( "isSupported(" + parm1 + "," + parm2 + ")" ) ; return super . isSupported ( parm1 , parm2 ) ; } protected void setShouldStripWhitespace ( boolean parm1 ) { if ( DEBUG ) System . out . println ( "set_ShouldStripWS(" + parm1 + ")" ) ; super . setShouldStripWhitespace ( parm1 ) ; } protected void ensureSizeOfIndex ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "ensureSizeOfIndex(" + parm1 + "," + parm2 + ")" ) ; super . ensureSizeOfIndex ( parm1 , parm2 ) ; } protected void ensureSize ( int parm1 ) { if ( DEBUG ) System . out . println ( "ensureSize(" + parm1 + ")" ) ; } public String getDocumentEncoding ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDocumentEncoding(" + parm1 + ")" ) ; return super . getDocumentEncoding ( parm1 ) ; } public void appendChild ( int parm1 , boolean parm2 , boolean parm3 ) { if ( DEBUG ) { System . out . println ( "appendChild(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } super . appendChild ( parm1 , parm2 , parm3 ) ; } public short getLevel ( int parm1 ) { if ( DEBUG ) System . out . println ( "getLevel(" + parm1 + ")" ) ; return super . getLevel ( parm1 ) ; } public String getDocumentBaseURI ( ) { if ( DEBUG ) System . out . println ( "getDocBaseURI()" ) ; return super . getDocumentBaseURI ( ) ; } public int getNextNamespaceNode ( int parm1 , int parm2 , boolean parm3 ) { if ( DEBUG ) { System . out . println ( "getNextNamesapceNode(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } return super . getNextNamespaceNode ( parm1 , parm2 , parm3 ) ; } public void appendTextChild ( String parm1 ) { if ( DEBUG ) System . out . println ( "appendTextChild(" + parm1 + ")" ) ; super . appendTextChild ( parm1 ) ; } protected int findGTE ( int [ ] parm1 , int parm2 , int parm3 , int parm4 ) { if ( DEBUG ) { System . out . println ( "findGTE(" + parm1 + "," + parm2 + "," + parm3 + ")" ) ; } return super . findGTE ( parm1 , parm2 , parm3 , parm4 ) ; } public int getFirstNamespaceNode ( int parm1 , boolean parm2 ) { if ( DEBUG ) System . out . println ( "getFirstNamespaceNode()" ) ; return super . getFirstNamespaceNode ( parm1 , parm2 ) ; } public int getStringValueChunkCount ( int parm1 ) { if ( DEBUG ) System . out . println ( "getStringChunkCount(" + parm1 + ")" ) ; return super . getStringValueChunkCount ( parm1 ) ; } public int getLastChild ( int parm1 ) { if ( DEBUG ) System . out . println ( "getLastChild(" + parm1 + ")" ) ; return super . getLastChild ( parm1 ) ; } public boolean hasChildNodes ( int parm1 ) { if ( DEBUG ) System . out . println ( "hasChildNodes(" + parm1 + ")" ) ; return super . hasChildNodes ( parm1 ) ; } public short getNodeType ( int parm1 ) { if ( DEBUG ) { DEBUG = false ; System . out . print ( "getNodeType(" + parm1 + ") " ) ; int exID = getExpandedTypeID ( parm1 ) ; String name = getLocalNameFromExpandedNameID ( exID ) ; System . out . println ( ".. Node name [" + name + "]" + "[" + getNodeType ( parm1 ) + "]" ) ; DEBUG = true ; } return super . getNodeType ( parm1 ) ; } public boolean isCharacterElementContentWhitespace ( int parm1 ) { if ( DEBUG ) System . out . println ( "isCharacterElementContentWhitespace(" + parm1 + ")" ) ; return super . isCharacterElementContentWhitespace ( parm1 ) ; } public int getFirstChild ( int parm1 ) { if ( DEBUG ) System . out . println ( "getFirstChild(" + parm1 + ")" ) ; return super . getFirstChild ( parm1 ) ; } public String getDocumentSystemIdentifier ( int parm1 ) { if ( DEBUG ) System . out . println ( "getDocSysID(" + parm1 + ")" ) ; return super . getDocumentSystemIdentifier ( parm1 ) ; } protected void declareNamespaceInContext ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "declareNamespaceContext(" + parm1 + "," + parm2 + ")" ) ; super . declareNamespaceInContext ( parm1 , parm2 ) ; } public String getNamespaceFromExpandedNameID ( int parm1 ) { if ( DEBUG ) { DEBUG = false ; System . out . print ( "getNamespaceFromExpandedNameID(" + parm1 + ")" ) ; System . out . println ( "..." + super . getNamespaceFromExpandedNameID ( parm1 ) ) ; DEBUG = true ; } return super . getNamespaceFromExpandedNameID ( parm1 ) ; } public String getLocalNameFromExpandedNameID ( int parm1 ) { if ( DEBUG ) { DEBUG = false ; System . out . print ( "getLocalNameFromExpandedNameID(" + parm1 + ")" ) ; System . out . println ( "..." + super . getLocalNameFromExpandedNameID ( parm1 ) ) ; DEBUG = true ; } return super . getLocalNameFromExpandedNameID ( parm1 ) ; } public int getExpandedTypeID ( int parm1 ) { if ( DEBUG ) System . out . println ( "getExpandedTypeID(" + parm1 + ")" ) ; return super . getExpandedTypeID ( parm1 ) ; } public int getDocument ( ) { if ( DEBUG ) System . out . println ( "getDocument()" ) ; return super . getDocument ( ) ; } protected int findInSortedSuballocatedIntVector ( SuballocatedIntVector parm1 , int parm2 ) { if ( DEBUG ) { System . out . println ( "findInSortedSubAlloctedVector(" + parm1 + "," + parm2 + ")" ) ; } return super . findInSortedSuballocatedIntVector ( parm1 , parm2 ) ; } public boolean isDocumentAllDeclarationsProcessed ( int parm1 ) { if ( DEBUG ) System . out . println ( "isDocumentAllDeclProc(" + parm1 + ")" ) ; return super . isDocumentAllDeclarationsProcessed ( parm1 ) ; } protected void error ( String parm1 ) { if ( DEBUG ) System . out . println ( "error(" + parm1 + ")" ) ; super . error ( parm1 ) ; } protected int _firstch ( int parm1 ) { if ( DEBUG ) System . out . println ( "_firstch(" + parm1 + ")" ) ; return super . _firstch ( parm1 ) ; } public int getOwnerDocument ( int parm1 ) { if ( DEBUG ) System . out . println ( "getOwnerDoc(" + parm1 + ")" ) ; return super . getOwnerDocument ( parm1 ) ; } protected int _nextsib ( int parm1 ) { if ( DEBUG ) System . out . println ( "_nextSib(" + parm1 + ")" ) ; return super . _nextsib ( parm1 ) ; } public int getNextSibling ( int parm1 ) { if ( DEBUG ) System . out . println ( "getNextSibling(" + parm1 + ")" ) ; return super . getNextSibling ( parm1 ) ; } public boolean getDocumentAllDeclarationsProcessed ( ) { if ( DEBUG ) System . out . println ( "getDocAllDeclProc()" ) ; return super . getDocumentAllDeclarationsProcessed ( ) ; } public int getParent ( int parm1 ) { if ( DEBUG ) System . out . println ( "getParent(" + parm1 + ")" ) ; return super . getParent ( parm1 ) ; } public int getExpandedTypeID ( String parm1 , String parm2 , int parm3 ) { if ( DEBUG ) System . out . println ( "getExpandedTypeID()" ) ; return super . getExpandedTypeID ( parm1 , parm2 , parm3 ) ; } public void setDocumentBaseURI ( String parm1 ) { if ( DEBUG ) System . out . println ( "setDocBaseURI()" ) ; super . setDocumentBaseURI ( parm1 ) ; } public char [ ] getStringValueChunk ( int parm1 , int parm2 , int [ ] parm3 ) { if ( DEBUG ) { System . out . println ( "getStringChunkValue(" + parm1 + "," + parm2 + ")" ) ; } return super . getStringValueChunk ( parm1 , parm2 , parm3 ) ; } public DTMAxisTraverser getAxisTraverser ( int parm1 ) { if ( DEBUG ) System . out . println ( "getAxixTraverser(" + parm1 + ")" ) ; return super . getAxisTraverser ( parm1 ) ; } public DTMAxisIterator getTypedAxisIterator ( int parm1 , int parm2 ) { if ( DEBUG ) System . out . println ( "getTypedAxisIterator(" + parm1 + "," + parm2 + ")" ) ; return super . getTypedAxisIterator ( parm1 , parm2 ) ; } public DTMAxisIterator getAxisIterator ( int parm1 ) { if ( DEBUG ) System . out . println ( "getAxisIterator(" + parm1 + ")" ) ; return super . getAxisIterator ( parm1 ) ; } public int getElementById ( String parm1 ) { if ( DEBUG ) System . out . println ( "getElementByID(" + parm1 + ")" ) ; return DTM . NULL ; } public DeclHandler getDeclHandler ( ) { if ( DEBUG ) System . out . println ( "getDeclHandler()" ) ; return null ; } public ErrorHandler getErrorHandler ( ) { if ( DEBUG ) System . out . println ( "getErrorHandler()" ) ; return null ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { if ( DEBUG ) System . out . println ( "get_DTD-SID()" ) ; return null ; } } 	1	['96', '4', '2', '15', '197', '0', '2', '13', '66', '0.919838057', '2568', '1', '2', '0.497354497', '0.180871212', '1', '26', '25.61458333', '11', '2.0938', '2']
package org . apache . xalan . xsltc . compiler ; import java . util . ArrayList ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . FilterGenerator ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NumberType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . TestGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Predicate extends Expression implements Closure { private Expression _exp = null ; private boolean _canOptimize = true ; private boolean _nthPositionFilter = false ; private boolean _nthDescendant = false ; int _ptype = - 1 ; private String _className = null ; private ArrayList _closureVars = null ; private Closure _parentClosure = null ; private Expression _value = null ; private Step _step = null ; public Predicate ( Expression exp ) { _exp = exp ; _exp . setParent ( this ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _exp . setParser ( parser ) ; } public boolean isNthPositionFilter ( ) { return _nthPositionFilter ; } public boolean isNthDescendant ( ) { return _nthDescendant ; } public void dontOptimize ( ) { _canOptimize = false ; } public boolean hasPositionCall ( ) { return _exp . hasPositionCall ( ) ; } public boolean hasLastCall ( ) { return _exp . hasLastCall ( ) ; } public boolean inInnerClass ( ) { return ( _className != null ) ; } public Closure getParentClosure ( ) { if ( _parentClosure == null ) { SyntaxTreeNode node = getParent ( ) ; do { if ( node instanceof Closure ) { _parentClosure = ( Closure ) node ; break ; } if ( node instanceof TopLevelElement ) { break ; } node = node . getParent ( ) ; } while ( node != null ) ; } return _parentClosure ; } public String getInnerClassName ( ) { return _className ; } public void addVariable ( VariableRefBase variableRef ) { if ( _closureVars == null ) { _closureVars = new ArrayList ( ) ; } if ( ! _closureVars . contains ( variableRef ) ) { _closureVars . add ( variableRef ) ; Closure parentClosure = getParentClosure ( ) ; if ( parentClosure != null ) { parentClosure . addVariable ( variableRef ) ; } } } public int getPosType ( ) { if ( _ptype == - 1 ) { SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof StepPattern ) { _ptype = ( ( StepPattern ) parent ) . getNodeType ( ) ; } else if ( parent instanceof AbsoluteLocationPath ) { AbsoluteLocationPath path = ( AbsoluteLocationPath ) parent ; Expression exp = path . getPath ( ) ; if ( exp instanceof Step ) { _ptype = ( ( Step ) exp ) . getNodeType ( ) ; } } else if ( parent instanceof VariableRefBase ) { final VariableRefBase ref = ( VariableRefBase ) parent ; final VariableBase var = ref . getVariable ( ) ; final Expression exp = var . getExpression ( ) ; if ( exp instanceof Step ) { _ptype = ( ( Step ) exp ) . getNodeType ( ) ; } } else if ( parent instanceof Step ) { _ptype = ( ( Step ) parent ) . getNodeType ( ) ; } } return _ptype ; } public boolean parentIsPattern ( ) { return ( getParent ( ) instanceof Pattern ) ; } public Expression getExpr ( ) { return _exp ; } public String toString ( ) { return "pred(" + _exp + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type texp = _exp . typeCheck ( stable ) ; if ( texp instanceof ReferenceType ) { _exp = new CastExpr ( _exp , texp = Type . Real ) ; } if ( texp instanceof ResultTreeType ) { _exp = new CastExpr ( _exp , Type . Boolean ) ; _exp = new CastExpr ( _exp , Type . Real ) ; texp = _exp . typeCheck ( stable ) ; } if ( texp instanceof NumberType ) { if ( texp instanceof IntType == false ) { _exp = new CastExpr ( _exp , Type . Int ) ; } if ( _canOptimize ) { _nthPositionFilter = ! _exp . hasLastCall ( ) && ! _exp . hasPositionCall ( ) ; if ( _nthPositionFilter ) { SyntaxTreeNode parent = getParent ( ) ; _nthDescendant = ( parent instanceof Step ) && ( parent . getParent ( ) instanceof AbsoluteLocationPath ) ; return _type = Type . NodeSet ; } } _nthPositionFilter = _nthDescendant = false ; final QName position = getParser ( ) . getQNameIgnoreDefaultNs ( "position" ) ; final PositionCall positionCall = new PositionCall ( position ) ; positionCall . setParser ( getParser ( ) ) ; positionCall . setParent ( this ) ; _exp = new EqualityExpr ( EqualityExpr . EQ , positionCall , _exp ) ; if ( _exp . typeCheck ( stable ) != Type . Boolean ) { _exp = new CastExpr ( _exp , Type . Boolean ) ; } return _type = Type . Boolean ; } else { if ( texp instanceof BooleanType == false ) { _exp = new CastExpr ( _exp , Type . Boolean ) ; } return _type = Type . Boolean ; } } private void compileFilter ( ClassGenerator classGen , MethodGenerator methodGen ) { TestGenerator testGen ; LocalVariableGen local ; FilterGenerator filterGen ; _className = getXSLTC ( ) . getHelperClassName ( ) ; filterGen = new FilterGenerator ( _className , "java.lang.Object" , toString ( ) , ACC_PUBLIC | ACC_SUPER , new String [ ] { CURRENT_NODE_LIST_FILTER } , classGen . getStylesheet ( ) ) ; final ConstantPoolGen cpg = filterGen . getConstantPool ( ) ; final int length = ( _closureVars == null ) ? 0 : _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { VariableBase var = ( ( VariableRefBase ) _closureVars . get ( i ) ) . getVariable ( ) ; filterGen . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getEscapedName ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; } final InstructionList il = new InstructionList ( ) ; testGen = new TestGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , Util . getJCRefType ( TRANSLET_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) } , new String [ ] { "node" , "position" , "last" , "current" , "translet" , "iterator" } , "test" , _className , il , cpg ) ; local = testGen . addLocalVariable ( "document" , Util . getJCRefType ( DOM_INTF_SIG ) , null , null ) ; final String className = classGen . getClassName ( ) ; il . append ( filterGen . loadTranslet ( ) ) ; il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( className , DOM_FIELD , DOM_INTF_SIG ) ) ) ; il . append ( new ASTORE ( local . getIndex ( ) ) ) ; testGen . setDomIndex ( local . getIndex ( ) ) ; _exp . translate ( filterGen , testGen ) ; il . append ( IRETURN ) ; testGen . stripAttributes ( true ) ; testGen . setMaxLocals ( ) ; testGen . setMaxStack ( ) ; testGen . removeNOPs ( ) ; filterGen . addEmptyConstructor ( ACC_PUBLIC ) ; filterGen . addMethod ( testGen . getMethod ( ) ) ; getXSLTC ( ) . dumpClass ( filterGen . getJavaClass ( ) ) ; } public boolean isBooleanTest ( ) { return ( _exp instanceof BooleanExpr ) ; } public boolean isNodeValueTest ( ) { if ( ! _canOptimize ) return false ; return ( getStep ( ) != null && getCompareValue ( ) != null ) ; } public Step getStep ( ) { if ( _step != null ) { return _step ; } if ( _exp == null ) { return null ; } if ( _exp instanceof EqualityExpr ) { EqualityExpr exp = ( EqualityExpr ) _exp ; Expression left = exp . getLeft ( ) ; Expression right = exp . getRight ( ) ; if ( left instanceof CastExpr ) { left = ( ( CastExpr ) left ) . getExpr ( ) ; } if ( left instanceof Step ) { _step = ( Step ) left ; } if ( right instanceof CastExpr ) { right = ( ( CastExpr ) right ) . getExpr ( ) ; } if ( right instanceof Step ) { _step = ( Step ) right ; } } return _step ; } public Expression getCompareValue ( ) { if ( _value != null ) { return _value ; } if ( _exp == null ) { return null ; } if ( _exp instanceof EqualityExpr ) { EqualityExpr exp = ( EqualityExpr ) _exp ; Expression left = exp . getLeft ( ) ; Expression right = exp . getRight ( ) ; if ( left instanceof LiteralExpr ) { _value = left ; return _value ; } if ( left instanceof VariableRefBase && left . getType ( ) == Type . String ) { _value = left ; return _value ; } if ( right instanceof LiteralExpr ) { _value = right ; return _value ; } if ( right instanceof VariableRefBase && right . getType ( ) == Type . String ) { _value = right ; return _value ; } } return null ; } public void translateFilter ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; compileFilter ( classGen , methodGen ) ; il . append ( new NEW ( cpg . addClass ( _className ) ) ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( _className , "<init>" , "()V" ) ) ) ; final int length = ( _closureVars == null ) ? 0 : _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { VariableRefBase varRef = ( VariableRefBase ) _closureVars . get ( i ) ; VariableBase var = varRef . getVariable ( ) ; Type varType = var . getType ( ) ; il . append ( DUP ) ; Closure variableClosure = _parentClosure ; while ( variableClosure != null ) { if ( variableClosure . inInnerClass ( ) ) break ; variableClosure = variableClosure . getParentClosure ( ) ; } if ( variableClosure != null ) { il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( variableClosure . getInnerClassName ( ) , var . getEscapedName ( ) , varType . toSignature ( ) ) ) ) ; } else { il . append ( var . loadInstruction ( ) ) ; } il . append ( new PUTFIELD ( cpg . addFieldref ( _className , var . getEscapedName ( ) , varType . toSignature ( ) ) ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _nthPositionFilter || _nthDescendant ) { _exp . translate ( classGen , methodGen ) ; } else if ( isNodeValueTest ( ) && ( getParent ( ) instanceof Step ) ) { _value . translate ( classGen , methodGen ) ; il . append ( new CHECKCAST ( cpg . addClass ( STRING_CLASS ) ) ) ; il . append ( new PUSH ( cpg , ( ( EqualityExpr ) _exp ) . getOp ( ) ) ) ; } else { translateFilter ( classGen , methodGen ) ; } } } 	1	['23', '3', '0', '57', '107', '69', '4', '55', '22', '0.804545455', '948', '0.9', '4', '0.76344086', '0.204968944', '2', '8', '39.7826087', '10', '2.8261', '1']
package org . apache . xalan . templates ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xpath . XPathContext ; public class AVTPartSimple extends AVTPart { private String m_val ; public AVTPartSimple ( String val ) { m_val = val ; } public String getSimpleString ( ) { return m_val ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } public void evaluate ( XPathContext xctxt , FastStringBuffer buf , int context , org . apache . xml . utils . PrefixResolver nsNode ) { buf . append ( m_val ) ; } public void callVisitors ( XSLTVisitor visitor ) { } } 	1	['5', '2', '0', '6', '7', '4', '1', '5', '5', '0.5', '22', '1', '0', '0.555555556', '0.325', '0', '0', '3.2', '1', '0.8', '1']
package org . apache . xalan . trace ; import org . apache . xalan . transformer . TransformerImpl ; import org . xml . sax . Attributes ; public class GenerateEvent implements java . util . EventListener { public TransformerImpl m_processor ; public int m_eventtype ; public char m_characters [ ] ; public int m_start ; public int m_length ; public String m_name ; public String m_data ; public Attributes m_atts ; public GenerateEvent ( TransformerImpl processor , int eventType ) { m_processor = processor ; m_eventtype = eventType ; } public GenerateEvent ( TransformerImpl processor , int eventType , String name , Attributes atts ) { m_name = name ; m_atts = atts ; m_processor = processor ; m_eventtype = eventType ; } public GenerateEvent ( TransformerImpl processor , int eventType , char ch [ ] , int start , int length ) { m_characters = ch ; m_start = start ; m_length = length ; m_processor = processor ; m_eventtype = eventType ; } public GenerateEvent ( TransformerImpl processor , int eventType , String name , String data ) { m_name = name ; m_data = data ; m_processor = processor ; m_eventtype = eventType ; } public GenerateEvent ( TransformerImpl processor , int eventType , String data ) { m_data = data ; m_processor = processor ; m_eventtype = eventType ; } } 	1	['5', '1', '0', '4', '6', '0', '4', '1', '5', '0.6875', '82', '0', '1', '0', '0.666666667', '0', '0', '13.8', '0', '0', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . w3c . dom . DOMException ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; public class DTMNamedNodeMap implements NamedNodeMap { DTM dtm ; int element ; short m_count = - 1 ; public DTMNamedNodeMap ( DTM dtm , int element ) { this . dtm = dtm ; this . element = element ; } public int getLength ( ) { if ( m_count == - 1 ) { short count = 0 ; for ( int n = dtm . getFirstAttribute ( element ) ; n != - 1 ; n = dtm . getNextAttribute ( n ) ) { ++ count ; } m_count = count ; } return ( int ) m_count ; } public Node getNamedItem ( String name ) { for ( int n = dtm . getFirstAttribute ( element ) ; n != - 1 ; n = dtm . getNextAttribute ( n ) ) { if ( dtm . getNodeName ( n ) . equals ( name ) ) return dtm . getNode ( n ) ; } return null ; } public Node item ( int i ) { int count = 0 ; for ( int n = dtm . getFirstAttribute ( element ) ; n != - 1 ; n = dtm . getNextAttribute ( n ) ) { if ( count == i ) return dtm . getNode ( n ) ; else ++ count ; } return null ; } public Node setNamedItem ( Node newNode ) { throw new DTMException ( DTMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public Node removeNamedItem ( String name ) { throw new DTMException ( DTMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public Node getNamedItemNS ( String namespaceURI , String localName ) { throw new DTMException ( DTMException . NOT_SUPPORTED_ERR ) ; } public Node setNamedItemNS ( Node arg ) throws DOMException { throw new DTMException ( DTMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public Node removeNamedItemNS ( String namespaceURI , String localName ) throws DOMException { throw new DTMException ( DTMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public class DTMException extends org . w3c . dom . DOMException { public DTMException ( short code , String message ) { super ( code , message ) ; } public DTMException ( short code ) { super ( code , "" ) ; } } } 	1	['9', '1', '0', '3', '16', '24', '2', '2', '9', '0.708333333', '143', '0', '1', '0', '0.4', '0', '0', '14.55555556', '3', '1.5556', '2']
package org . apache . xml . utils ; public class NSInfo { public NSInfo ( boolean hasProcessedNS , boolean hasXMLNSAttrs ) { m_hasProcessedNS = hasProcessedNS ; m_hasXMLNSAttrs = hasXMLNSAttrs ; m_namespace = null ; m_ancestorHasXMLNSAttrs = ANCESTORXMLNSUNPROCESSED ; } public NSInfo ( boolean hasProcessedNS , boolean hasXMLNSAttrs , int ancestorHasXMLNSAttrs ) { m_hasProcessedNS = hasProcessedNS ; m_hasXMLNSAttrs = hasXMLNSAttrs ; m_ancestorHasXMLNSAttrs = ancestorHasXMLNSAttrs ; m_namespace = null ; } public NSInfo ( String namespace , boolean hasXMLNSAttrs ) { m_hasProcessedNS = true ; m_hasXMLNSAttrs = hasXMLNSAttrs ; m_namespace = namespace ; m_ancestorHasXMLNSAttrs = ANCESTORXMLNSUNPROCESSED ; } public String m_namespace ; public boolean m_hasXMLNSAttrs ; public boolean m_hasProcessedNS ; public int m_ancestorHasXMLNSAttrs ; public static final int ANCESTORXMLNSUNPROCESSED = 0 ; public static final int ANCESTORHASXMLNS = 1 ; public static final int ANCESTORNOXMLNS = 2 ; } 	1	['3', '1', '0', '1', '4', '0', '1', '0', '3', '0.642857143', '55', '0', '0', '0', '0.666666667', '0', '0', '15', '0', '0', '1']
package org . apache . xalan . xsltc . compiler ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionConstants ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . InvokeInstruction ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ANEWARRAY ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ACONST_NULL ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . MultiHashtable ; import org . apache . xalan . xsltc . compiler . util . ObjectType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; class FunctionCall extends Expression { private QName _fname ; private final Vector _arguments ; private final static Vector EMPTY_ARG_LIST = new Vector ( 0 ) ; protected final static String EXT_XSLTC = TRANSLET_URI ; protected final static String JAVA_EXT_XSLTC = EXT_XSLTC + "/java" ; protected final static String EXT_XALAN = "http://xml.apache.org/xalan" ; protected final static String JAVA_EXT_XALAN = "http://xml.apache.org/xalan/java" ; protected final static String JAVA_EXT_XALAN_OLD = "http://xml.apache.org/xslt/java" ; protected final static String EXSLT_COMMON = "http://exslt.org/common" ; protected final static String EXSLT_MATH = "http://exslt.org/math" ; protected final static String EXSLT_SETS = "http://exslt.org/sets" ; protected final static String EXSLT_DATETIME = "http://exslt.org/dates-and-times" ; protected final static String EXSLT_STRINGS = "http://exslt.org/strings" ; protected final static int NAMESPACE_FORMAT_JAVA = 0 ; protected final static int NAMESPACE_FORMAT_CLASS = 1 ; protected final static int NAMESPACE_FORMAT_PACKAGE = 2 ; protected final static int NAMESPACE_FORMAT_CLASS_OR_PACKAGE = 3 ; private int _namespace_format = NAMESPACE_FORMAT_JAVA ; Expression _thisArgument = null ; private String _className ; private Class _clazz ; private Method _chosenMethod ; private Constructor _chosenConstructor ; private MethodType _chosenMethodType ; private boolean unresolvedExternal ; private boolean _isExtConstructor = false ; private boolean _isStatic = false ; private boolean resolveDynamic = false ; private static final MultiHashtable _internal2Java = new MultiHashtable ( ) ; private static final Hashtable _java2Internal = new Hashtable ( ) ; private static final Hashtable _extensionNamespaceTable = new Hashtable ( ) ; private static final Hashtable _extensionFunctionTable = new Hashtable ( ) ; static class JavaType { public Class type ; public int distance ; public JavaType ( Class type , int distance ) { this . type = type ; this . distance = distance ; } public boolean equals ( Object query ) { return query . equals ( type ) ; } } static { try { final Class nodeClass = Class . forName ( "org.w3c.dom.Node" ) ; final Class nodeListClass = Class . forName ( "org.w3c.dom.NodeList" ) ; _internal2Java . put ( Type . Boolean , new JavaType ( Boolean . TYPE , 0 ) ) ; _internal2Java . put ( Type . Boolean , new JavaType ( Boolean . class , 1 ) ) ; _internal2Java . put ( Type . Boolean , new JavaType ( Object . class , 2 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Double . TYPE , 0 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Double . class , 1 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Float . TYPE , 2 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Long . TYPE , 3 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Integer . TYPE , 4 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Short . TYPE , 5 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Byte . TYPE , 6 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Character . TYPE , 7 ) ) ; _internal2Java . put ( Type . Real , new JavaType ( Object . class , 8 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Double . TYPE , 0 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Double . class , 1 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Float . TYPE , 2 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Long . TYPE , 3 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Integer . TYPE , 4 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Short . TYPE , 5 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Byte . TYPE , 6 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Character . TYPE , 7 ) ) ; _internal2Java . put ( Type . Int , new JavaType ( Object . class , 8 ) ) ; _internal2Java . put ( Type . String , new JavaType ( String . class , 0 ) ) ; _internal2Java . put ( Type . String , new JavaType ( Object . class , 1 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( nodeListClass , 0 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( nodeClass , 1 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( Object . class , 2 ) ) ; _internal2Java . put ( Type . NodeSet , new JavaType ( String . class , 3 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( nodeListClass , 0 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( nodeClass , 1 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( Object . class , 2 ) ) ; _internal2Java . put ( Type . Node , new JavaType ( String . class , 3 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( nodeListClass , 0 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( nodeClass , 1 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( Object . class , 2 ) ) ; _internal2Java . put ( Type . ResultTree , new JavaType ( String . class , 3 ) ) ; _internal2Java . put ( Type . Reference , new JavaType ( Object . class , 0 ) ) ; _java2Internal . put ( Boolean . TYPE , Type . Boolean ) ; _java2Internal . put ( Void . TYPE , Type . Void ) ; _java2Internal . put ( Character . TYPE , Type . Real ) ; _java2Internal . put ( Byte . TYPE , Type . Real ) ; _java2Internal . put ( Short . TYPE , Type . Real ) ; _java2Internal . put ( Integer . TYPE , Type . Real ) ; _java2Internal . put ( Long . TYPE , Type . Real ) ; _java2Internal . put ( Float . TYPE , Type . Real ) ; _java2Internal . put ( Double . TYPE , Type . Real ) ; _java2Internal . put ( String . class , Type . String ) ; _java2Internal . put ( Object . class , Type . Reference ) ; _java2Internal . put ( nodeListClass , Type . NodeSet ) ; _java2Internal . put ( nodeClass , Type . NodeSet ) ; _extensionNamespaceTable . put ( EXT_XALAN , "org.apache.xalan.lib.Extensions" ) ; _extensionNamespaceTable . put ( EXSLT_COMMON , "org.apache.xalan.lib.ExsltCommon" ) ; _extensionNamespaceTable . put ( EXSLT_MATH , "org.apache.xalan.lib.ExsltMath" ) ; _extensionNamespaceTable . put ( EXSLT_SETS , "org.apache.xalan.lib.ExsltSets" ) ; _extensionNamespaceTable . put ( EXSLT_DATETIME , "org.apache.xalan.lib.ExsltDatetime" ) ; _extensionNamespaceTable . put ( EXSLT_STRINGS , "org.apache.xalan.lib.ExsltStrings" ) ; _extensionFunctionTable . put ( EXSLT_COMMON + ":nodeSet" , "nodeset" ) ; _extensionFunctionTable . put ( EXSLT_COMMON + ":objectType" , "objectType" ) ; _extensionFunctionTable . put ( EXT_XALAN + ":nodeset" , "nodeset" ) ; } catch ( ClassNotFoundException e ) { System . err . println ( e ) ; } } public FunctionCall ( QName fname , Vector arguments ) { _fname = fname ; _arguments = arguments ; _type = null ; } public FunctionCall ( QName fname ) { this ( fname , EMPTY_ARG_LIST ) ; } public String getName ( ) { return ( _fname . toString ( ) ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _arguments != null ) { final int n = _arguments . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = ( Expression ) _arguments . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public String getClassNameFromUri ( String uri ) { String className = ( String ) _extensionNamespaceTable . get ( uri ) ; if ( className != null ) return className ; else { if ( uri . startsWith ( JAVA_EXT_XSLTC ) ) { int length = JAVA_EXT_XSLTC . length ( ) + 1 ; return ( uri . length ( ) > length ) ? uri . substring ( length ) : EMPTYSTRING ; } else if ( uri . startsWith ( JAVA_EXT_XALAN ) ) { int length = JAVA_EXT_XALAN . length ( ) + 1 ; return ( uri . length ( ) > length ) ? uri . substring ( length ) : EMPTYSTRING ; } else if ( uri . startsWith ( JAVA_EXT_XALAN_OLD ) ) { int length = JAVA_EXT_XALAN_OLD . length ( ) + 1 ; return ( uri . length ( ) > length ) ? uri . substring ( length ) : EMPTYSTRING ; } else { int index = uri . lastIndexOf ( '/' ) ; return ( index > 0 ) ? uri . substring ( index + 1 ) : uri ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _type != null ) return _type ; final String namespace = _fname . getNamespace ( ) ; String local = _fname . getLocalPart ( ) ; if ( isExtension ( ) ) { _fname = new QName ( null , null , local ) ; return typeCheckStandard ( stable ) ; } else if ( isStandard ( ) ) { return typeCheckStandard ( stable ) ; } else { try { _className = getClassNameFromUri ( namespace ) ; final int pos = local . lastIndexOf ( '.' ) ; if ( pos > 0 ) { _isStatic = true ; if ( _className != null && _className . length ( ) > 0 ) { _namespace_format = NAMESPACE_FORMAT_PACKAGE ; _className = _className + "." + local . substring ( 0 , pos ) ; } else { _namespace_format = NAMESPACE_FORMAT_JAVA ; _className = local . substring ( 0 , pos ) ; } _fname = new QName ( namespace , null , local . substring ( pos + 1 ) ) ; } else { if ( _className != null && _className . length ( ) > 0 ) { try { _clazz = ObjectFactory . findProviderClass ( _className , ObjectFactory . findClassLoader ( ) , true ) ; _namespace_format = NAMESPACE_FORMAT_CLASS ; } catch ( ClassNotFoundException e ) { _namespace_format = NAMESPACE_FORMAT_PACKAGE ; } } else _namespace_format = NAMESPACE_FORMAT_JAVA ; if ( local . indexOf ( '-' ) > 0 ) { local = replaceDash ( local ) ; } String extFunction = ( String ) _extensionFunctionTable . get ( namespace + ":" + local ) ; if ( extFunction != null ) { _fname = new QName ( null , null , extFunction ) ; return typeCheckStandard ( stable ) ; } else _fname = new QName ( namespace , null , local ) ; } return typeCheckExternal ( stable ) ; } catch ( TypeCheckError e ) { ErrorMsg errorMsg = e . getErrorMsg ( ) ; if ( errorMsg == null ) { final String name = _fname . getLocalPart ( ) ; errorMsg = new ErrorMsg ( ErrorMsg . METHOD_NOT_FOUND_ERR , name ) ; } getParser ( ) . reportError ( ERROR , errorMsg ) ; return _type = Type . Void ; } } } public Type typeCheckStandard ( SymbolTable stable ) throws TypeCheckError { _fname . clearNamespace ( ) ; final int n = _arguments . size ( ) ; final Vector argsType = typeCheckArgs ( stable ) ; final MethodType args = new MethodType ( Type . Void , argsType ) ; final MethodType ptype = lookupPrimop ( stable , _fname . getLocalPart ( ) , args ) ; if ( ptype != null ) { for ( int i = 0 ; i < n ; i ++ ) { final Type argType = ( Type ) ptype . argsType ( ) . elementAt ( i ) ; final Expression exp = ( Expression ) _arguments . elementAt ( i ) ; if ( ! argType . identicalTo ( exp . getType ( ) ) ) { try { _arguments . setElementAt ( new CastExpr ( exp , argType ) , i ) ; } catch ( TypeCheckError e ) { throw new TypeCheckError ( this ) ; } } } _chosenMethodType = ptype ; return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public Type typeCheckConstructor ( SymbolTable stable ) throws TypeCheckError { final Vector constructors = findConstructors ( ) ; if ( constructors == null ) { throw new TypeCheckError ( ErrorMsg . CONSTRUCTOR_NOT_FOUND , _className ) ; } final int nConstructors = constructors . size ( ) ; final int nArgs = _arguments . size ( ) ; final Vector argsType = typeCheckArgs ( stable ) ; int bestConstrDistance = Integer . MAX_VALUE ; _type = null ; for ( int j , i = 0 ; i < nConstructors ; i ++ ) { final Constructor constructor = ( Constructor ) constructors . elementAt ( i ) ; final Class [ ] paramTypes = constructor . getParameterTypes ( ) ; Class extType = null ; int currConstrDistance = 0 ; for ( j = 0 ; j < nArgs ; j ++ ) { extType = paramTypes [ j ] ; final Type intType = ( Type ) argsType . elementAt ( j ) ; Object match = _internal2Java . maps ( intType , extType ) ; if ( match != null ) { currConstrDistance += ( ( JavaType ) match ) . distance ; } else if ( intType instanceof ObjectType ) { ObjectType objectType = ( ObjectType ) intType ; if ( objectType . getJavaClass ( ) == extType ) continue ; else if ( extType . isAssignableFrom ( objectType . getJavaClass ( ) ) ) currConstrDistance += 1 ; else { currConstrDistance = Integer . MAX_VALUE ; break ; } } else { currConstrDistance = Integer . MAX_VALUE ; break ; } } if ( j == nArgs && currConstrDistance < bestConstrDistance ) { _chosenConstructor = constructor ; _isExtConstructor = true ; bestConstrDistance = currConstrDistance ; _type = ( _clazz != null ) ? Type . newObjectType ( _clazz ) : Type . newObjectType ( _className ) ; } } if ( _type != null ) { return _type ; } else { resolveDynamic = true ; } return _type = ( _clazz != null ) ? Type . newObjectType ( _clazz ) : Type . newObjectType ( _className ) ; } public Type typeCheckExternal ( SymbolTable stable ) throws TypeCheckError { int nArgs = _arguments . size ( ) ; final String name = _fname . getLocalPart ( ) ; if ( _fname . getLocalPart ( ) . equals ( "new" ) ) { return typeCheckConstructor ( stable ) ; } else { boolean hasThisArgument = false ; if ( nArgs == 0 ) _isStatic = true ; if ( ! _isStatic ) { if ( _namespace_format == NAMESPACE_FORMAT_JAVA || _namespace_format == NAMESPACE_FORMAT_PACKAGE ) hasThisArgument = true ; Expression firstArg = ( Expression ) _arguments . elementAt ( 0 ) ; Type firstArgType = ( Type ) firstArg . typeCheck ( stable ) ; if ( _namespace_format == NAMESPACE_FORMAT_CLASS && firstArgType instanceof ObjectType && _clazz != null && _clazz . isAssignableFrom ( ( ( ObjectType ) firstArgType ) . getJavaClass ( ) ) ) hasThisArgument = true ; else if ( firstArgType instanceof ReferenceType ) { resolveDynamic = true ; typeCheckArgs ( stable ) ; return Type . String ; } if ( hasThisArgument ) { _thisArgument = ( Expression ) _arguments . elementAt ( 0 ) ; _arguments . remove ( 0 ) ; nArgs -- ; if ( firstArgType instanceof ObjectType ) { _className = ( ( ObjectType ) firstArgType ) . getJavaClassName ( ) ; } else throw new TypeCheckError ( ErrorMsg . NO_JAVA_FUNCT_THIS_REF , name ) ; } } else if ( _className . length ( ) == 0 ) { final Parser parser = getParser ( ) ; if ( parser != null ) { reportWarning ( this , parser , ErrorMsg . FUNCTION_RESOLVE_ERR , _fname . toString ( ) ) ; } unresolvedExternal = true ; return _type = Type . Int ; } } final Vector methods = findMethods ( ) ; if ( methods == null ) { throw new TypeCheckError ( ErrorMsg . METHOD_NOT_FOUND_ERR , _className + "." + name ) ; } Class extType = null ; final int nMethods = methods . size ( ) ; final Vector argsType = typeCheckArgs ( stable ) ; int bestMethodDistance = Integer . MAX_VALUE ; _type = null ; for ( int j , i = 0 ; i < nMethods ; i ++ ) { final Method method = ( Method ) methods . elementAt ( i ) ; final Class [ ] paramTypes = method . getParameterTypes ( ) ; int currMethodDistance = 0 ; for ( j = 0 ; j < nArgs ; j ++ ) { extType = paramTypes [ j ] ; final Type intType = ( Type ) argsType . elementAt ( j ) ; Object match = _internal2Java . maps ( intType , extType ) ; if ( match != null ) { currMethodDistance += ( ( JavaType ) match ) . distance ; } else { if ( intType instanceof ReferenceType ) { currMethodDistance += 1 ; } else if ( intType instanceof ObjectType ) { ObjectType object = ( ObjectType ) intType ; if ( extType . getName ( ) . equals ( object . getJavaClassName ( ) ) ) currMethodDistance += 0 ; else if ( extType . isAssignableFrom ( object . getJavaClass ( ) ) ) currMethodDistance += 1 ; else { currMethodDistance = Integer . MAX_VALUE ; break ; } } else { currMethodDistance = Integer . MAX_VALUE ; break ; } } } if ( j == nArgs ) { extType = method . getReturnType ( ) ; _type = ( Type ) _java2Internal . get ( extType ) ; if ( _type == null ) { _type = Type . newObjectType ( extType ) ; } if ( _type != null && currMethodDistance < bestMethodDistance ) { _chosenMethod = method ; bestMethodDistance = currMethodDistance ; } } } if ( _chosenMethod != null && _thisArgument == null && ! Modifier . isStatic ( _chosenMethod . getModifiers ( ) ) ) { throw new TypeCheckError ( ErrorMsg . NO_JAVA_FUNCT_THIS_REF , getMethodSignature ( argsType ) ) ; } if ( _type != null ) { if ( _type == Type . NodeSet ) { getXSLTC ( ) . setMultiDocument ( true ) ; } return _type ; } throw new TypeCheckError ( ErrorMsg . ARGUMENT_CONVERSION_ERR , getMethodSignature ( argsType ) ) ; } public Vector typeCheckArgs ( SymbolTable stable ) throws TypeCheckError { final Vector result = new Vector ( ) ; final Enumeration e = _arguments . elements ( ) ; while ( e . hasMoreElements ( ) ) { final Expression exp = ( Expression ) e . nextElement ( ) ; result . addElement ( exp . typeCheck ( stable ) ) ; } return result ; } protected final Expression argument ( int i ) { return ( Expression ) _arguments . elementAt ( i ) ; } protected final Expression argument ( ) { return argument ( 0 ) ; } protected final int argumentCount ( ) { return _arguments . size ( ) ; } protected final void setArgument ( int i , Expression exp ) { _arguments . setElementAt ( exp , i ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { Type type = Type . Boolean ; if ( _chosenMethodType != null ) type = _chosenMethodType . resultType ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; translate ( classGen , methodGen ) ; if ( ( type instanceof BooleanType ) || ( type instanceof IntType ) ) { _falseList . add ( il . append ( new IFEQ ( null ) ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = argumentCount ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index ; if ( isStandard ( ) || isExtension ( ) ) { for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startIterator ( classGen , methodGen ) ; } final String name = _fname . toString ( ) . replace ( '-' , '_' ) + "F" ; String args = Constants . EMPTYSTRING ; if ( name . equals ( "sumF" ) ) { args = DOM_INTF_SIG ; il . append ( methodGen . loadDOM ( ) ) ; } else if ( name . equals ( "normalize_spaceF" ) ) { if ( _chosenMethodType . toSignature ( args ) . equals ( "()Ljava/lang/String;" ) ) { args = "I" + DOM_INTF_SIG ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; } } index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , name , _chosenMethodType . toSignature ( args ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( unresolvedExternal ) { index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "unresolved_externalF" , "(Ljava/lang/String;)V" ) ; il . append ( new PUSH ( cpg , _fname . toString ( ) ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( _isExtConstructor ) { final String clazz = _chosenConstructor . getDeclaringClass ( ) . getName ( ) ; Class [ ] paramTypes = _chosenConstructor . getParameterTypes ( ) ; il . append ( new NEW ( cpg . addClass ( _className ) ) ) ; il . append ( InstructionConstants . DUP ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startIterator ( classGen , methodGen ) ; exp . getType ( ) . translateTo ( classGen , methodGen , paramTypes [ i ] ) ; } final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( '(' ) ; for ( int i = 0 ; i < paramTypes . length ; i ++ ) { buffer . append ( getSignature ( paramTypes [ i ] ) ) ; } buffer . append ( ')' ) ; buffer . append ( "V" ) ; index = cpg . addMethodref ( clazz , "<init>" , buffer . toString ( ) ) ; il . append ( new INVOKESPECIAL ( index ) ) ; ( Type . Object ) . translateFrom ( classGen , methodGen , _chosenConstructor . getDeclaringClass ( ) ) ; } else if ( resolveDynamic ) { final LocalVariableGen _local = methodGen . addLocalVariable2 ( "objects" , org . apache . bcel . generic . Type . OBJECT , il . getEnd ( ) ) ; il . append ( new PUSH ( cpg , n + 1 ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( OBJECT_CLASS ) ) ) ; il . append ( DUP ) ; if ( _thisArgument != null ) { il . append ( new PUSH ( cpg , 0 ) ) ; _thisArgument . translate ( classGen , methodGen ) ; } else { il . append ( new PUSH ( cpg , 0 ) ) ; il . append ( ACONST_NULL ) ; } il . append ( AASTORE ) ; for ( int i = 0 ; i < n ; i ++ ) { il . append ( DUP ) ; il . append ( new PUSH ( cpg , i + 1 ) ) ; Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startIterator ( classGen , methodGen ) ; exp . getType ( ) . translateTo ( classGen , methodGen , Type . Reference ) ; il . append ( AASTORE ) ; } il . append ( new ASTORE ( _local . getIndex ( ) ) ) ; String methodName = null ; if ( _chosenMethod != null ) methodName = _chosenMethod . getName ( ) ; else methodName = _fname . getLocalPart ( ) ; il . append ( new PUSH ( cpg , _className ) ) ; il . append ( new PUSH ( cpg , methodName ) ) ; il . append ( new ALOAD ( _local . getIndex ( ) ) ) ; index = cpg . addMethodref ( CALL_FUNCTION_CLASS , INVOKE_METHOD , "(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;" ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else { final String clazz = _chosenMethod . getDeclaringClass ( ) . getName ( ) ; Class [ ] paramTypes = _chosenMethod . getParameterTypes ( ) ; if ( _thisArgument != null ) { _thisArgument . translate ( classGen , methodGen ) ; } for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = argument ( i ) ; exp . translate ( classGen , methodGen ) ; exp . startIterator ( classGen , methodGen ) ; exp . getType ( ) . translateTo ( classGen , methodGen , paramTypes [ i ] ) ; } final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( '(' ) ; for ( int i = 0 ; i < paramTypes . length ; i ++ ) { buffer . append ( getSignature ( paramTypes [ i ] ) ) ; } buffer . append ( ')' ) ; buffer . append ( getSignature ( _chosenMethod . getReturnType ( ) ) ) ; if ( _thisArgument != null && _clazz . isInterface ( ) ) { index = cpg . addInterfaceMethodref ( clazz , _fname . getLocalPart ( ) , buffer . toString ( ) ) ; il . append ( new INVOKEINTERFACE ( index , n + 1 ) ) ; } else { index = cpg . addMethodref ( clazz , _fname . getLocalPart ( ) , buffer . toString ( ) ) ; il . append ( _thisArgument != null ? ( InvokeInstruction ) new INVOKEVIRTUAL ( index ) : ( InvokeInstruction ) new INVOKESTATIC ( index ) ) ; } _type . translateFrom ( classGen , methodGen , _chosenMethod . getReturnType ( ) ) ; } } public String toString ( ) { return "funcall(" + _fname + ", " + _arguments + ')' ; } public boolean isStandard ( ) { final String namespace = _fname . getNamespace ( ) ; return ( namespace == null ) || ( namespace . equals ( Constants . EMPTYSTRING ) ) ; } public boolean isExtension ( ) { final String namespace = _fname . getNamespace ( ) ; return ( namespace != null ) && ( namespace . equals ( EXT_XSLTC ) ) ; } private Vector findMethods ( ) { Vector result = null ; final String namespace = _fname . getNamespace ( ) ; if ( _className != null && _className . length ( ) > 0 ) { final int nArgs = _arguments . size ( ) ; try { if ( _clazz == null ) { _clazz = ObjectFactory . findProviderClass ( _className , ObjectFactory . findClassLoader ( ) , true ) ; if ( _clazz == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } final String methodName = _fname . getLocalPart ( ) ; final Method [ ] methods = _clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final int mods = methods [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && methods [ i ] . getName ( ) . equals ( methodName ) && methods [ i ] . getParameterTypes ( ) . length == nArgs ) { if ( result == null ) { result = new Vector ( ) ; } result . addElement ( methods [ i ] ) ; } } } catch ( ClassNotFoundException e ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } return result ; } private Vector findConstructors ( ) { Vector result = null ; final String namespace = _fname . getNamespace ( ) ; final int nArgs = _arguments . size ( ) ; try { if ( _clazz == null ) { _clazz = ObjectFactory . findProviderClass ( _className , ObjectFactory . findClassLoader ( ) , true ) ; if ( _clazz == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } final Constructor [ ] constructors = _clazz . getConstructors ( ) ; for ( int i = 0 ; i < constructors . length ; i ++ ) { final int mods = constructors [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && constructors [ i ] . getParameterTypes ( ) . length == nArgs ) { if ( result == null ) { result = new Vector ( ) ; } result . addElement ( constructors [ i ] ) ; } } } catch ( ClassNotFoundException e ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , _className ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } return result ; } static final String getSignature ( Class clazz ) { if ( clazz . isArray ( ) ) { final StringBuffer sb = new StringBuffer ( ) ; Class cl = clazz ; while ( cl . isArray ( ) ) { sb . append ( "[" ) ; cl = cl . getComponentType ( ) ; } sb . append ( getSignature ( cl ) ) ; return sb . toString ( ) ; } else if ( clazz . isPrimitive ( ) ) { if ( clazz == Integer . TYPE ) { return "I" ; } else if ( clazz == Byte . TYPE ) { return "B" ; } else if ( clazz == Long . TYPE ) { return "J" ; } else if ( clazz == Float . TYPE ) { return "F" ; } else if ( clazz == Double . TYPE ) { return "D" ; } else if ( clazz == Short . TYPE ) { return "S" ; } else if ( clazz == Character . TYPE ) { return "C" ; } else if ( clazz == Boolean . TYPE ) { return "Z" ; } else if ( clazz == Void . TYPE ) { return "V" ; } else { final String name = clazz . toString ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . UNKNOWN_SIG_TYPE_ERR , name ) ; throw new Error ( err . toString ( ) ) ; } } else { return "L" + clazz . getName ( ) . replace ( '.' , '/' ) + ';' ; } } static final String getSignature ( Method meth ) { final StringBuffer sb = new StringBuffer ( ) ; sb . append ( '(' ) ; final Class [ ] params = meth . getParameterTypes ( ) ; for ( int j = 0 ; j < params . length ; j ++ ) { sb . append ( getSignature ( params [ j ] ) ) ; } return sb . append ( ')' ) . append ( getSignature ( meth . getReturnType ( ) ) ) . toString ( ) ; } static final String getSignature ( Constructor cons ) { final StringBuffer sb = new StringBuffer ( ) ; sb . append ( '(' ) ; final Class [ ] params = cons . getParameterTypes ( ) ; for ( int j = 0 ; j < params . length ; j ++ ) { sb . append ( getSignature ( params [ j ] ) ) ; } return sb . append ( ")V" ) . toString ( ) ; } private String getMethodSignature ( Vector argsType ) { final StringBuffer buf = new StringBuffer ( _className ) ; buf . append ( '.' ) . append ( _fname . getLocalPart ( ) ) . append ( '(' ) ; int nArgs = argsType . size ( ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { final Type intType = ( Type ) argsType . elementAt ( i ) ; buf . append ( intType . toString ( ) ) ; if ( i < nArgs - 1 ) buf . append ( ", " ) ; } buf . append ( ')' ) ; return buf . toString ( ) ; } protected static String replaceDash ( String name ) { char dash = '-' ; StringBuffer buff = new StringBuffer ( "" ) ; for ( int i = 0 ; i < name . length ( ) ; i ++ ) { if ( i > 0 && name . charAt ( i - 1 ) == dash ) buff . append ( Character . toUpperCase ( name . charAt ( i ) ) ) ; else if ( name . charAt ( i ) != dash ) buff . append ( name . charAt ( i ) ) ; } return buff . toString ( ) ; } } 	1	['27', '3', '24', '69', '150', '97', '25', '44', '15', '0.914663462', '2553', '0.96875', '4', '0.747368421', '0.130177515', '3', '11', '92.37037037', '21', '3.4815', '2']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; public class SelfIteratorNoPredicate extends LocPathIterator { SelfIteratorNoPredicate ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; } public SelfIteratorNoPredicate ( ) throws javax . xml . transform . TransformerException { super ( null ) ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next ; DTM dtm = m_cdtm ; m_lastFetched = next = ( DTM . NULL == m_lastFetched ) ? m_context : DTM . NULL ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return xctxt . getCurrentNode ( ) ; } public int getLastPos ( XPathContext xctxt ) { return 1 ; } } 	1	['5', '5', '0', '8', '8', '10', '3', '5', '4', '2', '57', '0', '0', '0.9765625', '0.45', '1', '4', '10.4', '4', '1.2', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_sk extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "Viac než jeden štýl dokumentu bol definovaný v rovnakom súbore." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "Vzor ''{0}'' je už v tomto štýle dokumentu definovaný." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "Vzor ''{0}'' nie je v tomto štýle dokumentu definovaný." } , { ErrorMsg . VARIABLE_REDEF_ERR , "Premenná ''{0}'' je viackrát definovaná v tom istom rozsahu." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "Premenná alebo parameter ''{0}'' nie je definovaná." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "Nie je možné nájsť triedu ''{0}''." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "Nie je možné nájsť externú metódu ''{0}'' (musí byť verejná)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Nie je možné konvertovať typ argumentu/návratu vo volaní metódy ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "Súbor alebo URI ''{0}'' sa nenašli." } , { ErrorMsg . INVALID_URI_ERR , "Neplatný URI ''{0}''." } , { ErrorMsg . FILE_ACCESS_ERR , "Nie je možné otvoriť súbor alebo URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "Očakáva sa element <xsl:stylesheet> alebo <xsl:transform>." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Predpona názvového priestoru ''{0}'' nie je deklarovaná." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Nie je možné rozlíšiť volanie funkcie ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "Argument pre ''{0}'' musí byť reťazcom literálu." } , { ErrorMsg . XPATH_PARSER_ERR , "Chyba pri analýze výrazu XPath ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Chýba požadovaný atribút ''{0}''." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Neplatný znak ''{0}'' vo výraze XPath." } , { ErrorMsg . ILLEGAL_PI_ERR , "Neplatný názov ''{0}'' pre inštrukciu spracovania." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "Atribút ''{0}'' mimo elementu." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Nelegálny atribút ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Cirkulárny import/zahrnutie. Štýl dokumentu ''{0}'' je už zavedený." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Fragmenty stromu výsledkov nemožno triediť (elementy <xsl:sort> sú ignorované). Keď vytvárate výsledkový strom, musíte triediť uzly." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Desiatkové formátovanie ''{0}'' je už definované." } , { ErrorMsg . XSL_VERSION_ERR , "Verzia XSL ''{0}'' nie je podporovaná XSLTC." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Cirkulárna referencia premennej/parametra v ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Neznámy operátor pre binárny výraz." } , { ErrorMsg . ILLEGAL_ARG_ERR , "Neplatný argument(y) pre volanie funkcie." } , { ErrorMsg . DOCUMENT_ARG_ERR , "Druhý argument pre funkciu dokumentu() musí byť sada uzlov." } , { ErrorMsg . MISSING_WHEN_ERR , "V <xsl:choose> sa vyžaduje najmenej jeden element <xsl:when>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "V  <xsl:choose> je povolený len jeden element <xsl:otherwise>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> možno použiť len v <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> možno použiť len v <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "V <xsl:choose> sú povolené len elementy <xsl:when> a <xsl:otherwise>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set> chýba atribút 'name'." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Neplatný element potomka." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "Nemôžete volať element ''{0}''" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "Nemôžete volať atribút ''{0}''" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Textové údaje sú mimo elementu vrchnej úrovne <xsl:stylesheet>." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "Analyzátor JAXP nie je správne nakonfigurovaný" } , { ErrorMsg . INTERNAL_ERR , "Neodstrániteľná interná chyba XSLTC: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Nepodporovaný element XSL ''{0}''." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "Nerozlíšené rozšírenie XSLTC ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "Vstupný dokument nie je štýlom dokumentu (názvový priestor XSL nie je deklarovaný v koreňovom elemente)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Nebolo možné nájsť cieľ štýlu dokumentu ''{0}''." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Nie je implementované: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "Vstupný dokument neobsahuje štýl dokumentu XSL." } , { ErrorMsg . ELEMENT_PARSE_ERR , "Nebolo možné analyzovať element ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "Atribút použitia <key> musí byť uzol, sada uzlov, reťazec alebo číslo." } , { ErrorMsg . OUTPUT_VERSION_ERR , "Verzia výstupného dokumentu XML by mala byť 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Neznámy operátor pre relačný výraz" } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Pokus o použitie neexistujúcej sady atribútov ''{0}''." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Nie je možné analyzovať vzor hodnoty atribútu ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Neznámy typ údajov v podpise pre triedu ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "Nie je možné konvertovať typ údajov ''{0}'' na ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Tento vzor neobsahuje platnú definíciu triedy transletu." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Tento vzor neobsahuje triedu s názvom ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Nebolo možné zaviesť triedu transletu ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Trieda transletu zavedená, ale nie je možné vytvoriť inštanciu transletu." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "Pokus o nastavenie ErrorListener pre ''{0}'' na null" } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "XSLTC podporuje len StreamSource, SAXSource a DOMSource" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "Objekt zdroja odovzdaný ''{0}'' nemá žiadny obsah." } , { ErrorMsg . JAXP_COMPILE_ERR , "Nebolo možné skompilovať štýl dokumentu" } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory nerozoznáva atribút ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() sa musí volať pred startDocument()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformátor nemá žiadny zapuzdrený objekt transletu." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "Pre výsledok transformácie nebol definovaný žiadny výstupný handler." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "Objekt výsledku odovzdaný ''{0}'' je neplatný." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Pokus o prístup k neplatnému majetku transformátora ''{0}''." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Nebolo možné vytvoriť adaptér SAX2DOM: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() bol zavolaný bez nastaveného systemId." } , { ErrorMsg . COMPILE_STDIN_ERR , "Voľba -i sa musí používať s voľbou -o." } , { ErrorMsg . COMPILE_USAGE_STR , "SYNOPSIS\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]\n      [-d <directory>] [-j <jarfile>] [-p <package>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }\n\nOPTIONS\n   -o <output>    priraďuje názov <output> generovanému transletu \n. Štandardne sa názov transletu \n berie z názvu <stylesheet>. Táto voľba sa ignoruje pri kompilovaní viacerých štýlov dokumentov\n\n.   -d <directory> uvádza cieľový adresár pre translet\n   -j <jarfile>   pakuje triedy transletov do súboru jar názvu \n uvedeného ako <jarfile>\n   -p <package>   uvádza predponu názvu balíku pre všetky generované triedy transletu.\n\n   -n             povoľuje zoradenie vzorov v riadku (štandardné chovanie v priemere lepšie). \n\n   -x             zapína   výstupy správ ladenia \n   -s             zakazuje volanie System.exit\n   -u             interpretuje<stylesheet> argumenty ako URL\n   -i             núti kompilátor čítať štýl dokumentu z stdin\n   -v             tlačí verziu kompilátora\n   -h             tlačí príkaz tohto použitia\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SYNOPSIS \n   java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]\n      [-x] [-s] [-n <iterations>] {-u <document_url> | <document>}\n      <class> [<param1>=<value1> ...]\n\n   používa translet <class> na transformáciu dokumentu XML \n   uvedeného ako <document>. <class> transletu je buď v \n užívateľovej CLASSPATH alebo vo voliteľne uvedenom <jarfile>.\nVOĽBY\n   -j <jarfile>    uvádza súbor jar, z ktorého sa má zaviesť translet\n   -x              zapína ďalší výstup správ ladenia\n   -s              zakazuje volanie System.exit\n   -n <iterations> spúšťa transformáciu <iterations> ráz a \n                   zobrazuje informácie profilovania\n   -u <document_url> uvádza vstupný dokument XML ako URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> možno použiť len v <xsl:for-each> alebo <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "Výstupné kódovanie ''{0}'' nie je v tomto JVM podporované." } , { ErrorMsg . SYNTAX_ERR , "Chyba syntaxe v ''{0}''." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "Nie je možné nájsť externý konštruktor ''{0}''." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "Prvý argument pre nestatickú funkciu Java ''{0}'' nie je platnou referenciou objektu." } , { ErrorMsg . TYPE_CHECK_ERR , "Chyba pri kontrole typu výrazu ''{0}''." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Chyba pri kontrole typu výrazu na neznámom mieste." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "Voľba príkazového riadka ''{0}'' je neplatná." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "Voľbe príkazového riadka ''{0}'' chýba požadovaný argument." } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "UPOZORNENIE:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "UPOZORNENIE:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "KRITICKÁ CHYBA:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "KRITICKÁ CHYBA:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "CHYBA:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "CHYBA:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Transformácia pomocou transletu ''{0}'' " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Transformácia pomocou transletu ''{0}'' zo súboru jar ''{1}''" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "Nebolo možné vytvoriť inštanciu triedy TransformerFactory ''{0}''." } , { ErrorMsg . COMPILER_ERROR_KEY , "Chyby prekladača:" } , { ErrorMsg . COMPILER_WARNING_KEY , "Upozornenia prekladača:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Chyby transletu:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xalan . templates ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . processor . StylesheetHandler ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . StringBufferPool ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; public class AVT implements java . io . Serializable , XSLTVisitable { private String m_simpleString = null ; private Vector m_parts = null ; private String m_rawName ; public String getRawName ( ) { return m_rawName ; } public void setRawName ( String rawName ) { m_rawName = rawName ; } private String m_name ; public String getName ( ) { return m_name ; } public void setName ( String name ) { m_name = name ; } private String m_uri ; public String getURI ( ) { return m_uri ; } public void setURI ( String uri ) { m_uri = uri ; } public AVT ( StylesheetHandler handler , String uri , String name , String rawName , String stringedValue , ElemTemplateElement owner ) throws javax . xml . transform . TransformerException { m_uri = uri ; m_name = name ; m_rawName = rawName ; StringTokenizer tokenizer = new StringTokenizer ( stringedValue , "{}\"\'" , true ) ; int nTokens = tokenizer . countTokens ( ) ; if ( nTokens < 2 ) { m_simpleString = stringedValue ; } else { FastStringBuffer buffer = StringBufferPool . get ( ) ; FastStringBuffer exprBuffer = StringBufferPool . get ( ) ; try { m_parts = new Vector ( nTokens + 1 ) ; String t = null ; String lookahead = null ; String error = null ; while ( tokenizer . hasMoreTokens ( ) ) { if ( lookahead != null ) { t = lookahead ; lookahead = null ; } else t = tokenizer . nextToken ( ) ; if ( t . length ( ) == 1 ) { switch ( t . charAt ( 0 ) ) { case ( '\"' ) : case ( '\'' ) : { buffer . append ( t ) ; break ; } case ( '{' ) : { try { lookahead = tokenizer . nextToken ( ) ; if ( lookahead . equals ( "{" ) ) { buffer . append ( lookahead ) ; lookahead = null ; break ; } else { if ( buffer . length ( ) > 0 ) { m_parts . addElement ( new AVTPartSimple ( buffer . toString ( ) ) ) ; buffer . setLength ( 0 ) ; } exprBuffer . setLength ( 0 ) ; while ( null != lookahead ) { if ( lookahead . length ( ) == 1 ) { switch ( lookahead . charAt ( 0 ) ) { case '\'' : case '\"' : { exprBuffer . append ( lookahead ) ; String quote = lookahead ; lookahead = tokenizer . nextToken ( ) ; while ( ! lookahead . equals ( quote ) ) { exprBuffer . append ( lookahead ) ; lookahead = tokenizer . nextToken ( ) ; } exprBuffer . append ( lookahead ) ; lookahead = tokenizer . nextToken ( ) ; break ; } case '{' : { error = XSLMessages . createMessage ( XSLTErrorResources . ER_NO_CURLYBRACE , null ) ; lookahead = null ; break ; } case '}' : { buffer . setLength ( 0 ) ; XPath xpath = handler . createXPath ( exprBuffer . toString ( ) , owner ) ; m_parts . addElement ( new AVTPartXPath ( xpath ) ) ; lookahead = null ; break ; } default : { exprBuffer . append ( lookahead ) ; lookahead = tokenizer . nextToken ( ) ; } } } else { exprBuffer . append ( lookahead ) ; lookahead = tokenizer . nextToken ( ) ; } } if ( error != null ) { break ; } } break ; } catch ( java . util . NoSuchElementException ex ) { error = XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { name , stringedValue } ) ; break ; } } case ( '}' ) : { lookahead = tokenizer . nextToken ( ) ; if ( lookahead . equals ( "}" ) ) { buffer . append ( lookahead ) ; lookahead = null ; } else { try { handler . warn ( XSLTErrorResources . WG_FOUND_CURLYBRACE , null ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } buffer . append ( "}" ) ; } break ; } default : { buffer . append ( t ) ; } } } else { buffer . append ( t ) ; } if ( null != error ) { try { handler . warn ( XSLTErrorResources . WG_ATTR_TEMPLATE , new Object [ ] { error } ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } break ; } } if ( buffer . length ( ) > 0 ) { m_parts . addElement ( new AVTPartSimple ( buffer . toString ( ) ) ) ; buffer . setLength ( 0 ) ; } } finally { StringBufferPool . free ( buffer ) ; StringBufferPool . free ( exprBuffer ) ; } } if ( null == m_parts && ( null == m_simpleString ) ) { m_simpleString = "" ; } } public String getSimpleString ( ) { if ( null != m_simpleString ) { return m_simpleString ; } else if ( null != m_parts ) { FastStringBuffer buf = StringBufferPool . get ( ) ; String s ; try { buf . setLength ( 0 ) ; int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; buf . append ( part . getSimpleString ( ) ) ; } s = buf . toString ( ) ; } finally { StringBufferPool . free ( buf ) ; } return s ; } else { return "" ; } } public String evaluate ( XPathContext xctxt , int context , org . apache . xml . utils . PrefixResolver nsNode ) throws javax . xml . transform . TransformerException { FastStringBuffer buf = StringBufferPool . get ( ) ; try { if ( null != m_simpleString ) { return m_simpleString ; } else if ( null != m_parts ) { buf . setLength ( 0 ) ; int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; part . evaluate ( xctxt , buf , context , nsNode ) ; } return buf . toString ( ) ; } else { return "" ; } } finally { StringBufferPool . free ( buf ) ; } } public boolean isContextInsensitive ( ) { return null != m_simpleString ; } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_parts ) { int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; if ( part . canTraverseOutsideSubtree ( ) ) return true ; } } return false ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { if ( null != m_parts ) { int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; part . fixupVariables ( vars , globalsSize ) ; } } } public void callVisitors ( XSLTVisitor visitor ) { if ( visitor . visitAVT ( this ) && ( null != m_parts ) ) { int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; part . callVisitors ( visitor ) ; } } } public boolean isSimple ( ) { return m_simpleString != null ; } } 	1	['14', '1', '0', '23', '44', '29', '11', '13', '14', '0.769230769', '546', '1', '0', '0', '0.206349206', '0', '0', '37.64285714', '4', '1.8571', '1']
package org . apache . xpath ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . NodeVector ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class NodeSetDTM extends NodeVector implements DTMIterator , Cloneable { public NodeSetDTM ( DTMManager dtmManager ) { super ( ) ; m_manager = dtmManager ; } public NodeSetDTM ( int blocksize , int dummy , DTMManager dtmManager ) { super ( blocksize ) ; m_manager = dtmManager ; } public NodeSetDTM ( NodeSetDTM nodelist ) { super ( ) ; m_manager = nodelist . getDTMManager ( ) ; m_root = nodelist . getRoot ( ) ; addNodes ( ( DTMIterator ) nodelist ) ; } public NodeSetDTM ( DTMIterator ni ) { super ( ) ; m_manager = ni . getDTMManager ( ) ; m_root = ni . getRoot ( ) ; addNodes ( ni ) ; } public NodeSetDTM ( NodeIterator iterator , XPathContext xctxt ) { super ( ) ; Node node ; m_manager = xctxt . getDTMManager ( ) ; while ( null != ( node = iterator . nextNode ( ) ) ) { int handle = xctxt . getDTMHandleFromNode ( node ) ; addNodeInDocOrder ( handle , xctxt ) ; } } public NodeSetDTM ( NodeList nodeList , XPathContext xctxt ) { super ( ) ; m_manager = xctxt . getDTMManager ( ) ; int n = nodeList . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Node node = nodeList . item ( i ) ; int handle = xctxt . getDTMHandleFromNode ( node ) ; addNode ( handle ) ; } } public NodeSetDTM ( int node , DTMManager dtmManager ) { super ( ) ; m_manager = dtmManager ; addNode ( node ) ; } public void setEnvironment ( Object environment ) { } public int getRoot ( ) { if ( DTM . NULL == m_root ) { if ( size ( ) > 0 ) return item ( 0 ) ; else return DTM . NULL ; } else return m_root ; } public void setRoot ( int context , Object environment ) { } public Object clone ( ) throws CloneNotSupportedException { NodeSetDTM clone = ( NodeSetDTM ) super . clone ( ) ; return clone ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { NodeSetDTM clone = ( NodeSetDTM ) clone ( ) ; clone . reset ( ) ; return clone ; } public void reset ( ) { m_next = 0 ; } public int getWhatToShow ( ) { return DTMFilter . SHOW_ALL & ~ DTMFilter . SHOW_ENTITY_REFERENCE ; } public DTMFilter getFilter ( ) { return null ; } public boolean getExpandEntityReferences ( ) { return true ; } public DTM getDTM ( int nodeHandle ) { return m_manager . getDTM ( nodeHandle ) ; } DTMManager m_manager ; public DTMManager getDTMManager ( ) { return m_manager ; } public int nextNode ( ) { if ( ( m_next ) < this . size ( ) ) { int next = this . elementAt ( m_next ) ; m_next ++ ; return next ; } else return DTM . NULL ; } public int previousNode ( ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_ITERATE , null ) ) ; if ( ( m_next - 1 ) > 0 ) { m_next -- ; return this . elementAt ( m_next ) ; } else return DTM . NULL ; } public void detach ( ) { } public void allowDetachToRelease ( boolean allowRelease ) { } public boolean isFresh ( ) { return ( m_next == 0 ) ; } public void runTo ( int index ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_INDEX , null ) ) ; if ( ( index >= 0 ) && ( m_next < m_firstFree ) ) m_next = index ; else m_next = m_firstFree - 1 ; } public int item ( int index ) { runTo ( index ) ; return this . elementAt ( index ) ; } public int getLength ( ) { runTo ( - 1 ) ; return this . size ( ) ; } public void addNode ( int n ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; this . addElement ( n ) ; } public void insertNode ( int n , int pos ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; insertElementAt ( n , pos ) ; } public void removeNode ( int n ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; this . removeElement ( n ) ; } public void addNodes ( DTMIterator iterator ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; if ( null != iterator ) { int obj ; while ( DTM . NULL != ( obj = iterator . nextNode ( ) ) ) { addElement ( obj ) ; } } } public void addNodesInDocOrder ( DTMIterator iterator , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; int node ; while ( DTM . NULL != ( node = iterator . nextNode ( ) ) ) { addNodeInDocOrder ( node , support ) ; } } public int addNodeInDocOrder ( int node , boolean test , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; int insertIndex = - 1 ; if ( test ) { int size = size ( ) , i ; for ( i = size - 1 ; i >= 0 ; i -- ) { int child = elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } DTM dtm = support . getDTM ( node ) ; if ( ! dtm . isNodeAfter ( node , child ) ) { break ; } } if ( i != - 2 ) { insertIndex = i + 1 ; insertElementAt ( node , insertIndex ) ; } } else { insertIndex = this . size ( ) ; boolean foundit = false ; for ( int i = 0 ; i < insertIndex ; i ++ ) { if ( i == node ) { foundit = true ; break ; } } if ( ! foundit ) addElement ( node ) ; } return insertIndex ; } public int addNodeInDocOrder ( int node , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; return addNodeInDocOrder ( node , true , support ) ; } public int size ( ) { return super . size ( ) ; } public void addElement ( int value ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . addElement ( value ) ; } public void insertElementAt ( int value , int at ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . insertElementAt ( value , at ) ; } public void appendNodes ( NodeVector nodes ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . appendNodes ( nodes ) ; } public void removeAllElements ( ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . removeAllElements ( ) ; } public boolean removeElement ( int s ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; return super . removeElement ( s ) ; } public void removeElementAt ( int i ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . removeElementAt ( i ) ; } public void setElementAt ( int node , int index ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . setElementAt ( node , index ) ; } public void setItem ( int node , int index ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . setElementAt ( node , index ) ; } public int elementAt ( int i ) { runTo ( i ) ; return super . elementAt ( i ) ; } public boolean contains ( int s ) { runTo ( - 1 ) ; return super . contains ( s ) ; } public int indexOf ( int elem , int index ) { runTo ( - 1 ) ; return super . indexOf ( elem , index ) ; } public int indexOf ( int elem ) { runTo ( - 1 ) ; return super . indexOf ( elem ) ; } transient protected int m_next = 0 ; public int getCurrentPos ( ) { return m_next ; } public void setCurrentPos ( int i ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_INDEX , null ) ) ; m_next = i ; } public int getCurrentNode ( ) { if ( ! m_cacheNodes ) throw new RuntimeException ( "This NodeSetDTM can not do indexing or counting functions!" ) ; int saved = m_next ; int current = ( m_next > 0 ) ? m_next - 1 : m_next ; int n = ( current < m_firstFree ) ? elementAt ( current ) : DTM . NULL ; m_next = saved ; return n ; } transient protected boolean m_mutable = true ; transient protected boolean m_cacheNodes = true ; protected int m_root = DTM . NULL ; public boolean getShouldCacheNodes ( ) { return m_cacheNodes ; } public void setShouldCacheNodes ( boolean b ) { if ( ! isFresh ( ) ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANNOT_CALL_SETSHOULDCACHENODE , null ) ) ; m_cacheNodes = b ; m_mutable = true ; } public boolean isMutable ( ) { return m_mutable ; } transient private int m_last = 0 ; public int getLast ( ) { return m_last ; } public void setLast ( int last ) { m_last = last ; } public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return - 1 ; } } 	1	['56', '2', '1', '22', '84', '714', '15', '7', '56', '0.739393939', '839', '0.833333333', '1', '0.363636364', '0.160714286', '1', '4', '13.875', '9', '1.5714', '1']
package org . apache . xpath . compiler ; import java . util . Vector ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . res . XPATHErrorResources ; class Lexer { private Compiler m_compiler ; PrefixResolver m_namespaceContext ; XPathParser m_processor ; static final int TARGETEXTRA = 10000 ; private int m_patternMap [ ] = new int [ 100 ] ; private int m_patternMapSize ; Lexer ( Compiler compiler , PrefixResolver resolver , XPathParser xpathProcessor ) { m_compiler = compiler ; m_namespaceContext = resolver ; m_processor = xpathProcessor ; } void tokenize ( String pat ) throws javax . xml . transform . TransformerException { tokenize ( pat , null ) ; } void tokenize ( String pat , Vector targetStrings ) throws javax . xml . transform . TransformerException { m_compiler . m_currentPattern = pat ; m_patternMapSize = 0 ; m_compiler . m_opMap = new OpMapVector ( OpMap . MAXTOKENQUEUESIZE * 5 , OpMap . BLOCKTOKENQUEUESIZE * 5 , OpMap . MAPINDEX_LENGTH ) ; int nChars = pat . length ( ) ; int startSubstring = - 1 ; int posOfNSSep = - 1 ; boolean isStartOfPat = true ; boolean isAttrName = false ; boolean isNum = false ; int nesting = 0 ; for ( int i = 0 ; i < nChars ; i ++ ) { char c = pat . charAt ( i ) ; switch ( c ) { case '\"' : { if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } } startSubstring = i ; for ( i ++ ; ( i < nChars ) && ( ( c = pat . charAt ( i ) ) != '\"' ) ; i ++ ) ; if ( c == '\"' && i < nChars ) { addToTokenQueue ( pat . substring ( startSubstring , i + 1 ) ) ; startSubstring = - 1 ; } else { m_processor . error ( XPATHErrorResources . ER_EXPECTED_DOUBLE_QUOTE , null ) ; } } break ; case '\'' : if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } } startSubstring = i ; for ( i ++ ; ( i < nChars ) && ( ( c = pat . charAt ( i ) ) != '\'' ) ; i ++ ) ; if ( c == '\'' && i < nChars ) { addToTokenQueue ( pat . substring ( startSubstring , i + 1 ) ) ; startSubstring = - 1 ; } else { m_processor . error ( XPATHErrorResources . ER_EXPECTED_SINGLE_QUOTE , null ) ; } break ; case 0x0A : case 0x0D : case ' ' : case '\t' : if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } startSubstring = - 1 ; } break ; case '@' : isAttrName = true ; case '-' : if ( '-' == c ) { if ( ! ( isNum || ( startSubstring == - 1 ) ) ) { break ; } isNum = false ; } case '(' : case '[' : case ')' : case ']' : case '|' : case '/' : case '*' : case '+' : case '=' : case ',' : case '\\' : case '^' : case '!' : case '$' : case '<' : case '>' : if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } startSubstring = - 1 ; } else if ( ( '/' == c ) && isStartOfPat ) { isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; } else if ( '*' == c ) { isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; } if ( 0 == nesting ) { if ( '|' == c ) { if ( null != targetStrings ) { recordTokenString ( targetStrings ) ; } isStartOfPat = true ; } } if ( ( ')' == c ) || ( ']' == c ) ) { nesting -- ; } else if ( ( '(' == c ) || ( '[' == c ) ) { nesting ++ ; } addToTokenQueue ( pat . substring ( i , i + 1 ) ) ; break ; case ':' : if ( i > 0 ) { if ( posOfNSSep == ( i - 1 ) ) { if ( startSubstring != - 1 ) { if ( startSubstring < ( i - 1 ) ) addToTokenQueue ( pat . substring ( startSubstring , i - 1 ) ) ; } isNum = false ; isAttrName = false ; startSubstring = - 1 ; posOfNSSep = - 1 ; addToTokenQueue ( pat . substring ( i - 1 , i + 1 ) ) ; break ; } else { posOfNSSep = i ; } } default : if ( - 1 == startSubstring ) { startSubstring = i ; isNum = Character . isDigit ( c ) ; } else if ( isNum ) { isNum = Character . isDigit ( c ) ; } } } if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; if ( ( - 1 != posOfNSSep ) || ( ( m_namespaceContext != null ) && ( m_namespaceContext . handlesNullPrefixes ( ) ) ) ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , nChars ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , nChars ) ) ; } } if ( 0 == m_compiler . getTokenQueueSize ( ) ) { m_processor . error ( XPATHErrorResources . ER_EMPTY_EXPRESSION , null ) ; } else if ( null != targetStrings ) { recordTokenString ( targetStrings ) ; } m_processor . m_queueMark = 0 ; } private boolean mapPatternElemPos ( int nesting , boolean isStart , boolean isAttrName ) { if ( 0 == nesting ) { if ( m_patternMapSize >= m_patternMap . length ) { int patternMap [ ] = m_patternMap ; int len = m_patternMap . length ; m_patternMap = new int [ m_patternMapSize + 100 ] ; System . arraycopy ( patternMap , 0 , m_patternMap , 0 , len ) ; } if ( ! isStart ) { m_patternMap [ m_patternMapSize - 1 ] -= TARGETEXTRA ; } m_patternMap [ m_patternMapSize ] = ( m_compiler . getTokenQueueSize ( ) - ( isAttrName ? 1 : 0 ) ) + TARGETEXTRA ; m_patternMapSize ++ ; isStart = false ; } return isStart ; } private int getTokenQueuePosFromMap ( int i ) { int pos = m_patternMap [ i ] ; return ( pos >= TARGETEXTRA ) ? ( pos - TARGETEXTRA ) : pos ; } private final void resetTokenMark ( int mark ) { int qsz = m_compiler . getTokenQueueSize ( ) ; m_processor . m_queueMark = ( mark > 0 ) ? ( ( mark <= qsz ) ? mark - 1 : mark ) : 0 ; if ( m_processor . m_queueMark < qsz ) { m_processor . m_token = ( String ) m_compiler . getTokenQueue ( ) . elementAt ( m_processor . m_queueMark ++ ) ; m_processor . m_tokenChar = m_processor . m_token . charAt ( 0 ) ; } else { m_processor . m_token = null ; m_processor . m_tokenChar = 0 ; } } final int getKeywordToken ( String key ) { int tok ; try { Integer itok = ( Integer ) Keywords . m_keywords . get ( key ) ; tok = ( null != itok ) ? itok . intValue ( ) : 0 ; } catch ( NullPointerException npe ) { tok = 0 ; } catch ( ClassCastException cce ) { tok = 0 ; } return tok ; } private void recordTokenString ( Vector targetStrings ) { int tokPos = getTokenQueuePosFromMap ( m_patternMapSize - 1 ) ; resetTokenMark ( tokPos + 1 ) ; if ( m_processor . lookahead ( '(' , 1 ) ) { int tok = getKeywordToken ( m_processor . m_token ) ; switch ( tok ) { case OpCodes . NODETYPE_COMMENT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_COMMENT ) ; break ; case OpCodes . NODETYPE_TEXT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_TEXT ) ; break ; case OpCodes . NODETYPE_NODE : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; break ; case OpCodes . NODETYPE_ROOT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ROOT ) ; break ; case OpCodes . NODETYPE_ANYELEMENT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; break ; case OpCodes . NODETYPE_PI : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; break ; default : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; } } else { if ( m_processor . tokenIs ( '@' ) ) { tokPos ++ ; resetTokenMark ( tokPos + 1 ) ; } if ( m_processor . lookahead ( ':' , 1 ) ) { tokPos += 2 ; } targetStrings . addElement ( m_compiler . getTokenQueue ( ) . elementAt ( tokPos ) ) ; } } private final void addToTokenQueue ( String s ) { m_compiler . getTokenQueue ( ) . addElement ( s ) ; } private int mapNSTokens ( String pat , int startSubstring , int posOfNSSep , int posOfScan ) throws javax . xml . transform . TransformerException { String prefix = "" ; if ( ( startSubstring >= 0 ) && ( posOfNSSep >= 0 ) ) { prefix = pat . substring ( startSubstring , posOfNSSep ) ; } String uName ; if ( ( null != m_namespaceContext ) && ! prefix . equals ( "*" ) && ! prefix . equals ( "xmlns" ) ) { try { if ( prefix . length ( ) > 0 ) uName = ( ( PrefixResolver ) m_namespaceContext ) . getNamespaceForPrefix ( prefix ) ; else { if ( false ) { addToTokenQueue ( ":" ) ; String s = pat . substring ( posOfNSSep + 1 , posOfScan ) ; if ( s . length ( ) > 0 ) addToTokenQueue ( s ) ; return - 1 ; } else { uName = ( ( PrefixResolver ) m_namespaceContext ) . getNamespaceForPrefix ( prefix ) ; } } } catch ( ClassCastException cce ) { uName = m_namespaceContext . getNamespaceForPrefix ( prefix ) ; } } else { uName = prefix ; } if ( ( null != uName ) && ( uName . length ( ) > 0 ) ) { addToTokenQueue ( uName ) ; addToTokenQueue ( ":" ) ; String s = pat . substring ( posOfNSSep + 1 , posOfScan ) ; if ( s . length ( ) > 0 ) addToTokenQueue ( s ) ; } else { m_processor . error ( XPATHErrorResources . ER_PREFIX_MUST_RESOLVE , new String [ ] { prefix } ) ; } return - 1 ; } } 	1	['10', '1', '0', '6', '30', '3', '1', '6', '0', '0.611111111', '807', '0.5', '3', '0', '0.3125', '0', '0', '79.1', '11', '2.8', '2']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExtensionNamespaceSupport ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class ElemExsltFunction extends ElemTemplate { public int getXSLToken ( ) { return Constants . EXSLT_ELEMNAME_FUNCTION ; } public String getNodeName ( ) { return Constants . EXSLT_ELEMNAME_FUNCTION_STRING ; } public void execute ( TransformerImpl transformer , XObject [ ] args ) throws TransformerException { XPathContext xctxt = transformer . getXPathContext ( ) ; VariableStack vars = xctxt . getVarStack ( ) ; int thisFrame = vars . getStackFrame ( ) ; int nextFrame = vars . link ( m_frameSize ) ; if ( m_inArgsSize < args . length ) { throw new TransformerException ( "function called with too many args" ) ; } if ( m_inArgsSize > 0 ) { vars . clearLocalSlots ( 0 , m_inArgsSize ) ; if ( args . length > 0 ) { vars . setStackFrame ( thisFrame ) ; NodeList children = this . getChildNodes ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { Node child = children . item ( i ) ; if ( children . item ( i ) instanceof ElemParam ) { ElemParam param = ( ElemParam ) children . item ( i ) ; vars . setLocalVariable ( param . getIndex ( ) , args [ i ] , nextFrame ) ; } } vars . setStackFrame ( nextFrame ) ; } } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; vars . setStackFrame ( nextFrame ) ; transformer . executeChildTemplates ( this , true ) ; vars . unlink ( thisFrame ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; String namespace = getName ( ) . getNamespace ( ) ; String handlerClass = "org.apache.xalan.extensions.ExtensionHandlerExsltFunction" ; Object [ ] args = { namespace , sroot } ; ExtensionNamespaceSupport extNsSpt = new ExtensionNamespaceSupport ( namespace , handlerClass , args ) ; sroot . getExtensionNamespacesManager ( ) . registerExtension ( extNsSpt ) ; if ( ! ( namespace . equals ( Constants . S_EXSLT_FUNCTIONS_URL ) ) ) { namespace = Constants . S_EXSLT_FUNCTIONS_URL ; args = new Object [ ] { namespace , sroot } ; extNsSpt = new ExtensionNamespaceSupport ( namespace , handlerClass , args ) ; sroot . getExtensionNamespacesManager ( ) . registerExtension ( extNsSpt ) ; } } } 	1	['5', '4', '0', '15', '29', '10', '3', '12', '5', '2', '169', '0', '0', '0.981900452', '0.4', '4', '7', '32.8', '1', '0.8', '2']
package org . apache . xalan . xsltc . trax ; import java . io . IOException ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . sax . SAXResult ; import org . apache . xml . utils . XMLReaderManager ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLFilterImpl ; import org . xml . sax . helpers . XMLReaderFactory ; public class TrAXFilter extends XMLFilterImpl { private Templates _templates ; private TransformerImpl _transformer ; private TransformerHandlerImpl _transformerHandler ; public TrAXFilter ( Templates templates ) throws TransformerConfigurationException { _templates = templates ; _transformer = ( TransformerImpl ) templates . newTransformer ( ) ; _transformerHandler = new TransformerHandlerImpl ( _transformer ) ; } public Transformer getTransformer ( ) { return _transformer ; } private void createParent ( ) throws SAXException { XMLReader parent = null ; try { SAXParserFactory pfactory = SAXParserFactory . newInstance ( ) ; pfactory . setNamespaceAware ( true ) ; SAXParser saxparser = pfactory . newSAXParser ( ) ; parent = saxparser . getXMLReader ( ) ; } catch ( ParserConfigurationException e ) { throw new SAXException ( e ) ; } catch ( FactoryConfigurationError e ) { throw new SAXException ( e . toString ( ) ) ; } if ( parent == null ) { parent = XMLReaderFactory . createXMLReader ( ) ; } setParent ( parent ) ; } public void parse ( InputSource input ) throws SAXException , IOException { XMLReader managedReader = null ; try { if ( getParent ( ) == null ) { try { managedReader = XMLReaderManager . getInstance ( ) . getXMLReader ( ) ; setParent ( managedReader ) ; } catch ( SAXException e ) { throw new SAXException ( e . toString ( ) ) ; } } getParent ( ) . parse ( input ) ; } finally { if ( managedReader != null ) { XMLReaderManager . getInstance ( ) . releaseXMLReader ( managedReader ) ; } } } public void parse ( String systemId ) throws SAXException , IOException { parse ( new InputSource ( systemId ) ) ; } public void setContentHandler ( ContentHandler handler ) { _transformerHandler . setResult ( new SAXResult ( handler ) ) ; if ( getParent ( ) == null ) { try { createParent ( ) ; } catch ( SAXException e ) { return ; } } getParent ( ) . setContentHandler ( _transformerHandler ) ; } public void setErrorListener ( ErrorListener handler ) { } } 	1	['7', '2', '0', '5', '29', '17', '2', '3', '6', '0.888888889', '133', '1', '2', '0.85', '0.285714286', '1', '2', '17.57142857', '2', '1', '1']
package org . apache . xml . utils ; import java . util . Stack ; import java . util . StringTokenizer ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . w3c . dom . Element ; public class QName implements java . io . Serializable { protected String _localName ; protected String _namespaceURI ; protected String _prefix ; public static final String S_XMLNAMESPACEURI = "http://www.w3.org/XML/1998/namespace" ; private int m_hashCode ; public QName ( ) { } public QName ( String namespaceURI , String localName ) { this ( namespaceURI , localName , false ) ; } public QName ( String namespaceURI , String localName , boolean validate ) { if ( localName == null ) throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_NULL , null ) ) ; if ( validate ) { if ( ! XMLChar . isValidNCName ( localName ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } _namespaceURI = namespaceURI ; _localName = localName ; m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String namespaceURI , String prefix , String localName ) { this ( namespaceURI , prefix , localName , false ) ; } public QName ( String namespaceURI , String prefix , String localName , boolean validate ) { if ( localName == null ) throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_NULL , null ) ) ; if ( validate ) { if ( ! XMLChar . isValidNCName ( localName ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } if ( ( null != prefix ) && ( ! XMLChar . isValidNCName ( prefix ) ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_PREFIX_INVALID , null ) ) ; } } _namespaceURI = namespaceURI ; _prefix = prefix ; _localName = localName ; m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String localName ) { this ( localName , false ) ; } public QName ( String localName , boolean validate ) { if ( localName == null ) throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_NULL , null ) ) ; if ( validate ) { if ( ! XMLChar . isValidNCName ( localName ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } _namespaceURI = null ; _localName = localName ; m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String qname , Stack namespaces ) { this ( qname , namespaces , false ) ; } public QName ( String qname , Stack namespaces , boolean validate ) { String namespace = null ; String prefix = null ; int indexOfNSSep = qname . indexOf ( ':' ) ; if ( indexOfNSSep > 0 ) { prefix = qname . substring ( 0 , indexOfNSSep ) ; if ( prefix . equals ( "xml" ) ) { namespace = S_XMLNAMESPACEURI ; } else if ( prefix . equals ( "xmlns" ) ) { return ; } else { int depth = namespaces . size ( ) ; for ( int i = depth - 1 ; i >= 0 ; i -- ) { NameSpace ns = ( NameSpace ) namespaces . elementAt ( i ) ; while ( null != ns ) { if ( ( null != ns . m_prefix ) && prefix . equals ( ns . m_prefix ) ) { namespace = ns . m_uri ; i = - 1 ; break ; } ns = ns . m_next ; } } } if ( null == namespace ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PREFIX_MUST_RESOLVE , new Object [ ] { prefix } ) ) ; } } _localName = ( indexOfNSSep < 0 ) ? qname : qname . substring ( indexOfNSSep + 1 ) ; if ( validate ) { if ( ( _localName == null ) || ( ! XMLChar . isValidNCName ( _localName ) ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } _namespaceURI = namespace ; _prefix = prefix ; m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String qname , Element namespaceContext , PrefixResolver resolver ) { this ( qname , namespaceContext , resolver , false ) ; } public QName ( String qname , Element namespaceContext , PrefixResolver resolver , boolean validate ) { _namespaceURI = null ; int indexOfNSSep = qname . indexOf ( ':' ) ; if ( indexOfNSSep > 0 ) { if ( null != namespaceContext ) { String prefix = qname . substring ( 0 , indexOfNSSep ) ; _prefix = prefix ; if ( prefix . equals ( "xml" ) ) { _namespaceURI = S_XMLNAMESPACEURI ; } else if ( prefix . equals ( "xmlns" ) ) { return ; } else { _namespaceURI = resolver . getNamespaceForPrefix ( prefix , namespaceContext ) ; } if ( null == _namespaceURI ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PREFIX_MUST_RESOLVE , new Object [ ] { prefix } ) ) ; } } else { } } _localName = ( indexOfNSSep < 0 ) ? qname : qname . substring ( indexOfNSSep + 1 ) ; if ( validate ) { if ( ( _localName == null ) || ( ! XMLChar . isValidNCName ( _localName ) ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } m_hashCode = toString ( ) . hashCode ( ) ; } public QName ( String qname , PrefixResolver resolver ) { this ( qname , resolver , false ) ; } public QName ( String qname , PrefixResolver resolver , boolean validate ) { String prefix = null ; _namespaceURI = null ; int indexOfNSSep = qname . indexOf ( ':' ) ; if ( indexOfNSSep > 0 ) { prefix = qname . substring ( 0 , indexOfNSSep ) ; if ( prefix . equals ( "xml" ) ) { _namespaceURI = S_XMLNAMESPACEURI ; } else { _namespaceURI = resolver . getNamespaceForPrefix ( prefix ) ; } if ( null == _namespaceURI ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_PREFIX_MUST_RESOLVE , new Object [ ] { prefix } ) ) ; } _localName = qname . substring ( indexOfNSSep + 1 ) ; } else if ( indexOfNSSep == 0 ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NAME_CANT_START_WITH_COLON , null ) ) ; } else { _localName = qname ; } if ( validate ) { if ( ( _localName == null ) || ( ! XMLChar . isValidNCName ( _localName ) ) ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ARG_LOCALNAME_INVALID , null ) ) ; } } m_hashCode = toString ( ) . hashCode ( ) ; _prefix = prefix ; } public String getNamespaceURI ( ) { return _namespaceURI ; } public String getPrefix ( ) { return _prefix ; } public String getLocalName ( ) { return _localName ; } public String toString ( ) { return _prefix != null ? ( _prefix + ":" + _localName ) : ( _namespaceURI != null ? ( "{" + _namespaceURI + "}" + _localName ) : _localName ) ; } public String toNamespacedString ( ) { return ( _namespaceURI != null ? ( "{" + _namespaceURI + "}" + _localName ) : _localName ) ; } public String getNamespace ( ) { return getNamespaceURI ( ) ; } public String getLocalPart ( ) { return getLocalName ( ) ; } public int hashCode ( ) { return m_hashCode ; } public boolean equals ( String ns , String localPart ) { String thisnamespace = getNamespaceURI ( ) ; return getLocalName ( ) . equals ( localPart ) && ( ( ( null != thisnamespace ) && ( null != ns ) ) ? thisnamespace . equals ( ns ) : ( ( null == thisnamespace ) && ( null == ns ) ) ) ; } public boolean equals ( Object object ) { if ( object == this ) return true ; if ( object instanceof QName ) { QName qname = ( QName ) object ; String thisnamespace = getNamespaceURI ( ) ; String thatnamespace = qname . getNamespaceURI ( ) ; return getLocalName ( ) . equals ( qname . getLocalName ( ) ) && ( ( ( null != thisnamespace ) && ( null != thatnamespace ) ) ? thisnamespace . equals ( thatnamespace ) : ( ( null == thisnamespace ) && ( null == thatnamespace ) ) ) ; } else return false ; } public static QName getQNameFromString ( String name ) { StringTokenizer tokenizer = new StringTokenizer ( name , "{}" , false ) ; QName qname ; String s1 = tokenizer . nextToken ( ) ; String s2 = tokenizer . hasMoreTokens ( ) ? tokenizer . nextToken ( ) : null ; if ( null == s2 ) qname = new QName ( null , s1 ) ; else qname = new QName ( s1 , s2 ) ; return qname ; } public static boolean isXMLNSDecl ( String attRawName ) { return ( attRawName . startsWith ( "xmlns" ) && ( attRawName . equals ( "xmlns" ) || attRawName . startsWith ( "xmlns:" ) ) ) ; } public static String getPrefixFromXMLNSDecl ( String attRawName ) { int index = attRawName . indexOf ( ':' ) ; return ( index >= 0 ) ? attRawName . substring ( index + 1 ) : "" ; } public static String getLocalPart ( String qname ) { int index = qname . indexOf ( ':' ) ; return ( index < 0 ) ? qname : qname . substring ( index + 1 ) ; } public static String getPrefixPart ( String qname ) { int index = qname . indexOf ( ':' ) ; return ( index >= 0 ) ? qname . substring ( 0 , index ) : "" ; } } 	1	['28', '1', '0', '53', '49', '268', '49', '4', '28', '0.562962963', '741', '0.8', '0', '0', '0.285714286', '1', '1', '25.28571429', '9', '1.4286', '2']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_pl extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Nieobsługiwana funkcja!" } , { ER_CANNOT_OVERWRITE_CAUSE , "Nie można nadpisać przyczyny" } , { ER_NO_DEFAULT_IMPL , "Nie znaleziono domyślnej implementacji" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) nie jest obecnie obsługiwane" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Przesunięcie większe niż szczelina" } , { ER_COROUTINE_NOT_AVAIL , "Koprocedura niedostępna, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager otrzymał żądanie co_exit()" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() nie powiodło się" } , { ER_COROUTINE_PARAM , "Błąd parametru koprocedury ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nNIEOCZEKIWANE: Analizator doTerminate odpowiada {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "Nie można wywołać parse podczas analizowania" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Błąd: iterator określonego typu dla osi {0} nie jest zaimplementowany" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Błąd: iterator dla osi {0} nie jest zaimplementowany" } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Kopia iteratora nie jest obsługiwana" } , { ER_UNKNOWN_AXIS_TYPE , "Nieznany typ przejścia osi {0}" } , { ER_AXIS_NOT_SUPPORTED , "Nieobsługiwane przejście osi: {0}" } , { ER_NO_DTMIDS_AVAIL , "Nie ma więcej dostępnych identyfikatorów DTM" } , { ER_NOT_SUPPORTED , "Nieobsługiwane: {0}" } , { ER_NODE_NON_NULL , "Węzeł musi być niepusty dla getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "Nie można przetłumaczyć węzła na uchwyt" } , { ER_STARTPARSE_WHILE_PARSING , "Nie można wywołać startParse podczas analizowania" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse potrzebuje niepustego SAXParser" } , { ER_COULD_NOT_INIT_PARSER , "nie można zainicjować analizatora" } , { ER_EXCEPTION_CREATING_POOL , "wyjątek podczas tworzenia nowej instancji dla puli" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Ścieżka zawiera niepoprawną sekwencję o zmienionym znaczeniu" } , { ER_SCHEME_REQUIRED , "Schemat jest wymagany!" } , { ER_NO_SCHEME_IN_URI , "Nie znaleziono schematu w URI {0}" } , { ER_NO_SCHEME_INURI , "Nie znaleziono schematu w URI" } , { ER_PATH_INVALID_CHAR , "Ścieżka zawiera niepoprawny znak {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Nie można ustawić schematu z pustego ciągu znaków" } , { ER_SCHEME_NOT_CONFORMANT , "Schemat nie jest zgodny." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Host nie jest poprawnie skonstruowanym adresem" } , { ER_PORT_WHEN_HOST_NULL , "Nie można ustawić portu, kiedy host jest pusty" } , { ER_INVALID_PORT , "Niepoprawny numer portu" } , { ER_FRAG_FOR_GENERIC_URI , "Fragment można ustawić tylko dla ogólnego URI" } , { ER_FRAG_WHEN_PATH_NULL , "Nie można ustawić fragmentu, kiedy ścieżka jest pusta" } , { ER_FRAG_INVALID_CHAR , "Fragment zawiera niepoprawny znak" } , { ER_PARSER_IN_USE , "Analizator jest już używany" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Nie można zmienić {0} {1} podczas analizowania" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Powodowanie siebie jest niedozwolone" } , { ER_NO_USERINFO_IF_NO_HOST , "Nie można podać informacji o użytkowniku, jeśli nie podano hosta" } , { ER_NO_PORT_IF_NO_HOST , "Nie można podać portu, jeśli nie podano hosta" } , { ER_NO_QUERY_STRING_IN_PATH , "Tekstu zapytania nie można podać w tekście ścieżki i zapytania" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Nie można podać fragmentu jednocześnie w ścieżce i fragmencie" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Nie można zainicjować URI z pustymi parametrami" } , { ER_METHOD_NOT_SUPPORTED , "Metoda nie jest jeszcze obsługiwana" } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter nie jest obecnie możliwy do ponownego uruchomienia" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader nie przed żądaniem startParse" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Nieobsługiwane przejście osi: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "Utworzono ListingErrorHandler z pustym PrintWriter!" } , { ER_SYSTEMID_UNKNOWN , "Nieznany identyfikator systemu" } , { ER_LOCATION_UNKNOWN , "Położenie błędu jest nieznane" } , { ER_PREFIX_MUST_RESOLVE , "Przedrostek musi dać się przetłumaczyć na przestrzeń nazw: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "Funkcja createDocument() nie jest obsługiwana w XPathContext!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Potomek atrybutu nie ma dokumentu właściciela!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Potomek atrybutu nie ma elementu dokumentu właściciela!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Ostrzeżenie: nie można wyprowadzić tekstu przed elementem dokumentu!  Ignoruję..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Nie można mieć więcej niż jeden element główny w DOM!" } , { ER_ARG_LOCALNAME_NULL , "Argument 'localName' jest pusty" } , { ER_ARG_LOCALNAME_INVALID , "Nazwa lokalna w QNAME powinna być poprawną nazwą NCName" } , { ER_ARG_PREFIX_INVALID , "Przedrostek w QNAME powinien być poprawną nazwą NCName" } , { "BAD_CODE" , "Parametr createMessage był spoza zakresu" } , { "FORMAT_FAILED" , "Podczas wywołania messageFormat zgłoszony został wyjątek" } , { "line" , "Wiersz: " } , { "column" , "Kolumna " } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "Klasa szeregująca ''{0}'' nie implementuje procedury obsługi org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "Nie można znaleźć zasobu [ {0} ].\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "Zasób [ {0} ] nie mógł załadować: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Wielkość bufora <=0" } , { ER_INVALID_UTF16_SURROGATE , "Wykryto niepoprawny surogat UTF-16: {0} ?" } , { ER_OIERROR , "Błąd we/wy" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Nie można dodać atrybutu {0} po węzłach potomnych ani przed wyprodukowaniem elementu.  Atrybut zostanie zignorowany." } , { ER_NAMESPACE_PREFIX , "Nie zadeklarowano przestrzeni nazw dla przedrostka ''{0}''." } , { ER_STRAY_ATTRIBUTE , "Atrybut ''{0}'' poza elementem." } , { ER_STRAY_NAMESPACE , "Deklaracja przestrzeni nazw ''{0}''=''{1}'' poza elementem." } , { ER_COULD_NOT_LOAD_RESOURCE , "Nie można załadować ''{0}'' (sprawdź CLASSPATH), używane są teraz wartości domyślne" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "Nie można załadować pliku właściwości ''{0}'' dla metody wyjściowej ''{1}'' (sprawdź CLASSPATH)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "pl" , "PL" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xalan ; public class Version { public static String getVersion ( ) { return getProduct ( ) + " " + getImplementationLanguage ( ) + " " + getMajorVersionNum ( ) + "." + getReleaseVersionNum ( ) + "." + ( ( getDevelopmentVersionNum ( ) > 0 ) ? ( "D" + getDevelopmentVersionNum ( ) ) : ( "" + getMaintenanceVersionNum ( ) ) ) ; } public static void main ( String argv [ ] ) { System . out . println ( getVersion ( ) ) ; } public static String getProduct ( ) { return "Xalan" ; } public static String getImplementationLanguage ( ) { return "Java" ; } public static int getMajorVersionNum ( ) { return 2 ; } public static int getReleaseVersionNum ( ) { return 6 ; } public static int getMaintenanceVersionNum ( ) { return 0 ; } public static int getDevelopmentVersionNum ( ) { try { if ( ( new String ( "" ) ) . length ( ) == 0 ) return 0 ; else return Integer . parseInt ( "" ) ; } catch ( NumberFormatException nfe ) { return 0 ; } } } 	1	['9', '1', '0', '1', '18', '36', '1', '0', '9', '2', '81', '0', '0', '0', '0.111111111', '0', '0', '8', '2', '1.1111', '4']
package org . apache . xalan . trace ; public interface TraceListenerEx3 extends TraceListenerEx2 { public void extension ( ExtensionEvent ee ) ; public void extensionEnd ( ExtensionEvent ee ) ; } 	1	['2', '1', '0', '4', '2', '1', '2', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; public class ElemAttributeSet extends ElemUse { public QName m_qname = null ; public void setName ( QName name ) { m_qname = name ; } public QName getName ( ) { return m_qname ; } public int getXSLToken ( ) { return Constants . ELEMNAME_DEFINEATTRIBUTESET ; } public String getNodeName ( ) { return Constants . ELEMNAME_ATTRIBUTESET_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; if ( transformer . isRecursiveAttrSet ( this ) ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_XSLATTRSET_USED_ITSELF , new Object [ ] { m_qname . getLocalPart ( ) } ) ) ; } transformer . pushElemAttributeSet ( this ) ; super . execute ( transformer ) ; ElemAttribute attr = ( ElemAttribute ) getFirstChildElem ( ) ; while ( null != attr ) { attr . execute ( transformer ) ; attr = ( ElemAttribute ) attr . getNextSiblingElem ( ) ; } transformer . popElemAttributeSet ( ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public ElemTemplateElement appendChildElem ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_ATTRIBUTE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } public void recompose ( StylesheetRoot root ) { root . recomposeAttributeSets ( this ) ; } } 	1	['8', '4', '0', '11', '27', '16', '6', '8', '8', '0.571428571', '109', '0', '1', '0.966507177', '0.3', '2', '4', '12.5', '3', '1.125', '2']
package org . apache . xalan . processor ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Properties ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TemplatesHandler ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TrAXFilter ; import org . apache . xalan . transformer . TransformerIdentityImpl ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . transformer . XalanProperties ; import org . apache . xml . dtm . ref . sax2dtm . SAX2DTM ; import org . apache . xml . utils . DefaultErrorHandler ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . TreeWalker ; import org . apache . xml . utils . StylesheetPIHandler ; import org . apache . xml . utils . StopParseException ; import org . w3c . dom . Node ; import org . xml . sax . InputSource ; import org . xml . sax . XMLFilter ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class TransformerFactoryImpl extends SAXTransformerFactory { public static final String XSLT_PROPERTIES = "org/apache/xalan/res/XSLTInfo.properties" ; public TransformerFactoryImpl ( ) { } public static final String FEATURE_INCREMENTAL = "http://xml.apache.org/xalan/features/incremental" ; public static final String FEATURE_OPTIMIZE = "http://xml.apache.org/xalan/features/optimize" ; public static final String FEATURE_SOURCE_LOCATION = XalanProperties . SOURCE_LOCATION ; public javax . xml . transform . Templates processFromNode ( Node node ) throws TransformerConfigurationException { try { TemplatesHandler builder = newTemplatesHandler ( ) ; TreeWalker walker = new TreeWalker ( builder , new org . apache . xml . utils . DOM2Helper ( ) , builder . getSystemId ( ) ) ; walker . traverse ( node ) ; return builder . getTemplates ( ) ; } catch ( org . xml . sax . SAXException se ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( new TransformerException ( se ) ) ; } catch ( TransformerException ex ) { throw new TransformerConfigurationException ( ex ) ; } return null ; } else throw new TransformerConfigurationException ( XSLMessages . createMessage ( XSLTErrorResources . ER_PROCESSFROMNODE_FAILED , null ) , se ) ; } catch ( TransformerConfigurationException tce ) { throw tce ; } catch ( Exception e ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( new TransformerException ( e ) ) ; } catch ( TransformerException ex ) { throw new TransformerConfigurationException ( ex ) ; } return null ; } else throw new TransformerConfigurationException ( XSLMessages . createMessage ( XSLTErrorResources . ER_PROCESSFROMNODE_FAILED , null ) , e ) ; } } private String m_DOMsystemID = null ; String getDOMsystemID ( ) { return m_DOMsystemID ; } javax . xml . transform . Templates processFromNode ( Node node , String systemID ) throws TransformerConfigurationException { m_DOMsystemID = systemID ; return processFromNode ( node ) ; } public Source getAssociatedStylesheet ( Source source , String media , String title , String charset ) throws TransformerConfigurationException { String baseID ; InputSource isource = null ; Node node = null ; XMLReader reader = null ; if ( source instanceof DOMSource ) { DOMSource dsource = ( DOMSource ) source ; node = dsource . getNode ( ) ; baseID = dsource . getSystemId ( ) ; } else { isource = SAXSource . sourceToInputSource ( source ) ; baseID = isource . getSystemId ( ) ; } StylesheetPIHandler handler = new StylesheetPIHandler ( baseID , media , title , charset ) ; if ( m_uriResolver != null ) { handler . setURIResolver ( m_uriResolver ) ; } try { if ( null != node ) { TreeWalker walker = new TreeWalker ( handler , new org . apache . xml . utils . DOM2Helper ( ) , baseID ) ; walker . traverse ( node ) ; } else { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } reader . setContentHandler ( handler ) ; reader . parse ( isource ) ; } } catch ( StopParseException spe ) { } catch ( org . xml . sax . SAXException se ) { throw new TransformerConfigurationException ( "getAssociatedStylesheets failed" , se ) ; } catch ( IOException ioe ) { throw new TransformerConfigurationException ( "getAssociatedStylesheets failed" , ioe ) ; } return handler . getAssociatedStylesheet ( ) ; } public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { return new StylesheetHandler ( this ) ; } public boolean getFeature ( String name ) { if ( ( DOMResult . FEATURE == name ) || ( DOMSource . FEATURE == name ) || ( SAXResult . FEATURE == name ) || ( SAXSource . FEATURE == name ) || ( StreamResult . FEATURE == name ) || ( StreamSource . FEATURE == name ) || ( SAXTransformerFactory . FEATURE == name ) || ( SAXTransformerFactory . FEATURE_XMLFILTER == name ) ) return true ; else if ( ( DOMResult . FEATURE . equals ( name ) ) || ( DOMSource . FEATURE . equals ( name ) ) || ( SAXResult . FEATURE . equals ( name ) ) || ( SAXSource . FEATURE . equals ( name ) ) || ( StreamResult . FEATURE . equals ( name ) ) || ( StreamSource . FEATURE . equals ( name ) ) || ( SAXTransformerFactory . FEATURE . equals ( name ) ) || ( SAXTransformerFactory . FEATURE_XMLFILTER . equals ( name ) ) ) return true ; else return false ; } public static boolean m_optimize = true ; public static boolean m_source_location = false ; public void setAttribute ( String name , Object value ) throws IllegalArgumentException { if ( name . equals ( FEATURE_INCREMENTAL ) ) { if ( value instanceof Boolean ) { org . apache . xml . dtm . DTMManager . setIncremental ( ( ( Boolean ) value ) . booleanValue ( ) ) ; } else if ( value instanceof String ) { org . apache . xml . dtm . DTMManager . setIncremental ( ( new Boolean ( ( String ) value ) ) . booleanValue ( ) ) ; } else { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_BAD_VALUE , new Object [ ] { name , value } ) ) ; } } else if ( name . equals ( FEATURE_OPTIMIZE ) ) { if ( value instanceof Boolean ) { m_optimize = ( ( Boolean ) value ) . booleanValue ( ) ; } else if ( value instanceof String ) { m_optimize = ( new Boolean ( ( String ) value ) ) . booleanValue ( ) ; } else { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_BAD_VALUE , new Object [ ] { name , value } ) ) ; } } else if ( name . equals ( FEATURE_SOURCE_LOCATION ) ) { if ( value instanceof Boolean ) { m_source_location = ( ( Boolean ) value ) . booleanValue ( ) ; SAX2DTM . setUseSourceLocation ( m_source_location ) ; } else if ( value instanceof String ) { m_source_location = ( new Boolean ( ( String ) value ) ) . booleanValue ( ) ; SAX2DTM . setUseSourceLocation ( m_source_location ) ; } else { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_BAD_VALUE , new Object [ ] { name , value } ) ) ; } } else { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_SUPPORTED , new Object [ ] { name } ) ) ; } } public Object getAttribute ( String name ) throws IllegalArgumentException { if ( name . equals ( FEATURE_INCREMENTAL ) ) { return new Boolean ( org . apache . xml . dtm . DTMManager . getIncremental ( ) ) ; } else if ( name . equals ( FEATURE_OPTIMIZE ) ) { return new Boolean ( m_optimize ) ; } else if ( name . equals ( FEATURE_SOURCE_LOCATION ) ) { return new Boolean ( m_source_location ) ; } else throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ATTRIB_VALUE_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; } public XMLFilter newXMLFilter ( Source src ) throws TransformerConfigurationException { Templates templates = newTemplates ( src ) ; if ( templates == null ) return null ; return newXMLFilter ( templates ) ; } public XMLFilter newXMLFilter ( Templates templates ) throws TransformerConfigurationException { try { return new TrAXFilter ( templates ) ; } catch ( TransformerConfigurationException ex ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( ex ) ; return null ; } catch ( TransformerException ex1 ) { new TransformerConfigurationException ( ex1 ) ; } } throw ex ; } } public TransformerHandler newTransformerHandler ( Source src ) throws TransformerConfigurationException { Templates templates = newTemplates ( src ) ; if ( templates == null ) return null ; return newTransformerHandler ( templates ) ; } public TransformerHandler newTransformerHandler ( Templates templates ) throws TransformerConfigurationException { try { TransformerImpl transformer = ( TransformerImpl ) templates . newTransformer ( ) ; transformer . setURIResolver ( m_uriResolver ) ; TransformerHandler th = ( TransformerHandler ) transformer . getInputContentHandler ( true ) ; return th ; } catch ( TransformerConfigurationException ex ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( ex ) ; return null ; } catch ( TransformerException ex1 ) { ex = new TransformerConfigurationException ( ex1 ) ; } } throw ex ; } } public TransformerHandler newTransformerHandler ( ) throws TransformerConfigurationException { return new TransformerIdentityImpl ( ) ; } public Transformer newTransformer ( Source source ) throws TransformerConfigurationException { try { Templates tmpl = newTemplates ( source ) ; if ( tmpl == null ) return null ; Transformer transformer = tmpl . newTransformer ( ) ; transformer . setURIResolver ( m_uriResolver ) ; return transformer ; } catch ( TransformerConfigurationException ex ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( ex ) ; return null ; } catch ( TransformerException ex1 ) { ex = new TransformerConfigurationException ( ex1 ) ; } } throw ex ; } } public Transformer newTransformer ( ) throws TransformerConfigurationException { return new TransformerIdentityImpl ( ) ; } public Templates newTemplates ( Source source ) throws TransformerConfigurationException { String baseID = source . getSystemId ( ) ; if ( null != baseID ) { baseID = SystemIDResolver . getAbsoluteURI ( baseID ) ; } if ( source instanceof DOMSource ) { DOMSource dsource = ( DOMSource ) source ; Node node = dsource . getNode ( ) ; if ( null != node ) return processFromNode ( node , baseID ) ; else { String messageStr = XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_DOMSOURCE_INPUT , null ) ; throw new IllegalArgumentException ( messageStr ) ; } } TemplatesHandler builder = newTemplatesHandler ( ) ; builder . setSystemId ( baseID ) ; try { InputSource isource = SAXSource . sourceToInputSource ( source ) ; isource . setSystemId ( baseID ) ; XMLReader reader = null ; if ( source instanceof SAXSource ) reader = ( ( SAXSource ) source ) . getXMLReader ( ) ; if ( null == reader ) { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } } if ( null == reader ) reader = XMLReaderFactory . createXMLReader ( ) ; reader . setContentHandler ( builder ) ; reader . parse ( isource ) ; } catch ( org . xml . sax . SAXException se ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( new TransformerException ( se ) ) ; } catch ( TransformerException ex1 ) { throw new TransformerConfigurationException ( ex1 ) ; } } else throw new TransformerConfigurationException ( se . getMessage ( ) , se ) ; } catch ( Exception e ) { if ( m_errorListener != null ) { try { m_errorListener . fatalError ( new TransformerException ( e ) ) ; return null ; } catch ( TransformerException ex1 ) { throw new TransformerConfigurationException ( ex1 ) ; } } else throw new TransformerConfigurationException ( e . getMessage ( ) , e ) ; } return builder . getTemplates ( ) ; } URIResolver m_uriResolver ; public void setURIResolver ( URIResolver resolver ) { m_uriResolver = resolver ; } public URIResolver getURIResolver ( ) { return m_uriResolver ; } private ErrorListener m_errorListener = new DefaultErrorHandler ( ) ; public ErrorListener getErrorListener ( ) { return m_errorListener ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( null == listener ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ERRORLISTENER , null ) ) ; m_errorListener = listener ; } } 	1	['23', '3', '0', '19', '75', '167', '7', '14', '20', '0.909090909', '797', '0.222222222', '0', '0.487804878', '0.207070707', '1', '2', '33.26086957', '17', '1.6087', '5']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_zh_TW extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "同一個檔案中定義一個以上的樣式表。" } , { ErrorMsg . TEMPLATE_REDEF_ERR , "此樣式表中已經有定義範本 ''{0}''。" } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "此樣式表中尚未定義範本 ''{0}''。" } , { ErrorMsg . VARIABLE_REDEF_ERR , "同一範圍中定義了多個變數 ''{0}''。" } , { ErrorMsg . VARIABLE_UNDEF_ERR , "變數或參數 ''{0}'' 尚未定義。" } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "找不到類別 ''{0}''。" } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "找不到外部方法 ''{0}''（必須是公用的）。" } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "無法將呼叫中的引數/傳回類型轉換為方法 ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "找不到檔案或 URI ''{0}''。" } , { ErrorMsg . INVALID_URI_ERR , "URI ''{0}'' 無效。" } , { ErrorMsg . FILE_ACCESS_ERR , "無法開啟檔案或 URI ''{0}''。" } , { ErrorMsg . MISSING_ROOT_ERR , "原預期為 <xsl:stylesheet> 或 <xsl:transform> 元素。" } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "尚未宣告名稱空間字首 ''{0}''。" } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "無法解析對函數 ''{0}'' 的呼叫。" } , { ErrorMsg . NEED_LITERAL_ERR , "''{0}'' 的引數必須是文字字串。" } , { ErrorMsg . XPATH_PARSER_ERR , "剖析 XPath 表示式 ''{0}'' 時發生錯誤。" } , { ErrorMsg . REQUIRED_ATTR_ERR , "遺漏必要的屬性 ''{0}''。" } , { ErrorMsg . ILLEGAL_CHAR_ERR , "XPath 表示式中包含不合法字元 ''{0}''" } , { ErrorMsg . ILLEGAL_PI_ERR , "處理指示的名稱 ''{0}'' 不合法。" } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "屬性 ''{0}'' 超出元素外。" } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "屬性 ''{0}'' 不合法。" } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "循環匯入/併入。樣式表 ''{0}'' 已經載入。" } , { ErrorMsg . RESULT_TREE_SORT_ERR , "結果樹片段無法排序（<xsl:sort> 元素被忽略）。您必須於建立結果樹時，將節點排序。" } , { ErrorMsg . SYMBOLS_REDEF_ERR , "已經有定義十進位格式 ''{0}''。" } , { ErrorMsg . XSL_VERSION_ERR , "XSLTC 不支援 XSL 版本 ''{0}''。" } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "''{0}'' 中包含循環變數/參數參照。" } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "二進位表示式的運算子不明。" } , { ErrorMsg . ILLEGAL_ARG_ERR , "函數呼叫的引數不合法。" } , { ErrorMsg . DOCUMENT_ARG_ERR , "document() 函數的第二個引數必須是節點集。" } , { ErrorMsg . MISSING_WHEN_ERR , "<xsl:choose> 中至少要有一個 <xsl:when> 元素。" } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "<xsl:choose> 中只接受一個 <xsl:otherwise> 元素。" } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> 只能用在 <xsl:choose> 中。" } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> 只能用在 <xsl:choose> 中。" } , { ErrorMsg . WHEN_ELEMENT_ERR , "<xsl:choose> 中只接受 <xsl:when> 和 <xsl:otherwise> 兩個元素。" } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set> 遺漏 'name' 屬性。" } , { ErrorMsg . ILLEGAL_CHILD_ERR , "子項元素不合法。" } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "不可以呼叫元素 ''{0}''" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "不可以呼叫屬性 ''{0}''" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "文字資料超出頂層 <xsl:stylesheet> 元素。" } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "JAXP 剖析器未正確配置" } , { ErrorMsg . INTERNAL_ERR , "發生無法復原的 XSLTC 內部錯誤：''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "XSL 元素 ''{0}'' 不受支援。" } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "XSLTC 延伸項目 ''{0}'' 無法辨識。" } , { ErrorMsg . MISSING_XSLT_URI_ERR , "輸入文件不是樣式表（XSL 名稱空間未在根元素中宣告）。" } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "找不到樣式表目標 ''{0}''。" } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "尚未實作：''{0}''。" } , { ErrorMsg . NOT_STYLESHEET_ERR , "輸入文件未包含 XSL 樣式表。" } , { ErrorMsg . ELEMENT_PARSE_ERR , "無法剖析元素 ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "<key> 的 use 屬性必須是 node、node-set、string 或 number。" } , { ErrorMsg . OUTPUT_VERSION_ERR , "輸出 XML 文件版本應該是 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "關聯式表示式的運算子不明" } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "嘗試使用不存在的屬性集 ''{0}''。" } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "無法剖析屬性值範本 ''{0}''。" } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "類別 ''{0}'' 中的簽章資料類型不明。" } , { ErrorMsg . DATA_CONVERSION_ERR , "無法將資料類型 ''{0}'' 轉換為 ''{1}''。" } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "此 Templates 未包含有效的 translet 類別定義。" } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "此範本未包含名稱為 ''{0}'' 的類別。" } , { ErrorMsg . TRANSLET_CLASS_ERR , "無法載入 translet 類別 ''{0}''。" } , { ErrorMsg . TRANSLET_OBJECT_ERR , "已載入 Translet 類別，但是無法建立 translet 實例。" } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "嘗試將 ''{0}'' 的 ErrorListener 設為 null" } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "XSLTC 只支援 StreamSource、SAXSource 與 DOMSource" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "傳遞給 ''{0}'' 的 Source 物件沒有內容。" } , { ErrorMsg . JAXP_COMPILE_ERR , "無法編譯樣式表" } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory 無法辨識屬性 ''{0}''。" } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() 必須在 startDocument() 之前呼叫。" } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformer 沒有簡化的 translet 物件。" } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "沒有已定義的輸出處理程式供轉換結果使用。" } , { ErrorMsg . JAXP_NO_RESULT_ERR , "傳遞給 ''{0}'' 的 Result 物件無效。" } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "嘗試存取無效的 Transformer 內容 ''{0}''。" } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "無法建立 SAX2DOM 配接卡：''{0}''。" } , { ErrorMsg . XSLTC_SOURCE_ERR , "呼叫 XSLTCSource.build() 時，未設定 systemId 。" } , { ErrorMsg . COMPILE_STDIN_ERR , "-i 選項必須和 -o 選項一起使用。" } , { ErrorMsg . COMPILE_USAGE_STR , "概要\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]\n      [-d <directory>] [-j <jarfile>] [-p <package>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }\n\n選項\n   -o <output>    指定名稱 <output> 給產生的\n                  translet。依預設，translet 名稱\n                  是從 <stylesheet> 名稱取出。若編譯\n                  多份樣式表時，此選項會被忽略。\n   -d <directory> 指定 translet 的目標目錄\n   -j <jarfile>   將 translet 類別封裝在 jar 檔案中，該檔案\n                  名稱由 <jarfile> 指定\n   -p <package>   指定所有產生的\n                  translet 類別之套件名稱字首。\n   -n             啟用範本列入（平均而言，預設行為較佳）。\n                  \n   -x             開啟額外的除錯訊息輸出\n   -s             停用呼叫 System.exit\n   -u             將 <stylesheet> 引數解譯為 URL\n   -i             強迫編譯器從 stdin 讀取樣式表\n   -v             列印編譯器的版本\n   -h             列印此用法陳述\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "概要\n   java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]\n      [-x] [-s] [-n <iterations>]{-u <document_url> | <document>}\n      <class> [<param1>=<value1> ...]\n\n   使用 translet <class> 轉換 \n   指定作為 <document> 的 XML 文件。translet <class> 位於\n   使用者的 CLASSPATH 中，或選擇性指定的 <jarfile> 中。\n選項\n   -j <jarfile>    指定用來載入 translet 的 jar 檔案\n   -x              開啟額外的除錯訊息輸出\n   -s              停用呼叫 System.exit\n   -n <iterations> 執行轉換 <iterations> 次以及\n                   顯示設定檔資訊\n   -u <document_url> 指定 XML 輸入文件為 URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> 只能用在 <xsl:for-each> 或 <xsl:apply-templates> 內。" } , { ErrorMsg . UNSUPPORTED_ENCODING , "此 JVM 不支援輸出編碼 ''{0}''。" } , { ErrorMsg . SYNTAX_ERR , "''{0}'' 中有語法錯誤。" } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "找不到外部建構子 ''{0}''。" } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "非靜態 Java 函數 ''{0}'' 的第一個引數不是有效的物件參照。" } , { ErrorMsg . TYPE_CHECK_ERR , "檢查表示式 ''{0}'' 的類型時發生錯誤。" } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "在不明位置檢查表示式的類型時，發生錯誤。" } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "指令行選項 ''{0}'' 無效。" } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "指令行選項 ''{0}'' 遺漏必要的引數。" } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "警告：''{0}''\n       ：{1}" } , { ErrorMsg . WARNING_MSG , "警告：''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "嚴重錯誤：''{0}''\n           ：{1}" } , { ErrorMsg . FATAL_ERR_MSG , "嚴重錯誤：''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "錯誤：''{0}''\n     ：{1}" } , { ErrorMsg . ERROR_MSG , "錯誤：''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "使用 translet ''{0}'' 進行轉換 " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "使用來自 jar 檔案 ''{1}'' 的 translet ''{0}'' 進行轉換" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "無法建立 TransformerFactory 類別 ''{0}'' 的實例。" } , { ErrorMsg . COMPILER_ERROR_KEY , "編譯器錯誤：" } , { ErrorMsg . COMPILER_WARNING_KEY , "編譯器警告：" } , { ErrorMsg . RUNTIME_ERROR_KEY , "編譯器錯誤：" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_sk extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Funkcia nie je podporovaná!" } , { ER_CANNOT_OVERWRITE_CAUSE , "Nie je možné prepísať príčinu" } , { ER_NO_DEFAULT_IMPL , "Nebola nájdená žiadna predvolená implementácia " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) nie je momentálne podporovaný" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Offset väčší, než zásuvka" } , { ER_COROUTINE_NOT_AVAIL , "Korutina nie je dostupná, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager obdržal požiadavku co_exit()" } , { ER_COJOINROUTINESET_FAILED , "zlyhal co_joinCoroutineSet()" } , { ER_COROUTINE_PARAM , "Chyba parametra korutiny ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nNEOČAKÁVANÉ: Analyzátor doTerminate odpovedá {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "syntaktický analyzátor nemôže byť volaný počas vykonávania analýzy" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Chyba: napísaný iterátor pre os {0} nie je implementovaný" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Chyba: iterátor pre os {0} nie je implementovaný " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Klon iterátora nie je podporovaný" } , { ER_UNKNOWN_AXIS_TYPE , "Neznámy typ pretínania osí: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Pretínanie osí nie je podporované: {0}" } , { ER_NO_DTMIDS_AVAIL , "Žiadne ďalšie DTM ID nie sú dostupné" } , { ER_NOT_SUPPORTED , "Nie je podporované: {0}" } , { ER_NODE_NON_NULL , "Pre getDTMHandleFromNode musí byť uzol nenulový" } , { ER_COULD_NOT_RESOLVE_NODE , "Nebolo možné určiť uzol na spracovanie" } , { ER_STARTPARSE_WHILE_PARSING , "startParse nemôže byť volaný počas vykonávania analýzy" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse potrebuje nenulový SAXParser" } , { ER_COULD_NOT_INIT_PARSER , "nebolo možné inicializovať syntaktický analyzátor pomocou" } , { ER_EXCEPTION_CREATING_POOL , "výnimka vytvárania novej inštancie oblasti" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Cesta obsahuje neplatnú únikovú sekvenciu" } , { ER_SCHEME_REQUIRED , "Je požadovaná schéma!" } , { ER_NO_SCHEME_IN_URI , "V URI sa nenašla žiadna schéma: {0}" } , { ER_NO_SCHEME_INURI , "V URI nebola nájdená žiadna schéma" } , { ER_PATH_INVALID_CHAR , "Cesta obsahuje neplatný znak: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Nie je možné stanoviť schému z nulového reťazca" } , { ER_SCHEME_NOT_CONFORMANT , "Nezhodná schéma." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Hostiteľ nie je správne formátovaná adresa" } , { ER_PORT_WHEN_HOST_NULL , "Nemôže byť stanovený port, ak je hostiteľ null" } , { ER_INVALID_PORT , "Neplatné číslo portu" } , { ER_FRAG_FOR_GENERIC_URI , "Fragment môže byť stanovený len pre všeobecné URI" } , { ER_FRAG_WHEN_PATH_NULL , "Ak je cesta nulová, nemôže byť stanovený fragment" } , { ER_FRAG_INVALID_CHAR , "Fragment obsahuje neplatný znak" } , { ER_PARSER_IN_USE , "Syntaktický analyzátor je už používaný" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Nie je možné zmeniť {0} {1} počas vykonávania analýzy" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Samozapríčinenie nie je povolené" } , { ER_NO_USERINFO_IF_NO_HOST , "Ak nebol zadaný hostiteľ, možno nebolo zadané userinfo" } , { ER_NO_PORT_IF_NO_HOST , "Ak nebol zadaný hostiteľ, možno nebol zadaný port" } , { ER_NO_QUERY_STRING_IN_PATH , "Reťazec dotazu nemôže byť zadaný v ceste a reťazci dotazu" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Fragment nemôže byť zadaný v ceste, ani vo fragmente" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Nie je možné inicializovať URI s prázdnymi parametrami" } , { ER_METHOD_NOT_SUPPORTED , "Metóda ešte nie je podporovaná " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter nie je momentálne reštartovateľný" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader nepredchádza požiadavke na startParse" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Pretínanie osí nie je podporované: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler vytvorený s nulovým PrintWriter!" } , { ER_SYSTEMID_UNKNOWN , "Neznáme SystemId" } , { ER_LOCATION_UNKNOWN , "Neznáme miesto výskytu chyby" } , { ER_PREFIX_MUST_RESOLVE , "Predpona sa musí rozlíšiť do názvového priestoru: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() nie je podporované XPathContext!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Potomok atribútu nemá dokument vlastníka!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Potomok atribútu nemá súčasť dokumentu vlastníka!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Upozornenie: nemožno vypustiť text pred elementom dokumentu!  Ignorovanie..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Nie je možné mať viac, než jeden koreň DOM!" } , { ER_ARG_LOCALNAME_NULL , "Argument 'localName' je null" } , { ER_ARG_LOCALNAME_INVALID , "Lokálny názov v QNAME by mal byť platným NCName" } , { ER_ARG_PREFIX_INVALID , "Predpona v QNAME by mala byť platným NCName" } , { "BAD_CODE" , "Parameter na createMessage bol mimo ohraničenia" } , { "FORMAT_FAILED" , "Výnimka počas volania messageFormat" } , { "line" , "Riadok #" } , { "column" , "Stĺpec #" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "Trieda serializátora ''{0}'' neimplementuje org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "Prostriedok [ {0} ] nemohol byť nájdený.\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "Prostriedok [ {0} ] sa nedal načítať: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Veľkosť vyrovnávacej pamäte <=0" } , { ER_INVALID_UTF16_SURROGATE , "Bolo zistené neplatné nahradenie UTF-16: {0} ?" } , { ER_OIERROR , "chyba IO" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Nie je možné pridať atribút {0} po uzloch potomka alebo pred vytvorením elementu.  Atribút bude ignorovaný." } , { ER_NAMESPACE_PREFIX , "Názvový priestor pre predponu ''{0}'' nebol deklarovaný." } , { ER_STRAY_ATTRIBUTE , "Atribút ''{0}'' je mimo elementu." } , { ER_STRAY_NAMESPACE , "Deklarácia názvového priestoru ''{0}''=''{1}'' je mimo elementu." } , { ER_COULD_NOT_LOAD_RESOURCE , "Nedalo sa načítať ''{0}'' (skontrolujte CLASSPATH), používajú sa predvolené hodnoty" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "Nedal sa načítať súbor vlastností ''{0}'' pre výstupnú metódu ''{1}'' (skontrolujte CLASSPATH)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xml . dtm . ref . sax2dtm ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import org . apache . xml . dtm . * ; import org . apache . xml . dtm . ref . * ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . IntVector ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . SuballocatedIntVector ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . * ; import org . xml . sax . ext . * ; public class SAX2DTM extends DTMDefaultBaseIterators implements EntityResolver , DTDHandler , ContentHandler , ErrorHandler , DeclHandler , LexicalHandler { private static final boolean DEBUG = false ; private IncrementalSAXSource m_incrementalSAXSource = null ; protected FastStringBuffer m_chars ; protected SuballocatedIntVector m_data ; transient protected IntStack m_parents ; transient protected int m_previous = 0 ; transient protected java . util . Vector m_prefixMappings = new java . util . Vector ( ) ; transient protected IntStack m_contextIndexes ; transient protected int m_textType = DTM . TEXT_NODE ; transient protected int m_coalescedTextType = DTM . TEXT_NODE ; transient protected Locator m_locator = null ; transient private String m_systemId = null ; transient protected boolean m_insideDTD = false ; protected DTMTreeWalker m_walker = new DTMTreeWalker ( ) ; protected DTMStringPool m_valuesOrPrefixes ; protected boolean m_endDocumentOccured = false ; protected SuballocatedIntVector m_dataOrQName ; protected Hashtable m_idAttributes = new Hashtable ( ) ; static final String [ ] m_fixednames = { null , null , null , "#text" , "#cdata_section" , null , null , null , "#comment" , "#document" , null , "#document-fragment" , null } ; private Vector m_entities = null ; private static final int ENTITY_FIELD_PUBLICID = 0 ; private static final int ENTITY_FIELD_SYSTEMID = 1 ; private static final int ENTITY_FIELD_NOTATIONNAME = 2 ; private static final int ENTITY_FIELD_NAME = 3 ; private static final int ENTITY_FIELDS_PER = 4 ; protected int m_textPendingStart = - 1 ; protected boolean m_useSourceLocationProperty = false ; protected static boolean m_source_location = false ; protected StringVector m_sourceSystemId ; protected IntVector m_sourceLine ; protected IntVector m_sourceColumn ; public SAX2DTM ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { this ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , DEFAULT_BLOCKSIZE , true , false ) ; } public SAX2DTM ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib , boolean newNameTable ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , usePrevsib , newNameTable ) ; if ( blocksize <= 64 ) { m_data = new SuballocatedIntVector ( blocksize , DEFAULT_NUMBLOCKS_SMALL ) ; m_dataOrQName = new SuballocatedIntVector ( blocksize , DEFAULT_NUMBLOCKS_SMALL ) ; m_valuesOrPrefixes = new DTMStringPool ( 16 ) ; m_chars = new FastStringBuffer ( 7 , 10 ) ; m_contextIndexes = new IntStack ( 4 ) ; m_parents = new IntStack ( 4 ) ; } else { m_data = new SuballocatedIntVector ( blocksize , DEFAULT_NUMBLOCKS ) ; m_dataOrQName = new SuballocatedIntVector ( blocksize , DEFAULT_NUMBLOCKS ) ; m_valuesOrPrefixes = new DTMStringPool ( ) ; m_chars = new FastStringBuffer ( 10 , 13 ) ; m_contextIndexes = new IntStack ( ) ; m_parents = new IntStack ( ) ; } m_data . addElement ( 0 ) ; m_useSourceLocationProperty = m_source_location ; m_sourceSystemId = ( m_useSourceLocationProperty ) ? new StringVector ( ) : null ; m_sourceLine = ( m_useSourceLocationProperty ) ? new IntVector ( ) : null ; m_sourceColumn = ( m_useSourceLocationProperty ) ? new IntVector ( ) : null ; } public static void setUseSourceLocation ( boolean useSourceLocation ) { m_source_location = useSourceLocation ; } protected int _dataOrQName ( int identity ) { if ( identity < m_size ) return m_dataOrQName . elementAt ( identity ) ; while ( true ) { boolean isMore = nextNode ( ) ; if ( ! isMore ) return NULL ; else if ( identity < m_size ) return m_dataOrQName . elementAt ( identity ) ; } } public void clearCoRoutine ( ) { clearCoRoutine ( true ) ; } public void clearCoRoutine ( boolean callDoTerminate ) { if ( null != m_incrementalSAXSource ) { if ( callDoTerminate ) m_incrementalSAXSource . deliverMoreNodes ( false ) ; m_incrementalSAXSource = null ; } } public void setIncrementalSAXSource ( IncrementalSAXSource incrementalSAXSource ) { m_incrementalSAXSource = incrementalSAXSource ; incrementalSAXSource . setContentHandler ( this ) ; incrementalSAXSource . setLexicalHandler ( this ) ; incrementalSAXSource . setDTDHandler ( this ) ; } public ContentHandler getContentHandler ( ) { if ( m_incrementalSAXSource instanceof IncrementalSAXSource_Filter ) return ( ContentHandler ) m_incrementalSAXSource ; else return this ; } public LexicalHandler getLexicalHandler ( ) { if ( m_incrementalSAXSource instanceof IncrementalSAXSource_Filter ) return ( LexicalHandler ) m_incrementalSAXSource ; else return this ; } public EntityResolver getEntityResolver ( ) { return this ; } public DTDHandler getDTDHandler ( ) { return this ; } public ErrorHandler getErrorHandler ( ) { return this ; } public DeclHandler getDeclHandler ( ) { return this ; } public boolean needsTwoThreads ( ) { return null != m_incrementalSAXSource ; } public void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws SAXException { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return ; int type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } else { int firstChild = _firstch ( identity ) ; if ( DTM . NULL != firstChild ) { int offset = - 1 ; int length = 0 ; int startNode = identity ; identity = firstChild ; do { type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; if ( - 1 == offset ) { offset = m_data . elementAt ( dataIndex ) ; } length += m_data . elementAt ( dataIndex + 1 ) ; } identity = getNextNodeIdentity ( identity ) ; } while ( DTM . NULL != identity && ( _parent ( identity ) >= startNode ) ) ; if ( length > 0 ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } } else if ( type != DTM . ELEMENT_NODE ) { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } String str = m_valuesOrPrefixes . indexToString ( dataIndex ) ; if ( normalize ) FastStringBuffer . sendNormalizedSAXcharacters ( str . toCharArray ( ) , 0 , str . length ( ) , ch ) ; else ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } } } public String getNodeName ( int nodeHandle ) { int expandedTypeID = getExpandedTypeID ( nodeHandle ) ; int namespaceID = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; if ( 0 == namespaceID ) { int type = getNodeType ( nodeHandle ) ; if ( type == DTM . NAMESPACE_NODE ) { if ( null == m_expandedNameTable . getLocalName ( expandedTypeID ) ) return "xmlns" ; else return "xmlns:" + m_expandedNameTable . getLocalName ( expandedTypeID ) ; } else if ( 0 == m_expandedNameTable . getLocalNameID ( expandedTypeID ) ) { return m_fixednames [ type ] ; } else return m_expandedNameTable . getLocalName ( expandedTypeID ) ; } else { int qnameIndex = m_dataOrQName . elementAt ( makeNodeIdentity ( nodeHandle ) ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public String getNodeNameX ( int nodeHandle ) { int expandedTypeID = getExpandedTypeID ( nodeHandle ) ; int namespaceID = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; if ( 0 == namespaceID ) { String name = m_expandedNameTable . getLocalName ( expandedTypeID ) ; if ( name == null ) return "" ; else return name ; } else { int qnameIndex = m_dataOrQName . elementAt ( makeNodeIdentity ( nodeHandle ) ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public boolean isAttributeSpecified ( int attributeHandle ) { return true ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } protected int getNextNodeIdentity ( int identity ) { identity += 1 ; while ( identity >= m_size ) { if ( null == m_incrementalSAXSource ) return DTM . NULL ; nextNode ( ) ; } return identity ; } public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { DTMTreeWalker treeWalker = m_walker ; ContentHandler prevCH = treeWalker . getcontentHandler ( ) ; if ( null != prevCH ) { treeWalker = new DTMTreeWalker ( ) ; } treeWalker . setcontentHandler ( ch ) ; treeWalker . setDTM ( this ) ; try { treeWalker . traverse ( nodeHandle ) ; } finally { treeWalker . setcontentHandler ( null ) ; } } public int getNumberOfNodes ( ) { return m_size ; } protected boolean nextNode ( ) { if ( null == m_incrementalSAXSource ) return false ; if ( m_endDocumentOccured ) { clearCoRoutine ( ) ; return false ; } Object gotMore = m_incrementalSAXSource . deliverMoreNodes ( true ) ; if ( ! ( gotMore instanceof Boolean ) ) { if ( gotMore instanceof RuntimeException ) { throw ( RuntimeException ) gotMore ; } else if ( gotMore instanceof Exception ) { throw new WrappedRuntimeException ( ( Exception ) gotMore ) ; } clearCoRoutine ( ) ; return false ; } if ( gotMore != Boolean . TRUE ) { clearCoRoutine ( ) ; } return true ; } private final boolean isTextType ( int type ) { return ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) ; } protected int addNode ( int type , int expandedTypeID , int parentIndex , int previousSibling , int dataOrPrefix , boolean canHaveFirstChild ) { int nodeIndex = m_size ++ ; if ( m_dtmIdent . size ( ) == ( nodeIndex > > > DTMManager . IDENT_DTM_NODE_BITS ) ) { addNewDTMID ( nodeIndex ) ; } m_firstch . addElement ( canHaveFirstChild ? NOTPROCESSED : DTM . NULL ) ; m_nextsib . addElement ( NOTPROCESSED ) ; m_parent . addElement ( parentIndex ) ; m_exptype . addElement ( expandedTypeID ) ; m_dataOrQName . addElement ( dataOrPrefix ) ; if ( m_prevsib != null ) { m_prevsib . addElement ( previousSibling ) ; } if ( DTM . NULL != previousSibling ) { m_nextsib . setElementAt ( nodeIndex , previousSibling ) ; } if ( m_locator != null && m_useSourceLocationProperty ) { setSourceLocation ( ) ; } switch ( type ) { case DTM . NAMESPACE_NODE : declareNamespaceInContext ( parentIndex , nodeIndex ) ; break ; case DTM . ATTRIBUTE_NODE : break ; default : if ( DTM . NULL == previousSibling && DTM . NULL != parentIndex ) { m_firstch . setElementAt ( nodeIndex , parentIndex ) ; } break ; } return nodeIndex ; } protected void addNewDTMID ( int nodeIndex ) { try { if ( m_mgr == null ) throw new ClassCastException ( ) ; DTMManagerDefault mgrD = ( DTMManagerDefault ) m_mgr ; int id = mgrD . getFirstFreeDTMID ( ) ; mgrD . addDTM ( this , id , nodeIndex ) ; m_dtmIdent . addElement ( id << DTMManager . IDENT_DTM_NODE_BITS ) ; } catch ( ClassCastException e ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DTMIDS_AVAIL , null ) ) ; } } public void migrateTo ( DTMManager manager ) { super . migrateTo ( manager ) ; int numDTMs = m_dtmIdent . size ( ) ; int dtmId = m_mgrDefault . getFirstFreeDTMID ( ) ; int nodeIndex = 0 ; for ( int i = 0 ; i < numDTMs ; i ++ ) { m_dtmIdent . setElementAt ( dtmId << DTMManager . IDENT_DTM_NODE_BITS , i ) ; m_mgrDefault . addDTM ( this , dtmId , nodeIndex ) ; dtmId ++ ; nodeIndex += ( 1 << DTMManager . IDENT_DTM_NODE_BITS ) ; } } protected void setSourceLocation ( ) { m_sourceSystemId . addElement ( m_locator . getSystemId ( ) ) ; m_sourceLine . addElement ( m_locator . getLineNumber ( ) ) ; m_sourceColumn . addElement ( m_locator . getColumnNumber ( ) ) ; if ( m_sourceSystemId . size ( ) != m_size ) { System . err . println ( "CODING ERROR in Source Location: " + m_size + " != " + m_sourceSystemId . size ( ) ) ; System . exit ( 1 ) ; } } public String getNodeValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; return m_chars . getString ( offset , length ) ; } else if ( DTM . ELEMENT_NODE == type || DTM . DOCUMENT_FRAGMENT_NODE == type || DTM . DOCUMENT_NODE == type ) { return null ; } else { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } } public String getLocalName ( int nodeHandle ) { return m_expandedNameTable . getLocalName ( _exptype ( makeNodeIdentity ( nodeHandle ) ) ) ; } public String getUnparsedEntityURI ( String name ) { String url = "" ; if ( null == m_entities ) return url ; int n = m_entities . size ( ) ; for ( int i = 0 ; i < n ; i += ENTITY_FIELDS_PER ) { String ename = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_NAME ) ; if ( null != ename && ename . equals ( name ) ) { String nname = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_NOTATIONNAME ) ; if ( null != nname ) { url = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_SYSTEMID ) ; if ( null == url ) { url = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_PUBLICID ) ; } } break ; } } return url ; } public String getPrefix ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type = _type ( identity ) ; if ( DTM . ELEMENT_NODE == type ) { int prefixIndex = _dataOrQName ( identity ) ; if ( 0 == prefixIndex ) return "" ; else { String qname = m_valuesOrPrefixes . indexToString ( prefixIndex ) ; return getPrefix ( qname , null ) ; } } else if ( DTM . ATTRIBUTE_NODE == type ) { int prefixIndex = _dataOrQName ( identity ) ; if ( prefixIndex < 0 ) { prefixIndex = m_data . elementAt ( - prefixIndex ) ; String qname = m_valuesOrPrefixes . indexToString ( prefixIndex ) ; return getPrefix ( qname , null ) ; } } return "" ; } public int getAttributeNode ( int nodeHandle , String namespaceURI , String name ) { for ( int attrH = getFirstAttribute ( nodeHandle ) ; DTM . NULL != attrH ; attrH = getNextAttribute ( attrH ) ) { String attrNS = getNamespaceURI ( attrH ) ; String attrName = getLocalName ( attrH ) ; boolean nsMatch = namespaceURI == attrNS || ( namespaceURI != null && namespaceURI . equals ( attrNS ) ) ; if ( nsMatch && name . equals ( attrName ) ) return attrH ; } return DTM . NULL ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } public String getNamespaceURI ( int nodeHandle ) { return m_expandedNameTable . getNamespace ( _exptype ( makeNodeIdentity ( nodeHandle ) ) ) ; } public XMLString getStringValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type ; if ( identity == DTM . NULL ) type = DTM . NULL ; else type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; return m_xstrf . newstr ( m_chars , offset , length ) ; } else { int firstChild = _firstch ( identity ) ; if ( DTM . NULL != firstChild ) { int offset = - 1 ; int length = 0 ; int startNode = identity ; identity = firstChild ; do { type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; if ( - 1 == offset ) { offset = m_data . elementAt ( dataIndex ) ; } length += m_data . elementAt ( dataIndex + 1 ) ; } identity = getNextNodeIdentity ( identity ) ; } while ( DTM . NULL != identity && ( _parent ( identity ) >= startNode ) ) ; if ( length > 0 ) { return m_xstrf . newstr ( m_chars , offset , length ) ; } } else if ( type != DTM . ELEMENT_NODE ) { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return m_xstrf . newstr ( m_valuesOrPrefixes . indexToString ( dataIndex ) ) ; } } return m_xstrf . emptystr ( ) ; } public boolean isWhitespace ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type ; if ( identity == DTM . NULL ) type = DTM . NULL ; else type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; return m_chars . isWhitespace ( offset , length ) ; } return false ; } public int getElementById ( String elementId ) { Integer intObj ; boolean isMore = true ; do { intObj = ( Integer ) m_idAttributes . get ( elementId ) ; if ( null != intObj ) return makeNodeHandle ( intObj . intValue ( ) ) ; if ( ! isMore || m_endDocumentOccured ) break ; isMore = nextNode ( ) ; } while ( null == intObj ) ; return DTM . NULL ; } public String getPrefix ( String qname , String uri ) { String prefix ; int uriIndex = - 1 ; if ( null != uri && uri . length ( ) > 0 ) { do { uriIndex = m_prefixMappings . indexOf ( uri , ++ uriIndex ) ; } while ( ( uriIndex & 0x01 ) == 0 ) ; if ( uriIndex >= 0 ) { prefix = ( String ) m_prefixMappings . elementAt ( uriIndex - 1 ) ; } else if ( null != qname ) { int indexOfNSSep = qname . indexOf ( ':' ) ; if ( qname . equals ( "xmlns" ) ) prefix = "" ; else if ( qname . startsWith ( "xmlns:" ) ) prefix = qname . substring ( indexOfNSSep + 1 ) ; else prefix = ( indexOfNSSep > 0 ) ? qname . substring ( 0 , indexOfNSSep ) : null ; } else { prefix = null ; } } else if ( null != qname ) { int indexOfNSSep = qname . indexOf ( ':' ) ; if ( indexOfNSSep > 0 ) { if ( qname . startsWith ( "xmlns:" ) ) prefix = qname . substring ( indexOfNSSep + 1 ) ; else prefix = qname . substring ( 0 , indexOfNSSep ) ; } else { if ( qname . equals ( "xmlns" ) ) prefix = "" ; else prefix = null ; } } else { prefix = null ; } return prefix ; } public int getIdForNamespace ( String uri ) { return m_valuesOrPrefixes . stringToIndex ( uri ) ; } public String getNamespaceURI ( String prefix ) { String uri = "" ; int prefixIndex = m_contextIndexes . peek ( ) - 1 ; if ( null == prefix ) prefix = "" ; do { prefixIndex = m_prefixMappings . indexOf ( prefix , ++ prefixIndex ) ; } while ( ( prefixIndex >= 0 ) && ( prefixIndex & 0x01 ) == 0x01 ) ; if ( prefixIndex > - 1 ) { uri = ( String ) m_prefixMappings . elementAt ( prefixIndex + 1 ) ; } return uri ; } public void setIDAttribute ( String id , int elem ) { m_idAttributes . put ( id , new Integer ( elem ) ) ; } protected void charactersFlush ( ) { if ( m_textPendingStart >= 0 ) { int length = m_chars . size ( ) - m_textPendingStart ; boolean doStrip = false ; if ( getShouldStripWhitespace ( ) ) { doStrip = m_chars . isWhitespace ( m_textPendingStart , length ) ; } if ( doStrip ) m_chars . setLength ( m_textPendingStart ) ; else { int exName = m_expandedNameTable . getExpandedTypeID ( DTM . TEXT_NODE ) ; int dataIndex = m_data . size ( ) ; m_previous = addNode ( m_coalescedTextType , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; m_data . addElement ( m_textPendingStart ) ; m_data . addElement ( length ) ; } m_textPendingStart = - 1 ; m_textType = m_coalescedTextType = DTM . TEXT_NODE ; } } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException { return null ; } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( null == m_entities ) { m_entities = new Vector ( ) ; } try { systemId = SystemIDResolver . getAbsoluteURI ( systemId , getDocumentBaseURI ( ) ) ; } catch ( Exception e ) { throw new org . xml . sax . SAXException ( e ) ; } m_entities . addElement ( publicId ) ; m_entities . addElement ( systemId ) ; m_entities . addElement ( notationName ) ; m_entities . addElement ( name ) ; } public void setDocumentLocator ( Locator locator ) { m_locator = locator ; m_systemId = locator . getSystemId ( ) ; } public void startDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "startDocument" ) ; int doc = addNode ( DTM . DOCUMENT_NODE , m_expandedNameTable . getExpandedTypeID ( DTM . DOCUMENT_NODE ) , DTM . NULL , DTM . NULL , 0 , true ) ; m_parents . push ( doc ) ; m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "endDocument" ) ; charactersFlush ( ) ; m_nextsib . setElementAt ( NULL , 0 ) ; if ( m_firstch . elementAt ( 0 ) == NOTPROCESSED ) m_firstch . setElementAt ( NULL , 0 ) ; if ( DTM . NULL != m_previous ) m_nextsib . setElementAt ( DTM . NULL , m_previous ) ; m_parents = null ; m_prefixMappings = null ; m_contextIndexes = null ; m_endDocumentOccured = true ; m_locator = null ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { if ( DEBUG ) System . out . println ( "startPrefixMapping: prefix: " + prefix + ", uri: " + uri ) ; if ( null == prefix ) prefix = "" ; m_prefixMappings . addElement ( prefix ) ; m_prefixMappings . addElement ( uri ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { if ( DEBUG ) System . out . println ( "endPrefixMapping: prefix: " + prefix ) ; if ( null == prefix ) prefix = "" ; int index = m_contextIndexes . peek ( ) - 1 ; do { index = m_prefixMappings . indexOf ( prefix , ++ index ) ; } while ( ( index >= 0 ) && ( ( index & 0x01 ) == 0x01 ) ) ; if ( index > - 1 ) { m_prefixMappings . setElementAt ( "%@$#^@#" , index ) ; m_prefixMappings . setElementAt ( "%@$#^@#" , index + 1 ) ; } } protected boolean declAlreadyDeclared ( String prefix ) { int startDecls = m_contextIndexes . peek ( ) ; java . util . Vector prefixMappings = m_prefixMappings ; int nDecls = prefixMappings . size ( ) ; for ( int i = startDecls ; i < nDecls ; i += 2 ) { String prefixDecl = ( String ) prefixMappings . elementAt ( i ) ; if ( prefixDecl == null ) continue ; if ( prefixDecl . equals ( prefix ) ) return true ; } return false ; } boolean m_pastFirstElement = false ; public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( DEBUG ) { System . out . println ( "startElement: uri: " + uri + ", localname: " + localName + ", qname: " + qName + ", atts: " + attributes ) ; boolean DEBUG_ATTRS = true ; if ( DEBUG_ATTRS & attributes != null ) { int n = attributes . getLength ( ) ; if ( n == 0 ) System . out . println ( "\tempty attribute list" ) ; else for ( int i = 0 ; i < n ; i ++ ) System . out . println ( "\t attr: uri: " + attributes . getURI ( i ) + ", localname: " + attributes . getLocalName ( i ) + ", qname: " + attributes . getQName ( i ) + ", type: " + attributes . getType ( i ) + ", value: " + attributes . getValue ( i ) ) ; } } charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( uri , localName , DTM . ELEMENT_NODE ) ; String prefix = getPrefix ( qName , uri ) ; int prefixIndex = ( null != prefix ) ? m_valuesOrPrefixes . stringToIndex ( qName ) : 0 ; int elemNode = addNode ( DTM . ELEMENT_NODE , exName , m_parents . peek ( ) , m_previous , prefixIndex , true ) ; if ( m_indexing ) indexNode ( exName , elemNode ) ; m_parents . push ( elemNode ) ; int startDecls = m_contextIndexes . peek ( ) ; int nDecls = m_prefixMappings . size ( ) ; int prev = DTM . NULL ; if ( ! m_pastFirstElement ) { prefix = "xml" ; String declURL = "http://www.w3.org/XML/1998/namespace" ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; int val = m_valuesOrPrefixes . stringToIndex ( declURL ) ; prev = addNode ( DTM . NAMESPACE_NODE , exName , elemNode , prev , val , false ) ; m_pastFirstElement = true ; } for ( int i = startDecls ; i < nDecls ; i += 2 ) { prefix = ( String ) m_prefixMappings . elementAt ( i ) ; if ( prefix == null ) continue ; String declURL = ( String ) m_prefixMappings . elementAt ( i + 1 ) ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; int val = m_valuesOrPrefixes . stringToIndex ( declURL ) ; prev = addNode ( DTM . NAMESPACE_NODE , exName , elemNode , prev , val , false ) ; } int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String attrUri = attributes . getURI ( i ) ; String attrQName = attributes . getQName ( i ) ; String valString = attributes . getValue ( i ) ; prefix = getPrefix ( attrQName , attrUri ) ; int nodeType ; String attrLocalName = attributes . getLocalName ( i ) ; if ( ( null != attrQName ) && ( attrQName . equals ( "xmlns" ) || attrQName . startsWith ( "xmlns:" ) ) ) { if ( declAlreadyDeclared ( prefix ) ) continue ; nodeType = DTM . NAMESPACE_NODE ; } else { nodeType = DTM . ATTRIBUTE_NODE ; if ( attributes . getType ( i ) . equalsIgnoreCase ( "ID" ) ) setIDAttribute ( valString , elemNode ) ; } if ( null == valString ) valString = "" ; int val = m_valuesOrPrefixes . stringToIndex ( valString ) ; if ( null != prefix ) { prefixIndex = m_valuesOrPrefixes . stringToIndex ( attrQName ) ; int dataIndex = m_data . size ( ) ; m_data . addElement ( prefixIndex ) ; m_data . addElement ( val ) ; val = - dataIndex ; } exName = m_expandedNameTable . getExpandedTypeID ( attrUri , attrLocalName , nodeType ) ; prev = addNode ( nodeType , exName , elemNode , prev , val , false ) ; } if ( DTM . NULL != prev ) m_nextsib . setElementAt ( DTM . NULL , prev ) ; if ( null != m_wsfilter ) { short wsv = m_wsfilter . getShouldStripSpace ( makeNodeHandle ( elemNode ) , this ) ; boolean shouldStrip = ( DTMWSFilter . INHERIT == wsv ) ? getShouldStripWhitespace ( ) : ( DTMWSFilter . STRIP == wsv ) ; pushShouldStripWhitespace ( shouldStrip ) ; } m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( DEBUG ) System . out . println ( "endElement: uri: " + uri + ", localname: " + localName + ", qname: " + qName ) ; charactersFlush ( ) ; m_contextIndexes . quickPop ( 1 ) ; int topContextIndex = m_contextIndexes . peek ( ) ; if ( topContextIndex != m_prefixMappings . size ( ) ) { m_prefixMappings . setSize ( topContextIndex ) ; } int lastNode = m_previous ; m_previous = m_parents . pop ( ) ; if ( DTM . NULL == lastNode ) m_firstch . setElementAt ( DTM . NULL , m_previous ) ; else m_nextsib . setElementAt ( DTM . NULL , lastNode ) ; popShouldStripWhitespace ( ) ; } public void characters ( char ch [ ] , int start , int length ) throws SAXException { if ( m_textPendingStart == - 1 ) { m_textPendingStart = m_chars . size ( ) ; m_coalescedTextType = m_textType ; } else if ( m_textType == DTM . TEXT_NODE ) { m_coalescedTextType = DTM . TEXT_NODE ; } m_chars . append ( ch , start , length ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { characters ( ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { if ( DEBUG ) System . out . println ( "processingInstruction: target: " + target + ", data: " + data ) ; charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( null , target , DTM . PROCESSING_INSTRUCTION_NODE ) ; int dataIndex = m_valuesOrPrefixes . stringToIndex ( data ) ; m_previous = addNode ( DTM . PROCESSING_INSTRUCTION_NODE , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; } public void skippedEntity ( String name ) throws SAXException { } public void warning ( SAXParseException e ) throws SAXException { System . err . println ( e . getMessage ( ) ) ; } public void error ( SAXParseException e ) throws SAXException { throw e ; } public void fatalError ( SAXParseException e ) throws SAXException { throw e ; } public void elementDecl ( String name , String model ) throws SAXException { } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { } public void internalEntityDecl ( String name , String value ) throws SAXException { } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { m_insideDTD = true ; } public void endDTD ( ) throws SAXException { m_insideDTD = false ; } public void startEntity ( String name ) throws SAXException { } public void endEntity ( String name ) throws SAXException { } public void startCDATA ( ) throws SAXException { m_textType = DTM . CDATA_SECTION_NODE ; } public void endCDATA ( ) throws SAXException { m_textType = DTM . TEXT_NODE ; } public void comment ( char ch [ ] , int start , int length ) throws SAXException { if ( m_insideDTD ) return ; charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( DTM . COMMENT_NODE ) ; int dataIndex = m_valuesOrPrefixes . stringToIndex ( new String ( ch , start , length ) ) ; m_previous = addNode ( DTM . COMMENT_NODE , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { if ( m_useSourceLocationProperty ) { node = makeNodeIdentity ( node ) ; return new NodeLocator ( null , m_sourceSystemId . elementAt ( node ) , m_sourceLine . elementAt ( node ) , m_sourceColumn . elementAt ( node ) ) ; } else if ( m_locator != null ) { return new NodeLocator ( null , m_locator . getSystemId ( ) , - 1 , - 1 ) ; } else if ( m_systemId != null ) { return new NodeLocator ( null , m_systemId , - 1 , - 1 ) ; } return null ; } } 	1	['75', '4', '2', '25', '190', '2297', '5', '21', '65', '0.908361486', '2494', '0.9375', '11', '0.56626506', '0.134234234', '2', '20', '31.82666667', '13', '2.2933', '3']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . utils . XMLChar ; import java . util . Vector ; final class CallTemplate extends Instruction { private QName _name ; private Object [ ] _parameters = null ; private Template _calleeTemplate = null ; public void display ( int indent ) { indent ( indent ) ; System . out . print ( "CallTemplate" ) ; Util . println ( " name " + _name ) ; displayContents ( indent + IndentIncrement ) ; } public boolean hasWithParams ( ) { return elementCount ( ) > 0 ; } public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; if ( name . length ( ) > 0 ) { if ( ! XMLChar . isValidQName ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , name , this ) ; parser . reportError ( Constants . ERROR , err ) ; } _name = parser . getQNameIgnoreDefaultNs ( name ) ; } else { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "name" ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Template template = stable . lookupTemplate ( _name ) ; if ( template != null ) { typeCheckContents ( stable ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . TEMPLATE_UNDEF_ERR , _name , this ) ; throw new TypeCheckError ( err ) ; } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Stylesheet stylesheet = classGen . getStylesheet ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( stylesheet . hasLocalParams ( ) || hasContents ( ) ) { _calleeTemplate = getCalleeTemplate ( ) ; if ( _calleeTemplate != null ) { buildParameterList ( ) ; } else { final int push = cpg . addMethodref ( TRANSLET_CLASS , PUSH_PARAM_FRAME , PUSH_PARAM_FRAME_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEVIRTUAL ( push ) ) ; translateContents ( classGen , methodGen ) ; } } final String className = stylesheet . getClassName ( ) ; String methodName = Util . escape ( _name . toString ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; StringBuffer methodSig = new StringBuffer ( "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + NODE_SIG ) ; if ( _calleeTemplate != null ) { Vector calleeParams = _calleeTemplate . getParameters ( ) ; int numParams = _parameters . length ; for ( int i = 0 ; i < numParams ; i ++ ) { SyntaxTreeNode node = ( SyntaxTreeNode ) _parameters [ i ] ; methodSig . append ( OBJECT_SIG ) ; if ( node instanceof Param ) { il . append ( ACONST_NULL ) ; } else { node . translate ( classGen , methodGen ) ; } } } methodSig . append ( ")V" ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( className , methodName , methodSig . toString ( ) ) ) ) ; if ( _calleeTemplate == null && ( stylesheet . hasLocalParams ( ) || hasContents ( ) ) ) { final int pop = cpg . addMethodref ( TRANSLET_CLASS , POP_PARAM_FRAME , POP_PARAM_FRAME_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEVIRTUAL ( pop ) ) ; } } public Template getCalleeTemplate ( ) { Stylesheet stylesheet = getXSLTC ( ) . getStylesheet ( ) ; Vector templates = stylesheet . getAllValidTemplates ( ) ; int size = templates . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Template t = ( Template ) templates . elementAt ( i ) ; if ( t . getName ( ) == _name && t . isSimpleNamedTemplate ( ) ) { return t ; } } return null ; } private void buildParameterList ( ) { Vector defaultParams = _calleeTemplate . getParameters ( ) ; int numParams = defaultParams . size ( ) ; _parameters = new Object [ numParams ] ; for ( int i = 0 ; i < numParams ; i ++ ) { _parameters [ i ] = defaultParams . elementAt ( i ) ; } int count = elementCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Object node = elementAt ( i ) ; if ( node instanceof WithParam ) { WithParam withParam = ( WithParam ) node ; QName name = withParam . getName ( ) ; for ( int k = 0 ; k < numParams ; k ++ ) { Object object = _parameters [ k ] ; if ( object instanceof Param && ( ( Param ) object ) . getName ( ) == name ) { withParam . setDoParameterOptimization ( true ) ; _parameters [ k ] = withParam ; break ; } else if ( object instanceof WithParam && ( ( WithParam ) object ) . getName ( ) == name ) { withParam . setDoParameterOptimization ( true ) ; _parameters [ k ] = withParam ; break ; } } } } } } 	1	['8', '3', '0', '23', '62', '2', '2', '22', '6', '0.619047619', '411', '1', '2', '0.888888889', '0.270833333', '1', '6', '50', '10', '3.75', '2']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_ru extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Функция не поддерживается!" } , { ER_CANNOT_OVERWRITE_CAUSE , "Невозможно перезаписать причину" } , { ER_NO_DEFAULT_IMPL , "Не найдена реализация по умолчанию" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) в настоящее время не поддерживается" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Смещение больше диапазона" } , { ER_COROUTINE_NOT_AVAIL , "Coroutine недоступна, ИД={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager получил запрос co_exit()" } , { ER_COJOINROUTINESET_FAILED , "Ошибка co_joinCoroutineSet()" } , { ER_COROUTINE_PARAM , "Ошибка параметра Coroutine ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nНепредвиденная ошибка: Ответ анализатора doTerminate: {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "Нельзя вызывать анализатор во время анализа" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Ошибка: типизированный итератор для оси {0} не реализован" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Ошибка: итератор для оси {0} не реализован" } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Копия итератора не поддерживается" } , { ER_UNKNOWN_AXIS_TYPE , "Неизвестный тип Traverser для оси: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Traverser для оси не поддерживается: {0}" } , { ER_NO_DTMIDS_AVAIL , "Нет доступных ИД DTM" } , { ER_NOT_SUPPORTED , "Не поддерживается: {0}" } , { ER_NODE_NON_NULL , "Для getDTMHandleFromNode узел должен быть непустым" } , { ER_COULD_NOT_RESOLVE_NODE , "Не удалось преобразовать узел в дескриптор" } , { ER_STARTPARSE_WHILE_PARSING , "Нельзя вызывать startParse во время анализа" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "Для startParse необходим непустой SAXParser" } , { ER_COULD_NOT_INIT_PARSER , "Не удалось инициализировать анализатор с" } , { ER_EXCEPTION_CREATING_POOL , "Исключительная ситуация при создании нового экземпляра пула" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "В имени пути встречается недопустимая Esc-последовательность" } , { ER_SCHEME_REQUIRED , "Необходима схема!" } , { ER_NO_SCHEME_IN_URI , "В URI не найдена схема: {0}" } , { ER_NO_SCHEME_INURI , "В URI не найдена схема" } , { ER_PATH_INVALID_CHAR , "В имени пути обнаружен недопустимый символ: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Невозможно задать схему для пустой строки" } , { ER_SCHEME_NOT_CONFORMANT , "Схема не конформативна." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Неправильно сформирован адрес хоста" } , { ER_PORT_WHEN_HOST_NULL , "Невозможно задать порт для пустого адреса хоста" } , { ER_INVALID_PORT , "Недопустимый номер порта" } , { ER_FRAG_FOR_GENERIC_URI , "Фрагмент можно задать только для шаблона URI" } , { ER_FRAG_WHEN_PATH_NULL , "Невозможно задать фрагмент для пустого пути" } , { ER_FRAG_INVALID_CHAR , "Фрагмент содержит недопустимый символ" } , { ER_PARSER_IN_USE , "Анализатор уже используется" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Невозможно изменить {0} {1} во время анализа" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Самоприсвоение недопустимо" } , { ER_NO_USERINFO_IF_NO_HOST , "Нельзя указывать информацию о пользователе, если не задан хост" } , { ER_NO_PORT_IF_NO_HOST , "Нельзя указывать порт, если не задан хост" } , { ER_NO_QUERY_STRING_IN_PATH , "Нельзя указывать строку запроса в строке пути и запроса" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Невозможно задать фрагмент одновременно для пути и фрагмента" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Невозможно инициализировать URI с пустыми параметрами" } , { ER_METHOD_NOT_SUPPORTED , "Метод еще не поддерживается" } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "Перезапуск IncrementalSAXSource_Filter в настоящее время невозможен" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "Нельзя применять XMLReader до startParse" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Traverser для оси не поддерживается: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler создан с пустым PrintWriter!" } , { ER_SYSTEMID_UNKNOWN , "Неизвестный ИД системы" } , { ER_LOCATION_UNKNOWN , "Неизвестное расположение или ошибка" } , { ER_PREFIX_MUST_RESOLVE , "Префикс должен обеспечивать преобразование в пространство имен: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() не поддерживается XPathContext!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "У атрибута child нет документа-владельца!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "У атрибута child нет элемента документа-владельца!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Предупреждение: Невозможно вывести текст перед элементом документа! Проигнорирован..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "В DOM может быть только один корневой элемент!" } , { ER_ARG_LOCALNAME_NULL , "Пустой аргумент 'localName'" } , { ER_ARG_LOCALNAME_INVALID , "Локальное имя в QNAME должно быть допустимым именем NCName" } , { ER_ARG_PREFIX_INVALID , "Префикс в QNAME должен быть допустимым именем NCName" } , { "BAD_CODE" , "Параметр createMessage лежит вне допустимого диапазона" } , { "FORMAT_FAILED" , "Исключительная ситуация при вызове messageFormat" } , { "line" , "Номер строки" } , { "column" , "Номер столбца" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "Класс сериализатора ''{0}'' не реализует org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "Ресурс [ {0} ] не найден.\n{1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "Не удалось загрузить ресурс [ {0} ]: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Размер буфера <=0" } , { ER_INVALID_UTF16_SURROGATE , "Обнаружено недопустимое значение UTF-16: {0} ?" } , { ER_OIERROR , "Ошибка ввода-вывода" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Невозможно добавить атрибут {0} после дочерних узлов или перед созданием элемента. Атрибут будет проигнорирован. " } , { ER_NAMESPACE_PREFIX , "Пространство имен для префикса ''{0}'' не объявлено." } , { ER_STRAY_ATTRIBUTE , "Атрибут ''{0}'' вне элемента." } , { ER_STRAY_NAMESPACE , "Объявление пространства имен ''{0}''=''{1}'' вне элемента." } , { ER_COULD_NOT_LOAD_RESOURCE , "Не удалось загрузить ''{0}'' (проверьте CLASSPATH), применяются значения по умолчанию" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "Не удалось загрузить файл свойств ''{0}'' для метода вывода ''{1}'' (проверьте CLASSPATH)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_zh_TW extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "在比對型樣中不允許使用 current() 函數！" } , { ER_CURRENT_TAKES_NO_ARGS , "current() 函數不接受引數！" } , { ER_DOCUMENT_REPLACED , "document() 函數實作已被 org.apache.xalan.xslt.FuncDocument 取代！" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "環境定義沒有擁有者文件！" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() 有太多引數。" } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() 有太多引數。" } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() 有太多引數。" } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() 有太多引數。" } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() 有太多引數。" } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() 有太多引數。" } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() 有太多引數。" } , { ER_TRANSLATE_TAKES_3_ARGS , "translate() 函數需要 3 個引數！" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "unparsed-entity-uri 函數只需要 1 個引數！" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "namespace axis 尚未實作！" } , { ER_UNKNOWN_AXIS , "不明軸：{0}" } , { ER_UNKNOWN_MATCH_OPERATION , "不明的比對作業！" } , { ER_INCORRECT_ARG_LENGTH , "processing-instruction() 節點測試的引數長度不正確！" } , { ER_CANT_CONVERT_TO_NUMBER , "{0} 無法轉換為數字" } , { ER_CANT_CONVERT_TO_NODELIST , "{0} 無法轉換為 NodeList！" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0} 無法轉換為 NodeSetDTM！" } , { ER_CANT_CONVERT_TO_TYPE , "無法將 {0} 轉換為 type#{1}" } , { ER_EXPECTED_MATCH_PATTERN , "原預期在 getMatchScore 中會出現比對型樣！" } , { ER_COULDNOT_GET_VAR_NAMED , "無法取得變數名稱 {0}" } , { ER_UNKNOWN_OPCODE , "錯誤！不明作業碼：{0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "額外的不合法記號：{0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "括錯引號的文字... 原預期為雙引號！" } , { ER_EXPECTED_SINGLE_QUOTE , "括錯引號的文字... 原預期為單引號！" } , { ER_EMPTY_EXPRESSION , "空的表示式！" } , { ER_EXPECTED_BUT_FOUND , "原預期為 {0}，卻發現：{1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "程式設計師假設(Programmer assertion)不正確！- {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "boolean(...) 引數在 19990709 XPath 初稿中不再是可選用的。" } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "找到 ','，但之前沒有引數！" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "找到 ','，但之後沒有引數！" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' 或 '.[predicate]' 是不合法語法。請改用 'self::node()[predicate]'。" } , { ER_ILLEGAL_AXIS_NAME , "不合法軸名稱：{0}" } , { ER_UNKNOWN_NODETYPE , "不明節點類型：{0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "型樣文字 ({0}) 需要用引號括住！" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} 無法格式化為數字！" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "無法建立 XML TransformerFactory Liaison：{0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "錯誤！沒有找到 xpath select 表示式 (-select)。" } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "錯誤！在 OP_LOCATIONPATH 之後找不到 ENDOP" } , { ER_ERROR_OCCURED , "發生錯誤！" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "提供給變數的 VariableReference 超出環境定義或沒有定義！名稱 = {0}" } , { ER_AXES_NOT_ALLOWED , "比對型樣中只接受 child:: 以及 attribute:: 兩種軸！不當的軸 = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() 含有不正確引數數目。" } , { ER_COUNT_TAKES_1_ARG , "count 函數只需要一個引數！" } , { ER_COULDNOT_FIND_FUNCTION , "找不到函數：{0}" } , { ER_UNSUPPORTED_ENCODING , "不支援編碼：{0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "getNextSibling 時在 DTM 發生問題... 嘗試回復" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "程式設計師錯誤：無法寫入 EmptyNodeList。" } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory 不受 XPathContext 支援！" } , { ER_PREFIX_MUST_RESOLVE , "字首必須解析為名稱空間：{0}" } , { ER_PARSE_NOT_SUPPORTED , "在 XPathContext 中不支援剖析（InputSource 原始檔）！無法開啟 {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API character(char ch[]... 不能被 DTM 處理！" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... 不能被 DTM 處理！" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison 不能處理 {0} 類型的節點" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper 不能處理 {0} 類型的節點" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse 錯誤：SystemID - {0} 行 - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse 錯誤" } , { ER_INVALID_UTF16_SURROGATE , "偵測到無效的 UTF-16 代理：{0}?" } , { ER_OIERROR , "IO 錯誤" } , { ER_CANNOT_CREATE_URL , "無法針對：{0} 建立 URL" } , { ER_XPATH_READOBJECT , "位於 XPath.readObject：{0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "找不到函數記號。" } , { ER_CANNOT_DEAL_XPATH_TYPE , "無法處理 XPath 類型：{0}" } , { ER_NODESET_NOT_MUTABLE , "此 NodeSet 不是易變的" } , { ER_NODESETDTM_NOT_MUTABLE , "此 NodeSetDTM 不是易變的" } , { ER_VAR_NOT_RESOLVABLE , "變數無法解析：{0}" } , { ER_NULL_ERROR_HANDLER , "空值錯誤處理程式" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "程式設計師的假設(assertion)：不明 opcode：{0}" } , { ER_ZERO_OR_ONE , "0 或 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() 不受 XRTreeFragSelectWrapper 支援" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() 不受 XRTreeFragSelectWrapper 支援" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() 不受 XStringForChars 支援" } , { ER_COULD_NOT_FIND_VAR , "找不到名稱為 {0} 的變數" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars 不接受字串作為引數" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer 引數不可為空值" } , { ER_TWO_OR_THREE , "2 或 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "變數在連結之前即被存取！" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB 不可使用字串作為引數！" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n!!!! 錯誤！設定 Walker 的根目錄為空值!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "此 NodeSetDTM 不可疊代為前一個節點！" } , { ER_NODESET_CANNOT_ITERATE , "此 NodeSet 不可疊代為前一個節點！" } , { ER_NODESETDTM_CANNOT_INDEX , "此 NodeSetDTM 不可執行檢索或計數功能！" } , { ER_NODESET_CANNOT_INDEX , "此 NodeSet 不可執行檢索或計數功能！" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "在呼叫 nextNode 之後不能呼叫 setShouldCacheNodes。" } , { ER_ONLY_ALLOWS , "{0} 只允許 {1} 引數" } , { ER_UNKNOWN_STEP , "程式設計師對於 getNextStepPos 的假設(assertion)：不明 stepType：{0}" } , { ER_EXPECTED_REL_LOC_PATH , "預期在 '/' 或 '//' 記號之後為相對的位置路徑。" } , { ER_EXPECTED_LOC_PATH , "必須是位置路徑，卻遇到下列記號:  {0}" } , { ER_EXPECTED_LOC_STEP , "預期在 '/' 或 '//' 記號之後為 location step。" } , { ER_EXPECTED_NODE_TEST , "原預期為符合 NCName:* 或 QName 的 node test。" } , { ER_EXPECTED_STEP_PATTERN , "原預期為 step pattern，但卻遇到 '/'。" } , { ER_EXPECTED_REL_PATH_PATTERN , "原預期為相對的路徑型樣。" } , { ER_CANT_CONVERT_TO_BOOLEAN , "無法將 {0} 轉換為 boolean。" } , { ER_CANT_CONVERT_TO_SINGLENODE , "無法將 {0} 轉換為單一節點。此取得元適用於 ANY_UNORDERED_NODE_TYPE 和 FIRST_ORDERED_NODE_TYPE 兩種類型。" } , { ER_CANT_GET_SNAPSHOT_LENGTH , "無法取得類型 {0} 的瞬間快照長度。此取得元適用於 UNORDERED_NODE_SNAPSHOT_TYPE 和 ORDERED_NODE_SNAPSHOT_TYPE 兩種類型。" } , { ER_NON_ITERATOR_TYPE , "無法疊代非疊代類型：{0}" } , { ER_DOC_MUTATED , "自傳回結果之後，文件已產生變化。重複項目無效。" } , { ER_INVALID_XPATH_TYPE , "XPath 類型引數 {0} 無效" } , { ER_EMPTY_XPATH_RESULT , "XPath 結果物件空白" } , { ER_INCOMPATIBLE_TYPES , "傳回類型：{0} 無法強制成為指定的類型：{1}" } , { ER_NULL_RESOLVER , "無法解析含空值字首解析器的字首。" } , { ER_CANT_CONVERT_TO_STRING , "無法將 {0} 轉換為字串。" } , { ER_NON_SNAPSHOT_TYPE , "無法呼叫 snapshotItem 類型：{0}。此方法適用於 UNORDERED_NODE_SNAPSHOT_TYPE 和 ORDERED_NODE_SNAPSHOT_TYPE 兩種類型。" } , { ER_WRONG_DOCUMENT , "環境定義節點不屬於和此 XPathEvaluator 連結的文件。" } , { ER_WRONG_NODETYPE , "環境定義節點類型未受支援。" } , { ER_XPATH_ERROR , "XPath 發生不明錯誤。" } , { WG_LOCALE_NAME_NOT_HANDLED , "format-number 函數中的語言環境名稱尚未處理！" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL 內容未受支援：{0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "目前不要對內容：{1} 中的名稱空間 {0} 做任何動作" } , { WG_SECURITY_EXCEPTION , "嘗試存取 XSL 系統內容：{0} 時發生 SecurityException" } , { WG_QUO_NO_LONGER_DEFINED , "XPath 中已不再定義舊語法：quo(...)。" } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath 需要衍生物件來實作 nodeTest！" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "找不到函數記號。" } , { WG_COULDNOT_FIND_FUNCTION , "找不到函數：{0}" } , { WG_CANNOT_MAKE_URL_FROM , "無法從：{0} 產生 URL" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "-E 選項不受 DTM 剖析器支援" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "提供給變數的 VariableReference 超出環境定義或沒有定義！名稱 = {0}" } , { WG_UNSUPPORTED_ENCODING , "不支援編碼：{0}" } , { "ui_language" , "zh" } , { "help_language" , "zh" } , { "language" , "zh" } , { "BAD_CODE" , "createMessage 的參數超出界限" } , { "FORMAT_FAILED" , "在 messageFormat 呼叫期間擲出異常" } , { "version" , ">>>>>>> Xalan 版本" } , { "version2" , "<<<<<<<" } , { "yes" , "yes" } , { "line" , "行號" } , { "column" , "欄號" } , { "xsldone" , "XSLProcessor：完成" } , { "xpath_option" , "xpath 選項：" } , { "optionIN" , "[-in inputXMLURL]" } , { "optionSelect" , "[-select xpath 表示式]" } , { "optionMatch" , "[-match 符合型樣（用於比對診斷）]" } , { "optionAnyExpr" , "或只有一個 xpath 表示式會執行診斷傾出" } , { "noParsermsg1" , "XSL 程序沒有順利完成。" } , { "noParsermsg2" , "** 找不到剖析器 **" } , { "noParsermsg3" , "請檢查類別路徑。" } , { "noParsermsg4" , "如果您沒有 IBM 的 XML Parser for Java，可自以下網址下載" } , { "noParsermsg5" , "IBM 的 AlphaWorks：http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "錯誤：" ; public static final String WARNING_HEADER = "警告：" ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "zh" , "TW" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xalan . templates ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPath ; import org . apache . xpath . axes . AxesWalker ; import org . apache . xpath . axes . FilterExprIteratorSimple ; import org . apache . xpath . axes . FilterExprWalker ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . axes . SelfIteratorNoPredicate ; import org . apache . xpath . axes . WalkerFactory ; import org . apache . xpath . axes . WalkingIterator ; import org . apache . xpath . operations . Variable ; import org . apache . xpath . operations . VariableSafeAbsRef ; public class RedundentExprEliminator extends XSLTVisitor { Vector m_paths ; Vector m_absPaths ; boolean m_isSameContext ; AbsPathChecker m_absPathChecker = new AbsPathChecker ( ) ; static int m_uniquePsuedoVarID = 1 ; static final String PSUEDOVARNAMESPACE = Constants . S_VENDORURL + "/xalan/psuedovar" ; public static boolean DEBUG = false ; public static boolean DIAGNOSE_NUM_PATHS_REDUCED = false ; public static boolean DIAGNOSE_MULTISTEPLIST = false ; VarNameCollector m_varNameCollector = new VarNameCollector ( ) ; public RedundentExprEliminator ( ) { m_isSameContext = true ; m_absPaths = new Vector ( ) ; m_paths = null ; } public void eleminateRedundentLocals ( ElemTemplateElement psuedoVarRecipient ) { eleminateRedundent ( psuedoVarRecipient , m_paths ) ; } public void eleminateRedundentGlobals ( StylesheetRoot stylesheet ) { eleminateRedundent ( stylesheet , m_absPaths ) ; } protected void eleminateRedundent ( ElemTemplateElement psuedoVarRecipient , Vector paths ) { int n = paths . size ( ) ; int numPathsEliminated = 0 ; int numUniquePathsEliminated = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ExpressionOwner owner = ( ExpressionOwner ) paths . elementAt ( i ) ; if ( null != owner ) { int found = findAndEliminateRedundant ( i + 1 , i , owner , psuedoVarRecipient , paths ) ; if ( found > 0 ) numUniquePathsEliminated ++ ; numPathsEliminated += found ; } } eleminateSharedPartialPaths ( psuedoVarRecipient , paths ) ; if ( DIAGNOSE_NUM_PATHS_REDUCED ) diagnoseNumPaths ( paths , numPathsEliminated , numUniquePathsEliminated ) ; } protected void eleminateSharedPartialPaths ( ElemTemplateElement psuedoVarRecipient , Vector paths ) { MultistepExprHolder list = createMultistepExprList ( paths ) ; if ( null != list ) { if ( DIAGNOSE_MULTISTEPLIST ) list . diagnose ( ) ; boolean isGlobal = ( paths == m_absPaths ) ; int longestStepsCount = list . m_stepCount ; for ( int i = longestStepsCount - 1 ; i >= 1 ; i -- ) { MultistepExprHolder next = list ; while ( null != next ) { if ( next . m_stepCount < i ) break ; list = matchAndEliminatePartialPaths ( next , list , isGlobal , i , psuedoVarRecipient ) ; next = next . m_next ; } } } } protected MultistepExprHolder matchAndEliminatePartialPaths ( MultistepExprHolder testee , MultistepExprHolder head , boolean isGlobal , int lengthToTest , ElemTemplateElement varScope ) { if ( null == testee . m_exprOwner ) return head ; WalkingIterator iter1 = ( WalkingIterator ) testee . m_exprOwner . getExpression ( ) ; if ( partialIsVariable ( testee , lengthToTest ) ) return head ; MultistepExprHolder matchedPaths = null ; MultistepExprHolder matchedPathsTail = null ; MultistepExprHolder meh = head ; while ( null != meh ) { if ( ( meh != testee ) && ( null != meh . m_exprOwner ) ) { WalkingIterator iter2 = ( WalkingIterator ) meh . m_exprOwner . getExpression ( ) ; if ( stepsEqual ( iter1 , iter2 , lengthToTest ) ) { if ( null == matchedPaths ) { try { matchedPaths = ( MultistepExprHolder ) testee . clone ( ) ; testee . m_exprOwner = null ; } catch ( CloneNotSupportedException cnse ) { } matchedPathsTail = matchedPaths ; matchedPathsTail . m_next = null ; } try { matchedPathsTail . m_next = ( MultistepExprHolder ) meh . clone ( ) ; meh . m_exprOwner = null ; } catch ( CloneNotSupportedException cnse ) { } matchedPathsTail = matchedPathsTail . m_next ; matchedPathsTail . m_next = null ; } } meh = meh . m_next ; } int matchCount = 0 ; if ( null != matchedPaths ) { ElemTemplateElement root = isGlobal ? varScope : findCommonAncestor ( matchedPaths ) ; WalkingIterator sharedIter = ( WalkingIterator ) matchedPaths . m_exprOwner . getExpression ( ) ; WalkingIterator newIter = createIteratorFromSteps ( sharedIter , lengthToTest ) ; ElemVariable var = createPsuedoVarDecl ( root , newIter , isGlobal ) ; if ( DIAGNOSE_MULTISTEPLIST ) System . err . println ( "Created var: " + var . getName ( ) + ( isGlobal ? "(Global)" : "" ) ) ; while ( null != matchedPaths ) { ExpressionOwner owner = matchedPaths . m_exprOwner ; WalkingIterator iter = ( WalkingIterator ) owner . getExpression ( ) ; if ( DIAGNOSE_MULTISTEPLIST ) diagnoseLineNumber ( iter ) ; LocPathIterator newIter2 = changePartToRef ( var . getName ( ) , iter , lengthToTest , isGlobal ) ; owner . setExpression ( newIter2 ) ; matchedPaths = matchedPaths . m_next ; } } if ( DIAGNOSE_MULTISTEPLIST ) diagnoseMultistepList ( matchCount , lengthToTest , isGlobal ) ; return head ; } boolean partialIsVariable ( MultistepExprHolder testee , int lengthToTest ) { if ( 1 == lengthToTest ) { WalkingIterator wi = ( WalkingIterator ) testee . m_exprOwner . getExpression ( ) ; if ( wi . getFirstWalker ( ) instanceof FilterExprWalker ) return true ; } return false ; } protected void diagnoseLineNumber ( Expression expr ) { ElemTemplateElement e = getElemFromExpression ( expr ) ; System . err . println ( "   " + e . getSystemId ( ) + " Line " + e . getLineNumber ( ) ) ; } protected ElemTemplateElement findCommonAncestor ( MultistepExprHolder head ) { int numExprs = head . getLength ( ) ; ElemTemplateElement [ ] elems = new ElemTemplateElement [ numExprs ] ; int [ ] ancestorCounts = new int [ numExprs ] ; MultistepExprHolder next = head ; int shortestAncestorCount = 10000 ; for ( int i = 0 ; i < numExprs ; i ++ ) { ElemTemplateElement elem = getElemFromExpression ( next . m_exprOwner . getExpression ( ) ) ; elems [ i ] = elem ; int numAncestors = countAncestors ( elem ) ; ancestorCounts [ i ] = numAncestors ; if ( numAncestors < shortestAncestorCount ) { shortestAncestorCount = numAncestors ; } next = next . m_next ; } for ( int i = 0 ; i < numExprs ; i ++ ) { if ( ancestorCounts [ i ] > shortestAncestorCount ) { int numStepCorrection = ancestorCounts [ i ] - shortestAncestorCount ; for ( int j = 0 ; j < numStepCorrection ; j ++ ) { elems [ i ] = elems [ i ] . getParentElem ( ) ; } } } ElemTemplateElement first = null ; while ( shortestAncestorCount -- >= 0 ) { boolean areEqual = true ; first = elems [ 0 ] ; for ( int i = 1 ; i < numExprs ; i ++ ) { if ( first != elems [ i ] ) { areEqual = false ; break ; } } if ( areEqual && isNotSameAsOwner ( head , first ) && first . canAcceptVariables ( ) ) { if ( DIAGNOSE_MULTISTEPLIST ) { System . err . print ( first . getClass ( ) . getName ( ) ) ; System . err . println ( " at   " + first . getSystemId ( ) + " Line " + first . getLineNumber ( ) ) ; } return first ; } for ( int i = 0 ; i < numExprs ; i ++ ) { elems [ i ] = elems [ i ] . getParentElem ( ) ; } } assertion ( false , "Could not find common ancestor!!!" ) ; return null ; } protected boolean isNotSameAsOwner ( MultistepExprHolder head , ElemTemplateElement ete ) { MultistepExprHolder next = head ; while ( null != next ) { ElemTemplateElement elemOwner = getElemFromExpression ( next . m_exprOwner . getExpression ( ) ) ; if ( elemOwner == ete ) return false ; next = next . m_next ; } return true ; } protected int countAncestors ( ElemTemplateElement elem ) { int count = 0 ; while ( null != elem ) { count ++ ; elem = elem . getParentElem ( ) ; } return count ; } protected void diagnoseMultistepList ( int matchCount , int lengthToTest , boolean isGlobal ) { if ( matchCount > 0 ) { System . err . print ( "Found multistep matches: " + matchCount + ", " + lengthToTest + " length" ) ; if ( isGlobal ) System . err . println ( " (global)" ) ; else System . err . println ( ) ; } } protected LocPathIterator changePartToRef ( final QName uniquePsuedoVarName , WalkingIterator wi , final int numSteps , final boolean isGlobal ) { Variable var = new Variable ( ) ; var . setQName ( uniquePsuedoVarName ) ; var . setIsGlobal ( isGlobal ) ; if ( isGlobal ) { ElemTemplateElement elem = getElemFromExpression ( wi ) ; StylesheetRoot root = elem . getStylesheetRoot ( ) ; Vector vars = root . getVariablesAndParamsComposed ( ) ; var . setIndex ( vars . size ( ) - 1 ) ; } AxesWalker walker = wi . getFirstWalker ( ) ; for ( int i = 0 ; i < numSteps ; i ++ ) { assertion ( null != walker , "Walker should not be null!" ) ; walker = walker . getNextWalker ( ) ; } if ( null != walker ) { FilterExprWalker few = new FilterExprWalker ( wi ) ; few . setInnerExpression ( var ) ; few . exprSetParent ( wi ) ; few . setNextWalker ( walker ) ; walker . setPrevWalker ( few ) ; wi . setFirstWalker ( few ) ; return wi ; } else { FilterExprIteratorSimple feis = new FilterExprIteratorSimple ( var ) ; feis . exprSetParent ( wi . exprGetParent ( ) ) ; return feis ; } } protected WalkingIterator createIteratorFromSteps ( final WalkingIterator wi , int numSteps ) { WalkingIterator newIter = new WalkingIterator ( wi . getPrefixResolver ( ) ) ; try { AxesWalker walker = ( AxesWalker ) wi . getFirstWalker ( ) . clone ( ) ; newIter . setFirstWalker ( walker ) ; walker . setLocPathIterator ( newIter ) ; for ( int i = 1 ; i < numSteps ; i ++ ) { AxesWalker next = ( AxesWalker ) walker . getNextWalker ( ) . clone ( ) ; walker . setNextWalker ( next ) ; next . setLocPathIterator ( newIter ) ; walker = next ; } walker . setNextWalker ( null ) ; } catch ( CloneNotSupportedException cnse ) { throw new WrappedRuntimeException ( cnse ) ; } return newIter ; } protected boolean stepsEqual ( WalkingIterator iter1 , WalkingIterator iter2 , int numSteps ) { AxesWalker aw1 = iter1 . getFirstWalker ( ) ; AxesWalker aw2 = iter2 . getFirstWalker ( ) ; for ( int i = 0 ; ( i < numSteps ) ; i ++ ) { if ( ( null == aw1 ) || ( null == aw2 ) ) return false ; if ( ! aw1 . deepEquals ( aw2 ) ) return false ; aw1 = aw1 . getNextWalker ( ) ; aw2 = aw2 . getNextWalker ( ) ; } assertion ( ( null != aw1 ) || ( null != aw2 ) , "Total match is incorrect!" ) ; return true ; } protected MultistepExprHolder createMultistepExprList ( Vector paths ) { MultistepExprHolder first = null ; int n = paths . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ExpressionOwner eo = ( ExpressionOwner ) paths . elementAt ( i ) ; if ( null == eo ) continue ; LocPathIterator lpi = ( LocPathIterator ) eo . getExpression ( ) ; int numPaths = countSteps ( lpi ) ; if ( numPaths > 1 ) { if ( null == first ) first = new MultistepExprHolder ( eo , numPaths , null ) ; else first = first . addInSortedOrder ( eo , numPaths ) ; } } if ( ( null == first ) || ( first . getLength ( ) <= 1 ) ) return null ; else return first ; } protected int findAndEliminateRedundant ( int start , int firstOccuranceIndex , ExpressionOwner firstOccuranceOwner , ElemTemplateElement psuedoVarRecipient , Vector paths ) throws org . w3c . dom . DOMException { MultistepExprHolder head = null ; MultistepExprHolder tail = null ; int numPathsFound = 0 ; int n = paths . size ( ) ; Expression expr1 = firstOccuranceOwner . getExpression ( ) ; if ( DEBUG ) assertIsLocPathIterator ( expr1 , firstOccuranceOwner ) ; boolean isGlobal = ( paths == m_absPaths ) ; LocPathIterator lpi = ( LocPathIterator ) expr1 ; int stepCount = countSteps ( lpi ) ; for ( int j = start ; j < n ; j ++ ) { ExpressionOwner owner2 = ( ExpressionOwner ) paths . elementAt ( j ) ; if ( null != owner2 ) { Expression expr2 = owner2 . getExpression ( ) ; boolean isEqual = expr2 . deepEquals ( lpi ) ; if ( isEqual ) { LocPathIterator lpi2 = ( LocPathIterator ) expr2 ; if ( null == head ) { head = new MultistepExprHolder ( firstOccuranceOwner , stepCount , null ) ; tail = head ; numPathsFound ++ ; } tail . m_next = new MultistepExprHolder ( owner2 , stepCount , null ) ; tail = tail . m_next ; paths . setElementAt ( null , j ) ; numPathsFound ++ ; } } } if ( ( 0 == numPathsFound ) && isGlobal ) { head = new MultistepExprHolder ( firstOccuranceOwner , stepCount , null ) ; numPathsFound ++ ; } if ( null != head ) { ElemTemplateElement root = isGlobal ? psuedoVarRecipient : findCommonAncestor ( head ) ; LocPathIterator sharedIter = ( LocPathIterator ) head . m_exprOwner . getExpression ( ) ; ElemVariable var = createPsuedoVarDecl ( root , sharedIter , isGlobal ) ; if ( DIAGNOSE_MULTISTEPLIST ) System . err . println ( "Created var: " + var . getName ( ) + ( isGlobal ? "(Global)" : "" ) ) ; QName uniquePsuedoVarName = var . getName ( ) ; while ( null != head ) { ExpressionOwner owner = head . m_exprOwner ; if ( DIAGNOSE_MULTISTEPLIST ) diagnoseLineNumber ( owner . getExpression ( ) ) ; changeToVarRef ( uniquePsuedoVarName , owner , paths , root ) ; head = head . m_next ; } paths . setElementAt ( var . getSelect ( ) , firstOccuranceIndex ) ; } return numPathsFound ; } protected int oldFindAndEliminateRedundant ( int start , int firstOccuranceIndex , ExpressionOwner firstOccuranceOwner , ElemTemplateElement psuedoVarRecipient , Vector paths ) throws org . w3c . dom . DOMException { QName uniquePsuedoVarName = null ; boolean foundFirst = false ; int numPathsFound = 0 ; int n = paths . size ( ) ; Expression expr1 = firstOccuranceOwner . getExpression ( ) ; if ( DEBUG ) assertIsLocPathIterator ( expr1 , firstOccuranceOwner ) ; boolean isGlobal = ( paths == m_absPaths ) ; LocPathIterator lpi = ( LocPathIterator ) expr1 ; for ( int j = start ; j < n ; j ++ ) { ExpressionOwner owner2 = ( ExpressionOwner ) paths . elementAt ( j ) ; if ( null != owner2 ) { Expression expr2 = owner2 . getExpression ( ) ; boolean isEqual = expr2 . deepEquals ( lpi ) ; if ( isEqual ) { LocPathIterator lpi2 = ( LocPathIterator ) expr2 ; if ( ! foundFirst ) { foundFirst = true ; ElemVariable var = createPsuedoVarDecl ( psuedoVarRecipient , lpi , isGlobal ) ; if ( null == var ) return 0 ; uniquePsuedoVarName = var . getName ( ) ; changeToVarRef ( uniquePsuedoVarName , firstOccuranceOwner , paths , psuedoVarRecipient ) ; paths . setElementAt ( var . getSelect ( ) , firstOccuranceIndex ) ; numPathsFound ++ ; } changeToVarRef ( uniquePsuedoVarName , owner2 , paths , psuedoVarRecipient ) ; paths . setElementAt ( null , j ) ; numPathsFound ++ ; } } } if ( ( 0 == numPathsFound ) && ( paths == m_absPaths ) ) { ElemVariable var = createPsuedoVarDecl ( psuedoVarRecipient , lpi , true ) ; if ( null == var ) return 0 ; uniquePsuedoVarName = var . getName ( ) ; changeToVarRef ( uniquePsuedoVarName , firstOccuranceOwner , paths , psuedoVarRecipient ) ; paths . setElementAt ( var . getSelect ( ) , firstOccuranceIndex ) ; numPathsFound ++ ; } return numPathsFound ; } protected int countSteps ( LocPathIterator lpi ) { if ( lpi instanceof WalkingIterator ) { WalkingIterator wi = ( WalkingIterator ) lpi ; AxesWalker aw = wi . getFirstWalker ( ) ; int count = 0 ; while ( null != aw ) { count ++ ; aw = aw . getNextWalker ( ) ; } return count ; } else return 1 ; } protected void changeToVarRef ( QName varName , ExpressionOwner owner , Vector paths , ElemTemplateElement psuedoVarRecipient ) { Variable varRef = ( paths == m_absPaths ) ? new VariableSafeAbsRef ( ) : new Variable ( ) ; varRef . setQName ( varName ) ; if ( paths == m_absPaths ) { StylesheetRoot root = ( StylesheetRoot ) psuedoVarRecipient ; Vector globalVars = root . getVariablesAndParamsComposed ( ) ; varRef . setIndex ( globalVars . size ( ) - 1 ) ; varRef . setIsGlobal ( true ) ; } owner . setExpression ( varRef ) ; } protected ElemVariable createPsuedoVarDecl ( ElemTemplateElement psuedoVarRecipient , LocPathIterator lpi , boolean isGlobal ) throws org . w3c . dom . DOMException { QName uniquePsuedoVarName = new QName ( PSUEDOVARNAMESPACE , "#" + m_uniquePsuedoVarID ) ; m_uniquePsuedoVarID ++ ; if ( isGlobal ) { return createGlobalPsuedoVarDecl ( uniquePsuedoVarName , ( StylesheetRoot ) psuedoVarRecipient , lpi ) ; } else return createLocalPsuedoVarDecl ( uniquePsuedoVarName , psuedoVarRecipient , lpi ) ; } protected ElemVariable createGlobalPsuedoVarDecl ( QName uniquePsuedoVarName , StylesheetRoot stylesheetRoot , LocPathIterator lpi ) throws org . w3c . dom . DOMException { ElemVariable psuedoVar = new ElemVariable ( ) ; psuedoVar . setIsTopLevel ( true ) ; XPath xpath = new XPath ( lpi ) ; psuedoVar . setSelect ( xpath ) ; psuedoVar . setName ( uniquePsuedoVarName ) ; Vector globalVars = stylesheetRoot . getVariablesAndParamsComposed ( ) ; psuedoVar . setIndex ( globalVars . size ( ) ) ; globalVars . addElement ( psuedoVar ) ; return psuedoVar ; } protected ElemVariable createLocalPsuedoVarDecl ( QName uniquePsuedoVarName , ElemTemplateElement psuedoVarRecipient , LocPathIterator lpi ) throws org . w3c . dom . DOMException { ElemVariable psuedoVar = new ElemVariablePsuedo ( ) ; XPath xpath = new XPath ( lpi ) ; psuedoVar . setSelect ( xpath ) ; psuedoVar . setName ( uniquePsuedoVarName ) ; ElemVariable var = addVarDeclToElem ( psuedoVarRecipient , lpi , psuedoVar ) ; lpi . exprSetParent ( var ) ; return var ; } protected ElemVariable addVarDeclToElem ( ElemTemplateElement psuedoVarRecipient , LocPathIterator lpi , ElemVariable psuedoVar ) throws org . w3c . dom . DOMException { ElemTemplateElement ete = psuedoVarRecipient . getFirstChildElem ( ) ; lpi . callVisitors ( null , m_varNameCollector ) ; if ( m_varNameCollector . getVarCount ( ) > 0 ) { ElemTemplateElement baseElem = getElemFromExpression ( lpi ) ; ElemVariable varElem = getPrevVariableElem ( baseElem ) ; while ( null != varElem ) { if ( m_varNameCollector . doesOccur ( varElem . getName ( ) ) ) { psuedoVarRecipient = varElem . getParentElem ( ) ; ete = varElem . getNextSiblingElem ( ) ; break ; } varElem = getPrevVariableElem ( varElem ) ; } } if ( ( null != ete ) && ( Constants . ELEMNAME_PARAMVARIABLE == ete . getXSLToken ( ) ) ) { if ( isParam ( lpi ) ) return null ; while ( null != ete ) { ete = ete . getNextSiblingElem ( ) ; if ( ( null != ete ) && Constants . ELEMNAME_PARAMVARIABLE != ete . getXSLToken ( ) ) break ; } } psuedoVarRecipient . insertBefore ( psuedoVar , ete ) ; m_varNameCollector . reset ( ) ; return psuedoVar ; } protected boolean isParam ( ExpressionNode expr ) { while ( null != expr ) { if ( expr instanceof ElemTemplateElement ) break ; expr = expr . exprGetParent ( ) ; } if ( null != expr ) { ElemTemplateElement ete = ( ElemTemplateElement ) expr ; while ( null != ete ) { int type = ete . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_PARAMVARIABLE : return true ; case Constants . ELEMNAME_TEMPLATE : case Constants . ELEMNAME_STYLESHEET : return false ; } ete = ete . getParentElem ( ) ; } } return false ; } protected ElemVariable getPrevVariableElem ( ElemTemplateElement elem ) { while ( null != ( elem = getPrevElementWithinContext ( elem ) ) ) { int type = elem . getXSLToken ( ) ; if ( ( Constants . ELEMNAME_VARIABLE == type ) || ( Constants . ELEMNAME_PARAMVARIABLE == type ) ) { return ( ElemVariable ) elem ; } } return null ; } protected ElemTemplateElement getPrevElementWithinContext ( ElemTemplateElement elem ) { ElemTemplateElement prev = elem . getPreviousSiblingElem ( ) ; if ( null == prev ) prev = elem . getParentElem ( ) ; if ( null != prev ) { int type = prev . getXSLToken ( ) ; if ( ( Constants . ELEMNAME_FOREACH == type ) || ( Constants . ELEMNAME_TEMPLATE == type ) || ( Constants . ELEMNAME_STYLESHEET == type ) ) { prev = null ; } } return prev ; } protected ElemTemplateElement getElemFromExpression ( Expression expr ) { ExpressionNode parent = expr . exprGetParent ( ) ; while ( null != parent ) { if ( parent instanceof ElemTemplateElement ) return ( ElemTemplateElement ) parent ; parent = parent . exprGetParent ( ) ; } throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ASSERT_NO_TEMPLATE_PARENT , null ) ) ; } public boolean isAbsolute ( LocPathIterator path ) { int analysis = path . getAnalysisBits ( ) ; boolean isAbs = ( WalkerFactory . isSet ( analysis , WalkerFactory . BIT_ROOT ) || WalkerFactory . isSet ( analysis , WalkerFactory . BIT_ANY_DESCENDANT_FROM_ROOT ) ) ; if ( isAbs ) { isAbs = m_absPathChecker . checkAbsolute ( path ) ; } return isAbs ; } public boolean visitLocationPath ( ExpressionOwner owner , LocPathIterator path ) { if ( path instanceof SelfIteratorNoPredicate ) { return true ; } else if ( path instanceof WalkingIterator ) { WalkingIterator wi = ( WalkingIterator ) path ; AxesWalker aw = wi . getFirstWalker ( ) ; if ( ( aw instanceof FilterExprWalker ) && ( null == aw . getNextWalker ( ) ) ) { FilterExprWalker few = ( FilterExprWalker ) aw ; Expression exp = few . getInnerExpression ( ) ; if ( exp instanceof Variable ) return true ; } } if ( isAbsolute ( path ) && ( null != m_absPaths ) ) { if ( DEBUG ) validateNewAddition ( m_absPaths , owner , path ) ; m_absPaths . addElement ( owner ) ; } else if ( m_isSameContext && ( null != m_paths ) ) { if ( DEBUG ) validateNewAddition ( m_paths , owner , path ) ; m_paths . addElement ( owner ) ; } return true ; } public boolean visitPredicate ( ExpressionOwner owner , Expression pred ) { boolean savedIsSame = m_isSameContext ; m_isSameContext = false ; pred . callVisitors ( owner , this ) ; m_isSameContext = savedIsSame ; return false ; } public boolean visitTopLevelInstruction ( ElemTemplateElement elem ) { int type = elem . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEMPLATE : return visitInstruction ( elem ) ; default : return true ; } } public boolean visitInstruction ( ElemTemplateElement elem ) { int type = elem . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_TEMPLATE : case Constants . ELEMNAME_FOREACH : { if ( type == Constants . ELEMNAME_FOREACH ) { ElemForEach efe = ( ElemForEach ) elem ; Expression select = efe . getSelect ( ) ; select . callVisitors ( efe , this ) ; } Vector savedPaths = m_paths ; m_paths = new Vector ( ) ; elem . callChildVisitors ( this , false ) ; eleminateRedundentLocals ( elem ) ; m_paths = savedPaths ; return false ; } case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_SORT : boolean savedIsSame = m_isSameContext ; m_isSameContext = false ; elem . callChildVisitors ( this ) ; m_isSameContext = savedIsSame ; return false ; default : return true ; } } protected void diagnoseNumPaths ( Vector paths , int numPathsEliminated , int numUniquePathsEliminated ) { if ( numPathsEliminated > 0 ) { if ( paths == m_paths ) { System . err . println ( "Eliminated " + numPathsEliminated + " total paths!" ) ; System . err . println ( "Consolodated " + numUniquePathsEliminated + " redundent paths!" ) ; } else { System . err . println ( "Eliminated " + numPathsEliminated + " total global paths!" ) ; System . err . println ( "Consolodated " + numUniquePathsEliminated + " redundent global paths!" ) ; } } } private final void assertIsLocPathIterator ( Expression expr1 , ExpressionOwner eo ) throws RuntimeException { if ( ! ( expr1 instanceof LocPathIterator ) ) { String errMsg ; if ( expr1 instanceof Variable ) { errMsg = "Programmer's assertion: expr1 not an iterator: " + ( ( Variable ) expr1 ) . getQName ( ) ; } else { errMsg = "Programmer's assertion: expr1 not an iterator: " + expr1 . getClass ( ) . getName ( ) ; } throw new RuntimeException ( errMsg + ", " + eo . getClass ( ) . getName ( ) + " " + expr1 . exprGetParent ( ) ) ; } } private static void validateNewAddition ( Vector paths , ExpressionOwner owner , LocPathIterator path ) throws RuntimeException { assertion ( owner . getExpression ( ) == path , "owner.getExpression() != path!!!" ) ; int n = paths . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ExpressionOwner ew = ( ExpressionOwner ) paths . elementAt ( i ) ; assertion ( ew != owner , "duplicate owner on the list!!!" ) ; assertion ( ew . getExpression ( ) != path , "duplicate expression on the list!!!" ) ; } } protected static void assertion ( boolean b , String msg ) { if ( ! b ) { throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , new Object [ ] { msg } ) ) ; } } class MultistepExprHolder implements Cloneable { ExpressionOwner m_exprOwner ; final int m_stepCount ; MultistepExprHolder m_next ; public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } MultistepExprHolder ( ExpressionOwner exprOwner , int stepCount , MultistepExprHolder next ) { m_exprOwner = exprOwner ; assertion ( null != m_exprOwner , "exprOwner can not be null!" ) ; m_stepCount = stepCount ; m_next = next ; } MultistepExprHolder addInSortedOrder ( ExpressionOwner exprOwner , int stepCount ) { MultistepExprHolder first = this ; MultistepExprHolder next = this ; MultistepExprHolder prev = null ; while ( null != next ) { if ( stepCount >= next . m_stepCount ) { MultistepExprHolder newholder = new MultistepExprHolder ( exprOwner , stepCount , next ) ; if ( null == prev ) first = newholder ; else prev . m_next = newholder ; return first ; } prev = next ; next = next . m_next ; } prev . m_next = new MultistepExprHolder ( exprOwner , stepCount , null ) ; return first ; } MultistepExprHolder unlink ( MultistepExprHolder itemToRemove ) { MultistepExprHolder first = this ; MultistepExprHolder next = this ; MultistepExprHolder prev = null ; while ( null != next ) { if ( next == itemToRemove ) { if ( null == prev ) first = next . m_next ; else prev . m_next = next . m_next ; next . m_next = null ; return first ; } prev = next ; next = next . m_next ; } assertion ( false , "unlink failed!!!" ) ; return null ; } int getLength ( ) { int count = 0 ; MultistepExprHolder next = this ; while ( null != next ) { count ++ ; next = next . m_next ; } return count ; } protected void diagnose ( ) { System . err . print ( "Found multistep iterators: " + this . getLength ( ) + "  " ) ; MultistepExprHolder next = this ; while ( null != next ) { System . err . print ( "" + next . m_stepCount ) ; next = next . m_next ; if ( null != next ) System . err . print ( ", " ) ; } System . err . println ( ) ; } } } 	1	['38', '3', '0', '27', '128', '607', '1', '27', '8', '0.9', '1849', '0', '2', '0.357142857', '0.194594595', '0', '0', '47.39473684', '15', '3.7632', '2']
package org . apache . xalan . xslt ; import java . io . File ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; public class EnvironmentCheck { public static void main ( String [ ] args ) { PrintWriter sendOutputTo = new PrintWriter ( System . out , true ) ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( "-out" . equalsIgnoreCase ( args [ i ] ) ) { i ++ ; if ( i < args . length ) { try { sendOutputTo = new PrintWriter ( new FileWriter ( args [ i ] , true ) ) ; } catch ( Exception e ) { System . err . println ( "# WARNING: -out " + args [ i ] + " threw " + e . toString ( ) ) ; } } else { System . err . println ( "# WARNING: -out argument should have a filename, output sent to console" ) ; } } } EnvironmentCheck app = new EnvironmentCheck ( ) ; app . checkEnvironment ( sendOutputTo ) ; } public boolean checkEnvironment ( PrintWriter pw ) { if ( null != pw ) outWriter = pw ; Hashtable hash = getEnvironmentHash ( ) ; boolean environmentHasErrors = writeEnvironmentReport ( hash ) ; if ( environmentHasErrors ) { logMsg ( "# WARNING: Potential problems found in your environment!" ) ; logMsg ( "#    Check any 'ERROR' items above against the Xalan FAQs" ) ; logMsg ( "#    to correct potential problems with your classes/jars" ) ; logMsg ( "#    http://xml.apache.org/xalan-j/faq.html" ) ; if ( null != outWriter ) outWriter . flush ( ) ; return false ; } else { logMsg ( "# YAHOO! Your environment seems to be OK." ) ; if ( null != outWriter ) outWriter . flush ( ) ; return true ; } } public Hashtable getEnvironmentHash ( ) { Hashtable hash = new Hashtable ( ) ; checkJAXPVersion ( hash ) ; checkProcessorVersion ( hash ) ; checkParserVersion ( hash ) ; checkAntVersion ( hash ) ; checkDOMVersion ( hash ) ; checkSAXVersion ( hash ) ; checkSystemProperties ( hash ) ; return hash ; } protected boolean writeEnvironmentReport ( Hashtable h ) { if ( null == h ) { logMsg ( "# ERROR: writeEnvironmentReport called with null Hashtable" ) ; return false ; } boolean errors = false ; logMsg ( "#---- BEGIN writeEnvironmentReport($Revision: 1.26 $): Useful stuff found: ----" ) ; for ( Enumeration keys = h . keys ( ) ; keys . hasMoreElements ( ) ; ) { Object key = keys . nextElement ( ) ; String keyStr = ( String ) key ; try { if ( keyStr . startsWith ( FOUNDCLASSES ) ) { Vector v = ( Vector ) h . get ( keyStr ) ; errors |= logFoundJars ( v , keyStr ) ; } else { if ( keyStr . startsWith ( ERROR ) ) { errors = true ; } logMsg ( keyStr + "=" + h . get ( keyStr ) ) ; } } catch ( Exception e ) { logMsg ( "Reading-" + key + "= threw: " + e . toString ( ) ) ; } } logMsg ( "#----- END writeEnvironmentReport: Useful properties found: -----" ) ; return errors ; } public static final String ERROR = "ERROR." ; public static final String WARNING = "WARNING." ; public static final String ERROR_FOUND = "At least one error was found!" ; public static final String VERSION = "version." ; public static final String FOUNDCLASSES = "foundclasses." ; public static final String CLASS_PRESENT = "present-unknown-version" ; public static final String CLASS_NOTPRESENT = "not-present" ; public String [ ] jarNames = { "xalan.jar" , "xalansamples.jar" , "xalanj1compat.jar" , "xalanservlet.jar" , "xerces.jar" , "xercesImpl.jar" , "testxsl.jar" , "crimson.jar" , "lotusxsl.jar" , "jaxp.jar" , "parser.jar" , "dom.jar" , "sax.jar" , "xml.jar" , "xml-apis.jar" , "xsltc.jar" } ; protected boolean logFoundJars ( Vector v , String desc ) { if ( ( null == v ) || ( v . size ( ) < 1 ) ) return false ; boolean errors = false ; logMsg ( "#---- BEGIN Listing XML-related jars in: " + desc + " ----" ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { Hashtable subhash = ( Hashtable ) v . elementAt ( i ) ; for ( Enumeration keys = subhash . keys ( ) ; keys . hasMoreElements ( ) ; ) { Object key = keys . nextElement ( ) ; String keyStr = ( String ) key ; try { if ( keyStr . startsWith ( ERROR ) ) { errors = true ; } logMsg ( keyStr + "=" + subhash . get ( keyStr ) ) ; } catch ( Exception e ) { errors = true ; logMsg ( "Reading-" + key + "= threw: " + e . toString ( ) ) ; } } } logMsg ( "#----- END Listing XML-related jars in: " + desc + " -----" ) ; return errors ; } public void appendEnvironmentReport ( Node container , Document factory , Hashtable h ) { if ( ( null == container ) || ( null == factory ) ) { return ; } try { Element envCheckNode = factory . createElement ( "EnvironmentCheck" ) ; envCheckNode . setAttribute ( "version" , "$Revision: 1.26 $" ) ; container . appendChild ( envCheckNode ) ; if ( null == h ) { Element statusNode = factory . createElement ( "status" ) ; statusNode . setAttribute ( "result" , "ERROR" ) ; statusNode . appendChild ( factory . createTextNode ( "appendEnvironmentReport called with null Hashtable!" ) ) ; envCheckNode . appendChild ( statusNode ) ; return ; } boolean errors = false ; Element hashNode = factory . createElement ( "environment" ) ; envCheckNode . appendChild ( hashNode ) ; for ( Enumeration keys = h . keys ( ) ; keys . hasMoreElements ( ) ; ) { Object key = keys . nextElement ( ) ; String keyStr = ( String ) key ; try { if ( keyStr . startsWith ( FOUNDCLASSES ) ) { Vector v = ( Vector ) h . get ( keyStr ) ; errors |= appendFoundJars ( hashNode , factory , v , keyStr ) ; } else { if ( keyStr . startsWith ( ERROR ) ) { errors = true ; } Element node = factory . createElement ( "item" ) ; node . setAttribute ( "key" , keyStr ) ; node . appendChild ( factory . createTextNode ( ( String ) h . get ( keyStr ) ) ) ; hashNode . appendChild ( node ) ; } } catch ( Exception e ) { errors = true ; Element node = factory . createElement ( "item" ) ; node . setAttribute ( "key" , keyStr ) ; node . appendChild ( factory . createTextNode ( ERROR + " Reading " + key + " threw: " + e . toString ( ) ) ) ; hashNode . appendChild ( node ) ; } } Element statusNode = factory . createElement ( "status" ) ; statusNode . setAttribute ( "result" , ( errors ? "ERROR" : "OK" ) ) ; envCheckNode . appendChild ( statusNode ) ; } catch ( Exception e2 ) { System . err . println ( "appendEnvironmentReport threw: " + e2 . toString ( ) ) ; e2 . printStackTrace ( ) ; } } protected boolean appendFoundJars ( Node container , Document factory , Vector v , String desc ) { if ( ( null == v ) || ( v . size ( ) < 1 ) ) return false ; boolean errors = false ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { Hashtable subhash = ( Hashtable ) v . elementAt ( i ) ; for ( Enumeration keys = subhash . keys ( ) ; keys . hasMoreElements ( ) ; ) { Object key = keys . nextElement ( ) ; try { String keyStr = ( String ) key ; if ( keyStr . startsWith ( ERROR ) ) { errors = true ; } Element node = factory . createElement ( "foundJar" ) ; node . setAttribute ( "name" , keyStr . substring ( 0 , keyStr . indexOf ( "-" ) ) ) ; node . setAttribute ( "desc" , keyStr . substring ( keyStr . indexOf ( "-" ) + 1 ) ) ; node . appendChild ( factory . createTextNode ( ( String ) subhash . get ( keyStr ) ) ) ; container . appendChild ( node ) ; } catch ( Exception e ) { errors = true ; Element node = factory . createElement ( "foundJar" ) ; node . appendChild ( factory . createTextNode ( ERROR + " Reading " + key + " threw: " + e . toString ( ) ) ) ; container . appendChild ( node ) ; } } } return errors ; } protected void checkSystemProperties ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; try { String javaVersion = System . getProperty ( "java.version" ) ; h . put ( "java.version" , javaVersion ) ; } catch ( SecurityException se ) { h . put ( "java.version" , "WARNING: SecurityException thrown accessing system version properties" ) ; } try { String cp = System . getProperty ( "java.class.path" ) ; h . put ( "java.class.path" , cp ) ; Vector classpathJars = checkPathForJars ( cp , jarNames ) ; if ( null != classpathJars ) h . put ( FOUNDCLASSES + "java.class.path" , classpathJars ) ; String othercp = System . getProperty ( "sun.boot.class.path" ) ; if ( null != othercp ) { h . put ( "sun.boot.class.path" , othercp ) ; classpathJars = checkPathForJars ( othercp , jarNames ) ; if ( null != classpathJars ) h . put ( FOUNDCLASSES + "sun.boot.class.path" , classpathJars ) ; } othercp = System . getProperty ( "java.ext.dirs" ) ; if ( null != othercp ) { h . put ( "java.ext.dirs" , othercp ) ; classpathJars = checkPathForJars ( othercp , jarNames ) ; if ( null != classpathJars ) h . put ( FOUNDCLASSES + "java.ext.dirs" , classpathJars ) ; } } catch ( SecurityException se2 ) { h . put ( "java.class.path" , "WARNING: SecurityException thrown accessing system classpath properties" ) ; } } protected Vector checkPathForJars ( String cp , String [ ] jars ) { if ( ( null == cp ) || ( null == jars ) || ( 0 == cp . length ( ) ) || ( 0 == jars . length ) ) return null ; Vector v = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( cp , File . pathSeparator ) ; while ( st . hasMoreTokens ( ) ) { String filename = st . nextToken ( ) ; for ( int i = 0 ; i < jars . length ; i ++ ) { if ( filename . indexOf ( jars [ i ] ) > - 1 ) { File f = new File ( filename ) ; if ( f . exists ( ) ) { try { Hashtable h = new Hashtable ( 2 ) ; h . put ( jars [ i ] + "-path" , f . getAbsolutePath ( ) ) ; if ( ! ( "xalan.jar" . equalsIgnoreCase ( jars [ i ] ) ) ) { h . put ( jars [ i ] + "-apparent.version" , getApparentVersion ( jars [ i ] , f . length ( ) ) ) ; } v . addElement ( h ) ; } catch ( Exception e ) { } } else { Hashtable h = new Hashtable ( 2 ) ; h . put ( jars [ i ] + "-path" , WARNING + " Classpath entry: " + filename + " does not exist" ) ; h . put ( jars [ i ] + "-apparent.version" , CLASS_NOTPRESENT ) ; v . addElement ( h ) ; } } } } return v ; } protected String getApparentVersion ( String jarName , long jarSize ) { String foundSize = ( String ) jarVersions . get ( new Long ( jarSize ) ) ; if ( ( null != foundSize ) && ( foundSize . startsWith ( jarName ) ) ) { return foundSize ; } else { if ( "xerces.jar" . equalsIgnoreCase ( jarName ) || "xercesImpl.jar" . equalsIgnoreCase ( jarName ) ) { return jarName + " " + WARNING + CLASS_PRESENT ; } else { return jarName + " " + CLASS_PRESENT ; } } } protected void checkJAXPVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; final Class noArgs [ ] = new Class [ 0 ] ; Class clazz = null ; try { final String JAXP1_CLASS = "javax.xml.parsers.DocumentBuilder" ; final String JAXP11_METHOD = "getDOMImplementation" ; clazz = ObjectFactory . findProviderClass ( JAXP1_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; Method method = clazz . getMethod ( JAXP11_METHOD , noArgs ) ; h . put ( VERSION + "JAXP" , "1.1 or higher" ) ; } catch ( Exception e ) { if ( null != clazz ) { h . put ( ERROR + VERSION + "JAXP" , "1.0.1" ) ; h . put ( ERROR , ERROR_FOUND ) ; } else { h . put ( ERROR + VERSION + "JAXP" , CLASS_NOTPRESENT ) ; h . put ( ERROR , ERROR_FOUND ) ; } } } protected void checkProcessorVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; try { final String XALAN1_VERSION_CLASS = "org.apache.xalan.xslt.XSLProcessorVersion" ; Class clazz = ObjectFactory . findProviderClass ( XALAN1_VERSION_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; StringBuffer buf = new StringBuffer ( ) ; Field f = clazz . getField ( "PRODUCT" ) ; buf . append ( f . get ( null ) ) ; buf . append ( ';' ) ; f = clazz . getField ( "LANGUAGE" ) ; buf . append ( f . get ( null ) ) ; buf . append ( ';' ) ; f = clazz . getField ( "S_VERSION" ) ; buf . append ( f . get ( null ) ) ; buf . append ( ';' ) ; h . put ( VERSION + "xalan1" , buf . toString ( ) ) ; } catch ( Exception e1 ) { h . put ( VERSION + "xalan1" , CLASS_NOTPRESENT ) ; } try { final String XALAN2_VERSION_CLASS = "org.apache.xalan.processor.XSLProcessorVersion" ; Class clazz = ObjectFactory . findProviderClass ( XALAN2_VERSION_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; StringBuffer buf = new StringBuffer ( ) ; Field f = clazz . getField ( "S_VERSION" ) ; buf . append ( f . get ( null ) ) ; h . put ( VERSION + "xalan2x" , buf . toString ( ) ) ; } catch ( Exception e2 ) { h . put ( VERSION + "xalan2x" , CLASS_NOTPRESENT ) ; } try { final String XALAN2_2_VERSION_CLASS = "org.apache.xalan.Version" ; final String XALAN2_2_VERSION_METHOD = "getVersion" ; final Class noArgs [ ] = new Class [ 0 ] ; Class clazz = ObjectFactory . findProviderClass ( XALAN2_2_VERSION_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; Method method = clazz . getMethod ( XALAN2_2_VERSION_METHOD , noArgs ) ; Object returnValue = method . invoke ( null , new Object [ 0 ] ) ; h . put ( VERSION + "xalan2_2" , ( String ) returnValue ) ; } catch ( Exception e2 ) { h . put ( VERSION + "xalan2_2" , CLASS_NOTPRESENT ) ; } } protected void checkParserVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; try { final String XERCES1_VERSION_CLASS = "org.apache.xerces.framework.Version" ; Class clazz = ObjectFactory . findProviderClass ( XERCES1_VERSION_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; Field f = clazz . getField ( "fVersion" ) ; String parserVersion = ( String ) f . get ( null ) ; h . put ( VERSION + "xerces1" , parserVersion ) ; } catch ( Exception e ) { h . put ( VERSION + "xerces1" , CLASS_NOTPRESENT ) ; } try { final String XERCES2_VERSION_CLASS = "org.apache.xerces.impl.Version" ; Class clazz = ObjectFactory . findProviderClass ( XERCES2_VERSION_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; Field f = clazz . getField ( "fVersion" ) ; String parserVersion = ( String ) f . get ( null ) ; h . put ( VERSION + "xerces2" , parserVersion ) ; } catch ( Exception e ) { h . put ( VERSION + "xerces2" , CLASS_NOTPRESENT ) ; } try { final String CRIMSON_CLASS = "org.apache.crimson.parser.Parser2" ; Class clazz = ObjectFactory . findProviderClass ( CRIMSON_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; h . put ( VERSION + "crimson" , CLASS_PRESENT ) ; } catch ( Exception e ) { h . put ( VERSION + "crimson" , CLASS_NOTPRESENT ) ; } } protected void checkAntVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; try { final String ANT_VERSION_CLASS = "org.apache.tools.ant.Main" ; final String ANT_VERSION_METHOD = "getAntVersion" ; final Class noArgs [ ] = new Class [ 0 ] ; Class clazz = ObjectFactory . findProviderClass ( ANT_VERSION_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; Method method = clazz . getMethod ( ANT_VERSION_METHOD , noArgs ) ; Object returnValue = method . invoke ( null , new Object [ 0 ] ) ; h . put ( VERSION + "ant" , ( String ) returnValue ) ; } catch ( Exception e ) { h . put ( VERSION + "ant" , CLASS_NOTPRESENT ) ; } } protected void checkDOMVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; final String DOM_LEVEL2_CLASS = "org.w3c.dom.Document" ; final String DOM_LEVEL2_METHOD = "createElementNS" ; final String DOM_LEVEL2WD_CLASS = "org.w3c.dom.Node" ; final String DOM_LEVEL2WD_METHOD = "supported" ; final String DOM_LEVEL2FD_CLASS = "org.w3c.dom.Node" ; final String DOM_LEVEL2FD_METHOD = "isSupported" ; final Class twoStringArgs [ ] = { java . lang . String . class , java . lang . String . class } ; try { Class clazz = ObjectFactory . findProviderClass ( DOM_LEVEL2_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; Method method = clazz . getMethod ( DOM_LEVEL2_METHOD , twoStringArgs ) ; h . put ( VERSION + "DOM" , "2.0" ) ; try { clazz = ObjectFactory . findProviderClass ( DOM_LEVEL2WD_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; method = clazz . getMethod ( DOM_LEVEL2WD_METHOD , twoStringArgs ) ; h . put ( ERROR + VERSION + "DOM.draftlevel" , "2.0wd" ) ; h . put ( ERROR , ERROR_FOUND ) ; } catch ( Exception e2 ) { try { clazz = ObjectFactory . findProviderClass ( DOM_LEVEL2FD_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; method = clazz . getMethod ( DOM_LEVEL2FD_METHOD , twoStringArgs ) ; h . put ( VERSION + "DOM.draftlevel" , "2.0fd" ) ; } catch ( Exception e3 ) { h . put ( ERROR + VERSION + "DOM.draftlevel" , "2.0unknown" ) ; h . put ( ERROR , ERROR_FOUND ) ; } } } catch ( Exception e ) { h . put ( ERROR + VERSION + "DOM" , "ERROR attempting to load DOM level 2 class: " + e . toString ( ) ) ; h . put ( ERROR , ERROR_FOUND ) ; } } protected void checkSAXVersion ( Hashtable h ) { if ( null == h ) h = new Hashtable ( ) ; final String SAX_VERSION1_CLASS = "org.xml.sax.Parser" ; final String SAX_VERSION1_METHOD = "parse" ; final String SAX_VERSION2_CLASS = "org.xml.sax.XMLReader" ; final String SAX_VERSION2_METHOD = "parse" ; final String SAX_VERSION2BETA_CLASSNF = "org.xml.sax.helpers.AttributesImpl" ; final String SAX_VERSION2BETA_METHODNF = "setAttributes" ; final Class oneStringArg [ ] = { java . lang . String . class } ; final Class attributesArg [ ] = { org . xml . sax . Attributes . class } ; try { Class clazz = ObjectFactory . findProviderClass ( SAX_VERSION2BETA_CLASSNF , ObjectFactory . findClassLoader ( ) , true ) ; Method method = clazz . getMethod ( SAX_VERSION2BETA_METHODNF , attributesArg ) ; h . put ( VERSION + "SAX" , "2.0" ) ; } catch ( Exception e ) { h . put ( ERROR + VERSION + "SAX" , "ERROR attempting to load SAX version 2 class: " + e . toString ( ) ) ; h . put ( ERROR , ERROR_FOUND ) ; try { Class clazz = ObjectFactory . findProviderClass ( SAX_VERSION2_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; Method method = clazz . getMethod ( SAX_VERSION2_METHOD , oneStringArg ) ; h . put ( VERSION + "SAX-backlevel" , "2.0beta2-or-earlier" ) ; } catch ( Exception e2 ) { h . put ( ERROR + VERSION + "SAX" , "ERROR attempting to load SAX version 2 class: " + e . toString ( ) ) ; h . put ( ERROR , ERROR_FOUND ) ; try { Class clazz = ObjectFactory . findProviderClass ( SAX_VERSION1_CLASS , ObjectFactory . findClassLoader ( ) , true ) ; Method method = clazz . getMethod ( SAX_VERSION1_METHOD , oneStringArg ) ; h . put ( VERSION + "SAX-backlevel" , "1.0" ) ; } catch ( Exception e3 ) { h . put ( ERROR + VERSION + "SAX-backlevel" , "ERROR attempting to load SAX version 1 class: " + e3 . toString ( ) ) ; } } } } protected static Hashtable jarVersions = new Hashtable ( ) ; static { jarVersions . put ( new Long ( 857192 ) , "xalan.jar from xalan-j_1_1" ) ; jarVersions . put ( new Long ( 440237 ) , "xalan.jar from xalan-j_1_2" ) ; jarVersions . put ( new Long ( 436094 ) , "xalan.jar from xalan-j_1_2_1" ) ; jarVersions . put ( new Long ( 426249 ) , "xalan.jar from xalan-j_1_2_2" ) ; jarVersions . put ( new Long ( 702536 ) , "xalan.jar from xalan-j_2_0_0" ) ; jarVersions . put ( new Long ( 720930 ) , "xalan.jar from xalan-j_2_0_1" ) ; jarVersions . put ( new Long ( 732330 ) , "xalan.jar from xalan-j_2_1_0" ) ; jarVersions . put ( new Long ( 872241 ) , "xalan.jar from xalan-j_2_2_D10" ) ; jarVersions . put ( new Long ( 882739 ) , "xalan.jar from xalan-j_2_2_D11" ) ; jarVersions . put ( new Long ( 923866 ) , "xalan.jar from xalan-j_2_2_0" ) ; jarVersions . put ( new Long ( 905872 ) , "xalan.jar from xalan-j_2_3_D1" ) ; jarVersions . put ( new Long ( 906122 ) , "xalan.jar from xalan-j_2_3_0" ) ; jarVersions . put ( new Long ( 906248 ) , "xalan.jar from xalan-j_2_3_1" ) ; jarVersions . put ( new Long ( 983377 ) , "xalan.jar from xalan-j_2_4_D1" ) ; jarVersions . put ( new Long ( 997276 ) , "xalan.jar from xalan-j_2_4_0" ) ; jarVersions . put ( new Long ( 1031036 ) , "xalan.jar from xalan-j_2_4_1" ) ; jarVersions . put ( new Long ( 596540 ) , "xsltc.jar from xalan-j_2_2_0" ) ; jarVersions . put ( new Long ( 590247 ) , "xsltc.jar from xalan-j_2_3_D1" ) ; jarVersions . put ( new Long ( 589914 ) , "xsltc.jar from xalan-j_2_3_0" ) ; jarVersions . put ( new Long ( 589915 ) , "xsltc.jar from xalan-j_2_3_1" ) ; jarVersions . put ( new Long ( 1306667 ) , "xsltc.jar from xalan-j_2_4_D1" ) ; jarVersions . put ( new Long ( 1328227 ) , "xsltc.jar from xalan-j_2_4_0" ) ; jarVersions . put ( new Long ( 1344009 ) , "xsltc.jar from xalan-j_2_4_1" ) ; jarVersions . put ( new Long ( 1348361 ) , "xsltc.jar from xalan-j_2_5_D1" ) ; jarVersions . put ( new Long ( 1268634 ) , "xsltc.jar-bundled from xalan-j_2_3_0" ) ; jarVersions . put ( new Long ( 100196 ) , "xml-apis.jar from xalan-j_2_2_0 or xalan-j_2_3_D1" ) ; jarVersions . put ( new Long ( 108484 ) , "xml-apis.jar from xalan-j_2_3_0, or xalan-j_2_3_1 from xml-commons-1.0.b2" ) ; jarVersions . put ( new Long ( 109049 ) , "xml-apis.jar from xalan-j_2_4_0 from xml-commons RIVERCOURT1 branch" ) ; jarVersions . put ( new Long ( 113749 ) , "xml-apis.jar from xalan-j_2_4_1 from factoryfinder-build of xml-commons RIVERCOURT1" ) ; jarVersions . put ( new Long ( 124704 ) , "xml-apis.jar from tck-jaxp-1_2_0 branch of xml-commons" ) ; jarVersions . put ( new Long ( 124724 ) , "xml-apis.jar from tck-jaxp-1_2_0 branch of xml-commons, tag: xml-commons-external_1_2_01" ) ; jarVersions . put ( new Long ( 424490 ) , "xalan.jar from Xerces Tools releases - ERROR:DO NOT USE!" ) ; jarVersions . put ( new Long ( 1591855 ) , "xerces.jar from xalan-j_1_1 from xerces-1..." ) ; jarVersions . put ( new Long ( 1498679 ) , "xerces.jar from xalan-j_1_2 from xerces-1_2_0.bin" ) ; jarVersions . put ( new Long ( 1484896 ) , "xerces.jar from xalan-j_1_2_1 from xerces-1_2_1.bin" ) ; jarVersions . put ( new Long ( 804460 ) , "xerces.jar from xalan-j_1_2_2 from xerces-1_2_2.bin" ) ; jarVersions . put ( new Long ( 1499244 ) , "xerces.jar from xalan-j_2_0_0 from xerces-1_2_3.bin" ) ; jarVersions . put ( new Long ( 1605266 ) , "xerces.jar from xalan-j_2_0_1 from xerces-1_3_0.bin" ) ; jarVersions . put ( new Long ( 904030 ) , "xerces.jar from xalan-j_2_1_0 from xerces-1_4.bin" ) ; jarVersions . put ( new Long ( 904030 ) , "xerces.jar from xerces-1_4_0.bin" ) ; jarVersions . put ( new Long ( 1802885 ) , "xerces.jar from xerces-1_4_2.bin" ) ; jarVersions . put ( new Long ( 1734594 ) , "xerces.jar from Xerces-J-bin.2.0.0.beta3" ) ; jarVersions . put ( new Long ( 1808883 ) , "xerces.jar from xalan-j_2_2_D10,D11,D12 or xerces-1_4_3.bin" ) ; jarVersions . put ( new Long ( 1812019 ) , "xerces.jar from xalan-j_2_2_0" ) ; jarVersions . put ( new Long ( 1720292 ) , "xercesImpl.jar from xalan-j_2_3_D1" ) ; jarVersions . put ( new Long ( 1730053 ) , "xercesImpl.jar from xalan-j_2_3_0 or xalan-j_2_3_1 from xerces-2_0_0" ) ; jarVersions . put ( new Long ( 1728861 ) , "xercesImpl.jar from xalan-j_2_4_D1 from xerces-2_0_1" ) ; jarVersions . put ( new Long ( 972027 ) , "xercesImpl.jar from xalan-j_2_4_0 from xerces-2_1" ) ; jarVersions . put ( new Long ( 831587 ) , "xercesImpl.jar from xalan-j_2_4_1 from xerces-2_2" ) ; jarVersions . put ( new Long ( 891817 ) , "xercesImpl.jar from xalan-j_2_5_D1 from xerces-2_3" ) ; jarVersions . put ( new Long ( 895924 ) , "xercesImpl.jar from xerces-2_4" ) ; jarVersions . put ( new Long ( 1010806 ) , "xercesImpl.jar from Xerces-J-bin.2.6.2" ) ; jarVersions . put ( new Long ( 37485 ) , "xalanj1compat.jar from xalan-j_2_0_0" ) ; jarVersions . put ( new Long ( 38100 ) , "xalanj1compat.jar from xalan-j_2_0_1" ) ; jarVersions . put ( new Long ( 18779 ) , "xalanservlet.jar from xalan-j_2_0_0" ) ; jarVersions . put ( new Long ( 21453 ) , "xalanservlet.jar from xalan-j_2_0_1" ) ; jarVersions . put ( new Long ( 24826 ) , "xalanservlet.jar from xalan-j_2_3_1 or xalan-j_2_4_1" ) ; jarVersions . put ( new Long ( 24831 ) , "xalanservlet.jar from xalan-j_2_4_1" ) ; jarVersions . put ( new Long ( 5618 ) , "jaxp.jar from jaxp1.0.1" ) ; jarVersions . put ( new Long ( 136133 ) , "parser.jar from jaxp1.0.1" ) ; jarVersions . put ( new Long ( 28404 ) , "jaxp.jar from jaxp-1.1" ) ; jarVersions . put ( new Long ( 187162 ) , "crimson.jar from jaxp-1.1" ) ; jarVersions . put ( new Long ( 801714 ) , "xalan.jar from jaxp-1.1" ) ; jarVersions . put ( new Long ( 196399 ) , "crimson.jar from crimson-1.1.1" ) ; jarVersions . put ( new Long ( 33323 ) , "jaxp.jar from crimson-1.1.1 or jakarta-ant-1.4.1b1" ) ; jarVersions . put ( new Long ( 152717 ) , "crimson.jar from crimson-1.1.2beta2" ) ; jarVersions . put ( new Long ( 88143 ) , "xml-apis.jar from crimson-1.1.2beta2" ) ; jarVersions . put ( new Long ( 206384 ) , "crimson.jar from crimson-1.1.3 or jakarta-ant-1.4.1b1" ) ; jarVersions . put ( new Long ( 136198 ) , "parser.jar from jakarta-ant-1.3 or 1.2" ) ; jarVersions . put ( new Long ( 5537 ) , "jaxp.jar from jakarta-ant-1.3 or 1.2" ) ; } protected PrintWriter outWriter = new PrintWriter ( System . out , true ) ; protected void logMsg ( String s ) { outWriter . println ( s ) ; } } 	1	['19', '1', '0', '2', '73', '161', '1', '1', '5', '0.983333333', '2178', '0.2', '0', '0', '0.25308642', '0', '0', '113.1052632', '9', '3.5789', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . * ; import org . apache . xml . utils . SuballocatedIntVector ; import org . apache . xml . utils . BoolStack ; import java . util . Vector ; import javax . xml . transform . Source ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . res . XMLErrorResources ; import java . io . * ; public abstract class DTMDefaultBase implements DTM { static boolean JJK_DEBUG = false ; public static final int ROOTNODE = 0 ; protected int m_size = 0 ; protected SuballocatedIntVector m_exptype ; protected SuballocatedIntVector m_firstch ; protected SuballocatedIntVector m_nextsib ; protected SuballocatedIntVector m_prevsib ; protected SuballocatedIntVector m_parent ; protected Vector m_namespaceDeclSets = null ; protected SuballocatedIntVector m_namespaceDeclSetElements = null ; protected int [ ] [ ] [ ] m_elemIndexes ; public static final int DEFAULT_BLOCKSIZE = 512 ; public static final int DEFAULT_NUMBLOCKS = 32 ; public static final int DEFAULT_NUMBLOCKS_SMALL = 4 ; protected static final int NOTPROCESSED = DTM . NULL - 1 ; public DTMManager m_mgr ; protected DTMManagerDefault m_mgrDefault = null ; protected SuballocatedIntVector m_dtmIdent ; protected String m_documentBaseURI ; protected DTMWSFilter m_wsfilter ; protected boolean m_shouldStripWS = false ; protected BoolStack m_shouldStripWhitespaceStack ; protected XMLStringFactory m_xstrf ; protected ExpandedNameTable m_expandedNameTable ; protected boolean m_indexing ; public DTMDefaultBase ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { this ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , DEFAULT_BLOCKSIZE , true , false ) ; } public DTMDefaultBase ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib , boolean newNameTable ) { int numblocks ; if ( blocksize <= 64 ) { numblocks = DEFAULT_NUMBLOCKS_SMALL ; m_dtmIdent = new SuballocatedIntVector ( 4 , 1 ) ; } else { numblocks = DEFAULT_NUMBLOCKS ; m_dtmIdent = new SuballocatedIntVector ( 32 ) ; } m_exptype = new SuballocatedIntVector ( blocksize , numblocks ) ; m_firstch = new SuballocatedIntVector ( blocksize , numblocks ) ; m_nextsib = new SuballocatedIntVector ( blocksize , numblocks ) ; m_parent = new SuballocatedIntVector ( blocksize , numblocks ) ; if ( usePrevsib ) m_prevsib = new SuballocatedIntVector ( blocksize , numblocks ) ; m_mgr = mgr ; if ( mgr instanceof DTMManagerDefault ) m_mgrDefault = ( DTMManagerDefault ) mgr ; m_documentBaseURI = ( null != source ) ? source . getSystemId ( ) : null ; m_dtmIdent . setElementAt ( dtmIdentity , 0 ) ; m_wsfilter = whiteSpaceFilter ; m_xstrf = xstringfactory ; m_indexing = doIndexing ; if ( doIndexing ) { m_expandedNameTable = new ExpandedNameTable ( ) ; } else { m_expandedNameTable = m_mgrDefault . getExpandedNameTable ( this ) ; } if ( null != whiteSpaceFilter ) { m_shouldStripWhitespaceStack = new BoolStack ( ) ; pushShouldStripWhitespace ( false ) ; } } protected void ensureSizeOfIndex ( int namespaceID , int LocalNameID ) { if ( null == m_elemIndexes ) { m_elemIndexes = new int [ namespaceID + 20 ] [ ] [ ] ; } else if ( m_elemIndexes . length <= namespaceID ) { int [ ] [ ] [ ] indexes = m_elemIndexes ; m_elemIndexes = new int [ namespaceID + 20 ] [ ] [ ] ; System . arraycopy ( indexes , 0 , m_elemIndexes , 0 , indexes . length ) ; } int [ ] [ ] localNameIndex = m_elemIndexes [ namespaceID ] ; if ( null == localNameIndex ) { localNameIndex = new int [ LocalNameID + 100 ] [ ] ; m_elemIndexes [ namespaceID ] = localNameIndex ; } else if ( localNameIndex . length <= LocalNameID ) { int [ ] [ ] indexes = localNameIndex ; localNameIndex = new int [ LocalNameID + 100 ] [ ] ; System . arraycopy ( indexes , 0 , localNameIndex , 0 , indexes . length ) ; m_elemIndexes [ namespaceID ] = localNameIndex ; } int [ ] elemHandles = localNameIndex [ LocalNameID ] ; if ( null == elemHandles ) { elemHandles = new int [ 128 ] ; localNameIndex [ LocalNameID ] = elemHandles ; elemHandles [ 0 ] = 1 ; } else if ( elemHandles . length <= elemHandles [ 0 ] + 1 ) { int [ ] indexes = elemHandles ; elemHandles = new int [ elemHandles [ 0 ] + 1024 ] ; System . arraycopy ( indexes , 0 , elemHandles , 0 , indexes . length ) ; localNameIndex [ LocalNameID ] = elemHandles ; } } protected void indexNode ( int expandedTypeID , int identity ) { ExpandedNameTable ent = m_expandedNameTable ; short type = ent . getType ( expandedTypeID ) ; if ( DTM . ELEMENT_NODE == type ) { int namespaceID = ent . getNamespaceID ( expandedTypeID ) ; int localNameID = ent . getLocalNameID ( expandedTypeID ) ; ensureSizeOfIndex ( namespaceID , localNameID ) ; int [ ] index = m_elemIndexes [ namespaceID ] [ localNameID ] ; index [ index [ 0 ] ] = identity ; index [ 0 ] ++ ; } } protected int findGTE ( int [ ] list , int start , int len , int value ) { int low = start ; int high = start + ( len - 1 ) ; int end = high ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int c = list [ mid ] ; if ( c > value ) high = mid - 1 ; else if ( c < value ) low = mid + 1 ; else return mid ; } return ( low <= end && list [ low ] > value ) ? low : - 1 ; } int findElementFromIndex ( int nsIndex , int lnIndex , int firstPotential ) { int [ ] [ ] [ ] indexes = m_elemIndexes ; if ( null != indexes && nsIndex < indexes . length ) { int [ ] [ ] lnIndexs = indexes [ nsIndex ] ; if ( null != lnIndexs && lnIndex < lnIndexs . length ) { int [ ] elems = lnIndexs [ lnIndex ] ; if ( null != elems ) { int pos = findGTE ( elems , 1 , elems [ 0 ] , firstPotential ) ; if ( pos > - 1 ) { return elems [ pos ] ; } } } } return NOTPROCESSED ; } protected abstract int getNextNodeIdentity ( int identity ) ; protected abstract boolean nextNode ( ) ; protected abstract int getNumberOfNodes ( ) ; protected DTMAxisTraverser [ ] m_traversers ; protected short _type ( int identity ) { int info = _exptype ( identity ) ; if ( NULL != info ) return m_expandedNameTable . getType ( info ) ; else return NULL ; } protected int _exptype ( int identity ) { if ( identity == DTM . NULL ) return NULL ; while ( identity >= m_size ) { if ( ! nextNode ( ) && identity >= m_size ) return NULL ; } return m_exptype . elementAt ( identity ) ; } protected int _level ( int identity ) { while ( identity >= m_size ) { boolean isMore = nextNode ( ) ; if ( ! isMore && identity >= m_size ) return NULL ; } int i = 0 ; while ( NULL != ( identity = _parent ( identity ) ) ) ++ i ; return i ; } protected int _firstch ( int identity ) { int info = ( identity >= m_size ) ? NOTPROCESSED : m_firstch . elementAt ( identity ) ; while ( info == NOTPROCESSED ) { boolean isMore = nextNode ( ) ; if ( identity >= m_size && ! isMore ) return NULL ; else { info = m_firstch . elementAt ( identity ) ; if ( info == NOTPROCESSED && ! isMore ) return NULL ; } } return info ; } protected int _nextsib ( int identity ) { int info = ( identity >= m_size ) ? NOTPROCESSED : m_nextsib . elementAt ( identity ) ; while ( info == NOTPROCESSED ) { boolean isMore = nextNode ( ) ; if ( identity >= m_size && ! isMore ) return NULL ; else { info = m_nextsib . elementAt ( identity ) ; if ( info == NOTPROCESSED && ! isMore ) return NULL ; } } return info ; } protected int _prevsib ( int identity ) { if ( identity < m_size ) return m_prevsib . elementAt ( identity ) ; while ( true ) { boolean isMore = nextNode ( ) ; if ( identity >= m_size && ! isMore ) return NULL ; else if ( identity < m_size ) return m_prevsib . elementAt ( identity ) ; } } protected int _parent ( int identity ) { if ( identity < m_size ) return m_parent . elementAt ( identity ) ; while ( true ) { boolean isMore = nextNode ( ) ; if ( identity >= m_size && ! isMore ) return NULL ; else if ( identity < m_size ) return m_parent . elementAt ( identity ) ; } } public void dumpDTM ( OutputStream os ) { try { if ( os == null ) { File f = new File ( "DTMDump" + ( ( Object ) this ) . hashCode ( ) + ".txt" ) ; System . err . println ( "Dumping... " + f . getAbsolutePath ( ) ) ; os = new FileOutputStream ( f ) ; } PrintStream ps = new PrintStream ( os ) ; while ( nextNode ( ) ) { } int nRecords = m_size ; ps . println ( "Total nodes: " + nRecords ) ; for ( int index = 0 ; index < nRecords ; ++ index ) { int i = makeNodeHandle ( index ) ; ps . println ( "=========== index=" + index + " handle=" + i + " ===========" ) ; ps . println ( "NodeName: " + getNodeName ( i ) ) ; ps . println ( "NodeNameX: " + getNodeNameX ( i ) ) ; ps . println ( "LocalName: " + getLocalName ( i ) ) ; ps . println ( "NamespaceURI: " + getNamespaceURI ( i ) ) ; ps . println ( "Prefix: " + getPrefix ( i ) ) ; int exTypeID = _exptype ( index ) ; ps . println ( "Expanded Type ID: " + Integer . toHexString ( exTypeID ) ) ; int type = _type ( index ) ; String typestring ; switch ( type ) { case DTM . ATTRIBUTE_NODE : typestring = "ATTRIBUTE_NODE" ; break ; case DTM . CDATA_SECTION_NODE : typestring = "CDATA_SECTION_NODE" ; break ; case DTM . COMMENT_NODE : typestring = "COMMENT_NODE" ; break ; case DTM . DOCUMENT_FRAGMENT_NODE : typestring = "DOCUMENT_FRAGMENT_NODE" ; break ; case DTM . DOCUMENT_NODE : typestring = "DOCUMENT_NODE" ; break ; case DTM . DOCUMENT_TYPE_NODE : typestring = "DOCUMENT_NODE" ; break ; case DTM . ELEMENT_NODE : typestring = "ELEMENT_NODE" ; break ; case DTM . ENTITY_NODE : typestring = "ENTITY_NODE" ; break ; case DTM . ENTITY_REFERENCE_NODE : typestring = "ENTITY_REFERENCE_NODE" ; break ; case DTM . NAMESPACE_NODE : typestring = "NAMESPACE_NODE" ; break ; case DTM . NOTATION_NODE : typestring = "NOTATION_NODE" ; break ; case DTM . NULL : typestring = "NULL" ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : typestring = "PROCESSING_INSTRUCTION_NODE" ; break ; case DTM . TEXT_NODE : typestring = "TEXT_NODE" ; break ; default : typestring = "Unknown!" ; break ; } ps . println ( "Type: " + typestring ) ; int firstChild = _firstch ( index ) ; if ( DTM . NULL == firstChild ) ps . println ( "First child: DTM.NULL" ) ; else if ( NOTPROCESSED == firstChild ) ps . println ( "First child: NOTPROCESSED" ) ; else ps . println ( "First child: " + firstChild ) ; if ( m_prevsib != null ) { int prevSibling = _prevsib ( index ) ; if ( DTM . NULL == prevSibling ) ps . println ( "Prev sibling: DTM.NULL" ) ; else if ( NOTPROCESSED == prevSibling ) ps . println ( "Prev sibling: NOTPROCESSED" ) ; else ps . println ( "Prev sibling: " + prevSibling ) ; } int nextSibling = _nextsib ( index ) ; if ( DTM . NULL == nextSibling ) ps . println ( "Next sibling: DTM.NULL" ) ; else if ( NOTPROCESSED == nextSibling ) ps . println ( "Next sibling: NOTPROCESSED" ) ; else ps . println ( "Next sibling: " + nextSibling ) ; int parent = _parent ( index ) ; if ( DTM . NULL == parent ) ps . println ( "Parent: DTM.NULL" ) ; else if ( NOTPROCESSED == parent ) ps . println ( "Parent: NOTPROCESSED" ) ; else ps . println ( "Parent: " + parent ) ; int level = _level ( index ) ; ps . println ( "Level: " + level ) ; ps . println ( "Node Value: " + getNodeValue ( i ) ) ; ps . println ( "String Value: " + getStringValue ( i ) ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( System . err ) ; System . exit ( - 1 ) ; } } public String dumpNode ( int nodeHandle ) { if ( nodeHandle == DTM . NULL ) return "[null]" ; String typestring ; switch ( getNodeType ( nodeHandle ) ) { case DTM . ATTRIBUTE_NODE : typestring = "ATTR" ; break ; case DTM . CDATA_SECTION_NODE : typestring = "CDATA" ; break ; case DTM . COMMENT_NODE : typestring = "COMMENT" ; break ; case DTM . DOCUMENT_FRAGMENT_NODE : typestring = "DOC_FRAG" ; break ; case DTM . DOCUMENT_NODE : typestring = "DOC" ; break ; case DTM . DOCUMENT_TYPE_NODE : typestring = "DOC_TYPE" ; break ; case DTM . ELEMENT_NODE : typestring = "ELEMENT" ; break ; case DTM . ENTITY_NODE : typestring = "ENTITY" ; break ; case DTM . ENTITY_REFERENCE_NODE : typestring = "ENT_REF" ; break ; case DTM . NAMESPACE_NODE : typestring = "NAMESPACE" ; break ; case DTM . NOTATION_NODE : typestring = "NOTATION" ; break ; case DTM . NULL : typestring = "null" ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : typestring = "PI" ; break ; case DTM . TEXT_NODE : typestring = "TEXT" ; break ; default : typestring = "Unknown!" ; break ; } StringBuffer sb = new StringBuffer ( ) ; sb . append ( "[" + nodeHandle + ": " + typestring + "(0x" + Integer . toHexString ( getExpandedTypeID ( nodeHandle ) ) + ") " + getNodeNameX ( nodeHandle ) + " {" + getNamespaceURI ( nodeHandle ) + "}" + "=\"" + getNodeValue ( nodeHandle ) + "\"]" ) ; return sb . toString ( ) ; } public void setFeature ( String featureId , boolean state ) { } public boolean hasChildNodes ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int firstChild = _firstch ( identity ) ; return firstChild != DTM . NULL ; } final public int makeNodeHandle ( int nodeIdentity ) { if ( NULL == nodeIdentity ) return NULL ; if ( JJK_DEBUG && nodeIdentity > DTMManager . IDENT_NODE_DEFAULT ) System . err . println ( "GONK! (only useful in limited situations)" ) ; return m_dtmIdent . elementAt ( nodeIdentity > > > DTMManager . IDENT_DTM_NODE_BITS ) + ( nodeIdentity & DTMManager . IDENT_NODE_DEFAULT ) ; } final public int makeNodeIdentity ( int nodeHandle ) { if ( NULL == nodeHandle ) return NULL ; if ( m_mgrDefault != null ) { int whichDTMindex = nodeHandle > > > DTMManager . IDENT_DTM_NODE_BITS ; if ( m_mgrDefault . m_dtms [ whichDTMindex ] != this ) return NULL ; else return m_mgrDefault . m_dtm_offsets [ whichDTMindex ] | ( nodeHandle & DTMManager . IDENT_NODE_DEFAULT ) ; } int whichDTMid = m_dtmIdent . indexOf ( nodeHandle & DTMManager . IDENT_DTM_DEFAULT ) ; return ( whichDTMid == NULL ) ? NULL : ( whichDTMid << DTMManager . IDENT_DTM_NODE_BITS ) + ( nodeHandle & DTMManager . IDENT_NODE_DEFAULT ) ; } public int getFirstChild ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int firstChild = _firstch ( identity ) ; return makeNodeHandle ( firstChild ) ; } public int getTypedFirstChild ( int nodeHandle , int nodeType ) { int firstChild , eType ; if ( nodeType < DTM . NTYPES ) { for ( firstChild = _firstch ( makeNodeIdentity ( nodeHandle ) ) ; firstChild != DTM . NULL ; firstChild = _nextsib ( firstChild ) ) { eType = _exptype ( firstChild ) ; if ( eType == nodeType || ( eType >= DTM . NTYPES && m_expandedNameTable . getType ( eType ) == nodeType ) ) { return makeNodeHandle ( firstChild ) ; } } } else { for ( firstChild = _firstch ( makeNodeIdentity ( nodeHandle ) ) ; firstChild != DTM . NULL ; firstChild = _nextsib ( firstChild ) ) { if ( _exptype ( firstChild ) == nodeType ) { return makeNodeHandle ( firstChild ) ; } } } return DTM . NULL ; } public int getLastChild ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int child = _firstch ( identity ) ; int lastChild = DTM . NULL ; while ( child != DTM . NULL ) { lastChild = child ; child = _nextsib ( child ) ; } return makeNodeHandle ( lastChild ) ; } public abstract int getAttributeNode ( int nodeHandle , String namespaceURI , String name ) ; public int getFirstAttribute ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; return makeNodeHandle ( getFirstAttributeIdentity ( nodeID ) ) ; } protected int getFirstAttributeIdentity ( int identity ) { int type = _type ( identity ) ; if ( DTM . ELEMENT_NODE == type ) { while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { type = _type ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return identity ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } protected int getTypedAttribute ( int nodeHandle , int attType ) { int type = getNodeType ( nodeHandle ) ; if ( DTM . ELEMENT_NODE == type ) { int identity = makeNodeIdentity ( nodeHandle ) ; while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { type = _type ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE ) { if ( _exptype ( identity ) == attType ) return makeNodeHandle ( identity ) ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } public int getNextSibling ( int nodeHandle ) { if ( nodeHandle == DTM . NULL ) return DTM . NULL ; return makeNodeHandle ( _nextsib ( makeNodeIdentity ( nodeHandle ) ) ) ; } public int getTypedNextSibling ( int nodeHandle , int nodeType ) { if ( nodeHandle == DTM . NULL ) return DTM . NULL ; int node = makeNodeIdentity ( nodeHandle ) ; int eType ; while ( ( node = _nextsib ( node ) ) != DTM . NULL && ( ( eType = _exptype ( node ) ) != nodeType && m_expandedNameTable . getType ( eType ) != nodeType ) ) ; return ( node == DTM . NULL ? DTM . NULL : makeNodeHandle ( node ) ) ; } public int getPreviousSibling ( int nodeHandle ) { if ( nodeHandle == DTM . NULL ) return DTM . NULL ; if ( m_prevsib != null ) return makeNodeHandle ( _prevsib ( makeNodeIdentity ( nodeHandle ) ) ) ; else { int nodeID = makeNodeIdentity ( nodeHandle ) ; int parent = _parent ( nodeID ) ; int node = _firstch ( parent ) ; int result = DTM . NULL ; while ( node != nodeID ) { result = node ; node = _nextsib ( node ) ; } return makeNodeHandle ( result ) ; } } public int getNextAttribute ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; if ( _type ( nodeID ) == DTM . ATTRIBUTE_NODE ) { return makeNodeHandle ( getNextAttributeIdentity ( nodeID ) ) ; } return DTM . NULL ; } protected int getNextAttributeIdentity ( int identity ) { while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { int type = _type ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return identity ; } else if ( type != DTM . NAMESPACE_NODE ) { break ; } } return DTM . NULL ; } private Vector m_namespaceLists = null ; protected void declareNamespaceInContext ( int elementNodeIndex , int namespaceNodeIndex ) { SuballocatedIntVector nsList = null ; if ( m_namespaceDeclSets == null ) { m_namespaceDeclSetElements = new SuballocatedIntVector ( 32 ) ; m_namespaceDeclSetElements . addElement ( elementNodeIndex ) ; m_namespaceDeclSets = new Vector ( ) ; nsList = new SuballocatedIntVector ( 32 ) ; m_namespaceDeclSets . addElement ( nsList ) ; } else { int last = m_namespaceDeclSetElements . size ( ) - 1 ; if ( last >= 0 && elementNodeIndex == m_namespaceDeclSetElements . elementAt ( last ) ) { nsList = ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( last ) ; } } if ( nsList == null ) { m_namespaceDeclSetElements . addElement ( elementNodeIndex ) ; SuballocatedIntVector inherited = findNamespaceContext ( _parent ( elementNodeIndex ) ) ; if ( inherited != null ) { int isize = inherited . size ( ) ; nsList = new SuballocatedIntVector ( Math . max ( Math . min ( isize + 16 , 2048 ) , 32 ) ) ; for ( int i = 0 ; i < isize ; ++ i ) { nsList . addElement ( inherited . elementAt ( i ) ) ; } } else { nsList = new SuballocatedIntVector ( 32 ) ; } m_namespaceDeclSets . addElement ( nsList ) ; } int newEType = _exptype ( namespaceNodeIndex ) ; for ( int i = nsList . size ( ) - 1 ; i >= 0 ; -- i ) { if ( newEType == getExpandedTypeID ( nsList . elementAt ( i ) ) ) { nsList . setElementAt ( makeNodeHandle ( namespaceNodeIndex ) , i ) ; return ; } } nsList . addElement ( makeNodeHandle ( namespaceNodeIndex ) ) ; } protected SuballocatedIntVector findNamespaceContext ( int elementNodeIndex ) { if ( null != m_namespaceDeclSetElements ) { int wouldBeAt = findInSortedSuballocatedIntVector ( m_namespaceDeclSetElements , elementNodeIndex ) ; if ( wouldBeAt >= 0 ) return ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( wouldBeAt ) ; if ( wouldBeAt == - 1 ) return null ; wouldBeAt = - 1 - wouldBeAt ; int candidate = m_namespaceDeclSetElements . elementAt ( -- wouldBeAt ) ; int ancestor = _parent ( elementNodeIndex ) ; if ( wouldBeAt == 0 && candidate < ancestor ) { int rootHandle = getDocumentRoot ( makeNodeHandle ( elementNodeIndex ) ) ; int rootID = makeNodeIdentity ( rootHandle ) ; int uppermostNSCandidateID ; if ( getNodeType ( rootHandle ) == DTM . DOCUMENT_NODE ) { int ch = _firstch ( rootID ) ; uppermostNSCandidateID = ( ch != DTM . NULL ) ? ch : rootID ; } else { uppermostNSCandidateID = rootID ; } if ( candidate == uppermostNSCandidateID ) { return ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( wouldBeAt ) ; } } while ( wouldBeAt >= 0 && ancestor > 0 ) { if ( candidate == ancestor ) { return ( SuballocatedIntVector ) m_namespaceDeclSets . elementAt ( wouldBeAt ) ; } else if ( candidate < ancestor ) { do { ancestor = _parent ( ancestor ) ; } while ( candidate < ancestor ) ; } else if ( wouldBeAt > 0 ) { candidate = m_namespaceDeclSetElements . elementAt ( -- wouldBeAt ) ; } else break ; } } return null ; } protected int findInSortedSuballocatedIntVector ( SuballocatedIntVector vector , int lookfor ) { int i = 0 ; if ( vector != null ) { int first = 0 ; int last = vector . size ( ) - 1 ; while ( first <= last ) { i = ( first + last ) / 2 ; int test = lookfor - vector . elementAt ( i ) ; if ( test == 0 ) { return i ; } else if ( test < 0 ) { last = i - 1 ; } else { first = i + 1 ; } } if ( first > i ) { i = first ; } } return - 1 - i ; } public int getFirstNamespaceNode ( int nodeHandle , boolean inScope ) { if ( inScope ) { int identity = makeNodeIdentity ( nodeHandle ) ; if ( _type ( identity ) == DTM . ELEMENT_NODE ) { SuballocatedIntVector nsContext = findNamespaceContext ( identity ) ; if ( nsContext == null || nsContext . size ( ) < 1 ) return NULL ; return nsContext . elementAt ( 0 ) ; } else return NULL ; } else { int identity = makeNodeIdentity ( nodeHandle ) ; if ( _type ( identity ) == DTM . ELEMENT_NODE ) { while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { int type = _type ( identity ) ; if ( type == DTM . NAMESPACE_NODE ) return makeNodeHandle ( identity ) ; else if ( DTM . ATTRIBUTE_NODE != type ) break ; } return NULL ; } else return NULL ; } } public int getNextNamespaceNode ( int baseHandle , int nodeHandle , boolean inScope ) { if ( inScope ) { SuballocatedIntVector nsContext = findNamespaceContext ( makeNodeIdentity ( baseHandle ) ) ; if ( nsContext == null ) return NULL ; int i = 1 + nsContext . indexOf ( nodeHandle ) ; if ( i <= 0 || i == nsContext . size ( ) ) return NULL ; return nsContext . elementAt ( i ) ; } else { int identity = makeNodeIdentity ( nodeHandle ) ; while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { int type = _type ( identity ) ; if ( type == DTM . NAMESPACE_NODE ) { return makeNodeHandle ( identity ) ; } else if ( type != DTM . ATTRIBUTE_NODE ) { break ; } } } return DTM . NULL ; } public int getParent ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity > 0 ) return makeNodeHandle ( _parent ( identity ) ) ; else return DTM . NULL ; } public int getDocument ( ) { return m_dtmIdent . elementAt ( 0 ) ; } public int getOwnerDocument ( int nodeHandle ) { if ( DTM . DOCUMENT_NODE == getNodeType ( nodeHandle ) ) return DTM . NULL ; return getDocumentRoot ( nodeHandle ) ; } public int getDocumentRoot ( int nodeHandle ) { return getDocument ( ) ; } public abstract XMLString getStringValue ( int nodeHandle ) ; public int getStringValueChunkCount ( int nodeHandle ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return 0 ; } public char [ ] getStringValueChunk ( int nodeHandle , int chunkIndex , int [ ] startAndLen ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } public int getExpandedTypeID ( int nodeHandle ) { int id = makeNodeIdentity ( nodeHandle ) ; if ( id == NULL ) return NULL ; return _exptype ( id ) ; } public int getExpandedTypeID ( String namespace , String localName , int type ) { ExpandedNameTable ent = m_expandedNameTable ; return ent . getExpandedTypeID ( namespace , localName , type ) ; } public String getLocalNameFromExpandedNameID ( int expandedNameID ) { return m_expandedNameTable . getLocalName ( expandedNameID ) ; } public String getNamespaceFromExpandedNameID ( int expandedNameID ) { return m_expandedNameTable . getNamespace ( expandedNameID ) ; } public int getNamespaceType ( final int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int expandedNameID = _exptype ( identity ) ; return m_expandedNameTable . getNamespaceID ( expandedNameID ) ; } public abstract String getNodeName ( int nodeHandle ) ; public String getNodeNameX ( int nodeHandle ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } public abstract String getLocalName ( int nodeHandle ) ; public abstract String getPrefix ( int nodeHandle ) ; public abstract String getNamespaceURI ( int nodeHandle ) ; public abstract String getNodeValue ( int nodeHandle ) ; public short getNodeType ( int nodeHandle ) { if ( nodeHandle == DTM . NULL ) return DTM . NULL ; return m_expandedNameTable . getType ( _exptype ( makeNodeIdentity ( nodeHandle ) ) ) ; } public short getLevel ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; return ( short ) ( _level ( identity ) + 1 ) ; } public int getNodeIdent ( int nodeHandle ) { return makeNodeIdentity ( nodeHandle ) ; } public int getNodeHandle ( int nodeId ) { return makeNodeHandle ( nodeId ) ; } public boolean isSupported ( String feature , String version ) { return false ; } public String getDocumentBaseURI ( ) { return m_documentBaseURI ; } public void setDocumentBaseURI ( String baseURI ) { m_documentBaseURI = baseURI ; } public String getDocumentSystemIdentifier ( int nodeHandle ) { return m_documentBaseURI ; } public String getDocumentEncoding ( int nodeHandle ) { return "UTF-8" ; } public String getDocumentStandalone ( int nodeHandle ) { return null ; } public String getDocumentVersion ( int documentHandle ) { return null ; } public boolean getDocumentAllDeclarationsProcessed ( ) { return true ; } public abstract String getDocumentTypeDeclarationSystemIdentifier ( ) ; public abstract String getDocumentTypeDeclarationPublicIdentifier ( ) ; public abstract int getElementById ( String elementId ) ; public abstract String getUnparsedEntityURI ( String name ) ; public boolean supportsPreStripping ( ) { return true ; } public boolean isNodeAfter ( int nodeHandle1 , int nodeHandle2 ) { int index1 = makeNodeIdentity ( nodeHandle1 ) ; int index2 = makeNodeIdentity ( nodeHandle2 ) ; return index1 != NULL & index2 != NULL & index1 <= index2 ; } public boolean isCharacterElementContentWhitespace ( int nodeHandle ) { return false ; } public boolean isDocumentAllDeclarationsProcessed ( int documentHandle ) { return true ; } public abstract boolean isAttributeSpecified ( int attributeHandle ) ; public abstract void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException ; public abstract void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException ; public org . w3c . dom . Node getNode ( int nodeHandle ) { return new DTMNodeProxy ( this , nodeHandle ) ; } public void appendChild ( int newChild , boolean clone , boolean cloneDepth ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; } public void appendTextChild ( String str ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; } protected void error ( String msg ) { throw new DTMException ( msg ) ; } protected boolean getShouldStripWhitespace ( ) { return m_shouldStripWS ; } protected void pushShouldStripWhitespace ( boolean shouldStrip ) { m_shouldStripWS = shouldStrip ; if ( null != m_shouldStripWhitespaceStack ) m_shouldStripWhitespaceStack . push ( shouldStrip ) ; } protected void popShouldStripWhitespace ( ) { if ( null != m_shouldStripWhitespaceStack ) m_shouldStripWS = m_shouldStripWhitespaceStack . popAndTop ( ) ; } protected void setShouldStripWhitespace ( boolean shouldStrip ) { m_shouldStripWS = shouldStrip ; if ( null != m_shouldStripWhitespaceStack ) m_shouldStripWhitespaceStack . setTop ( shouldStrip ) ; } public void documentRegistration ( ) { } public void documentRelease ( ) { } public void migrateTo ( DTMManager mgr ) { m_mgr = mgr ; if ( mgr instanceof DTMManagerDefault ) m_mgrDefault = ( DTMManagerDefault ) mgr ; } public DTMManager getManager ( ) { return m_mgr ; } public SuballocatedIntVector getDTMIDs ( ) { if ( m_mgr == null ) return null ; return m_dtmIdent ; } } 	1	['94', '1', '1', '16', '141', '4141', '4', '13', '68', '0.922341697', '2326', '0.777777778', '14', '0', '0.173835125', '0', '0', '23.45744681', '15', '2.4681', '3']
package org . apache . xml . res ; public class XMLErrorResources_sv extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Funktion inte understödd:" } , { ER_CANNOT_OVERWRITE_CAUSE , "Kan inte skriva över orsak" } , { ER_NO_DEFAULT_IMPL , "Standardimplementering saknas i:" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) understöds för närvarande inte" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Offset större än fack" } , { ER_COROUTINE_NOT_AVAIL , "Sidorutin inte tillgänglig, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager mottog co_exit()-förfrågan" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() misslyckades" } , { ER_COROUTINE_PARAM , "Sidorutin fick parameterfel ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nOVÄNTAT: Parser doTerminate-svar {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "parse får inte anropas medan tolkning sker" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Fel: typad upprepare för axel {0} inte implementerad" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Fel: upprepare för axel {0} inte implementerad" } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Uppreparklon understöds inte" } , { ER_UNKNOWN_AXIS_TYPE , "Okänd axeltraverstyp: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Axeltravers understöds inte: {0}" } , { ER_NO_DTMIDS_AVAIL , "Inga fler DTM-IDs är tillgängliga" } , { ER_NOT_SUPPORTED , "Understöds inte: {0}" } , { ER_NODE_NON_NULL , "Nod måste vara icke-null för getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "Kunde inte lösa nod till ett handtag" } , { ER_STARTPARSE_WHILE_PARSING , "startParse får inte anropas medan tolkning sker" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse behöver en SAXParser som är icke-null" } , { ER_COULD_NOT_INIT_PARSER , "kunde inte initialisera tolk med" } , { ER_EXCEPTION_CREATING_POOL , "undantag skapar ny instans för pool" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Väg innehåller ogiltig flyktsekvens" } , { ER_SCHEME_REQUIRED , "Schema krävs!" } , { ER_NO_SCHEME_IN_URI , "Schema saknas i URI: {0}" } , { ER_NO_SCHEME_INURI , "Schema saknas i URI" } , { ER_PATH_INVALID_CHAR , "Väg innehåller ogiltigt tecken: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Kan inte sätta schema från null-sträng" } , { ER_SCHEME_NOT_CONFORMANT , "Schemat är inte likformigt." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Värd är inte en välformulerad adress" } , { ER_PORT_WHEN_HOST_NULL , "Port kan inte sättas när värd är null" } , { ER_INVALID_PORT , "Ogiltigt portnummer" } , { ER_FRAG_FOR_GENERIC_URI , "Fragment kan bara sättas för en allmän URI" } , { ER_FRAG_WHEN_PATH_NULL , "Fragment kan inte sättas när väg är null" } , { ER_FRAG_INVALID_CHAR , "Fragment innehåller ogiltigt tecken" } , { ER_PARSER_IN_USE , "Tolk används redan" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Kan inte ändra {0} {1} medan tolkning sker" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Självorsakande inte tillåten" } , { ER_NO_USERINFO_IF_NO_HOST , "Userinfo får inte anges om värden inte är angiven" } , { ER_NO_PORT_IF_NO_HOST , "Port får inte anges om värden inte är angiven" } , { ER_NO_QUERY_STRING_IN_PATH , "Förfrågan-sträng kan inte anges i väg och förfrågan-sträng" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Fragment kan inte anges i både vägen och fragmentet" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Kan inte initialisera URI med tomma parametrar" } , { ER_METHOD_NOT_SUPPORTED , "Metod ännu inte understödd " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter kan för närvarande inte startas om" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader inte innan startParse-begäran" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Det går inte att vända axeln: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler skapad med null PrintWriter!" } , { ER_SYSTEMID_UNKNOWN , "SystemId okänt" } , { ER_LOCATION_UNKNOWN , "Platsen för felet är okänd" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() understöds inte av XPathContext!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Attributbarn saknar ägardokument!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Attributbarn saknar ägardokumentelement!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Varning: kan inte skriva ut text innan dokumentelement!  Ignorerar..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Kan inte ha mer än en rot på en DOM!" } , { ER_ARG_LOCALNAME_NULL , "Argument 'localName' är null" } , { ER_ARG_LOCALNAME_INVALID , "Localname i QNAME bör vara ett giltigt NCName" } , { ER_ARG_PREFIX_INVALID , "Prefixet i QNAME bör vara ett giltigt NCName" } , { "BAD_CODE" , "Parameter till createMessage ligger utanför tillåtet intervall" } , { "FORMAT_FAILED" , "Undantag utlöst vid messageFormat-anrop" } , { "line" , "Rad #" } , { "column" , "Kolumn #" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.3', '875', '0', '0', '0.976190476', '1', '0', '0', '289', '1', '0.3333', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_zh_TW extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "函數不受支援！" } , { ER_CANNOT_OVERWRITE_CAUSE , "無法改寫原因" } , { ER_NO_DEFAULT_IMPL , "找不到預設實作" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) 目前不受支援" } , { ER_OFFSET_BIGGER_THAN_SLOT , "偏移比槽大" } , { ER_COROUTINE_NOT_AVAIL , "沒有 Coroutine 可用，id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager 收到 co_exit() 要求" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() 失效" } , { ER_COROUTINE_PARAM , "Coroutine 參數錯誤 ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\n非預期的結果：剖析器 doTerminate 回答 {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "在剖析時未呼叫 parse" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "錯誤：針對軸 {0} 輸入的重複項目沒有實作" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "錯誤：軸 {0} 的重複項目沒有實作" } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "重複項目複製不受支援" } , { ER_UNKNOWN_AXIS_TYPE , "不明的軸遍歷類型：{0}" } , { ER_AXIS_NOT_SUPPORTED , "不支援軸遍歷：{0}" } , { ER_NO_DTMIDS_AVAIL , "沒有可用的 DTM ID" } , { ER_NOT_SUPPORTED , "不支援：{0}" } , { ER_NODE_NON_NULL , "對 getDTMHandleFromNode 而言，節點必須為非空值" } , { ER_COULD_NOT_RESOLVE_NODE , "無法解析節點為控點" } , { ER_STARTPARSE_WHILE_PARSING , "在剖析時未呼叫 startParse" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse 需要非空值的 SAXParser" } , { ER_COULD_NOT_INIT_PARSER , "無法使用以下項目起始設定剖析器" } , { ER_EXCEPTION_CREATING_POOL , "建立儲存池的新實例時發生異常" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "路徑包含無效的跳脫字元" } , { ER_SCHEME_REQUIRED , "綱要是必需的！" } , { ER_NO_SCHEME_IN_URI , "在 URI：{0} 找不到綱要" } , { ER_NO_SCHEME_INURI , "在 URI 找不到綱要" } , { ER_PATH_INVALID_CHAR , "路徑包含無效的字元：{0}" } , { ER_SCHEME_FROM_NULL_STRING , "無法從空字串設定綱要" } , { ER_SCHEME_NOT_CONFORMANT , "綱要不是 conformant。" } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "主機沒有完整的位址" } , { ER_PORT_WHEN_HOST_NULL , "主機為空值時，無法設定埠" } , { ER_INVALID_PORT , "無效的埠編號" } , { ER_FRAG_FOR_GENERIC_URI , "只能對通用的 URI 設定片段" } , { ER_FRAG_WHEN_PATH_NULL , "路徑為空值時，無法設定片段" } , { ER_FRAG_INVALID_CHAR , "片段包含無效的字元" } , { ER_PARSER_IN_USE , "剖析器已在使用中" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "剖析時無法變更 {0} {1}" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "不允許本身的因果關係" } , { ER_NO_USERINFO_IF_NO_HOST , "如果沒有指定主機，不可指定 Userinfo" } , { ER_NO_PORT_IF_NO_HOST , "如果沒有指定主機，不可指定埠" } , { ER_NO_QUERY_STRING_IN_PATH , "在路徑及查詢字串中不可指定查詢字串" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "片段無法同時在路徑和片段中指定" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "無法以空白參數起始設定 URI" } , { ER_METHOD_NOT_SUPPORTED , "方法不受支援" } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter 目前無法重新啟動" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader 沒有在 startParse 要求之前" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "不支援軸遍歷：{0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "以空值 PrintWriter 建立的 ListingErrorHandler！" } , { ER_SYSTEMID_UNKNOWN , "不明的 SystemId" } , { ER_LOCATION_UNKNOWN , "錯誤位置不明" } , { ER_PREFIX_MUST_RESOLVE , "字首必須解析為名稱空間：{0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "在 XPathContext 中不支援 createDocument()" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "屬性子項元件沒有擁有者文件！" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "屬性子項元件沒有擁有者文件元素！" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "警告：不能輸出文件元素之前的文字！忽略..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "一個 DOM 只能有一個根目錄！" } , { ER_ARG_LOCALNAME_NULL , "引數 'localName' 為空值" } , { ER_ARG_LOCALNAME_INVALID , "QNAME 中的本端名稱應該是有效的 NCName" } , { ER_ARG_PREFIX_INVALID , "QNAME 中的字首應該是有效的 NCName" } , { "BAD_CODE" , "createMessage 的參數超出界限" } , { "FORMAT_FAILED" , "在 messageFormat 呼叫期間擲出異常" } , { "line" , "行號" } , { "column" , "欄號" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "serializer 類別 ''{0}'' 不實作 org.xml.sax.ContentHandler。" } , { ER_RESOURCE_COULD_NOT_FIND , "找不到資源 [ {0} ]。\n{1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "無法載入資源 [ {0} ]：{1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "緩衝區大小 <=0" } , { ER_INVALID_UTF16_SURROGATE , "偵測到無效的 UTF-16 代理：{0}?" } , { ER_OIERROR , "IO 錯誤" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "在產生子項節點之後，或在產生元素之前，不可新增屬性 {0}。屬性會被忽略。" } , { ER_NAMESPACE_PREFIX , "字首 ''{0}'' 的名稱空間尚未宣告。" } , { ER_STRAY_ATTRIBUTE , "屬性 ''{0}'' 超出元素外。" } , { ER_STRAY_NAMESPACE , "名稱空間宣告 ''{0}''=''{1}'' 超出元素外。" } , { ER_COULD_NOT_LOAD_RESOURCE , "無法載入 ''{0}''（檢查 CLASSPATH），目前只使用預設值" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "無法載入輸出方法 ''{1}'' 的內容檔 ''{0}''（檢查 CLASSPATH）" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "zh" , "TW" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . utils . XMLChar ; final class ProcessingInstruction extends Instruction { private AttributeValue _name ; private boolean _isLiteral = false ; public void parseContents ( Parser parser ) { final String name = getAttribute ( "name" ) ; if ( name . length ( ) > 0 ) { _isLiteral = Util . isLiteral ( name ) ; if ( _isLiteral ) { if ( ! XMLChar . isValidNCName ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_NCNAME_ERR , name , this ) ; parser . reportError ( Constants . ERROR , err ) ; } } _name = AttributeValue . create ( this , name , parser ) ; } else reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "name" ) ; if ( name . equals ( "xml" ) ) { reportError ( this , parser , ErrorMsg . ILLEGAL_PI_ERR , "xml" ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _name . typeCheck ( stable ) ; typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( ! _isLiteral ) { LocalVariableGen nameValue = methodGen . addLocalVariable2 ( "nameValue" , Util . getJCRefType ( STRING_SIG ) , il . getEnd ( ) ) ; _name . translate ( classGen , methodGen ) ; il . append ( new ASTORE ( nameValue . getIndex ( ) ) ) ; il . append ( new ALOAD ( nameValue . getIndex ( ) ) ) ; final int check = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "checkNCName" , "(" + STRING_SIG + ")V" ) ; il . append ( new INVOKESTATIC ( check ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( DUP ) ; il . append ( new ALOAD ( nameValue . getIndex ( ) ) ) ; } else { il . append ( methodGen . loadHandler ( ) ) ; il . append ( DUP ) ; _name . translate ( classGen , methodGen ) ; } il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , "stringValueHandler" , STRING_VALUE_HANDLER_SIG ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeHandler ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_VALUE_HANDLER , "getValueOfPI" , "()" + STRING_SIG ) ) ) ; final int processingInstruction = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "processingInstruction" , "(" + STRING_SIG + STRING_SIG + ")V" ) ; il . append ( new INVOKEINTERFACE ( processingInstruction , 3 ) ) ; il . append ( methodGen . storeHandler ( ) ) ; } } 	1	['4', '3', '0', '26', '38', '0', '1', '25', '3', '0.333333333', '221', '1', '1', '0.949152542', '0.4', '2', '6', '53.75', '5', '2', '1']
package org . apache . xalan . lib . sql ; import java . util . Vector ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xpath . XPathContext ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTM ; import java . sql . Connection ; import java . sql . Statement ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; import java . sql . SQLException ; import java . sql . * ; import org . apache . xml . dtm . ref . * ; public class SQLDocument extends DTMDocument { private boolean DEBUG = false ; private static final String S_NAMESPACE = "http://xml.apache.org/xalan/SQLExtension" ; private static final String S_SQL = "sql" ; private static final String S_ROW_SET = "row-set" ; private static final String S_METADATA = "metadata" ; private static final String S_COLUMN_HEADER = "column-header" ; private static final String S_ROW = "row" ; private static final String S_COL = "col" ; private static final String S_OUT_PARAMETERS = "out-parameters" ; private static final String S_CATALOGUE_NAME = "catalogue-name" ; private static final String S_DISPLAY_SIZE = "column-display-size" ; private static final String S_COLUMN_LABEL = "column-label" ; private static final String S_COLUMN_NAME = "column-name" ; private static final String S_COLUMN_TYPE = "column-type" ; private static final String S_COLUMN_TYPENAME = "column-typename" ; private static final String S_PRECISION = "precision" ; private static final String S_SCALE = "scale" ; private static final String S_SCHEMA_NAME = "schema-name" ; private static final String S_TABLE_NAME = "table-name" ; private static final String S_CASESENSITIVE = "case-sensitive" ; private static final String S_DEFINITELYWRITABLE = "definitely-writable" ; private static final String S_ISNULLABLE = "nullable" ; private static final String S_ISSIGNED = "signed" ; private static final String S_ISWRITEABLE = "writable" ; private static final String S_ISSEARCHABLE = "searchable" ; private int m_SQL_TypeID = 0 ; private int m_MetaData_TypeID = 0 ; private int m_ColumnHeader_TypeID = 0 ; private int m_RowSet_TypeID = 0 ; private int m_Row_TypeID = 0 ; private int m_Col_TypeID = 0 ; private int m_OutParameter_TypeID = 0 ; private int m_ColAttrib_CATALOGUE_NAME_TypeID = 0 ; private int m_ColAttrib_DISPLAY_SIZE_TypeID = 0 ; private int m_ColAttrib_COLUMN_LABEL_TypeID = 0 ; private int m_ColAttrib_COLUMN_NAME_TypeID = 0 ; private int m_ColAttrib_COLUMN_TYPE_TypeID = 0 ; private int m_ColAttrib_COLUMN_TYPENAME_TypeID = 0 ; private int m_ColAttrib_PRECISION_TypeID = 0 ; private int m_ColAttrib_SCALE_TypeID = 0 ; private int m_ColAttrib_SCHEMA_NAME_TypeID = 0 ; private int m_ColAttrib_TABLE_NAME_TypeID = 0 ; private int m_ColAttrib_CASESENSITIVE_TypeID = 0 ; private int m_ColAttrib_DEFINITELYWRITEABLE_TypeID = 0 ; private int m_ColAttrib_ISNULLABLE_TypeID = 0 ; private int m_ColAttrib_ISSIGNED_TypeID = 0 ; private int m_ColAttrib_ISWRITEABLE_TypeID = 0 ; private int m_ColAttrib_ISSEARCHABLE_TypeID = 0 ; private Statement m_Statement = null ; private ExpressionContext m_ExpressionContext = null ; private ConnectionPool m_ConnectionPool = null ; private ResultSet m_ResultSet = null ; private SQLQueryParser m_QueryParser = null ; private int [ ] m_ColHeadersIdx ; private int m_ColCount ; private int m_MetaDataIdx = DTM . NULL ; private int m_RowSetIdx = DTM . NULL ; private int m_SQLIdx = DTM . NULL ; private int m_FirstRowIdx = DTM . NULL ; private int m_LastRowIdx = DTM . NULL ; private boolean m_StreamingMode = true ; private boolean m_MultipleResults = false ; private boolean m_HasErrors = false ; private boolean m_IsStatementCachingEnabled = false ; private XConnection m_XConnection = null ; public SQLDocument ( DTMManager mgr , int ident ) { super ( mgr , ident ) ; } public static SQLDocument getNewDocument ( ExpressionContext exprContext ) { DTMManager mgr = ( ( XPathContext . XPathExpressionContext ) exprContext ) . getDTMManager ( ) ; DTMManagerDefault mgrDefault = ( DTMManagerDefault ) mgr ; int dtmIdent = mgrDefault . getFirstFreeDTMID ( ) ; SQLDocument doc = new SQLDocument ( mgr , dtmIdent << DTMManager . IDENT_DTM_NODE_BITS ) ; mgrDefault . addDTM ( doc , dtmIdent ) ; doc . setExpressionContext ( exprContext ) ; return doc ; } protected void setExpressionContext ( ExpressionContext expr ) { m_ExpressionContext = expr ; } public ExpressionContext getExpressionContext ( ) { return m_ExpressionContext ; } public void execute ( XConnection xconn , SQLQueryParser query ) throws SQLException { try { m_StreamingMode = "true" . equals ( xconn . getFeature ( "streaming" ) ) ; m_MultipleResults = "true" . equals ( xconn . getFeature ( "multiple-results" ) ) ; m_IsStatementCachingEnabled = "true" . equals ( xconn . getFeature ( "cache-statements" ) ) ; m_XConnection = xconn ; m_QueryParser = query ; executeSQLStatement ( ) ; createExpandedNameTable ( ) ; m_DocumentIdx = addElement ( 0 , m_Document_TypeID , DTM . NULL , DTM . NULL ) ; m_SQLIdx = addElement ( 1 , m_SQL_TypeID , m_DocumentIdx , DTM . NULL ) ; if ( ! m_MultipleResults ) extractSQLMetaData ( m_ResultSet . getMetaData ( ) ) ; addRowToDTMFromResultSet ( ) ; } catch ( SQLException e ) { m_HasErrors = true ; throw e ; } } private void executeSQLStatement ( ) throws SQLException { m_ConnectionPool = m_XConnection . getConnectionPool ( ) ; Connection conn = m_ConnectionPool . getConnection ( ) ; if ( ! m_QueryParser . hasParameters ( ) ) { m_Statement = conn . createStatement ( ) ; if ( ! m_Statement . execute ( m_QueryParser . getSQLQuery ( ) ) ) { throw new SQLException ( "Error in Query" ) ; } } else if ( m_QueryParser . isCallable ( ) ) { CallableStatement cstmt = conn . prepareCall ( m_QueryParser . getSQLQuery ( ) ) ; m_QueryParser . registerOutputParameters ( cstmt ) ; m_QueryParser . populateStatement ( cstmt , m_ExpressionContext ) ; m_Statement = cstmt ; if ( ! cstmt . execute ( ) ) throw new SQLException ( "Error in Callable Statement" ) ; } else { PreparedStatement stmt = conn . prepareStatement ( m_QueryParser . getSQLQuery ( ) ) ; m_QueryParser . populateStatement ( stmt , m_ExpressionContext ) ; m_Statement = stmt ; if ( ! stmt . execute ( ) ) throw new SQLException ( "Error in Prepared Statement" ) ; } m_ResultSet = m_Statement . getResultSet ( ) ; } private void extractSQLMetaData ( ResultSetMetaData meta ) { m_MetaDataIdx = addElement ( 1 , m_MetaData_TypeID , m_MultipleResults ? m_RowSetIdx : m_SQLIdx , DTM . NULL ) ; try { m_ColCount = meta . getColumnCount ( ) ; m_ColHeadersIdx = new int [ m_ColCount ] ; } catch ( Exception e ) { m_XConnection . setError ( e , this , checkWarnings ( ) ) ; } int lastColHeaderIdx = DTM . NULL ; int i = 1 ; for ( i = 1 ; i <= m_ColCount ; i ++ ) { m_ColHeadersIdx [ i - 1 ] = addElement ( 2 , m_ColumnHeader_TypeID , m_MetaDataIdx , lastColHeaderIdx ) ; lastColHeaderIdx = m_ColHeadersIdx [ i - 1 ] ; try { addAttributeToNode ( meta . getColumnName ( i ) , m_ColAttrib_COLUMN_NAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_COLUMN_NAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getColumnLabel ( i ) , m_ColAttrib_COLUMN_LABEL_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_COLUMN_LABEL_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getCatalogName ( i ) , m_ColAttrib_CATALOGUE_NAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_CATALOGUE_NAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( new Integer ( meta . getColumnDisplaySize ( i ) ) , m_ColAttrib_DISPLAY_SIZE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_DISPLAY_SIZE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( new Integer ( meta . getColumnType ( i ) ) , m_ColAttrib_COLUMN_TYPE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_COLUMN_TYPE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getColumnTypeName ( i ) , m_ColAttrib_COLUMN_TYPENAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_COLUMN_TYPENAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( new Integer ( meta . getPrecision ( i ) ) , m_ColAttrib_PRECISION_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_PRECISION_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( new Integer ( meta . getScale ( i ) ) , m_ColAttrib_SCALE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_SCALE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getSchemaName ( i ) , m_ColAttrib_SCHEMA_NAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_SCHEMA_NAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . getTableName ( i ) , m_ColAttrib_TABLE_NAME_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_TABLE_NAME_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isCaseSensitive ( i ) ? S_ISTRUE : S_ISFALSE , m_ColAttrib_CASESENSITIVE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_CASESENSITIVE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isDefinitelyWritable ( i ) ? S_ISTRUE : S_ISFALSE , m_ColAttrib_DEFINITELYWRITEABLE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_DEFINITELYWRITEABLE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isNullable ( i ) != 0 ? S_ISTRUE : S_ISFALSE , m_ColAttrib_ISNULLABLE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_ISNULLABLE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isSigned ( i ) ? S_ISTRUE : S_ISFALSE , m_ColAttrib_ISSIGNED_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_ISSIGNED_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isWritable ( i ) == true ? S_ISTRUE : S_ISFALSE , m_ColAttrib_ISWRITEABLE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_ISWRITEABLE_TypeID , lastColHeaderIdx ) ; } try { addAttributeToNode ( meta . isSearchable ( i ) == true ? S_ISTRUE : S_ISFALSE , m_ColAttrib_ISSEARCHABLE_TypeID , lastColHeaderIdx ) ; } catch ( Exception e ) { addAttributeToNode ( S_ATTRIB_NOT_SUPPORTED , m_ColAttrib_ISSEARCHABLE_TypeID , lastColHeaderIdx ) ; } } } protected void createExpandedNameTable ( ) { super . createExpandedNameTable ( ) ; m_SQL_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SQL , DTM . ELEMENT_NODE ) ; m_MetaData_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_METADATA , DTM . ELEMENT_NODE ) ; m_ColumnHeader_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_HEADER , DTM . ELEMENT_NODE ) ; m_RowSet_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ROW_SET , DTM . ELEMENT_NODE ) ; m_Row_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ROW , DTM . ELEMENT_NODE ) ; m_Col_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COL , DTM . ELEMENT_NODE ) ; m_OutParameter_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_OUT_PARAMETERS , DTM . ELEMENT_NODE ) ; m_ColAttrib_CATALOGUE_NAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_CATALOGUE_NAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_DISPLAY_SIZE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_DISPLAY_SIZE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_COLUMN_LABEL_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_LABEL , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_COLUMN_NAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_NAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_COLUMN_TYPE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_TYPE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_COLUMN_TYPENAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_COLUMN_TYPENAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_PRECISION_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_PRECISION , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_SCALE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SCALE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_SCHEMA_NAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SCHEMA_NAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_TABLE_NAME_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_TABLE_NAME , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_CASESENSITIVE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_CASESENSITIVE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_DEFINITELYWRITEABLE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_DEFINITELYWRITABLE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_ISNULLABLE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ISNULLABLE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_ISSIGNED_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ISSIGNED , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_ISWRITEABLE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ISWRITEABLE , DTM . ATTRIBUTE_NODE ) ; m_ColAttrib_ISSEARCHABLE_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_ISSEARCHABLE , DTM . ATTRIBUTE_NODE ) ; } private boolean addRowToDTMFromResultSet ( ) { try { if ( m_FirstRowIdx == DTM . NULL ) { m_RowSetIdx = addElement ( 1 , m_RowSet_TypeID , m_SQLIdx , m_MultipleResults ? m_RowSetIdx : m_MetaDataIdx ) ; if ( m_MultipleResults ) extractSQLMetaData ( m_ResultSet . getMetaData ( ) ) ; } if ( ! m_ResultSet . next ( ) ) { if ( m_StreamingMode && ( m_LastRowIdx != DTM . NULL ) ) { m_nextsib . setElementAt ( DTM . NULL , m_LastRowIdx ) ; } m_ResultSet . close ( ) ; if ( m_MultipleResults ) { while ( ! m_Statement . getMoreResults ( ) && m_Statement . getUpdateCount ( ) >= 0 ) ; m_ResultSet = m_Statement . getResultSet ( ) ; } else m_ResultSet = null ; if ( m_ResultSet != null ) { m_FirstRowIdx = DTM . NULL ; addRowToDTMFromResultSet ( ) ; } else { Vector parameters = m_QueryParser . getParameters ( ) ; if ( parameters != null ) { int outParamIdx = addElement ( 1 , m_OutParameter_TypeID , m_SQLIdx , m_RowSetIdx ) ; int lastColID = DTM . NULL ; for ( int indx = 0 ; indx < parameters . size ( ) ; indx ++ ) { QueryParameter parm = ( QueryParameter ) parameters . elementAt ( indx ) ; if ( parm . isOutput ( ) ) { Object rawobj = ( ( CallableStatement ) m_Statement ) . getObject ( indx + 1 ) ; lastColID = addElementWithData ( rawobj , 2 , m_Col_TypeID , outParamIdx , lastColID ) ; addAttributeToNode ( parm . getName ( ) , m_ColAttrib_COLUMN_NAME_TypeID , lastColID ) ; addAttributeToNode ( parm . getName ( ) , m_ColAttrib_COLUMN_LABEL_TypeID , lastColID ) ; addAttributeToNode ( new Integer ( parm . getType ( ) ) , m_ColAttrib_COLUMN_TYPE_TypeID , lastColID ) ; addAttributeToNode ( parm . getTypeName ( ) , m_ColAttrib_COLUMN_TYPENAME_TypeID , lastColID ) ; } } } SQLWarning warn = checkWarnings ( ) ; if ( warn != null ) m_XConnection . setError ( null , null , warn ) ; } return false ; } if ( m_FirstRowIdx == DTM . NULL ) { m_FirstRowIdx = addElement ( 2 , m_Row_TypeID , m_RowSetIdx , m_MultipleResults ? m_MetaDataIdx : DTM . NULL ) ; m_LastRowIdx = m_FirstRowIdx ; if ( m_StreamingMode ) { m_nextsib . setElementAt ( m_LastRowIdx , m_LastRowIdx ) ; } } else { if ( ! m_StreamingMode ) { m_LastRowIdx = addElement ( 2 , m_Row_TypeID , m_RowSetIdx , m_LastRowIdx ) ; } } int colID = _firstch ( m_LastRowIdx ) ; int pcolID = DTM . NULL ; for ( int i = 1 ; i <= m_ColCount ; i ++ ) { Object o = m_ResultSet . getObject ( i ) ; if ( colID == DTM . NULL ) { pcolID = addElementWithData ( o , 3 , m_Col_TypeID , m_LastRowIdx , pcolID ) ; cloneAttributeFromNode ( pcolID , m_ColHeadersIdx [ i - 1 ] ) ; } else { int dataIdent = _firstch ( colID ) ; if ( dataIdent == DTM . NULL ) { error ( "Streaming Mode, Data Error" ) ; } else { m_ObjectArray . setAt ( dataIdent , o ) ; } } if ( colID != DTM . NULL ) { colID = _nextsib ( colID ) ; } } } catch ( Exception e ) { if ( DEBUG ) { System . out . println ( "SQL Error Fetching next row [" + e . getLocalizedMessage ( ) + "]" ) ; } m_XConnection . setError ( e , this , checkWarnings ( ) ) ; m_HasErrors = true ; } return true ; } public boolean hasErrors ( ) { return m_HasErrors ; } public void close ( ) { try { SQLWarning warn = checkWarnings ( ) ; if ( warn != null ) m_XConnection . setError ( null , null , warn ) ; } catch ( Exception e ) { } try { if ( null != m_ResultSet ) { m_ResultSet . close ( ) ; m_ResultSet = null ; } } catch ( Exception e ) { } Connection conn = null ; try { if ( null != m_Statement ) { conn = m_Statement . getConnection ( ) ; m_Statement . close ( ) ; m_Statement = null ; } } catch ( Exception e ) { } try { if ( conn != null ) { if ( m_HasErrors ) m_ConnectionPool . releaseConnectionOnError ( conn ) ; else m_ConnectionPool . releaseConnection ( conn ) ; } } catch ( Exception e ) { } getManager ( ) . release ( this , true ) ; } protected boolean nextNode ( ) { if ( DEBUG ) System . out . println ( "nextNode()" ) ; try { return false ; } catch ( Exception e ) { return false ; } } protected int _nextsib ( int identity ) { if ( m_ResultSet != null ) { int id = _exptype ( identity ) ; if ( ( id == m_Row_TypeID ) && ( identity >= m_LastRowIdx ) ) { if ( DEBUG ) System . out . println ( "reading from the ResultSet" ) ; addRowToDTMFromResultSet ( ) ; } else if ( m_MultipleResults && identity == m_RowSetIdx ) { if ( DEBUG ) System . out . println ( "reading for next ResultSet" ) ; int startIdx = m_RowSetIdx ; while ( startIdx == m_RowSetIdx && m_ResultSet != null ) addRowToDTMFromResultSet ( ) ; } } return super . _nextsib ( identity ) ; } public void documentRegistration ( ) { if ( DEBUG ) System . out . println ( "Document Registration" ) ; } public void documentRelease ( ) { if ( DEBUG ) System . out . println ( "Document Release" ) ; } public SQLWarning checkWarnings ( ) { SQLWarning warn = null ; if ( m_Statement != null ) { try { warn = m_Statement . getWarnings ( ) ; m_Statement . clearWarnings ( ) ; } catch ( SQLException se ) { } } return ( warn ) ; } } 	1	['16', '5', '0', '13', '95', '18', '1', '13', '9', '0.8', '1467', '1', '4', '0.926470588', '0.205357143', '2', '8', '86.625', '23', '3.6875', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_tr extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "İşlev desteklenmiyor!" } , { ER_CANNOT_OVERWRITE_CAUSE , "Nedenin üzerine yazılamaz" } , { ER_NO_DEFAULT_IMPL , "Varsayılan uygulama bulunamadı" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) şu an desteklenmiyor" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Göreli konum yuvadan büyük" } , { ER_COROUTINE_NOT_AVAIL , "Coroutine kullanılamıyor, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager co_exit() isteği aldı" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() başarısız oldu" } , { ER_COROUTINE_PARAM , "Coroutine değiştirgesi hatası ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nBEKLENMEYEN: Parser doTerminate yanıtı {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "Ayrıştırma sırasında parse çağrılamaz" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Hata: {0} ekseni için tip atanmış yineleyici gerçekleştirilmedi" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Hata: {0} ekseni için yineleyici gerçekleştirilmedi" } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Yineleyici eşkopyası desteklenmiyor" } , { ER_UNKNOWN_AXIS_TYPE , "Bilinmeyen eksen dolaşma tipi: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Eksen dolaşıcı desteklenmiyor: {0}" } , { ER_NO_DTMIDS_AVAIL , "Kullanılabilecek başka DTM tanıtıcısı yok" } , { ER_NOT_SUPPORTED , "Desteklenmiyor: {0}" } , { ER_NODE_NON_NULL , "getDTMHandleFromNode için düğüm boş değerli olmamalıdır" } , { ER_COULD_NOT_RESOLVE_NODE , "Düğüm tanıtıcı değere çözülemedi" } , { ER_STARTPARSE_WHILE_PARSING , "Ayrıştırma sırasında startParse çağrılamaz" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse için boş değerli olmayan SAXParser gerekiyor" } , { ER_COULD_NOT_INIT_PARSER , "Ayrıştırıcı bununla kullanıma hazırlanamadı" } , { ER_EXCEPTION_CREATING_POOL , "Havuz için yeni örnek yaratılırken kural dışı durum" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Yol geçersiz kaçış dizisi içeriyor" } , { ER_SCHEME_REQUIRED , "Şema gerekli!" } , { ER_NO_SCHEME_IN_URI , "URI içinde şema bulunamadı: {0}" } , { ER_NO_SCHEME_INURI , "URI içinde şema bulunamadı" } , { ER_PATH_INVALID_CHAR , "Yol geçersiz karakter içeriyor: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Boş değerli dizgiden şema tanımlanamaz" } , { ER_SCHEME_NOT_CONFORMANT , "Şema uyumlu değil." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Anasistem doğru biçimli bir adres değil" } , { ER_PORT_WHEN_HOST_NULL , "Anasistem boş değerliyken kapı tanımlanamaz" } , { ER_INVALID_PORT , "Kapı numarası geçersiz" } , { ER_FRAG_FOR_GENERIC_URI , "Parça yalnızca soysal URI için tanımlanabilir" } , { ER_FRAG_WHEN_PATH_NULL , "Yol boş değerliyken parça tanımlanamaz" } , { ER_FRAG_INVALID_CHAR , "Parça geçersiz karakter içeriyor" } , { ER_PARSER_IN_USE , "Ayrıştırıcı kullanımda" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Ayrıştırma sırasında {0} {1} değiştirilemez" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Öznedenselliğe izin verilmez" } , { ER_NO_USERINFO_IF_NO_HOST , "Anasistem belirtilmediyse kullanıcı bilgisi belirtilemez" } , { ER_NO_PORT_IF_NO_HOST , "Anasistem belirtilmediyse kapı belirtilemez" } , { ER_NO_QUERY_STRING_IN_PATH , "Yol ve sorgu dizgisinde sorgu dizgisi belirtilemez" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Parça hem yolda, hem de parçada belirtilemez" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Boş değiştirgelerle URI kullanıma hazırlanamaz" } , { ER_METHOD_NOT_SUPPORTED , "Yöntem henüz desteklenmiyor" } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter şu an yeniden başlatılabilir durumda değil" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader, startParse isteğinden önce olmaz" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Eksen dolaşıcı desteklenmiyor: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler boş değerli PrintWriter ile yaratıldı!" } , { ER_SYSTEMID_UNKNOWN , "SystemId bilinmiyor" } , { ER_LOCATION_UNKNOWN , "Hata yeri bilinmiyor" } , { ER_PREFIX_MUST_RESOLVE , "Önek bir ad alanına çözülmelidir: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "XPathContext içinde createDocument() desteklenmiyor!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Özniteliğin alt öğesinin iye belgesi yok!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Özniteliğin alt öğesinin iye belge öğesi yok!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Uyarı: Belge öğesinden önce metin çıkışı olamaz!  Yoksayılıyor..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "DOM üzerinde birden fazla kök olamaz!" } , { ER_ARG_LOCALNAME_NULL , "'localName' bağımsız değiştirgesi boş değerli" } , { ER_ARG_LOCALNAME_INVALID , "QNAME içindeki yerel ad (localname) geçerli bir NCName olmalıdır" } , { ER_ARG_PREFIX_INVALID , "QNAME içindeki önek geçerli bir NCName olmalıdır" } , { "BAD_CODE" , "createMessage için kullanılan değiştirge sınırların dışında" } , { "FORMAT_FAILED" , "messageFormat çağrısı sırasında kural dışı durum yayınlandı" } , { "line" , "Satır #" } , { "column" , "Kolon #" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "Diziselleştirici sınıfı ''{0}'' org.xml.sax.ContentHandler işlevini uygulamıyor." } , { ER_RESOURCE_COULD_NOT_FIND , "Kaynak [ {0} ] bulunamadı.\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "Kaynak [ {0} ] yükleyemedi: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Arabellek büyüklüğü <=0" } , { ER_INVALID_UTF16_SURROGATE , "UTF-16 yerine kullanılan değer geçersiz: {0} ?" } , { ER_OIERROR , "GÇ hatası" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Alt düğümlerden sonra ya da bir öğe üretilmeden önce {0} özniteliği eklenemez. Öznitelik yoksayılacak." } , { ER_NAMESPACE_PREFIX , "''{0}'' önekine ilişkin ad alanı bildirilmedi." } , { ER_STRAY_ATTRIBUTE , "''{0}'' özniteliği öğenin dışında." } , { ER_STRAY_NAMESPACE , "''{0}''=''{1}'' ad alanı bildirimi öğenin dışında." } , { ER_COULD_NOT_LOAD_RESOURCE , "''{0}'' yüklenemedi (CLASSPATH değişkeninizi inceleyin), yalnızca varsayılanlar kullanılıyor" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "''{1}'' çıkış yöntemi için ''{0}'' özellik dosyası yüklenemedi (CLASSPATH değişkenini inceleyin)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "tr" , "TR" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xpath . compiler ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	1	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '1']
package org . apache . xpath ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . DOM2Helper ; import org . apache . xpath . axes . ContextNodeList ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeFilter ; import org . w3c . dom . traversal . NodeIterator ; public class NodeSet implements NodeList , NodeIterator , Cloneable , ContextNodeList { public NodeSet ( ) { m_blocksize = 32 ; m_mapSize = 0 ; } public NodeSet ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = 0 ; } public NodeSet ( NodeList nodelist ) { this ( 32 ) ; addNodes ( nodelist ) ; } public NodeSet ( NodeSet nodelist ) { this ( 32 ) ; addNodes ( ( NodeIterator ) nodelist ) ; } public NodeSet ( NodeIterator ni ) { this ( 32 ) ; addNodes ( ni ) ; } public NodeSet ( Node node ) { this ( 32 ) ; addNode ( node ) ; } public Node getRoot ( ) { return null ; } public NodeIterator cloneWithReset ( ) throws CloneNotSupportedException { NodeSet clone = ( NodeSet ) clone ( ) ; clone . reset ( ) ; return clone ; } public void reset ( ) { m_next = 0 ; } public int getWhatToShow ( ) { return NodeFilter . SHOW_ALL & ~ NodeFilter . SHOW_ENTITY_REFERENCE ; } public NodeFilter getFilter ( ) { return null ; } public boolean getExpandEntityReferences ( ) { return true ; } public Node nextNode ( ) throws DOMException { if ( ( m_next ) < this . size ( ) ) { Node next = this . elementAt ( m_next ) ; m_next ++ ; return next ; } else return null ; } public Node previousNode ( ) throws DOMException { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_ITERATE , null ) ) ; if ( ( m_next - 1 ) > 0 ) { m_next -- ; return this . elementAt ( m_next ) ; } else return null ; } public void detach ( ) { } public boolean isFresh ( ) { return ( m_next == 0 ) ; } public void runTo ( int index ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_INDEX , null ) ) ; if ( ( index >= 0 ) && ( m_next < m_firstFree ) ) m_next = index ; else m_next = m_firstFree - 1 ; } public Node item ( int index ) { runTo ( index ) ; return ( Node ) this . elementAt ( index ) ; } public int getLength ( ) { runTo ( - 1 ) ; return this . size ( ) ; } public void addNode ( Node n ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; this . addElement ( n ) ; } public void insertNode ( Node n , int pos ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; insertElementAt ( n , pos ) ; } public void removeNode ( Node n ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; this . removeElement ( n ) ; } public void addNodes ( NodeList nodelist ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null != nodelist ) { int nChildren = nodelist . getLength ( ) ; for ( int i = 0 ; i < nChildren ; i ++ ) { Node obj = nodelist . item ( i ) ; if ( null != obj ) { addElement ( obj ) ; } } } } public void addNodes ( NodeSet ns ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; addNodes ( ( NodeIterator ) ns ) ; } public void addNodes ( NodeIterator iterator ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null != iterator ) { Node obj ; while ( null != ( obj = iterator . nextNode ( ) ) ) { addElement ( obj ) ; } } } public void addNodesInDocOrder ( NodeList nodelist , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; int nChildren = nodelist . getLength ( ) ; for ( int i = 0 ; i < nChildren ; i ++ ) { Node node = nodelist . item ( i ) ; if ( null != node ) { addNodeInDocOrder ( node , support ) ; } } } public void addNodesInDocOrder ( NodeIterator iterator , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; Node node ; while ( null != ( node = iterator . nextNode ( ) ) ) { addNodeInDocOrder ( node , support ) ; } } private boolean addNodesInDocOrder ( int start , int end , int testIndex , NodeList nodelist , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; boolean foundit = false ; int i ; Node node = nodelist . item ( testIndex ) ; for ( i = end ; i >= start ; i -- ) { Node child = ( Node ) elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } if ( ! DOM2Helper . isNodeAfter ( node , child ) ) { insertElementAt ( node , i + 1 ) ; testIndex -- ; if ( testIndex > 0 ) { boolean foundPrev = addNodesInDocOrder ( 0 , i , testIndex , nodelist , support ) ; if ( ! foundPrev ) { addNodesInDocOrder ( i , size ( ) - 1 , testIndex , nodelist , support ) ; } } break ; } } if ( i == - 1 ) { insertElementAt ( node , 0 ) ; } return foundit ; } public int addNodeInDocOrder ( Node node , boolean test , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; int insertIndex = - 1 ; if ( test ) { int size = size ( ) , i ; for ( i = size - 1 ; i >= 0 ; i -- ) { Node child = ( Node ) elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } if ( ! DOM2Helper . isNodeAfter ( node , child ) ) { break ; } } if ( i != - 2 ) { insertIndex = i + 1 ; insertElementAt ( node , insertIndex ) ; } } else { insertIndex = this . size ( ) ; boolean foundit = false ; for ( int i = 0 ; i < insertIndex ; i ++ ) { if ( this . item ( i ) . equals ( node ) ) { foundit = true ; break ; } } if ( ! foundit ) addElement ( node ) ; } return insertIndex ; } public int addNodeInDocOrder ( Node node , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; return addNodeInDocOrder ( node , true , support ) ; } transient protected int m_next = 0 ; public int getCurrentPos ( ) { return m_next ; } public void setCurrentPos ( int i ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_INDEX , null ) ) ; m_next = i ; } public Node getCurrentNode ( ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_INDEX , null ) ) ; int saved = m_next ; Node n = ( m_next < m_firstFree ) ? elementAt ( m_next ) : null ; m_next = saved ; return n ; } transient protected boolean m_mutable = true ; transient protected boolean m_cacheNodes = true ; public boolean getShouldCacheNodes ( ) { return m_cacheNodes ; } public void setShouldCacheNodes ( boolean b ) { if ( ! isFresh ( ) ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANNOT_CALL_SETSHOULDCACHENODE , null ) ) ; m_cacheNodes = b ; m_mutable = true ; } transient private int m_last = 0 ; public int getLast ( ) { return m_last ; } public void setLast ( int last ) { m_last = last ; } private int m_blocksize ; Node m_map [ ] ; protected int m_firstFree = 0 ; private int m_mapSize ; public Object clone ( ) throws CloneNotSupportedException { NodeSet clone = ( NodeSet ) super . clone ( ) ; if ( ( null != this . m_map ) && ( this . m_map == clone . m_map ) ) { clone . m_map = new Node [ this . m_map . length ] ; System . arraycopy ( this . m_map , 0 , clone . m_map , 0 , this . m_map . length ) ; } return clone ; } public int size ( ) { return m_firstFree ; } public void addElement ( Node value ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( ( m_firstFree + 1 ) >= m_mapSize ) { if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final void push ( Node value ) { int ff = m_firstFree ; if ( ( ff + 1 ) >= m_mapSize ) { if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , ff + 1 ) ; m_map = newMap ; } } m_map [ ff ] = value ; ff ++ ; m_firstFree = ff ; } public final Node pop ( ) { m_firstFree -- ; Node n = m_map [ m_firstFree ] ; m_map [ m_firstFree ] = null ; return n ; } public final Node popAndTop ( ) { m_firstFree -- ; m_map [ m_firstFree ] = null ; return ( m_firstFree == 0 ) ? null : m_map [ m_firstFree - 1 ] ; } public final void popQuick ( ) { m_firstFree -- ; m_map [ m_firstFree ] = null ; } public final Node peepOrNull ( ) { return ( ( null != m_map ) && ( m_firstFree > 0 ) ) ? m_map [ m_firstFree - 1 ] : null ; } public final void pushPair ( Node v1 , Node v2 ) { if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { if ( ( m_firstFree + 2 ) >= m_mapSize ) { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree ) ; m_map = newMap ; } } m_map [ m_firstFree ] = v1 ; m_map [ m_firstFree + 1 ] = v2 ; m_firstFree += 2 ; } public final void popPair ( ) { m_firstFree -= 2 ; m_map [ m_firstFree ] = null ; m_map [ m_firstFree + 1 ] = null ; } public final void setTail ( Node n ) { m_map [ m_firstFree - 1 ] = n ; } public final void setTailSub1 ( Node n ) { m_map [ m_firstFree - 2 ] = n ; } public final Node peepTail ( ) { return m_map [ m_firstFree - 1 ] ; } public final Node peepTailSub1 ( ) { return m_map [ m_firstFree - 2 ] ; } public void insertElementAt ( Node value , int at ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } if ( at <= ( m_firstFree - 1 ) ) { System . arraycopy ( m_map , at , m_map , at + 1 , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; } public void appendNodes ( NodeSet nodes ) { int nNodes = nodes . size ( ) ; if ( null == m_map ) { m_mapSize = nNodes + m_blocksize ; m_map = new Node [ m_mapSize ] ; } else if ( ( m_firstFree + nNodes ) >= m_mapSize ) { m_mapSize += ( nNodes + m_blocksize ) ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + nNodes ) ; m_map = newMap ; } System . arraycopy ( nodes . m_map , 0 , m_map , m_firstFree , nNodes ) ; m_firstFree += nNodes ; } public void removeAllElements ( ) { if ( null == m_map ) return ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { m_map [ i ] = null ; } m_firstFree = 0 ; } public boolean removeElement ( Node s ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) { if ( i < m_firstFree - 1 ) System . arraycopy ( m_map , i + 1 , m_map , i , m_firstFree - i - 1 ) ; m_firstFree -- ; m_map [ m_firstFree ] = null ; return true ; } } return false ; } public void removeElementAt ( int i ) { if ( null == m_map ) return ; if ( i >= m_firstFree ) throw new ArrayIndexOutOfBoundsException ( i + " >= " + m_firstFree ) ; else if ( i < 0 ) throw new ArrayIndexOutOfBoundsException ( i ) ; if ( i < m_firstFree - 1 ) System . arraycopy ( m_map , i + 1 , m_map , i , m_firstFree - i - 1 ) ; m_firstFree -- ; m_map [ m_firstFree ] = null ; } public void setElementAt ( Node node , int index ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } m_map [ index ] = node ; } public Node elementAt ( int i ) { if ( null == m_map ) return null ; return m_map [ i ] ; } public boolean contains ( Node s ) { runTo ( - 1 ) ; if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) return true ; } return false ; } public int indexOf ( Node elem , int index ) { runTo ( - 1 ) ; if ( null == m_map ) return - 1 ; for ( int i = index ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( elem ) ) return i ; } return - 1 ; } public int indexOf ( Node elem ) { runTo ( - 1 ) ; if ( null == m_map ) return - 1 ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( elem ) ) return i ; } return - 1 ; } } 	1	['61', '1', '0', '10', '77', '714', '6', '4', '60', '0.629166667', '1486', '0.875', '0', '0', '0.219262295', '0', '0', '23.2295082', '9', '2.2459', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . w3c . dom . Node ; public class DTMNodeList extends DTMNodeListBase { private DTMIterator m_iter ; private DTMNodeList ( ) { } public DTMNodeList ( DTMIterator dtmIterator ) { if ( dtmIterator != null ) { int pos = dtmIterator . getCurrentPos ( ) ; try { m_iter = ( DTMIterator ) dtmIterator . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { m_iter = dtmIterator ; } m_iter . setShouldCacheNodes ( true ) ; m_iter . runTo ( - 1 ) ; m_iter . setCurrentPos ( pos ) ; } } public DTMIterator getDTMIterator ( ) { return m_iter ; } public Node item ( int index ) { if ( m_iter != null ) { int handle = m_iter . item ( index ) ; if ( handle == DTM . NULL ) { return null ; } return m_iter . getDTM ( handle ) . getNode ( handle ) ; } else { return null ; } } public int getLength ( ) { return ( m_iter != null ) ? m_iter . getLength ( ) : 0 ; } } 	1	['5', '2', '0', '6', '15', '0', '3', '3', '4', '0.25', '72', '1', '1', '0.4', '0.466666667', '0', '0', '13.2', '3', '1.2', '1']
package org . apache . xalan . xsltc . compiler ; import java . io . File ; import java . io . IOException ; import java . io . StringReader ; import java . util . Dictionary ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import java_cup . runtime . Symbol ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . runtime . AttributeList ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; public class Parser implements Constants , ContentHandler { private static final String XSL = "xsl" ; private static final String TRANSLET = "translet" ; private Locator _locator = null ; private XSLTC _xsltc ; private XPathParser _xpathParser ; private Vector _errors ; private Vector _warnings ; private Hashtable _instructionClasses ; private Hashtable _instructionAttrs ; ; private Hashtable _qNames ; private Hashtable _namespaces ; private QName _useAttributeSets ; private QName _excludeResultPrefixes ; private QName _extensionElementPrefixes ; private Hashtable _variableScope ; private Stylesheet _currentStylesheet ; private SymbolTable _symbolTable ; private Output _output ; private Template _template ; private boolean _rootNamespaceDef ; private SyntaxTreeNode _root ; private String _target ; private int _currentImportPrecedence ; public Parser ( XSLTC xsltc ) { _xsltc = xsltc ; } public void init ( ) { _qNames = new Hashtable ( 512 ) ; _namespaces = new Hashtable ( ) ; _instructionClasses = new Hashtable ( ) ; _instructionAttrs = new Hashtable ( ) ; _variableScope = new Hashtable ( ) ; _template = null ; _errors = new Vector ( ) ; _warnings = new Vector ( ) ; _symbolTable = new SymbolTable ( ) ; _xpathParser = new XPathParser ( this ) ; _currentStylesheet = null ; _output = null ; _root = null ; _rootNamespaceDef = false ; _currentImportPrecedence = 1 ; initStdClasses ( ) ; initInstructionAttrs ( ) ; initExtClasses ( ) ; initSymbolTable ( ) ; _useAttributeSets = getQName ( XSLT_URI , XSL , "use-attribute-sets" ) ; _excludeResultPrefixes = getQName ( XSLT_URI , XSL , "exclude-result-prefixes" ) ; _extensionElementPrefixes = getQName ( XSLT_URI , XSL , "extension-element-prefixes" ) ; } public void setOutput ( Output output ) { if ( _output != null ) { if ( _output . getImportPrecedence ( ) <= output . getImportPrecedence ( ) ) { String cdata = _output . getCdata ( ) ; output . mergeCdata ( cdata ) ; _output . disable ( ) ; _output = output ; } else { output . disable ( ) ; } } else { _output = output ; } } public Output getOutput ( ) { return _output ; } public Properties getOutputProperties ( ) { return getTopLevelStylesheet ( ) . getOutputProperties ( ) ; } public void addVariable ( Variable var ) { addVariableOrParam ( var ) ; } public void addParameter ( Param param ) { addVariableOrParam ( param ) ; } private void addVariableOrParam ( VariableBase var ) { Object existing = _variableScope . get ( var . getName ( ) ) ; if ( existing != null ) { if ( existing instanceof Stack ) { Stack stack = ( Stack ) existing ; stack . push ( var ) ; } else if ( existing instanceof VariableBase ) { Stack stack = new Stack ( ) ; stack . push ( existing ) ; stack . push ( var ) ; _variableScope . put ( var . getName ( ) , stack ) ; } } else { _variableScope . put ( var . getName ( ) , var ) ; } } public void removeVariable ( QName name ) { Object existing = _variableScope . get ( name ) ; if ( existing instanceof Stack ) { Stack stack = ( Stack ) existing ; if ( ! stack . isEmpty ( ) ) stack . pop ( ) ; if ( ! stack . isEmpty ( ) ) return ; } _variableScope . remove ( name ) ; } public VariableBase lookupVariable ( QName name ) { Object existing = _variableScope . get ( name ) ; if ( existing instanceof VariableBase ) { return ( ( VariableBase ) existing ) ; } else if ( existing instanceof Stack ) { Stack stack = ( Stack ) existing ; return ( ( VariableBase ) stack . peek ( ) ) ; } return ( null ) ; } public void setXSLTC ( XSLTC xsltc ) { _xsltc = xsltc ; } public XSLTC getXSLTC ( ) { return _xsltc ; } public int getCurrentImportPrecedence ( ) { return _currentImportPrecedence ; } public int getNextImportPrecedence ( ) { return ++ _currentImportPrecedence ; } public void setCurrentStylesheet ( Stylesheet stylesheet ) { _currentStylesheet = stylesheet ; } public Stylesheet getCurrentStylesheet ( ) { return _currentStylesheet ; } public Stylesheet getTopLevelStylesheet ( ) { return _xsltc . getStylesheet ( ) ; } public QName getQNameSafe ( final String stringRep ) { final int colon = stringRep . lastIndexOf ( ':' ) ; if ( colon != - 1 ) { final String prefix = stringRep . substring ( 0 , colon ) ; final String localname = stringRep . substring ( colon + 1 ) ; String namespace = null ; if ( prefix . equals ( XMLNS_PREFIX ) == false ) { namespace = _symbolTable . lookupNamespace ( prefix ) ; if ( namespace == null ) namespace = EMPTYSTRING ; } return getQName ( namespace , prefix , localname ) ; } else { final String uri = stringRep . equals ( XMLNS_PREFIX ) ? null : _symbolTable . lookupNamespace ( EMPTYSTRING ) ; return getQName ( uri , null , stringRep ) ; } } public QName getQName ( final String stringRep ) { return getQName ( stringRep , true , false ) ; } public QName getQNameIgnoreDefaultNs ( final String stringRep ) { return getQName ( stringRep , true , true ) ; } public QName getQName ( final String stringRep , boolean reportError ) { return getQName ( stringRep , reportError , false ) ; } private QName getQName ( final String stringRep , boolean reportError , boolean ignoreDefaultNs ) { final int colon = stringRep . lastIndexOf ( ':' ) ; if ( colon != - 1 ) { final String prefix = stringRep . substring ( 0 , colon ) ; final String localname = stringRep . substring ( colon + 1 ) ; String namespace = null ; if ( prefix . equals ( XMLNS_PREFIX ) == false ) { namespace = _symbolTable . lookupNamespace ( prefix ) ; if ( namespace == null && reportError ) { final int line = _locator . getLineNumber ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . NAMESPACE_UNDEF_ERR , line , prefix ) ; reportError ( ERROR , err ) ; } } return getQName ( namespace , prefix , localname ) ; } else { if ( stringRep . equals ( XMLNS_PREFIX ) ) { ignoreDefaultNs = true ; } final String defURI = ignoreDefaultNs ? null : _symbolTable . lookupNamespace ( EMPTYSTRING ) ; return getQName ( defURI , null , stringRep ) ; } } public QName getQName ( String namespace , String prefix , String localname ) { if ( namespace == null || namespace . equals ( EMPTYSTRING ) ) { QName name = ( QName ) _qNames . get ( localname ) ; if ( name == null ) { name = new QName ( null , prefix , localname ) ; _qNames . put ( localname , name ) ; } return name ; } else { Dictionary space = ( Dictionary ) _namespaces . get ( namespace ) ; if ( space == null ) { final QName name = new QName ( namespace , prefix , localname ) ; _namespaces . put ( namespace , space = new Hashtable ( ) ) ; space . put ( localname , name ) ; return name ; } else { QName name = ( QName ) space . get ( localname ) ; if ( name == null ) { name = new QName ( namespace , prefix , localname ) ; space . put ( localname , name ) ; } return name ; } } } public QName getQName ( String scope , String name ) { return getQName ( scope + name ) ; } public QName getQName ( QName scope , QName name ) { return getQName ( scope . toString ( ) + name . toString ( ) ) ; } public QName getUseAttributeSets ( ) { return _useAttributeSets ; } public QName getExtensionElementPrefixes ( ) { return _extensionElementPrefixes ; } public QName getExcludeResultPrefixes ( ) { return _excludeResultPrefixes ; } public Stylesheet makeStylesheet ( SyntaxTreeNode element ) throws CompilerException { try { Stylesheet stylesheet ; if ( element instanceof Stylesheet ) { stylesheet = ( Stylesheet ) element ; } else { stylesheet = new Stylesheet ( ) ; stylesheet . setSimplified ( ) ; stylesheet . addElement ( element ) ; stylesheet . setAttributes ( element . getAttributes ( ) ) ; if ( element . lookupNamespace ( EMPTYSTRING ) == null ) { element . addPrefixMapping ( EMPTYSTRING , EMPTYSTRING ) ; } } stylesheet . setParser ( this ) ; return stylesheet ; } catch ( ClassCastException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NOT_STYLESHEET_ERR , element ) ; throw new CompilerException ( err . toString ( ) ) ; } } public void createAST ( Stylesheet stylesheet ) { try { if ( stylesheet != null ) { stylesheet . parseContents ( this ) ; final int precedence = stylesheet . getImportPrecedence ( ) ; final Enumeration elements = stylesheet . elements ( ) ; while ( elements . hasMoreElements ( ) ) { Object child = elements . nextElement ( ) ; if ( child instanceof Text ) { final int l = _locator . getLineNumber ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . ILLEGAL_TEXT_NODE_ERR , l , null ) ; reportError ( ERROR , err ) ; } } if ( ! errorsFound ( ) ) { stylesheet . typeCheck ( _symbolTable ) ; } } } catch ( TypeCheckError e ) { reportError ( ERROR , new ErrorMsg ( e ) ) ; } } public SyntaxTreeNode parse ( XMLReader reader , InputSource input ) { try { reader . setContentHandler ( this ) ; reader . parse ( input ) ; return ( SyntaxTreeNode ) getStylesheet ( _root ) ; } catch ( IOException e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( e ) ) ; } catch ( SAXException e ) { Throwable ex = e . getException ( ) ; if ( _xsltc . debug ( ) ) { e . printStackTrace ( ) ; if ( ex != null ) ex . printStackTrace ( ) ; } reportError ( ERROR , new ErrorMsg ( e ) ) ; } catch ( CompilerException e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( e ) ) ; } catch ( Exception e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( e ) ) ; } return null ; } public SyntaxTreeNode parse ( InputSource input ) { try { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { factory . setFeature ( Constants . NAMESPACE_FEATURE , true ) ; } catch ( Exception e ) { factory . setNamespaceAware ( true ) ; } final SAXParser parser = factory . newSAXParser ( ) ; final XMLReader reader = parser . getXMLReader ( ) ; return ( parse ( reader , input ) ) ; } catch ( ParserConfigurationException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . SAX_PARSER_CONFIG_ERR ) ; reportError ( ERROR , err ) ; } catch ( SAXParseException e ) { reportError ( ERROR , new ErrorMsg ( e . getMessage ( ) , e . getLineNumber ( ) ) ) ; } catch ( SAXException e ) { reportError ( ERROR , new ErrorMsg ( e . getMessage ( ) ) ) ; } return null ; } public SyntaxTreeNode getDocumentRoot ( ) { return _root ; } private String _PImedia = null ; private String _PItitle = null ; private String _PIcharset = null ; protected void setPIParameters ( String media , String title , String charset ) { _PImedia = media ; _PItitle = title ; _PIcharset = charset ; } private SyntaxTreeNode getStylesheet ( SyntaxTreeNode root ) throws CompilerException { if ( _target == null ) { if ( ! _rootNamespaceDef ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . MISSING_XSLT_URI_ERR ) ; throw new CompilerException ( msg . toString ( ) ) ; } return ( root ) ; } if ( _target . charAt ( 0 ) == '#' ) { SyntaxTreeNode element = findStylesheet ( root , _target . substring ( 1 ) ) ; if ( element == null ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . MISSING_XSLT_TARGET_ERR , _target , root ) ; throw new CompilerException ( msg . toString ( ) ) ; } return ( element ) ; } else { return ( loadExternalStylesheet ( _target ) ) ; } } private SyntaxTreeNode findStylesheet ( SyntaxTreeNode root , String href ) { if ( root == null ) return null ; if ( root instanceof Stylesheet ) { String id = root . getAttribute ( "id" ) ; if ( id . equals ( href ) ) return root ; } Vector children = root . getContents ( ) ; if ( children != null ) { final int count = children . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) children . elementAt ( i ) ; SyntaxTreeNode node = findStylesheet ( child , href ) ; if ( node != null ) return node ; } } return null ; } private SyntaxTreeNode loadExternalStylesheet ( String location ) throws CompilerException { InputSource source ; if ( ( new File ( location ) ) . exists ( ) ) source = new InputSource ( "file:" + location ) ; else source = new InputSource ( location ) ; SyntaxTreeNode external = ( SyntaxTreeNode ) parse ( source ) ; return ( external ) ; } private void initAttrTable ( String elementName , String [ ] attrs ) { _instructionAttrs . put ( getQName ( XSLT_URI , XSL , elementName ) , attrs ) ; } private void initInstructionAttrs ( ) { initAttrTable ( "template" , new String [ ] { "match" , "name" , "priority" , "mode" } ) ; initAttrTable ( "stylesheet" , new String [ ] { "id" , "version" , "extension-element-prefixes" , "exclude-result-prefixes" } ) ; initAttrTable ( "transform" , new String [ ] { "id" , "version" , "extension-element-prefixes" , "exclude-result-prefixes" } ) ; initAttrTable ( "text" , new String [ ] { "disable-output-escaping" } ) ; initAttrTable ( "if" , new String [ ] { "test" } ) ; initAttrTable ( "choose" , new String [ ] { } ) ; initAttrTable ( "when" , new String [ ] { "test" } ) ; initAttrTable ( "otherwise" , new String [ ] { } ) ; initAttrTable ( "for-each" , new String [ ] { "select" } ) ; initAttrTable ( "message" , new String [ ] { "terminate" } ) ; initAttrTable ( "number" , new String [ ] { "level" , "count" , "from" , "value" , "format" , "lang" , "letter-value" , "grouping-separator" , "grouping-size" } ) ; initAttrTable ( "comment" , new String [ ] { } ) ; initAttrTable ( "copy" , new String [ ] { "use-attribute-sets" } ) ; initAttrTable ( "copy-of" , new String [ ] { "select" } ) ; initAttrTable ( "param" , new String [ ] { "name" , "select" } ) ; initAttrTable ( "with-param" , new String [ ] { "name" , "select" } ) ; initAttrTable ( "variable" , new String [ ] { "name" , "select" } ) ; initAttrTable ( "output" , new String [ ] { "method" , "version" , "encoding" , "omit-xml-declaration" , "standalone" , "doctype-public" , "doctype-system" , "cdata-section-elements" , "indent" , "media-type" } ) ; initAttrTable ( "sort" , new String [ ] { "select" , "order" , "case-order" , "lang" , "data-type" } ) ; initAttrTable ( "key" , new String [ ] { "name" , "match" , "use" } ) ; initAttrTable ( "fallback" , new String [ ] { } ) ; initAttrTable ( "attribute" , new String [ ] { "name" , "namespace" } ) ; initAttrTable ( "attribute-set" , new String [ ] { "name" , "use-attribute-sets" } ) ; initAttrTable ( "value-of" , new String [ ] { "select" , "disable-output-escaping" } ) ; initAttrTable ( "element" , new String [ ] { "name" , "namespace" , "use-attribute-sets" } ) ; initAttrTable ( "call-template" , new String [ ] { "name" } ) ; initAttrTable ( "apply-templates" , new String [ ] { "select" , "mode" } ) ; initAttrTable ( "apply-imports" , new String [ ] { } ) ; initAttrTable ( "decimal-format" , new String [ ] { "name" , "decimal-separator" , "grouping-separator" , "infinity" , "minus-sign" , "NaN" , "percent" , "per-mille" , "zero-digit" , "digit" , "pattern-separator" } ) ; initAttrTable ( "import" , new String [ ] { "href" } ) ; initAttrTable ( "include" , new String [ ] { "href" } ) ; initAttrTable ( "strip-space" , new String [ ] { "elements" } ) ; initAttrTable ( "preserve-space" , new String [ ] { "elements" } ) ; initAttrTable ( "processing-instruction" , new String [ ] { "name" } ) ; initAttrTable ( "namespace-alias" , new String [ ] { "stylesheet-prefix" , "result-prefix" } ) ; } private void initStdClasses ( ) { initStdClass ( "template" , "Template" ) ; initStdClass ( "stylesheet" , "Stylesheet" ) ; initStdClass ( "transform" , "Stylesheet" ) ; initStdClass ( "text" , "Text" ) ; initStdClass ( "if" , "If" ) ; initStdClass ( "choose" , "Choose" ) ; initStdClass ( "when" , "When" ) ; initStdClass ( "otherwise" , "Otherwise" ) ; initStdClass ( "for-each" , "ForEach" ) ; initStdClass ( "message" , "Message" ) ; initStdClass ( "number" , "Number" ) ; initStdClass ( "comment" , "Comment" ) ; initStdClass ( "copy" , "Copy" ) ; initStdClass ( "copy-of" , "CopyOf" ) ; initStdClass ( "param" , "Param" ) ; initStdClass ( "with-param" , "WithParam" ) ; initStdClass ( "variable" , "Variable" ) ; initStdClass ( "output" , "Output" ) ; initStdClass ( "sort" , "Sort" ) ; initStdClass ( "key" , "Key" ) ; initStdClass ( "fallback" , "Fallback" ) ; initStdClass ( "attribute" , "XslAttribute" ) ; initStdClass ( "attribute-set" , "AttributeSet" ) ; initStdClass ( "value-of" , "ValueOf" ) ; initStdClass ( "element" , "XslElement" ) ; initStdClass ( "call-template" , "CallTemplate" ) ; initStdClass ( "apply-templates" , "ApplyTemplates" ) ; initStdClass ( "apply-imports" , "ApplyImports" ) ; initStdClass ( "decimal-format" , "DecimalFormatting" ) ; initStdClass ( "import" , "Import" ) ; initStdClass ( "include" , "Include" ) ; initStdClass ( "strip-space" , "Whitespace" ) ; initStdClass ( "preserve-space" , "Whitespace" ) ; initStdClass ( "processing-instruction" , "ProcessingInstruction" ) ; initStdClass ( "namespace-alias" , "NamespaceAlias" ) ; } private void initStdClass ( String elementName , String className ) { _instructionClasses . put ( getQName ( XSLT_URI , XSL , elementName ) , COMPILER_PACKAGE + '.' + className ) ; } public boolean elementSupported ( String namespace , String localName ) { return ( _instructionClasses . get ( getQName ( namespace , XSL , localName ) ) != null ) ; } public boolean functionSupported ( String fname ) { return ( _symbolTable . lookupPrimop ( fname ) != null ) ; } private void initExtClasses ( ) { initExtClass ( "output" , "TransletOutput" ) ; initExtClass ( REDIRECT_URI , "write" , "TransletOutput" ) ; } private void initExtClass ( String elementName , String className ) { _instructionClasses . put ( getQName ( TRANSLET_URI , TRANSLET , elementName ) , COMPILER_PACKAGE + '.' + className ) ; } private void initExtClass ( String namespace , String elementName , String className ) { _instructionClasses . put ( getQName ( namespace , TRANSLET , elementName ) , COMPILER_PACKAGE + '.' + className ) ; } private void initSymbolTable ( ) { MethodType I_V = new MethodType ( Type . Int , Type . Void ) ; MethodType I_R = new MethodType ( Type . Int , Type . Real ) ; MethodType I_S = new MethodType ( Type . Int , Type . String ) ; MethodType I_D = new MethodType ( Type . Int , Type . NodeSet ) ; MethodType R_I = new MethodType ( Type . Real , Type . Int ) ; MethodType R_V = new MethodType ( Type . Real , Type . Void ) ; MethodType R_R = new MethodType ( Type . Real , Type . Real ) ; MethodType R_D = new MethodType ( Type . Real , Type . NodeSet ) ; MethodType R_O = new MethodType ( Type . Real , Type . Reference ) ; MethodType I_I = new MethodType ( Type . Int , Type . Int ) ; MethodType D_O = new MethodType ( Type . NodeSet , Type . Reference ) ; MethodType D_V = new MethodType ( Type . NodeSet , Type . Void ) ; MethodType D_S = new MethodType ( Type . NodeSet , Type . String ) ; MethodType D_D = new MethodType ( Type . NodeSet , Type . NodeSet ) ; MethodType A_V = new MethodType ( Type . Node , Type . Void ) ; MethodType S_V = new MethodType ( Type . String , Type . Void ) ; MethodType S_S = new MethodType ( Type . String , Type . String ) ; MethodType S_A = new MethodType ( Type . String , Type . Node ) ; MethodType S_D = new MethodType ( Type . String , Type . NodeSet ) ; MethodType S_O = new MethodType ( Type . String , Type . Reference ) ; MethodType B_O = new MethodType ( Type . Boolean , Type . Reference ) ; MethodType B_V = new MethodType ( Type . Boolean , Type . Void ) ; MethodType B_B = new MethodType ( Type . Boolean , Type . Boolean ) ; MethodType B_S = new MethodType ( Type . Boolean , Type . String ) ; MethodType D_X = new MethodType ( Type . NodeSet , Type . Object ) ; MethodType R_RR = new MethodType ( Type . Real , Type . Real , Type . Real ) ; MethodType I_II = new MethodType ( Type . Int , Type . Int , Type . Int ) ; MethodType B_RR = new MethodType ( Type . Boolean , Type . Real , Type . Real ) ; MethodType B_II = new MethodType ( Type . Boolean , Type . Int , Type . Int ) ; MethodType S_SS = new MethodType ( Type . String , Type . String , Type . String ) ; MethodType S_DS = new MethodType ( Type . String , Type . Real , Type . String ) ; MethodType S_SR = new MethodType ( Type . String , Type . String , Type . Real ) ; MethodType O_SO = new MethodType ( Type . Reference , Type . String , Type . Reference ) ; MethodType D_SS = new MethodType ( Type . NodeSet , Type . String , Type . String ) ; MethodType D_SD = new MethodType ( Type . NodeSet , Type . String , Type . NodeSet ) ; MethodType B_BB = new MethodType ( Type . Boolean , Type . Boolean , Type . Boolean ) ; MethodType B_SS = new MethodType ( Type . Boolean , Type . String , Type . String ) ; MethodType S_SD = new MethodType ( Type . String , Type . String , Type . NodeSet ) ; MethodType S_DSS = new MethodType ( Type . String , Type . Real , Type . String , Type . String ) ; MethodType S_SRR = new MethodType ( Type . String , Type . String , Type . Real , Type . Real ) ; MethodType S_SSS = new MethodType ( Type . String , Type . String , Type . String , Type . String ) ; _symbolTable . addPrimop ( "current" , A_V ) ; _symbolTable . addPrimop ( "last" , I_V ) ; _symbolTable . addPrimop ( "position" , I_V ) ; _symbolTable . addPrimop ( "true" , B_V ) ; _symbolTable . addPrimop ( "false" , B_V ) ; _symbolTable . addPrimop ( "not" , B_B ) ; _symbolTable . addPrimop ( "name" , S_V ) ; _symbolTable . addPrimop ( "name" , S_A ) ; _symbolTable . addPrimop ( "generate-id" , S_V ) ; _symbolTable . addPrimop ( "generate-id" , S_A ) ; _symbolTable . addPrimop ( "ceiling" , R_R ) ; _symbolTable . addPrimop ( "floor" , R_R ) ; _symbolTable . addPrimop ( "round" , R_R ) ; _symbolTable . addPrimop ( "contains" , B_SS ) ; _symbolTable . addPrimop ( "number" , R_O ) ; _symbolTable . addPrimop ( "number" , R_V ) ; _symbolTable . addPrimop ( "boolean" , B_O ) ; _symbolTable . addPrimop ( "string" , S_O ) ; _symbolTable . addPrimop ( "string" , S_V ) ; _symbolTable . addPrimop ( "translate" , S_SSS ) ; _symbolTable . addPrimop ( "string-length" , I_V ) ; _symbolTable . addPrimop ( "string-length" , I_S ) ; _symbolTable . addPrimop ( "starts-with" , B_SS ) ; _symbolTable . addPrimop ( "format-number" , S_DS ) ; _symbolTable . addPrimop ( "format-number" , S_DSS ) ; _symbolTable . addPrimop ( "unparsed-entity-uri" , S_S ) ; _symbolTable . addPrimop ( "key" , D_SS ) ; _symbolTable . addPrimop ( "key" , D_SD ) ; _symbolTable . addPrimop ( "id" , D_S ) ; _symbolTable . addPrimop ( "id" , D_D ) ; _symbolTable . addPrimop ( "namespace-uri" , S_V ) ; _symbolTable . addPrimop ( "function-available" , B_S ) ; _symbolTable . addPrimop ( "element-available" , B_S ) ; _symbolTable . addPrimop ( "document" , D_S ) ; _symbolTable . addPrimop ( "document" , D_V ) ; _symbolTable . addPrimop ( "count" , I_D ) ; _symbolTable . addPrimop ( "sum" , R_D ) ; _symbolTable . addPrimop ( "local-name" , S_V ) ; _symbolTable . addPrimop ( "local-name" , S_D ) ; _symbolTable . addPrimop ( "namespace-uri" , S_V ) ; _symbolTable . addPrimop ( "namespace-uri" , S_D ) ; _symbolTable . addPrimop ( "substring" , S_SR ) ; _symbolTable . addPrimop ( "substring" , S_SRR ) ; _symbolTable . addPrimop ( "substring-after" , S_SS ) ; _symbolTable . addPrimop ( "substring-before" , S_SS ) ; _symbolTable . addPrimop ( "normalize-space" , S_V ) ; _symbolTable . addPrimop ( "normalize-space" , S_S ) ; _symbolTable . addPrimop ( "system-property" , S_S ) ; _symbolTable . addPrimop ( "nodeset" , D_O ) ; _symbolTable . addPrimop ( "objectType" , S_O ) ; _symbolTable . addPrimop ( "cast" , O_SO ) ; _symbolTable . addPrimop ( "+" , R_RR ) ; _symbolTable . addPrimop ( "-" , R_RR ) ; _symbolTable . addPrimop ( "*" , R_RR ) ; _symbolTable . addPrimop ( "/" , R_RR ) ; _symbolTable . addPrimop ( "%" , R_RR ) ; _symbolTable . addPrimop ( "+" , I_II ) ; _symbolTable . addPrimop ( "-" , I_II ) ; _symbolTable . addPrimop ( "*" , I_II ) ; _symbolTable . addPrimop ( "<" , B_RR ) ; _symbolTable . addPrimop ( "<=" , B_RR ) ; _symbolTable . addPrimop ( ">" , B_RR ) ; _symbolTable . addPrimop ( ">=" , B_RR ) ; _symbolTable . addPrimop ( "<" , B_II ) ; _symbolTable . addPrimop ( "<=" , B_II ) ; _symbolTable . addPrimop ( ">" , B_II ) ; _symbolTable . addPrimop ( ">=" , B_II ) ; _symbolTable . addPrimop ( "<" , B_BB ) ; _symbolTable . addPrimop ( "<=" , B_BB ) ; _symbolTable . addPrimop ( ">" , B_BB ) ; _symbolTable . addPrimop ( ">=" , B_BB ) ; _symbolTable . addPrimop ( "or" , B_BB ) ; _symbolTable . addPrimop ( "and" , B_BB ) ; _symbolTable . addPrimop ( "u-" , R_R ) ; _symbolTable . addPrimop ( "u-" , I_I ) ; } public SymbolTable getSymbolTable ( ) { return _symbolTable ; } public Template getTemplate ( ) { return _template ; } public void setTemplate ( Template template ) { _template = template ; } private int _templateIndex = 0 ; public int getTemplateIndex ( ) { return ( _templateIndex ++ ) ; } private boolean versionIsOne = true ; public SyntaxTreeNode makeInstance ( String uri , String prefix , String local , Attributes attributes ) { SyntaxTreeNode node = null ; QName qname = getQName ( uri , prefix , local ) ; String className = ( String ) _instructionClasses . get ( qname ) ; if ( className != null ) { try { final Class clazz = ObjectFactory . findProviderClass ( className , ObjectFactory . findClassLoader ( ) , true ) ; node = ( SyntaxTreeNode ) clazz . newInstance ( ) ; node . setQName ( qname ) ; node . setParser ( this ) ; if ( _locator != null ) { node . setLineNumber ( _locator . getLineNumber ( ) ) ; } if ( node instanceof Stylesheet ) { _xsltc . setStylesheet ( ( Stylesheet ) node ) ; } checkForSuperfluousAttributes ( node , attributes ) ; } catch ( ClassNotFoundException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , node ) ; reportError ( ERROR , err ) ; } catch ( Exception e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INTERNAL_ERR , e . getMessage ( ) , node ) ; reportError ( FATAL , err ) ; } } else { if ( uri != null ) { if ( uri . equals ( XSLT_URI ) ) { node = new UnsupportedElement ( uri , prefix , local , false ) ; UnsupportedElement element = ( UnsupportedElement ) node ; ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_XSL_ERR , _locator . getLineNumber ( ) , local ) ; element . setErrorMessage ( msg ) ; if ( versionIsOne ) { reportError ( UNSUPPORTED , msg ) ; } } else if ( uri . equals ( TRANSLET_URI ) ) { node = new UnsupportedElement ( uri , prefix , local , true ) ; UnsupportedElement element = ( UnsupportedElement ) node ; ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_EXT_ERR , _locator . getLineNumber ( ) , local ) ; element . setErrorMessage ( msg ) ; } else { Stylesheet sheet = _xsltc . getStylesheet ( ) ; if ( ( sheet != null ) && ( sheet . isExtension ( uri ) ) ) { if ( sheet != ( SyntaxTreeNode ) _parentStack . peek ( ) ) { node = new UnsupportedElement ( uri , prefix , local , true ) ; UnsupportedElement elem = ( UnsupportedElement ) node ; ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_EXT_ERR , _locator . getLineNumber ( ) , prefix + ":" + local ) ; elem . setErrorMessage ( msg ) ; } } } } if ( node == null ) node = new LiteralElement ( ) ; } if ( ( node != null ) && ( node instanceof LiteralElement ) ) { ( ( LiteralElement ) node ) . setQName ( qname ) ; } return ( node ) ; } private void checkForSuperfluousAttributes ( SyntaxTreeNode node , Attributes attrs ) { QName qname = node . getQName ( ) ; boolean isStylesheet = ( node instanceof Stylesheet ) ; String [ ] legal = ( String [ ] ) _instructionAttrs . get ( qname ) ; if ( versionIsOne && legal != null ) { int j ; final int n = attrs . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final String attrQName = attrs . getQName ( i ) ; if ( isStylesheet && attrQName . equals ( "version" ) ) { versionIsOne = attrs . getValue ( i ) . equals ( "1.0" ) ; } if ( attrQName . startsWith ( "xml" ) || attrQName . indexOf ( ':' ) > 0 ) continue ; for ( j = 0 ; j < legal . length ; j ++ ) { if ( attrQName . equalsIgnoreCase ( legal [ j ] ) ) { break ; } } if ( j == legal . length ) { final ErrorMsg err = new ErrorMsg ( ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , attrQName , node ) ; reportError ( WARNING , err ) ; } } } } public Expression parseExpression ( SyntaxTreeNode parent , String exp ) { return ( Expression ) parseTopLevel ( parent , "<EXPRESSION>" + exp , null ) ; } public Expression parseExpression ( SyntaxTreeNode parent , String attr , String def ) { String exp = parent . getAttribute ( attr ) ; if ( ( exp . length ( ) == 0 ) && ( def != null ) ) exp = def ; return ( Expression ) parseTopLevel ( parent , "<EXPRESSION>" + exp , exp ) ; } public Pattern parsePattern ( SyntaxTreeNode parent , String pattern ) { return ( Pattern ) parseTopLevel ( parent , "<PATTERN>" + pattern , pattern ) ; } public Pattern parsePattern ( SyntaxTreeNode parent , String attr , String def ) { String pattern = parent . getAttribute ( attr ) ; if ( ( pattern . length ( ) == 0 ) && ( def != null ) ) pattern = def ; return ( Pattern ) parseTopLevel ( parent , "<PATTERN>" + pattern , pattern ) ; } private SyntaxTreeNode parseTopLevel ( SyntaxTreeNode parent , String text , String expression ) { int line = 0 ; if ( _locator != null ) line = _locator . getLineNumber ( ) ; try { _xpathParser . setScanner ( new XPathLexer ( new StringReader ( text ) ) ) ; Symbol result = _xpathParser . parse ( expression , line ) ; if ( result != null ) { final SyntaxTreeNode node = ( SyntaxTreeNode ) result . value ; if ( node != null ) { node . setParser ( this ) ; node . setParent ( parent ) ; node . setLineNumber ( line ) ; return node ; } } reportError ( ERROR , new ErrorMsg ( ErrorMsg . XPATH_PARSER_ERR , expression , parent ) ) ; } catch ( Exception e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( ErrorMsg . XPATH_PARSER_ERR , expression , parent ) ) ; } SyntaxTreeNode . Dummy . setParser ( this ) ; return SyntaxTreeNode . Dummy ; } public boolean errorsFound ( ) { return _errors . size ( ) > 0 ; } public void printErrors ( ) { final int size = _errors . size ( ) ; if ( size > 0 ) { System . err . println ( new ErrorMsg ( ErrorMsg . COMPILER_ERROR_KEY ) ) ; for ( int i = 0 ; i < size ; i ++ ) { System . err . println ( "  " + _errors . elementAt ( i ) ) ; } } } public void printWarnings ( ) { final int size = _warnings . size ( ) ; if ( size > 0 ) { System . err . println ( new ErrorMsg ( ErrorMsg . COMPILER_WARNING_KEY ) ) ; for ( int i = 0 ; i < size ; i ++ ) { System . err . println ( "  " + _warnings . elementAt ( i ) ) ; } } } public void reportError ( final int category , final ErrorMsg error ) { switch ( category ) { case Constants . INTERNAL : _errors . addElement ( error ) ; break ; case Constants . UNSUPPORTED : _errors . addElement ( error ) ; break ; case Constants . FATAL : _errors . addElement ( error ) ; break ; case Constants . ERROR : _errors . addElement ( error ) ; break ; case Constants . WARNING : _warnings . addElement ( error ) ; break ; } } public Vector getErrors ( ) { return _errors ; } public Vector getWarnings ( ) { return _warnings ; } private Stack _parentStack = null ; private Hashtable _prefixMapping = null ; public void startDocument ( ) { _root = null ; _target = null ; _prefixMapping = null ; _parentStack = new Stack ( ) ; } public void endDocument ( ) { } public void startPrefixMapping ( String prefix , String uri ) { if ( _prefixMapping == null ) { _prefixMapping = new Hashtable ( ) ; } _prefixMapping . put ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) { } public void startElement ( String uri , String localname , String qname , Attributes attributes ) throws SAXException { final int col = qname . lastIndexOf ( ':' ) ; final String prefix = ( col == - 1 ) ? null : qname . substring ( 0 , col ) ; SyntaxTreeNode element = makeInstance ( uri , prefix , localname , attributes ) ; if ( element == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ELEMENT_PARSE_ERR , prefix + ':' + localname ) ; throw new SAXException ( err . toString ( ) ) ; } if ( _root == null ) { if ( ( _prefixMapping == null ) || ( _prefixMapping . containsValue ( Constants . XSLT_URI ) == false ) ) _rootNamespaceDef = false ; else _rootNamespaceDef = true ; _root = element ; } else { SyntaxTreeNode parent = ( SyntaxTreeNode ) _parentStack . peek ( ) ; parent . addElement ( element ) ; element . setParent ( parent ) ; } element . setAttributes ( ( Attributes ) new AttributeList ( attributes ) ) ; element . setPrefixMapping ( _prefixMapping ) ; if ( element instanceof Stylesheet ) { getSymbolTable ( ) . setCurrentNode ( element ) ; ( ( Stylesheet ) element ) . excludeExtensionPrefixes ( this ) ; } _prefixMapping = null ; _parentStack . push ( element ) ; } public void endElement ( String uri , String localname , String qname ) { _parentStack . pop ( ) ; } public void characters ( char [ ] ch , int start , int length ) { String string = new String ( ch , start , length ) ; SyntaxTreeNode parent = ( SyntaxTreeNode ) _parentStack . peek ( ) ; if ( string . length ( ) == 0 ) return ; if ( parent instanceof Text ) { ( ( Text ) parent ) . setText ( string ) ; return ; } if ( parent instanceof Stylesheet ) return ; SyntaxTreeNode bro = parent . lastChild ( ) ; if ( ( bro != null ) && ( bro instanceof Text ) ) { Text text = ( Text ) bro ; if ( ! text . isTextElement ( ) ) { if ( ( length > 1 ) || ( ( ( int ) ch [ 0 ] ) < 0x100 ) ) { text . setText ( string ) ; return ; } } } parent . addElement ( new Text ( string ) ) ; } private String getTokenValue ( String token ) { final int start = token . indexOf ( '"' ) ; final int stop = token . lastIndexOf ( '"' ) ; return token . substring ( start + 1 , stop ) ; } public void processingInstruction ( String name , String value ) { if ( ( _target == null ) && ( name . equals ( "xml-stylesheet" ) ) ) { String href = null ; String media = null ; String title = null ; String charset = null ; StringTokenizer tokens = new StringTokenizer ( value ) ; while ( tokens . hasMoreElements ( ) ) { String token = ( String ) tokens . nextElement ( ) ; if ( token . startsWith ( "href" ) ) href = getTokenValue ( token ) ; else if ( token . startsWith ( "media" ) ) media = getTokenValue ( token ) ; else if ( token . startsWith ( "title" ) ) title = getTokenValue ( token ) ; else if ( token . startsWith ( "charset" ) ) charset = getTokenValue ( token ) ; } if ( ( ( _PImedia == null ) || ( _PImedia . equals ( media ) ) ) && ( ( _PItitle == null ) || ( _PImedia . equals ( title ) ) ) && ( ( _PIcharset == null ) || ( _PImedia . equals ( charset ) ) ) ) { _target = href ; } } } public void ignorableWhitespace ( char [ ] ch , int start , int length ) { } public void skippedEntity ( String name ) { } public void setDocumentLocator ( Locator locator ) { _locator = locator ; } } 	1	['76', '1', '0', '97', '205', '2560', '86', '24', '59', '0.933777778', '3305', '1', '9', '0', '0.093421053', '0', '0', '42.09210526', '13', '2.25', '3']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . DUP ; import org . apache . bcel . generic . GOTO_W ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . SWITCH ; import org . apache . bcel . generic . TargetLostException ; import org . apache . bcel . util . InstructionFinder ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NamedMethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; final class Mode implements Constants { private final QName _name ; private final Stylesheet _stylesheet ; private final String _methodName ; private Vector _templates ; private Vector _childNodeGroup = null ; private TestSeq _childNodeTestSeq = null ; private Vector _attribNodeGroup = null ; private TestSeq _attribNodeTestSeq = null ; private Vector _idxGroup = null ; private TestSeq _idxTestSeq = null ; private Vector [ ] _patternGroups ; private TestSeq [ ] _testSeq ; private Hashtable _preCompiled = new Hashtable ( ) ; private Hashtable _neededTemplates = new Hashtable ( ) ; private Hashtable _namedTemplates = new Hashtable ( ) ; private Hashtable _templateIHs = new Hashtable ( ) ; private Hashtable _templateILs = new Hashtable ( ) ; private LocationPathPattern _rootPattern = null ; private Hashtable _importLevels = null ; private Hashtable _keys = null ; private int _currentIndex ; public Mode ( QName name , Stylesheet stylesheet , String suffix ) { _name = name ; _stylesheet = stylesheet ; _methodName = APPLY_TEMPLATES + suffix ; _templates = new Vector ( ) ; _patternGroups = new Vector [ 32 ] ; } public String functionName ( ) { return _methodName ; } public String functionName ( int min , int max ) { if ( _importLevels == null ) { _importLevels = new Hashtable ( ) ; } _importLevels . put ( new Integer ( max ) , new Integer ( min ) ) ; return _methodName + '_' + max ; } public void addInstructionList ( Pattern pattern , InstructionList ilist ) { _preCompiled . put ( pattern , ilist ) ; } public InstructionList getInstructionList ( Pattern pattern ) { return ( InstructionList ) _preCompiled . get ( pattern ) ; } private String getClassName ( ) { return _stylesheet . getClassName ( ) ; } public Stylesheet getStylesheet ( ) { return _stylesheet ; } public void addTemplate ( Template template ) { _templates . addElement ( template ) ; } private Vector quicksort ( Vector templates , int p , int r ) { if ( p < r ) { final int q = partition ( templates , p , r ) ; quicksort ( templates , p , q ) ; quicksort ( templates , q + 1 , r ) ; } return templates ; } private int partition ( Vector templates , int p , int r ) { final Template x = ( Template ) templates . elementAt ( p ) ; int i = p - 1 ; int j = r + 1 ; while ( true ) { while ( x . compareTo ( ( Template ) templates . elementAt ( -- j ) ) > 0 ) ; while ( x . compareTo ( ( Template ) templates . elementAt ( ++ i ) ) < 0 ) ; if ( i < j ) { templates . set ( j , templates . set ( i , templates . elementAt ( j ) ) ) ; } else { return j ; } } } public void processPatterns ( Hashtable keys ) { _keys = keys ; _templates = quicksort ( _templates , 0 , _templates . size ( ) - 1 ) ; final Enumeration templates = _templates . elements ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; if ( template . isNamed ( ) && ! template . disabled ( ) ) { _namedTemplates . put ( template , this ) ; } final Pattern pattern = template . getPattern ( ) ; if ( pattern != null ) { flattenAlternative ( pattern , template , keys ) ; } } prepareTestSequences ( ) ; } private void flattenAlternative ( Pattern pattern , Template template , Hashtable keys ) { if ( pattern instanceof IdKeyPattern ) { final IdKeyPattern idkey = ( IdKeyPattern ) pattern ; idkey . setTemplate ( template ) ; if ( _idxGroup == null ) _idxGroup = new Vector ( ) ; _idxGroup . add ( pattern ) ; } else if ( pattern instanceof AlternativePattern ) { final AlternativePattern alt = ( AlternativePattern ) pattern ; flattenAlternative ( alt . getLeft ( ) , template , keys ) ; flattenAlternative ( alt . getRight ( ) , template , keys ) ; } else if ( pattern instanceof LocationPathPattern ) { final LocationPathPattern lpp = ( LocationPathPattern ) pattern ; lpp . setTemplate ( template ) ; addPatternToGroup ( lpp ) ; } } private void addPatternToGroup ( final LocationPathPattern lpp ) { if ( lpp instanceof IdKeyPattern ) { addPattern ( - 1 , lpp ) ; } else { final StepPattern kernel = lpp . getKernelPattern ( ) ; if ( kernel != null ) { addPattern ( kernel . getNodeType ( ) , lpp ) ; } else if ( _rootPattern == null || lpp . noSmallerThan ( _rootPattern ) ) { _rootPattern = lpp ; } } } private void addPattern ( int kernelType , LocationPathPattern pattern ) { final int oldLength = _patternGroups . length ; if ( kernelType >= oldLength ) { Vector [ ] newGroups = new Vector [ kernelType * 2 ] ; System . arraycopy ( _patternGroups , 0 , newGroups , 0 , oldLength ) ; _patternGroups = newGroups ; } Vector patterns ; if ( kernelType == DOM . NO_TYPE ) { if ( pattern . getAxis ( ) == Axis . ATTRIBUTE ) { patterns = ( _attribNodeGroup == null ) ? ( _attribNodeGroup = new Vector ( 2 ) ) : _attribNodeGroup ; } else { patterns = ( _childNodeGroup == null ) ? ( _childNodeGroup = new Vector ( 2 ) ) : _childNodeGroup ; } } else { patterns = ( _patternGroups [ kernelType ] == null ) ? ( _patternGroups [ kernelType ] = new Vector ( 2 ) ) : _patternGroups [ kernelType ] ; } if ( patterns . size ( ) == 0 ) { patterns . addElement ( pattern ) ; } else { boolean inserted = false ; for ( int i = 0 ; i < patterns . size ( ) ; i ++ ) { final LocationPathPattern lppToCompare = ( LocationPathPattern ) patterns . elementAt ( i ) ; if ( pattern . noSmallerThan ( lppToCompare ) ) { inserted = true ; patterns . insertElementAt ( pattern , i ) ; break ; } } if ( inserted == false ) { patterns . addElement ( pattern ) ; } } } private void completeTestSequences ( int nodeType , Vector patterns ) { if ( patterns != null ) { if ( _patternGroups [ nodeType ] == null ) { _patternGroups [ nodeType ] = patterns ; } else { final int m = patterns . size ( ) ; for ( int j = 0 ; j < m ; j ++ ) { addPattern ( nodeType , ( LocationPathPattern ) patterns . elementAt ( j ) ) ; } } } } private void prepareTestSequences ( ) { final Vector starGroup = _patternGroups [ DTM . ELEMENT_NODE ] ; final Vector atStarGroup = _patternGroups [ DTM . ATTRIBUTE_NODE ] ; completeTestSequences ( DTM . TEXT_NODE , _childNodeGroup ) ; completeTestSequences ( DTM . ELEMENT_NODE , _childNodeGroup ) ; completeTestSequences ( DTM . PROCESSING_INSTRUCTION_NODE , _childNodeGroup ) ; completeTestSequences ( DTM . COMMENT_NODE , _childNodeGroup ) ; completeTestSequences ( DTM . ATTRIBUTE_NODE , _attribNodeGroup ) ; final Vector names = _stylesheet . getXSLTC ( ) . getNamesIndex ( ) ; if ( starGroup != null || atStarGroup != null || _childNodeGroup != null || _attribNodeGroup != null ) { final int n = _patternGroups . length ; for ( int i = DTM . NTYPES ; i < n ; i ++ ) { if ( _patternGroups [ i ] == null ) continue ; final String name = ( String ) names . elementAt ( i - DTM . NTYPES ) ; if ( isAttributeName ( name ) ) { completeTestSequences ( i , atStarGroup ) ; completeTestSequences ( i , _attribNodeGroup ) ; } else { completeTestSequences ( i , starGroup ) ; completeTestSequences ( i , _childNodeGroup ) ; } } } _testSeq = new TestSeq [ DTM . NTYPES + names . size ( ) ] ; final int n = _patternGroups . length ; for ( int i = 0 ; i < n ; i ++ ) { final Vector patterns = _patternGroups [ i ] ; if ( patterns != null ) { final TestSeq testSeq = new TestSeq ( patterns , i , this ) ; testSeq . reduce ( ) ; _testSeq [ i ] = testSeq ; testSeq . findTemplates ( _neededTemplates ) ; } } if ( _childNodeGroup != null && _childNodeGroup . size ( ) > 0 ) { _childNodeTestSeq = new TestSeq ( _childNodeGroup , - 1 , this ) ; _childNodeTestSeq . reduce ( ) ; _childNodeTestSeq . findTemplates ( _neededTemplates ) ; } if ( _idxGroup != null && _idxGroup . size ( ) > 0 ) { _idxTestSeq = new TestSeq ( _idxGroup , this ) ; _idxTestSeq . reduce ( ) ; _idxTestSeq . findTemplates ( _neededTemplates ) ; } if ( _rootPattern != null ) { _neededTemplates . put ( _rootPattern . getTemplate ( ) , this ) ; } } private void compileNamedTemplate ( Template template , ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; String methodName = Util . escape ( template . getName ( ) . toString ( ) ) ; int numParams = 0 ; if ( template . isSimpleNamedTemplate ( ) ) { Vector parameters = template . getParameters ( ) ; numParams = parameters . size ( ) ; } org . apache . bcel . generic . Type [ ] types = new org . apache . bcel . generic . Type [ 4 + numParams ] ; String [ ] names = new String [ 4 + numParams ] ; types [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; types [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; types [ 2 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; types [ 3 ] = org . apache . bcel . generic . Type . INT ; names [ 0 ] = DOCUMENT_PNAME ; names [ 1 ] = ITERATOR_PNAME ; names [ 2 ] = TRANSLET_OUTPUT_PNAME ; names [ 3 ] = NODE_PNAME ; for ( int i = 4 ; i < 4 + numParams ; i ++ ) { types [ i ] = Util . getJCRefType ( OBJECT_SIG ) ; names [ i ] = "param" + String . valueOf ( i - 4 ) ; } NamedMethodGenerator methodGen = new NamedMethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , types , names , methodName , getClassName ( ) , il , cpg ) ; il . append ( template . compile ( classGen , methodGen ) ) ; il . append ( RETURN ) ; methodGen . stripAttributes ( true ) ; methodGen . setMaxLocals ( ) ; methodGen . setMaxStack ( ) ; methodGen . removeNOPs ( ) ; classGen . addMethod ( methodGen . getMethod ( ) ) ; } private void compileTemplates ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle next ) { Enumeration templates = _namedTemplates . keys ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; compileNamedTemplate ( template , classGen ) ; } templates = _neededTemplates . keys ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; if ( template . hasContents ( ) ) { InstructionList til = template . compile ( classGen , methodGen ) ; til . append ( new GOTO_W ( next ) ) ; _templateILs . put ( template , til ) ; _templateIHs . put ( template , til . getStart ( ) ) ; } else { _templateIHs . put ( template , next ) ; } } } private void appendTemplateCode ( InstructionList body ) { final Enumeration templates = _neededTemplates . keys ( ) ; while ( templates . hasMoreElements ( ) ) { final Object iList = _templateILs . get ( templates . nextElement ( ) ) ; if ( iList != null ) { body . append ( ( InstructionList ) iList ) ; } } } private void appendTestSequences ( InstructionList body ) { final int n = _testSeq . length ; for ( int i = 0 ; i < n ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( testSeq != null ) { InstructionList il = testSeq . getInstructionList ( ) ; if ( il != null ) body . append ( il ) ; } } } public static void compileGetChildren ( ClassGenerator classGen , MethodGenerator methodGen , int node ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int git = cpg . addInterfaceMethodref ( DOM_INTF , GET_CHILDREN , GET_CHILDREN_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( node ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; } private InstructionList compileDefaultRecursion ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle next ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final String applyTemplatesSig = classGen . getApplyTemplatesSig ( ) ; final int git = cpg . addInterfaceMethodref ( DOM_INTF , GET_CHILDREN , GET_CHILDREN_SIG ) ; final int applyTemplates = cpg . addMethodref ( getClassName ( ) , functionName ( ) , applyTemplatesSig ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( _currentIndex ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( applyTemplates ) ) ; il . append ( new GOTO_W ( next ) ) ; return il ; } private InstructionList compileDefaultText ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle next ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final int chars = cpg . addInterfaceMethodref ( DOM_INTF , CHARACTERS , CHARACTERS_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( _currentIndex ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEINTERFACE ( chars , 3 ) ) ; il . append ( new GOTO_W ( next ) ) ; return il ; } private InstructionList compileNamespaces ( ClassGenerator classGen , MethodGenerator methodGen , boolean [ ] isNamespace , boolean [ ] isAttribute , boolean attrFlag , InstructionHandle defaultTarget ) { final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final Vector namespaces = xsltc . getNamespaceIndex ( ) ; final Vector names = xsltc . getNamesIndex ( ) ; final int namespaceCount = namespaces . size ( ) + 1 ; final int namesCount = names . size ( ) ; final InstructionList il = new InstructionList ( ) ; final int [ ] types = new int [ namespaceCount ] ; final InstructionHandle [ ] targets = new InstructionHandle [ types . length ] ; if ( namespaceCount > 0 ) { boolean compiled = false ; for ( int i = 0 ; i < namespaceCount ; i ++ ) { targets [ i ] = defaultTarget ; types [ i ] = i ; } for ( int i = DTM . NTYPES ; i < ( DTM . NTYPES + namesCount ) ; i ++ ) { if ( ( isNamespace [ i ] ) && ( isAttribute [ i ] == attrFlag ) ) { String name = ( String ) names . elementAt ( i - DTM . NTYPES ) ; String namespace = name . substring ( 0 , name . lastIndexOf ( ':' ) ) ; final int type = xsltc . registerNamespace ( namespace ) ; if ( ( i < _testSeq . length ) && ( _testSeq [ i ] != null ) ) { targets [ type ] = ( _testSeq [ i ] ) . compile ( classGen , methodGen , defaultTarget ) ; compiled = true ; } } } if ( ! compiled ) return ( null ) ; final int getNS = cpg . addInterfaceMethodref ( DOM_INTF , "getNamespaceType" , "(I)I" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( _currentIndex ) ) ; il . append ( new INVOKEINTERFACE ( getNS , 2 ) ) ; il . append ( new SWITCH ( types , targets , defaultTarget ) ) ; return ( il ) ; } else { return ( null ) ; } } public void compileApplyTemplates ( ClassGenerator classGen ) { final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final Vector names = xsltc . getNamesIndex ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 3 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; final String [ ] argNames = new String [ 3 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = ITERATOR_PNAME ; argNames [ 2 ] = TRANSLET_OUTPUT_PNAME ; final InstructionList mainIL = new InstructionList ( ) ; final MethodGenerator methodGen = new MethodGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . VOID , argTypes , argNames , functionName ( ) , getClassName ( ) , mainIL , classGen . getConstantPool ( ) ) ; methodGen . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current ; current = methodGen . addLocalVariable2 ( "current" , org . apache . bcel . generic . Type . INT , mainIL . getEnd ( ) ) ; _currentIndex = current . getIndex ( ) ; final InstructionList body = new InstructionList ( ) ; body . append ( NOP ) ; final InstructionList ilLoop = new InstructionList ( ) ; ilLoop . append ( methodGen . loadIterator ( ) ) ; ilLoop . append ( methodGen . nextNode ( ) ) ; ilLoop . append ( DUP ) ; ilLoop . append ( new ISTORE ( _currentIndex ) ) ; final BranchHandle ifeq = ilLoop . append ( new IFLT ( null ) ) ; final BranchHandle loop = ilLoop . append ( new GOTO_W ( null ) ) ; ifeq . setTarget ( ilLoop . append ( RETURN ) ) ; final InstructionHandle ihLoop = ilLoop . getStart ( ) ; InstructionList ilRecurse = compileDefaultRecursion ( classGen , methodGen , ihLoop ) ; InstructionHandle ihRecurse = ilRecurse . getStart ( ) ; InstructionList ilText = compileDefaultText ( classGen , methodGen , ihLoop ) ; InstructionHandle ihText = ilText . getStart ( ) ; final int [ ] types = new int [ DTM . NTYPES + names . size ( ) ] ; for ( int i = 0 ; i < types . length ; i ++ ) { types [ i ] = i ; } final boolean [ ] isAttribute = new boolean [ types . length ] ; final boolean [ ] isNamespace = new boolean [ types . length ] ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { final String name = ( String ) names . elementAt ( i ) ; isAttribute [ i + DTM . NTYPES ] = isAttributeName ( name ) ; isNamespace [ i + DTM . NTYPES ] = isNamespaceName ( name ) ; } compileTemplates ( classGen , methodGen , ihLoop ) ; final TestSeq elemTest = _testSeq [ DTM . ELEMENT_NODE ] ; InstructionHandle ihElem = ihRecurse ; if ( elemTest != null ) ihElem = elemTest . compile ( classGen , methodGen , ihRecurse ) ; final TestSeq attrTest = _testSeq [ DTM . ATTRIBUTE_NODE ] ; InstructionHandle ihAttr = ihText ; if ( attrTest != null ) ihAttr = attrTest . compile ( classGen , methodGen , ihAttr ) ; InstructionList ilKey = null ; if ( _idxTestSeq != null ) { loop . setTarget ( _idxTestSeq . compile ( classGen , methodGen , body . getStart ( ) ) ) ; ilKey = _idxTestSeq . getInstructionList ( ) ; } else { loop . setTarget ( body . getStart ( ) ) ; } if ( _childNodeTestSeq != null ) { double nodePrio = _childNodeTestSeq . getPriority ( ) ; int nodePos = _childNodeTestSeq . getPosition ( ) ; double elemPrio = ( 0 - Double . MAX_VALUE ) ; int elemPos = Integer . MIN_VALUE ; if ( elemTest != null ) { elemPrio = elemTest . getPriority ( ) ; elemPos = elemTest . getPosition ( ) ; } if ( elemPrio == Double . NaN || elemPrio < nodePrio || ( elemPrio == nodePrio && elemPos < nodePos ) ) { ihElem = _childNodeTestSeq . compile ( classGen , methodGen , ihLoop ) ; } final TestSeq textTest = _testSeq [ DTM . TEXT_NODE ] ; double textPrio = ( 0 - Double . MAX_VALUE ) ; int textPos = Integer . MIN_VALUE ; if ( textTest != null ) { textPrio = textTest . getPriority ( ) ; textPos = textTest . getPosition ( ) ; } if ( textPrio == Double . NaN || textPrio < nodePrio || ( textPrio == nodePrio && textPos < nodePos ) ) { ihText = _childNodeTestSeq . compile ( classGen , methodGen , ihLoop ) ; _testSeq [ DTM . TEXT_NODE ] = _childNodeTestSeq ; } } InstructionHandle elemNamespaceHandle = ihElem ; InstructionList nsElem = compileNamespaces ( classGen , methodGen , isNamespace , isAttribute , false , ihElem ) ; if ( nsElem != null ) elemNamespaceHandle = nsElem . getStart ( ) ; InstructionHandle attrNamespaceHandle = ihAttr ; InstructionList nsAttr = compileNamespaces ( classGen , methodGen , isNamespace , isAttribute , true , ihAttr ) ; if ( nsAttr != null ) attrNamespaceHandle = nsAttr . getStart ( ) ; final InstructionHandle [ ] targets = new InstructionHandle [ types . length ] ; for ( int i = DTM . NTYPES ; i < targets . length ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( isNamespace [ i ] ) { if ( isAttribute [ i ] ) targets [ i ] = attrNamespaceHandle ; else targets [ i ] = elemNamespaceHandle ; } else if ( testSeq != null ) { if ( isAttribute [ i ] ) targets [ i ] = testSeq . compile ( classGen , methodGen , attrNamespaceHandle ) ; else targets [ i ] = testSeq . compile ( classGen , methodGen , elemNamespaceHandle ) ; } else { targets [ i ] = ihLoop ; } } targets [ DTM . ROOT_NODE ] = _rootPattern != null ? getTemplateInstructionHandle ( _rootPattern . getTemplate ( ) ) : ihRecurse ; targets [ DTM . DOCUMENT_NODE ] = _rootPattern != null ? getTemplateInstructionHandle ( _rootPattern . getTemplate ( ) ) : ihRecurse ; targets [ DTM . TEXT_NODE ] = _testSeq [ DTM . TEXT_NODE ] != null ? _testSeq [ DTM . TEXT_NODE ] . compile ( classGen , methodGen , ihText ) : ihText ; targets [ DTM . NAMESPACE_NODE ] = ihLoop ; targets [ DTM . ELEMENT_NODE ] = elemNamespaceHandle ; targets [ DTM . ATTRIBUTE_NODE ] = attrNamespaceHandle ; InstructionHandle ihPI = ihLoop ; if ( _childNodeTestSeq != null ) ihPI = ihElem ; if ( _testSeq [ DTM . PROCESSING_INSTRUCTION_NODE ] != null ) targets [ DTM . PROCESSING_INSTRUCTION_NODE ] = _testSeq [ DTM . PROCESSING_INSTRUCTION_NODE ] . compile ( classGen , methodGen , ihPI ) ; else targets [ DTM . PROCESSING_INSTRUCTION_NODE ] = ihPI ; InstructionHandle ihComment = ihLoop ; if ( _childNodeTestSeq != null ) ihComment = ihElem ; targets [ DTM . COMMENT_NODE ] = _testSeq [ DTM . COMMENT_NODE ] != null ? _testSeq [ DTM . COMMENT_NODE ] . compile ( classGen , methodGen , ihComment ) : ihComment ; targets [ DTM . CDATA_SECTION_NODE ] = ihLoop ; targets [ DTM . DOCUMENT_FRAGMENT_NODE ] = ihLoop ; targets [ DTM . DOCUMENT_TYPE_NODE ] = ihLoop ; targets [ DTM . ENTITY_NODE ] = ihLoop ; targets [ DTM . ENTITY_REFERENCE_NODE ] = ihLoop ; targets [ DTM . NOTATION_NODE ] = ihLoop ; for ( int i = DTM . NTYPES ; i < targets . length ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( ( testSeq == null ) || ( isNamespace [ i ] ) ) { if ( isAttribute [ i ] ) targets [ i ] = attrNamespaceHandle ; else targets [ i ] = elemNamespaceHandle ; } else { if ( isAttribute [ i ] ) targets [ i ] = testSeq . compile ( classGen , methodGen , attrNamespaceHandle ) ; else targets [ i ] = testSeq . compile ( classGen , methodGen , elemNamespaceHandle ) ; } } if ( ilKey != null ) body . insert ( ilKey ) ; final int getType = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; body . append ( methodGen . loadDOM ( ) ) ; body . append ( new ILOAD ( _currentIndex ) ) ; body . append ( new INVOKEINTERFACE ( getType , 2 ) ) ; InstructionHandle disp = body . append ( new SWITCH ( types , targets , ihLoop ) ) ; appendTestSequences ( body ) ; appendTemplateCode ( body ) ; if ( nsElem != null ) body . append ( nsElem ) ; if ( nsAttr != null ) body . append ( nsAttr ) ; body . append ( ilRecurse ) ; body . append ( ilText ) ; mainIL . append ( new GOTO_W ( ihLoop ) ) ; mainIL . append ( body ) ; mainIL . append ( ilLoop ) ; peepHoleOptimization ( methodGen ) ; methodGen . stripAttributes ( true ) ; methodGen . setMaxLocals ( ) ; methodGen . setMaxStack ( ) ; methodGen . removeNOPs ( ) ; classGen . addMethod ( methodGen . getMethod ( ) ) ; if ( _importLevels != null ) { Enumeration levels = _importLevels . keys ( ) ; while ( levels . hasMoreElements ( ) ) { Integer max = ( Integer ) levels . nextElement ( ) ; Integer min = ( Integer ) _importLevels . get ( max ) ; compileApplyImports ( classGen , min . intValue ( ) , max . intValue ( ) ) ; } } } private void compileTemplateCalls ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle next , int min , int max ) { Enumeration templates = _neededTemplates . keys ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; final int prec = template . getImportPrecedence ( ) ; if ( ( prec >= min ) && ( prec < max ) ) { if ( template . hasContents ( ) ) { InstructionList til = template . compile ( classGen , methodGen ) ; til . append ( new GOTO_W ( next ) ) ; _templateILs . put ( template , til ) ; _templateIHs . put ( template , til . getStart ( ) ) ; } else { _templateIHs . put ( template , next ) ; } } } } public void compileApplyImports ( ClassGenerator classGen , int min , int max ) { final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final Vector names = xsltc . getNamesIndex ( ) ; _namedTemplates = new Hashtable ( ) ; _neededTemplates = new Hashtable ( ) ; _templateIHs = new Hashtable ( ) ; _templateILs = new Hashtable ( ) ; _patternGroups = new Vector [ 32 ] ; _rootPattern = null ; Vector oldTemplates = _templates ; _templates = new Vector ( ) ; final Enumeration templates = oldTemplates . elements ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; final int prec = template . getImportPrecedence ( ) ; if ( ( prec >= min ) && ( prec < max ) ) addTemplate ( template ) ; } processPatterns ( _keys ) ; final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 3 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; final String [ ] argNames = new String [ 3 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = ITERATOR_PNAME ; argNames [ 2 ] = TRANSLET_OUTPUT_PNAME ; final InstructionList mainIL = new InstructionList ( ) ; final MethodGenerator methodGen = new MethodGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . VOID , argTypes , argNames , functionName ( ) + '_' + max , getClassName ( ) , mainIL , classGen . getConstantPool ( ) ) ; methodGen . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current ; current = methodGen . addLocalVariable2 ( "current" , org . apache . bcel . generic . Type . INT , mainIL . getEnd ( ) ) ; _currentIndex = current . getIndex ( ) ; final InstructionList body = new InstructionList ( ) ; body . append ( NOP ) ; final InstructionList ilLoop = new InstructionList ( ) ; ilLoop . append ( methodGen . loadIterator ( ) ) ; ilLoop . append ( methodGen . nextNode ( ) ) ; ilLoop . append ( DUP ) ; ilLoop . append ( new ISTORE ( _currentIndex ) ) ; final BranchHandle ifeq = ilLoop . append ( new IFLT ( null ) ) ; final BranchHandle loop = ilLoop . append ( new GOTO_W ( null ) ) ; ifeq . setTarget ( ilLoop . append ( RETURN ) ) ; final InstructionHandle ihLoop = ilLoop . getStart ( ) ; InstructionList ilRecurse = compileDefaultRecursion ( classGen , methodGen , ihLoop ) ; InstructionHandle ihRecurse = ilRecurse . getStart ( ) ; InstructionList ilText = compileDefaultText ( classGen , methodGen , ihLoop ) ; InstructionHandle ihText = ilText . getStart ( ) ; final int [ ] types = new int [ DTM . NTYPES + names . size ( ) ] ; for ( int i = 0 ; i < types . length ; i ++ ) { types [ i ] = i ; } final boolean [ ] isAttribute = new boolean [ types . length ] ; final boolean [ ] isNamespace = new boolean [ types . length ] ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { final String name = ( String ) names . elementAt ( i ) ; isAttribute [ i + DTM . NTYPES ] = isAttributeName ( name ) ; isNamespace [ i + DTM . NTYPES ] = isNamespaceName ( name ) ; } compileTemplateCalls ( classGen , methodGen , ihLoop , min , max ) ; final TestSeq elemTest = _testSeq [ DTM . ELEMENT_NODE ] ; InstructionHandle ihElem = ihRecurse ; if ( elemTest != null ) { ihElem = elemTest . compile ( classGen , methodGen , ihLoop ) ; } final TestSeq attrTest = _testSeq [ DTM . ATTRIBUTE_NODE ] ; InstructionHandle ihAttr = ihLoop ; if ( attrTest != null ) { ihAttr = attrTest . compile ( classGen , methodGen , ihAttr ) ; } InstructionList ilKey = null ; if ( _idxTestSeq != null ) { loop . setTarget ( _idxTestSeq . compile ( classGen , methodGen , body . getStart ( ) ) ) ; ilKey = _idxTestSeq . getInstructionList ( ) ; } else { loop . setTarget ( body . getStart ( ) ) ; } if ( _childNodeTestSeq != null ) { double nodePrio = _childNodeTestSeq . getPriority ( ) ; int nodePos = _childNodeTestSeq . getPosition ( ) ; double elemPrio = ( 0 - Double . MAX_VALUE ) ; int elemPos = Integer . MIN_VALUE ; if ( elemTest != null ) { elemPrio = elemTest . getPriority ( ) ; elemPos = elemTest . getPosition ( ) ; } if ( elemPrio == Double . NaN || elemPrio < nodePrio || ( elemPrio == nodePrio && elemPos < nodePos ) ) { ihElem = _childNodeTestSeq . compile ( classGen , methodGen , ihLoop ) ; } final TestSeq textTest = _testSeq [ DTM . TEXT_NODE ] ; double textPrio = ( 0 - Double . MAX_VALUE ) ; int textPos = Integer . MIN_VALUE ; if ( textTest != null ) { textPrio = textTest . getPriority ( ) ; textPos = textTest . getPosition ( ) ; } if ( textPrio == Double . NaN || textPrio < nodePrio || ( textPrio == nodePrio && textPos < nodePos ) ) { ihText = _childNodeTestSeq . compile ( classGen , methodGen , ihLoop ) ; _testSeq [ DTM . TEXT_NODE ] = _childNodeTestSeq ; } } InstructionHandle elemNamespaceHandle = ihElem ; InstructionList nsElem = compileNamespaces ( classGen , methodGen , isNamespace , isAttribute , false , ihElem ) ; if ( nsElem != null ) elemNamespaceHandle = nsElem . getStart ( ) ; InstructionList nsAttr = compileNamespaces ( classGen , methodGen , isNamespace , isAttribute , true , ihAttr ) ; InstructionHandle attrNamespaceHandle = ihAttr ; if ( nsAttr != null ) attrNamespaceHandle = nsAttr . getStart ( ) ; final InstructionHandle [ ] targets = new InstructionHandle [ types . length ] ; for ( int i = DTM . NTYPES ; i < targets . length ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( isNamespace [ i ] ) { if ( isAttribute [ i ] ) targets [ i ] = attrNamespaceHandle ; else targets [ i ] = elemNamespaceHandle ; } else if ( testSeq != null ) { if ( isAttribute [ i ] ) targets [ i ] = testSeq . compile ( classGen , methodGen , attrNamespaceHandle ) ; else targets [ i ] = testSeq . compile ( classGen , methodGen , elemNamespaceHandle ) ; } else { targets [ i ] = ihLoop ; } } targets [ DTM . ROOT_NODE ] = _rootPattern != null ? getTemplateInstructionHandle ( _rootPattern . getTemplate ( ) ) : ihRecurse ; targets [ DTM . DOCUMENT_NODE ] = _rootPattern != null ? getTemplateInstructionHandle ( _rootPattern . getTemplate ( ) ) : ihRecurse ; targets [ DTM . TEXT_NODE ] = _testSeq [ DTM . TEXT_NODE ] != null ? _testSeq [ DTM . TEXT_NODE ] . compile ( classGen , methodGen , ihText ) : ihText ; targets [ DTM . NAMESPACE_NODE ] = ihLoop ; targets [ DTM . ELEMENT_NODE ] = elemNamespaceHandle ; targets [ DTM . ATTRIBUTE_NODE ] = attrNamespaceHandle ; InstructionHandle ihPI = ihLoop ; if ( _childNodeTestSeq != null ) ihPI = ihElem ; if ( _testSeq [ DTM . PROCESSING_INSTRUCTION_NODE ] != null ) { targets [ DTM . PROCESSING_INSTRUCTION_NODE ] = _testSeq [ DTM . PROCESSING_INSTRUCTION_NODE ] . compile ( classGen , methodGen , ihPI ) ; } else { targets [ DTM . PROCESSING_INSTRUCTION_NODE ] = ihPI ; } InstructionHandle ihComment = ihLoop ; if ( _childNodeTestSeq != null ) ihComment = ihElem ; targets [ DTM . COMMENT_NODE ] = _testSeq [ DTM . COMMENT_NODE ] != null ? _testSeq [ DTM . COMMENT_NODE ] . compile ( classGen , methodGen , ihComment ) : ihComment ; targets [ DTM . CDATA_SECTION_NODE ] = ihLoop ; targets [ DTM . DOCUMENT_FRAGMENT_NODE ] = ihLoop ; targets [ DTM . DOCUMENT_TYPE_NODE ] = ihLoop ; targets [ DTM . ENTITY_NODE ] = ihLoop ; targets [ DTM . ENTITY_REFERENCE_NODE ] = ihLoop ; targets [ DTM . NOTATION_NODE ] = ihLoop ; for ( int i = DTM . NTYPES ; i < targets . length ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( ( testSeq == null ) || ( isNamespace [ i ] ) ) { if ( isAttribute [ i ] ) targets [ i ] = attrNamespaceHandle ; else targets [ i ] = elemNamespaceHandle ; } else { if ( isAttribute [ i ] ) targets [ i ] = testSeq . compile ( classGen , methodGen , attrNamespaceHandle ) ; else targets [ i ] = testSeq . compile ( classGen , methodGen , elemNamespaceHandle ) ; } } if ( ilKey != null ) body . insert ( ilKey ) ; final int getType = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; body . append ( methodGen . loadDOM ( ) ) ; body . append ( new ILOAD ( _currentIndex ) ) ; body . append ( new INVOKEINTERFACE ( getType , 2 ) ) ; InstructionHandle disp = body . append ( new SWITCH ( types , targets , ihLoop ) ) ; appendTestSequences ( body ) ; appendTemplateCode ( body ) ; if ( nsElem != null ) body . append ( nsElem ) ; if ( nsAttr != null ) body . append ( nsAttr ) ; body . append ( ilRecurse ) ; body . append ( ilText ) ; mainIL . append ( new GOTO_W ( ihLoop ) ) ; mainIL . append ( body ) ; mainIL . append ( ilLoop ) ; peepHoleOptimization ( methodGen ) ; methodGen . stripAttributes ( true ) ; methodGen . setMaxLocals ( ) ; methodGen . setMaxStack ( ) ; methodGen . removeNOPs ( ) ; classGen . addMethod ( methodGen . getMethod ( ) ) ; _templates = oldTemplates ; } private void peepHoleOptimization ( MethodGenerator methodGen ) { InstructionList il = methodGen . getInstructionList ( ) ; InstructionFinder find = new InstructionFinder ( il ) ; InstructionHandle ih ; String pattern ; pattern = "`ALOAD'`POP'`Instruction'" ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { if ( ( ! match [ 0 ] . hasTargeters ( ) ) && ( ! match [ 1 ] . hasTargeters ( ) ) ) { il . delete ( match [ 0 ] , match [ 1 ] ) ; } } catch ( TargetLostException e ) { } } pattern = "`ILOAD'`ALOAD'`SWAP'`Instruction'" ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { org . apache . bcel . generic . Instruction iload ; org . apache . bcel . generic . Instruction aload ; if ( ( ! match [ 0 ] . hasTargeters ( ) ) && ( ! match [ 1 ] . hasTargeters ( ) ) && ( ! match [ 2 ] . hasTargeters ( ) ) ) { iload = match [ 0 ] . getInstruction ( ) ; aload = match [ 1 ] . getInstruction ( ) ; il . insert ( match [ 0 ] , aload ) ; il . insert ( match [ 0 ] , iload ) ; il . delete ( match [ 0 ] , match [ 2 ] ) ; } } catch ( TargetLostException e ) { } } pattern = "`ALOAD_1'`ALOAD_1'`Instruction'" ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { org . apache . bcel . generic . Instruction iload ; org . apache . bcel . generic . Instruction aload ; if ( ( ! match [ 0 ] . hasTargeters ( ) ) && ( ! match [ 1 ] . hasTargeters ( ) ) ) { il . insert ( match [ 1 ] , new DUP ( ) ) ; il . delete ( match [ 1 ] ) ; } } catch ( TargetLostException e ) { } } } public InstructionHandle getTemplateInstructionHandle ( Template template ) { return ( InstructionHandle ) _templateIHs . get ( template ) ; } private static boolean isAttributeName ( String qname ) { final int col = qname . lastIndexOf ( ':' ) + 1 ; return ( qname . charAt ( col ) == '@' ) ; } private static boolean isNamespaceName ( String qname ) { final int col = qname . lastIndexOf ( ':' ) ; return ( col > - 1 && qname . charAt ( qname . length ( ) - 1 ) == '*' ) ; } } 	1	['31', '1', '0', '41', '149', '327', '4', '39', '12', '0.853968254', '3124', '1', '7', '0', '0.163306452', '0', '0', '99.09677419', '41', '5.7097', '3']
package org . apache . xml . serializer ; public interface SerializerConstants { static final String CDATA_CONTINUE = "]]]]><![CDATA[>" ; static final String CDATA_DELIMITER_CLOSE = "]]>" ; static final String CDATA_DELIMITER_OPEN = "<![CDATA[" ; static final char [ ] CNTCDATA = CDATA_CONTINUE . toCharArray ( ) ; static final char [ ] BEGCDATA = CDATA_DELIMITER_OPEN . toCharArray ( ) ; static final char [ ] ENDCDATA = CDATA_DELIMITER_CLOSE . toCharArray ( ) ; static final String EMPTYSTRING = "" ; static final String ENTITY_AMP = "&amp;" ; static final String ENTITY_CRLF = "&#xA;" ; static final String ENTITY_GT = "&gt;" ; static final String ENTITY_LT = "&lt;" ; static final String ENTITY_QUOT = "&quot;" ; static final String XML_PREFIX = "xml" ; static final String XMLNS_PREFIX = "xmlns" ; static final String XMLNS_URI = "http://www.w3.org/2000/xmlns/" ; public static final String DEFAULT_SAX_SERIALIZER = "org.apache.xml.serializer.ToXMLSAXHandler" ; } 	1	['1', '1', '0', '1', '2', '0', '1', '0', '0', '2', '27', '0', '0', '0', '0', '0', '0', '10', '0', '0', '2']
package org . apache . xml . serializer ; import java . util . Hashtable ; import java . util . Properties ; import javax . xml . transform . OutputKeys ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . ContentHandler ; public abstract class SerializerFactory { private static Hashtable m_formats = new Hashtable ( ) ; public static Serializer getSerializer ( Properties format ) { Serializer ser ; try { String method = format . getProperty ( OutputKeys . METHOD ) ; if ( method == null ) throw new IllegalArgumentException ( "The output format has a null method name" ) ; String className = format . getProperty ( OutputPropertiesFactory . S_KEY_CONTENT_HANDLER ) ; if ( null == className ) { Properties methodDefaults = OutputPropertiesFactory . getDefaultMethodProperties ( method ) ; className = methodDefaults . getProperty ( OutputPropertiesFactory . S_KEY_CONTENT_HANDLER ) ; if ( null == className ) throw new IllegalArgumentException ( "The output format must have a '" + OutputPropertiesFactory . S_KEY_CONTENT_HANDLER + "' property!" ) ; } ClassLoader loader = ObjectFactory . findClassLoader ( ) ; Class cls = ObjectFactory . findProviderClass ( className , loader , true ) ; Object obj = cls . newInstance ( ) ; if ( obj instanceof SerializationHandler ) { ser = ( Serializer ) cls . newInstance ( ) ; ser . setOutputFormat ( format ) ; } else { if ( obj instanceof ContentHandler ) { className = SerializerConstants . DEFAULT_SAX_SERIALIZER ; cls = ObjectFactory . findProviderClass ( className , loader , true ) ; SerializationHandler sh = ( SerializationHandler ) cls . newInstance ( ) ; sh . setContentHandler ( ( ContentHandler ) obj ) ; sh . setOutputFormat ( format ) ; ser = sh ; } else { throw new Exception ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SERIALIZER_NOT_CONTENTHANDLER , new Object [ ] { className } ) ) ; } } } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } return ser ; } } 	1	['3', '1', '0', '12', '17', '3', '6', '6', '2', '1', '111', '1', '0', '0', '0.5', '0', '0', '35.66666667', '6', '2', '2']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_ca extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "S''ha produït un error intern de temps d''execució a ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Es produeix un error de temps d'execució en executar <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "La conversió de ''{0}'' a ''{1}'' no és vàlida." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "XSLTC no dóna suport a la funció externa ''{0}''." } , { BasisLibrary . EQUALITY_EXPR_ERR , "L'expressió d'igualtat conté un tipus d'argument desconegut." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "La crida a ''{1}'' conté un tipus d''argument ''{0}'' no vàlid." } , { BasisLibrary . FORMAT_NUMBER_ERR , "S''ha intentat donar format al número ''{0}'' mitjançant el patró ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "No es pot clonar l''iterador ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "L''iterador de l''eix ''{0}'' no té suport." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "L''iterador de l''eix escrit ''{0}'' no té suport." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "L''atribut ''{0}'' es troba fora de l''element." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "La declaració d''espai de noms ''{0}''=''{1}'' es troba fora de l''element." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "L''espai de noms del prefix ''{0}'' no s''ha declarat." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter s'ha creat mitjançant un tipus incorrecte de DOM d'origen." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "L'analitzador SAX que feu servir no gestiona esdeveniments de declaració de DTD." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "L'analitzador SAX que feu servir no dóna suport a espais de noms XML." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "No s''ha pogut resoldre la referència d''URI ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_pt_BR extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Função não suportada!" } , { ER_CANNOT_OVERWRITE_CAUSE , "Impossível sobrepor causa" } , { ER_NO_DEFAULT_IMPL , "Nenhuma implementação padrão encontrada" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) não suportado atualmente" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Deslocamento maior que slot" } , { ER_COROUTINE_NOT_AVAIL , "Co-rotina não disponível, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager recebido para pedido co_exit()" } , { ER_COJOINROUTINESET_FAILED , "Falha de co_joinCoroutineSet()" } , { ER_COROUTINE_PARAM , "Erro de parâmetro coroutine ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nINESPERADO: doTerminate do analizador respondeu {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "parse não pode ser chamado durante análise" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Erro: digitado repetidor para eixo {0} não implementado" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Erro: repetidor para eixo {0} não implementado" } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Clone de repetidor não suportado" } , { ER_UNKNOWN_AXIS_TYPE , "Tipo de passagem de eixo desconhecida: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Atravessador de eixo não suportado: {0}" } , { ER_NO_DTMIDS_AVAIL , "Não existem mais IDs de DTM disponíveis" } , { ER_NOT_SUPPORTED , "Não suportado: {0}" } , { ER_NODE_NON_NULL , "O nó não deve ser nulo para getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "Não foi possível resolver o nó para um identificador" } , { ER_STARTPARSE_WHILE_PARSING , "startParse não pode ser chamado durante análise" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse precisa de um SAXParser não-nulo" } , { ER_COULD_NOT_INIT_PARSER , "não foi possível inicializar analisador com" } , { ER_EXCEPTION_CREATING_POOL , "exceção ao criar nova instância para o conjunto" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "O caminho contém seqüência de escape inválida" } , { ER_SCHEME_REQUIRED , "O esquema é obrigatório!" } , { ER_NO_SCHEME_IN_URI , "Nenhum esquema encontrado no URI: {0}" } , { ER_NO_SCHEME_INURI , "Nenhum esquema encontrado no URI" } , { ER_PATH_INVALID_CHAR , "O caminho contém caractere inválido: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Impossível definir esquema a partir da cadeia nula" } , { ER_SCHEME_NOT_CONFORMANT , "O esquema não está em conformidade." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "O host não é um endereço formado corretamente" } , { ER_PORT_WHEN_HOST_NULL , "A porta não pode ser definida quando o host é nulo" } , { ER_INVALID_PORT , "Número de porta inválido" } , { ER_FRAG_FOR_GENERIC_URI , "O fragmento só pode ser definido para um URI genérico" } , { ER_FRAG_WHEN_PATH_NULL , "O fragmento não pode ser definido quando o caminho é nulo" } , { ER_FRAG_INVALID_CHAR , "O fragmento contém caractere inválido" } , { ER_PARSER_IN_USE , "O analisador já está sendo utilizado" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Impossível alterar {0} {1} durante análise" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Auto-causação não permitida" } , { ER_NO_USERINFO_IF_NO_HOST , "Userinfo não pode ser especificado se host não for especificado" } , { ER_NO_PORT_IF_NO_HOST , "Port não pode ser especificado se host não for especificado" } , { ER_NO_QUERY_STRING_IN_PATH , "A cadeia de consulta não pode ser especificada na cadeia de consulta e caminho" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "O fragmento não pode ser especificado no caminho e fragmento" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Impossível inicializar URI com parâmetros vazios" } , { ER_METHOD_NOT_SUPPORTED , "Método ainda não suportado" } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter atualmente não reinicializável" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader não antes do pedido startParse" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Atravessador de eixo não suportado: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler criado com nulo PrintWriter!" } , { ER_SYSTEMID_UNKNOWN , "SystemId Desconhecido" } , { ER_LOCATION_UNKNOWN , "Localização de erro desconhecido" } , { ER_PREFIX_MUST_RESOLVE , "O prefixo deve ser resolvido para um namespace: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() não suportado em XPathContext!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "O atributo child não possui um documento do proprietário!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "O atributo child não possui um elemento de documento do proprietário!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Aviso: impossível emitir texto antes do elemento document! Ignorando..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Impossível ter mais de uma raiz em um DOM!" } , { ER_ARG_LOCALNAME_NULL , "O argumento 'localName' é nulo" } , { ER_ARG_LOCALNAME_INVALID , "Localname em QNAME deve ser um NCName válido" } , { ER_ARG_PREFIX_INVALID , "O prefixo em QNAME deve ser um NCName válido" } , { "BAD_CODE" , "O parâmetro para createMessage estava fora dos limites" } , { "FORMAT_FAILED" , "Exceção emitida durante chamada messageFormat" } , { "line" , "Linha n°" } , { "column" , "Coluna n°" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "A classe de serializador ''{0}'' não implementa org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "O recurso [ {0} ] não pôde ser encontrado.\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "O recurso [ {0} ] não pôde carregar: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Tamanho do buffer <=0" } , { ER_INVALID_UTF16_SURROGATE , "Detectado substituto UTF-16 inválido: {0} ?" } , { ER_OIERROR , "Erro de E/S" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Impossível incluir atributo {0} depois de nós filhos ou antes da geração de um elemento. O atributo será ignorado." } , { ER_NAMESPACE_PREFIX , "Namespace para prefixo ''{0}'' não foi declarado. " } , { ER_STRAY_ATTRIBUTE , "Atributo ''{0}'' fora do elemento. " } , { ER_STRAY_NAMESPACE , "Declaração de namespace ''{0}''=''{1}'' fora do elemento. " } , { ER_COULD_NOT_LOAD_RESOURCE , "Não foi possível carregar ''{0}'' (verifique CLASSPATH), utilizando agora somente os padrões" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "Não foi possível carregar o arquivo de propriedade ''{0}'' para o método de saída ''{1}'' (verifique CLASSPATH)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "pt" , "BR" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_pt_BR extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "A função current() não é permitida em um padrão de correspondência!" } , { ER_CURRENT_TAKES_NO_ARGS , "A função current() não aceita argumentos!" } , { ER_DOCUMENT_REPLACED , "A implementação da função document() foi substituída por org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "context não possui um documento do proprietário!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() possui argumentos em excesso." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() possui argumentos em excesso." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() possui argumentos em excesso." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() possui argumentos em excesso." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() possui argumentos em excesso." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() possui argumentos em excesso." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() possui argumentos em excesso." } , { ER_TRANSLATE_TAKES_3_ARGS , "A função translate() tem três argumentos!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "A função unparsed-entity-uri deve ter um argumento!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "namespace axis ainda não implementado!" } , { ER_UNKNOWN_AXIS , "eixo desconhecido: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "operação de correspondência desconhecida!" } , { ER_INCORRECT_ARG_LENGTH , "O comprimento de arg do teste de nó de processing-instruction() está incorreto! " } , { ER_CANT_CONVERT_TO_NUMBER , "Impossível converter {0} em um número" } , { ER_CANT_CONVERT_TO_NODELIST , "Impossível converter {0} em um NodeList!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Impossível converter {0} em um NodeSetDTM!" } , { ER_CANT_CONVERT_TO_TYPE , "Impossível converter {0} em um tipo {1}" } , { ER_EXPECTED_MATCH_PATTERN , "Padrão de correspondência esperado em getMatchScore!" } , { ER_COULDNOT_GET_VAR_NAMED , "Não foi possível obter a variável {0}" } , { ER_UNKNOWN_OPCODE , "ERRO! Código op desconhecido: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Tokens inválidos extras: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "literal com aspa incorreta... era esperada aspa dupla!" } , { ER_EXPECTED_SINGLE_QUOTE , "literal com aspa incorreta... era esperada aspa simples!" } , { ER_EMPTY_EXPRESSION , "Expressão vazia!" } , { ER_EXPECTED_BUT_FOUND , "Esperado {0}, mas encontrado: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "A declaração do programador está incorreta! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "O argumento boolean(...) não é mais opcional com o rascunho 19990709 XPath." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Encontrado ',' mas sem argumento precedente!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Encontrado ',' mas sem argumento seguinte!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' ou '.[predicate]' é sintaxe inválida.  Utilize então 'self::node()[predicate]'." } , { ER_ILLEGAL_AXIS_NAME , "nome de eixo inválido: {0}" } , { ER_UNKNOWN_NODETYPE , "Tipo de nó desconhecido: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "O literal de padrão ({0}) precisa ser colocado entre aspas!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} não pôde ser formatado para um número!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Não foi possível criar XML TransformerFactory Liaison: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Erro! Não encontrada a expressão xpath select (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "ERRO! Não foi possível encontrar ENDOP após OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Ocorreu um erro!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference fornecido para a variável fora de contexto ou sem definição!  Nome = {0}" } , { ER_AXES_NOT_ALLOWED , "Apenas os eixos child:: e attribute:: são permitidos em padrões de correspondência! Eixos transgredidos = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() possui um número incorreto de argumentos." } , { ER_COUNT_TAKES_1_ARG , "A função count deve ter um argumento!" } , { ER_COULDNOT_FIND_FUNCTION , "Não foi possível localizar a função: {0}" } , { ER_UNSUPPORTED_ENCODING , "Codificação não suportada: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Ocorreu um problema no DTM em getNextSibling... tentando recuperar" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Erro do programador: EmptyNodeList não pode ser gravado." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory não é suportado por XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "O prefixo deve ser resolvido para um namespace: {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (origem InputSource) não suportada no XPathContext! Impossível abrir {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API characters(char ch[]... não tratado pelo DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... não tratado pelo DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison não pode tratar nós do tipo {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper não pode tratar nós do tipo {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse error: SystemID - {0} linha - {1}" } , { ER_XERCES_PARSE_ERROR , "Erro de DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Detectado substituto UTF-16 inválido: {0} ?" } , { ER_OIERROR , "Erro de E/S" } , { ER_CANNOT_CREATE_URL , "Impossível criar url para: {0}" } , { ER_XPATH_READOBJECT , "Em XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "Token function não encontrado." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Impossível lidar com o tipo XPath: {0}" } , { ER_NODESET_NOT_MUTABLE , "Este NodeSet não é mutável" } , { ER_NODESETDTM_NOT_MUTABLE , "Este NodeSetDTM não é mutável" } , { ER_VAR_NOT_RESOLVABLE , "A variável não pode ser resolvida: {0}" } , { ER_NULL_ERROR_HANDLER , "Rotina de tratamento de erros nula" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Declaração do programador: código de opção desconhecido: {0}" } , { ER_ZERO_OR_ONE , "0 ou 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() não suportado por XRTreeFragSelectWrapper" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() não suportado por XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() não suportado para XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Não foi possível encontrar a variável com o nome {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars não pode obter uma cadeia para um argumento" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "O argumento FastStringBuffer não pode ser nulo" } , { ER_TWO_OR_THREE , "2 ou 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Variável acessada antes de ser ligada!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB não pode obter uma cadeia para um argumento!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Erro! Definindo a raiz de um transmissor como nula!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Este NodeSetDTM não pode iterar em um nó anterior!" } , { ER_NODESET_CANNOT_ITERATE , "Este NodeSet não pode iterar em um nó anterior!" } , { ER_NODESETDTM_CANNOT_INDEX , "Este NodeSetDTM não pode executar funções de indexação ou de contagem!" } , { ER_NODESET_CANNOT_INDEX , "Este NodeSet não pode executar funções de indexação ou de contagem!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Impossível chamar setShouldCacheNodes depois de nextNode ter sido chamado!" } , { ER_ONLY_ALLOWS , "{0} permite apenas {1} argumento(s)" } , { ER_UNKNOWN_STEP , "Declaração do programador em getNextStepPos: stepType desconhecido: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Era esperado um caminho de localização relativo após o token '/' ou '//'." } , { ER_EXPECTED_LOC_PATH , "Era esperado um caminho de localização, mas o seguinte token foi encontrado:  {0}" } , { ER_EXPECTED_LOC_STEP , "Era esperada uma etapa de localização após o token '/' ou '//'." } , { ER_EXPECTED_NODE_TEST , "Era esperado um nó correspondente a NCName:* ou QName." } , { ER_EXPECTED_STEP_PATTERN , "Era esperado um padrão de etapa, mas foi encontrado '/'." } , { ER_EXPECTED_REL_PATH_PATTERN , "Era esperado um padrão de caminho relativo." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Impossível converter {0} em um boolean." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Impossível converter {0} em um único nó. Este getter se aplica aos tipos ANY_UNORDERED_NODE_TYPE e FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Impossível obter comprimento de instantâneo no tipo: {0}. Este getter se aplica aos tipos UNORDERED_NODE_SNAPSHOT_TYPE e ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Impossível iterar em tipo de não iterador: {0}" } , { ER_DOC_MUTATED , "Documento alterado desde o retorno do resultado. O iterador é inválido." } , { ER_INVALID_XPATH_TYPE , "Argumento de tipo XPath inválido: {0}" } , { ER_EMPTY_XPATH_RESULT , "Objeto de resultado XPath vazio" } , { ER_INCOMPATIBLE_TYPES , "O tipo retornado: {0} não pode ser forçado no tipo especificado: {1}" } , { ER_NULL_RESOLVER , "Não foi possível resolver o prefixo com um resolvedor de prefixo nulo." } , { ER_CANT_CONVERT_TO_STRING , "Impossível converter {0} em uma cadeia." } , { ER_NON_SNAPSHOT_TYPE , "Impossível chamar snapshotItem no tipo: {0}. Este método se aplica aos tipos UNORDERED_NODE_SNAPSHOT_TYPE e ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "O nó do contexto não pertence ao documento que está ligado a este XPathEvaluator." } , { ER_WRONG_NODETYPE , "O tipo de nó de contexto não é suportado." } , { ER_XPATH_ERROR , "Erro desconhecido em XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "nome de locale na função format-number ainda não tratado!" } , { WG_PROPERTY_NOT_SUPPORTED , "Propriedade XSL não suportada: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Não fazer nada no momento com o namespace {0} na propriedade {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException ao tentar acessar a propriedade do sistema XSL: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Sintaxe antiga: quo(...) não está mais definida no XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath precisa de um objeto derivado para implementar nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "Token function não encontrado." } , { WG_COULDNOT_FIND_FUNCTION , "Não foi possível localizar a função: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Impossível criar URL a partir de: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "A opção -E não é suportada pelo analisador do DTM" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference fornecido para a variável fora de contexto ou sem definição!  Nome = {0}" } , { WG_UNSUPPORTED_ENCODING , "Codificação não suportada: {0}" } , { "ui_language" , "pt" } , { "help_language" , "pt" } , { "language" , "pt" } , { "BAD_CODE" , "O parâmetro para createMessage estava fora dos limites" } , { "FORMAT_FAILED" , "Exceção emitida durante chamada messageFormat" } , { "version" , ">>>>>>> Versão Xalan" } , { "version2" , "<<<<<<<" } , { "yes" , "sim" } , { "line" , "Linha n°" } , { "column" , "Coluna n°" } , { "xsldone" , "XSLProcessor: concluído" } , { "xpath_option" , "opções xpath:" } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath expression]" } , { "optionMatch" , "[-match match pattern (para corresponder diagnósticos)]" } , { "optionAnyExpr" , "Ou apenas uma expressão xpath executará um dump de diagnóstico" } , { "noParsermsg1" , "O Processo XSL não obteve êxito." } , { "noParsermsg2" , "** Não foi possível encontrar o analisador **" } , { "noParsermsg3" , "Verifique seu classpath." } , { "noParsermsg4" , "Se você não tiver o XML Parser para Java da IBM, poderá fazer o download dele a partir de" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Erro: " ; public static final String WARNING_HEADER = "Aviso: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PADRÃO " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "pt" , "BR" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_pt_BR extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Erro: Impossível ter '{' na expressão" } , { ER_ILLEGAL_ATTRIBUTE , "{0} possui um atributo inválido: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode é nulo em xsl:apply-imports!" } , { ER_CANNOT_ADD , "Impossível incluir {0} em {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode é nulo em handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "{0} deve ter um atributo name." } , { ER_TEMPLATE_NOT_FOUND , "Não foi possível localizar o gabarito: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Não foi possível resolver nome AVT em xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} requer o atributo: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} deve ter um atributo ''test''." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Valor inválido no atributo de nível: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "O nome de processing-instruction não pode ser 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "O nome de processing-instruction deve ser um NCName válido: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} deve ter um atributo de correspondência se tiver um modo." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} requer um nome ou um atributo de correspondência." } , { ER_CANT_RESOLVE_NSPREFIX , "Impossível resolver prefixo de namespace: {0}" } , { ER_ILLEGAL_VALUE , "xml:space possui um valor inválido: {0}" } , { ER_NO_OWNERDOC , "O nó filho não possui um documento do proprietário!" } , { ER_ELEMTEMPLATEELEM_ERR , "Erro de ElemTemplateElement: {0}" } , { ER_NULL_CHILD , "Tentando incluir um filho nulo!" } , { ER_NEED_SELECT_ATTRIB , "{0} requer um atributo select." } , { ER_NEED_TEST_ATTRIB , "xsl:when deve ter um atributo 'test'." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param deve ter um atributo 'name'." } , { ER_NO_CONTEXT_OWNERDOC , "context não possui um documento do proprietário!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Não foi possível criar XML TransformerFactory Liaison: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: O processo não foi bem-sucedido." } , { ER_NOT_SUCCESSFUL , "Xalan: não foi bem-sucedido." } , { ER_ENCODING_NOT_SUPPORTED , "Codificação não suportada: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Não foi possível criar TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key requer um atributo 'name'!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key requer um atributo 'match'!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key requer um atributo 'use'!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} requer um atributo ''elements''!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) Está faltando o atributo ''prefix'' de {0}" } , { ER_BAD_STYLESHEET_URL , "A URL da página de estilo é inválida: {0}" } , { ER_FILE_NOT_FOUND , "O arquivo da página de estilo não foi encontrado: {0}" } , { ER_IOEXCEPTION , "Ocorreu uma Exceção de E/S (entrada/saída) no arquivo de página de estilo: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Não foi possível encontrar o atributo href para {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} está incluindo a si mesmo, direta ou indiretamente!" } , { ER_PROCESSINCLUDE_ERROR , "Erro de StylesheetHandler.processInclude, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) Está faltando o atributo ''lang'' de {0}" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) Elemento {0} aplicado incorretamente?? Está faltando o elemento de contêiner ''component''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "A saída pode ser apenas para um Element, DocumentFragment, Document ou PrintWriter." } , { ER_PROCESS_ERROR , "Erro de StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "Erro de UnImplNode: {0}" } , { ER_NO_SELECT_EXPRESSION , "Erro! Não encontrada a expressão xpath select (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Não é possível serializar um XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "A entrada de folha de estilo não foi especificada!" } , { ER_FAILED_PROCESS_STYLESHEET , "Falha ao processar folha de estilo!" } , { ER_COULDNT_PARSE_DOC , "Não foi possível analisar o documento {0}!" } , { ER_COULDNT_FIND_FRAGMENT , "Não foi possível localizar o fragmento: {0}" } , { ER_NODE_NOT_ELEMENT , "O nó apontado por um identificador de fragmento não era um elemento: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each deve ter um atributo match ou name" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "templates deve ter um atributo match ou name" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Nenhum clone de fragmento de documento!" } , { ER_CANT_CREATE_ITEM , "Impossível criar item na árvore de resultados: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space no XML de origem possui um valor inválido: {0}" } , { ER_NO_XSLKEY_DECLARATION , "Não existe nenhuma declaração xsl:key para {0}!" } , { ER_CANT_CREATE_URL , "Erro! Impossível criar url para: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions não é suportado" } , { ER_PROCESSOR_ERROR , "Erro de XSLT TransformerFactory" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} não permitido dentro de uma folha de estilo!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns não é mais suportado!  Utilize então xsl:output." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space não é mais suportado!  Utilize então xsl:strip-space ou xsl:preserve-space." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result não é mais suportado!  Utilize então xsl:output." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} possui um atributo inválido: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Elemento XSL desconhecido: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort somente pode ser utilizado com xsl:apply-templates ou xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when aplicado incorretamente!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when não está ligado a xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise aplicado incorretamente!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise não está ligado a xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} não é permitido dentro de um gabarito!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) o namespace de extensão {0} possui prefixo {1} desconhecido" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Importações só podem ocorrer como os primeiros elementos na folha de estilo!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} está importando a si mesmo, direta ou indiretamente!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:space tem um valor inválido: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet não obteve êxito!" } , { ER_SAX_EXCEPTION , "Exceção de SAX" } , { ER_XSLT_ERROR , "Erro de XSLT" } , { ER_CURRENCY_SIGN_ILLEGAL , "O sinal monetário não é permitido na cadeia de padrões de formato" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Função Document não suportada no DOM da Folha de Estilo!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Impossível resolver prefixo de solucionador sem Prefixo!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Redirecionar extensão: Não foi possível obter o nome do arquivo - o atributo file ou select deve retornar uma cadeia válida." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Impossível construir FormatterListener em Redirecionar extensão!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "O prefixo em exclude-result-prefixes não é válido: {0}" } , { ER_MISSING_NS_URI , "URI de namespace ausente para o prefixo especificado" } , { ER_MISSING_ARG_FOR_OPTION , "Argumento ausente para a opção: {0}" } , { ER_INVALID_OPTION , "Opção inválida: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Cadeia com problemas de formatação: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet requer um atributo 'version'!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Atributo: {0} possui um valor inválido: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose requer um xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports não permitido em um xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Impossível utilizar um DTMLiaison para um nó DOM de saída... transmita um org.apache.xpath.DOM2Helper no lugar!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Impossível utilizar um DTMLiaison para um nó DOM de entrada... transmita um org.apache.xpath.DOM2Helper no lugar!" } , { ER_CALL_TO_EXT_FAILED , "Falha na chamada do elemento da extensão: {0}" } , { ER_PREFIX_MUST_RESOLVE , "O prefixo deve ser resolvido para um namespace: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Detectado substituto UTF-16 inválido: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} utilizou a si mesmo, o que causará um loop infinito." } , { ER_CANNOT_MIX_XERCESDOM , "Impossível misturar entrada não Xerces-DOM com saída Xerces-DOM!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "Em ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Encontrado mais de um gabarito chamado: {0}" } , { ER_INVALID_KEY_CALL , "Chamada de função inválida: chamadas key() recursivas não são permitidas" } , { ER_REFERENCING_ITSELF , "A variável {0} está fazendo referência a si mesmo, direta ou indiretamente!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "O nó de entrada não pode ser nulo para um DOMSource de newTemplates!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Arquivo de classe não encontrado para a opção {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Elemento requerido não encontrado: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream não pode ser nulo" } , { ER_URI_CANNOT_BE_NULL , "URI não pode ser nulo" } , { ER_FILE_CANNOT_BE_NULL , "File não pode ser nulo" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource não pode ser nulo" } , { ER_CANNOT_INIT_BSFMGR , "Não foi possível inicializar o BSF Manager" } , { ER_CANNOT_CMPL_EXTENSN , "Não foi possível compilar a extensão" } , { ER_CANNOT_CREATE_EXTENSN , "Não foi possível criar extensão: {0} devido a: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "A chamada do método da instância para o método {0} requer uma instância Object como primeiro argumento" } , { ER_INVALID_ELEMENT_NAME , "Especificado nome de elemento inválido {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "O método do nome de elemento deve ser estático {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "A função de extensão {0} : {1} é desconhecida" } , { ER_MORE_MATCH_CONSTRUCTOR , "Mais de uma correspondência principal para o construtor de {0}" } , { ER_MORE_MATCH_METHOD , "Mais de uma correspondência principal para o método {0}" } , { ER_MORE_MATCH_ELEMENT , "Mais de uma correspondência principal para o método do elemento {0}" } , { ER_INVALID_CONTEXT_PASSED , "Contexto inválido transmitido para avaliar {0}" } , { ER_POOL_EXISTS , "O conjunto já existe" } , { ER_NO_DRIVER_NAME , "Nenhum Nome de driver foi especificado" } , { ER_NO_URL , "Nenhuma URL especificada" } , { ER_POOL_SIZE_LESSTHAN_ONE , "O tamanho do conjunto é menor que um!" } , { ER_INVALID_DRIVER , "Especificado nome de driver inválido!" } , { ER_NO_STYLESHEETROOT , "Não encontrada a raiz da folha de estilo!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Valor inválido para xml:space" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode falhou" } , { ER_RESOURCE_COULD_NOT_LOAD , "O recurso [ {0} ] não pôde carregar: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Tamanho do buffer <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Erro desconhecido ao chamar a extensão" } , { ER_NO_NAMESPACE_DECL , "O prefixo {0} não possui uma declaração de namespace correspondente" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Conteúdo de elemento não permitido para lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Finalização direcionada por folha de estilo" } , { ER_ONE_OR_TWO , "1 ou 2" } , { ER_TWO_OR_THREE , "2 ou 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Não foi possível carregar {0} (verificar CLASSPATH); utilizando apenas os padrões" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Impossível inicializar gabaritos padrão" } , { ER_RESULT_NULL , "O resultado não deve ser nulo" } , { ER_RESULT_COULD_NOT_BE_SET , "O resultado não pôde ser definido" } , { ER_NO_OUTPUT_SPECIFIED , "Nenhuma saída especificada" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Impossível transformar em um Resultado do tipo {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Impossível transformar uma Origem do tipo {0}" } , { ER_NULL_CONTENT_HANDLER , "Rotina de tratamento de conteúdo nula" } , { ER_NULL_ERROR_HANDLER , "Rotina de tratamento de erros nula" } , { ER_CANNOT_CALL_PARSE , "parse não pode ser chamado se ContentHandler não tiver sido definido" } , { ER_NO_PARENT_FOR_FILTER , "Nenhum pai para o filtro" } , { ER_NO_STYLESHEET_IN_MEDIA , "Nenhuma página de estilo foi encontrada em: {0}, mídia= {1}" } , { ER_NO_STYLESHEET_PI , "Nenhum PI xml-stylesheet encontrado em: {0}" } , { ER_NOT_SUPPORTED , "Não suportado: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "O valor para a propriedade {0} deve ser uma instância Booleana" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "Não foi possível obter script externo em {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "O recurso [ {0} ] não pôde ser encontrado.\n{1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Propriedade de saída não reconhecida: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Falha ao criar a instância ElemLiteralResult" } , { ER_VALUE_SHOULD_BE_NUMBER , "O valor para {0} deve conter um número analisável" } , { ER_VALUE_SHOULD_EQUAL , "O valor de {0} deve ser igual a yes ou no" } , { ER_FAILED_CALLING_METHOD , "Falha ao chamar o método {0}" } , { ER_FAILED_CREATING_ELEMTMPL , "Falha ao criar a instância ElemTemplateElement" } , { ER_CHARS_NOT_ALLOWED , "Não são permitidos caracteres neste ponto do documento" } , { ER_ATTR_NOT_ALLOWED , "O atributo \"{0}\" não é permitido no elemento {1}!" } , { ER_BAD_VALUE , "{0} possui valor inválido {1}" } , { ER_ATTRIB_VALUE_NOT_FOUND , "Valor do atributo {0} não encontrado" } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "Valor do atributo {0} não reconhecido" } , { ER_NULL_URI_NAMESPACE , "Tentando gerar um prefixo de namespace com URI nulo" } , { ER_NUMBER_TOO_BIG , "Tentando formatar um número superior ao maior inteiro Longo" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Impossível encontrar a classe de driver SAX1 {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "Classe de driver SAX1 {0} encontrada, mas não pode ser carregada" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "Classe de driver SAX1 {0} carregada, mas não pode ser instanciada" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "A classe de driver SAX1 {0} não implementa org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Propriedade de sistema org.xml.sax.parser não especificada" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "O argumento Parser não deve ser nulo" } , { ER_FEATURE , "Recurso: {0}" } , { ER_PROPERTY , "Propriedade: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Solucionador de entidade nulo" } , { ER_NULL_DTD_HANDLER , "Rotina de tratamento DTD nula" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Nenhum Nome de Driver Especificado!" } , { ER_NO_URL_SPECIFIED , "Nenhuma URL Especificada!" } , { ER_POOLSIZE_LESS_THAN_ONE , "O tamanho do conjunto é menor que 1!" } , { ER_INVALID_DRIVER_NAME , "Especificado Nome de Driver Inválido!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Erro do programador! expr não possui pai ElemTemplateElement!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Declaração do programador em RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} não é permitido nesta posição na página de estilo!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "O texto sem espaço em branco não é permitido nesta posição na página de estilo!" } , { INVALID_TCHAR , "Valor inválido: {1} utilizado para o caractere CHAR: {0}. Um atributo de tipo CHAR deve ter apenas 1 caractere!" } , { INVALID_QNAME , "Valor inválido: {1} utilizado para o atributo QNAME: {0}" } , { INVALID_ENUM , "Valor inválido: {1} utilizado para o atributo ENUM: {0}. Os valores válidos são: {2}." } , { INVALID_NMTOKEN , "Valor inválido: {1} utilizado para o atributo NMTOKEN: {0}" } , { INVALID_NCNAME , "Valor inválido: {1} utilizado para o atributo NCNAME: {0}" } , { INVALID_BOOLEAN , "Valor inválido: {1} utilizado para o atributo boolean: {0}" } , { INVALID_NUMBER , "Valor inválido: {1} utilizado para o atributo number: {0}" } , { ER_ARG_LITERAL , "Argumento para {0} no padrão de correspondência deve ser um literal." } , { ER_DUPLICATE_GLOBAL_VAR , "Declaração de variável global duplicada." } , { ER_DUPLICATE_VAR , "Declaração de variável duplicada." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template deve ter um atributo name ou match (ou ambos)" } , { ER_INVALID_PREFIX , "O prefixo em exclude-result-prefixes não é válido: {0}" } , { ER_NO_ATTRIB_SET , "O attribute-set {0} não existe" } , { WG_FOUND_CURLYBRACE , "Encontrado '}', mas nenhum gabarito de atributo aberto!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Aviso: o atributo count não corresponde a um predecessor em xsl:number! Destino = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Sintaxe antiga: O nome do atributo 'expr' foi alterado para 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan ainda não trata do nome de locale na função format-number." } , { WG_LOCALE_NOT_FOUND , "Aviso: Não foi possível localizar o locale para xml:lang={0}" } , { WG_CANNOT_MAKE_URL_FROM , "Impossível criar URL a partir de: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Impossível carregar doc solicitado: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Impossível localizar Intercalador para <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Sintaxe antiga: a instrução functions deve utilizar uma url de {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "codificação não suportada: {0}, utilizando UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "codificação não suportada: {0}, utilizando Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Encontrados conflitos de especificação: O último {0} encontrado na página de estilo será utilizado." } , { WG_PARSING_AND_PREPARING , "========= Análise e preparação {0} ==========" } , { WG_ATTR_TEMPLATE , "Gabarito de Atr, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Conflito de correspondência entre xsl:strip-space e xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan ainda não trata do atributo {0}!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Nenhuma declaração encontrada para formato decimal: {0}" } , { WG_OLD_XSLT_NS , "Namespace XSLT ausente ou incorreto." } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Apenas uma declaração padrão xsl:decimal-format é permitida." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "Os nomes de xsl:decimal-format devem ser exclusivos. O nome \"{0}\" foi duplicado." } , { WG_ILLEGAL_ATTRIBUTE , "{0} possui um atributo inválido: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Não foi possível resolver prefixo de namespace: {0}. O nó será ignorado." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet requer um atributo 'version'!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Nome de atributo inválido: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Valor inválido utilizado para o atributo {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "O nodeset resultante do segundo argumento da função document está vazio. Retornar um node-set vazio." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "O valor do atributo 'name' do nome xsl:processing-instruction não deve ser 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "O valor do atributo 'name' de xsl:processing-instruction deve ser um NCName válido: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Impossível incluir atributo {0} depois de nós filhos ou antes da geração de um elemento. O atributo será ignorado." } , { "ui_language" , "pt" } , { "help_language" , "pt" } , { "language" , "pt" } , { "BAD_CODE" , "O parâmetro para createMessage estava fora dos limites" } , { "FORMAT_FAILED" , "Exceção emitida durante chamada messageFormat" } , { "version" , ">>>>>>> Versão Xalan" } , { "version2" , "<<<<<<<" } , { "yes" , "sim" } , { "line" , "Linha n°" } , { "column" , "Coluna n°" } , { "xsldone" , "XSLProcessor: concluído" } , { "xslProc_option" , "Opções da classe Process da linha de comando de Xalan-J:" } , { "xslProc_option" , "Opções da classe Process da linha de comandos de Xalan-J:" } , { "xslProc_invalid_xsltc_option" , "A opção {0} não é suportada no modo XSLTC." } , { "xslProc_invalid_xalan_option" , "A opção {0} somente pode ser utilizada com -XSLTC." } , { "xslProc_no_input" , "Erro: Nenhuma página de estilo ou xml de entrada foi especificado. Execute este comando sem nenhuma opção para instruções de uso." } , { "xslProc_common_options" , "-Opções Comuns-" } , { "xslProc_xalan_options" , "-Opções para Xalan-" } , { "xslProc_xsltc_options" , "-Opções para XSLTC-" } , { "xslProc_return_to_continue" , "(pressione <return> para continuar)" } , { "optionXSLTC" , "   [-XSLTC (utilizar XSLTC para transformação)]" } , { "optionIN" , "   [-IN inputXMLURL]" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER nome completo da classe do analisador liaison]" } , { "optionE" , "   [-E (Não expandir refs de entidade)]" } , { "optionV" , "   [-E (Não expandir refs de entidade)]" } , { "optionQC" , "   [-QC (Avisos de Conflitos de Padrão Silencioso)]" } , { "optionQ" , "   [-Q  (Modo Silencioso)]" } , { "optionLF" , "   [-LF (Utilizar avanços de linha apenas na saída {padrão é CR/LF})]" } , { "optionCR" , "   [-CR (Utilizar retornos de carro apenas na saída {padrão é CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Quais caracteres de escape {padrão é <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Controlar como os espaços são recuados {padrão é 0})]" } , { "optionTT" , "   [-TT (Rastrear os gabaritos enquanto estão sendo chamados.)]" } , { "optionTG" , "   [-TG (Rastrear cada evento de geração.)]" } , { "optionTS" , "   [-TS (Rastrear cada evento de seleção.)]" } , { "optionTTC" , "   [-TTC (Rastrear os filhos do modelo enquanto estão sendo processados.)]" } , { "optionTCLASS" , "   [-TCLASS (Classe TraceListener para extensões de rastreio.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Definir se ocorrer validação. A validação fica desativada por padrão.)]" } , { "optionEDUMP" , "   [-EDUMP {nome de arquivo opcional} (Executar stackdump sob erro.)]" } , { "optionXML" , "   [-XML (Utilizar formatador XML e incluir cabeçalho XML.)]" } , { "optionTEXT" , "   [-TEXT (Utilizar formatador de Texto simples.)]" } , { "optionHTML" , "   [-HTML (Utilizar formatador HTML.)]" } , { "optionPARAM" , "   [-PARAM expressão de nome (Definir um parâmetro stylesheet)]" } , { "noParsermsg1" , "O Processo XSL não obteve êxito." } , { "noParsermsg2" , "** Não foi possível encontrar o analisador **" } , { "noParsermsg3" , "Verifique seu classpath." } , { "noParsermsg4" , "Se você não tiver o XML Parser para Java da IBM, poderá fazer o download dele a partir de" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER nome completo da classe (URIResolver a ser utilizado para resolver URIs)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER nome completo da classe (EntityResolver a ser utilizado para resolver entidades)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER nome completo da classe (ContentHandler a ser utilizado para serializar saída)]" } , { "optionLINENUMBERS" , "   [-L utilizar números de linha para documento de origem]" } , { "optionMEDIA" , "   [-MEDIA mediaType (utilizar atributo de mídia para encontrar folha de estilo associada a um documento.)]" } , { "optionFLAVOR" , "   [-FLAVOR flavorName (Utilizar explicitamente s2s=SAX ou d2d=DOM para executar transformação.)]" } , { "optionDIAG" , "   [-DIAG (Imprimir total de milissegundos que a transformação gastou.)]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL (pedir construção incremental de DTM definindo http://xml.apache.org/xalan/features/incremental verdadeiro.)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE (pedir processamento de otimização sem folha de estilo definindo http://xml.apache.org/xalan/features/optimize falso.)]" } , { "optionRL" , "   [-RL recursionlimit (declarar limite numérico em profundidade de recorrência de folha de estilo.)]" } , { "optionXO" , "   [-XO [transletName] (atribuir nome ao translet gerado)]" } , { "optionXD" , "   [-XD destinationDirectory (especificar um diretório de destino para translet)]" } , { "optionXJ" , "   [-XJ jarfile (empacota classes translet em um arquivo jar denominado <jarfile>)]" } , { "optionXP" , "   [-XP package (especifica um prefixo de nome de pacote para todas as classes translet geradas)]" } , { "optionXN" , "   [-XN (ativa a seqüência de gabaritos)]" } , { "optionXX" , "   [-XX (ativa a saída de mensagem de depuração adicional)]" } , { "optionXT" , "   [-XT (utilizar translet para transformação, se possível)]" } , { "diagTiming" , " --------- Transformação de {0} via {1} levou {2} ms" } , { "recursionTooDeep" , "Aninhamento de gabaritos muito extenso. aninhamento = {0}, gabarito {1} {2}" } , { "nameIs" , "o nome é" } , { "matchPatternIs" , "o padrão de correspondência é" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Erro: " ; public static final String WARNING_HEADER = "Aviso: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PADRÃO " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "pt" , "BR" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xalan . transformer ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . KeyDeclaration ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . axes . OneStepIteratorForward ; public class KeyIterator extends OneStepIteratorForward { private QName m_name ; public QName getName ( ) { return m_name ; } private Vector m_keyDeclarations ; public Vector getKeyDeclarations ( ) { return m_keyDeclarations ; } KeyIterator ( QName name , Vector keyDeclarations ) { super ( Axis . ALL ) ; m_keyDeclarations = keyDeclarations ; m_name = name ; } public short acceptNode ( int testNode ) { boolean foundKey = false ; KeyIterator ki = ( KeyIterator ) m_lpi ; org . apache . xpath . XPathContext xctxt = ki . getXPathContext ( ) ; Vector keys = ki . getKeyDeclarations ( ) ; QName name = ki . getName ( ) ; try { int nDeclarations = keys . size ( ) ; for ( int i = 0 ; i < nDeclarations ; i ++ ) { KeyDeclaration kd = ( KeyDeclaration ) keys . elementAt ( i ) ; if ( ! kd . getName ( ) . equals ( name ) ) continue ; foundKey = true ; XPath matchExpr = kd . getMatch ( ) ; double score = matchExpr . getMatchScore ( xctxt , testNode ) ; if ( score == kd . getMatch ( ) . MATCH_SCORE_NONE ) continue ; return DTMIterator . FILTER_ACCEPT ; } } catch ( TransformerException se ) { } if ( ! foundKey ) throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_XSLKEY_DECLARATION , new Object [ ] { name . getLocalName ( ) } ) ) ; return DTMIterator . FILTER_REJECT ; } } 	1	['4', '8', '0', '9', '15', '2', '2', '7', '3', '0.333333333', '97', '1', '1', '0.978571429', '0.4375', '2', '2', '22.75', '4', '1.5', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class AbsoluteLocationPath extends Expression { private Expression _path ; public AbsoluteLocationPath ( ) { _path = null ; } public AbsoluteLocationPath ( Expression path ) { _path = path ; if ( path != null ) { _path . setParent ( this ) ; } } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _path != null ) { _path . setParser ( parser ) ; } } public Expression getPath ( ) { return ( _path ) ; } public String toString ( ) { return "AbsoluteLocationPath(" + ( _path != null ? _path . toString ( ) : "null" ) + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _path != null ) { final Type ptype = _path . typeCheck ( stable ) ; if ( ptype instanceof NodeType ) { _path = new CastExpr ( _path , Type . NodeSet ) ; } } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _path != null ) { final int initAI = cpg . addMethodref ( ABSOLUTE_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( ABSOLUTE_ITERATOR ) ) ) ; il . append ( DUP ) ; _path . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( initAI ) ) ; } else { final int gitr = cpg . addInterfaceMethodref ( DOM_INTF , "getIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEINTERFACE ( gitr , 1 ) ) ; } } } 	1	['7', '3', '0', '19', '28', '0', '1', '18', '7', '0', '143', '1', '1', '0.934210526', '0.285714286', '2', '7', '19.28571429', '2', '1.1429', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_ja extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "current() 関数はパターンのマッチングでは許可されていません!" } , { ER_CURRENT_TAKES_NO_ARGS , "current() 関数は引き数を受け入れません!" } , { ER_DOCUMENT_REPLACED , "document() 関数のインプリメンテーションが org.apache.xalan.xslt.FuncDocument により置き換えられました!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "コンテキストに所有者文書がありません!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() の引き数が多すぎます。" } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() の引き数が多すぎます。" } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() の引き数が多すぎます。" } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() の引き数が多すぎます。" } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() の引き数が多すぎます。" } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() の引き数が多すぎます。" } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() の引き数が多すぎます。" } , { ER_TRANSLATE_TAKES_3_ARGS , "translate() 関数は 3 個の引き数を使用します!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "unparsed-entity-uri 関数は引き数を 1 個使用します!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "namespace axis がまだインプリメントされていません!" } , { ER_UNKNOWN_AXIS , "不明な軸: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "不明のマッチング操作!" } , { ER_INCORRECT_ARG_LENGTH , "processing-instruction() のノード・テストの引き数の長さが誤っています!" } , { ER_CANT_CONVERT_TO_NUMBER , "{0} を数に変換できません" } , { ER_CANT_CONVERT_TO_NODELIST , "{0} を NodeList に変換できません!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0} を NodeSetDTM に変換できません!" } , { ER_CANT_CONVERT_TO_TYPE , "{0} を type#{1} に変換できません" } , { ER_EXPECTED_MATCH_PATTERN , "getMatchScore で必要な一致パターンです!" } , { ER_COULDNOT_GET_VAR_NAMED , "{0} という名前の変数を取得できませんでした" } , { ER_UNKNOWN_OPCODE , "エラー! 不明な op コード: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "余分の正しくないトークン: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "引用符が誤っているリテラル... 二重引用符が必要でした!" } , { ER_EXPECTED_SINGLE_QUOTE , "引用符が誤っているリテラル... 単一引用符が必要でした!" } , { ER_EMPTY_EXPRESSION , "空の式です!" } , { ER_EXPECTED_BUT_FOUND , "{0} が必要でしたが、{1} が見つかりました" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "プログラマーのアサーションが誤っています! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "ブール(...) 引き数は 19990709 XPath ドラフトではもうオプションでありません。" } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "',' が見つかりましたが、先立つ引き数がありません!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "',' が見つかりましたが、後続の引き数がありません!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' または '.[predicate]' は正しくない構文です。  代りに  'self::node()[predicate]' を使用してください。" } , { ER_ILLEGAL_AXIS_NAME , "正しくない軸の名前: {0}" } , { ER_UNKNOWN_NODETYPE , "不明なノード・タイプ: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "パターン・リテラル ({0}) には引用符が必要です!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} を数にフォーマット設定できませんでした!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "XML TransformerFactory Liaison を作成できませんでした: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "エラー! xpath select 式 (-select) が見つかりませんでした。" } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "エラー! OP_LOCATIONPATH の後に ENDOP が見つかりませんでした" } , { ER_ERROR_OCCURED , "エラーが起こりました!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "変数に指定された VariableReference がコンテキスト外か、定義なしです!  名前 = {0}" } , { ER_AXES_NOT_ALLOWED , "マッチング・パターンで許可されているのは child:: および attribute:: だけです!  問題の軸 = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() の引き数の数が誤っています。" } , { ER_COUNT_TAKES_1_ARG , "count 関数は引き数を 1 個使用します!" } , { ER_COULDNOT_FIND_FUNCTION , "関数: {0} が見つかりませんでした" } , { ER_UNSUPPORTED_ENCODING , "サポートされないエンコード: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "問題が getNextSibling 内の DTM で起こりました... リカバリーしようとしています" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "プログラマー・エラー: EmptyNodeList を書き込み先にはできません。" } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory は XPathContext によりサポートされません!" } , { ER_PREFIX_MUST_RESOLVE , "接頭部はネーム・スペースに解決されなければなりません: {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (InputSource ソース) は XPathContext 内でサポートされません! {0} をオープンできません" } , { ER_SAX_API_NOT_HANDLED , "SAX API characters(char ch[]... は DTM により処理されません!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... は DTM により処理されません!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison はタイプ {0} のノードを処理できません" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper はタイプ {0} のノードを処理できません" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse エラー: SystemID - {0} 行 - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse エラー" } , { ER_INVALID_UTF16_SURROGATE , "無効な UTF-16 サロゲートが検出されました: {0} ?" } , { ER_OIERROR , "入出力エラー" } , { ER_CANNOT_CREATE_URL , "{0} の URL を作成できません。" } , { ER_XPATH_READOBJECT , "XPath.readObject 内: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "関数トークンが見つかりません。" } , { ER_CANNOT_DEAL_XPATH_TYPE , "XPath タイプ: {0} を処理できません" } , { ER_NODESET_NOT_MUTABLE , "この NodeSet は可変でありません" } , { ER_NODESETDTM_NOT_MUTABLE , "この NodeSetDTM は可変でありません" } , { ER_VAR_NOT_RESOLVABLE , "変数は解決可能でありません: {0}" } , { ER_NULL_ERROR_HANDLER , "ヌルのエラー・ハンドラー" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "プログラマーのアサーション: 不明な命令コード: {0}" } , { ER_ZERO_OR_ONE , "0 または 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() は XRTreeFragSelectWrapper によってサポートされません" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() は XRTreeFragSelectWrapper によってサポートされません" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() は XStringForChars の場合はサポートされません" } , { ER_COULD_NOT_FIND_VAR , "名前 {0} をもつ変数が見つかりませんでした" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars は引き数にストリングを使用しません" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer 引き数はヌルにできません" } , { ER_TWO_OR_THREE , "2 または 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "変数がバインドされる前にアクセスされました!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB は引き数にストリングを使用しません!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! エラー! ウォーカーのルートをヌルに設定しています!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "この NodeSetDTM は直前のノードを繰り返すことができません!" } , { ER_NODESET_CANNOT_ITERATE , "この NodeSet は直前のノードを繰り返すことができません!" } , { ER_NODESETDTM_CANNOT_INDEX , "この NodeSetDTM は索引付けやカウントの機能を実行できません!" } , { ER_NODESET_CANNOT_INDEX , "この NodeSet は索引付けやカウントの機能を実行できません!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "nextNode を呼び出した後に setShouldCacheNodes を呼び出すことはできません!" } , { ER_ONLY_ALLOWS , "{0} に許可される引き数は {1} 個のみです" } , { ER_UNKNOWN_STEP , "getNextStepPos 内のプログラマーのアサーション: 不明な stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "相対ロケーション・パスは '/' または '//' トークンの次に必要でした。" } , { ER_EXPECTED_LOC_PATH , "ロケーション・パスが必要でしたが、次のトークンが検出されました:  {0}" } , { ER_EXPECTED_LOC_STEP , "ロケーション・ステップは '/' または '//' トークンの次に必要でした。" } , { ER_EXPECTED_NODE_TEST , "NCName:* または QName のいずれかと一致するノード・テストが必要でした。" } , { ER_EXPECTED_STEP_PATTERN , "ステップ・パターンが必要でしたが、'/' が検出されました。" } , { ER_EXPECTED_REL_PATH_PATTERN , "相対パス・パターンが必要でした。" } , { ER_CANT_CONVERT_TO_BOOLEAN , "{0} をブールに変換できません。" } , { ER_CANT_CONVERT_TO_SINGLENODE , "{0} を単一ノードに変換できません。 この getter がタイプ ANY_UNORDERED_NODE_TYPE および FIRST_ORDERED_NODE_TYPE に適用されます。" } , { ER_CANT_GET_SNAPSHOT_LENGTH , "タイプ: {0} についてのスナップショットの長さを取得できません。 この getter がタイプ UNORDERED_NODE_SNAPSHOT_TYPE および ORDERED_NODE_SNAPSHOT_TYPE に適用されます。" } , { ER_NON_ITERATOR_TYPE , "非イテレーター・タイプ: {0} は繰り返しができません" } , { ER_DOC_MUTATED , "結果が戻された以後に文書が変更されました。 イテレーターが無効です。" } , { ER_INVALID_XPATH_TYPE , "無効な XPath タイプ引き数: {0}" } , { ER_EMPTY_XPATH_RESULT , "空の XPath 結果オブジェクト" } , { ER_INCOMPATIBLE_TYPES , "戻されたタイプ: {0} は指定されたタイプ: {1} に強制できません" } , { ER_NULL_RESOLVER , "接頭部をヌル接頭部リゾルバーに解決できません。" } , { ER_CANT_CONVERT_TO_STRING , "{0} をストリングに変換できません。" } , { ER_NON_SNAPSHOT_TYPE , "タイプ: {0} 上の snapshotItem の呼び出しができません。 このメソッドがタイプ UNORDERED_NODE_SNAPSHOT_TYPE および ORDERED_NODE_SNAPSHOT_TYPE に適用されます。" } , { ER_WRONG_DOCUMENT , "コンテキスト・ノードはこの XPathEvaluator にバインドされている文書に属していません。" } , { ER_WRONG_NODETYPE , "コンテキスト・ノード・タイプはサポートされていません。" } , { ER_XPATH_ERROR , "XPath に不明なエラーがあります。" } , { WG_LOCALE_NAME_NOT_HANDLED , "フォーマット番号関数内のロケール名はまだ処理されません!" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL プロパティー: {0} はサポートされていません" } , { WG_DONT_DO_ANYTHING_WITH_NS , "現在、プロパティー {1} のネーム・スペース {0} で何も実行されていません" } , { WG_SECURITY_EXCEPTION , "XSL システム・プロパティー: {0} にアクセスしようとしているときに SecurityException" } , { WG_QUO_NO_LONGER_DEFINED , "旧構文: quo(...) は XPath 内にもう定義されていません。" } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "nodeTest をインプリメントするには XPath に派生オブジェクトが必要です!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "関数トークンが見つかりません。" } , { WG_COULDNOT_FIND_FUNCTION , "関数: {0} が見つかりませんでした" } , { WG_CANNOT_MAKE_URL_FROM , "URL を {0} から作成できません。" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "-E オプションは DTM パーサーの場合はサポートされません" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "変数に指定された VariableReference がコンテキスト外か、定義なしです!  名前 = {0}" } , { WG_UNSUPPORTED_ENCODING , "サポートされないエンコード: {0}" } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "createMessage へのパラメーターが境界外でした。" } , { "FORMAT_FAILED" , "messageFormat 呼び出し中に例外がスローされました。" } , { "version" , ">>>>>>> Xalan バージョン " } , { "version2" , "<<<<<<<" } , { "yes" , "はい" } , { "line" , "行 #" } , { "column" , "桁 #" } , { "xsldone" , "XSLProcessor: 完了" } , { "xpath_option" , "xpath オプション: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath 式]" } , { "optionMatch" , "   [-match マッチング・パターン (マッチング診断用)]" } , { "optionAnyExpr" , "あるいは診断ダンプを実行するのは xpath 式だけです" } , { "noParsermsg1" , "XSL 処理は成功しませんでした。" } , { "noParsermsg2" , "** パーサーが見つかりませんでした **" } , { "noParsermsg3" , "クラスパスを調べてください。" } , { "noParsermsg4" , "IBM の XML Parser for Java がない場合は、次のサイトからダウンロードできます:" } , { "noParsermsg5" , "IBM AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#エラー" ; public static final String ERROR_HEADER = "エラー: " ; public static final String WARNING_HEADER = "警告: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "パターン " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xalan . transformer ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . ObjectStack ; public class StackGuard { public static int m_recursionLimit = - 1 ; TransformerImpl m_transformer ; public int getRecursionLimit ( ) { return m_recursionLimit ; } public void setRecursionLimit ( int limit ) { m_recursionLimit = limit ; } public StackGuard ( TransformerImpl transformerImpl ) { m_transformer = transformerImpl ; } public int countLikeTemplates ( ElemTemplate templ , int pos ) { ObjectStack elems = m_transformer . getCurrentTemplateElements ( ) ; int count = 1 ; for ( int i = pos - 1 ; i >= 0 ; i -- ) { if ( ( ElemTemplateElement ) elems . elementAt ( i ) == templ ) count ++ ; } return count ; } private ElemTemplate getNextMatchOrNamedTemplate ( int pos ) { ObjectStack elems = m_transformer . getCurrentTemplateElements ( ) ; for ( int i = pos ; i >= 0 ; i -- ) { ElemTemplateElement elem = ( ElemTemplateElement ) elems . elementAt ( i ) ; if ( null != elem ) { if ( elem . getXSLToken ( ) == Constants . ELEMNAME_TEMPLATE ) { return ( ElemTemplate ) elem ; } } } return null ; } public void checkForInfinateLoop ( ) throws TransformerException { int nTemplates = m_transformer . getCurrentTemplateElementsCount ( ) ; if ( nTemplates < m_recursionLimit ) return ; if ( m_recursionLimit <= 0 ) return ; for ( int i = ( nTemplates - 1 ) ; i >= m_recursionLimit ; i -- ) { ElemTemplate template = getNextMatchOrNamedTemplate ( i ) ; if ( null == template ) break ; int loopCount = countLikeTemplates ( template , i ) ; if ( loopCount >= m_recursionLimit ) { String idIs = XSLMessages . createMessage ( ( ( null != template . getName ( ) ) ? "nameIs" : "matchPatternIs" ) , null ) ; Object [ ] msgArgs = new Object [ ] { new Integer ( loopCount ) , idIs , ( ( null != template . getName ( ) ) ? template . getName ( ) . toString ( ) : template . getMatch ( ) . getPatternString ( ) ) } ; String msg = XSLMessages . createMessage ( "recursionTooDeep" , msgArgs ) ; throw new TransformerException ( msg ) ; } } } } 	1	['7', '1', '0', '8', '19', '0', '3', '7', '5', '0.5', '157', '0', '1', '0', '0.458333333', '0', '0', '21.14285714', '4', '1.4286', '2']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_de extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Fehler: '{' darf nicht innerhalb des Ausdrucks stehen." } , { ER_ILLEGAL_ATTRIBUTE , "{0} hat ein unzulässiges Attribut {1}." } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode ist Null in xsl:apply-imports!" } , { ER_CANNOT_ADD , "{0} kann nicht {1} hinzugefügt werden." } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode ist Null in handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "{0} muss ein Namensattribut haben." } , { ER_TEMPLATE_NOT_FOUND , "Vorlage konnte nicht gefunden werden: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Namensvorlage für den Attributwert in xsl:call-template konnte nicht aufgelöst werden." } , { ER_REQUIRES_ATTRIB , "{0} erfordert das Attribut {1}." } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} muss über ein Attribut ''test'' verfügen." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Falscher Wert für Ebenenattribut: {0}." } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Name der Verarbeitungsanweisung darf nicht 'xml' sein." } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Name der Verarbeitungsanweisung muss ein gültiges NCName-Format haben: {0}." } , { ER_NEED_MATCH_ATTRIB , "{0} muss über ein entsprechendes Attribut verfügen, wenn ein Modus vorhanden ist." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} erfordert einen Namen oder ein Übereinstimmungsattribut." } , { ER_CANT_RESOLVE_NSPREFIX , "Präfix des Namensbereichs kann nicht aufgelöst werden: {0}." } , { ER_ILLEGAL_VALUE , "xml:space weist einen ungültigen Wert auf: {0}" } , { ER_NO_OWNERDOC , "Der Kindknoten hat kein Eignerdokument!" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement-Fehler: {0}" } , { ER_NULL_CHILD , "Es wird versucht, ein leeres Kind hinzuzufügen!" } , { ER_NEED_SELECT_ATTRIB , "{0} erfordert ein Attribut ''select''." } , { ER_NEED_TEST_ATTRIB , "xsl:when muss über ein Attribut 'test' verfügen." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param muss über ein Attribut 'name' verfügen." } , { ER_NO_CONTEXT_OWNERDOC , "Der Kontextknoten verfügt nicht über ein Eignerdokument!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "XML-TransformerFactory-Liaison konnte nicht erstellt werden: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan:-Prozess konnte nicht erfolgreich durchgeführt werden." } , { ER_NOT_SUCCESSFUL , "Xalan: war nicht erfolgreich." } , { ER_ENCODING_NOT_SUPPORTED , "Verschlüsselung wird nicht unterstützt: {0}." } , { ER_COULD_NOT_CREATE_TRACELISTENER , "TraceListener konnte nicht erstellt werden: {0}." } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key erfordert ein Attribut 'name'!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key erfordert ein Attribut 'match'!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key erfordert ein Attribut 'use'!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} erfordert ein Attribut ''elements''!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0}: Das Attribut ''prefix'' fehlt. " } , { ER_BAD_STYLESHEET_URL , "Formatvorlagen-URL-Adresse ist ungültig: {0}." } , { ER_FILE_NOT_FOUND , "Formatvorlagendatei konnte nicht gefunden werden: {0}." } , { ER_IOEXCEPTION , "Bei folgender Formatvorlagendatei ist eine E/A-Ausnahmebedingung aufgetreten: {0}." } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Attribut 'href' für {0} konnte nicht gefunden werden." } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} schließt sich selbst direkt oder indirekt mit ein!" } , { ER_PROCESSINCLUDE_ERROR , "Fehler in StylesheetHandler.processInclude, {0}." } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0}: Das Attribut ''lang'' fehlt. " } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) Element {0} an falscher Position?? Fehlendes Containerelement ''component''. " } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Ausgabe kann nur an ein Element, Dokumentfragment, Dokument oder Druckausgabeprogramm erfolgen." } , { ER_PROCESS_ERROR , "Fehler in StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "UnImplNode-Fehler: {0}" } , { ER_NO_SELECT_EXPRESSION , "Fehler! xpath-Auswahlausdruck (-select) konnte nicht gefunden werden." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "XSLProcessor kann nicht serialisiert werden!" } , { ER_NO_INPUT_STYLESHEET , "Formatvorlageneingabe wurde nicht angegeben!" } , { ER_FAILED_PROCESS_STYLESHEET , "Verarbeitung der Formatvorlage fehlgeschlagen!" } , { ER_COULDNT_PARSE_DOC , "Dokument {0} konnte nicht syntaktisch analysiert werden!" } , { ER_COULDNT_FIND_FRAGMENT , "Fragment konnte nicht gefunden werden: {0}." } , { ER_NODE_NOT_ELEMENT , "Der Knoten, auf den von einer Fragment-ID verwiesen wurde, war kein Element: {0}." } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "'for-each' muss entweder ein Attribut 'match' oder 'name' haben." } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "Vorlagen müssen entweder ein Attribut 'match' oder 'name' haben." } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Kein Klon eines Dokumentfragments!" } , { ER_CANT_CREATE_ITEM , "Im Ergebnisbaum kann kein Eintrag erzeugt werden: {0}." } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space in der Quellen-XML hat einen ungültigen Wert: {0}." } , { ER_NO_XSLKEY_DECLARATION , "Keine Deklaration xsl:key für {0} vorhanden!" } , { ER_CANT_CREATE_URL , "Fehler! URL kann nicht erstellt werden für: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions wird nicht unterstützt." } , { ER_PROCESSOR_ERROR , "XSLT-TransformerFactory-Fehler" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} nicht zulässig innerhalb einer Formatvorlage!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns wird nicht mehr unterstützt!  Verwenden Sie stattdessen xsl:output." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space wird nicht mehr unterstützt!  Verwenden Sie stattdessen xsl:strip-space oder xsl:preserve-space." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result wird nicht mehr unterstützt!  Verwenden Sie stattdessen xsl:output." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} hat ein ungültiges Attribut: {1}." } , { ER_UNKNOWN_XSL_ELEM , "Unbekanntes XSL-Element: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort kann nur mit xsl:apply-templates oder xsl:for-each verwendet werden." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when steht an der falschen Position!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) Für xsl:when ist xsl:choose nicht als Elter definiert!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise steht an der falschen Position!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) Für xsl:otherwise ist xsl:choose nicht als Elter definiert!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} ist innerhalb einer Vorlage nicht zulässig!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0}: Erweiterung des Namensbereichspräfixes {1} ist unbekannt" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Importe können nur als erste Elemente in der Formatvorlage auftreten!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} importiert sich direkt oder indirekt selbst!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:space hat einen ungültigen Wert: {0}. " } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet nicht erfolgreich!" } , { ER_SAX_EXCEPTION , "SAX-Ausnahmebedingung" } , { ER_XSLT_ERROR , "XSLT-Fehler" } , { ER_CURRENCY_SIGN_ILLEGAL , "Ein Währungssymbol ist in der Formatmusterzeichenfolge nicht zulässig." } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Eine Dokumentfunktion wird in der Dokumentobjektmodell-Formatvorlage nicht unterstützt!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Präfix einer Auflösung ohne Präfix kann nicht aufgelöst werden!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Umleitungserweiterung: Dateiname konnte nicht abgerufen werden - Datei oder Attribut 'select' muss eine gültige Zeichenfolge zurückgeben. " } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "FormatterListener kann in Umleitungserweiterung nicht erstellt werden!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Präfix in exclude-result-prefixes ist nicht gültig: {0}." } , { ER_MISSING_NS_URI , "Fehlende Namensbereichs-URI für angegebenes Präfix." } , { ER_MISSING_ARG_FOR_OPTION , "Fehlendes Argument für Option: {0}." } , { ER_INVALID_OPTION , "Ungültige Option: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Syntaktisch falsche Formatzeichenfolge: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet erfordert ein Attribut 'version'!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Attribut {0} weist einen ungültigen Wert auf: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose erfordert xsl:when." } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports ist in xsl:for-each nicht zulässig." } , { ER_CANT_USE_DTM_FOR_OUTPUT , "DTMLiaison kann nicht für einen Ausgabe-Dokumentobjektmodellknoten verwendet werden... Übergeben Sie stattdessen org.apache.xpath.DOM2Helper!" } , { ER_CANT_USE_DTM_FOR_INPUT , "DTMLiaison kann nicht für einen Eingabe-Dokumentobjektmodellknoten verwendet werden... Übergeben Sie stattdessen org.apache.xpath.DOM2Helper!" } , { ER_CALL_TO_EXT_FAILED , "Aufruf an Erweiterungselement fehlgeschlagen: {0}." } , { ER_PREFIX_MUST_RESOLVE , "Das Präfix muss in einen Namensbereich aufgelöst werden: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Ungültige UTF-16-Ersetzung festgestellt: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} verwendet sich selbst, wodurch eine Endlosschleife verursacht wird." } , { ER_CANNOT_MIX_XERCESDOM , "Nicht-Xerces-Dokumentobjektmodelleingabe kann nicht mit Xerces-Dokumentobjektmodellausgabe gemischt werden!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "In ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Mehrere Vorlagen mit folgendem Namen gefunden: {0}." } , { ER_INVALID_KEY_CALL , "Ungültiger Funktionsaufruf: rekursive Aufrufe 'key()'sind nicht zulässig." } , { ER_REFERENCING_ITSELF , "Variable {0} verweist direkt oder indirekt auf sich selbst!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Der Eingabeknoten kann für DOMSource für newTemplates nicht Null sein!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Klassendatei für Option {0} wurde nicht gefunden." } , { ER_REQUIRED_ELEM_NOT_FOUND , "Erforderliches Element nicht gefunden: {0}." } , { ER_INPUT_CANNOT_BE_NULL , "InputStream kann nicht Null sein." } , { ER_URI_CANNOT_BE_NULL , "URI kann nicht Null sein." } , { ER_FILE_CANNOT_BE_NULL , "Eine Datei kann nicht Null sein." } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource kann nicht Null sein." } , { ER_CANNOT_INIT_BSFMGR , "BSF Manager kann nicht initialisiert werden." } , { ER_CANNOT_CMPL_EXTENSN , "Erweiterung konnte nicht kompiliert werden." } , { ER_CANNOT_CREATE_EXTENSN , "Erweiterung {0} konnte nicht erstellt werden. Ursache: {1}." } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "Der Aufruf einer Exemplardefinitionsmethode von Methode {0} erfordert ein Objektexemplar als erstes Argument." } , { ER_INVALID_ELEMENT_NAME , "Ungültiger Elementname angegeben {0}." } , { ER_ELEMENT_NAME_METHOD_STATIC , "Elementnamenmethode muss statisch sein: {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Erweiterungsfunktion {0} : {1} ist unbekannt." } , { ER_MORE_MATCH_CONSTRUCTOR , "Mehrere passende Entsprechungen für Konstruktor für {0}." } , { ER_MORE_MATCH_METHOD , "Mehrere passende Entsprechungen für Methode {0}." } , { ER_MORE_MATCH_ELEMENT , "Mehrere passende Entsprechungen für Elementmethode {0}." } , { ER_INVALID_CONTEXT_PASSED , "Ungültiger Kontext zur Auswertung von {0} übergeben." } , { ER_POOL_EXISTS , "Pool ist bereits vorhanden." } , { ER_NO_DRIVER_NAME , "Kein Treibername angegeben." } , { ER_NO_URL , "Keine URL-Adresse angegeben." } , { ER_POOL_SIZE_LESSTHAN_ONE , "Poolgröße ist kleiner als Eins!" } , { ER_INVALID_DRIVER , "Ungültiger Treibername angegeben!" } , { ER_NO_STYLESHEETROOT , "Root der Formatvorlage konnte nicht gefunden werden!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Ungültiger Wert für xml:space" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode ist fehlgeschlagen." } , { ER_RESOURCE_COULD_NOT_LOAD , "Die Ressource [ {0} ] konnte nicht geladen werden: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Puffergröße <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Unbekannter Fehler beim Aufrufen der Erweiterung." } , { ER_NO_NAMESPACE_DECL , "Präfix {0} hat keine entsprechende Namensbereichdeklaration." } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Elementinhalt nicht zulässig für lang=javaclass {0}." } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Formatvorlage hat die Beendigung übertragen." } , { ER_ONE_OR_TWO , "1 oder 2" } , { ER_TWO_OR_THREE , "2 oder 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "{0} (CLASSPATH prüfen) konnte nicht geladen werden; es werden die Standardwerte verwendet." } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Standardvorlagen können nicht initialisiert werden." } , { ER_RESULT_NULL , "Das Ergebnis darf nicht Null sein." } , { ER_RESULT_COULD_NOT_BE_SET , "Das Ergebnis konnte nicht festgelegt werden." } , { ER_NO_OUTPUT_SPECIFIED , "Keine Ausgabe angegeben." } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Umsetzen in ein Ergebnis des Typs {0} ist nicht möglich. " } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Umsetzen einer Quelle des Typs {0} ist nicht möglich. " } , { ER_NULL_CONTENT_HANDLER , "Es ist keine Inhaltssteuerroutine vorhanden." } , { ER_NULL_ERROR_HANDLER , "Kein Fehlerbehandlungsprogramm vorhanden" } , { ER_CANNOT_CALL_PARSE , "Die Syntaxanalyse kann nicht aufgerufen werden, wenn ContentHandler nicht festgelegt wurde." } , { ER_NO_PARENT_FOR_FILTER , "Kein Elter für Filter vorhanden" } , { ER_NO_STYLESHEET_IN_MEDIA , "Keine Formatvorlage gefunden in: {0}, Datenträger= {1}." } , { ER_NO_STYLESHEET_PI , "Keine Verarbeitungsanweisung für xml-stylesheet gefunden in {0}." } , { ER_NOT_SUPPORTED , "Nicht unterstützt: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Der Wert für Merkmal {0} sollte ein Boolesches Exemplar sein." } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "Externes Script bei {0} konnte nicht erreicht werden." } , { ER_RESOURCE_COULD_NOT_FIND , "Die Ressource [ {0} ] konnte nicht gefunden werden.\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Ausgabemerkmal nicht erkannt: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Das Erstellen des Exemplars ElemLiteralResult ist fehlgeschlagen." } , { ER_VALUE_SHOULD_BE_NUMBER , "Der Wert für {0} sollte eine syntaktisch analysierbare Zahl sein." } , { ER_VALUE_SHOULD_EQUAL , "Der Wert für {0} sollte ''yes'' oder ''no'' entsprechen." } , { ER_FAILED_CALLING_METHOD , "Aufruf von Methode {0} ist fehlgeschlagen" } , { ER_FAILED_CREATING_ELEMTMPL , "Das Erstellen des Exemplars ElemTemplateElement ist fehlgeschlagen." } , { ER_CHARS_NOT_ALLOWED , "Zeichen sind an dieser Stelle im Dokument nicht zulässig." } , { ER_ATTR_NOT_ALLOWED , "Das Attribut \"{0}\" ist im Element {1} nicht zulässig!" } , { ER_BAD_VALUE , "{0} ungültiger Wert {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "Attributwert {0} wurde nicht gefunden " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "Attributwert {0} wurde nicht erkannt " } , { ER_NULL_URI_NAMESPACE , "Es wird versucht, ein Namensbereichpräfix mit einer Null-URI zu erzeugen." } , { ER_NUMBER_TOO_BIG , "Es wird versucht, eine größere Zahl als die größte erweiterte Ganzzahl zu formatieren." } , { ER_CANNOT_FIND_SAX1_DRIVER , "SAX1-Treiberklasse {0} konnte nicht gefunden werden." } , { ER_SAX1_DRIVER_NOT_LOADED , "SAX1-Treiberklasse {0} gefunden, kann aber nicht geladen werden." } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "SAX1-Treiberklasse {0} geladen, kann aber nicht instanziert werden." } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1-Treiberklasse {0} implementiert nicht org.xml.sax.Parser." } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Systemmerkmal org.xml.sax.parser ist nicht angegeben." } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Parserargument darf nicht Null sein." } , { ER_FEATURE , "Feature: {0}" } , { ER_PROPERTY , "Merkmal: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Es ist keine Entitätenauflösungsroutine vorhanden." } , { ER_NULL_DTD_HANDLER , "Es ist keine Steuerroutine für Dokumenttypbeschreibungen vorhanden." } , { ER_NO_DRIVER_NAME_SPECIFIED , "Kein Treibername angegeben!" } , { ER_NO_URL_SPECIFIED , "Keine URL-Adresse angegeben!" } , { ER_POOLSIZE_LESS_THAN_ONE , "Poolgröße ist kleiner als 1!" } , { ER_INVALID_DRIVER_NAME , "Ungültiger Treibername angegeben!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Programmierfehler! 'expr' hat kein Elter ElemTemplateElement!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Programmiererfestlegung in RedundentExprEliminator: {0} " } , { ER_NOT_ALLOWED_IN_POSITION , "{0} ist an dieser Position in der Formatvorlage nicht zulässig!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Anderer Text als Leerzeichen ist an dieser Position in der Formatvorlage nicht zulässig!" } , { INVALID_TCHAR , "Unzulässiger Wert {1} für CHAR-Attribut verwendet: {0}.  Ein Attribut des Typs CHAR darf nur ein Zeichen umfassen!" } , { INVALID_QNAME , "Unzulässiger Wert {1} für QNAME-Attribut verwendet: {0}" } , { INVALID_ENUM , "Unzulässiger Wert {1} für ENUM-Attribut verwendet: {0}.  Folgende Werte sind gültig: {2}." } , { INVALID_NMTOKEN , "Unzulässiger Wert {1} für NMTOKEN-Attribut verwendet: {0}. " } , { INVALID_NCNAME , "Unzulässiger Wert {1} für NCNAME-Attribut verwendet: {0}. " } , { INVALID_BOOLEAN , "Unzulässiger Wert {1} für BOOLEAN-Attribut verwendet: {0}. " } , { INVALID_NUMBER , "Unzulässiger Wert {1} für NUMBER-Attribut verwendet: {0}. " } , { ER_ARG_LITERAL , "Argument von {0} in Suchmuster muss ein Literal sein." } , { ER_DUPLICATE_GLOBAL_VAR , "Doppelte Deklaration einer globalen Variablen." } , { ER_DUPLICATE_VAR , "Doppelte Deklaration einer Variablen." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template muss ein Attribut 'name' und/oder 'match' haben." } , { ER_INVALID_PREFIX , "Präfix in exclude-result-prefixes ist nicht gültig: {0}." } , { ER_NO_ATTRIB_SET , "Die Attributgruppe {0} ist nicht vorhanden." } , { WG_FOUND_CURLYBRACE , "'}' gefunden, es ist aber keine Attributvorlage geöffnet!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Warnung: Attribut 'count' entspricht keinem übergeordneten Fensterobjekt in xsl:number! Ziel = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Veraltete Syntax: Der Name des Attributs 'expr' wurde in 'select' geändert." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan bearbeitet noch nicht den Ländereinstellungsnamen in der Funktion 'format-number'." } , { WG_LOCALE_NOT_FOUND , "Warnung: Ländereinstellung für xml:lang={0} konnte nicht gefunden werden." } , { WG_CANNOT_MAKE_URL_FROM , "URL konnte nicht erstellt werden aus: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Angeforderte Dokumentation kann nicht geladen werden: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Collator für <sort xml:lang={0} konnte nicht gefunden werden." } , { WG_FUNCTIONS_SHOULD_USE_URL , "Veraltete Syntax: Die Funktionsanweisung sollte eine URL-Adresse {0} verwenden." } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "Verschlüsselung nicht unterstützt: {0}, UTF-8 wird verwendet." } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "Verschlüsselung nicht unterstützt: {0}, Java {1} wird verwendet." } , { WG_SPECIFICITY_CONFLICTS , "Genauigkeitskonflikte gefunden: {0}. Die letzte Angabe in der Formatvorlage wird verwendet." } , { WG_PARSING_AND_PREPARING , "========= Syntaxanalyse und Vorbereitung von {0} ==========" } , { WG_ATTR_TEMPLATE , "Attributvorlage, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Übereinstimmungskonflikt zwischen xsl:strip-space und xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan bearbeitet noch nicht das Attribut {0}!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Keine Deklaration für Dezimalformat gefunden: {0}" } , { WG_OLD_XSLT_NS , "Fehlender oder ungültiger XSLT-Namensbereich " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Nur eine Standarddeklaration xsl:decimal-format ist zulässig." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "Namen in xsl:decimal-format müssen eindeutig sein. Name \"{0}\" wurde dupliziert." } , { WG_ILLEGAL_ATTRIBUTE , "{0} hat ein unzulässiges Attribut {1}." } , { WG_COULD_NOT_RESOLVE_PREFIX , "Namensbereichpräfix konnte nicht aufgelöst werden: {0}. Der Knoten wird ignoriert." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet erfordert ein Attribut 'version'!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Unzulässiger Attributname: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Unzulässiger Wert für Attribut {0} verwendet: {1}" } , { WG_EMPTY_SECOND_ARG , "Die Ergebnisknoteneinstellung des zweiten Arguments der Dokumentfunktion ist leer. Geben Sie eine leere Knotengruppe zurück." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Der Wert des Attributs 'name' von xsl:processing-instruction darf nicht 'xml' sein." } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Der Wert des Attributs 'name' von xsl:processing-instruction muss ein gültiger NCName sein: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Attribut {0} kann nicht nach Kindknoten oder vor dem Erstellen eines Elements hinzugefügt werden.  Das Attribut wird ignoriert." } , { "ui_language" , "de" } , { "help_language" , "de" } , { "language" , "de" } , { "BAD_CODE" , "Der Parameter für createMessage lag außerhalb des gültigen Bereichs" } , { "FORMAT_FAILED" , "Während des Aufrufs von messageFormat wurde eine Ausnahmebedingung ausgelöst" } , { "version" , ">>>>>>> Xalan-Version " } , { "version2" , "<<<<<<<" } , { "yes" , "ja" } , { "line" , "Zeilennummer" } , { "column" , "Spaltennummer" } , { "xsldone" , "XSLProcessor: fertig" } , { "xslProc_option" , "Optionen für Verarbeitungsklassen in der Xalan-J-Befehlszeile:" } , { "xslProc_option" , "Optionen für Verarbeitungsklassen in der Xalan-J-Befehlszeile:" } , { "xslProc_invalid_xsltc_option" , "Die Option {0} wird im XSLTC-Modus nicht unterstützt." } , { "xslProc_invalid_xalan_option" , "Die Option {0} kann nur mit -XSLTC verwendet werden." } , { "xslProc_no_input" , "Fehler: Es wurde keine Formatvorlagen- oder Eingabe-XML angegeben. Führen Sie diesen Befehl ohne Optionen für Syntaxanweisungen aus." } , { "xslProc_common_options" , "-Allgemeine Optionen-" } , { "xslProc_xalan_options" , "-Optionen für Xalan-" } , { "xslProc_xsltc_options" , "-Optionen für XSLTC-" } , { "xslProc_return_to_continue" , "(Drücken Sie die Eingabetaste, um fortzufahren.)" } , { "optionXSLTC" , "[-XSLTC (XSLTC für Umsetzung verwenden)]" } , { "optionIN" , "[-IN EingabeXMLURL]" } , { "optionXSL" , "[-XSL XSLUmsetzungsURL]" } , { "optionOUT" , "[-OUT AusgabeDateiName]" } , { "optionLXCIN" , "[-LXCIN kompilierteDateivorlageDateiNameEin]" } , { "optionLXCOUT" , "[-LXCOUT kompilierteDateivorlageDateiNameAus]" } , { "optionPARSER" , "[-PARSER vollständig qualifizierter Klassenname der Parser-Liaison]" } , { "optionE" , "[-E (Entitätenverweise nicht erweitern)]" } , { "optionV" , "[-E (Entitätenverweise nicht erweitern)]" } , { "optionQC" , "[-QC (Unterdrückte Musterkonfliktwarnungen)]" } , { "optionQ" , "[-Q  (Unterdrückter Modus)]" } , { "optionLF" , "[-LF (Nur Zeilenvorschubzeichen bei Ausgabe verwenden {Standardeinstellung ist CR/LF})]" } , { "optionCR" , "[-CR (Nur Zeilenschaltung bei Ausgabe verwenden {Standardeinstellung ist CR/LF})]" } , { "optionESCAPE" , "[-ESCAPE (Zeichen, die mit einem Escapezeichen angegeben werden müssen {Standardeinstellung ist <>&\"\'\\r\\n}]" } , { "optionINDENT" , "[-INDENT (Steuerung, um wie viele Leerzeichen eingerückt werden soll {Standardeinstellung ist 0})]" } , { "optionTT" , "[-TT (Trace für Vorlagen ausführen, wenn sie aufgerufen werden.)]" } , { "optionTG" , "[-TG (Trace für jedes Generierungsereignis durchführen.)]" } , { "optionTS" , "[-TS (Trace für jedes Auswahlereignis durchführen.)]" } , { "optionTTC" , "[-TTC (Trace für die untergeordneten Vorlagen ausführen, wenn sie verarbeitet werden.)]" } , { "optionTCLASS" , "[-TCLASS (TraceListener-Klasse für Trace-Erweiterungen.)]" } , { "optionVALIDATE" , "[-VALIDATE (Festlegen, ob eine Gültigkeitsprüfung erfolgen soll.  Die Gültigkeitsprüfung ist standardmäßig ausgeschaltet.)]" } , { "optionEDUMP" , "[-EDUMP {optionaler Dateiname} (Bei Fehler Stapelspeicherauszug erstellen.)]" } , { "optionXML" , "[-XML (XML-Formatierungsprogramm verwenden und XML-Header hinzufügen.)]" } , { "optionTEXT" , "[-TEXT (Einfaches Textformatierungsprogramm verwenden.)]" } , { "optionHTML" , "[-HTML (HTML-Formatierungsprogramm verwenden.)]" } , { "optionPARAM" , "[-PARAM Name Ausdruck (Festlegen eines Formatvorlagenparameters)]" } , { "noParsermsg1" , "XSL-Prozess konnte nicht erfolgreich durchgeführt werden." } , { "noParsermsg2" , "** Parser konnte nicht gefunden werden **" } , { "noParsermsg3" , "Bitte überprüfen Sie den Klassenpfad." } , { "noParsermsg4" , "Wenn Sie nicht über einen IBM XML-Parser für Java verfügen, können Sie ihn herunterladen:" } , { "noParsermsg5" , "IBM AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "[-URIRESOLVER vollständiger Klassenname (URIResolver wird zum Auflösen von URIs verwendet)]" } , { "optionENTITYRESOLVER" , "[-ENTITYRESOLVER vollständiger Klassenname (EntityResolver wird zum Auflösen von Entitäten verwendet)]" } , { "optionCONTENTHANDLER" , "[-CONTENTHANDLER vollständiger Klassenname (ContentHandler wird zum Serialisieren der Ausgabe verwendet)]" } , { "optionLINENUMBERS" , "[-L Zeilennummern für das Quellendokument verwenden]" } , { "optionMEDIA" , "[-MEDIA DatenträgerTyp (Datenträgerattribut verwenden, um die einem Dokument zugeordnete Formatvorlage zu suchen.)]" } , { "optionFLAVOR" , "[-FLAVOR WunschName (Explizit s2s=SAX oder d2d=DOM verwenden, um die Umsetzung auszuführen.)]" } , { "optionDIAG" , "[-DIAG (Gesamtanzahl Millisekunden für die Umsetzung ausgeben.)]" } , { "optionINCREMENTAL" , "[-INCREMENTAL (Inkrementelle DTM-Erstellung mit der Einstellung 'true' für http://xml.apache.org/xalan/features/incremental anfordern.)]" } , { "optionNOOPTIMIMIZE" , "[-NOOPTIMIMIZE (Mit der Einstellung 'false' für http://xml.apache.org/xalan/features/optimize anfordern, dass keine Formatvorlagenoptimierung ausgeführt wird.)]" } , { "optionRL" , "[-RL Verschachtelungsbegrenzung (Numerische Begrenzung für Verschachtelungstiefe der Formatvorlage festlegen.)]" } , { "optionXO" , "[-XO [transletName] (Namen dem generierten Translet zuordnen)]" } , { "optionXD" , "[-XD ZielVerzeichnis (Ein Zielverzeichnis für Translet angeben)]" } , { "optionXJ" , "[-XJ jardatei (Translet-Klassen in eine jar-Datei mit dem Namen <jardatei> packen)]" } , { "optionXP" , "[-XP paket (Ein Paketnamenpräfix für alle generierten Translet-Klassen angeben)]" } , { "optionXN" , "[-XN (Inline-Anordnung für Vorlagen aktivieren)]" } , { "optionXX" , "[-XX (Zusätzliche Debugnachrichtenausgabe aktivieren)]" } , { "optionXT" , "[-XT (Translet für Umsetzung verwenden, wenn möglich)]" } , { "diagTiming" , "--------- Umsetzung von {0} über {1} betrug {2} Millisekunden" } , { "recursionTooDeep" , "Vorlagenverschachtelung ist zu stark. Verschachtelung = {0}, Vorlage {1} {2}" } , { "nameIs" , "Der Name ist" } , { "matchPatternIs" , "Das Suchmuster ist" } } ; public static final String BAD_CODE = "FEHLERHAFTER_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FEHLGESCHLAGEN" ; public static final String ERROR_STRING = "#Fehler" ; public static final String ERROR_HEADER = "Fehler: " ; public static final String WARNING_HEADER = "Achtung: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MUSTER " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xml . serializer ; public class EncodingInfo extends Object { final String name ; final String javaName ; final int lastPrintable ; public EncodingInfo ( String name , String javaName , int lastPrintable ) { this . name = name ; this . javaName = javaName ; this . lastPrintable = lastPrintable ; } } 	1	['1', '1', '0', '1', '2', '0', '1', '0', '1', '2', '16', '0', '0', '0', '1', '0', '0', '12', '0', '0', '2']
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class VariableStack implements Cloneable { public static final int CLEARLIMITATION = 1024 ; public VariableStack ( ) { reset ( ) ; } public synchronized Object clone ( ) throws CloneNotSupportedException { VariableStack vs = ( VariableStack ) super . clone ( ) ; vs . _stackFrames = ( XObject [ ] ) _stackFrames . clone ( ) ; vs . _links = ( int [ ] ) _links . clone ( ) ; return vs ; } XObject [ ] _stackFrames = new XObject [ XPathContext . RECURSIONLIMIT * 2 ] ; int _frameTop ; private int _currentFrameBottom ; int [ ] _links = new int [ XPathContext . RECURSIONLIMIT ] ; int _linksTop ; public XObject elementAt ( final int i ) { return _stackFrames [ i ] ; } public int size ( ) { return _frameTop ; } public void reset ( ) { _frameTop = 0 ; _linksTop = 0 ; _links [ _linksTop ++ ] = 0 ; _stackFrames = new XObject [ _stackFrames . length ] ; } public void setStackFrame ( int sf ) { _currentFrameBottom = sf ; } public int getStackFrame ( ) { return _currentFrameBottom ; } public int link ( final int size ) { _currentFrameBottom = _frameTop ; _frameTop += size ; if ( _frameTop >= _stackFrames . length ) { XObject newsf [ ] = new XObject [ _stackFrames . length + XPathContext . RECURSIONLIMIT + size ] ; System . arraycopy ( _stackFrames , 0 , newsf , 0 , _stackFrames . length ) ; _stackFrames = newsf ; } if ( _linksTop + 1 >= _links . length ) { int newlinks [ ] = new int [ _links . length + ( CLEARLIMITATION * 2 ) ] ; System . arraycopy ( _links , 0 , newlinks , 0 , _links . length ) ; _links = newlinks ; } _links [ _linksTop ++ ] = _currentFrameBottom ; return _currentFrameBottom ; } public void unlink ( ) { _frameTop = _links [ -- _linksTop ] ; _currentFrameBottom = _links [ _linksTop - 1 ] ; } public void unlink ( int currentFrame ) { _frameTop = _links [ -- _linksTop ] ; _currentFrameBottom = currentFrame ; } public void setLocalVariable ( int index , XObject val ) { _stackFrames [ index + _currentFrameBottom ] = val ; } public void setLocalVariable ( int index , XObject val , int stackFrame ) { _stackFrames [ index + stackFrame ] = val ; } public XObject getLocalVariable ( XPathContext xctxt , int index ) throws TransformerException { index += _currentFrameBottom ; XObject val = _stackFrames [ index ] ; if ( null == val ) throw new TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VARIABLE_ACCESSED_BEFORE_BIND , null ) , xctxt . getSAXLocator ( ) ) ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return val ; } public XObject getLocalVariable ( int index , int frame ) throws TransformerException { index += frame ; XObject val = _stackFrames [ index ] ; return val ; } public XObject getLocalVariable ( XPathContext xctxt , int index , boolean destructiveOK ) throws TransformerException { index += _currentFrameBottom ; XObject val = _stackFrames [ index ] ; if ( null == val ) throw new TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VARIABLE_ACCESSED_BEFORE_BIND , null ) , xctxt . getSAXLocator ( ) ) ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return destructiveOK ? val : val . getFresh ( ) ; } public boolean isLocalSet ( int index ) throws TransformerException { return ( _stackFrames [ index + _currentFrameBottom ] != null ) ; } private static XObject [ ] m_nulls = new XObject [ CLEARLIMITATION ] ; public void clearLocalSlots ( int start , int len ) { start += _currentFrameBottom ; System . arraycopy ( m_nulls , 0 , _stackFrames , start , len ) ; } public void setGlobalVariable ( final int index , final XObject val ) { _stackFrames [ index ] = val ; } public XObject getGlobalVariable ( XPathContext xctxt , final int index ) throws TransformerException { XObject val = _stackFrames [ index ] ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return val ; } public XObject getGlobalVariable ( XPathContext xctxt , final int index , boolean destructiveOK ) throws TransformerException { XObject val = _stackFrames [ index ] ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return destructiveOK ? val : val . getFresh ( ) ; } public XObject getVariableOrParam ( XPathContext xctxt , org . apache . xml . utils . QName qname ) throws javax . xml . transform . TransformerException { org . apache . xml . utils . PrefixResolver prefixResolver = xctxt . getNamespaceContext ( ) ; if ( prefixResolver instanceof org . apache . xalan . templates . ElemTemplateElement ) { org . apache . xalan . templates . ElemVariable vvar ; org . apache . xalan . templates . ElemTemplateElement prev = ( org . apache . xalan . templates . ElemTemplateElement ) prefixResolver ; if ( ! ( prev instanceof org . apache . xalan . templates . Stylesheet ) ) { while ( ! ( prev . getParentNode ( ) instanceof org . apache . xalan . templates . Stylesheet ) ) { org . apache . xalan . templates . ElemTemplateElement savedprev = prev ; while ( null != ( prev = prev . getPreviousSiblingElem ( ) ) ) { if ( prev instanceof org . apache . xalan . templates . ElemVariable ) { vvar = ( org . apache . xalan . templates . ElemVariable ) prev ; if ( vvar . getName ( ) . equals ( qname ) ) return getLocalVariable ( xctxt , vvar . getIndex ( ) ) ; } } prev = savedprev . getParentElem ( ) ; } } vvar = prev . getStylesheetRoot ( ) . getVariableOrParamComposed ( qname ) ; if ( null != vvar ) return getGlobalVariable ( xctxt , vvar . getIndex ( ) ) ; } throw new javax . xml . transform . TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VAR_NOT_RESOLVABLE , new Object [ ] { qname . toString ( ) } ) ) ; } } 	1	['22', '1', '0', '27', '44', '0', '18', '11', '21', '0.734693878', '477', '0.285714286', '2', '0', '0.365079365', '0', '0', '20.36363636', '3', '1', '1']
package org . apache . xalan . templates ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xpath . XPathContext ; public abstract class AVTPart implements java . io . Serializable , XSLTVisitable { public AVTPart ( ) { } public abstract String getSimpleString ( ) ; public abstract void evaluate ( XPathContext xctxt , FastStringBuffer buf , int context , org . apache . xml . utils . PrefixResolver nsNode ) throws javax . xml . transform . TransformerException ; public void setXPathSupport ( XPathContext support ) { } public boolean canTraverseOutsideSubtree ( ) { return false ; } public abstract void fixupVariables ( java . util . Vector vars , int globalsSize ) ; } 	1	['6', '1', '2', '7', '7', '15', '3', '4', '6', '2', '12', '0', '0', '0', '0.361111111', '0', '0', '1', '1', '0.8333', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; public class OneStepIterator extends ChildTestIterator { protected int m_axis = - 1 ; protected DTMAxisIterator m_iterator ; OneStepIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; m_axis = WalkerFactory . getAxisFromStep ( compiler , firstStepPos ) ; } public OneStepIterator ( DTMAxisIterator iterator , int axis ) throws javax . xml . transform . TransformerException { super ( null ) ; m_iterator = iterator ; m_axis = axis ; int whatToShow = DTMFilter . SHOW_ALL ; initNodeTest ( whatToShow ) ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; if ( m_axis > - 1 ) m_iterator = m_cdtm . getAxisIterator ( m_axis ) ; m_iterator . setStartNode ( m_context ) ; } public void detach ( ) { if ( m_allowDetach ) { if ( m_axis > - 1 ) m_iterator = null ; super . detach ( ) ; } } protected int getNextNode ( ) { return m_lastFetched = m_iterator . next ( ) ; } public Object clone ( ) throws CloneNotSupportedException { OneStepIterator clone = ( OneStepIterator ) super . clone ( ) ; if ( m_iterator != null ) { clone . m_iterator = m_iterator . cloneIterator ( ) ; } return clone ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { OneStepIterator clone = ( OneStepIterator ) super . cloneWithReset ( ) ; clone . m_iterator = m_iterator ; return clone ; } public boolean isReverseAxes ( ) { return m_iterator . isReverse ( ) ; } protected int getProximityPosition ( int predicateIndex ) { if ( ! isReverseAxes ( ) ) return super . getProximityPosition ( predicateIndex ) ; if ( predicateIndex < 0 ) return - 1 ; if ( m_proximityPositions [ predicateIndex ] <= 0 ) { XPathContext xctxt = getXPathContext ( ) ; try { OneStepIterator clone = ( OneStepIterator ) this . clone ( ) ; int root = getRoot ( ) ; xctxt . pushCurrentNode ( root ) ; clone . setRoot ( root , xctxt ) ; clone . m_predCount = predicateIndex ; int count = 1 ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } m_proximityPositions [ predicateIndex ] += count ; } catch ( CloneNotSupportedException cnse ) { } finally { xctxt . popCurrentNode ( ) ; } } return m_proximityPositions [ predicateIndex ] ; } public int getLength ( ) { if ( ! isReverseAxes ( ) ) return super . getLength ( ) ; boolean isPredicateTest = ( this == m_execContext . getSubContextList ( ) ) ; int predCount = getPredicateCount ( ) ; if ( - 1 != m_length && isPredicateTest && m_predicateIndex < 1 ) return m_length ; int count = 0 ; XPathContext xctxt = getXPathContext ( ) ; try { OneStepIterator clone = ( OneStepIterator ) this . cloneWithReset ( ) ; int root = getRoot ( ) ; xctxt . pushCurrentNode ( root ) ; clone . setRoot ( root , xctxt ) ; clone . m_predCount = m_predicateIndex ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } } catch ( CloneNotSupportedException cnse ) { } finally { xctxt . popCurrentNode ( ) ; } if ( isPredicateTest && m_predicateIndex < 1 ) m_length = count ; return count ; } protected void countProximityPosition ( int i ) { if ( ! isReverseAxes ( ) ) super . countProximityPosition ( i ) ; else if ( i < m_proximityPositions . length ) m_proximityPositions [ i ] -- ; } public void reset ( ) { super . reset ( ) ; if ( null != m_iterator ) m_iterator . reset ( ) ; } public int getAxis ( ) { return m_axis ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( m_axis != ( ( OneStepIterator ) expr ) . m_axis ) return false ; return true ; } } 	1	['14', '7', '0', '12', '41', '7', '3', '10', '10', '0.346153846', '330', '1', '1', '0.917241379', '0.273809524', '4', '18', '22.42857143', '9', '2.2857', '1']
package org . apache . xml . serializer ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . lang . reflect . Method ; import java . net . URL ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . StringTokenizer ; import java . security . PrivilegedAction ; import java . security . AccessController ; public class Encodings extends Object { static final int m_defaultLastPrintable = 0x7F ; static final String ENCODINGS_FILE = "org/apache/xml/serializer/Encodings.properties" ; static final String ENCODINGS_PROP = "org.apache.xalan.serialize.encodings" ; private static final Method SUN_CHAR2BYTE_CONVERTER_METHOD = findCharToByteConverterMethod ( ) ; private static Method findCharToByteConverterMethod ( ) { try { AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { try { Class charToByteConverterClass = ( Class ) Class . forName ( "sun.io.CharToByteConverter" ) ; Class argTypes [ ] = { String . class } ; return charToByteConverterClass . getMethod ( "getConverter" , argTypes ) ; } catch ( Exception e ) { throw new RuntimeException ( e . toString ( ) ) ; } } } ) ; } catch ( Exception e ) { System . err . println ( "Warning: Could not get charToByteConverterClass!" ) ; } return null ; } public static Writer getWriter ( OutputStream output , String encoding ) throws UnsupportedEncodingException { for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { try { return new OutputStreamWriter ( output , _encodings [ i ] . javaName ) ; } catch ( java . lang . IllegalArgumentException iae ) { } catch ( UnsupportedEncodingException usee ) { } } } try { return new OutputStreamWriter ( output , encoding ) ; } catch ( java . lang . IllegalArgumentException iae ) { throw new UnsupportedEncodingException ( encoding ) ; } } public static Object getCharToByteConverter ( String encoding ) { if ( SUN_CHAR2BYTE_CONVERTER_METHOD == null ) { return null ; } Object args [ ] = new Object [ 1 ] ; for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { try { args [ 0 ] = _encodings [ i ] . javaName ; Object converter = SUN_CHAR2BYTE_CONVERTER_METHOD . invoke ( null , args ) ; if ( null != converter ) return converter ; } catch ( Exception iae ) { } } } return null ; } public static int getLastPrintable ( String encoding ) { EncodingInfo ei ; String normalizedEncoding = encoding . toUpperCase ( ) ; ei = ( EncodingInfo ) _encodingTableKeyJava . get ( normalizedEncoding ) ; if ( ei == null ) ei = ( EncodingInfo ) _encodingTableKeyMime . get ( normalizedEncoding ) ; if ( ei != null ) return ei . lastPrintable ; return m_defaultLastPrintable ; } public static int getLastPrintable ( ) { return m_defaultLastPrintable ; } public static final String DEFAULT_MIME_ENCODING = "UTF-8" ; public static String getMimeEncoding ( String encoding ) { if ( null == encoding ) { try { encoding = System . getProperty ( "file.encoding" , "UTF8" ) ; if ( null != encoding ) { String jencoding = ( encoding . equalsIgnoreCase ( "Cp1252" ) || encoding . equalsIgnoreCase ( "ISO8859_1" ) || encoding . equalsIgnoreCase ( "8859_1" ) || encoding . equalsIgnoreCase ( "UTF8" ) ) ? DEFAULT_MIME_ENCODING : convertJava2MimeEncoding ( encoding ) ; encoding = ( null != jencoding ) ? jencoding : DEFAULT_MIME_ENCODING ; } else { encoding = DEFAULT_MIME_ENCODING ; } } catch ( SecurityException se ) { encoding = DEFAULT_MIME_ENCODING ; } } else { encoding = convertJava2MimeEncoding ( encoding ) ; } return encoding ; } public static String convertJava2MimeEncoding ( String encoding ) { EncodingInfo enc = ( EncodingInfo ) _encodingTableKeyJava . get ( encoding . toUpperCase ( ) ) ; if ( null != enc ) return enc . name ; return encoding ; } public static String convertMime2JavaEncoding ( String encoding ) { for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { return _encodings [ i ] . javaName ; } } return encoding ; } private static EncodingInfo [ ] loadEncodingInfo ( ) { URL url = null ; try { String urlString = null ; InputStream is = null ; try { urlString = System . getProperty ( ENCODINGS_PROP , "" ) ; } catch ( SecurityException e ) { } if ( urlString != null && urlString . length ( ) > 0 ) { url = new URL ( urlString ) ; is = url . openStream ( ) ; } if ( is == null ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; is = ss . getResourceAsStream ( ObjectFactory . findClassLoader ( ) , ENCODINGS_FILE ) ; } Properties props = new Properties ( ) ; if ( is != null ) { props . load ( is ) ; is . close ( ) ; } else { } int totalEntries = props . size ( ) ; int totalMimeNames = 0 ; Enumeration keys = props . keys ( ) ; for ( int i = 0 ; i < totalEntries ; ++ i ) { String javaName = ( String ) keys . nextElement ( ) ; String val = props . getProperty ( javaName ) ; totalMimeNames ++ ; int pos = val . indexOf ( ' ' ) ; for ( int j = 0 ; j < pos ; ++ j ) if ( val . charAt ( j ) == ',' ) totalMimeNames ++ ; } EncodingInfo [ ] ret = new EncodingInfo [ totalMimeNames ] ; int j = 0 ; keys = props . keys ( ) ; for ( int i = 0 ; i < totalEntries ; ++ i ) { String javaName = ( String ) keys . nextElement ( ) ; String val = props . getProperty ( javaName ) ; int pos = val . indexOf ( ' ' ) ; String mimeName ; int lastPrintable ; if ( pos < 0 ) { mimeName = val ; lastPrintable = 0x00FF ; } else { lastPrintable = Integer . decode ( val . substring ( pos ) . trim ( ) ) . intValue ( ) ; StringTokenizer st = new StringTokenizer ( val . substring ( 0 , pos ) , "," ) ; for ( boolean first = true ; st . hasMoreTokens ( ) ; first = false ) { mimeName = st . nextToken ( ) ; ret [ j ] = new EncodingInfo ( mimeName , javaName , lastPrintable ) ; _encodingTableKeyMime . put ( mimeName . toUpperCase ( ) , ret [ j ] ) ; if ( first ) _encodingTableKeyJava . put ( javaName . toUpperCase ( ) , ret [ j ] ) ; j ++ ; } } } return ret ; } catch ( java . net . MalformedURLException mue ) { throw new org . apache . xml . utils . WrappedRuntimeException ( mue ) ; } catch ( java . io . IOException ioe ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ioe ) ; } } private static final Hashtable _encodingTableKeyJava = new Hashtable ( ) ; private static final Hashtable _encodingTableKeyMime = new Hashtable ( ) ; private static final EncodingInfo [ ] _encodings = loadEncodingInfo ( ) ; } 	1	['11', '1', '0', '10', '49', '31', '5', '5', '8', '0.925', '429', '0.5', '1', '0', '0.266666667', '0', '0', '37.27272727', '12', '3.1818', '3']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; public final class WriterToUTF8Buffered extends Writer { private static final int BYTES_MAX = 16 * 1024 ; private static final int CHARS_MAX = ( BYTES_MAX / 3 ) ; private final OutputStream m_os ; private final byte m_outputBytes [ ] ; private final char m_inputChars [ ] ; private int count ; public WriterToUTF8Buffered ( OutputStream out ) throws UnsupportedEncodingException { m_os = out ; m_outputBytes = new byte [ BYTES_MAX + 3 ] ; m_inputChars = new char [ CHARS_MAX + 1 ] ; count = 0 ; } public void write ( final int c ) throws IOException { if ( count >= BYTES_MAX ) flushBuffer ( ) ; if ( c < 0x80 ) { m_outputBytes [ count ++ ] = ( byte ) ( c ) ; } else if ( c < 0x800 ) { m_outputBytes [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; m_outputBytes [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { m_outputBytes [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; m_outputBytes [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; m_outputBytes [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } public void write ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { int lengthx3 = 3 * length ; if ( lengthx3 >= BYTES_MAX - count ) { flushBuffer ( ) ; if ( lengthx3 >= BYTES_MAX ) { final int chunks = 1 + length / CHARS_MAX ; for ( int chunk = 0 ; chunk < chunks ; chunk ++ ) { int start_chunk = start + ( ( length * chunk ) / chunks ) ; int end_chunk = start + ( ( length * ( chunk + 1 ) ) / chunks ) ; int len_chunk = ( end_chunk - start_chunk ) ; this . write ( chars , start_chunk , len_chunk ) ; } return ; } } final int n = length + start ; final byte [ ] buf_loc = m_outputBytes ; int count_loc = count ; int i = start ; { char c ; for ( ; i < n && ( c = chars [ i ] ) < 0x80 ; i ++ ) buf_loc [ count_loc ++ ] = ( byte ) c ; } for ( ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) buf_loc [ count_loc ++ ] = ( byte ) ( c ) ; else if ( c < 0x800 ) { buf_loc [ count_loc ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf_loc [ count_loc ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf_loc [ count_loc ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf_loc [ count_loc ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf_loc [ count_loc ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } count = count_loc ; } private void directWrite ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { if ( length >= BYTES_MAX - count ) { flushBuffer ( ) ; if ( length >= BYTES_MAX ) { int chunks = 1 + length / CHARS_MAX ; for ( int chunk = 0 ; chunk < chunks ; chunk ++ ) { int start_chunk = start + ( ( length * chunk ) / chunks ) ; int end_chunk = start + ( ( length * ( chunk + 1 ) ) / chunks ) ; int len_chunk = ( end_chunk - start_chunk ) ; this . directWrite ( chars , start_chunk , len_chunk ) ; } return ; } } final int n = length + start ; final byte [ ] buf_loc = m_outputBytes ; int count_loc = count ; for ( int i = start ; i < n ; i ++ ) buf_loc [ count_loc ++ ] = ( byte ) buf_loc [ i ] ; count = count_loc ; } public void write ( final String s ) throws IOException { final int length = s . length ( ) ; int lengthx3 = 3 * length ; if ( lengthx3 >= BYTES_MAX - count ) { flushBuffer ( ) ; if ( lengthx3 >= BYTES_MAX ) { final int start = 0 ; int chunks = 1 + length / CHARS_MAX ; for ( int chunk = 0 ; chunk < chunks ; chunk ++ ) { int start_chunk = start + ( ( length * chunk ) / chunks ) ; int end_chunk = start + ( ( length * ( chunk + 1 ) ) / chunks ) ; int len_chunk = ( end_chunk - start_chunk ) ; s . getChars ( start_chunk , end_chunk , m_inputChars , 0 ) ; this . write ( m_inputChars , 0 , len_chunk ) ; } return ; } } s . getChars ( 0 , length , m_inputChars , 0 ) ; final char [ ] chars = m_inputChars ; final int n = length ; final byte [ ] buf_loc = m_outputBytes ; int count_loc = count ; int i = 0 ; { char c ; for ( ; i < n && ( c = chars [ i ] ) < 0x80 ; i ++ ) buf_loc [ count_loc ++ ] = ( byte ) c ; } for ( ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) buf_loc [ count_loc ++ ] = ( byte ) ( c ) ; else if ( c < 0x800 ) { buf_loc [ count_loc ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf_loc [ count_loc ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf_loc [ count_loc ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf_loc [ count_loc ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf_loc [ count_loc ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } count = count_loc ; } public void flushBuffer ( ) throws IOException { if ( count > 0 ) { m_os . write ( m_outputBytes , 0 , count ) ; count = 0 ; } } public void flush ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . flush ( ) ; } public void close ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . close ( ) ; } public OutputStream getOutputStream ( ) { return m_os ; } public void directWrite ( final String s ) throws IOException { final int length = s . length ( ) ; if ( length >= BYTES_MAX - count ) { flushBuffer ( ) ; if ( length >= BYTES_MAX ) { final int start = 0 ; int chunks = 1 + length / CHARS_MAX ; for ( int chunk = 0 ; chunk < chunks ; chunk ++ ) { int start_chunk = start + ( ( length * chunk ) / chunks ) ; int end_chunk = start + ( ( length * ( chunk + 1 ) ) / chunks ) ; int len_chunk = ( end_chunk - start_chunk ) ; s . getChars ( start_chunk , end_chunk , m_inputChars , 0 ) ; this . directWrite ( m_inputChars , 0 , len_chunk ) ; } return ; } } s . getChars ( 0 , length , m_inputChars , 0 ) ; final char [ ] chars = m_inputChars ; final byte [ ] buf_loc = m_outputBytes ; int count_loc = count ; int i = 0 ; while ( i < length ) buf_loc [ count_loc ++ ] = ( byte ) chars [ i ++ ] ; count = count_loc ; } } 	1	['10', '2', '0', '1', '16', '0', '1', '0', '9', '0.537037037', '703', '1', '0', '0.590909091', '0.36', '1', '2', '68.7', '1', '0.9', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . objects . XRTreeFragSelectWrapper ; import org . apache . xpath . objects . XString ; import org . apache . xalan . res . XSLTErrorResources ; public class ElemVariable extends ElemTemplateElement { public ElemVariable ( ) { } protected int m_index ; int m_frameSize = - 1 ; public void setIndex ( int index ) { m_index = index ; } public int getIndex ( ) { return m_index ; } private XPath m_selectPattern ; public void setSelect ( XPath v ) { m_selectPattern = v ; } public XPath getSelect ( ) { return m_selectPattern ; } protected QName m_qname ; public void setName ( QName v ) { m_qname = v ; } public QName getName ( ) { return m_qname ; } private boolean m_isTopLevel = false ; public void setIsTopLevel ( boolean v ) { m_isTopLevel = v ; } public boolean getIsTopLevel ( ) { return m_isTopLevel ; } public int getXSLToken ( ) { return Constants . ELEMNAME_VARIABLE ; } public String getNodeName ( ) { return Constants . ELEMNAME_VARIABLE_STRING ; } public ElemVariable ( ElemVariable param ) throws TransformerException { m_selectPattern = param . m_selectPattern ; m_qname = param . m_qname ; m_isTopLevel = param . m_isTopLevel ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; int sourceNode = transformer . getXPathContext ( ) . getCurrentNode ( ) ; XObject var = getValue ( transformer , sourceNode ) ; transformer . getXPathContext ( ) . getVarStack ( ) . setLocalVariable ( m_index , var ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public XObject getValue ( TransformerImpl transformer , int sourceNode ) throws TransformerException { XObject var ; XPathContext xctxt = transformer . getXPathContext ( ) ; xctxt . pushCurrentNode ( sourceNode ) ; try { if ( null != m_selectPattern ) { var = m_selectPattern . execute ( xctxt , sourceNode , this ) ; var . allowDetachToRelease ( false ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , m_selectPattern , var ) ; } else if ( null == getFirstChildElem ( ) ) { var = XString . EMPTYSTRING ; } else { int df ; try { if ( m_parentNode instanceof Stylesheet ) df = transformer . transformToGlobalRTF ( this ) ; else df = transformer . transformToRTF ( this ) ; } finally { } var = new XRTreeFrag ( df , xctxt , this ) ; } } finally { xctxt . popCurrentNode ( ) ; } return var ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { if ( null == m_selectPattern && org . apache . xalan . processor . TransformerFactoryImpl . m_optimize ) { XPath newSelect = rewriteChildToExpression ( this ) ; if ( null != newSelect ) m_selectPattern = newSelect ; } StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_selectPattern ) m_selectPattern . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( ! ( m_parentNode instanceof Stylesheet ) && m_qname != null ) { m_index = cstate . addVariableName ( m_qname ) - cstate . getGlobalsSize ( ) ; } else if ( m_parentNode instanceof Stylesheet ) { cstate . resetStackFrameSize ( ) ; } super . compose ( sroot ) ; } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { super . endCompose ( sroot ) ; if ( m_parentNode instanceof Stylesheet ) { StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; m_frameSize = cstate . getFrameSize ( ) ; cstate . resetStackFrameSize ( ) ; } } static XPath rewriteChildToExpression ( ElemTemplateElement varElem ) throws TransformerException { ElemTemplateElement t = varElem . getFirstChildElem ( ) ; if ( null != t && null == t . getNextSiblingElem ( ) ) { int etype = t . getXSLToken ( ) ; if ( Constants . ELEMNAME_VALUEOF == etype ) { ElemValueOf valueof = ( ElemValueOf ) t ; if ( valueof . getDisableOutputEscaping ( ) == false && valueof . getDOMBackPointer ( ) == null ) { varElem . m_firstChild = null ; return new XPath ( new XRTreeFragSelectWrapper ( valueof . getSelect ( ) . getExpression ( ) ) ) ; } } else if ( Constants . ELEMNAME_TEXTLITERALRESULT == etype ) { ElemTextLiteral lit = ( ElemTextLiteral ) t ; if ( lit . getDisableOutputEscaping ( ) == false && lit . getDOMBackPointer ( ) == null ) { String str = lit . getNodeValue ( ) ; XString xstr = new XString ( str ) ; varElem . m_firstChild = null ; return new XPath ( new XRTreeFragSelectWrapper ( xstr ) ) ; } } } return null ; } public void recompose ( StylesheetRoot root ) { root . recomposeVariables ( this ) ; } public void setParentElem ( ElemTemplateElement p ) { super . setParentElem ( p ) ; p . m_hasVariableDecl = true ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitVariableOrParamDecl ( this ) ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( null != m_selectPattern ) m_selectPattern . getExpression ( ) . callVisitors ( m_selectPattern , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } public boolean isPsuedoVar ( ) { java . lang . String ns = m_qname . getNamespaceURI ( ) ; if ( ( null != ns ) && ns . equals ( RedundentExprEliminator . PSUEDOVARNAMESPACE ) ) { if ( m_qname . getLocalName ( ) . startsWith ( "#" ) ) return true ; } return false ; } public ElemTemplateElement appendChild ( ElemTemplateElement elem ) { if ( m_selectPattern != null ) { error ( XSLTErrorResources . ER_CANT_HAVE_CONTENT_AND_SELECT , new Object [ ] { "xsl:" + this . getNodeName ( ) } ) ; return null ; } return super . appendChild ( elem ) ; } } 	1	['23', '3', '3', '35', '76', '161', '18', '23', '20', '0.827272727', '417', '0.8', '2', '0.903225806', '0.169565217', '2', '16', '16.91304348', '4', '1.1304', '2']
package org . apache . xml . serializer ; import javax . xml . transform . SourceLocator ; import org . xml . sax . SAXException ; public interface ExtendedContentHandler extends org . xml . sax . ContentHandler { public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException ; public void addAttributes ( org . xml . sax . Attributes atts ) throws org . xml . sax . SAXException ; public void addAttribute ( String qName , String value ) ; public void characters ( String chars ) throws SAXException ; public void endElement ( String elemName ) throws SAXException ; public void startElement ( String uri , String localName , String qName ) throws org . xml . sax . SAXException ; public void startElement ( String qName ) throws SAXException ; public void namespaceAfterStartElement ( String uri , String prefix ) throws SAXException ; public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException ; public void entityReference ( String entityName ) throws SAXException ; public NamespaceMappings getNamespaceMappings ( ) ; public String getPrefix ( String uri ) ; public String getNamespaceURI ( String name , boolean isElement ) ; public String getNamespaceURIFromPrefix ( String prefix ) ; public void setSourceLocator ( SourceLocator locator ) ; public static final int NO_BAD_CHARS = 0x1 ; public static final int HTML_ATTREMPTY = 0x2 ; public static final int HTML_ATTRURL = 0x4 ; public void addUniqueAttribute ( String qName , String value , int flags ) throws SAXException ; } 	1	['16', '1', '0', '2', '16', '120', '1', '1', '16', '1.066666667', '19', '0', '0', '0', '0.354166667', '0', '0', '0', '1', '1', '2']
package org . apache . xalan . templates ; import java . text . DecimalFormatSymbols ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExtensionNamespacesManager ; import org . apache . xalan . processor . XSLTSchema ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . ref . ExpandedNameTable ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; public class StylesheetRoot extends StylesheetComposed implements java . io . Serializable , Templates { public StylesheetRoot ( ErrorListener errorListener ) throws TransformerConfigurationException { super ( null ) ; setStylesheetRoot ( this ) ; try { m_selectDefault = new XPath ( "node()" , this , this , XPath . SELECT , errorListener ) ; initDefaultRule ( errorListener ) ; } catch ( TransformerException se ) { throw new TransformerConfigurationException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_INIT_DEFAULT_TEMPLATES , null ) , se ) ; } } private Hashtable m_availElems ; public StylesheetRoot ( XSLTSchema schema , ErrorListener listener ) throws TransformerConfigurationException { this ( listener ) ; m_availElems = schema . getElemsAvailable ( ) ; } public boolean isRoot ( ) { return true ; } public Hashtable getAvailableElements ( ) { return m_availElems ; } private ExtensionNamespacesManager m_extNsMgr = null ; public ExtensionNamespacesManager getExtensionNamespacesManager ( ) { if ( m_extNsMgr == null ) m_extNsMgr = new ExtensionNamespacesManager ( ) ; return m_extNsMgr ; } public Vector getExtensions ( ) { return m_extNsMgr != null ? m_extNsMgr . getExtensions ( ) : null ; } public Transformer newTransformer ( ) { return new TransformerImpl ( this ) ; } public Properties getDefaultOutputProps ( ) { return m_outputProperties . getProperties ( ) ; } public Properties getOutputProperties ( ) { return ( Properties ) getDefaultOutputProps ( ) . clone ( ) ; } public void recompose ( ) throws TransformerException { Vector recomposableElements = new Vector ( ) ; if ( null == m_globalImportList ) { Vector importList = new Vector ( ) ; addImports ( this , true , importList ) ; m_globalImportList = new StylesheetComposed [ importList . size ( ) ] ; for ( int i = 0 , j = importList . size ( ) - 1 ; i < importList . size ( ) ; i ++ ) { m_globalImportList [ j ] = ( StylesheetComposed ) importList . elementAt ( i ) ; m_globalImportList [ j ] . recomposeIncludes ( m_globalImportList [ j ] ) ; m_globalImportList [ j -- ] . recomposeImports ( ) ; } } int n = getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { StylesheetComposed imported = getGlobalImport ( i ) ; imported . recompose ( recomposableElements ) ; } QuickSort2 ( recomposableElements , 0 , recomposableElements . size ( ) - 1 ) ; m_outputProperties = new OutputProperties ( org . apache . xml . serializer . Method . UNKNOWN ) ; m_attrSets = new Hashtable ( ) ; m_decimalFormatSymbols = new Hashtable ( ) ; m_keyDecls = new Vector ( ) ; m_namespaceAliasComposed = new Hashtable ( ) ; m_templateList = new TemplateList ( ) ; m_variables = new Vector ( ) ; for ( int i = recomposableElements . size ( ) - 1 ; i >= 0 ; i -- ) ( ( ElemTemplateElement ) recomposableElements . elementAt ( i ) ) . recompose ( this ) ; initComposeState ( ) ; m_templateList . compose ( this ) ; m_outputProperties . compose ( this ) ; m_outputProperties . endCompose ( this ) ; n = getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { StylesheetComposed imported = this . getGlobalImport ( i ) ; int includedCount = imported . getIncludeCountComposed ( ) ; for ( int j = - 1 ; j < includedCount ; j ++ ) { Stylesheet included = imported . getIncludeComposed ( j ) ; composeTemplates ( included ) ; } } if ( m_extNsMgr != null ) m_extNsMgr . registerUnregisteredNamespaces ( ) ; clearComposeState ( ) ; } void composeTemplates ( ElemTemplateElement templ ) throws TransformerException { templ . compose ( this ) ; for ( ElemTemplateElement child = templ . getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { composeTemplates ( child ) ; } templ . endCompose ( this ) ; } private StylesheetComposed [ ] m_globalImportList ; protected void addImports ( Stylesheet stylesheet , boolean addToList , Vector importList ) { int n = stylesheet . getImportCount ( ) ; if ( n > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { Stylesheet imported = stylesheet . getImport ( i ) ; addImports ( imported , true , importList ) ; } } n = stylesheet . getIncludeCount ( ) ; if ( n > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { Stylesheet included = stylesheet . getInclude ( i ) ; addImports ( included , false , importList ) ; } } if ( addToList ) importList . addElement ( stylesheet ) ; } public StylesheetComposed getGlobalImport ( int i ) { return m_globalImportList [ i ] ; } public int getGlobalImportCount ( ) { return ( m_globalImportList != null ) ? m_globalImportList . length : 1 ; } public int getImportNumber ( StylesheetComposed sheet ) { if ( this == sheet ) return 0 ; int n = getGlobalImportCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( sheet == getGlobalImport ( i ) ) return i ; } return - 1 ; } private OutputProperties m_outputProperties ; void recomposeOutput ( OutputProperties oprops ) throws TransformerException { m_outputProperties . copyFrom ( oprops ) ; } public OutputProperties getOutputComposed ( ) { return m_outputProperties ; } private boolean m_outputMethodSet = false ; public boolean isOutputMethodSet ( ) { return m_outputMethodSet ; } private Hashtable m_attrSets ; void recomposeAttributeSets ( ElemAttributeSet attrSet ) { Vector attrSetList = ( Vector ) m_attrSets . get ( attrSet . getName ( ) ) ; if ( null == attrSetList ) { attrSetList = new Vector ( ) ; m_attrSets . put ( attrSet . getName ( ) , attrSetList ) ; } attrSetList . addElement ( attrSet ) ; } public Vector getAttributeSetComposed ( QName name ) throws ArrayIndexOutOfBoundsException { return ( Vector ) m_attrSets . get ( name ) ; } private Hashtable m_decimalFormatSymbols ; void recomposeDecimalFormats ( DecimalFormatProperties dfp ) { DecimalFormatSymbols oldDfs = ( DecimalFormatSymbols ) m_decimalFormatSymbols . get ( dfp . getName ( ) ) ; if ( null == oldDfs ) { m_decimalFormatSymbols . put ( dfp . getName ( ) , dfp . getDecimalFormatSymbols ( ) ) ; } else if ( ! dfp . getDecimalFormatSymbols ( ) . equals ( oldDfs ) ) { String themsg ; if ( dfp . getName ( ) . equals ( new QName ( "" ) ) ) { themsg = XSLMessages . createWarning ( XSLTErrorResources . WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , new Object [ 0 ] ) ; } else { themsg = XSLMessages . createWarning ( XSLTErrorResources . WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , new Object [ ] { dfp . getName ( ) } ) ; } error ( themsg ) ; } } public DecimalFormatSymbols getDecimalFormatComposed ( QName name ) { return ( DecimalFormatSymbols ) m_decimalFormatSymbols . get ( name ) ; } private Vector m_keyDecls ; void recomposeKeys ( KeyDeclaration keyDecl ) { m_keyDecls . addElement ( keyDecl ) ; } public Vector getKeysComposed ( ) { return m_keyDecls ; } private Hashtable m_namespaceAliasComposed ; void recomposeNamespaceAliases ( NamespaceAlias nsAlias ) { m_namespaceAliasComposed . put ( nsAlias . getStylesheetNamespace ( ) , nsAlias ) ; } public NamespaceAlias getNamespaceAliasComposed ( String uri ) { return ( NamespaceAlias ) ( ( null == m_namespaceAliasComposed ) ? null : m_namespaceAliasComposed . get ( uri ) ) ; } private TemplateList m_templateList ; void recomposeTemplates ( ElemTemplate template ) { m_templateList . setTemplate ( template ) ; } public final TemplateList getTemplateListComposed ( ) { return m_templateList ; } public final void setTemplateListComposed ( TemplateList templateList ) { m_templateList = templateList ; } public ElemTemplate getTemplateComposed ( XPathContext xctxt , int targetNode , QName mode , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { return m_templateList . getTemplate ( xctxt , targetNode , mode , quietConflictWarnings , dtm ) ; } public ElemTemplate getTemplateComposed ( XPathContext xctxt , int targetNode , QName mode , int maxImportLevel , int endImportLevel , boolean quietConflictWarnings , DTM dtm ) throws TransformerException { return m_templateList . getTemplate ( xctxt , targetNode , mode , maxImportLevel , endImportLevel , quietConflictWarnings , dtm ) ; } public ElemTemplate getTemplateComposed ( QName qname ) { return m_templateList . getTemplate ( qname ) ; } private Vector m_variables ; void recomposeVariables ( ElemVariable elemVar ) { if ( getVariableOrParamComposed ( elemVar . getName ( ) ) == null ) { elemVar . setIsTopLevel ( true ) ; elemVar . setIndex ( m_variables . size ( ) ) ; m_variables . addElement ( elemVar ) ; } } public ElemVariable getVariableOrParamComposed ( QName qname ) { if ( null != m_variables ) { int n = m_variables . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ElemVariable var = ( ElemVariable ) m_variables . elementAt ( i ) ; if ( var . getName ( ) . equals ( qname ) ) return var ; } } return null ; } public Vector getVariablesAndParamsComposed ( ) { return m_variables ; } private TemplateList m_whiteSpaceInfoList ; void recomposeWhiteSpaceInfo ( WhiteSpaceInfo wsi ) { if ( null == m_whiteSpaceInfoList ) m_whiteSpaceInfoList = new TemplateList ( ) ; m_whiteSpaceInfoList . setTemplate ( wsi ) ; } public boolean shouldCheckWhitespace ( ) { return null != m_whiteSpaceInfoList ; } public WhiteSpaceInfo getWhiteSpaceInfo ( XPathContext support , int targetElement , DTM dtm ) throws TransformerException { if ( null != m_whiteSpaceInfoList ) return ( WhiteSpaceInfo ) m_whiteSpaceInfoList . getTemplate ( support , targetElement , null , false , dtm ) ; else return null ; } public boolean shouldStripWhiteSpace ( XPathContext support , int targetElement ) throws TransformerException { if ( null != m_whiteSpaceInfoList ) { while ( DTM . NULL != targetElement ) { DTM dtm = support . getDTM ( targetElement ) ; WhiteSpaceInfo info = ( WhiteSpaceInfo ) m_whiteSpaceInfoList . getTemplate ( support , targetElement , null , false , dtm ) ; if ( null != info ) return info . getShouldStripSpace ( ) ; int parent = dtm . getParent ( targetElement ) ; if ( DTM . NULL != parent && DTM . ELEMENT_NODE == dtm . getNodeType ( parent ) ) targetElement = parent ; else targetElement = DTM . NULL ; } } return false ; } public boolean canStripWhiteSpace ( ) { return ( null != m_whiteSpaceInfoList ) ; } private ElemTemplate m_defaultTextRule ; public final ElemTemplate getDefaultTextRule ( ) { return m_defaultTextRule ; } private ElemTemplate m_defaultRule ; public final ElemTemplate getDefaultRule ( ) { return m_defaultRule ; } private ElemTemplate m_defaultRootRule ; public final ElemTemplate getDefaultRootRule ( ) { return m_defaultRootRule ; } private ElemTemplate m_startRule ; public final ElemTemplate getStartRule ( ) { return m_startRule ; } XPath m_selectDefault ; private void initDefaultRule ( ErrorListener errorListener ) throws TransformerException { m_defaultRule = new ElemTemplate ( ) ; m_defaultRule . setStylesheet ( this ) ; XPath defMatch = new XPath ( "*" , this , this , XPath . MATCH , errorListener ) ; m_defaultRule . setMatch ( defMatch ) ; ElemApplyTemplates childrenElement = new ElemApplyTemplates ( ) ; childrenElement . setIsDefaultTemplate ( true ) ; childrenElement . setSelect ( m_selectDefault ) ; m_defaultRule . appendChild ( childrenElement ) ; m_startRule = m_defaultRule ; m_defaultTextRule = new ElemTemplate ( ) ; m_defaultTextRule . setStylesheet ( this ) ; defMatch = new XPath ( "text() | @*" , this , this , XPath . MATCH , errorListener ) ; m_defaultTextRule . setMatch ( defMatch ) ; ElemValueOf elemValueOf = new ElemValueOf ( ) ; m_defaultTextRule . appendChild ( elemValueOf ) ; XPath selectPattern = new XPath ( "." , this , this , XPath . SELECT , errorListener ) ; elemValueOf . setSelect ( selectPattern ) ; m_defaultRootRule = new ElemTemplate ( ) ; m_defaultRootRule . setStylesheet ( this ) ; defMatch = new XPath ( "/" , this , this , XPath . MATCH , errorListener ) ; m_defaultRootRule . setMatch ( defMatch ) ; childrenElement = new ElemApplyTemplates ( ) ; childrenElement . setIsDefaultTemplate ( true ) ; m_defaultRootRule . appendChild ( childrenElement ) ; childrenElement . setSelect ( m_selectDefault ) ; } private void QuickSort2 ( Vector v , int lo0 , int hi0 ) { int lo = lo0 ; int hi = hi0 ; if ( hi0 > lo0 ) { ElemTemplateElement midNode = ( ElemTemplateElement ) v . elementAt ( ( lo0 + hi0 ) / 2 ) ; while ( lo <= hi ) { while ( ( lo < hi0 ) && ( ( ( ElemTemplateElement ) v . elementAt ( lo ) ) . compareTo ( midNode ) < 0 ) ) { ++ lo ; } while ( ( hi > lo0 ) && ( ( ( ElemTemplateElement ) v . elementAt ( hi ) ) . compareTo ( midNode ) > 0 ) ) { -- hi ; } if ( lo <= hi ) { ElemTemplateElement node = ( ElemTemplateElement ) v . elementAt ( lo ) ; v . setElementAt ( v . elementAt ( hi ) , lo ) ; v . setElementAt ( node , hi ) ; ++ lo ; -- hi ; } } if ( lo0 < hi ) { QuickSort2 ( v , lo0 , hi ) ; } if ( lo < hi0 ) { QuickSort2 ( v , lo , hi0 ) ; } } } private ComposeState m_composeState ; void initComposeState ( ) { m_composeState = new ComposeState ( ) ; } ComposeState getComposeState ( ) { return m_composeState ; } private void clearComposeState ( ) { m_composeState = null ; } class ComposeState { ComposeState ( ) { int size = m_variables . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { ElemVariable ev = ( ElemVariable ) m_variables . elementAt ( i ) ; m_variableNames . addElement ( ev . getName ( ) ) ; } } private ExpandedNameTable m_ent = new ExpandedNameTable ( ) ; public int getQNameID ( QName qname ) { return m_ent . getExpandedTypeID ( qname . getNamespace ( ) , qname . getLocalName ( ) , org . apache . xml . dtm . DTM . ELEMENT_NODE ) ; } private java . util . Vector m_variableNames = new java . util . Vector ( ) ; int addVariableName ( final org . apache . xml . utils . QName qname ) { int pos = m_variableNames . size ( ) ; m_variableNames . addElement ( qname ) ; int frameSize = m_variableNames . size ( ) - getGlobalsSize ( ) ; if ( frameSize > m_maxStackFrameSize ) m_maxStackFrameSize ++ ; return pos ; } void resetStackFrameSize ( ) { m_maxStackFrameSize = 0 ; } int getFrameSize ( ) { return m_maxStackFrameSize ; } int getCurrentStackFrameSize ( ) { return m_variableNames . size ( ) ; } void setCurrentStackFrameSize ( int sz ) { m_variableNames . setSize ( sz ) ; } int getGlobalsSize ( ) { return m_variables . size ( ) ; } IntStack m_marks = new IntStack ( ) ; void pushStackMark ( ) { m_marks . push ( getCurrentStackFrameSize ( ) ) ; } void popStackMark ( ) { int mark = m_marks . pop ( ) ; setCurrentStackFrameSize ( mark ) ; } java . util . Vector getVariableNames ( ) { return m_variableNames ; } private int m_maxStackFrameSize ; } } 	1	['50', '5', '0', '53', '121', '1069', '45', '24', '34', '0.939909297', '987', '0.944444444', '11', '0.853658537', '0.079130435', '3', '6', '18.38', '10', '1.6', '3']
package org . apache . xpath . domapi ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . events . Event ; import org . w3c . dom . events . EventListener ; import org . w3c . dom . events . EventTarget ; import org . w3c . dom . traversal . NodeIterator ; import org . w3c . dom . xpath . XPathException ; import org . w3c . dom . xpath . XPathResult ; public class XPathResultImpl implements XPathResult , EventListener { private XObject m_resultObj ; private short m_resultType = ANY_TYPE ; private boolean m_isInvalidIteratorState = false ; private Node m_contextNode ; private NodeIterator m_iterator = null ; private NodeList m_list = null ; XPathResultImpl ( short type , XObject result , Node contextNode ) { if ( ! isValidType ( type ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INVALID_XPATH_TYPE , new Object [ ] { new Integer ( type ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } if ( null == result ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_EMPTY_XPATH_RESULT , null ) ; throw new XPathException ( XPathException . INVALID_EXPRESSION_ERR , fmsg ) ; } this . m_resultObj = result ; this . m_contextNode = contextNode ; if ( type == ANY_TYPE ) { this . m_resultType = getTypeFromXObject ( result ) ; } else { this . m_resultType = type ; } if ( ( ( m_resultType == XPathResult . ORDERED_NODE_ITERATOR_TYPE ) || ( m_resultType == XPathResult . UNORDERED_NODE_ITERATOR_TYPE ) ) && ( contextNode instanceof EventTarget ) ) { ( ( EventTarget ) contextNode ) . addEventListener ( "MutationEvents" , this , true ) ; } if ( ( m_resultType == ORDERED_NODE_ITERATOR_TYPE ) || ( m_resultType == UNORDERED_NODE_ITERATOR_TYPE ) || ( m_resultType == ANY_UNORDERED_NODE_TYPE ) || ( m_resultType == FIRST_ORDERED_NODE_TYPE ) ) { try { m_iterator = m_resultObj . nodeset ( ) ; } catch ( TransformerException te ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCOMPATIBLE_TYPES , new Object [ ] { getTypeString ( getTypeFromXObject ( m_resultObj ) ) , getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } } else if ( ( m_resultType == UNORDERED_NODE_SNAPSHOT_TYPE ) || ( m_resultType == ORDERED_NODE_SNAPSHOT_TYPE ) ) { try { m_list = m_resultObj . nodelist ( ) ; } catch ( TransformerException te ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCOMPATIBLE_TYPES , new Object [ ] { getTypeString ( getTypeFromXObject ( m_resultObj ) ) , getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } } } public short getResultType ( ) { return m_resultType ; } public double getNumberValue ( ) throws XPathException { if ( getResultType ( ) != NUMBER_TYPE ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_CONVERT_TO_NUMBER , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } else { try { return m_resultObj . num ( ) ; } catch ( Exception e ) { throw new XPathException ( XPathException . TYPE_ERR , e . getMessage ( ) ) ; } } } public String getStringValue ( ) throws XPathException { if ( getResultType ( ) != STRING_TYPE ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_CONVERT_TO_STRING , new Object [ ] { m_resultObj . getTypeString ( ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } else { try { return m_resultObj . str ( ) ; } catch ( Exception e ) { throw new XPathException ( XPathException . TYPE_ERR , e . getMessage ( ) ) ; } } } public boolean getBooleanValue ( ) throws XPathException { if ( getResultType ( ) != BOOLEAN_TYPE ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_CONVERT_TO_BOOLEAN , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } else { try { return m_resultObj . bool ( ) ; } catch ( TransformerException e ) { throw new XPathException ( XPathException . TYPE_ERR , e . getMessage ( ) ) ; } } } public Node getSingleNodeValue ( ) throws XPathException { if ( ( m_resultType != ANY_UNORDERED_NODE_TYPE ) && ( m_resultType != FIRST_ORDERED_NODE_TYPE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_CONVERT_TO_SINGLENODE , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } NodeIterator result = null ; try { result = m_resultObj . nodeset ( ) ; } catch ( TransformerException te ) { throw new XPathException ( XPathException . TYPE_ERR , te . getMessage ( ) ) ; } if ( null == result ) return null ; Node node = result . nextNode ( ) ; if ( isNamespaceNode ( node ) ) { return new XPathNamespaceImpl ( node ) ; } else { return node ; } } public boolean getInvalidIteratorState ( ) { return m_isInvalidIteratorState ; } public int getSnapshotLength ( ) throws XPathException { if ( ( m_resultType != UNORDERED_NODE_SNAPSHOT_TYPE ) && ( m_resultType != ORDERED_NODE_SNAPSHOT_TYPE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_GET_SNAPSHOT_LENGTH , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } return m_list . getLength ( ) ; } public Node iterateNext ( ) throws XPathException , DOMException { if ( ( m_resultType != UNORDERED_NODE_ITERATOR_TYPE ) && ( m_resultType != ORDERED_NODE_ITERATOR_TYPE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NON_ITERATOR_TYPE , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } if ( getInvalidIteratorState ( ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_DOC_MUTATED , null ) ; throw new DOMException ( DOMException . INVALID_STATE_ERR , fmsg ) ; } Node node = m_iterator . nextNode ( ) ; if ( isNamespaceNode ( node ) ) { return new XPathNamespaceImpl ( node ) ; } else { return node ; } } public Node snapshotItem ( int index ) throws XPathException { if ( ( m_resultType != UNORDERED_NODE_SNAPSHOT_TYPE ) && ( m_resultType != ORDERED_NODE_SNAPSHOT_TYPE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NON_SNAPSHOT_TYPE , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } Node node = m_list . item ( index ) ; if ( isNamespaceNode ( node ) ) { return new XPathNamespaceImpl ( node ) ; } else { return node ; } } public static boolean isValidType ( short type ) { switch ( type ) { case ANY_TYPE : case NUMBER_TYPE : case STRING_TYPE : case BOOLEAN_TYPE : case UNORDERED_NODE_ITERATOR_TYPE : case ORDERED_NODE_ITERATOR_TYPE : case UNORDERED_NODE_SNAPSHOT_TYPE : case ORDERED_NODE_SNAPSHOT_TYPE : case ANY_UNORDERED_NODE_TYPE : case FIRST_ORDERED_NODE_TYPE : return true ; default : return false ; } } public void handleEvent ( Event event ) { if ( event . getType ( ) . equals ( "MutationEvents" ) ) { m_isInvalidIteratorState = true ; ( ( EventTarget ) m_contextNode ) . removeEventListener ( "MutationEvents" , this , true ) ; } } public String getTypeString ( int type ) { switch ( type ) { case ANY_TYPE : return "ANY_TYPE" ; case ANY_UNORDERED_NODE_TYPE : return "ANY_UNORDERED_NODE_TYPE" ; case BOOLEAN_TYPE : return "BOOLEAN" ; case FIRST_ORDERED_NODE_TYPE : return "FIRST_ORDERED_NODE_TYPE" ; case NUMBER_TYPE : return "NUMBER_TYPE" ; case ORDERED_NODE_ITERATOR_TYPE : return "ORDERED_NODE_ITERATOR_TYPE" ; case ORDERED_NODE_SNAPSHOT_TYPE : return "ORDERED_NODE_SNAPSHOT_TYPE" ; case STRING_TYPE : return "STRING_TYPE" ; case UNORDERED_NODE_ITERATOR_TYPE : return "UNORDERED_NODE_ITERATOR_TYPE" ; case UNORDERED_NODE_SNAPSHOT_TYPE : return "UNORDERED_NODE_SNAPSHOT_TYPE" ; default : return "#UNKNOWN" ; } } private short getTypeFromXObject ( XObject object ) { switch ( object . getType ( ) ) { case XObject . CLASS_BOOLEAN : return BOOLEAN_TYPE ; case XObject . CLASS_NODESET : return UNORDERED_NODE_ITERATOR_TYPE ; case XObject . CLASS_NUMBER : return NUMBER_TYPE ; case XObject . CLASS_STRING : return STRING_TYPE ; case XObject . CLASS_RTREEFRAG : return UNORDERED_NODE_ITERATOR_TYPE ; case XObject . CLASS_NULL : return ANY_TYPE ; default : return ANY_TYPE ; } } private boolean isNamespaceNode ( Node node ) { if ( ( null != node ) && ( node . getNodeType ( ) == Node . ATTRIBUTE_NODE ) && ( node . getNodeName ( ) . startsWith ( "xmlns:" ) || node . getNodeName ( ) . equals ( "xmlns" ) ) ) { return true ; } else { return false ; } } } 	1	['15', '1', '0', '4', '40', '35', '1', '3', '12', '0.773809524', '573', '1', '1', '0', '0.255555556', '0', '0', '36.8', '5', '1.4667', '1']
package org . apache . xml . utils . res ; public class XResources_ja_JP_HA extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "alphabet" , new char [ ] { 0x3042 , 0x3044 , 0x3046 , 0x3048 , 0x304a , 0x304b , 0x304d , 0x304f , 0x3051 , 0x3053 , 0x3055 , 0x3057 , 0x3059 , 0x305b , 0x305d , 0x305f , 0x3061 , 0x3064 , 0x3066 , 0x3068 , 0x306a , 0x306b , 0x306c , 0x306d , 0x306e , 0x306f , 0x3072 , 0x3075 , 0x3078 , 0x307b , 0x307e , 0x307f , 0x3080 , 0x3081 , 0x3082 , 0x3084 , 0x3086 , 0x3088 , 0x3089 , 0x308a , 0x308b , 0x308c , 0x308d , 0x308f , 0x3090 , 0x3091 , 0x3092 , 0x3093 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "multiplier" , new long [ ] { Long . MAX_VALUE , Long . MAX_VALUE , 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4EAC , 0x5146 , 0x5104 , 0x4E07 , 0x5343 , 0x767e , 0x5341 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x4E00 , 0x4E8C , 0x4E09 , 0x56DB , 0x4E94 , 0x516D , 0x4E03 , 0x516B , 0x4E5D } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '599', '0', '0', '0.976190476', '1', '0', '0', '198.3333333', '1', '0.3333', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_cs extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Funkce current() není ve vzorku shody povolena!" } , { ER_CURRENT_TAKES_NO_ARGS , "Funkce current() neakceptuje argumenty!" } , { ER_DOCUMENT_REPLACED , "implementace funkce document() byla nahrazena funkcí org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "Parametr context nemá dokument vlastníka!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "Příliš mnoho argumentů funkce local-name()." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "Příliš mnoho argumentů funkce namespace-uri()." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "Příliš mnoho argumentů funkce normalize-space()." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "Příliš mnoho argumentů funkce number()." } , { ER_NAME_HAS_TOO_MANY_ARGS , "Příliš mnoho argumentů funkce name()." } , { ER_STRING_HAS_TOO_MANY_ARGS , "Příliš mnoho argumentů funkce string()." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "Příliš mnoho argumentů funkce string-length()." } , { ER_TRANSLATE_TAKES_3_ARGS , "Funkce translate() akceptuje tři argumenty!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "Funkce unparsed-entity-uri musí akceptovat jeden argument!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "Obor názvů axis nebyl ještě implementován!" } , { ER_UNKNOWN_AXIS , "neznámý parametr axis: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "neznámá operace shody!" } , { ER_INCORRECT_ARG_LENGTH , "Nesprávná délka argumentu testu uzlu processing-instruction()!" } , { ER_CANT_CONVERT_TO_NUMBER , "{0} nelze převést na parametr number" } , { ER_CANT_CONVERT_TO_NODELIST , "{0} nelze převést na parametr NodeList!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0} nelze převést na parametr NodeSetDTM!" } , { ER_CANT_CONVERT_TO_TYPE , "{0} nelze převést na parametr type#{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Funkce getMatchScore očekává parametr!" } , { ER_COULDNOT_GET_VAR_NAMED , "Nelze získat proměnnou s názvem {0}" } , { ER_UNKNOWN_OPCODE , "Chyba! Neznámý kód operace: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Další nepovolené tokeny: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "nesprávně uvedený literál... Byly očekávány uvozovky!" } , { ER_EXPECTED_SINGLE_QUOTE , "nesprávně uvedený literál... Byly očekávány jednoduché uvozovky!" } , { ER_EMPTY_EXPRESSION , "Prázdný výraz!" } , { ER_EXPECTED_BUT_FOUND , "Očekáváno: {0}, ale nalezeno: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Nesprávné tvrzení programátora! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "booleovský(...) argument již není v návrhu 19990709 XPath volitelný." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Byl nalezen znak ',' bez předchozího argumentu!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Byl nalezen znak ',' bez následujícího argumentu!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "Výraz '..[predicate]' nebo '.[predicate]' má nesprávnou syntaxi. Použijte místo toho 'self::node()[predicate]'." } , { ER_ILLEGAL_AXIS_NAME , "nepovolený název osy: {0}" } , { ER_UNKNOWN_NODETYPE , "Neznámý typ uzlu: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Je nutno uvést vzorek literálu ({0})!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} nelze zformátovat jako číslo!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Nelze vytvořit prvek XML TransformerFactory Liaison: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Chyba! Nebyl nalezen výraz výběru xpath (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "Chyba! Nebyl nalezen výraz ENDOP po OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Došlo k chybě!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "Odkaz VariableReference uveden k proměnné mimo kontext nebo bez definice! Název = {0}" } , { ER_AXES_NOT_ALLOWED , "Ve vzorcích shody jsou povoleny pouze osy child:: a attribute::! Nepovolené osy = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "nesprávný počet argumentů parametru key()." } , { ER_COUNT_TAKES_1_ARG , "Funkce count musí obsahovat jeden argument!" } , { ER_COULDNOT_FIND_FUNCTION , "Nelze nalézt funkci: {0}" } , { ER_UNSUPPORTED_ENCODING , "Nepodporované kódování: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Ve funkci getNextSibling došlo v DTM k chybě... Probíhá pokus o obnovu" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Chyba programátora: Do funkce EmptyNodeList nelze zapisovat." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "Funkce XPathContext nepodporuje funkci setDOMFactory!" } , { ER_PREFIX_MUST_RESOLVE , "Předponu musí být možno přeložit do oboru názvů: {0}" } , { ER_PARSE_NOT_SUPPORTED , "Funkce XPathContext nepodporuje analýzu (InputSource source)! {0} - nelze otevřít" } , { ER_SAX_API_NOT_HANDLED , "Znaky SAX API (char ch[]... nejsou v DTM zpracovávány!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "Funkce ignorableWhitespace(char ch[]... není v DTM zpracovávána!" } , { ER_DTM_CANNOT_HANDLE_NODES , "Funkce DTMLiaison nemůže zpracovávat uzly typu {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "Funkce DOM2Helper nemůže zpracovávat uzly typu {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Chyba funkce DOM2Helper.parse: SystemID - {0} řádek - {1}" } , { ER_XERCES_PARSE_ERROR , "Chyba funkce DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Byla zjištěna neplatná náhrada UTF-16: {0} ?" } , { ER_OIERROR , "Chyba vstupu/výstupu" } , { ER_CANNOT_CREATE_URL , "Nelze vytvořit url pro: {0}" } , { ER_XPATH_READOBJECT , "Ve funkci XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "nebyl nalezen token funkce." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Nelze pracovat s typem XPath: {0}" } , { ER_NODESET_NOT_MUTABLE , "Tento prvek NodeSet nelze měnit" } , { ER_NODESETDTM_NOT_MUTABLE , "Tento prvek NodeSetDTM nelze měnit" } , { ER_VAR_NOT_RESOLVABLE , "Proměnnou nelze přeložit: {0}" } , { ER_NULL_ERROR_HANDLER , "Obslužný program pro zpracování chyb hodnoty null" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Tvrzení programátora: neznámý kód operace: {0}" } , { ER_ZERO_OR_ONE , "0 nebo 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "Funkce XRTreeFragSelectWrapper nepodporuje rtf()" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "Funkce XRTreeFragSelectWrapper nepodporuje asNodeIterator()" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "Funkce XStringForChars nepodporuje funkci fsb()" } , { ER_COULD_NOT_FIND_VAR , "Nelze nalézt proměnnou s názvem {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "Argumentem funkce XStringForChars nemůže být řetězec" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "Argument funkce FastStringBuffer nemůže mít hodnotu null" } , { ER_TWO_OR_THREE , "2 nebo 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Přístup k proměnné předtím, než je závazná!" } , { ER_FSB_CANNOT_TAKE_STRING , "Argumentem funkce XStringForFSB nemůže být řetězec!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Chyba! Nastavení kořene objektu walker na hodnotu null!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Tato funkce NodeSetDTM nemůže být stejná jako předcházející uzel!" } , { ER_NODESET_CANNOT_ITERATE , "Tato funkce NodeSet nemůže být stejná jako předcházející uzel!" } , { ER_NODESETDTM_CANNOT_INDEX , "Tato funkce NodeSetDTM nemůže provádět indexovací nebo početní funkce!" } , { ER_NODESET_CANNOT_INDEX , "Tato funkce NodeSet nemůže provádět indexovací nebo početní funkce!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Nelze volat funkci setShouldCacheNodes poté, co byla volána funkce nextNode!" } , { ER_ONLY_ALLOWS , "{0} povoluje pouze {1} argumentů" } , { ER_UNKNOWN_STEP , "Tvrzení programátora v getNextStepPos: neznámý stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Po tokenu '/' nebo '//' byla očekávána cesta relativního umístění." } , { ER_EXPECTED_LOC_PATH , "Očekávala se cesta umístění, avšak byl zaznamenán následující token:  {0}" } , { ER_EXPECTED_LOC_STEP , "Po tokenu '/' nebo '//' byl očekáván krok umístění" } , { ER_EXPECTED_NODE_TEST , "Byl očekáván test uzlu, který odpovídá buď prvkům NCName:* nebo QName." } , { ER_EXPECTED_STEP_PATTERN , "Byl očekáván vzorek kroku, avšak byl zaznamenán znak '/'." } , { ER_EXPECTED_REL_PATH_PATTERN , "Byl očekáván vzorek relativní cesty." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Nelze převést {0} na booleovský typ." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Nelze převést {0} na jednoduchý uzel. Tento způsob lze lépe použít pro typy ANY_UNORDERED_NODE_TYPE a FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Nelze sejmout délku typu: {0}. Tento způsob se lépe používá pro typy UNORDERED_NODE_SNAPSHOT_TYPE a ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Nelze provést iteraci prostřednictvím typu, který není iterátor: {0}" } , { ER_DOC_MUTATED , "Dokument se od doby, kdy byly vráceny výsledky, změnil. Iterátor je neplatný." } , { ER_INVALID_XPATH_TYPE , "Neplatný argument typu XPath: {0}" } , { ER_EMPTY_XPATH_RESULT , "Prázdný objekt výsledku XPath" } , { ER_INCOMPATIBLE_TYPES , "Vrácený typ: {0} nemůže být vynucen na určený typ: {1}" } , { ER_NULL_RESOLVER , "Nelze řešit předponu řešitelem (resolver) s předponou hodnoty null." } , { ER_CANT_CONVERT_TO_STRING , "Nelze převést {0} na řetězec." } , { ER_NON_SNAPSHOT_TYPE , "Nelze volat snapshotItem na typ: {0}. Tato metoda se používá pro typy UNORDERED_NODE_SNAPSHOT_TYPE a ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Uzel kontextu nepatří mezi dokumenty, které jsou vázány k XPathEvaluator." } , { ER_WRONG_NODETYPE , "Typ uzlu kontextu není podporován." } , { ER_XPATH_ERROR , "Neznámá chyba objektu XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "funkce format-number prozatím nezpracovala název národního prostředí (locale)!" } , { WG_PROPERTY_NOT_SUPPORTED , "Vlastnost XSL není podporována: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Aktuálně nedělejte nic s oborem názvů {0} vlastnosti: {1}" } , { WG_SECURITY_EXCEPTION , "Při pokusu o přístup k systémové vlastnosti XSL došlo k výjimce SecurityException: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Zastaralá syntaxe: quo(...) již není v XPath definováno." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath potřebuje k implementaci funkce nodeTest odvozený objekt!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "nebyl nalezen token funkce." } , { WG_COULDNOT_FIND_FUNCTION , "Nelze nalézt funkci: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Nelze vytvořit adresu URL z: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "Analyzátor DTM nepodporuje volbu -E" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "Odkaz VariableReference uveden k proměnné mimo kontext nebo bez definice! Název = {0}" } , { WG_UNSUPPORTED_ENCODING , "Nepodporované kódování: {0}" } , { "ui_language" , "cs" } , { "help_language" , "cs" } , { "language" , "cs" } , { "BAD_CODE" , "Parametr funkce createMessage je mimo limit" } , { "FORMAT_FAILED" , "Při volání funkce messageFormat došlo k výjimce" } , { "version" , ">>>>>>> Verze Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "ano" } , { "line" , "Řádek #" } , { "column" , "Sloupec #" } , { "xsldone" , "XSLProcessor: hotovo" } , { "xpath_option" , "volby xpath: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select výraz xpath]" } , { "optionMatch" , "   [-match vzorek shody (pro diagnostiku shody)]" } , { "optionAnyExpr" , "Jinak výpis dignostiky provede pouze výraz xpath" } , { "noParsermsg1" , "Proces XSL nebyl úspěšný." } , { "noParsermsg2" , "** Nelze najít analyzátor **" } , { "noParsermsg3" , "Zkontrolujte cestu classpath." } , { "noParsermsg4" , "Nemáte-li analyzátor XML jazyka Java společnosti IBM, můžete si jej stáhnout z adresy:" } , { "noParsermsg5" , "AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#chyba" ; public static final String ERROR_HEADER = "Chyba: " ; public static final String WARNING_HEADER = "Varování: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "cs" , "CZ" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPathContext ; public class ElemUnknown extends ElemLiteralResult { public int getXSLToken ( ) { return Constants . ELEMNAME_UNDEFINED ; } private void executeFallbacks ( TransformerImpl transformer ) throws TransformerException { for ( ElemTemplateElement child = m_firstChild ; child != null ; child = child . m_nextSibling ) { if ( child . getXSLToken ( ) == Constants . ELEMNAME_FALLBACK ) { try { transformer . pushElemTemplateElement ( child ) ; ( ( ElemFallback ) child ) . executeFallback ( transformer ) ; } finally { transformer . popElemTemplateElement ( ) ; } } } } private boolean hasFallbackChildren ( ) { for ( ElemTemplateElement child = m_firstChild ; child != null ; child = child . m_nextSibling ) { if ( child . getXSLToken ( ) == Constants . ELEMNAME_FALLBACK ) return true ; } return false ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { if ( hasFallbackChildren ( ) ) { executeFallbacks ( transformer ) ; } else { } } catch ( TransformerException e ) { transformer . getErrorListener ( ) . fatalError ( e ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } 	1	['5', '5', '0', '5', '15', '8', '0', '5', '3', '2', '81', '0', '0', '0.983539095', '0.7', '2', '3', '15.2', '3', '1.2', '2']
package org . apache . xml . utils . res ; public class XResources_ja_JP_HI extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "alphabet" , new char [ ] { 0x3044 , 0x308d , 0x306f , 0x306b , 0x307b , 0x3078 , 0x3068 , 0x3061 , 0x308a , 0x306c , 0x308b , 0x3092 , 0x308f , 0x304b , 0x3088 , 0x305f , 0x308c , 0x305d , 0x3064 , 0x306d , 0x306a , 0x3089 , 0x3080 , 0x3046 , 0x3090 , 0x306e , 0x304a , 0x304f , 0x3084 , 0x307e , 0x3051 , 0x3075 , 0x3053 , 0x3048 , 0x3066 , 0x3042 , 0x3055 , 0x304d , 0x3086 , 0x3081 , 0x307f , 0x3057 , 0x3091 , 0x3072 , 0x3082 , 0x305b , 0x3059 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "multiplier" , new long [ ] { Long . MAX_VALUE , Long . MAX_VALUE , 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4EAC , 0x5146 , 0x5104 , 0x4E07 , 0x5343 , 0x767e , 0x5341 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x4E00 , 0x4E8C , 0x4E09 , 0x56DB , 0x4E94 , 0x516D , 0x4E03 , 0x516B , 0x4E5D } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '595', '0', '0', '0.976190476', '1', '0', '0', '197', '1', '0.3333', '1']
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . PrefixResolverDefault ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class XPathAPI { public static Node selectSingleNode ( Node contextNode , String str ) throws TransformerException { return selectSingleNode ( contextNode , str , contextNode ) ; } public static Node selectSingleNode ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { NodeIterator nl = selectNodeIterator ( contextNode , str , namespaceNode ) ; return nl . nextNode ( ) ; } public static NodeIterator selectNodeIterator ( Node contextNode , String str ) throws TransformerException { return selectNodeIterator ( contextNode , str , contextNode ) ; } public static NodeIterator selectNodeIterator ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XObject list = eval ( contextNode , str , namespaceNode ) ; return list . nodeset ( ) ; } public static NodeList selectNodeList ( Node contextNode , String str ) throws TransformerException { return selectNodeList ( contextNode , str , contextNode ) ; } public static NodeList selectNodeList ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XObject list = eval ( contextNode , str , namespaceNode ) ; return list . nodelist ( ) ; } public static XObject eval ( Node contextNode , String str ) throws TransformerException { return eval ( contextNode , str , contextNode ) ; } public static XObject eval ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XPathContext xpathSupport = new XPathContext ( ) ; PrefixResolverDefault prefixResolver = new PrefixResolverDefault ( ( namespaceNode . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( ( Document ) namespaceNode ) . getDocumentElement ( ) : namespaceNode ) ; XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } public static XObject eval ( Node contextNode , String str , PrefixResolver prefixResolver ) throws TransformerException { XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; XPathContext xpathSupport = new XPathContext ( ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } } 	1	['10', '1', '0', '5', '21', '45', '0', '5', '10', '2', '116', '0', '0', '0', '0.5', '0', '0', '10.6', '1', '0.9', '1']
package org . apache . xalan . xsltc . trax ; import java . io . InputStream ; import java . io . Reader ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . w3c . dom . Document ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public final class Util { public static String baseName ( String name ) { return org . apache . xalan . xsltc . compiler . util . Util . baseName ( name ) ; } public static String noExtName ( String name ) { return org . apache . xalan . xsltc . compiler . util . Util . noExtName ( name ) ; } public static String toJavaName ( String name ) { return org . apache . xalan . xsltc . compiler . util . Util . toJavaName ( name ) ; } public static InputSource getInputSource ( XSLTC xsltc , Source source ) throws TransformerConfigurationException { InputSource input = null ; String systemId = source . getSystemId ( ) ; try { if ( source instanceof SAXSource ) { final SAXSource sax = ( SAXSource ) source ; input = sax . getInputSource ( ) ; try { XMLReader reader = sax . getXMLReader ( ) ; if ( reader == null ) { try { reader = XMLReaderFactory . createXMLReader ( ) ; } catch ( Exception e ) { try { SAXParserFactory parserFactory = SAXParserFactory . newInstance ( ) ; parserFactory . setNamespaceAware ( true ) ; reader = parserFactory . newSAXParser ( ) . getXMLReader ( ) ; } catch ( ParserConfigurationException pce ) { throw new TransformerConfigurationException ( "ParserConfigurationException" , pce ) ; } } } reader . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , false ) ; xsltc . setXMLReader ( reader ) ; } catch ( SAXNotRecognizedException snre ) { throw new TransformerConfigurationException ( "SAXNotRecognizedException " , snre ) ; } catch ( SAXNotSupportedException snse ) { throw new TransformerConfigurationException ( "SAXNotSupportedException " , snse ) ; } catch ( SAXException se ) { throw new TransformerConfigurationException ( "SAXException " , se ) ; } } else if ( source instanceof DOMSource ) { final DOMSource domsrc = ( DOMSource ) source ; final Document dom = ( Document ) domsrc . getNode ( ) ; final DOM2SAX dom2sax = new DOM2SAX ( dom ) ; xsltc . setXMLReader ( dom2sax ) ; input = SAXSource . sourceToInputSource ( source ) ; if ( input == null ) { input = new InputSource ( domsrc . getSystemId ( ) ) ; } } else if ( source instanceof StreamSource ) { final StreamSource stream = ( StreamSource ) source ; final InputStream istream = stream . getInputStream ( ) ; final Reader reader = stream . getReader ( ) ; if ( istream != null ) { input = new InputSource ( istream ) ; } else if ( reader != null ) { input = new InputSource ( reader ) ; } else { input = new InputSource ( systemId ) ; } } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } input . setSystemId ( systemId ) ; } catch ( NullPointerException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_SOURCE_ERR , "TransformerFactory.newTemplates()" ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( SecurityException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . FILE_ACCESS_ERR , systemId ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } return input ; } } 	1	['5', '1', '0', '6', '34', '10', '2', '4', '5', '2', '198', '0', '0', '0', '0.3', '0', '0', '38.6', '1', '0.8', '1']
package org . apache . xpath . compiler ; import javax . xml . transform . TransformerException ; import org . apache . xpath . functions . Function ; public class FuncLoader { private int m_funcID ; private String m_funcName ; public String getName ( ) { return m_funcName ; } public FuncLoader ( String funcName , int funcID ) { super ( ) ; m_funcID = funcID ; m_funcName = funcName ; } public Function getFunction ( ) throws TransformerException { try { String className = m_funcName ; if ( className . indexOf ( "." ) < 0 ) { className = "org.apache.xpath.functions." + className ; } return ( Function ) ObjectFactory . newInstance ( className , ObjectFactory . findClassLoader ( ) , true ) ; } catch ( ObjectFactory . ConfigurationError e ) { throw new TransformerException ( e . getException ( ) ) ; } } } 	1	['3', '1', '0', '5', '12', '0', '2', '3', '3', '0.5', '46', '1', '0', '0', '0.555555556', '0', '0', '13.66666667', '1', '0.6667', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import org . apache . xpath . res . XPATHMessages ; public class XSLMessages extends XPATHMessages { private static ListResourceBundle XSLTBundle = null ; private static final String XSLT_ERROR_RESOURCES = "org.apache.xalan.res.XSLTErrorResources" ; public static final String createMessage ( String msgKey , Object args [ ] ) { if ( XSLTBundle == null ) XSLTBundle = loadResourceBundle ( XSLT_ERROR_RESOURCES ) ; if ( XSLTBundle != null ) { return createMsg ( XSLTBundle , msgKey , args ) ; } else return "Could not load any resource bundles." ; } public static final String createWarning ( String msgKey , Object args [ ] ) { if ( XSLTBundle == null ) XSLTBundle = loadResourceBundle ( XSLT_ERROR_RESOURCES ) ; if ( XSLTBundle != null ) { return createMsg ( XSLTBundle , msgKey , args ) ; } else return "Could not load any resource bundles." ; } } 	1	['4', '3', '0', '69', '7', '0', '68', '1', '3', '0.833333333', '40', '1', '0', '0.818181818', '0.555555556', '0', '0', '8.5', '3', '1.5', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xpath . Expression ; import org . apache . xpath . compiler . Compiler ; public class OneStepIteratorForward extends ChildTestIterator { protected int m_axis = - 1 ; OneStepIteratorForward ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; m_axis = WalkerFactory . getAxisFromStep ( compiler , firstStepPos ) ; } public OneStepIteratorForward ( int axis ) { super ( null ) ; m_axis = axis ; int whatToShow = DTMFilter . SHOW_ALL ; initNodeTest ( whatToShow ) ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( m_axis ) ; } protected int getNextNode ( ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; return m_lastFetched ; } public int getAxis ( ) { return m_axis ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( m_axis != ( ( OneStepIteratorForward ) expr ) . m_axis ) return false ; return true ; } } 	1	['6', '7', '1', '8', '16', '0', '3', '6', '4', '0.2', '94', '1', '0', '0.97080292', '0.4', '4', '10', '14.5', '3', '1.1667', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . objects . XString ; public class ElemWithParam extends ElemTemplateElement { int m_index ; private XPath m_selectPattern = null ; public void setSelect ( XPath v ) { m_selectPattern = v ; } public XPath getSelect ( ) { return m_selectPattern ; } private QName m_qname = null ; int m_qnameID ; public void setName ( QName v ) { m_qname = v ; } public QName getName ( ) { return m_qname ; } public int getXSLToken ( ) { return Constants . ELEMNAME_WITHPARAM ; } public String getNodeName ( ) { return Constants . ELEMNAME_WITHPARAM_STRING ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { if ( null == m_selectPattern && org . apache . xalan . processor . TransformerFactoryImpl . m_optimize ) { XPath newSelect = ElemVariable . rewriteChildToExpression ( this ) ; if ( null != newSelect ) m_selectPattern = newSelect ; } m_qnameID = sroot . getComposeState ( ) . getQNameID ( m_qname ) ; super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_selectPattern ) m_selectPattern . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public void setParentElem ( ElemTemplateElement p ) { super . setParentElem ( p ) ; p . m_hasVariableDecl = true ; } public XObject getValue ( TransformerImpl transformer , int sourceNode ) throws TransformerException { XObject var ; XPathContext xctxt = transformer . getXPathContext ( ) ; xctxt . pushCurrentNode ( sourceNode ) ; try { if ( null != m_selectPattern ) { var = m_selectPattern . execute ( xctxt , sourceNode , this ) ; var . allowDetachToRelease ( false ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , m_selectPattern , var ) ; } else if ( null == getFirstChildElem ( ) ) { var = XString . EMPTYSTRING ; } else { int df = transformer . transformToRTF ( this ) ; var = new XRTreeFrag ( df , xctxt , this ) ; } } finally { xctxt . popCurrentNode ( ) ; } return var ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs && ( null != m_selectPattern ) ) m_selectPattern . getExpression ( ) . callVisitors ( m_selectPattern , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } public ElemTemplateElement appendChild ( ElemTemplateElement elem ) { if ( m_selectPattern != null ) { error ( XSLTErrorResources . ER_CANT_HAVE_CONTENT_AND_SELECT , new Object [ ] { "xsl:" + this . getNodeName ( ) } ) ; return null ; } return super . appendChild ( elem ) ; } } 	1	['12', '3', '0', '21', '39', '14', '2', '19', '11', '0.818181818', '195', '0.5', '2', '0.946859903', '0.194444444', '2', '10', '14.91666667', '3', '1.1667', '2']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_fr extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Fonction non prise en charge !" } , { ER_CANNOT_OVERWRITE_CAUSE , "Impossible de remplacer la cause" } , { ER_NO_DEFAULT_IMPL , "Impossible de trouver une implémentation par défaut " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) n''est pas pris en charge" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Décalage plus important que l'emplacement" } , { ER_COROUTINE_NOT_AVAIL , "Coroutine non disponible, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager a reçu une demande de co_exit()" } , { ER_COJOINROUTINESET_FAILED , "Echec de co_joinCoroutineSet()" } , { ER_COROUTINE_PARAM , "Erreur de paramètre de Coroutine ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nRESULTAT INATTENDU : L''analyseur doTerminate répond {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "parse ne peut être appelé lors de l'analyse" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Erreur : itérateur typé de l''axe {0} non implémenté" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Erreur : itérateur de l''axe {0} non implémenté " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Clone de l'itérateur non pris en charge" } , { ER_UNKNOWN_AXIS_TYPE , "Type transversal d''axe inconnu : {0}" } , { ER_AXIS_NOT_SUPPORTED , "Traverseur d''axe non pris en charge : {0}" } , { ER_NO_DTMIDS_AVAIL , "Aucun autre ID de DTM disponible" } , { ER_NOT_SUPPORTED , "Non pris en charge : {0}" } , { ER_NODE_NON_NULL , "Le noeud ne doit pas être vide pour getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "Impossible de convertir le noeud en pointeur" } , { ER_STARTPARSE_WHILE_PARSING , "startParse ne peut être appelé pendant l'analyse" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse requiert un SAXParser non vide" } , { ER_COULD_NOT_INIT_PARSER , "impossible d'initialiser l'analyseur" } , { ER_EXCEPTION_CREATING_POOL , "exception durant la création d'une instance du pool" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Le chemin d'accès contient une séquence d'échappement non valide" } , { ER_SCHEME_REQUIRED , "Processus requis !" } , { ER_NO_SCHEME_IN_URI , "Processus introuvable dans l''URI : {0}" } , { ER_NO_SCHEME_INURI , "Processus introuvable dans l'URI" } , { ER_PATH_INVALID_CHAR , "Le chemin contient un caractère non valide : {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Impossible de définir le processus à partir de la chaîne vide" } , { ER_SCHEME_NOT_CONFORMANT , "Le processus n'est pas conforme." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "L'hôte n'est pas une adresse bien formée" } , { ER_PORT_WHEN_HOST_NULL , "Le port ne peut être défini quand l'hôte est vide" } , { ER_INVALID_PORT , "Numéro de port non valide" } , { ER_FRAG_FOR_GENERIC_URI , "Le fragment ne peut être défini que pour un URI générique" } , { ER_FRAG_WHEN_PATH_NULL , "Le fragment ne peut être défini quand le chemin d'accès est vide" } , { ER_FRAG_INVALID_CHAR , "Le fragment contient un caractère non valide" } , { ER_PARSER_IN_USE , "L'analyseur est déjà utilisé" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Impossible de modifier {0} {1} durant l''analyse" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Auto-causalité interdite" } , { ER_NO_USERINFO_IF_NO_HOST , "Userinfo ne peut être spécifié si l'hôte ne l'est pas" } , { ER_NO_PORT_IF_NO_HOST , "Le port peut ne pas être spécifié si l'hôte n'est pas spécifié" } , { ER_NO_QUERY_STRING_IN_PATH , "La chaîne de requête ne doit pas figurer dans un chemin et une chaîne de requête" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Le fragment ne doit pas être indiqué à la fois dans le chemin et dans le fragment" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Impossible d'initialiser l'URI avec des paramètres vides" } , { ER_METHOD_NOT_SUPPORTED , "Cette méthode n'est pas encore prise en charge " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter ne peut redémarrer" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader ne figure pas avant la demande startParse" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Traverseur d''axe non pris en charge : {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler créé avec PrintWriter vide !" } , { ER_SYSTEMID_UNKNOWN , "ID système inconnu" } , { ER_LOCATION_UNKNOWN , "Emplacement inconnu de l'erreur" } , { ER_PREFIX_MUST_RESOLVE , "Le préfixe doit se convertir en espace de noms : {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() non pris en charge dans XPathContext !" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "L'enfant de l'attribut ne possède pas de document propriétaire !" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Le contexte ne possède pas d'élément de document propriétaire !" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Avertissement : impossible d'afficher du texte avant l'élément de document !  Traitement ignoré..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Un DOM ne peut posséder plusieurs racines !" } , { ER_ARG_LOCALNAME_NULL , "L'argument ''localName'' est vide" } , { ER_ARG_LOCALNAME_INVALID , "Dans QNAME, le nom local doit être un nom NCName valide" } , { ER_ARG_PREFIX_INVALID , "Dans QNAME, le préfixe doit être un nom NCName valide" } , { "BAD_CODE" , "Le paramètre de createMessage se trouve hors limites" } , { "FORMAT_FAILED" , "Exception soulevée lors de l'appel de messageFormat" } , { "line" , "Ligne #" } , { "column" , "Colonne #" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "La classe de la méthode de sérialisation ''{0}'' n''implémente pas org.xml.sax.ContentHandler." } , { ER_RESOURCE_COULD_NOT_FIND , "La ressource [ {0} ] est introuvable.\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "La ressource [ {0} ] n''a pas pu charger : {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Taille du tampon <=0" } , { ER_INVALID_UTF16_SURROGATE , "Substitut UTF-16 non valide détecté : {0} ?" } , { ER_OIERROR , "Erreur d''E-S" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Ajout impossible de l''attribut {0} après des noeuds enfants ou avant la production d''un élément.  L''attribut est ignoré." } , { ER_NAMESPACE_PREFIX , "L''espace de noms du préfixe ''{0}'' n''a pas été déclaré." } , { ER_STRAY_ATTRIBUTE , "L''attribut ''{0}'' est à l''extérieur de l''élément." } , { ER_STRAY_NAMESPACE , "La déclaration d''espace de noms ''{0}''=''{1}'' est à l''extérieur de l''élément." } , { ER_COULD_NOT_LOAD_RESOURCE , "Impossible de charger ''{0}'' (vérifier CLASSPATH), les valeurs par défaut sont donc employées " } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "Impossible de charger le fichier de propriétés ''{0}'' pour la méthode de sortie ''{1}'' (vérifier CLASSPATH)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xalan . templates ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . NodeSorter ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . IntStack ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; public class ElemForEach extends ElemTemplateElement implements ExpressionOwner { static final boolean DEBUG = false ; public boolean m_doc_cache_off = false ; public ElemForEach ( ) { } protected Expression m_selectExpression = null ; protected XPath m_xpath = null ; public void setSelect ( XPath xpath ) { m_selectExpression = xpath . getExpression ( ) ; m_xpath = xpath ; } public Expression getSelect ( ) { return m_selectExpression ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; int length = getSortElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { getSortElem ( i ) . compose ( sroot ) ; } java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_selectExpression ) m_selectExpression . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; else { m_selectExpression = getStylesheetRoot ( ) . m_selectDefault . getExpression ( ) ; } } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { int length = getSortElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { getSortElem ( i ) . endCompose ( sroot ) ; } super . endCompose ( sroot ) ; } protected Vector m_sortElems = null ; public int getSortElemCount ( ) { return ( m_sortElems == null ) ? 0 : m_sortElems . size ( ) ; } public ElemSort getSortElem ( int i ) { return ( ElemSort ) m_sortElems . elementAt ( i ) ; } public void setSortElem ( ElemSort sortElem ) { if ( null == m_sortElems ) m_sortElems = new Vector ( ) ; m_sortElems . addElement ( sortElem ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_FOREACH ; } public String getNodeName ( ) { return Constants . ELEMNAME_FOREACH_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { transformer . pushCurrentTemplateRuleIsNull ( true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { transformSelectedNodes ( transformer ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; transformer . popCurrentTemplateRuleIsNull ( ) ; } } protected ElemTemplateElement getTemplateMatch ( ) { return this ; } public DTMIterator sortNodes ( XPathContext xctxt , Vector keys , DTMIterator sourceNodes ) throws TransformerException { NodeSorter sorter = new NodeSorter ( xctxt ) ; sourceNodes . setShouldCacheNodes ( true ) ; sourceNodes . runTo ( - 1 ) ; xctxt . pushContextNodeList ( sourceNodes ) ; try { sorter . sort ( sourceNodes , keys , xctxt ) ; sourceNodes . setCurrentPos ( 0 ) ; } finally { xctxt . popContextNodeList ( ) ; } return sourceNodes ; } public void transformSelectedNodes ( TransformerImpl transformer ) throws TransformerException { final XPathContext xctxt = transformer . getXPathContext ( ) ; final int sourceNode = xctxt . getCurrentNode ( ) ; DTMIterator sourceNodes = m_selectExpression . asIterator ( xctxt , sourceNode ) ; try { final Vector keys = ( m_sortElems == null ) ? null : transformer . processSortKeys ( this , sourceNode ) ; if ( null != keys ) sourceNodes = sortNodes ( xctxt , keys , sourceNodes ) ; if ( TransformerImpl . S_DEBUG ) { Expression expr = m_xpath . getExpression ( ) ; org . apache . xpath . objects . XObject xObject = expr . execute ( xctxt ) ; int current = xctxt . getCurrentNode ( ) ; transformer . getTraceManager ( ) . fireSelectedEvent ( current , this , "select" , m_xpath , xObject ) ; } xctxt . pushCurrentNode ( DTM . NULL ) ; IntStack currentNodes = xctxt . getCurrentNodeStack ( ) ; xctxt . pushCurrentExpressionNode ( DTM . NULL ) ; IntStack currentExpressionNodes = xctxt . getCurrentExpressionNodeStack ( ) ; xctxt . pushSAXLocatorNull ( ) ; xctxt . pushContextNodeList ( sourceNodes ) ; transformer . pushElemTemplateElement ( null ) ; DTM dtm = xctxt . getDTM ( sourceNode ) ; int docID = sourceNode & DTMManager . IDENT_DTM_DEFAULT ; int child ; while ( DTM . NULL != ( child = sourceNodes . nextNode ( ) ) ) { currentNodes . setTop ( child ) ; currentExpressionNodes . setTop ( child ) ; if ( ( child & DTMManager . IDENT_DTM_DEFAULT ) != docID ) { dtm = xctxt . getDTM ( child ) ; docID = child & DTMManager . IDENT_DTM_DEFAULT ; } final int nodeType = dtm . getNodeType ( child ) ; if ( TransformerImpl . S_DEBUG ) { transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; } for ( ElemTemplateElement t = this . m_firstChild ; t != null ; t = t . m_nextSibling ) { xctxt . setSAXLocator ( t ) ; transformer . setCurrentElement ( t ) ; t . execute ( transformer ) ; } if ( TransformerImpl . S_DEBUG ) { transformer . setCurrentElement ( null ) ; transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } if ( m_doc_cache_off ) { if ( DEBUG ) System . out . println ( "JJK***** CACHE RELEASE *****\n" + "\tdtm=" + dtm . getDocumentBaseURI ( ) ) ; xctxt . getSourceTreeManager ( ) . removeDocumentFromCache ( dtm . getDocument ( ) ) ; xctxt . release ( dtm , false ) ; } } } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEndEvent ( sourceNode , this , "select" , new XPath ( m_selectExpression ) , new org . apache . xpath . objects . XNodeSet ( sourceNodes ) ) ; xctxt . popSAXLocator ( ) ; xctxt . popContextNodeList ( ) ; transformer . popElemTemplateElement ( ) ; xctxt . popCurrentExpressionNode ( ) ; xctxt . popCurrentNode ( ) ; sourceNodes . detach ( ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; if ( Constants . ELEMNAME_SORT == type ) { setSortElem ( ( ElemSort ) newChild ) ; return newChild ; } else return super . appendChild ( newChild ) ; } public void callChildVisitors ( XSLTVisitor visitor , boolean callAttributes ) { if ( callAttributes && ( null != m_selectExpression ) ) m_selectExpression . callVisitors ( this , visitor ) ; int length = getSortElemCount ( ) ; for ( int i = 0 ; i < length ; i ++ ) { getSortElem ( i ) . callVisitors ( visitor ) ; } super . callChildVisitors ( visitor , callAttributes ) ; } public Expression getExpression ( ) { return m_selectExpression ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_selectExpression = exp ; } } 	1	['18', '3', '1', '24', '82', '79', '5', '20', '17', '0.752941176', '486', '0.6', '2', '0.920187793', '0.136752137', '2', '6', '25.72222222', '4', '1.2778', '2']
package org . apache . xalan . extensions ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . trace . ExtensionEvent ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . objects . XObject ; public class ExtensionHandlerJavaClass extends ExtensionHandlerJava { private Class m_classObj = null ; private Object m_defaultInstance = null ; public ExtensionHandlerJavaClass ( String namespaceUri , String scriptLang , String className ) { super ( namespaceUri , scriptLang , className ) ; try { m_classObj = getClassForName ( className ) ; } catch ( ClassNotFoundException e ) { } } public boolean isFunctionAvailable ( String function ) { Method [ ] methods = m_classObj . getMethods ( ) ; int nMethods = methods . length ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( function ) ) return true ; } return false ; } public boolean isElementAvailable ( String element ) { Method [ ] methods = m_classObj . getMethods ( ) ; int nMethods = methods . length ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( element ) ) { Class [ ] paramTypes = methods [ i ] . getParameterTypes ( ) ; if ( ( paramTypes . length == 2 ) && paramTypes [ 0 ] . isAssignableFrom ( org . apache . xalan . extensions . XSLProcessorContext . class ) && paramTypes [ 1 ] . isAssignableFrom ( org . apache . xalan . templates . ElemExtensionCall . class ) ) { return true ; } } } return false ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { Object [ ] methodArgs ; Object [ ] [ ] convertedArgs ; Class [ ] paramTypes ; try { if ( funcName . equals ( "new" ) ) { methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Constructor c = ( Constructor ) getFromCache ( methodKey , null , methodArgs ) ; if ( c != null && ! TransformerImpl . S_DEBUG ) { try { paramTypes = c . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return c . newInstance ( convertedArgs [ 0 ] ) ; } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } c = MethodResolver . getConstructor ( m_classObj , methodArgs , convertedArgs , exprContext ) ; putToCache ( methodKey , null , methodArgs , c ) ; if ( TransformerImpl . S_DEBUG ) { TransformerImpl trans = ( TransformerImpl ) exprContext . getXPathContext ( ) . getOwnerObject ( ) ; trans . getTraceManager ( ) . fireExtensionEvent ( new ExtensionEvent ( trans , c , convertedArgs [ 0 ] ) ) ; Object result ; try { result = c . newInstance ( convertedArgs [ 0 ] ) ; } catch ( Exception e ) { throw e ; } finally { trans . getTraceManager ( ) . fireExtensionEndEvent ( new ExtensionEvent ( trans , c , convertedArgs [ 0 ] ) ) ; } return result ; } else return c . newInstance ( convertedArgs [ 0 ] ) ; } else { int resolveType ; Object targetObject = null ; methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Method m = ( Method ) getFromCache ( methodKey , null , methodArgs ) ; if ( m != null && ! TransformerImpl . S_DEBUG ) { try { paramTypes = m . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; if ( Modifier . isStatic ( m . getModifiers ( ) ) ) return m . invoke ( null , convertedArgs [ 0 ] ) ; else { int nTargetArgs = convertedArgs [ 0 ] . length ; if ( ExpressionContext . class . isAssignableFrom ( paramTypes [ 0 ] ) ) nTargetArgs -- ; if ( methodArgs . length <= nTargetArgs ) return m . invoke ( m_defaultInstance , convertedArgs [ 0 ] ) ; else { targetObject = methodArgs [ 0 ] ; if ( targetObject instanceof XObject ) targetObject = ( ( XObject ) targetObject ) . object ( ) ; return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } } } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } if ( args . size ( ) > 0 ) { targetObject = methodArgs [ 0 ] ; if ( targetObject instanceof XObject ) targetObject = ( ( XObject ) targetObject ) . object ( ) ; if ( m_classObj . isAssignableFrom ( targetObject . getClass ( ) ) ) resolveType = MethodResolver . DYNAMIC ; else resolveType = MethodResolver . STATIC_AND_INSTANCE ; } else { targetObject = null ; resolveType = MethodResolver . STATIC_AND_INSTANCE ; } m = MethodResolver . getMethod ( m_classObj , funcName , methodArgs , convertedArgs , exprContext , resolveType ) ; putToCache ( methodKey , null , methodArgs , m ) ; if ( MethodResolver . DYNAMIC == resolveType ) { if ( TransformerImpl . S_DEBUG ) { TransformerImpl trans = ( TransformerImpl ) exprContext . getXPathContext ( ) . getOwnerObject ( ) ; trans . getTraceManager ( ) . fireExtensionEvent ( m , targetObject , convertedArgs [ 0 ] ) ; Object result ; try { result = m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } catch ( Exception e ) { throw e ; } finally { trans . getTraceManager ( ) . fireExtensionEndEvent ( m , targetObject , convertedArgs [ 0 ] ) ; } return result ; } else return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } else { if ( Modifier . isStatic ( m . getModifiers ( ) ) ) { if ( TransformerImpl . S_DEBUG ) { TransformerImpl trans = ( TransformerImpl ) exprContext . getXPathContext ( ) . getOwnerObject ( ) ; trans . getTraceManager ( ) . fireExtensionEvent ( m , null , convertedArgs [ 0 ] ) ; Object result ; try { result = m . invoke ( null , convertedArgs [ 0 ] ) ; } catch ( Exception e ) { throw e ; } finally { trans . getTraceManager ( ) . fireExtensionEndEvent ( m , null , convertedArgs [ 0 ] ) ; } return result ; } else return m . invoke ( null , convertedArgs [ 0 ] ) ; } else { if ( null == m_defaultInstance ) { if ( TransformerImpl . S_DEBUG ) { TransformerImpl trans = ( TransformerImpl ) exprContext . getXPathContext ( ) . getOwnerObject ( ) ; trans . getTraceManager ( ) . fireExtensionEvent ( new ExtensionEvent ( trans , m_classObj ) ) ; try { m_defaultInstance = m_classObj . newInstance ( ) ; } catch ( Exception e ) { throw e ; } finally { trans . getTraceManager ( ) . fireExtensionEndEvent ( new ExtensionEvent ( trans , m_classObj ) ) ; } } else m_defaultInstance = m_classObj . newInstance ( ) ; } if ( TransformerImpl . S_DEBUG ) { TransformerImpl trans = ( TransformerImpl ) exprContext . getXPathContext ( ) . getOwnerObject ( ) ; trans . getTraceManager ( ) . fireExtensionEvent ( m , m_defaultInstance , convertedArgs [ 0 ] ) ; Object result ; try { result = m . invoke ( m_defaultInstance , convertedArgs [ 0 ] ) ; } catch ( Exception e ) { throw e ; } finally { trans . getTraceManager ( ) . fireExtensionEndEvent ( m , m_defaultInstance , convertedArgs [ 0 ] ) ; } return result ; } else return m . invoke ( m_defaultInstance , convertedArgs [ 0 ] ) ; } } } } catch ( InvocationTargetException ite ) { Throwable resultException = ite ; Throwable targetException = ite . getTargetException ( ) ; if ( targetException instanceof TransformerException ) throw ( ( TransformerException ) targetException ) ; else if ( targetException != null ) resultException = targetException ; throw new TransformerException ( resultException ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } public Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException { return callFunction ( extFunction . getFunctionName ( ) , args , extFunction . getMethodKey ( ) , exprContext ) ; } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { Object result = null ; Method m = ( Method ) getFromCache ( methodKey , null , null ) ; if ( null == m ) { try { m = MethodResolver . getElementMethod ( m_classObj , localPart ) ; if ( ( null == m_defaultInstance ) && ! Modifier . isStatic ( m . getModifiers ( ) ) ) { if ( TransformerImpl . S_DEBUG ) { transformer . getTraceManager ( ) . fireExtensionEvent ( new ExtensionEvent ( transformer , m_classObj ) ) ; try { m_defaultInstance = m_classObj . newInstance ( ) ; } catch ( Exception e ) { throw e ; } finally { transformer . getTraceManager ( ) . fireExtensionEndEvent ( new ExtensionEvent ( transformer , m_classObj ) ) ; } } else m_defaultInstance = m_classObj . newInstance ( ) ; } } catch ( Exception e ) { throw new TransformerException ( e . getMessage ( ) , e ) ; } putToCache ( methodKey , null , null , m ) ; } XSLProcessorContext xpc = new XSLProcessorContext ( transformer , stylesheetTree ) ; try { if ( TransformerImpl . S_DEBUG ) { transformer . getTraceManager ( ) . fireExtensionEvent ( m , m_defaultInstance , new Object [ ] { xpc , element } ) ; try { result = m . invoke ( m_defaultInstance , new Object [ ] { xpc , element } ) ; } catch ( Exception e ) { throw e ; } finally { transformer . getTraceManager ( ) . fireExtensionEndEvent ( m , m_defaultInstance , new Object [ ] { xpc , element } ) ; } } else result = m . invoke ( m_defaultInstance , new Object [ ] { xpc , element } ) ; } catch ( InvocationTargetException e ) { Throwable targetException = e . getTargetException ( ) ; if ( targetException instanceof TransformerException ) throw ( TransformerException ) targetException ; else if ( targetException != null ) throw new TransformerException ( targetException . getMessage ( ) , targetException ) ; else throw new TransformerException ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { throw new TransformerException ( e . getMessage ( ) , e ) ; } if ( result != null ) { xpc . outputToResultTree ( stylesheetTree , result ) ; } } } 	1	['6', '3', '0', '12', '48', '0', '0', '12', '6', '0.2', '861', '1', '0', '0.615384615', '0.388888889', '2', '6', '142.1666667', '6', '2', '3']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; public class FunctionOneArg extends Function implements ExpressionOwner { Expression m_arg0 ; public Expression getArg0 ( ) { return m_arg0 ; } public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { if ( 0 == argNum ) { m_arg0 = arg ; arg . exprSetParent ( this ) ; } else reportWrongNumberArgs ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum != 1 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "one" , null ) ) ; } public boolean canTraverseOutsideSubtree ( ) { return m_arg0 . canTraverseOutsideSubtree ( ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { if ( null != m_arg0 ) m_arg0 . fixupVariables ( vars , globalsSize ) ; } public void callArgVisitors ( XPathVisitor visitor ) { if ( null != m_arg0 ) m_arg0 . callVisitors ( this , visitor ) ; } public Expression getExpression ( ) { return m_arg0 ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_arg0 = exp ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( null != m_arg0 ) { if ( null == ( ( FunctionOneArg ) expr ) . m_arg0 ) return false ; if ( ! m_arg0 . deepEquals ( ( ( FunctionOneArg ) expr ) . m_arg0 ) ) return false ; } else if ( null != ( ( FunctionOneArg ) expr ) . m_arg0 ) return false ; return true ; } } 	1	['11', '3', '15', '22', '20', '0', '15', '7', '10', '0.3', '113', '0', '1', '0.791666667', '0.345454545', '2', '4', '9.181818182', '6', '1.5455', '1']
package org . apache . xml . utils ; import java . util . Hashtable ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParserFactory ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; import org . xml . sax . SAXException ; public class XMLReaderManager { private static final String NAMESPACES_FEATURE = "http://xml.org/sax/features/namespaces" ; private static final String NAMESPACE_PREFIXES_FEATURE = "http://xml.org/sax/features/namespace-prefixes" ; private static final XMLReaderManager m_singletonManager = new XMLReaderManager ( ) ; private static SAXParserFactory m_parserFactory ; private ThreadLocal m_readers ; private Hashtable m_inUse ; private XMLReaderManager ( ) { } public static XMLReaderManager getInstance ( ) { return m_singletonManager ; } public synchronized XMLReader getXMLReader ( ) throws SAXException { XMLReader reader ; boolean readerInUse ; if ( m_readers == null ) { m_readers = new ThreadLocal ( ) ; } if ( m_inUse == null ) { m_inUse = new Hashtable ( ) ; } reader = ( XMLReader ) m_readers . get ( ) ; boolean threadHasReader = ( reader != null ) ; if ( ! threadHasReader || m_inUse . get ( reader ) == Boolean . TRUE ) { try { try { reader = XMLReaderFactory . createXMLReader ( ) ; } catch ( Exception e ) { try { if ( m_parserFactory == null ) { m_parserFactory = SAXParserFactory . newInstance ( ) ; m_parserFactory . setNamespaceAware ( true ) ; } reader = m_parserFactory . newSAXParser ( ) . getXMLReader ( ) ; } catch ( ParserConfigurationException pce ) { throw pce ; } } try { reader . setFeature ( NAMESPACES_FEATURE , true ) ; reader . setFeature ( NAMESPACE_PREFIXES_FEATURE , false ) ; } catch ( SAXException se ) { } } catch ( ParserConfigurationException ex ) { throw new SAXException ( ex ) ; } catch ( FactoryConfigurationError ex1 ) { throw new SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( ! threadHasReader ) { m_readers . set ( reader ) ; m_inUse . put ( reader , Boolean . TRUE ) ; } } else { m_inUse . put ( reader , Boolean . TRUE ) ; } return reader ; } public synchronized void releaseXMLReader ( XMLReader reader ) { if ( m_readers . get ( ) == reader ) { m_inUse . put ( reader , Boolean . FALSE ) ; } } } 	1	['5', '1', '0', '4', '21', '6', '4', '0', '3', '0.958333333', '135', '1', '1', '0', '0.5', '0', '0', '24.8', '2', '0.8', '2']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_pl extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Funkcja current() jest niedozwolona we wzorcu!" } , { ER_CURRENT_TAKES_NO_ARGS , "Funkcja current() nie akceptuje argumentów!" } , { ER_DOCUMENT_REPLACED , "Implementacja funkcji document() została zastąpiona przez org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "Kontekst nie ma dokumentu właściciela!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "Funkcja local-name() ma zbyt wiele argumentów." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "Funkcja namespace-uri() ma zbyt wiele argumentów." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "Funkcja normalize-space() ma zbyt wiele argumentów." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "Funkcja number() ma zbyt wiele argumentów." } , { ER_NAME_HAS_TOO_MANY_ARGS , "Funkcja name() ma zbyt wiele argumentów." } , { ER_STRING_HAS_TOO_MANY_ARGS , "Funkcja string() ma zbyt wiele argumentów." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "Funkcja string-length() ma zbyt wiele argumentów." } , { ER_TRANSLATE_TAKES_3_ARGS , "Funkcja translate() akceptuje trzy argumenty!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "Funkcja unparsed-entity-uri() akceptuje tylko jeden argument!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "Oś przestrzeni nazw nie została jeszcze zaimplementowana!" } , { ER_UNKNOWN_AXIS , "nieznana oś: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "Nieznana operacja uzgadniania!" } , { ER_INCORRECT_ARG_LENGTH , "Długość argumentu testu węzła processing-instruction() jest niepoprawna!" } , { ER_CANT_CONVERT_TO_NUMBER , "Nie można przekształcić {0} w liczbę" } , { ER_CANT_CONVERT_TO_NODELIST , "Nie można przekształcić {0} w NodeList!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Nie można przekształcić {0} w NodeSetDTM!" } , { ER_CANT_CONVERT_TO_TYPE , "Nie można przekształcić {0} w type#{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Oczekiwano wzorca uzgadniania w getMatchScore!" } , { ER_COULDNOT_GET_VAR_NAMED , "Nie można pobrać zmiennej o nazwie {0}" } , { ER_UNKNOWN_OPCODE , "BŁĄD! Nieznany kod operacji: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Nadmiarowe niedozwolone leksemy: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Literał bez cudzysłowu... oczekiwano podwójnego cudzysłowu!" } , { ER_EXPECTED_SINGLE_QUOTE , "Literał bez cudzysłowu... oczekiwano pojedynczego cudzysłowu!" } , { ER_EMPTY_EXPRESSION , "Puste wyrażenie!" } , { ER_EXPECTED_BUT_FOUND , "Oczekiwano {0}, ale znaleziono: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Asercja programisty jest niepoprawna! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "argument boolean(...) nie jest już opcjonalny wg projektu 19990709 XPath draft." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Znaleziono znak ',', ale nie ma poprzedzającego argumentu!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Znaleziono znak ',', ale nie ma następującego argumentu!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predykat]' lub '.[predykat]' to niedozwolona składnia. Użyj zamiast tego 'self::node()[predykat]'." } , { ER_ILLEGAL_AXIS_NAME , "Niedozwolona nazwa osi: {0}" } , { ER_UNKNOWN_NODETYPE , "Nieznany typ węzła: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Literał wzorca ({0}) musi być w cudzysłowie!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "Nie można sformatować {0} do postaci liczbowej!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Nie można utworzyć połączenia XML TransformerFactory: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Błąd! Nie znaleziono wyrażenia wyboru xpath (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "BŁĄD! Nie można znaleźć ENDOP po OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Wystąpił błąd!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference nadana zmiennej nie należy do kontekstu lub nie ma definicji!  Nazwa = {0}" } , { ER_AXES_NOT_ALLOWED , "We wzorcach zgodności dozwolone są tylko osie child:: oraz attribute::!  Niewłaściwe osie = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "Funkcja key() ma niepoprawną liczbę argumentów." } , { ER_COUNT_TAKES_1_ARG , "Funkcja count() akceptuje tylko jeden argument!" } , { ER_COULDNOT_FIND_FUNCTION , "Nie można znaleźć funkcji: {0}" } , { ER_UNSUPPORTED_ENCODING , "Nieobsługiwane kodowanie: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Wystąpił problem w DTM w getNextSibling... próba wyjścia z błędu" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Błąd programisty: Nie można zapisywać do EmptyNodeList." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory nie jest obsługiwane przez XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Przedrostek musi dać się przetłumaczyć na przestrzeń nazw: {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (źródło InputSource) nie jest obsługiwane w XPathContext! Nie można otworzyć {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API characters(char ch[]... nie jest obsługiwane przez DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... nie jest obsługiwane przez DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison nie może obsłużyć węzłów typu {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper nie może obsłużyć węzłów typu {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Błąd DOM2Helper.parse : ID systemu - {0} wiersz - {1}" } , { ER_XERCES_PARSE_ERROR , "Błąd DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Wykryto niepoprawny surogat UTF-16: {0} ?" } , { ER_OIERROR , "Błąd we/wy" } , { ER_CANNOT_CREATE_URL , "Nie można utworzyć adresu url dla {0}" } , { ER_XPATH_READOBJECT , "W XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "Nie znaleziono leksemu funkcji." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Nie można uporać się z typem XPath {0}" } , { ER_NODESET_NOT_MUTABLE , "Ten NodeSet nie jest zmienny" } , { ER_NODESETDTM_NOT_MUTABLE , "Ten NodeSetDTM nie jest zmienny" } , { ER_VAR_NOT_RESOLVABLE , "Nie można rozstrzygnąć zmiennej {0}" } , { ER_NULL_ERROR_HANDLER , "Pusta procedura obsługi błędu" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Asercja programisty: nieznany opcode: {0}" } , { ER_ZERO_OR_ONE , "0 lub 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "Funkcja rtf() nie jest obsługiwana przez XRTreeFragSelectWrapper" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "Funkcja asNodeIterator() nie jest obsługiwana przez XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "Funkcja fsb() nie jest obsługiwana dla XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Nie można znaleźć zmiennej o nazwie {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars nie może pobrać ciągu znaków jako argumentu" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "Argument FastStringBuffer nie może być pusty" } , { ER_TWO_OR_THREE , "2 lub 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Nastąpiło odwołanie do zmiennej, zanim została ona związana!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB nie może pobrać ciągu znaków jako argumentu!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Błąd! Ustawienie root wędrownika na null!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Ten NodeSetDTM nie może iterować do poprzedniego węzła!" } , { ER_NODESET_CANNOT_ITERATE , "Ten NodeSet nie może iterować do poprzedniego węzła!" } , { ER_NODESETDTM_CANNOT_INDEX , "Ten NodeSetDTM nie może wykonać funkcji indeksowania lub zliczania!" } , { ER_NODESET_CANNOT_INDEX , "Ten NodeSet nie może wykonać funkcji indeksowania lub zliczania!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Nie można wywołać setShouldCacheNodes po wywołaniu nextNode!" } , { ER_ONLY_ALLOWS , "{0} zezwala tylko na {1} argumenty" } , { ER_UNKNOWN_STEP , "Asercja programisty w getNextStepPos: nieznany stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Po leksemie '/' oraz '//' oczekiwana była ścieżka względna położenia." } , { ER_EXPECTED_LOC_PATH , "Oczekiwano ścieżki położenia, ale napotkano następujący leksem:  {0}" } , { ER_EXPECTED_LOC_STEP , "Po leksemie '/' lub '//' oczekiwany był krok położenia." } , { ER_EXPECTED_NODE_TEST , "Oczekiwano testu węzła zgodnego albo z NCName:*, albo z QName." } , { ER_EXPECTED_STEP_PATTERN , "Oczekiwano wzorca kroku, ale napotkano '/'." } , { ER_EXPECTED_REL_PATH_PATTERN , "Oczekiwano wzorca ścieżki względnej." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Nie można przekształcić {0} w wartość boolowską." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Nie można przekształcić {0} w pojedynczy węzeł. Ta procedura czytająca stosuje się do typów ANY_UNORDERED_NODE_TYPE oraz FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Nie można pobrać długości obrazu stanu w typie: {0}. Ta procedura czytająca stosuje się do typów UNORDERED_NODE_SNAPSHOT_TYPE oraz ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Nie można iterować w typie nieiterowanym: {0}" } , { ER_DOC_MUTATED , "Dokument uległ zmianie od czasu zwrócenia rezultatu. Iterator jest niepoprawny." } , { ER_INVALID_XPATH_TYPE , "Niepoprawny argument typu XPath: {0}" } , { ER_EMPTY_XPATH_RESULT , "Pusty obiekt rezultatu XPath" } , { ER_INCOMPATIBLE_TYPES , "Nie można wymusić przekształcenia zwróconego typu {0} w podany typ {1}" } , { ER_NULL_RESOLVER , "Nie można przetłumaczyć przedrostka za pomocą procedury tłumaczącej o pustym przedrostku." } , { ER_CANT_CONVERT_TO_STRING , "Nie można przekształcić {0} w ciąg znaków." } , { ER_NON_SNAPSHOT_TYPE , "Nie można wywołać snapshotItem dla typu {0}. Metoda ta stosuje się do typów UNORDERED_NODE_SNAPSHOT_TYPE oraz ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Węzeł kontekstu nie należy do dokumentu, który jest związany z tym interfejsem XPathEvaluator." } , { ER_WRONG_NODETYPE , "Nieobsługiwany typ węzła kontekstu." } , { ER_XPATH_ERROR , "Nieznany błąd w XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "Nazwa lokalizacji w funkcji format-number nie została jeszcze obsłużona!" } , { WG_PROPERTY_NOT_SUPPORTED , "Nieobsługiwana właściwość XSL {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Nie rób teraz niczego z przestrzenią nazw {0} we właściwości {1}" } , { WG_SECURITY_EXCEPTION , "Wyjątek SecurityException podczas próby dostępu do właściwości systemowej XSL {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Stara składnia: quo(...) nie jest już zdefiniowana w XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath potrzebuje obiektu pochodnego, aby zaimplementować nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "Nie znaleziono leksemu funkcji." } , { WG_COULDNOT_FIND_FUNCTION , "Nie można znaleźć funkcji: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Nie można utworzyć adresu URL z {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "Opcja -E nie jest obsługiwana przez analizator DTM" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference nadana zmiennej nie należy do kontekstu lub nie ma definicji!  Nazwa = {0}" } , { WG_UNSUPPORTED_ENCODING , "Nieobsługiwane kodowanie: {0}" } , { "ui_language" , "pl" } , { "help_language" , "pl" } , { "language" , "pl" } , { "BAD_CODE" , "Parametr createMessage był spoza zakresu" } , { "FORMAT_FAILED" , "Podczas wywołania messageFormat zgłoszony został wyjątek" } , { "version" , ">>>>>>> Wersja Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "tak" } , { "line" , "Wiersz: " } , { "column" , "Kolumna: " } , { "xsldone" , "XSLProcessor: gotowe" } , { "xpath_option" , "opcje xpath: " } , { "optionIN" , "   [-in wejściowyXMLURL]" } , { "optionSelect" , "   [-select wyrażenie xpath]" } , { "optionMatch" , "   [-match wzorzec (do diagnostyki odnajdywania zgodności ze wzorcem)]" } , { "optionAnyExpr" , "Lub po prostu wyrażenie xpath dokona zrzutu diagnostycznego" } , { "noParsermsg1" , "Proces XSL nie wykonał się pomyślnie." } , { "noParsermsg2" , "** Nie można znaleźć analizatora **" } , { "noParsermsg3" , "Sprawdź classpath." } , { "noParsermsg4" , "Jeśli nie masz analizatora XML dla języka Java firmy IBM, możesz go pobrać " } , { "noParsermsg5" , "z serwisu AlphaWorks firmy IBM: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BŁĘDNY_KOD" ; public static final String FORMAT_FAILED = "FORMATOWANIE_NIE_POWIODŁO_SIĘ" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "nr błędu" ; public static final String ERROR_HEADER = "Błąd: " ; public static final String WARNING_HEADER = "Ostrzeżenie: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "WZORZEC " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "pl" , "PL" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_es extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "¡No está permitida la función current() en un patrón de coincidencia!" } , { ER_CURRENT_TAKES_NO_ARGS , "¡La función current() no acepta argumentos!" } , { ER_DOCUMENT_REPLACED , "¡La implementación de la función document() ha sido sustituida por org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "¡El contexto no tiene un documento propietario!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() tiene demasiados argumentos." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() tiene demasiados argumentos." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() tiene demasiados argumentos." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() tiene demasiados argumentos." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() tiene demasiados argumentos." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() tiene demasiados argumentos." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() tiene demasiados argumentos." } , { ER_TRANSLATE_TAKES_3_ARGS , "¡La función translate() utiliza tres argumentos!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "¡La función unparsed-entity-uri debería utilizar un solo argumento!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "¡Eje de espacio de nombres aún no implementado!" } , { ER_UNKNOWN_AXIS , "Eje desconocido: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "¡Operación de coincidencia desconocida!" } , { ER_INCORRECT_ARG_LENGTH , "¡La longitud del argumento de prueba del nodo processing-instruction() es incorrecta!" } , { ER_CANT_CONVERT_TO_NUMBER , "No se puede convertir {0} a un número" } , { ER_CANT_CONVERT_TO_NODELIST , "¡No se puede convertir {0} a NodeList!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "¡No se puede convertir {0} a NodeSetDTM!" } , { ER_CANT_CONVERT_TO_TYPE , "No se puede convertir {0} a un tipo {1}" } , { ER_EXPECTED_MATCH_PATTERN , "¡Se esperaba un patrón de coincidencia en getMatchScore!" } , { ER_COULDNOT_GET_VAR_NAMED , "No se ha podido obtener la variable de nombre {0}" } , { ER_UNKNOWN_OPCODE , "¡ERROR! Código de operación desconocido: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Señales extra no permitidas: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Literal sin entrecomillar... ¡Se esperaban comillas dobles!" } , { ER_EXPECTED_SINGLE_QUOTE , "Literal sin entrecomillar... ¡Se esperaban comillas simples!" } , { ER_EMPTY_EXPRESSION , "¡Expresión vacía!" } , { ER_EXPECTED_BUT_FOUND , "Se esperaba {0}, pero se ha encontrado: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "¡La aserción del programador es incorrecta! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "El argumento boolean(...) ya no es opcional con el borrador de XPath 19990709." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "¡Se ha encontrado ',' pero sin argumento precedente!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "¡Se ha encontrado ',' pero sin argumento siguiente!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' o '.[predicate]' es una sintaxis no permitida. Utilice 'self::node()[predicate]' en su lugar." } , { ER_ILLEGAL_AXIS_NAME , "Nombre de eje no permitido: {0}" } , { ER_UNKNOWN_NODETYPE , "nodetype desconocido: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "¡El literal del patrón ({0}) tiene que estar entrecomillado!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "¡No se ha podido formatear {0} como un número!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "No se ha podido crear Liaison TransformerFactory XML: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "¡Error! No se ha encontrado la expresión de selección (-select) de xpath." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "¡ERROR! No se ha podido encontrar ENDOP después de OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "¡Se ha producido un error!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "¡La VariableReference dada para la variable está fuera de contexto o sin definición! Nombre = {0}" } , { ER_AXES_NOT_ALLOWED , "¡Sólo se permiten los ejes child:: y attribute:: en patrones de coincidencia! Ejes incorrectos = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() tiene un número incorrecto de argumentos." } , { ER_COUNT_TAKES_1_ARG , "¡La función count debería utilizar un solo argumento!" } , { ER_COULDNOT_FIND_FUNCTION , "No se ha podido encontrar la función: {0}" } , { ER_UNSUPPORTED_ENCODING , "Codificación no soportada: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Se ha producido un problema en DTM en getNextSibling... Intentando recuperar" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Error del programador: No se puede escribir enEmptyNodeList." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "¡setDOMFactory no soportada por XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "El prefijo debe resolverse como un espacio de nombres: {0}" } , { ER_PARSE_NOT_SUPPORTED , "¡parse (InputSource source) no soportada en XPathContext! No se puede abrir {0}" } , { ER_SAX_API_NOT_HANDLED , "¡API SAX characters(char ch[]... no manejada por DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "¡ignorableWhitespace(char ch[]... no manejada por DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison no puede manejar nodos de tipo {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper no puede manejar nodos de tipo {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Error DOM2Helper.parse: SystemID - {0} línea - {1}" } , { ER_XERCES_PARSE_ERROR , "Error DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "¿Se ha detectado un sustituto UTF-16 no válido: {0}?" } , { ER_OIERROR , "Error de ES" } , { ER_CANNOT_CREATE_URL , "No se puede crear url para: {0}" } , { ER_XPATH_READOBJECT , "En XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "Señal de función no encontrada." } , { ER_CANNOT_DEAL_XPATH_TYPE , "No se puede tratar con el tipo XPath: {0}" } , { ER_NODESET_NOT_MUTABLE , "Este NodeSet no es mutable" } , { ER_NODESETDTM_NOT_MUTABLE , "Este NodeSetDTM no es mutable" } , { ER_VAR_NOT_RESOLVABLE , "Variable no resoluble: {0}" } , { ER_NULL_ERROR_HANDLER , "Manejador de error nulo" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Aserción del programador: opcode desconocido: {0}" } , { ER_ZERO_OR_ONE , "0 ó 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() no soportada por XRTreeFragSelectWrapper" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() no soportada por XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() no soportada para XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "No se ha podido encontrar la variable con el nombre {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars no puede utilizar una serie para un argumento" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "El argumento FastStringBuffer no puede ser nulo" } , { ER_TWO_OR_THREE , "2 ó 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "¡Se ha accedido a la variable antes de enlazarla!" } , { ER_FSB_CANNOT_TAKE_STRING , "¡XStringForFSB no puede utilizar una serie para un argumento!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! ¡Error! Estableciendo raíz de walker como nulo!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "¡Este NodeSetDTM no puede iterar a un nodo previo!" } , { ER_NODESET_CANNOT_ITERATE , "¡Este NodeSet no puede iterar a un nodo previo!" } , { ER_NODESETDTM_CANNOT_INDEX , "¡Este NodeSetDTM no puede realizar funciones de indexación o recuento!" } , { ER_NODESET_CANNOT_INDEX , "¡Este NodeSet no puede realizar funciones de indexación o recuento!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "¡No se puede llamar a setShouldCacheNodes después de llamar a nextNode!" } , { ER_ONLY_ALLOWS , "{0} sólo admite {1} argumentos" } , { ER_UNKNOWN_STEP , "Aserción del programador en getNextStepPos: stepType desconocido: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Se esperaba una vía de acceso de ubicación relativa después de la señal '/' o '//'." } , { ER_EXPECTED_LOC_PATH , "Se esperaba una vía de acceso de ubicación, pero se ha encontrado la señal siguiente:  {0}" } , { ER_EXPECTED_LOC_STEP , "Se esperaba un paso de ubicación después de la señal '/' o '//'." } , { ER_EXPECTED_NODE_TEST , "Se esperaba una prueba de nodo coincidente con NCName:* o QName." } , { ER_EXPECTED_STEP_PATTERN , "Se esperaba un patrón de paso, pero se ha encontrado '/'." } , { ER_EXPECTED_REL_PATH_PATTERN , "Se esperaba un patrón de vía de acceso relativa." } , { ER_CANT_CONVERT_TO_BOOLEAN , "No se puede convertir {0} a booleano." } , { ER_CANT_CONVERT_TO_SINGLENODE , "No se puede convertir {0} a un solo nodo. Este obtenedor se aplica a los tipos ANY_UNORDERED_NODE_TYPE y FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "No se puede obtener longitud de instantánea sobre el tipo: {0}. Este obtenedor se aplica a los tipos UNORDERED_NODE_SNAPSHOT_TYPE y ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "No se puede iterar sobre un tipo no iterador: {0}" } , { ER_DOC_MUTATED , "El documento ha mutado desde que se devolvió el resultado. El iterador no es válido." } , { ER_INVALID_XPATH_TYPE , "Argumento de tipo XPath no válido: {0}" } , { ER_EMPTY_XPATH_RESULT , "Objeto de resultado XPath vacío" } , { ER_INCOMPATIBLE_TYPES , "El tipo devuelto: {0} no se puede forzar al tipo especificado: {1}" } , { ER_NULL_RESOLVER , "Imposible resolver prefijo con un solucionador de prefijo nulo." } , { ER_CANT_CONVERT_TO_STRING , "No se puede convertir {0} a serie." } , { ER_NON_SNAPSHOT_TYPE , "No se puede llamar a snapshotItem sobre el tipo: {0}. Este método se aplica a los tipos UNORDERED_NODE_SNAPSHOT_TYPE y ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "El nodo de contexto no pertenece al documento que está enlazado a este XPathEvaluator." } , { ER_WRONG_NODETYPE , "El tipo de nodo de contexto no está soportado." } , { ER_XPATH_ERROR , "Error desconocido en XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "¡No se maneja aún el nombre de entorno local en la función format-number!" } , { WG_PROPERTY_NOT_SUPPORTED , "Propiedad XSL no soportada: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "No hacer nada actualmente con el espacio de nombres {0} en la propiedad: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException al intentar acceder a la propiedad del sistema XSL: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "La antigua sintaxis: quo(...) ya no está definida en XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "¡XPath necesita un objeto derivado para implementar nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "Señal de función no encontrada." } , { WG_COULDNOT_FIND_FUNCTION , "No se ha podido encontrar la función: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "No se puede crear URL desde: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "Opción -E no soportada para analizador DTM" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "¡VariableReference dada para la variable está fuera de contexto o sin definición! Nombre = {0}" } , { WG_UNSUPPORTED_ENCODING , "Codificación no soportada: {0}" } , { "ui_language" , "es" } , { "help_language" , "es" } , { "language" , "es" } , { "BAD_CODE" , "El parámetro para createMessage estaba fuera de los límites" } , { "FORMAT_FAILED" , "Se ha generado una excepción durante la llamada messageFormat" } , { "version" , ">>>>>>> Xalan versión" } , { "version2" , "<<<<<<<" } , { "yes" , "sí" } , { "line" , "Línea núm." } , { "column" , "Columna núm." } , { "xsldone" , "XSLProcessor: terminado" } , { "xpath_option" , "Opciones de xpath:" } , { "optionIN" , "[-in URLXMLEntrada]" } , { "optionSelect" , "[-select expresión xpath]" } , { "optionMatch" , "[-match patrón de coincidencia (para diagnósticos de coincidencia)]" } , { "optionAnyExpr" , "O simplemente una expresión xpath realizará un vuelco de diagnóstico" } , { "noParsermsg1" , "El proceso XSL no ha sido satisfactorio." } , { "noParsermsg2" , "** No se ha podido encontrar el analizador **" } , { "noParsermsg3" , "Compruebe la classpath." } , { "noParsermsg4" , "Si no dispone del analizador XML para Java de IBM, puede bajarlo de " } , { "noParsermsg5" , "IBM AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Aviso: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "es" , "ES" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xpath . compiler ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xpath . Expression ; import org . apache . xpath . axes . UnionPathIterator ; import org . apache . xpath . axes . WalkerFactory ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . functions . Function ; import org . apache . xpath . functions . WrongNumberArgsException ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XString ; import org . apache . xpath . operations . And ; import org . apache . xpath . operations . Div ; import org . apache . xpath . operations . Equals ; import org . apache . xpath . operations . Gt ; import org . apache . xpath . operations . Gte ; import org . apache . xpath . operations . Lt ; import org . apache . xpath . operations . Lte ; import org . apache . xpath . operations . Minus ; import org . apache . xpath . operations . Mod ; import org . apache . xpath . operations . Mult ; import org . apache . xpath . operations . Neg ; import org . apache . xpath . operations . NotEquals ; import org . apache . xpath . operations . Operation ; import org . apache . xpath . operations . Or ; import org . apache . xpath . operations . Plus ; import org . apache . xpath . operations . UnaryOperation ; import org . apache . xpath . operations . Variable ; import org . apache . xpath . patterns . FunctionPattern ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xpath . patterns . UnionPattern ; import org . apache . xpath . res . XPATHErrorResources ; public class Compiler extends OpMap { public Compiler ( ErrorListener errorHandler , SourceLocator locator ) { m_errorHandler = errorHandler ; m_locator = locator ; } public Compiler ( ) { m_errorHandler = null ; m_locator = null ; } public Expression compile ( int opPos ) throws TransformerException { int op = getOp ( opPos ) ; Expression expr = null ; switch ( op ) { case OpCodes . OP_XPATH : expr = compile ( opPos + 2 ) ; break ; case OpCodes . OP_OR : expr = or ( opPos ) ; break ; case OpCodes . OP_AND : expr = and ( opPos ) ; break ; case OpCodes . OP_NOTEQUALS : expr = notequals ( opPos ) ; break ; case OpCodes . OP_EQUALS : expr = equals ( opPos ) ; break ; case OpCodes . OP_LTE : expr = lte ( opPos ) ; break ; case OpCodes . OP_LT : expr = lt ( opPos ) ; break ; case OpCodes . OP_GTE : expr = gte ( opPos ) ; break ; case OpCodes . OP_GT : expr = gt ( opPos ) ; break ; case OpCodes . OP_PLUS : expr = plus ( opPos ) ; break ; case OpCodes . OP_MINUS : expr = minus ( opPos ) ; break ; case OpCodes . OP_MULT : expr = mult ( opPos ) ; break ; case OpCodes . OP_DIV : expr = div ( opPos ) ; break ; case OpCodes . OP_MOD : expr = mod ( opPos ) ; break ; case OpCodes . OP_NEG : expr = neg ( opPos ) ; break ; case OpCodes . OP_STRING : expr = string ( opPos ) ; break ; case OpCodes . OP_BOOL : expr = bool ( opPos ) ; break ; case OpCodes . OP_NUMBER : expr = number ( opPos ) ; break ; case OpCodes . OP_UNION : expr = union ( opPos ) ; break ; case OpCodes . OP_LITERAL : expr = literal ( opPos ) ; break ; case OpCodes . OP_VARIABLE : expr = variable ( opPos ) ; break ; case OpCodes . OP_GROUP : expr = group ( opPos ) ; break ; case OpCodes . OP_NUMBERLIT : expr = numberlit ( opPos ) ; break ; case OpCodes . OP_ARGUMENT : expr = arg ( opPos ) ; break ; case OpCodes . OP_EXTFUNCTION : expr = compileExtension ( opPos ) ; break ; case OpCodes . OP_FUNCTION : expr = compileFunction ( opPos ) ; break ; case OpCodes . OP_LOCATIONPATH : expr = locationPath ( opPos ) ; break ; case OpCodes . OP_PREDICATE : expr = null ; break ; case OpCodes . OP_MATCHPATTERN : expr = matchPattern ( opPos + 2 ) ; break ; case OpCodes . OP_LOCATIONPATHPATTERN : expr = locationPathPattern ( opPos ) ; break ; case OpCodes . OP_QUO : error ( XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { "quo" } ) ; break ; default : error ( XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { Integer . toString ( getOp ( opPos ) ) } ) ; } return expr ; } private Expression compileOperation ( Operation operation , int opPos ) throws TransformerException { int leftPos = getFirstChildPos ( opPos ) ; int rightPos = getNextOpPos ( leftPos ) ; operation . setLeftRight ( compile ( leftPos ) , compile ( rightPos ) ) ; return operation ; } private Expression compileUnary ( UnaryOperation unary , int opPos ) throws TransformerException { int rightPos = getFirstChildPos ( opPos ) ; unary . setRight ( compile ( rightPos ) ) ; return unary ; } protected Expression or ( int opPos ) throws TransformerException { return compileOperation ( new Or ( ) , opPos ) ; } protected Expression and ( int opPos ) throws TransformerException { return compileOperation ( new And ( ) , opPos ) ; } protected Expression notequals ( int opPos ) throws TransformerException { return compileOperation ( new NotEquals ( ) , opPos ) ; } protected Expression equals ( int opPos ) throws TransformerException { return compileOperation ( new Equals ( ) , opPos ) ; } protected Expression lte ( int opPos ) throws TransformerException { return compileOperation ( new Lte ( ) , opPos ) ; } protected Expression lt ( int opPos ) throws TransformerException { return compileOperation ( new Lt ( ) , opPos ) ; } protected Expression gte ( int opPos ) throws TransformerException { return compileOperation ( new Gte ( ) , opPos ) ; } protected Expression gt ( int opPos ) throws TransformerException { return compileOperation ( new Gt ( ) , opPos ) ; } protected Expression plus ( int opPos ) throws TransformerException { return compileOperation ( new Plus ( ) , opPos ) ; } protected Expression minus ( int opPos ) throws TransformerException { return compileOperation ( new Minus ( ) , opPos ) ; } protected Expression mult ( int opPos ) throws TransformerException { return compileOperation ( new Mult ( ) , opPos ) ; } protected Expression div ( int opPos ) throws TransformerException { return compileOperation ( new Div ( ) , opPos ) ; } protected Expression mod ( int opPos ) throws TransformerException { return compileOperation ( new Mod ( ) , opPos ) ; } protected Expression neg ( int opPos ) throws TransformerException { return compileUnary ( new Neg ( ) , opPos ) ; } protected Expression string ( int opPos ) throws TransformerException { return compileUnary ( new org . apache . xpath . operations . String ( ) , opPos ) ; } protected Expression bool ( int opPos ) throws TransformerException { return compileUnary ( new org . apache . xpath . operations . Bool ( ) , opPos ) ; } protected Expression number ( int opPos ) throws TransformerException { return compileUnary ( new org . apache . xpath . operations . Number ( ) , opPos ) ; } protected Expression literal ( int opPos ) { opPos = getFirstChildPos ( opPos ) ; return ( XString ) getTokenQueue ( ) . elementAt ( getOp ( opPos ) ) ; } protected Expression numberlit ( int opPos ) { opPos = getFirstChildPos ( opPos ) ; return ( XNumber ) getTokenQueue ( ) . elementAt ( getOp ( opPos ) ) ; } protected Expression variable ( int opPos ) throws TransformerException { Variable var = new Variable ( ) ; opPos = getFirstChildPos ( opPos ) ; int nsPos = getOp ( opPos ) ; java . lang . String namespace = ( OpCodes . EMPTY == nsPos ) ? null : ( java . lang . String ) getTokenQueue ( ) . elementAt ( nsPos ) ; java . lang . String localname = ( java . lang . String ) getTokenQueue ( ) . elementAt ( getOp ( opPos + 1 ) ) ; QName qname = new QName ( namespace , localname ) ; var . setQName ( qname ) ; return var ; } protected Expression group ( int opPos ) throws TransformerException { return compile ( opPos + 2 ) ; } protected Expression arg ( int opPos ) throws TransformerException { return compile ( opPos + 2 ) ; } protected Expression union ( int opPos ) throws TransformerException { locPathDepth ++ ; try { return UnionPathIterator . createUnionIterator ( this , opPos ) ; } finally { locPathDepth -- ; } } private int locPathDepth = - 1 ; public int getLocationPathDepth ( ) { return locPathDepth ; } public Expression locationPath ( int opPos ) throws TransformerException { locPathDepth ++ ; try { DTMIterator iter = WalkerFactory . newDTMIterator ( this , opPos , ( locPathDepth == 0 ) ) ; return ( Expression ) iter ; } finally { locPathDepth -- ; } } public Expression predicate ( int opPos ) throws TransformerException { return compile ( opPos + 2 ) ; } protected Expression matchPattern ( int opPos ) throws TransformerException { locPathDepth ++ ; try { int nextOpPos = opPos ; int i ; for ( i = 0 ; getOp ( nextOpPos ) == OpCodes . OP_LOCATIONPATHPATTERN ; i ++ ) { nextOpPos = getNextOpPos ( nextOpPos ) ; } if ( i == 1 ) return compile ( opPos ) ; UnionPattern up = new UnionPattern ( ) ; StepPattern [ ] patterns = new StepPattern [ i ] ; for ( i = 0 ; getOp ( opPos ) == OpCodes . OP_LOCATIONPATHPATTERN ; i ++ ) { nextOpPos = getNextOpPos ( opPos ) ; patterns [ i ] = ( StepPattern ) compile ( opPos ) ; opPos = nextOpPos ; } up . setPatterns ( patterns ) ; return up ; } finally { locPathDepth -- ; } } public Expression locationPathPattern ( int opPos ) throws TransformerException { opPos = getFirstChildPos ( opPos ) ; return stepPattern ( opPos , 0 , null ) ; } public int getWhatToShow ( int opPos ) { int axesType = getOp ( opPos ) ; int testType = getOp ( opPos + 3 ) ; switch ( testType ) { case OpCodes . NODETYPE_COMMENT : return DTMFilter . SHOW_COMMENT ; case OpCodes . NODETYPE_TEXT : return DTMFilter . SHOW_TEXT | DTMFilter . SHOW_CDATA_SECTION ; case OpCodes . NODETYPE_PI : return DTMFilter . SHOW_PROCESSING_INSTRUCTION ; case OpCodes . NODETYPE_NODE : switch ( axesType ) { case OpCodes . FROM_NAMESPACE : return DTMFilter . SHOW_NAMESPACE ; case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : return DTMFilter . SHOW_ATTRIBUTE ; case OpCodes . FROM_SELF : case OpCodes . FROM_ANCESTORS_OR_SELF : case OpCodes . FROM_DESCENDANTS_OR_SELF : return DTMFilter . SHOW_ALL ; default : if ( getOp ( 0 ) == OpCodes . OP_MATCHPATTERN ) return ~ DTMFilter . SHOW_ATTRIBUTE & ~ DTMFilter . SHOW_DOCUMENT & ~ DTMFilter . SHOW_DOCUMENT_FRAGMENT ; else return ~ DTMFilter . SHOW_ATTRIBUTE ; } case OpCodes . NODETYPE_ROOT : return DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT ; case OpCodes . NODETYPE_FUNCTEST : return NodeTest . SHOW_BYFUNCTION ; case OpCodes . NODENAME : switch ( axesType ) { case OpCodes . FROM_NAMESPACE : return DTMFilter . SHOW_NAMESPACE ; case OpCodes . FROM_ATTRIBUTES : case OpCodes . MATCH_ATTRIBUTE : return DTMFilter . SHOW_ATTRIBUTE ; case OpCodes . MATCH_ANY_ANCESTOR : case OpCodes . MATCH_IMMEDIATE_ANCESTOR : return DTMFilter . SHOW_ELEMENT ; default : return DTMFilter . SHOW_ELEMENT ; } default : return DTMFilter . SHOW_ALL ; } } private static final boolean DEBUG = false ; protected StepPattern stepPattern ( int opPos , int stepCount , StepPattern ancestorPattern ) throws TransformerException { int startOpPos = opPos ; int stepType = getOp ( opPos ) ; if ( OpCodes . ENDOP == stepType ) { return null ; } boolean addMagicSelf = true ; int endStep = getNextOpPos ( opPos ) ; StepPattern pattern ; int argLen ; switch ( stepType ) { case OpCodes . OP_FUNCTION : if ( DEBUG ) System . out . println ( "MATCH_FUNCTION: " + m_currentPattern ) ; addMagicSelf = false ; argLen = getOp ( opPos + OpMap . MAPINDEX_LENGTH ) ; pattern = new FunctionPattern ( compileFunction ( opPos ) , Axis . PARENT , Axis . CHILD ) ; break ; case OpCodes . FROM_ROOT : if ( DEBUG ) System . out . println ( "FROM_ROOT, " + m_currentPattern ) ; addMagicSelf = false ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; pattern = new StepPattern ( DTMFilter . SHOW_DOCUMENT | DTMFilter . SHOW_DOCUMENT_FRAGMENT , Axis . PARENT , Axis . CHILD ) ; break ; case OpCodes . MATCH_ATTRIBUTE : if ( DEBUG ) System . out . println ( "MATCH_ATTRIBUTE: " + getStepLocalName ( startOpPos ) + ", " + m_currentPattern ) ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; pattern = new StepPattern ( DTMFilter . SHOW_ATTRIBUTE , getStepNS ( startOpPos ) , getStepLocalName ( startOpPos ) , Axis . PARENT , Axis . ATTRIBUTE ) ; break ; case OpCodes . MATCH_ANY_ANCESTOR : if ( DEBUG ) System . out . println ( "MATCH_ANY_ANCESTOR: " + getStepLocalName ( startOpPos ) + ", " + m_currentPattern ) ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; int what = getWhatToShow ( startOpPos ) ; if ( 0x00000500 == what ) addMagicSelf = false ; pattern = new StepPattern ( getWhatToShow ( startOpPos ) , getStepNS ( startOpPos ) , getStepLocalName ( startOpPos ) , Axis . ANCESTOR , Axis . CHILD ) ; break ; case OpCodes . MATCH_IMMEDIATE_ANCESTOR : if ( DEBUG ) System . out . println ( "MATCH_IMMEDIATE_ANCESTOR: " + getStepLocalName ( startOpPos ) + ", " + m_currentPattern ) ; argLen = getArgLengthOfStep ( opPos ) ; opPos = getFirstChildPosOfStep ( opPos ) ; pattern = new StepPattern ( getWhatToShow ( startOpPos ) , getStepNS ( startOpPos ) , getStepLocalName ( startOpPos ) , Axis . PARENT , Axis . CHILD ) ; break ; default : error ( XPATHErrorResources . ER_UNKNOWN_MATCH_OPERATION , null ) ; return null ; } pattern . setPredicates ( getCompiledPredicates ( opPos + argLen ) ) ; if ( null == ancestorPattern ) { } else { pattern . setRelativePathPattern ( ancestorPattern ) ; } StepPattern relativePathPattern = stepPattern ( endStep , stepCount + 1 , pattern ) ; return ( null != relativePathPattern ) ? relativePathPattern : pattern ; } public Expression [ ] getCompiledPredicates ( int opPos ) throws TransformerException { int count = countPredicates ( opPos ) ; if ( count > 0 ) { Expression [ ] predicates = new Expression [ count ] ; compilePredicates ( opPos , predicates ) ; return predicates ; } return null ; } public int countPredicates ( int opPos ) throws TransformerException { int count = 0 ; while ( OpCodes . OP_PREDICATE == getOp ( opPos ) ) { count ++ ; opPos = getNextOpPos ( opPos ) ; } return count ; } private void compilePredicates ( int opPos , Expression [ ] predicates ) throws TransformerException { for ( int i = 0 ; OpCodes . OP_PREDICATE == getOp ( opPos ) ; i ++ ) { predicates [ i ] = predicate ( opPos ) ; opPos = getNextOpPos ( opPos ) ; } } Expression compileFunction ( int opPos ) throws TransformerException { int endFunc = opPos + getOp ( opPos + 1 ) - 1 ; opPos = getFirstChildPos ( opPos ) ; int funcID = getOp ( opPos ) ; opPos ++ ; if ( - 1 != funcID ) { Function func = FunctionTable . getFunction ( funcID ) ; func . postCompileStep ( this ) ; try { int i = 0 ; for ( int p = opPos ; p < endFunc ; p = getNextOpPos ( p ) , i ++ ) { func . setArg ( compile ( p ) , i ) ; } func . checkNumberArgs ( i ) ; } catch ( WrongNumberArgsException wnae ) { java . lang . String name = FunctionTable . m_functions [ funcID ] . getName ( ) ; m_errorHandler . fatalError ( new TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_ONLY_ALLOWS , new Object [ ] { name , wnae . getMessage ( ) } ) , m_locator ) ) ; } return func ; } else { error ( XPATHErrorResources . ER_FUNCTION_TOKEN_NOT_FOUND , null ) ; return null ; } } private static long s_nextMethodId = 0 ; synchronized private long getNextMethodId ( ) { if ( s_nextMethodId == Long . MAX_VALUE ) s_nextMethodId = 0 ; return s_nextMethodId ++ ; } private Expression compileExtension ( int opPos ) throws TransformerException { int endExtFunc = opPos + getOp ( opPos + 1 ) - 1 ; opPos = getFirstChildPos ( opPos ) ; java . lang . String ns = ( java . lang . String ) getTokenQueue ( ) . elementAt ( getOp ( opPos ) ) ; opPos ++ ; java . lang . String funcName = ( java . lang . String ) getTokenQueue ( ) . elementAt ( getOp ( opPos ) ) ; opPos ++ ; Function extension = new FuncExtFunction ( ns , funcName , String . valueOf ( getNextMethodId ( ) ) ) ; try { int i = 0 ; while ( opPos < endExtFunc ) { int nextOpPos = getNextOpPos ( opPos ) ; extension . setArg ( this . compile ( opPos ) , i ) ; opPos = nextOpPos ; i ++ ; } } catch ( WrongNumberArgsException wnae ) { ; } return extension ; } public void warn ( String msg , Object [ ] args ) throws TransformerException { java . lang . String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; if ( null != m_errorHandler ) { m_errorHandler . warning ( new TransformerException ( fmsg , m_locator ) ) ; } else { System . out . println ( fmsg + "; file " + m_locator . getSystemId ( ) + "; line " + m_locator . getLineNumber ( ) + "; column " + m_locator . getColumnNumber ( ) ) ; } } public void assertion ( boolean b , java . lang . String msg ) { if ( ! b ) { java . lang . String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } public void error ( String msg , Object [ ] args ) throws TransformerException { java . lang . String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; if ( null != m_errorHandler ) { m_errorHandler . fatalError ( new TransformerException ( fmsg , m_locator ) ) ; } else { throw new TransformerException ( fmsg , ( SAXSourceLocator ) m_locator ) ; } } private PrefixResolver m_currentPrefixResolver = null ; public PrefixResolver getNamespaceContext ( ) { return m_currentPrefixResolver ; } public void setNamespaceContext ( PrefixResolver pr ) { m_currentPrefixResolver = pr ; } ErrorListener m_errorHandler ; SourceLocator m_locator ; } 	1	['47', '2', '0', '59', '111', '1021', '22', '41', '15', '0.648550725', '1185', '0.666666667', '1', '0.323076923', '0.173913043', '1', '1', '24.08510638', '12', '1.2128', '4']
package org . apache . xalan . xsltc . dom ; import java . util . StringTokenizer ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMEnhancedForDTM ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xalan . xsltc . util . IntegerArray ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public class KeyIndex extends DTMAxisIteratorBase { private Hashtable _index = new Hashtable ( ) ; private IntegerArray _nodes = null ; private DOM _dom ; private DOMEnhancedForDTM _enhancedDOM ; private int _markedPosition = 0 ; public KeyIndex ( int dummy ) { } public void setRestartable ( boolean flag ) { } public void add ( Object value , int node ) { IntegerArray nodes ; if ( ( nodes = ( IntegerArray ) _index . get ( value ) ) == null ) { _index . put ( value , nodes = new IntegerArray ( ) ) ; } nodes . add ( node ) ; } public void merge ( KeyIndex other ) { if ( other == null ) return ; if ( other . _nodes != null ) { if ( _nodes == null ) { _nodes = other . _nodes ; } else { _nodes . merge ( other . _nodes ) ; } } } public void lookupId ( Object value ) { _nodes = null ; final StringTokenizer values = new StringTokenizer ( ( String ) value ) ; while ( values . hasMoreElements ( ) ) { final String token = ( String ) values . nextElement ( ) ; IntegerArray nodes = ( IntegerArray ) _index . get ( token ) ; if ( nodes == null && _enhancedDOM != null && _enhancedDOM . hasDOMSource ( ) ) { nodes = getDOMNodeById ( token ) ; } if ( nodes == null ) continue ; if ( _nodes == null ) { _nodes = nodes ; } else { _nodes . merge ( nodes ) ; } } } public IntegerArray getDOMNodeById ( String id ) { IntegerArray nodes = null ; if ( _enhancedDOM != null ) { int ident = _enhancedDOM . getElementById ( id ) ; if ( ident != DTM . NULL ) { nodes = new IntegerArray ( ) ; _index . put ( id , nodes ) ; nodes . add ( ident ) ; } } return nodes ; } public void lookupKey ( Object value ) { _nodes = ( IntegerArray ) _index . get ( value ) ; _position = 0 ; } public int next ( ) { if ( _nodes == null ) return DTMAxisIterator . END ; return ( _position < _nodes . cardinality ( ) ) ? _dom . getNodeHandle ( _nodes . at ( _position ++ ) ) : DTMAxisIterator . END ; } public int containsID ( int node , Object value ) { final String string = ( String ) value ; if ( string . indexOf ( ' ' ) > - 1 ) { final StringTokenizer values = new StringTokenizer ( string ) ; while ( values . hasMoreElements ( ) ) { final String token = ( String ) values . nextElement ( ) ; IntegerArray nodes = ( IntegerArray ) _index . get ( token ) ; if ( nodes == null && _enhancedDOM != null && _enhancedDOM . hasDOMSource ( ) ) { nodes = getDOMNodeById ( token ) ; } if ( nodes != null && nodes . indexOf ( node ) >= 0 ) { return 1 ; } } return 0 ; } else { IntegerArray nodes = ( IntegerArray ) _index . get ( value ) ; if ( nodes == null && _enhancedDOM != null && _enhancedDOM . hasDOMSource ( ) ) { nodes = getDOMNodeById ( string ) ; } return ( nodes != null && nodes . indexOf ( node ) >= 0 ) ? 1 : 0 ; } } public int containsKey ( int node , Object value ) { final IntegerArray nodes = ( IntegerArray ) _index . get ( value ) ; return ( nodes != null && nodes . indexOf ( node ) >= 0 ) ? 1 : 0 ; } public DTMAxisIterator reset ( ) { _position = 0 ; return this ; } public int getLast ( ) { return ( _nodes == null ) ? 0 : _nodes . cardinality ( ) ; } public int getPosition ( ) { return _position ; } public void setMark ( ) { _markedPosition = _position ; } public void gotoMark ( ) { _position = _markedPosition ; } public DTMAxisIterator setStartNode ( int start ) { if ( start == DTMAxisIterator . END ) { _nodes = null ; } else if ( _nodes != null ) { _position = 0 ; } return ( DTMAxisIterator ) this ; } public int getStartNode ( ) { return 0 ; } public boolean isReverse ( ) { return ( false ) ; } public DTMAxisIterator cloneIterator ( ) { KeyIndex other = new KeyIndex ( 0 ) ; other . _index = _index ; other . _nodes = _nodes ; other . _position = _position ; return ( DTMAxisIterator ) other ; } public void setDom ( DOM dom ) { _dom = dom ; if ( dom instanceof DOMEnhancedForDTM ) { _enhancedDOM = ( DOMEnhancedForDTM ) dom ; } else if ( dom instanceof DOMAdapter ) { DOM idom = ( ( DOMAdapter ) dom ) . getDOMImpl ( ) ; if ( idom instanceof DOMEnhancedForDTM ) { _enhancedDOM = ( DOMEnhancedForDTM ) idom ; } } } } 	1	['20', '2', '0', '9', '38', '34', '2', '7', '20', '0.778947368', '385', '1', '4', '0.40625', '0.242857143', '1', '7', '18', '11', '2.55', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_es extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "Hay más de una hoja de estilos definida en el mismo archivo." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "La plantilla ''{0}'' ya está definida en esta hoja de estilos." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "La plantilla ''{0}'' no está definida en esta hoja de estilos." } , { ErrorMsg . VARIABLE_REDEF_ERR , "La variable ''{0}'' se ha definido varias veces en el mismo ámbito." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "La variable o el parámetro ''{0}'' no están definidos." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "No se puede encontrar la clase ''{0}''." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "No se puede encontrar el método externo ''{0}'' (debe ser público)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "No se puede convertir el argumento/tipo de devolución en la llamada al método ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "Archivo o URI ''{0}'' no encontrado." } , { ErrorMsg . INVALID_URI_ERR , "URI ''{0}'' no válido." } , { ErrorMsg . FILE_ACCESS_ERR , "No se puede abrir el archivo o URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "Se esperaba el elemento <xsl:stylesheet> o <xsl:transform>." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "El prefijo ''{0}'' del espacio de nombres no está declarado." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Imposible resolver la llamada a la función ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "El argumento para ''{0}'' debe ser una serie literal." } , { ErrorMsg . XPATH_PARSER_ERR , "Error al analizar la expresión ''{0}'' de XPath." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Falta el atributo necesario ''{0}''." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Carácter ''{0}'' no permitido en expresión de XPath." } , { ErrorMsg . ILLEGAL_PI_ERR , "Nombre ''{0}'' no permitido para la instrucción de proceso." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "Atributo ''{0}'' fuera del elemento." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Atributo ''{0}'' no permitido." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "import/include circular. Hoja de estilos ''{0}'' ya cargada." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Los fragmentos del árbol de resultados no se pueden ordenar (elementos <xsl:sort> ignorados). Debe ordenar los nodos al crear el árbol de resultados." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "El formato decimal ''{0}'' ya está definido." } , { ErrorMsg . XSL_VERSION_ERR , "La versión de XSL ''{0}'' no está soportada por XSLTC." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Referencia de variable/parámetro circular en ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Operador desconocido para expresión binaria." } , { ErrorMsg . ILLEGAL_ARG_ERR , "Argumento(s) no permitido(s) para llamada a función." } , { ErrorMsg . DOCUMENT_ARG_ERR , "El segundo argumento de la función document() debe ser un conjunto de nodos." } , { ErrorMsg . MISSING_WHEN_ERR , "Se necesita al menos un elemento <xsl:when> en <xsl:choose>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "Sólo se permite un elemento <xsl:otherwise> en <xsl:choose>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> sólo puede utilizarse dentro de <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> sólo puede utilizarse dentro de <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "Sólo están permitidos los elementos <xsl:when> y <xsl:otherwise> en <xsl:choose>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "Falta el atributo 'name' en <xsl:attribute-set>." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Elemento hijo no permitido." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "No puede llamar a un elemento ''{0}''" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "No puede llamar a un atributo ''{0}''" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Datos de texto fuera del elemento <xsl:stylesheet> de nivel superior." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "Analizador JAXP no configurado correctamente" } , { ErrorMsg . INTERNAL_ERR , "Error interno de XSLTC irrecuperable: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Elemento XSL ''{0}'' no soportado." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "Extensión XSLTC ''{0}'' no reconocida." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "El documento de entrada no es una hoja de estilos (el espacio de nombres XSL no está declarado en el elemento raíz)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "No se ha podido encontrar el destino de la hoja de estilos ''{0}''." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "No implementado: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "El documento de entrada no contiene una hoja de estilos XSL." } , { ErrorMsg . ELEMENT_PARSE_ERR , "No se ha podido analizar el elemento ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "El atributo use de <key> debe ser node, node-set, string o number." } , { ErrorMsg . OUTPUT_VERSION_ERR , "La versión del documento XML de salida debería ser 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Operador desconocido para expresión relacional" } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Intento de utilizar un conjunto de atributos no existente ''{0}''." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "No se puede analizar la plantilla de valor del atributo ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Tipo de datos desconocido en la firma de la clase ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "No se puede convertir el tipo de datos ''{0}'' a ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Templates no contiene una definición de clase translet válida." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Templates no contiene una clase con el nombre ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "No se ha podido cargar la clase translet ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Clase translet cargada, pero no es posible crear una instancia translet." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "Intento de establecer ErrorListener para ''{0}'' como nulo" } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "Sólo StreamSource, SAXSource y DOMSource están soportadas por XSLTC" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "El objeto Source pasado a ''{0}'' no tiene contenido." } , { ErrorMsg . JAXP_COMPILE_ERR , "No se ha podido compilar la hoja de estilos" } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory no reconoce el atributo ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() debe llamarse antes de startDocument()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformer no tiene un objeto translet encapsulado." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "No se ha definido un manejador de salida para el resultado de la transformación." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "El objeto Result pasado a ''{0}'' no es válido." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Intento de acceder a una propiedad de Transformer ''{0}'' no válida." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "No se ha podido crear adaptador SAX2DOMr: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() llamado sin establecer systemId." } , { ErrorMsg . COMPILE_STDIN_ERR , "La opción -i debe utilizarse con la opción -o." } , { ErrorMsg . COMPILE_USAGE_STR , "SINOPSIS\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <salida>]\n      [-d <directorio>] [-j <archivojar>] [-p <paquete>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <hojaestilos> | -i }\n\nOPCIONES\n   -o <salida>    asigna el nombre <salida> al translet\n                  generado. Por omisión, el nombre del translet\n                  se toma del nombre de la <hojaestilos>. Esta opción\n                  se ignora si se compilan varias hojas de estilos.\n   -d <directorio> especificar un directorio de destino para el translet\n   -j <archivojar>   empaqueta las clases translet en el archivo jar del\n                  nombre especificado por <archivojar>\n   -p <paquete>   especifica un prefijo de nombre de paquete para todas las\n                  clases translet generadas.\n   -n             habilita la inclusión en línea de plantillas (comportamiento por omisión\n                  mejor según promedio).\n   -x             activa la salida de mensajes de depuración adicionales\n   -s             inhabilita la llamada a System.exit\n   -u             interpreta los argumentos <hojaestilos> como URL\n   -i             fuerza al compilador a que lea la hoja de estilos de stdin\n   -v             imprime la versión del compilador\n   -h             imprime esta sentencia de uso\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SINOPSIS \n   java org.apache.xalan.xsltc.cmdline.Transform [-j <archivojar>]\n      [-x] [-s] [-n <iteraciones>] {-u <url_documento> | <documento>}\n      <clase> [<parám1>=<valor1> ...]\n\n   utiliza la <clase> translet para transformar un documento XML \n   especificado como <documento>. La <clase> translet está en\n   la CLASSPATH del usuario o en el <archivojar> especificado opcionalmente.\nOPCIONES\n   -j <archivojar>    especifica un archivo jar desde el que se cargará translet\n   -x              activa la salida de mensajes de depuración adicionales\n   -s              inhabilita la llamada a System.exit\n   -n <iteraciones> ejecuta la transformación <iteraciones> veces y\n                   muestra información de perfiles\n   -u <url_documento> especifica el documento de entrada XML como un URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> sólo puede utilizarse dentro de <xsl:for-each> o <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "La codificación de salida ''{0}'' no está soportada en esta JVM." } , { ErrorMsg . SYNTAX_ERR , "Error de sintaxis en ''{0}''." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "No se puede encontrar el constructor externo ''{0}''." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "El primer argumento de la función Java no estática ''{0}'' no es una referencia de objeto válida." } , { ErrorMsg . TYPE_CHECK_ERR , "Error al comprobar el tipo de la expresión ''{0}''." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Error al comprobar el tipo de una expresión en una ubicación desconocida." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "La opción ''{0}'' de la línea de mandatos no es válida." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "Falta un argumento necesario en la opción ''{0}'' de la línea de mandatos." } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "AVISO:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "AVISO:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "ERROR MUY GRAVE:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "ERROR MUY GRAVE:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "ERROR:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "ERROR:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Transformación utilizando translet ''{0}'' " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Transformación utilizando translet ''{0}'' del archivo jar ''{1}''" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "No se ha podido crear una instancia de la clase TransformerFactory ''{0}''." } , { ErrorMsg . COMPILER_ERROR_KEY , "Errores del compilador:" } , { ErrorMsg . COMPILER_WARNING_KEY , "Avisos del compilador:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Errores de translet:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . GOTO_W ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . IFNE ; import org . apache . bcel . generic . IFNONNULL ; import org . apache . bcel . generic . IF_ICMPEQ ; import org . apache . bcel . generic . IF_ICMPLT ; import org . apache . bcel . generic . IF_ICMPNE ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; class StepPattern extends RelativePathPattern { private static final int NO_CONTEXT = 0 ; private static final int SIMPLE_CONTEXT = 1 ; private static final int GENERAL_CONTEXT = 2 ; protected final int _axis ; protected final int _nodeType ; protected Vector _predicates ; private Step _step = null ; private boolean _isEpsilon = false ; private int _contextCase ; private double _priority = Double . MAX_VALUE ; public StepPattern ( int axis , int nodeType , Vector predicates ) { _axis = axis ; _nodeType = nodeType ; _predicates = predicates ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate exp = ( Predicate ) _predicates . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public int getNodeType ( ) { return _nodeType ; } public void setPriority ( double priority ) { _priority = priority ; } public StepPattern getKernelPattern ( ) { return this ; } public boolean isWildcard ( ) { return _isEpsilon && hasPredicates ( ) == false ; } public StepPattern setPredicates ( Vector predicates ) { _predicates = predicates ; return ( this ) ; } protected boolean hasPredicates ( ) { return _predicates != null && _predicates . size ( ) > 0 ; } public double getDefaultPriority ( ) { if ( _priority != Double . MAX_VALUE ) { return _priority ; } if ( hasPredicates ( ) ) { return 0.5 ; } else { switch ( _nodeType ) { case - 1 : return - 0.5 ; case 0 : return 0.0 ; default : return ( _nodeType >= NodeTest . GTYPE ) ? 0.0 : - 0.5 ; } } } public int getAxis ( ) { return _axis ; } public void reduceKernelPattern ( ) { _isEpsilon = true ; } public String toString ( ) { final StringBuffer buffer = new StringBuffer ( "stepPattern(\"" ) ; buffer . append ( Axis . names [ _axis ] ) . append ( "\", " ) . append ( _isEpsilon ? ( "epsilon{" + Integer . toString ( _nodeType ) + "}" ) : Integer . toString ( _nodeType ) ) ; if ( _predicates != null ) buffer . append ( ", " ) . append ( _predicates . toString ( ) ) ; return buffer . append ( ')' ) . toString ( ) ; } private int analyzeCases ( ) { boolean noContext = true ; final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n && noContext ; i ++ ) { Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; if ( pred . isNthPositionFilter ( ) || pred . hasPositionCall ( ) || pred . hasLastCall ( ) ) { noContext = false ; } } if ( noContext ) { return NO_CONTEXT ; } else if ( n == 1 ) { return SIMPLE_CONTEXT ; } return GENERAL_CONTEXT ; } private String getNextFieldName ( ) { return "__step_pattern_iter_" + getXSLTC ( ) . nextStepPatternSerial ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( hasPredicates ( ) ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; pred . typeCheck ( stable ) ; } _contextCase = analyzeCases ( ) ; Step step = null ; if ( _contextCase == SIMPLE_CONTEXT ) { Predicate pred = ( Predicate ) _predicates . elementAt ( 0 ) ; if ( pred . isNthPositionFilter ( ) ) { _contextCase = GENERAL_CONTEXT ; step = new Step ( _axis , _nodeType , _predicates ) ; } else { step = new Step ( _axis , _nodeType , null ) ; } } else if ( _contextCase == GENERAL_CONTEXT ) { final int len = _predicates . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { ( ( Predicate ) _predicates . elementAt ( i ) ) . dontOptimize ( ) ; } step = new Step ( _axis , _nodeType , _predicates ) ; } if ( step != null ) { step . setParser ( getParser ( ) ) ; step . typeCheck ( stable ) ; _step = step ; } } return _axis == Axis . CHILD ? Type . Element : Type . Attribute ; } private void translateKernel ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _nodeType == DTM . ELEMENT_NODE ) { final int check = cpg . addInterfaceMethodref ( DOM_INTF , "isElement" , "(I)Z" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( check , 2 ) ) ; final BranchHandle icmp = il . append ( new IFNE ( null ) ) ; _falseList . add ( il . append ( new GOTO_W ( null ) ) ) ; icmp . setTarget ( il . append ( NOP ) ) ; } else if ( _nodeType == DTM . ATTRIBUTE_NODE ) { final int check = cpg . addInterfaceMethodref ( DOM_INTF , "isAttribute" , "(I)Z" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( check , 2 ) ) ; final BranchHandle icmp = il . append ( new IFNE ( null ) ) ; _falseList . add ( il . append ( new GOTO_W ( null ) ) ) ; icmp . setTarget ( il . append ( NOP ) ) ; } else { final int getEType = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( getEType , 2 ) ) ; il . append ( new PUSH ( cpg , _nodeType ) ) ; final BranchHandle icmp = il . append ( new IF_ICMPEQ ( null ) ) ; _falseList . add ( il . append ( new GOTO_W ( null ) ) ) ; icmp . setTarget ( il . append ( NOP ) ) ; } } private void translateNoContext ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; if ( ! _isEpsilon ) { il . append ( methodGen . loadCurrentNode ( ) ) ; translateKernel ( classGen , methodGen ) ; } final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; Expression exp = pred . getExpr ( ) ; exp . translateDesynthesized ( classGen , methodGen ) ; _trueList . append ( exp . _trueList ) ; _falseList . append ( exp . _falseList ) ; } InstructionHandle restore ; restore = il . append ( methodGen . storeCurrentNode ( ) ) ; backPatchTrueList ( restore ) ; BranchHandle skipFalse = il . append ( new GOTO ( null ) ) ; restore = il . append ( methodGen . storeCurrentNode ( ) ) ; backPatchFalseList ( restore ) ; _falseList . add ( il . append ( new GOTO ( null ) ) ) ; skipFalse . setTarget ( il . append ( NOP ) ) ; } private void translateSimpleContext ( ClassGenerator classGen , MethodGenerator methodGen ) { int index ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; LocalVariableGen match ; match = methodGen . addLocalVariable ( "step_pattern_tmp1" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) , null ) ; il . append ( new ISTORE ( match . getIndex ( ) ) ) ; if ( ! _isEpsilon ) { il . append ( new ILOAD ( match . getIndex ( ) ) ) ; translateKernel ( classGen , methodGen ) ; } il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; index = cpg . addMethodref ( MATCHING_ITERATOR , "<init>" , "(I" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( MATCHING_ITERATOR ) ) ) ; il . append ( DUP ) ; il . append ( new ILOAD ( match . getIndex ( ) ) ) ; _step . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( index ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( match . getIndex ( ) ) ) ; index = cpg . addInterfaceMethodref ( DOM_INTF , GET_PARENT , GET_PARENT_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; il . append ( methodGen . setStartNode ( ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( new ILOAD ( match . getIndex ( ) ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; Predicate pred = ( Predicate ) _predicates . elementAt ( 0 ) ; Expression exp = pred . getExpr ( ) ; exp . translateDesynthesized ( classGen , methodGen ) ; InstructionHandle restore = il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; exp . backPatchTrueList ( restore ) ; BranchHandle skipFalse = il . append ( new GOTO ( null ) ) ; restore = il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; exp . backPatchFalseList ( restore ) ; _falseList . add ( il . append ( new GOTO ( null ) ) ) ; skipFalse . setTarget ( il . append ( NOP ) ) ; } private void translateGeneralContext ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int iteratorIndex = 0 ; BranchHandle ifBlock = null ; LocalVariableGen iter , node , node2 ; final String iteratorName = getNextFieldName ( ) ; node = methodGen . addLocalVariable ( "step_pattern_tmp1" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) , null ) ; il . append ( new ISTORE ( node . getIndex ( ) ) ) ; iter = methodGen . addLocalVariable ( "step_pattern_tmp2" , Util . getJCRefType ( NODE_ITERATOR_SIG ) , il . getEnd ( ) , null ) ; if ( ! classGen . isExternal ( ) ) { final Field iterator = new Field ( ACC_PRIVATE , cpg . addUtf8 ( iteratorName ) , cpg . addUtf8 ( NODE_ITERATOR_SIG ) , null , cpg . getConstantPool ( ) ) ; classGen . addField ( iterator ) ; iteratorIndex = cpg . addFieldref ( classGen . getClassName ( ) , iteratorName , NODE_ITERATOR_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( iteratorIndex ) ) ; il . append ( DUP ) ; il . append ( new ASTORE ( iter . getIndex ( ) ) ) ; ifBlock = il . append ( new IFNONNULL ( null ) ) ; il . append ( classGen . loadTranslet ( ) ) ; } _step . translate ( classGen , methodGen ) ; il . append ( new ASTORE ( iter . getIndex ( ) ) ) ; if ( ! classGen . isExternal ( ) ) { il . append ( new ALOAD ( iter . getIndex ( ) ) ) ; il . append ( new PUTFIELD ( iteratorIndex ) ) ; ifBlock . setTarget ( il . append ( NOP ) ) ; } il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( node . getIndex ( ) ) ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , GET_PARENT , GET_PARENT_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; il . append ( new ALOAD ( iter . getIndex ( ) ) ) ; il . append ( SWAP ) ; il . append ( methodGen . setStartNode ( ) ) ; BranchHandle skipNext ; InstructionHandle begin , next ; node2 = methodGen . addLocalVariable ( "step_pattern_tmp3" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) , null ) ; skipNext = il . append ( new GOTO ( null ) ) ; next = il . append ( new ALOAD ( iter . getIndex ( ) ) ) ; begin = il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( new ISTORE ( node2 . getIndex ( ) ) ) ; _falseList . add ( il . append ( new IFLT ( null ) ) ) ; il . append ( new ILOAD ( node2 . getIndex ( ) ) ) ; il . append ( new ILOAD ( node . getIndex ( ) ) ) ; il . append ( new IF_ICMPLT ( next ) ) ; il . append ( new ILOAD ( node2 . getIndex ( ) ) ) ; il . append ( new ILOAD ( node . getIndex ( ) ) ) ; _falseList . add ( il . append ( new IF_ICMPNE ( null ) ) ) ; skipNext . setTarget ( begin ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( hasPredicates ( ) ) { switch ( _contextCase ) { case NO_CONTEXT : translateNoContext ( classGen , methodGen ) ; break ; case SIMPLE_CONTEXT : translateSimpleContext ( classGen , methodGen ) ; break ; default : translateGeneralContext ( classGen , methodGen ) ; break ; } } else if ( isWildcard ( ) ) { il . append ( POP ) ; } else { translateKernel ( classGen , methodGen ) ; } } } 	1	['20', '6', '1', '53', '102', '50', '8', '46', '13', '0.831578947', '1167', '1', '1', '0.838983051', '0.225', '3', '8', '56.85', '8', '2.6', '2']
package org . apache . xpath . domapi ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . XPath ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . xpath . XPathEvaluator ; import org . w3c . dom . xpath . XPathException ; import org . w3c . dom . xpath . XPathExpression ; import org . w3c . dom . xpath . XPathNSResolver ; public class XPathEvaluatorImpl implements XPathEvaluator { class DummyPrefixResolver implements PrefixResolver { public DummyPrefixResolver ( ) { } public String getNamespaceForPrefix ( String prefix , Node context ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NULL_RESOLVER , null ) ; throw new DOMException ( DOMException . NAMESPACE_ERR , fmsg ) ; } public String getNamespaceForPrefix ( String prefix ) { return getNamespaceForPrefix ( prefix , null ) ; } public boolean handlesNullPrefixes ( ) { return false ; } public String getBaseIdentifier ( ) { return null ; } } private Document m_doc = null ; public XPathEvaluatorImpl ( ) { super ( ) ; } public XPathEvaluatorImpl ( Document doc ) { m_doc = doc ; } public XPathExpression createExpression ( String expression , XPathNSResolver resolver ) throws XPathException , DOMException { try { XPath xpath = new XPath ( expression , null , ( ( null == resolver ) ? new DummyPrefixResolver ( ) : ( ( PrefixResolver ) resolver ) ) , XPath . SELECT ) ; return new XPathExpressionImpl ( xpath , m_doc ) ; } catch ( TransformerException e ) { throw new DOMException ( XPathException . INVALID_EXPRESSION_ERR , e . getMessageAndLocation ( ) ) ; } } public XPathNSResolver createNSResolver ( Node nodeResolver ) { return new XPathNSResolverImpl ( ( nodeResolver . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( ( Document ) nodeResolver ) . getDocumentElement ( ) : nodeResolver ) ; } public Object evaluate ( String expression , Node contextNode , XPathNSResolver resolver , short type , Object result ) throws XPathException , DOMException { XPathExpression xpathExpression = createExpression ( expression , resolver ) ; return xpathExpression . evaluate ( contextNode , type , result ) ; } } 	1	['5', '1', '0', '5', '15', '4', '1', '5', '5', '0.25', '77', '1', '0', '0', '0.4', '0', '0', '14.2', '2', '0.8', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemChoose extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_CHOOSE ; } public String getNodeName ( ) { return Constants . ELEMNAME_CHOOSE_STRING ; } public ElemChoose ( ) { } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; boolean found = false ; for ( ElemTemplateElement childElem = getFirstChildElem ( ) ; childElem != null ; childElem = childElem . getNextSiblingElem ( ) ) { int type = childElem . getXSLToken ( ) ; if ( Constants . ELEMNAME_WHEN == type ) { found = true ; ElemWhen when = ( ElemWhen ) childElem ; XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; if ( TransformerImpl . S_DEBUG ) { XObject test = when . getTest ( ) . execute ( xctxt , sourceNode , when ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , when , "test" , when . getTest ( ) , test ) ; if ( test . bool ( ) ) { transformer . getTraceManager ( ) . fireTraceEvent ( when ) ; transformer . executeChildTemplates ( when , true ) ; transformer . getTraceManager ( ) . fireTraceEndEvent ( when ) ; return ; } } else if ( when . getTest ( ) . bool ( xctxt , sourceNode , when ) ) { transformer . executeChildTemplates ( when , true ) ; return ; } } else if ( Constants . ELEMNAME_OTHERWISE == type ) { found = true ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( childElem ) ; transformer . executeChildTemplates ( childElem , true ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( childElem ) ; return ; } } if ( ! found ) transformer . getMsgMgr ( ) . error ( this , XSLTErrorResources . ER_CHOOSE_REQUIRES_WHEN ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_WHEN : case Constants . ELEMNAME_OTHERWISE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } public boolean canAcceptVariables ( ) { return false ; } } 	1	['6', '3', '0', '9', '26', '15', '0', '9', '6', '2', '160', '0', '0', '0.975124378', '0.444444444', '2', '6', '25.66666667', '4', '1.3333', '2']
package org . apache . xpath . compiler ; import java . util . Hashtable ; public class Keywords { static Hashtable m_keywords = new Hashtable ( ) ; static Hashtable m_axisnames = new Hashtable ( ) ; static Hashtable m_functions = new Hashtable ( ) ; static Hashtable m_nodetypes = new Hashtable ( ) ; private static final String FROM_ANCESTORS_STRING = "ancestor" ; private static final String FROM_ANCESTORS_OR_SELF_STRING = "ancestor-or-self" ; private static final String FROM_ATTRIBUTES_STRING = "attribute" ; private static final String FROM_CHILDREN_STRING = "child" ; private static final String FROM_DESCENDANTS_STRING = "descendant" ; private static final String FROM_DESCENDANTS_OR_SELF_STRING = "descendant-or-self" ; private static final String FROM_FOLLOWING_STRING = "following" ; private static final String FROM_FOLLOWING_SIBLINGS_STRING = "following-sibling" ; private static final String FROM_PARENT_STRING = "parent" ; private static final String FROM_PRECEDING_STRING = "preceding" ; private static final String FROM_PRECEDING_SIBLINGS_STRING = "preceding-sibling" ; private static final String FROM_SELF_STRING = "self" ; private static final String FROM_NAMESPACE_STRING = "namespace" ; private static final String FROM_SELF_ABBREVIATED_STRING = "." ; private static final String NODETYPE_COMMENT_STRING = "comment" ; private static final String NODETYPE_TEXT_STRING = "text" ; private static final String NODETYPE_PI_STRING = "processing-instruction" ; private static final String NODETYPE_NODE_STRING = "node" ; private static final String NODETYPE_ANYELEMENT_STRING = "*" ; private static final String FUNC_CURRENT_STRING = "current" ; private static final String FUNC_LAST_STRING = "last" ; private static final String FUNC_POSITION_STRING = "position" ; private static final String FUNC_COUNT_STRING = "count" ; static final String FUNC_ID_STRING = "id" ; public static final String FUNC_KEY_STRING = "key" ; private static final String FUNC_LOCAL_PART_STRING = "local-name" ; private static final String FUNC_NAMESPACE_STRING = "namespace-uri" ; private static final String FUNC_NAME_STRING = "name" ; private static final String FUNC_GENERATE_ID_STRING = "generate-id" ; private static final String FUNC_NOT_STRING = "not" ; private static final String FUNC_TRUE_STRING = "true" ; private static final String FUNC_FALSE_STRING = "false" ; private static final String FUNC_BOOLEAN_STRING = "boolean" ; private static final String FUNC_LANG_STRING = "lang" ; private static final String FUNC_NUMBER_STRING = "number" ; private static final String FUNC_FLOOR_STRING = "floor" ; private static final String FUNC_CEILING_STRING = "ceiling" ; private static final String FUNC_ROUND_STRING = "round" ; private static final String FUNC_SUM_STRING = "sum" ; private static final String FUNC_STRING_STRING = "string" ; private static final String FUNC_STARTS_WITH_STRING = "starts-with" ; private static final String FUNC_CONTAINS_STRING = "contains" ; private static final String FUNC_SUBSTRING_BEFORE_STRING = "substring-before" ; private static final String FUNC_SUBSTRING_AFTER_STRING = "substring-after" ; private static final String FUNC_NORMALIZE_SPACE_STRING = "normalize-space" ; private static final String FUNC_TRANSLATE_STRING = "translate" ; private static final String FUNC_CONCAT_STRING = "concat" ; private static final String FUNC_SYSTEM_PROPERTY_STRING = "system-property" ; private static final String FUNC_EXT_FUNCTION_AVAILABLE_STRING = "function-available" ; private static final String FUNC_EXT_ELEM_AVAILABLE_STRING = "element-available" ; private static final String FUNC_SUBSTRING_STRING = "substring" ; private static final String FUNC_STRING_LENGTH_STRING = "string-length" ; private static final String FUNC_UNPARSED_ENTITY_URI_STRING = "unparsed-entity-uri" ; private static final String FUNC_DOCLOCATION_STRING = "document-location" ; static { m_axisnames . put ( FROM_ANCESTORS_STRING , new Integer ( OpCodes . FROM_ANCESTORS ) ) ; m_axisnames . put ( FROM_ANCESTORS_OR_SELF_STRING , new Integer ( OpCodes . FROM_ANCESTORS_OR_SELF ) ) ; m_axisnames . put ( FROM_ATTRIBUTES_STRING , new Integer ( OpCodes . FROM_ATTRIBUTES ) ) ; m_axisnames . put ( FROM_CHILDREN_STRING , new Integer ( OpCodes . FROM_CHILDREN ) ) ; m_axisnames . put ( FROM_DESCENDANTS_STRING , new Integer ( OpCodes . FROM_DESCENDANTS ) ) ; m_axisnames . put ( FROM_DESCENDANTS_OR_SELF_STRING , new Integer ( OpCodes . FROM_DESCENDANTS_OR_SELF ) ) ; m_axisnames . put ( FROM_FOLLOWING_STRING , new Integer ( OpCodes . FROM_FOLLOWING ) ) ; m_axisnames . put ( FROM_FOLLOWING_SIBLINGS_STRING , new Integer ( OpCodes . FROM_FOLLOWING_SIBLINGS ) ) ; m_axisnames . put ( FROM_PARENT_STRING , new Integer ( OpCodes . FROM_PARENT ) ) ; m_axisnames . put ( FROM_PRECEDING_STRING , new Integer ( OpCodes . FROM_PRECEDING ) ) ; m_axisnames . put ( FROM_PRECEDING_SIBLINGS_STRING , new Integer ( OpCodes . FROM_PRECEDING_SIBLINGS ) ) ; m_axisnames . put ( FROM_SELF_STRING , new Integer ( OpCodes . FROM_SELF ) ) ; m_axisnames . put ( FROM_NAMESPACE_STRING , new Integer ( OpCodes . FROM_NAMESPACE ) ) ; m_nodetypes . put ( NODETYPE_COMMENT_STRING , new Integer ( OpCodes . NODETYPE_COMMENT ) ) ; m_nodetypes . put ( NODETYPE_TEXT_STRING , new Integer ( OpCodes . NODETYPE_TEXT ) ) ; m_nodetypes . put ( NODETYPE_PI_STRING , new Integer ( OpCodes . NODETYPE_PI ) ) ; m_nodetypes . put ( NODETYPE_NODE_STRING , new Integer ( OpCodes . NODETYPE_NODE ) ) ; m_nodetypes . put ( NODETYPE_ANYELEMENT_STRING , new Integer ( OpCodes . NODETYPE_ANYELEMENT ) ) ; m_keywords . put ( FROM_SELF_ABBREVIATED_STRING , new Integer ( OpCodes . FROM_SELF ) ) ; m_keywords . put ( FUNC_ID_STRING , new Integer ( FunctionTable . FUNC_ID ) ) ; m_keywords . put ( FUNC_KEY_STRING , new Integer ( FunctionTable . FUNC_KEY ) ) ; m_functions . put ( FUNC_CURRENT_STRING , new Integer ( FunctionTable . FUNC_CURRENT ) ) ; m_functions . put ( FUNC_LAST_STRING , new Integer ( FunctionTable . FUNC_LAST ) ) ; m_functions . put ( FUNC_POSITION_STRING , new Integer ( FunctionTable . FUNC_POSITION ) ) ; m_functions . put ( FUNC_COUNT_STRING , new Integer ( FunctionTable . FUNC_COUNT ) ) ; m_functions . put ( FUNC_ID_STRING , new Integer ( FunctionTable . FUNC_ID ) ) ; m_functions . put ( FUNC_KEY_STRING , new Integer ( FunctionTable . FUNC_KEY ) ) ; m_functions . put ( FUNC_LOCAL_PART_STRING , new Integer ( FunctionTable . FUNC_LOCAL_PART ) ) ; m_functions . put ( FUNC_NAMESPACE_STRING , new Integer ( FunctionTable . FUNC_NAMESPACE ) ) ; m_functions . put ( FUNC_NAME_STRING , new Integer ( FunctionTable . FUNC_QNAME ) ) ; m_functions . put ( FUNC_GENERATE_ID_STRING , new Integer ( FunctionTable . FUNC_GENERATE_ID ) ) ; m_functions . put ( FUNC_NOT_STRING , new Integer ( FunctionTable . FUNC_NOT ) ) ; m_functions . put ( FUNC_TRUE_STRING , new Integer ( FunctionTable . FUNC_TRUE ) ) ; m_functions . put ( FUNC_FALSE_STRING , new Integer ( FunctionTable . FUNC_FALSE ) ) ; m_functions . put ( FUNC_BOOLEAN_STRING , new Integer ( FunctionTable . FUNC_BOOLEAN ) ) ; m_functions . put ( FUNC_LANG_STRING , new Integer ( FunctionTable . FUNC_LANG ) ) ; m_functions . put ( FUNC_NUMBER_STRING , new Integer ( FunctionTable . FUNC_NUMBER ) ) ; m_functions . put ( FUNC_FLOOR_STRING , new Integer ( FunctionTable . FUNC_FLOOR ) ) ; m_functions . put ( FUNC_CEILING_STRING , new Integer ( FunctionTable . FUNC_CEILING ) ) ; m_functions . put ( FUNC_ROUND_STRING , new Integer ( FunctionTable . FUNC_ROUND ) ) ; m_functions . put ( FUNC_SUM_STRING , new Integer ( FunctionTable . FUNC_SUM ) ) ; m_functions . put ( FUNC_STRING_STRING , new Integer ( FunctionTable . FUNC_STRING ) ) ; m_functions . put ( FUNC_STARTS_WITH_STRING , new Integer ( FunctionTable . FUNC_STARTS_WITH ) ) ; m_functions . put ( FUNC_CONTAINS_STRING , new Integer ( FunctionTable . FUNC_CONTAINS ) ) ; m_functions . put ( FUNC_SUBSTRING_BEFORE_STRING , new Integer ( FunctionTable . FUNC_SUBSTRING_BEFORE ) ) ; m_functions . put ( FUNC_SUBSTRING_AFTER_STRING , new Integer ( FunctionTable . FUNC_SUBSTRING_AFTER ) ) ; m_functions . put ( FUNC_NORMALIZE_SPACE_STRING , new Integer ( FunctionTable . FUNC_NORMALIZE_SPACE ) ) ; m_functions . put ( FUNC_TRANSLATE_STRING , new Integer ( FunctionTable . FUNC_TRANSLATE ) ) ; m_functions . put ( FUNC_CONCAT_STRING , new Integer ( FunctionTable . FUNC_CONCAT ) ) ; m_functions . put ( FUNC_SYSTEM_PROPERTY_STRING , new Integer ( FunctionTable . FUNC_SYSTEM_PROPERTY ) ) ; m_functions . put ( FUNC_EXT_FUNCTION_AVAILABLE_STRING , new Integer ( FunctionTable . FUNC_EXT_FUNCTION_AVAILABLE ) ) ; m_functions . put ( FUNC_EXT_ELEM_AVAILABLE_STRING , new Integer ( FunctionTable . FUNC_EXT_ELEM_AVAILABLE ) ) ; m_functions . put ( FUNC_SUBSTRING_STRING , new Integer ( FunctionTable . FUNC_SUBSTRING ) ) ; m_functions . put ( FUNC_STRING_LENGTH_STRING , new Integer ( FunctionTable . FUNC_STRING_LENGTH ) ) ; m_functions . put ( FUNC_UNPARSED_ENTITY_URI_STRING , new Integer ( FunctionTable . FUNC_UNPARSED_ENTITY_URI ) ) ; m_functions . put ( NODETYPE_COMMENT_STRING , new Integer ( OpCodes . NODETYPE_COMMENT ) ) ; m_functions . put ( NODETYPE_TEXT_STRING , new Integer ( OpCodes . NODETYPE_TEXT ) ) ; m_functions . put ( NODETYPE_PI_STRING , new Integer ( OpCodes . NODETYPE_PI ) ) ; m_functions . put ( NODETYPE_NODE_STRING , new Integer ( OpCodes . NODETYPE_NODE ) ) ; m_functions . put ( FUNC_DOCLOCATION_STRING , new Integer ( FunctionTable . FUNC_DOCLOCATION ) ) ; } public static boolean functionAvailable ( String methName ) { try { Object tblEntry = m_functions . get ( methName ) ; if ( null == tblEntry ) return false ; int funcType = ( ( Integer ) tblEntry ) . intValue ( ) ; switch ( funcType ) { case OpCodes . NODETYPE_COMMENT : case OpCodes . NODETYPE_TEXT : case OpCodes . NODETYPE_PI : case OpCodes . NODETYPE_NODE : return false ; default : return true ; } } catch ( Exception e ) { return false ; } } } 	1	['3', '1', '0', '4', '9', '1', '4', '0', '2', '1.456896552', '583', '0.896551724', '0', '0', '0.5', '0', '0', '174', '3', '1', '2']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_hu extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "A függvény nem támogatott!" } , { ER_CANNOT_OVERWRITE_CAUSE , "Nem lehet felülírni az okot" } , { ER_NO_DEFAULT_IMPL , "Nem találtunk alapértelmezett megvalósítást " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "A ChunkedIntArray({0}) jelenleg nem támogatott" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Az eltolás nagyobb mint a nyílás" } , { ER_COROUTINE_NOT_AVAIL , "Társ-szubrutin nem érhető el, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager érkezett a co_exit() kérésre" } , { ER_COJOINROUTINESET_FAILED , "A co_joinCoroutineSet() nem sikerült" } , { ER_COROUTINE_PARAM , "Társ-szubrutin paraméter hiba ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nVÁRATLAN: elemző doTerminate válaszok {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "A parse-t nem hívhatja meg a elemzés közben" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Hiba: A típusos iterátor a(z) {0} tengelyhez nincs megvalósítva" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Hiba: Az iterátor a(z) {0} tengelyhez nincs megvalósítva " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Az iterátor klónok nem támogatottak" } , { ER_UNKNOWN_AXIS_TYPE , "Ismeretlen tengelytraverzál-típus: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Tengelytraverzál nem támogatott: {0}" } , { ER_NO_DTMIDS_AVAIL , "Nincs több DTM ID" } , { ER_NOT_SUPPORTED , "Nem támogatott: {0}" } , { ER_NODE_NON_NULL , "A csomópint nem-null kell legyen a getDTMHandleFromNode-hoz" } , { ER_COULD_NOT_RESOLVE_NODE , "Nem lehet a csomópontot hivatkozásra feloldani" } , { ER_STARTPARSE_WHILE_PARSING , "A startParse-t nem hívhatja elemzés közben" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "A startParse-nak nem-null SAXParser kell" } , { ER_COULD_NOT_INIT_PARSER , "Nem lehet inicializálni az elemzőt ezzel" } , { ER_EXCEPTION_CREATING_POOL , "kivétel egy új pool példány létrehozásánál" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Az eléréi út érvénytelen eszképszekvenciát tartalmaz" } , { ER_SCHEME_REQUIRED , "Sémára szükség van!" } , { ER_NO_SCHEME_IN_URI , "Nem található séma az URI-ban: {0}" } , { ER_NO_SCHEME_INURI , "Nem található séma az URI-ban" } , { ER_PATH_INVALID_CHAR , "Az elérési út érvénytelen karaktert tartalmaz: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Nem lehet beállítani a sémát null karakterláncból" } , { ER_SCHEME_NOT_CONFORMANT , "A séma nem megfelelő." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "A host nem jól formázott cím" } , { ER_PORT_WHEN_HOST_NULL , "A port-t nem állíthatja be, ha a host null" } , { ER_INVALID_PORT , "Érvénytelen portszám" } , { ER_FRAG_FOR_GENERIC_URI , "Darabot csak egy általános URI-hoz állíthat be" } , { ER_FRAG_WHEN_PATH_NULL , "A darabot csak nem állíthatja be, hí az elérési út null" } , { ER_FRAG_INVALID_CHAR , "A darab érvénytelen karaktert tartalmaz" } , { ER_PARSER_IN_USE , "Az elemző már használatban van" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Nem változtatható meg a(z) {0} {1} elemzés közben" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Az ön-megokolás nem megengedett" } , { ER_NO_USERINFO_IF_NO_HOST , "Nem adhat meg userinfo-t, ha nem adott meg host-ot" } , { ER_NO_PORT_IF_NO_HOST , "Nem adhat meg port-ot, ha nem adott meg host-ot" } , { ER_NO_QUERY_STRING_IN_PATH , "Lekérdezési karakterláncot nem adhat meg elérési útban és lekérdezési karakterláncban" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Darabot nem adhat meg sem az elérési útban sem a darabban" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Nem inicializálhatja az URI-t üres paraméterekkel" } , { ER_METHOD_NOT_SUPPORTED , "A metódus még nem támogatott " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "Az IncrementalSAXSource_Filter jelenleg nem índítható újra" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader nem a startParse kérés előtt" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Tengelytraverzál nem támogatott: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "A ListingErrorHandler létrejött null PrintWriter-rel!" } , { ER_SYSTEMID_UNKNOWN , "Ismeretlen SystemId" } , { ER_LOCATION_UNKNOWN , "A hiba helye ismeretlen" } , { ER_PREFIX_MUST_RESOLVE , "Az előtagnak egy névtérre kell feloldódnia: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "A createDocument() nem támogatott az XPathContext-ben!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Az attribútum leszármazottnak nincs tulajdonos dokumentuma!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Az attribútum leszármazottnak nincs tulajdonos dokumentum eleme!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Figyelmeztetés: nem lehet szöveget kiírni dokumentum elem előtt!  Figyelmen kívül marad..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Nem lehet egynél több gyökér a DOM-on!" } , { ER_ARG_LOCALNAME_NULL , "A 'localName' argumentum null" } , { ER_ARG_LOCALNAME_INVALID , "A QNAME-beli helyi névnek egy érvényes NCName-nek kell lenni" } , { ER_ARG_PREFIX_INVALID , "A QNAME-beli prefixnek egy érvényes NCName-nek kell lenni" } , { "BAD_CODE" , "A createMessage paramétere nincs a megfelelő tartományban" } , { "FORMAT_FAILED" , "Kivétel történt a messageFormat hívás alatt" } , { "line" , "Sor #" } , { "column" , "Oszlop #" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "A(z) ''{0}'' serializer osztály nem valósítja meg az org.xml.sax.ContentHandler funkciót." } , { ER_RESOURCE_COULD_NOT_FIND , "A(z) [ {0} ] erőforrás nem található.\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "Az erőforrást [ {0} ] nem lehet betölteni: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Pufferméret <= 0" } , { ER_INVALID_UTF16_SURROGATE , "Érvénytelen UTF-16 helyettesítés: {0} ?" } , { ER_OIERROR , "IO hiba" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "Nem lehet {0} attribútumat felvenni a gyermek node-ok után vagy mielőtt egy elem létrejönne.  Az attribútum figyelmen kívül marad." } , { ER_NAMESPACE_PREFIX , "A(z) ''{0}'' előtag névtere nem definiált." } , { ER_STRAY_ATTRIBUTE , "A(z) ''{0}'' attribútum kívül esik az elemen." } , { ER_STRAY_NAMESPACE , "A(z) ''{0}''=''{1}'' névtér-deklaráció kívül esik az elemen." } , { ER_COULD_NOT_LOAD_RESOURCE , "Nem lehet betölteni ''{0}''-t (ellenőrizze a CLASSPATH beállítást), az alapértelmezéseket használom" } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "Nem lehet betölteni a(z) ''{0}'' tulajdonság-fájlt a(z) ''{1}''  (ellenőrizze a CLASSPATH beállítást)" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "hu" , "HU" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xpath . res ; public class XPATHErrorResources_sv extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Funktionen current() är inte tillåten i ett matchningsmönster!" } , { ER_CURRENT_TAKES_NO_ARGS , "Funktionen current() tar inte emot argument!" } , { ER_DOCUMENT_REPLACED , "Implementeringen av funktionen document() har ersatts av org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "Kontext saknar ägardokument!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() har för många argument." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() har för många argument." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() har för många argument." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() har för många argument." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() har för många argument." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() har för många argument." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string.length() har för många argument." } , { ER_TRANSLATE_TAKES_3_ARGS , "Funktionen translate() tar emot tre argument!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "Funktionen unparsed-entity-uri borde ta emot ett argument!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "Namespace-axel inte implementerad än!" } , { ER_UNKNOWN_AXIS , "okänd axel: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "okänd matchningshandling!" } , { ER_INCORRECT_ARG_LENGTH , "Nodtests argumentlängd i processing-instruction() är inte korrekt!" } , { ER_CANT_CONVERT_TO_NUMBER , "Kan inte konvertera {0} till ett nummer" } , { ER_CANT_CONVERT_TO_NODELIST , "Kan inte konvertera {0} till en NodeList!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Kan inte konvertera {0} till en NodeSetDTM!" } , { ER_CANT_CONVERT_TO_TYPE , "Kan inte konvertera {0} till en type//{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Matchningsmönster i getMatchScore förväntat!" } , { ER_COULDNOT_GET_VAR_NAMED , "Kunde inte hämta variabeln {0}" } , { ER_UNKNOWN_OPCODE , "FEL! Okänd op-kod: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Ytterligare otillåtna tecken: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Litteral omges av fel sorts citationstecken... dubbla citationstecken förväntade!" } , { ER_EXPECTED_SINGLE_QUOTE , "Litteral omges av fel sorts citationstecken... enkla citationstecken förväntade!" } , { ER_EMPTY_EXPRESSION , "Tomt uttryck!" } , { ER_EXPECTED_BUT_FOUND , "{0} förväntat, men hittade: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Programmerares försäkran är inte korrekt! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "boolean(...)-argument är inte längre valfri med 19990709 XPath-utkast." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Hittade ',' men inget föregående argument!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Hittade ',' men inget efterföljande argument!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predikat]' or '.[predikat]' är otillåten syntax.  Använd 'self::node()[predikat]' istället." } , { ER_ILLEGAL_AXIS_NAME , "otillåtet axel-namn: {0}" } , { ER_UNKNOWN_NODETYPE , "okänd nodtyp: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Mönsterlitteral {0} måste sättas inom citationstecken!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} kunde inte formateras till ett nummer" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Kunde inte skapa XML TransformerFactory Liaison: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Fel! Hittade inte xpath select-uttryck (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "FEL! Hittade inte ENDOP efter OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Fel inträffade!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference angiven för variabel som är utanför sammanhanget eller som saknar definition!  Namn = {0}" } , { ER_AXES_NOT_ALLOWED , "Enbart barn::- och attribut::- axlar är tillåtna i matchningsmönster!  Regelvidriga axlar = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() har ett felaktigt antal argument." } , { ER_COUNT_TAKES_1_ARG , "Funktionen count borde ta emot ett argument!" } , { ER_COULDNOT_FIND_FUNCTION , "Hittade inte funktionen: {0}" } , { ER_UNSUPPORTED_ENCODING , "Ej understödd kodning: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Problem inträffade i DTM i getNextSibling... försöker återhämta" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Programmerarfel: EmptyNodeList kan inte skrivas till." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory understöds inte av XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (InputSource source) understöds inte av XPathContext! Kan inte öppna {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API-tecken(char ch[]... hanteras inte av DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... hanteras inte av DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison kan inte hantera noder av typen {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper kan inte hantera noder av typen {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse-fel: SystemID - {0} rad - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse-fel" } , { ER_INVALID_UTF16_SURROGATE , "Ogiltigt UTF-16-surrogat upptäckt: {0} ?" } , { ER_OIERROR , "IO-fel" } , { ER_CANNOT_CREATE_URL , "Kan inte skapa url för: {0}" } , { ER_XPATH_READOBJECT , "I XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "funktionstecken saknas." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Kan inte hantera XPath-typ: {0}" } , { ER_NODESET_NOT_MUTABLE , "NodeSet är oföränderlig" } , { ER_NODESETDTM_NOT_MUTABLE , "NodeSetDTM är oföränderlig" } , { ER_VAR_NOT_RESOLVABLE , "Variabel ej lösbar: {0}" } , { ER_NULL_ERROR_HANDLER , "Null error handler" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Programmerares försäkran: okänd op-kod: {0}" } , { ER_ZERO_OR_ONE , "0 eller 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() understöds inte av XRTreeFragSelectWrapper!" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() understöds inte av XRTreeFragSelectWrapper!" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() understöds inte av XRStringForChars!" } , { ER_COULD_NOT_FIND_VAR , "Hittade inte variabeln med namn {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars kan inte ta en sträng som argument" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer-argumentet får inte vara null" } , { ER_TWO_OR_THREE , "2 eller 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Variabeln användes innan den bands!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB kan inte ha en sträng som argument!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Fel! Anger roten för en \"walker\" till null!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Detta NodeSetDTM kan inte iterera till en tidigare nod!" } , { ER_NODESET_CANNOT_ITERATE , "Detta NodeSet kan inte iterera till en tidigare nod!" } , { ER_NODESETDTM_CANNOT_INDEX , "Detta NodeSetDTM har inte funktioner för indexering och räkning!" } , { ER_NODESET_CANNOT_INDEX , "Detta NodeSet har inte funktioner för indexering och räkning!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Det går inte att anropa setShouldCacheNodes efter att nextNode har anropats!" } , { ER_ONLY_ALLOWS , "{0} tillåter bara {1} argument" } , { ER_UNKNOWN_STEP , "Programmerarkontroll i getNextStepPos: okänt steg Typ: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "En relativ sökväg förväntades efter token '/' eller '//'." } , { ER_EXPECTED_LOC_PATH , "En plats förväntades, men följande token påträffades:  {0}" } , { ER_EXPECTED_LOC_STEP , "Ett platssteg förväntades efter token  '/' eller '//'." } , { ER_EXPECTED_NODE_TEST , "Ett nodtest som matchar antingen NCName:* eller QName förväntades." } , { ER_EXPECTED_STEP_PATTERN , "Ett stegmönster förväntades, men '/' påträffades." } , { ER_EXPECTED_REL_PATH_PATTERN , "Ett mönster för relativ sökväg förväntades." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Det går inte att konvertera {0} till ett Booleskt värde." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Det går inte att konvertera {0} till en enda nod. Gäller typerna ANY_UNORDERED_NODE_TYPE och FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Det går inte att erhålla längd för ögonblicksbild på typ: {0}. Gäller typerna UNORDERED_NODE_SNAPSHOT_TYPE och ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Det går inte att iterera över den icke itererbara typen: {0}" } , { ER_DOC_MUTATED , "Dokumentet har ändrats sedan resultatet genererades. Iterering ogiltig." } , { ER_INVALID_XPATH_TYPE , "Ogiltigt XPath-typargument: {0}" } , { ER_EMPTY_XPATH_RESULT , "Tomt XPath-resultatobjekt" } , { ER_INCOMPATIBLE_TYPES , "Den genererade typen: {0} kan inte bearbetas i den angivna typen: {1}" } , { ER_NULL_RESOLVER , "Det går inte att lösa prefixet utan prefixlösare." } , { ER_CANT_CONVERT_TO_STRING , "Det går inte att konvertera {0} till en sträng." } , { ER_NON_SNAPSHOT_TYPE , "Det går inte att anropa snapshotItem på typ: {0}. Metoden gäller typerna UNORDERED_NODE_SNAPSHOT_TYPE och ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Kontextnoden tillhör inte dokumentet som är bundet till denna XPathEvaluator." } , { ER_WRONG_NODETYPE , "Kontextnoden kan inte hanteras." } , { ER_XPATH_ERROR , "Okänt fel i XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "locale-namnet i format-number-funktionen ännu inte hanterat!" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL-Egenskap understöds inte: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Gör för närvarande inte någonting med namespace {0} i egenskap: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException vid försök att få tillgång till XSL-systemegenskap: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Gammal syntax: quo(...) är inte längre definierad i XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath behöver ett deriverat objekt för att implementera nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "funktionstecken saknas." } , { WG_COULDNOT_FIND_FUNCTION , "Hittade inte funktion: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Kan inte skapa URL från: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "Alternativet -E understöds inte för DTM-tolk" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference angiven för variabel som är utanför sammanhanget eller som saknar definition!  Namn = {0}" } , { WG_UNSUPPORTED_ENCODING , "Ej understödd kodning: {0}" } , { "ui_language" , "sv" } , { "help_language" , "sv" } , { "language" , "sv" } , { "BAD_CODE" , "Parameter till createMessage ligger utanför tillåtet intervall" } , { "FORMAT_FAILED" , "Undantag utlöst vid messageFormat-anrop" } , { "version" , ">>>>>>> Xalan Version" } , { "version2" , "<<<<<<<" } , { "yes" , "ja" } , { "line" , "Rad //" } , { "column" , "Kolumn //" } , { "xsldone" , "XSLProcessor färdig" } , { "xpath_option" , "xpath-alternativ" } , { "optionIN" , "    [-in inputXMLURL]" } , { "optionSelect" , "[-select xpath-uttryck]" } , { "optionMatch" , "   [-match matchningsmönster (för matchningsdiagnostik)]" } , { "optionAnyExpr" , "Eller bara ett xpath-uttryck kommer att göra en diagnostik-dump" } , { "noParsermsg1" , "XSL-Process misslyckades." } , { "noParsermsg2" , "** Hittade inte tolk **" } , { "noParsermsg3" , "Vänligen kontrollera din classpath" } , { "noParsermsg4" , "Om du inte har IBMs XML-Tolk för Java, kan du ladda ner den från" } , { "noParsermsg5" , "IBMs AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "DÅLIG_KOD" ; public static final String FORMAT_FAILDE = "FORMATTERING_MISSLYCKADES" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//fel" ; public static final String ERROR_HEADER = "Fel: " ; public static final String WARNING_HEADER = "Varning: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MÖNSTER " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.428571429', '1872', '0', '0', '0.976190476', '1', '0', '0', '618.3333333', '1', '0.3333', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class ApplyImports extends Instruction { private QName _modeName ; private String _functionName ; private int _precedence ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "ApplyTemplates" ) ; indent ( indent + IndentIncrement ) ; if ( _modeName != null ) { indent ( indent + IndentIncrement ) ; Util . println ( "mode " + _modeName ) ; } } public boolean hasWithParams ( ) { return hasContents ( ) ; } private int getMinPrecedence ( int max ) { Stylesheet stylesheet = getStylesheet ( ) ; Stylesheet root = getParser ( ) . getTopLevelStylesheet ( ) ; int min = max ; Enumeration templates = root . getContents ( ) . elements ( ) ; while ( templates . hasMoreElements ( ) ) { SyntaxTreeNode child = ( SyntaxTreeNode ) templates . nextElement ( ) ; if ( child instanceof Template ) { Stylesheet curr = child . getStylesheet ( ) ; while ( ( curr != null ) && ( curr != stylesheet ) ) { if ( curr . _importedFrom != null ) curr = curr . _importedFrom ; else if ( curr . _includedFrom != null ) curr = curr . _includedFrom ; else curr = null ; } if ( curr == stylesheet ) { int prec = child . getStylesheet ( ) . getImportPrecedence ( ) ; if ( prec < min ) min = prec ; } } } return ( min ) ; } public void parseContents ( Parser parser ) { Stylesheet stylesheet = getStylesheet ( ) ; stylesheet . setTemplateInlining ( false ) ; Template template = getTemplate ( ) ; _modeName = template . getModeName ( ) ; _precedence = template . getImportPrecedence ( ) ; stylesheet = parser . getTopLevelStylesheet ( ) ; final int maxPrecedence = _precedence ; final int minPrecedence = getMinPrecedence ( maxPrecedence ) ; final Mode mode = stylesheet . getMode ( _modeName ) ; _functionName = mode . functionName ( minPrecedence , maxPrecedence ) ; parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Stylesheet stylesheet = classGen . getStylesheet ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int current = methodGen . getLocalIndex ( "current" ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; int init = cpg . addMethodref ( SINGLETON_ITERATOR , "<init>" , "(" + NODE_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( SINGLETON_ITERATOR ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKESPECIAL ( init ) ) ; il . append ( methodGen . loadHandler ( ) ) ; final String className = classGen . getStylesheet ( ) . getClassName ( ) ; final String signature = classGen . getApplyTemplatesSig ( ) ; final int applyTemplates = cpg . addMethodref ( className , _functionName , signature ) ; il . append ( new INVOKEVIRTUAL ( applyTemplates ) ) ; } } 	1	['7', '3', '0', '21', '48', '17', '0', '21', '5', '0.888888889', '237', '1', '1', '0.903225806', '0.30952381', '1', '4', '32.42857143', '6', '1.7143', '1']
package org . apache . xml . utils ; import java . io . BufferedReader ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . net . URL ; import java . net . URLConnection ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class ListingErrorHandler implements ErrorHandler , ErrorListener { protected PrintWriter m_pw = null ; public ListingErrorHandler ( PrintWriter pw ) { if ( null == pw ) throw new NullPointerException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , null ) ) ; m_pw = pw ; } public ListingErrorHandler ( ) { m_pw = new PrintWriter ( System . err , true ) ; } public void warning ( SAXParseException exception ) throws SAXException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "warning: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnWarning ( ) ) throw exception ; } public void error ( SAXParseException exception ) throws SAXException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "error: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnError ( ) ) throw exception ; } public void fatalError ( SAXParseException exception ) throws SAXException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "fatalError: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnFatalError ( ) ) throw exception ; } public void warning ( TransformerException exception ) throws TransformerException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "warning: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnWarning ( ) ) throw exception ; } public void error ( TransformerException exception ) throws TransformerException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "error: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnError ( ) ) throw exception ; } public void fatalError ( TransformerException exception ) throws TransformerException { logExceptionLocation ( m_pw , exception ) ; m_pw . println ( "error: " + exception . getMessage ( ) ) ; m_pw . flush ( ) ; if ( getThrowOnError ( ) ) throw exception ; } public static void logExceptionLocation ( PrintWriter pw , Throwable exception ) { if ( null == pw ) pw = new PrintWriter ( System . err , true ) ; SourceLocator locator = null ; Throwable cause = exception ; do { if ( cause instanceof SAXParseException ) { locator = new SAXSourceLocator ( ( SAXParseException ) cause ) ; } else if ( cause instanceof TransformerException ) { SourceLocator causeLocator = ( ( TransformerException ) cause ) . getLocator ( ) ; if ( null != causeLocator ) { locator = causeLocator ; } } if ( cause instanceof TransformerException ) cause = ( ( TransformerException ) cause ) . getCause ( ) ; else if ( cause instanceof WrappedRuntimeException ) cause = ( ( WrappedRuntimeException ) cause ) . getException ( ) ; else if ( cause instanceof SAXException ) cause = ( ( SAXException ) cause ) . getException ( ) ; else cause = null ; } while ( null != cause ) ; if ( null != locator ) { String id = ( locator . getPublicId ( ) != locator . getPublicId ( ) ) ? locator . getPublicId ( ) : ( null != locator . getSystemId ( ) ) ? locator . getSystemId ( ) : "SystemId-Unknown" ; pw . print ( id + ":Line=" + locator . getLineNumber ( ) + ";Column=" + locator . getColumnNumber ( ) + ": " ) ; pw . println ( "exception:" + exception . getMessage ( ) ) ; pw . println ( "root-cause:" + ( ( null != cause ) ? cause . getMessage ( ) : "null" ) ) ; logSourceLine ( pw , locator ) ; } else { pw . print ( "SystemId-Unknown:locator-unavailable: " ) ; pw . println ( "exception:" + exception . getMessage ( ) ) ; pw . println ( "root-cause:" + ( ( null != cause ) ? cause . getMessage ( ) : "null" ) ) ; } } public static void logSourceLine ( PrintWriter pw , SourceLocator locator ) { if ( null == locator ) return ; if ( null == pw ) pw = new PrintWriter ( System . err , true ) ; String url = locator . getSystemId ( ) ; if ( null == url ) { pw . println ( "line: (No systemId; cannot read file)" ) ; pw . println ( ) ; return ; } try { int line = locator . getLineNumber ( ) ; int column = locator . getColumnNumber ( ) ; pw . println ( "line: " + getSourceLine ( url , line ) ) ; StringBuffer buf = new StringBuffer ( "line: " ) ; for ( int i = 1 ; i < column ; i ++ ) { buf . append ( ' ' ) ; } buf . append ( '^' ) ; pw . println ( buf . toString ( ) ) ; } catch ( Exception e ) { pw . println ( "line: logSourceLine unavailable due to: " + e . getMessage ( ) ) ; pw . println ( ) ; } } protected static String getSourceLine ( String sourceUrl , int lineNum ) throws Exception { URL url = null ; try { url = new URL ( sourceUrl ) ; } catch ( java . net . MalformedURLException mue ) { int indexOfColon = sourceUrl . indexOf ( ':' ) ; int indexOfSlash = sourceUrl . indexOf ( '/' ) ; if ( ( indexOfColon != - 1 ) && ( indexOfSlash != - 1 ) && ( indexOfColon < indexOfSlash ) ) { throw mue ; } else { url = new URL ( SystemIDResolver . getAbsoluteURI ( sourceUrl ) ) ; } } String line = null ; InputStream is = null ; BufferedReader br = null ; try { URLConnection uc = url . openConnection ( ) ; is = uc . getInputStream ( ) ; br = new BufferedReader ( new InputStreamReader ( is ) ) ; for ( int i = 1 ; i <= lineNum ; i ++ ) { line = br . readLine ( ) ; } } finally { br . close ( ) ; is . close ( ) ; } return line ; } public void setThrowOnWarning ( boolean b ) { throwOnWarning = b ; } public boolean getThrowOnWarning ( ) { return throwOnWarning ; } protected boolean throwOnWarning = false ; public void setThrowOnError ( boolean b ) { throwOnError = b ; } public boolean getThrowOnError ( ) { return throwOnError ; } protected boolean throwOnError = true ; public void setThrowOnFatalError ( boolean b ) { throwOnFatalError = b ; } public boolean getThrowOnFatalError ( ) { return throwOnFatalError ; } protected boolean throwOnFatalError = true ; } 	1	['17', '1', '0', '4', '55', '50', '0', '4', '16', '0.65625', '569', '1', '0', '0', '0.196078431', '0', '0', '32.23529412', '14', '1.8824', '2']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . res . XPATHErrorResources ; public class FunctionMultiArgs extends Function3Args { Expression [ ] m_args ; public Expression [ ] getArgs ( ) { return m_args ; } public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { if ( argNum < 3 ) super . setArg ( arg , argNum ) ; else { if ( null == m_args ) { m_args = new Expression [ 1 ] ; m_args [ 0 ] = arg ; } else { Expression [ ] args = new Expression [ m_args . length + 1 ] ; System . arraycopy ( m_args , 0 , args , 0 , m_args . length ) ; args [ m_args . length ] = arg ; m_args = args ; } arg . exprSetParent ( this ) ; } } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_args ) { for ( int i = 0 ; i < m_args . length ; i ++ ) { m_args [ i ] . fixupVariables ( vars , globalsSize ) ; } } } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { "Programmer's assertion:  the method FunctionMultiArgs.reportWrongNumberArgs() should never be called." } ) ; throw new RuntimeException ( fMsg ) ; } public boolean canTraverseOutsideSubtree ( ) { if ( super . canTraverseOutsideSubtree ( ) ) return true ; else { int n = m_args . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( m_args [ i ] . canTraverseOutsideSubtree ( ) ) return true ; } return false ; } } class ArgMultiOwner implements ExpressionOwner { int m_argIndex ; ArgMultiOwner ( int index ) { m_argIndex = index ; } public Expression getExpression ( ) { return m_args [ m_argIndex ] ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FunctionMultiArgs . this ) ; m_args [ m_argIndex ] = exp ; } } public void callArgVisitors ( XPathVisitor visitor ) { super . callArgVisitors ( visitor ) ; if ( null != m_args ) { int n = m_args . length ; for ( int i = 0 ; i < n ; i ++ ) { m_args [ i ] . callVisitors ( new ArgMultiOwner ( i ) , visitor ) ; } } } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; FunctionMultiArgs fma = ( FunctionMultiArgs ) expr ; if ( null != m_args ) { int n = m_args . length ; if ( ( null == fma ) || ( fma . m_args . length != n ) ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m_args [ i ] . deepEquals ( fma . m_args [ i ] ) ) return false ; } } else if ( null != fma . m_args ) { return false ; } return true ; } } 	1	['9', '6', '1', '9', '24', '6', '2', '8', '8', '0.375', '218', '0', '1', '0.888888889', '0.355555556', '5', '22', '23.11111111', '7', '2.3333', '1']
package org . apache . xml . dtm ; public interface Axis { public static final int ANCESTOR = 0 ; public static final int ANCESTORORSELF = 1 ; public static final int ATTRIBUTE = 2 ; public static final int CHILD = 3 ; public static final int DESCENDANT = 4 ; public static final int DESCENDANTORSELF = 5 ; public static final int FOLLOWING = 6 ; public static final int FOLLOWINGSIBLING = 7 ; public static final int NAMESPACEDECLS = 8 ; public static final int NAMESPACE = 9 ; public static final int PARENT = 10 ; public static final int PRECEDING = 11 ; public static final int PRECEDINGSIBLING = 12 ; public static final int SELF = 13 ; public static final int ALLFROMNODE = 14 ; public static final int PRECEDINGANDANCESTOR = 15 ; public static final int ALL = 16 ; public static final int DESCENDANTSFROMROOT = 17 ; public static final int DESCENDANTSORSELFFROMROOT = 18 ; public static final int ROOT = 19 ; public static final int FILTEREDLIST = 20 ; public static final String [ ] names = { "ancestor" , "ancestor-or-self" , "attribute" , "child" , "descendant" , "descendant-or-self" , "following" , "following-sibling" , "namespace-decls" , "namespace" , "parent" , "preceding" , "preceding-sibling" , "self" , "all-from-node" , "preceding-and-ancestor" , "all" , "descendants-from-root" , "descendants-or-self-from-root" , "root" , "filtered-list" } ; } 	1	['1', '1', '0', '4', '1', '0', '4', '0', '0', '2', '111', '0', '0', '0', '0', '0', '0', '88', '0', '0', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_ru extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Функция current() недопустима в шаблоне для сравнения!" } , { ER_CURRENT_TAKES_NO_ARGS , "У функции current() нет аргументов!" } , { ER_DOCUMENT_REPLACED , "Реализация функции document() заменена на org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "В контексте отсутствует документ-владелец!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "У функции local-name() слишком много аргументов." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "У функции namespace-uri() слишком много аргументов." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "У функции normalize-space() слишком много аргументов." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "У функции number() слишком много аргументов." } , { ER_NAME_HAS_TOO_MANY_ARGS , "У функции name() слишком много аргументов." } , { ER_STRING_HAS_TOO_MANY_ARGS , "У функции string() слишком много аргументов." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "У функции string-length() слишком много аргументов." } , { ER_TRANSLATE_TAKES_3_ARGS , "У функции translate() должно быть три аргумента!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "У функции unparsed-entity-uri должен быть один аргумент!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "Ось пространства имен еще не реализована!" } , { ER_UNKNOWN_AXIS , "Неизвестная ось: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "Неизвестная операция сравнения!" } , { ER_INCORRECT_ARG_LENGTH , "Недопустимая длина аргументов при сравнении узла processing-instruction()!" } , { ER_CANT_CONVERT_TO_NUMBER , "Невозможно преобразовать {0} в число" } , { ER_CANT_CONVERT_TO_NODELIST , "Невозможно преобразовать {0} в NodeList!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Невозможно преобразовать {0} в NodeSetDTM!" } , { ER_CANT_CONVERT_TO_TYPE , "Невозможно преобразовать {0} в тип#{1}" } , { ER_EXPECTED_MATCH_PATTERN , "В getMatchScore ожидался шаблон для сравнения!" } , { ER_COULDNOT_GET_VAR_NAMED , "Не удалось получить переменную {0}" } , { ER_UNKNOWN_OPCODE , "Ошибка! Неизвестный код операции: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Дополнительные недопустимые маркеры: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Литерал не заключен в кавычки... Ожидались двойные кавычки!" } , { ER_EXPECTED_SINGLE_QUOTE , "Литерал не заключен в кавычки... Ожидались одиночные кавычки!" } , { ER_EMPTY_EXPRESSION , "Пустое выражение!" } , { ER_EXPECTED_BUT_FOUND , "Ожидалось {0}, обнаружено: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Недопустимое программное предположение! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "В 19990709 XPath аргумент boolean(...) больше не является необязательным." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Обнаружена запятая ',' но перед ней отсутствует аргумент!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Обнаружена запятая ',' но после нее отсутствует аргумент!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "Синтаксис '..[предикат]' или '.[предикат]' недопустим. Используйте 'self::node()[предикат]'." } , { ER_ILLEGAL_AXIS_NAME , "Недопустимое имя оси: {0}" } , { ER_UNKNOWN_NODETYPE , "Неизвестный тип узла: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "В шаблоне литерал ({0}) должен быть заключен в кавычки!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} невозможно отформатировать как число!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Невозможно создать XML TransformerFactory Liaison: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Ошибка! Не найдено выражение выбора xpath (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "Ошибка! После OP_LOCATIONPATH отсутствует ENDOP" } , { ER_ERROR_OCCURED , "Ошибка!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference для переменной задан вне контекста или без определения! Имя = {0}" } , { ER_AXES_NOT_ALLOWED , "В шаблонах соответствия допустимы только оси child:: и attribute::! Недопустимые оси = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "В key() указано неверное число аргументов." } , { ER_COUNT_TAKES_1_ARG , "У функции count должен быть один аргумент!" } , { ER_COULDNOT_FIND_FUNCTION , "Функция не найдена: {0}" } , { ER_UNSUPPORTED_ENCODING , "Неподдерживаемая кодировка: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Ошибка в DTM в getNextSibling... Попытка восстановления" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Программная ошибка: запись в EmptyNodeList невозможна." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory не поддерживается XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Префикс должен обеспечивать преобразование в пространство имен: {0}" } , { ER_PARSE_NOT_SUPPORTED , "Анализ с (InputSource источник) не поддерживается в XPathContext! Не удалось открыть {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API characters(char ch[]... не обработан DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... не обработан DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison не может обрабатывать узлы типа {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper не может обрабатывать узлы типа {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Ошибка DOM2Helper.parse: SystemID - {0} строка - {1}" } , { ER_XERCES_PARSE_ERROR , "Ошибка DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Обнаружено недопустимое значение UTF-16: {0} ?" } , { ER_OIERROR , "Ошибка ввода-вывода" } , { ER_CANNOT_CREATE_URL , "Не удалось создать URL для {0}" } , { ER_XPATH_READOBJECT , "В XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "Маркер функции не найден." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Работа с типом XPath невозможна: {0}" } , { ER_NODESET_NOT_MUTABLE , "Данный набор NodeSet не является двусторонним" } , { ER_NODESETDTM_NOT_MUTABLE , "Данный набор NodeSetDTM не является двусторонним" } , { ER_VAR_NOT_RESOLVABLE , "Невозможно преобразовать переменную: {0}" } , { ER_NULL_ERROR_HANDLER , "Пустой обработчик ошибки" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Программное предположение: неизвестный код операции {0}" } , { ER_ZERO_OR_ONE , "0 или 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() не поддерживается XRTreeFragSelectWrapper" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() не поддерживается XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() не поддерживается XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Переменная {0} не найдена" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "Аргумент XStringForChars не может быть строкой" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "Аргумент FastStringBuffer не может быть пустым" } , { ER_TWO_OR_THREE , "2 или 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Обращение к переменной до ее связывания!" } , { ER_FSB_CANNOT_TAKE_STRING , "Аргумент XStringForFSB не может быть строкой!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Ошибка! Корневому каталогу walker присвоено пустое значение!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Данный NodeSetDTM не может работать с предыдущим узлом!" } , { ER_NODESET_CANNOT_ITERATE , "Данный NodeSet не может работать с предыдущим узлом!" } , { ER_NODESETDTM_CANNOT_INDEX , "Данный NodeSetDTM не может выполнять функции индексирования и подсчета!" } , { ER_NODESET_CANNOT_INDEX , "Данный NodeSet не может выполнять функции индексирования и подсчета!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Нельзя вызывать setShouldCacheNodes после вызова nextNode!" } , { ER_ONLY_ALLOWS , "Максимальное число аргументов {0} равно {1}" } , { ER_UNKNOWN_STEP , "Программное предположение в getNextStepPos: неизвестный тип stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Ожидался относительный путь, после которого должен был следовать маркер '/' или '//'." } , { ER_EXPECTED_LOC_PATH , "Ожидался путь, однако был обнаружен следующий маркер:  {0}" } , { ER_EXPECTED_LOC_STEP , "Ожидался шаг расположения, после которого должен был следовать маркер '/' или '//'." } , { ER_EXPECTED_NODE_TEST , "Ожидалось сравнение узла, соответствующее NCName:* или QName. " } , { ER_EXPECTED_STEP_PATTERN , "Ожидался шаблон шага, однако был обнаружен '/'." } , { ER_EXPECTED_REL_PATH_PATTERN , "Ожидался шаблон относительного пути." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Невозможно преобразовать {0} в булевский тип." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Невозможно преобразовать {0} в отдельный узел. Данная процедура получения относится к типам ANY_UNORDERED_NODE_TYPE и FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Невозможно получить длину моментальной копии для типа: {0}. Данная процедура получения относится к типам UNORDERED_NODE_SNAPSHOT_TYPE и ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Невозможно выполнить цикл для не типа, не допускающего итерацию: {0}" } , { ER_DOC_MUTATED , "С момента получения результата документ был изменен. Итератор недопустим." } , { ER_INVALID_XPATH_TYPE , "Недопустимый тип аргумента XPath: {0}" } , { ER_EMPTY_XPATH_RESULT , "Пустой объект результата XPath" } , { ER_INCOMPATIBLE_TYPES , "Возвращенный тип {0} невозможно принудительно преобразовать в указанный тип: {1}" } , { ER_NULL_RESOLVER , "Невозможно преобразовать префикс с помощью пустого преобразователя." } , { ER_CANT_CONVERT_TO_STRING , "Невозможно преобразовать {0} в строку." } , { ER_NON_SNAPSHOT_TYPE , "Невозможно вызвать snapshotItem для типа: {0}. Данная процедура относится к типам UNORDERED_NODE_SNAPSHOT_TYPE и ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Узел контекста не относится к документу, связанному с данным XPathEvaluator." } , { ER_WRONG_NODETYPE , "Тип узла контекста не поддерживается." } , { ER_XPATH_ERROR , "Неизвестная ошибка в XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "Локальное имя в функции format-number еще не обработано!" } , { WG_PROPERTY_NOT_SUPPORTED , "Свойство XSL не поддерживается: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Не выполняйте никаких операций с пространством имен {0} в свойстве: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException при попытке обращения к системному свойству XSL: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Старый синтаксис: quo(...) больше не определен в XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "Для реализации nodeTest в XPath необходим производный объект!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "Маркер функции не найден." } , { WG_COULDNOT_FIND_FUNCTION , "Функция не найдена: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Невозможно создать URL из: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "Опция -E не поддерживается анализатором DTM" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference для переменной задан вне контекста или без определения! Имя = {0}" } , { WG_UNSUPPORTED_ENCODING , "Неподдерживаемая кодировка: {0}" } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "Параметр createMessage лежит вне допустимого диапазона" } , { "FORMAT_FAILED" , "Исключительная ситуация при вызове messageFormat" } , { "version" , ">>>>>>> Версия Xalan" } , { "version2" , "<<<<<<<" } , { "yes" , "да" } , { "line" , "Номер строки" } , { "column" , "Номер столбца" } , { "xsldone" , "XSLProcessor: выполнено" } , { "xpath_option" , "Поддерживаемые опции:" } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select выражение xpath]" } , { "optionMatch" , "   [-match шаблон сравнения (для диагностики)]" } , { "optionAnyExpr" , "Или просто укажите выражение xpath для создания диагностического дампа" } , { "noParsermsg1" , "В процессе XSL обнаружены ошибки." } , { "noParsermsg2" , "** Анализатор не найден **" } , { "noParsermsg3" , "Проверьте значение classpath." } , { "noParsermsg4" , "Если у вас нет анализатора XML Parser for Java фирмы IBM, вы можете загрузить его с сайта" } , { "noParsermsg5" , "IBM AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "Ошибка" ; public static final String ERROR_HEADER = "Ошибка:" ; public static final String WARNING_HEADER = "Предупреждение: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "More than one stylesheet defined in the same file." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "Template ''{0}'' already defined in this stylesheet." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "Template ''{0}'' not defined in this stylesheet." } , { ErrorMsg . VARIABLE_REDEF_ERR , "Variable ''{0}'' is multiply defined in the same scope." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "Variable or parameter ''{0}'' is undefined." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "Cannot find class ''{0}''." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "Cannot find external method ''{0}'' (must be public)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Cannot convert argument/return type in call to method ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "File or URI ''{0}'' not found." } , { ErrorMsg . INVALID_URI_ERR , "Invalid URI ''{0}''." } , { ErrorMsg . FILE_ACCESS_ERR , "Cannot open file or URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "<xsl:stylesheet> or <xsl:transform> element expected." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Namespace prefix ''{0}'' is undeclared." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Unable to resolve call to function ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "Argument to ''{0}'' must be a literal string." } , { ErrorMsg . XPATH_PARSER_ERR , "Error parsing XPath expression ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Required attribute ''{0}'' is missing." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Illegal character ''{0}'' in XPath expression." } , { ErrorMsg . ILLEGAL_PI_ERR , "Illegal name ''{0}'' for processing instruction." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "Attribute ''{0}'' outside of element." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Illegal attribute ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Circular import/include. Stylesheet ''{0}'' already loaded." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Result-tree fragments cannot be sorted (<xsl:sort> elements are " + "ignored). You must sort the nodes when creating the result tree." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Decimal formatting ''{0}'' is already defined." } , { ErrorMsg . XSL_VERSION_ERR , "XSL version ''{0}'' is not supported by XSLTC." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Circular variable/parameter reference in ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Unknown operator for binary expression." } , { ErrorMsg . ILLEGAL_ARG_ERR , "Illegal argument(s) for function call." } , { ErrorMsg . DOCUMENT_ARG_ERR , "Second argument to document() function must be a node-set." } , { ErrorMsg . MISSING_WHEN_ERR , "At least one <xsl:when> element required in <xsl:choose>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "Only one <xsl:otherwise> element allowed in <xsl:choose>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> can only be used within <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> can only be used within <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "Only <xsl:when> and <xsl:otherwise> elements allowed in <xsl:choose>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set> is missing the 'name' attribute." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Illegal child element." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "You cannot call an element ''{0}''" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "You cannot call an attribute ''{0}''" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Text data outside of top-level <xsl:stylesheet> element." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "JAXP parser not configured correctly" } , { ErrorMsg . INTERNAL_ERR , "Unrecoverable XSLTC-internal error: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Unsupported XSL element ''{0}''." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "Unrecognised XSLTC extension ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "The input document is not a stylesheet (the XSL namespace is not " + "declared in the root element)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Could not find stylesheet target ''{0}''." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Not implemented: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "The input document does not contain an XSL stylesheet." } , { ErrorMsg . ELEMENT_PARSE_ERR , "Could not parse element ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "The use attribute of <key> must be node, node-set, string or number." } , { ErrorMsg . OUTPUT_VERSION_ERR , "Output XML document version should be 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Unknown operator for relational expression" } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Attempting to use non-existing attribute set ''{0}''." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Cannot parse attribute value template ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Unknown data-type in signature for class ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "Cannot convert data-type ''{0}'' to ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "This Templates does not contain a valid translet class definition." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "This Templates does not contain a class with the name ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Could not load the translet class ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Translet class loaded, but unable to create translet instance." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "Attempting to set ErrorListener for ''{0}'' to null" } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "Only StreamSource, SAXSource and DOMSource are supported by XSLTC" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "Source object passed to ''{0}'' has no contents." } , { ErrorMsg . JAXP_COMPILE_ERR , "Could not compile stylesheet" } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory does not recognise attribute ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() must be called prior to startDocument()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "The Transformer has no encapsulated translet object." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "No defined output handler for transformation result." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "Result object passed to ''{0}'' is invalid." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Attempting to access invalid Transformer property ''{0}''." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Could not create SAX2DOM adapter: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() called without systemId being set." } , { ErrorMsg . ER_RESULT_NULL , "Result should not be null" } , { ErrorMsg . JAXP_INVALID_SET_PARAM_VALUE , "The value of param {0} must be a valid Java Object" } , { ErrorMsg . COMPILE_STDIN_ERR , "The -i option must be used with the -o option." } , { ErrorMsg . COMPILE_USAGE_STR , "SYNOPSIS\n" + "   java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]\n" + "      [-d <directory>] [-j <jarfile>] [-p <package>]\n" + "      [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }\n\n" + "OPTIONS\n" + "   -o <output>    assigns the name <output> to the generated\n" + "                  translet.  By default the translet name is\n" + "                  derived from the <stylesheet> name.  This option\n" + "                  is ignored if compiling multiple stylesheets.\n" + "   -d <directory> specifies a destination directory for translet\n" + "   -j <jarfile>   packages translet classes into a jar file of the\n" + "                  name specified as <jarfile>\n" + "   -p <package>   specifies a package name prefix for all generated\n" + "                  translet classes.\n" + "   -n             enables template inlining (default behavior better\n" + "                  on average).\n" + "   -x             turns on additional debugging message output\n" + "   -s             disables calling System.exit\n" + "   -u             interprets <stylesheet> arguments as URLs\n" + "   -i             forces compiler to read stylesheet from stdin\n" + "   -v             prints the version of the compiler\n" + "   -h             prints this usage statement\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SYNOPSIS \n" + "   java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]\n" + "      [-x] [-s] [-n <iterations>] {-u <document_url> | <document>}\n" + "      <class> [<param1>=<value1> ...]\n\n" + "   uses the translet <class> to transform an XML document \n" + "   specified as <document>. The translet <class> is either in\n" + "   the user's CLASSPATH or in the optionally specified <jarfile>.\n" + "OPTIONS\n" + "   -j <jarfile>    specifies a jarfile from which to load translet\n" + "   -x              turns on additional debugging message output\n" + "   -s              disables calling System.exit\n" + "   -n <iterations> runs the transformation <iterations> times and\n" + "                   displays profiling information\n" + "   -u <document_url> specifies XML input document as a URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> can only be used within <xsl:for-each> or <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "Output encoding ''{0}'' is not supported on this JVM." } , { ErrorMsg . SYNTAX_ERR , "Syntax error in ''{0}''." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "Cannot find external constructor ''{0}''." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "The first argument to the non-static Java function ''{0}'' is not a " + "valid object reference." } , { ErrorMsg . TYPE_CHECK_ERR , "Error checking type of the expression ''{0}''." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Error checking type of an expression at an unknown location." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "The command-line option ''{0}'' is not valid." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "The command-line option ''{0}'' is missing a required argument." } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "WARNING:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "WARNING:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "FATAL ERROR:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "FATAL ERROR:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "ERROR:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "ERROR:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Transform using translet ''{0}'' " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Transform using translet ''{0}'' from jar file ''{1}''" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "Could not create an instance of the TransformerFactory class ''{0}''." } , { ErrorMsg . TRANSLET_NAME_JAVA_CONFLICT , "The name ''{0}'' could not be used as the name of the translet " + "class because it contains characters that are not permitted in the " + "name of Java class.  The name ''{1}'' was used instead." } , { ErrorMsg . COMPILER_ERROR_KEY , "Compiler errors:" } , { ErrorMsg . COMPILER_WARNING_KEY , "Compiler warnings:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Translet errors:" } , { ErrorMsg . INVALID_QNAME_ERR , "An attribute whose value must be a QName or whitespace-separated list of QNames had the value ''{0}''" } , { ErrorMsg . INVALID_NCNAME_ERR , "An attribute whose value must be an NCName had the value ''{0}''" } , { ErrorMsg . INVALID_METHOD_IN_OUTPUT , "The method attribute of an <xsl:output> element had the value ''{0}''.  The value must be one of 'xml', 'html', 'text', or qname-but-not-ncname" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '1', '1', '4', '1', '1', '0', '2', '0.5', '1326', '1', '0', '0.974358974', '1', '0', '0', '440.6666667', '1', '0.3333', '3']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class KeyCall extends FunctionCall { private Expression _name ; private Expression _value ; private Type _valueType ; private QName _resolvedQName = null ; public KeyCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; switch ( argumentCount ( ) ) { case 1 : _name = null ; _value = argument ( 0 ) ; break ; case 2 : _name = argument ( 0 ) ; _value = argument ( 1 ) ; break ; default : _name = _value = null ; break ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type returnType = super . typeCheck ( stable ) ; if ( _name != null ) { final Type nameType = _name . typeCheck ( stable ) ; if ( _name instanceof LiteralExpr ) { final LiteralExpr literal = ( LiteralExpr ) _name ; _resolvedQName = getParser ( ) . getQNameIgnoreDefaultNs ( literal . getValue ( ) ) ; } else if ( nameType instanceof StringType == false ) { _name = new CastExpr ( _name , Type . String ) ; } } _valueType = _value . typeCheck ( stable ) ; if ( _valueType != Type . NodeSet && _valueType != Type . String ) { _value = new CastExpr ( _value , Type . String ) ; } return returnType ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNodeHandle = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeHandle" , "(I)" + NODE_SIG ) ; final int dupInit = cpg . addMethodref ( DUP_FILTERED_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( DUP_FILTERED_ITERATOR ) ) ) ; il . append ( DUP ) ; translateCall ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( dupInit ) ) ; } private void translateCall ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNodeValue = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE , "(I)" + STRING_SIG ) ; final int getKeyIndex = cpg . addMethodref ( TRANSLET_CLASS , "getKeyIndex" , "(Ljava/lang/String;)" + KEY_INDEX_SIG ) ; final int lookupId = cpg . addMethodref ( KEY_INDEX_CLASS , "lookupId" , "(Ljava/lang/Object;)V" ) ; final int lookupKey = cpg . addMethodref ( KEY_INDEX_CLASS , "lookupKey" , "(Ljava/lang/Object;)V" ) ; final int merge = cpg . addMethodref ( KEY_INDEX_CLASS , "merge" , "(" + KEY_INDEX_SIG + ")V" ) ; final int indexConstructor = cpg . addMethodref ( TRANSLET_CLASS , "createKeyIndex" , "()" + KEY_INDEX_SIG ) ; final int keyDom = cpg . addMethodref ( XSLT_PACKAGE + ".dom.KeyIndex" , "setDom" , "(" + DOM_INTF_SIG + ")V" ) ; final LocalVariableGen returnIndex = methodGen . addLocalVariable ( "returnIndex" , Util . getJCRefType ( KEY_INDEX_SIG ) , il . getEnd ( ) , null ) ; final LocalVariableGen searchIndex = methodGen . addLocalVariable ( "searchIndex" , Util . getJCRefType ( KEY_INDEX_SIG ) , il . getEnd ( ) , null ) ; if ( _valueType == Type . NodeSet ) { il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; _value . translate ( classGen , methodGen ) ; _value . startIterator ( classGen , methodGen ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEVIRTUAL ( indexConstructor ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEVIRTUAL ( keyDom ) ) ; il . append ( new ASTORE ( returnIndex . getIndex ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( _name == null ) { il . append ( new PUSH ( cpg , "##id" ) ) ; } else if ( _resolvedQName != null ) { il . append ( new PUSH ( cpg , _resolvedQName . toString ( ) ) ) ; } else { _name . translate ( classGen , methodGen ) ; } il . append ( new INVOKEVIRTUAL ( getKeyIndex ) ) ; il . append ( new ASTORE ( searchIndex . getIndex ( ) ) ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; il . append ( new ALOAD ( returnIndex . getIndex ( ) ) ) ; il . append ( new ALOAD ( searchIndex . getIndex ( ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( getNodeValue , 2 ) ) ; if ( _name == null ) { il . append ( new INVOKEVIRTUAL ( lookupId ) ) ; } else { il . append ( new INVOKEVIRTUAL ( lookupKey ) ) ; } il . append ( new INVOKEVIRTUAL ( merge ) ) ; nextNode . setTarget ( il . append ( methodGen . loadIterator ( ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFGT ( loop ) ) ; il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new ALOAD ( returnIndex . getIndex ( ) ) ) ; } else { il . append ( classGen . loadTranslet ( ) ) ; if ( _name == null ) { il . append ( new PUSH ( cpg , "##id" ) ) ; } else if ( _resolvedQName != null ) { il . append ( new PUSH ( cpg , _resolvedQName . toString ( ) ) ) ; } else { _name . translate ( classGen , methodGen ) ; } il . append ( new INVOKEVIRTUAL ( getKeyIndex ) ) ; il . append ( DUP ) ; _value . translate ( classGen , methodGen ) ; if ( _name == null ) { il . append ( new INVOKEVIRTUAL ( lookupId ) ) ; } else { il . append ( new INVOKEVIRTUAL ( lookupKey ) ) ; } } } } 	1	['4', '4', '0', '32', '45', '0', '0', '32', '3', '0.083333333', '524', '1', '4', '0.96969697', '0.458333333', '3', '7', '129', '8', '2.5', '1']
package org . apache . xml . dtm . ref . sax2dtm ; import javax . xml . transform . Source ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . IntVector ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . XMLStringFactory ; import org . xml . sax . SAXException ; public class SAX2RTFDTM extends SAX2DTM { private static final boolean DEBUG = false ; private int m_currentDocumentNode = NULL ; IntStack mark_size = new IntStack ( ) ; IntStack mark_data_size = new IntStack ( ) ; IntStack mark_char_size = new IntStack ( ) ; IntStack mark_doq_size = new IntStack ( ) ; IntStack mark_nsdeclset_size = new IntStack ( ) ; IntStack mark_nsdeclelem_size = new IntStack ( ) ; int m_emptyNodeCount ; int m_emptyNSDeclSetCount ; int m_emptyNSDeclSetElemsCount ; int m_emptyDataCount ; int m_emptyCharsCount ; int m_emptyDataQNCount ; public SAX2RTFDTM ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing ) ; m_useSourceLocationProperty = false ; m_sourceSystemId = ( m_useSourceLocationProperty ) ? new StringVector ( ) : null ; m_sourceLine = ( m_useSourceLocationProperty ) ? new IntVector ( ) : null ; m_sourceColumn = ( m_useSourceLocationProperty ) ? new IntVector ( ) : null ; m_emptyNodeCount = m_size ; m_emptyNSDeclSetCount = ( m_namespaceDeclSets == null ) ? 0 : m_namespaceDeclSets . size ( ) ; m_emptyNSDeclSetElemsCount = ( m_namespaceDeclSetElements == null ) ? 0 : m_namespaceDeclSetElements . size ( ) ; m_emptyDataCount = m_data . size ( ) ; m_emptyCharsCount = m_chars . size ( ) ; m_emptyDataQNCount = m_dataOrQName . size ( ) ; } public int getDocument ( ) { return makeNodeHandle ( m_currentDocumentNode ) ; } public int getDocumentRoot ( int nodeHandle ) { for ( int id = makeNodeIdentity ( nodeHandle ) ; id != NULL ; id = _parent ( id ) ) { if ( _type ( id ) == DTM . DOCUMENT_NODE ) { return makeNodeHandle ( id ) ; } } return DTM . NULL ; } protected int _documentRoot ( int nodeIdentifier ) { if ( nodeIdentifier == NULL ) return NULL ; for ( int parent = _parent ( nodeIdentifier ) ; parent != NULL ; nodeIdentifier = parent , parent = _parent ( nodeIdentifier ) ) ; return nodeIdentifier ; } public void startDocument ( ) throws SAXException { m_endDocumentOccured = false ; m_prefixMappings = new java . util . Vector ( ) ; m_contextIndexes = new IntStack ( ) ; m_parents = new IntStack ( ) ; m_currentDocumentNode = m_size ; super . startDocument ( ) ; } public void endDocument ( ) throws SAXException { charactersFlush ( ) ; m_nextsib . setElementAt ( NULL , m_currentDocumentNode ) ; if ( m_firstch . elementAt ( m_currentDocumentNode ) == NOTPROCESSED ) m_firstch . setElementAt ( NULL , m_currentDocumentNode ) ; if ( DTM . NULL != m_previous ) m_nextsib . setElementAt ( DTM . NULL , m_previous ) ; m_parents = null ; m_prefixMappings = null ; m_contextIndexes = null ; m_currentDocumentNode = NULL ; m_endDocumentOccured = true ; } public void pushRewindMark ( ) { if ( m_indexing || m_elemIndexes != null ) throw new java . lang . NullPointerException ( "Coding error; Don't try to mark/rewind an indexed DTM" ) ; mark_size . push ( m_size ) ; mark_nsdeclset_size . push ( ( m_namespaceDeclSets == null ) ? 0 : m_namespaceDeclSets . size ( ) ) ; mark_nsdeclelem_size . push ( ( m_namespaceDeclSetElements == null ) ? 0 : m_namespaceDeclSetElements . size ( ) ) ; mark_data_size . push ( m_data . size ( ) ) ; mark_char_size . push ( m_chars . size ( ) ) ; mark_doq_size . push ( m_dataOrQName . size ( ) ) ; } public boolean popRewindMark ( ) { boolean top = mark_size . empty ( ) ; m_size = top ? m_emptyNodeCount : mark_size . pop ( ) ; m_exptype . setSize ( m_size ) ; m_firstch . setSize ( m_size ) ; m_nextsib . setSize ( m_size ) ; m_prevsib . setSize ( m_size ) ; m_parent . setSize ( m_size ) ; m_elemIndexes = null ; int ds = top ? m_emptyNSDeclSetCount : mark_nsdeclset_size . pop ( ) ; if ( m_namespaceDeclSets != null ) { m_namespaceDeclSets . setSize ( ds ) ; } int ds1 = top ? m_emptyNSDeclSetElemsCount : mark_nsdeclelem_size . pop ( ) ; if ( m_namespaceDeclSetElements != null ) { m_namespaceDeclSetElements . setSize ( ds1 ) ; } m_data . setSize ( top ? m_emptyDataCount : mark_data_size . pop ( ) ) ; m_chars . setLength ( top ? m_emptyCharsCount : mark_char_size . pop ( ) ) ; m_dataOrQName . setSize ( top ? m_emptyDataQNCount : mark_doq_size . pop ( ) ) ; return m_size == 0 ; } public boolean isTreeIncomplete ( ) { return ! m_endDocumentOccured ; } } 	1	['9', '5', '0', '11', '32', '8', '2', '9', '8', '0.821428571', '443', '0.142857143', '6', '0.954285714', '0.26984127', '2', '20', '46.66666667', '10', '2.8889', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_cs extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "Více než jedna předloha stylu je definována ve stejném souboru." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "Šablona ''{0}'' je již v této předloze stylu definována." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "Šablona ''{0}'' není v této předloze stylu definována." } , { ErrorMsg . VARIABLE_REDEF_ERR , "Proměnná ''{0}'' je několikanásobně definována ve stejném oboru." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "Proměnná nebo parametr ''{0}'' nejsou definovány." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "Nelze najít třídu ''{0}''." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "Nelze najít externí metodu ''{0}'' (musí být veřejná)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Nelze převést argument/návratový typ ve volání metody ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "Soubor nebo URI ''{0}'' nebyl nalezen." } , { ErrorMsg . INVALID_URI_ERR , "Neplatné URI ''{0}''." } , { ErrorMsg . FILE_ACCESS_ERR , "Nelze otevřít soubor nebo URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "Byl očekáván prvek <xsl:stylesheet> nebo <xsl:transform>." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Předpona oboru názvů ''{0}'' není deklarována." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Nelze vyřešit volání funkce ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "Argument pro ''{0}'' musí být řetězcem literálu." } , { ErrorMsg . XPATH_PARSER_ERR , "Chyba při analýze výrazu XPath ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Požadovaný atribut ''{0}'' chybí." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Neplatný znak ''{0}'' ve výrazu XPath." } , { ErrorMsg . ILLEGAL_PI_ERR , "Neplatný název ''{0}'' pro zpracování instrukce." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "Atribut ''{0}'' je vně prvku." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Neplatný atribut ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Cyklický import/zahrnutí. Předloha stylu ''{0}'' je již zavedena." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Fragmenty stromu výsledků nemohou být řazeny (prvky <xsl:sort> se ignorují). Při vytváření stromu výsledků musíte seřadit uzly." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Desetinné formátování ''{0}'' je již definováno." } , { ErrorMsg . XSL_VERSION_ERR , "Verze XSL ''{0}'' není produktem XSLTC podporována." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Cyklický odkaz na proměnnou/parametr v ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Neznámý operátor pro binární výraz." } , { ErrorMsg . ILLEGAL_ARG_ERR , "Neplatný argument pro volání funkce." } , { ErrorMsg . DOCUMENT_ARG_ERR , "Druhý argument pro funkci document() musí být node-set." } , { ErrorMsg . MISSING_WHEN_ERR , "Alespoň jeden prvek <xsl:when> se vyžaduje v <xsl:choose>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "Jen jeden prvek <xsl:otherwise> je povolen v <xsl:choose>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "Prvek <xsl:otherwise> může být použit jen v <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "Prvek <xsl:when> může být použit jen v <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "Pouze prvky <xsl:when> a <xsl:otherwise> jsou povoleny v <xsl:choose>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "V prvku <xsl:attribute-set> chybí atribut 'name'." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Neplatný prvek potomka." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "Nelze volat prvek ''{0}''" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "Nelze volat atribut ''{0}''" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Textová data jsou vně prvku nejvyšší úrovně <xsl:stylesheet>." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "Analyzátor JAXP je nesprávně konfigurován." } , { ErrorMsg . INTERNAL_ERR , "Neopravitelná chyba XSLTC-internal: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Nepodporovaný prvek XSL ''{0}''." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "Nerozpoznaná přípona XSLTC ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "Vstupní dokument není předloha stylu (obor názvů XSL není deklarován v kořenovém elementu)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Nelze najít cílovou předlohu se stylem ''{0}''." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Neimplementováno: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "Vstupní dokument neobsahuje předlohu stylu XSL." } , { ErrorMsg . ELEMENT_PARSE_ERR , "Nelze analyzovat prvek ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "Atribut use proměnné <key> musí být typu node, node-set, string nebo number." } , { ErrorMsg . OUTPUT_VERSION_ERR , "Výstupní verze dokumentu XML by měla být 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Neznámý operátor pro relační výraz" } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Pokus použít neexistující sadu atributů ''{0}''." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Nelze analyzovat šablonu hodnoty atributu ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Neznámý datový typ proměnné signature pro třídu ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "Nelze převést datový typ ''{0}'' na ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Tato šablona neobsahuje platnou definici třídy translet." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Tato šablona neobsahuje třídu se jménem ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Nelze zavést třídu translet ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Třída translet byla zavedena, avšak nelze vytvořit instanci translet." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "Pokus nastavit objekt ErrorListener pro ''{0}'' na hodnotu null" } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "Pouze proměnné StreamSource, SAXSource a DOMSource jsou podporovány produktem XSLTC" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "Zdrojový objekt předaný ''{0}'' nemá žádný obsah." } , { ErrorMsg . JAXP_COMPILE_ERR , "Nelze kompilovat předlohu se stylem" } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "Třída TransformerFactory nerozpoznala atribut ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "Metoda setResult() musí být volána před metodou startDocument()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Objekt Transformer nemá žádný zapouzdřený objekt translet." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "Neexistuje žádný definovaný výstupní obslužný program pro výsledek transformace." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "Výsledný objekt předaný ''{0}'' je neplatný." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Pokus o přístup k neplatné vlastnosti objektu Transformer: ''{0}''." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Nelze vytvořit adaptér SAX2DOM: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "Byla volána metoda XSLTCSource.build(), aniž by byla nastavena hodnota systemId." } , { ErrorMsg . COMPILE_STDIN_ERR , "Volba -i musí být použita s volbou -o." } , { ErrorMsg . COMPILE_USAGE_STR , "SYNOPSIS\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]\n      [-d <directory>] [-j <jarfile>] [-p <package>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }\n\nVOLBY\n   -o <output>    přiřazuje název <output> generovanému\n                  transletu. Standardně je název transletu\n                  převzat z názvu <stylesheet>. Tato volba\n                   se ignoruje, pokud se kompilují násobné předlohy stylů.\n   -d <directory> určuje výchozí adresář pro translet\n   -j <jarfile>   zabalí třídu transletu do souboru jar\n     pojmenovaného jako <jarfile>\n   -p <package>   určuje předponu názvu balíčku pro všechny generované \n třídy transletu.\n   -n             povoluje zarovnání šablony (výchozí chování je v průměru lepší\n                  .\n   -x             zapne další výstup zprávy ladění\n   -s             zakáže volání System.exit\n   -u             interpretuje <stylesheet> argumenty jako URL\n   -i             vynutí kompilátor číst předlohu stylů ze stdin\n   -v             tiskne verzi kompilátoru \n   -h             tiskne výpis tohoto použití \n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SYNOPSIS \n   java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]\n      [-x] [-s] [-n <iterations>] {-u <document_url> | <document>}\n      <class> [<param1>=<value1> ...]\n\n   použije translet <class> k transformaci dokumentu XML \n určeného jako <document>. Translet <class> je buď v\n   v uživatelské cestě CLASSPATH nebo ve volitelně určeném souboru <jarfile>.\nVOLBY\n     -j <jarfile>    určuje soubor jarfile, ze kterého se zavede translet\n   -x      převede další výstup zprávy ladění\n   -s              vypne volání System.exit\n   -n <iterations> spustí transformaci <iterations> krát a\n                   zobrazí informaci  o profilu\n   -u <document_url> určí vstupní dokument XML jako URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "Prvek <xsl:sort> může být použit jen v <xsl:for-each> nebo <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "Výstupní kódování ''{0}'' není v tomto prostředí JVM podporováno." } , { ErrorMsg . SYNTAX_ERR , "Chyba syntaxe v ''{0}''." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "Nelze najít vnější konstruktor ''{0}''." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "První argument nestatické funkce Java ''{0}'' není platným odkazem na objekt." } , { ErrorMsg . TYPE_CHECK_ERR , "Chyba při kontrole typu výrazu ''{0}''." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Chyba při kontrole typu výrazu na neznámém místě." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "Volba příkazového řádku ''{0}'' není platná." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "Volbě příkazového řádku ''{0}'' chybí požadovaný argument." } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "VAROVÁNÍ: ''{0}''\n        :{1}" } , { ErrorMsg . WARNING_MSG , "VAROVÁNÍ: ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "ZÁVAŽNÁ CHYBA: ''{0}''\n             :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "ZÁVAŽNÁ CHYBA: ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "CHYBA: ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "CHYBA: ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Transformace použitím transletu ''{0}'' " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Transformace použitím transletu ''{0}'' ze souboru jar ''{1}''" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "Nelze vytvořit instanci třídy TransformerFactory ''{0}''." } , { ErrorMsg . COMPILER_ERROR_KEY , "Chyby kompilátoru:" } , { ErrorMsg . COMPILER_WARNING_KEY , "Varování kompilátoru:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Chyby transletu:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xalan . templates ; import org . apache . xpath . XPath ; public class WhiteSpaceInfo extends ElemTemplate { private boolean m_shouldStripSpace ; public boolean getShouldStripSpace ( ) { return m_shouldStripSpace ; } public WhiteSpaceInfo ( Stylesheet thisSheet ) { setStylesheet ( thisSheet ) ; } public WhiteSpaceInfo ( XPath matchPattern , boolean shouldStripSpace , Stylesheet thisSheet ) { m_shouldStripSpace = shouldStripSpace ; setMatch ( matchPattern ) ; setStylesheet ( thisSheet ) ; } public void recompose ( StylesheetRoot root ) { root . recomposeWhiteSpaceInfo ( this ) ; } } 	1	['4', '4', '1', '9', '8', '4', '7', '4', '4', '0.666666667', '30', '1', '0', '0.99086758', '0.45', '0', '0', '6.25', '1', '0.5', '1']
package org . apache . xalan . xsltc . cmdline . getopt ; import java . util . ArrayList ; import java . util . List ; import java . util . ListIterator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; public class GetOpt { public GetOpt ( String [ ] args , String optString ) { theOptions = new ArrayList ( ) ; int currOptIndex = 0 ; theCmdArgs = new ArrayList ( ) ; theOptionMatcher = new OptionMatcher ( optString ) ; for ( int i = 0 ; i < args . length ; i ++ ) { String token = args [ i ] ; int tokenLength = token . length ( ) ; if ( token . equals ( "--" ) ) { currOptIndex = i + 1 ; break ; } else if ( token . startsWith ( "-" ) && tokenLength == 2 ) { theOptions . add ( new Option ( token . charAt ( 1 ) ) ) ; } else if ( token . startsWith ( "-" ) && tokenLength > 2 ) { for ( int j = 1 ; j < tokenLength ; j ++ ) { theOptions . add ( new Option ( token . charAt ( j ) ) ) ; } } else if ( ! token . startsWith ( "-" ) ) { if ( theOptions . size ( ) == 0 ) { currOptIndex = i ; break ; } else { int indexoflast = 0 ; indexoflast = theOptions . size ( ) - 1 ; Option op = ( Option ) theOptions . get ( indexoflast ) ; char opLetter = op . getArgLetter ( ) ; if ( ! op . hasArg ( ) && theOptionMatcher . hasArg ( opLetter ) ) { op . setArg ( token ) ; } else { currOptIndex = i ; break ; } } } } theOptionsIterator = theOptions . listIterator ( ) ; for ( int i = currOptIndex ; i < args . length ; i ++ ) { String token = args [ i ] ; theCmdArgs . add ( token ) ; } } public void printOptions ( ) { for ( ListIterator it = theOptions . listIterator ( ) ; it . hasNext ( ) ; ) { Option opt = ( Option ) it . next ( ) ; System . out . print ( "OPT =" + opt . getArgLetter ( ) ) ; String arg = opt . getArgument ( ) ; if ( arg != null ) { System . out . print ( " " + arg ) ; } System . out . println ( ) ; } } public int getNextOption ( ) throws IllegalArgumentException , MissingOptArgException { int retval = - 1 ; if ( theOptionsIterator . hasNext ( ) ) { theCurrentOption = ( Option ) theOptionsIterator . next ( ) ; char c = theCurrentOption . getArgLetter ( ) ; boolean shouldHaveArg = theOptionMatcher . hasArg ( c ) ; String arg = theCurrentOption . getArgument ( ) ; if ( ! theOptionMatcher . match ( c ) ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , new Character ( c ) ) ; throw ( new IllegalArgumentException ( msg . toString ( ) ) ) ; } else if ( shouldHaveArg && ( arg == null ) ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , new Character ( c ) ) ; throw ( new MissingOptArgException ( msg . toString ( ) ) ) ; } retval = c ; } return retval ; } public String getOptionArg ( ) { String retval = null ; String tmp = theCurrentOption . getArgument ( ) ; char c = theCurrentOption . getArgLetter ( ) ; if ( theOptionMatcher . hasArg ( c ) ) { retval = tmp ; } return retval ; } public String [ ] getCmdArgs ( ) { String [ ] retval = new String [ theCmdArgs . size ( ) ] ; int i = 0 ; for ( ListIterator it = theCmdArgs . listIterator ( ) ; it . hasNext ( ) ; ) { retval [ i ++ ] = ( String ) it . next ( ) ; } return retval ; } private Option theCurrentOption = null ; private ListIterator theOptionsIterator ; private List theOptions = null ; private List theCmdArgs = null ; private OptionMatcher theOptionMatcher = null ; class Option { private char theArgLetter ; private String theArgument = null ; public Option ( char argLetter ) { theArgLetter = argLetter ; } public void setArg ( String arg ) { theArgument = arg ; } public boolean hasArg ( ) { return ( theArgument != null ) ; } public char getArgLetter ( ) { return theArgLetter ; } public String getArgument ( ) { return theArgument ; } } class OptionMatcher { public OptionMatcher ( String optString ) { theOptString = optString ; } public boolean match ( char c ) { boolean retval = false ; if ( theOptString . indexOf ( c ) != - 1 ) { retval = true ; } return retval ; } public boolean hasArg ( char c ) { boolean retval = false ; int index = theOptString . indexOf ( c ) + 1 ; if ( index == theOptString . length ( ) ) { retval = false ; } else if ( theOptString . charAt ( index ) == ':' ) { retval = true ; } return retval ; } private String theOptString = null ; } } 	1	['5', '1', '0', '6', '36', '0', '3', '5', '5', '0.65', '330', '1', '2', '0', '0.466666667', '0', '0', '64', '3', '1.6', '1']
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources_tr extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Eşleşme örüntüsünde current() işlevine izin verilmez!" } , { ER_CURRENT_TAKES_NO_ARGS , "current() işlevi bağımsız değişken kabul etmez!" } , { ER_DOCUMENT_REPLACED , "document() işlevi uygulaması org.apache.xalan.xslt.FuncDocument ile değiştirildi!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "Bağlamın iye belgesi yok!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() işlevinde çok fazla bağımsız değişken var." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() işlevinde çok fazla bağımsız değişken var." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() işlevinde çok fazla bağımsız değişken var." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() işlevinde çok fazla bağımsız değişken var." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() işlevinde çok fazla bağımsız değişken var." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() işlevinde çok fazla bağımsız değişken var." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() işlevinde çok fazla bağımsız değişken var." } , { ER_TRANSLATE_TAKES_3_ARGS , "translate() işlevi üç bağımsız değişken alır!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "unparsed-entity-uri işlevi bir bağımsız değişken almalıdır!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "namespace ekseni henüz gerçekleştirilmedi!" } , { ER_UNKNOWN_AXIS , "Bilinmeyen eksen: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "Bilinmeyen eşleşme işlemi!" } , { ER_INCORRECT_ARG_LENGTH , "processing-instruction() düğüm sınamasının bağımsız değişken uzunluğu yanlış!" } , { ER_CANT_CONVERT_TO_NUMBER , "{0} bir sayıya dönüştürülemez" } , { ER_CANT_CONVERT_TO_NODELIST , "{0} NodeList''e dönüştürülemez!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0} NodeSetDTM''ye dönüştürülemez!" } , { ER_CANT_CONVERT_TO_TYPE , "{0} - type#{1} dönüşümü yapılamaz" } , { ER_EXPECTED_MATCH_PATTERN , "getMatchScore içinde eşleşme örüntüsü bekleniyor!" } , { ER_COULDNOT_GET_VAR_NAMED , "{0} adlı değişken alınamadı" } , { ER_UNKNOWN_OPCODE , "HATA! Bilinmeyen işlem kodu: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Fazladan geçersiz simgeler: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Hazır bilginin tırnak imi yanlış... çift tırnak bekleniyor!" } , { ER_EXPECTED_SINGLE_QUOTE , "Hazır bilginin tırnak imi yanlış... tek tırnak bekleniyor!" } , { ER_EMPTY_EXPRESSION , "İfade boş!" } , { ER_EXPECTED_BUT_FOUND , "{0} bekleniyordu, {1} bulundu" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Programcı değerlendirmesi yanlış! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "boolean(...) bağımsız değişkeni 19990709 XPath taslağıyla artık isteğe bağlı değil." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "',' bulundu, ancak öncesinde bağımsız değişken yok!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "',' bulundu, ancak sonrasında bağımsız değişken yok!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[karşılaştırma belirtimi]' ya da '.[karşılaştırma belirtimi]' geçersiz bir sözdizimi.  Yerine şunu kullanın: 'self::node()[karşılaştırma belirtimi]'." } , { ER_ILLEGAL_AXIS_NAME , "Eksen adı geçersiz: {0}" } , { ER_UNKNOWN_NODETYPE , "Düğüm tipi geçersiz: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Örüntü hazır bilgisinin ({0}) tırnak içine alınması gerekiyor!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} bir sayı olarak biçimlenemedi!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "XML TransformerFactory ilişkisi {0} yaratılamadı" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Hata! xpath select ifadesi (-select) bulunamadı." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "HATA! OP_LOCATIONPATH sonrasında ENDOP bulunamadı." } , { ER_ERROR_OCCURED , "Hata oluştu!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "Değişken için belirtilen VariableReference bağlam dışı ya da tanımsız! Ad = {0}" } , { ER_AXES_NOT_ALLOWED , "Eşleşme örüntülerinde yalnızca child:: ve attribute:: eksenlerine izin verilir! Geçersiz eksenler = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() yanlış sayıda bağımsız değişken içeriyor." } , { ER_COUNT_TAKES_1_ARG , "Sayım işlevi tek bir bağımsız değişken almalıdır!" } , { ER_COULDNOT_FIND_FUNCTION , "İşlev bulunamadı: {0}" } , { ER_UNSUPPORTED_ENCODING , "Desteklenmeyen kodlama: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "getNextSibling sırasında DTM içinde sorun oluştu... kurtarma girişiminde bulunuluyor" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Programcı hatası: EmptyNodeList içine yazılamaz." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory, XPathContext tarafından desteklenmiyor!" } , { ER_PREFIX_MUST_RESOLVE , "Önek bir ad alanına çözülmelidir: {0}" } , { ER_PARSE_NOT_SUPPORTED , "XPathContext içinde parse (InputSource kaynağı) desteklenmiyor! {0} açılamıyor" } , { ER_SAX_API_NOT_HANDLED , "SAX API characters(char ch[]... DTM tarafından işlenmedi!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... DTM tarafından işlenmedi!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison {0} tipi düğümleri işleyemez" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper {0} tipi düğümleri işleyemez" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse hatası: Sistem tnt - {0} satır - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse hatası" } , { ER_INVALID_UTF16_SURROGATE , "UTF-16 yerine kullanılan değer geçersiz: {0} ?" } , { ER_OIERROR , "GÇ hatası" } , { ER_CANNOT_CREATE_URL , "İlgili url yaratılamıyor: {0}" } , { ER_XPATH_READOBJECT , "XPath.readObject içinde: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "İşlev simgesi bulunamadı." } , { ER_CANNOT_DEAL_XPATH_TYPE , "XPath tipi işlenemiyor: {0}" } , { ER_NODESET_NOT_MUTABLE , "Bu NodeSet değişebilir türde değil" } , { ER_NODESETDTM_NOT_MUTABLE , "Bu NodeSetDTM değişebilir türde değil" } , { ER_VAR_NOT_RESOLVABLE , "Değişken çözülebilir bir değişken değil: {0}" } , { ER_NULL_ERROR_HANDLER , "Boş değerli hata işleyici" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Programcı değerlendirmesi: bilinmeyen opcode: {0}" } , { ER_ZERO_OR_ONE , "0 ya da 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() XRTreeFragSelectWrapper tarafından desteklenmiyor" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() XRTreeFragSelectWrapper tarafından desteklenmiyor" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() XStringForChars için desteklenmiyor" } , { ER_COULD_NOT_FIND_VAR , "{0} adında değişken bulunamadı" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars bağımsız değişken olarak dizgi alamaz" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer bağımsız değişkeni boş değerli olamaz" } , { ER_TWO_OR_THREE , "2 ya da 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Değişkene bağ tanımlamadan önce erişildi!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB bağımsız değişken olarak dizgi alamaz!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Hata! Walker kökü boş değere ayarlanıyor!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Bu NodeSetDTM önceki bir düğüme yineleme yapamaz!" } , { ER_NODESET_CANNOT_ITERATE , "Bu NodeSet önceki bir düğüme yineleme yapamaz!" } , { ER_NODESETDTM_CANNOT_INDEX , "Bu NodeSetDTM dizinleme ya da sayma işlevleri yapamaz!" } , { ER_NODESET_CANNOT_INDEX , "Bu NodeSet dizinleme ya da sayma işlevleri yapamaz!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "nextNode çağrıldıktan sonra setShouldCacheNodes çağrılamaz!" } , { ER_ONLY_ALLOWS , "{0} yalnızca {1} bağımsız değişkene izin verir" } , { ER_UNKNOWN_STEP , "getNextStepPos içinde programcı değerlendirmesi: bilinmeyen stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "'/' ya da '//' simgesinden sonra göreli yer yolu bekleniyordu." } , { ER_EXPECTED_LOC_PATH , "Yer yolu bekleniyordu, ancak şu simge saptandı:  {0}" } , { ER_EXPECTED_LOC_STEP , "'/' ya da '//' simgesinden sonra yer adımı bekleniyordu." } , { ER_EXPECTED_NODE_TEST , "NCName:* ya da QName ile eşleşen bir düğüm sınaması bekleniyordu." } , { ER_EXPECTED_STEP_PATTERN , "Adım örüntüsü bekleniyordu, ancak '/' saptandı." } , { ER_EXPECTED_REL_PATH_PATTERN , "Göreli yol örüntüsü bekleniyordu." } , { ER_CANT_CONVERT_TO_BOOLEAN , "{0} boole tipine dönüştürülemedi" } , { ER_CANT_CONVERT_TO_SINGLENODE , "{0} tek düğüme dönüştürülemiyor. Bu alma yöntemi (getter) ANY_UNORDERED_NODE_TYPE ve FIRST_ORDERED_NODE_TYPE tipleri için geçerlidir." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Bu tip üzerinde anlık görünüm uzunluğu alınamıyor: {0}. Bu alma yöntemi (getter) UNORDERED_NODE_SNAPSHOT_TYPE ve ORDERED_NODE_SNAPSHOT_TYPE tipleri için geçerlidir." } , { ER_NON_ITERATOR_TYPE , "Yineleyici olmayan tip üzerinde yinelenemez: {0}" } , { ER_DOC_MUTATED , "Sonuç döndürüldükten sonra belge değiştirildi. Yineleyici geçersiz." } , { ER_INVALID_XPATH_TYPE , "Geçersiz XPath tipi bağımsız değişkeni: {0}" } , { ER_EMPTY_XPATH_RESULT , "Boş XPath sonuç nesnesi" } , { ER_INCOMPATIBLE_TYPES , "Döndürülen {0} tipi, belirtilen {1} tipine zorlanamaz." } , { ER_NULL_RESOLVER , "Boş değerli önek çözücüyle önek çözülemez." } , { ER_CANT_CONVERT_TO_STRING , "{0} bir dizgiye dönüştürülemiyor." } , { ER_NON_SNAPSHOT_TYPE , "{0} tipi üzerinde snapshotItem çağrılamıyor. Bu yöntem UNORDERED_NODE_SNAPSHOT_TYPE ve ORDERED_NODE_SNAPSHOT_TYPE tipleri için geçerlidir." } , { ER_WRONG_DOCUMENT , "Bağlam düğümü, bu XPathEvaluator arabirimine bağlanan belgeye ait değil." } , { ER_WRONG_NODETYPE , "Bağlam düğümü tipi desteklenmiyor." } , { ER_XPATH_ERROR , "XPath içinde bilinmeyen hata." } , { WG_LOCALE_NAME_NOT_HANDLED , "format-number işlevinde ülke değeri adı henüz işlenmedi!" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL özelliği desteklenmiyor: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "{1} özelliğindeki {0} ad alanıyla şu an hiçbir şey yapmayın" } , { WG_SECURITY_EXCEPTION , "{0} XSL sistem özelliğine erişme girişimi sırasında SecurityException" } , { WG_QUO_NO_LONGER_DEFINED , "Eski sözdizimi: quo(...) artık XPath içinde tanımlanmaz." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "nodeTest uygulanması için XPath türetilmiş bir nesne gerektirir!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "İşlev simgesi bulunamadı." } , { WG_COULDNOT_FIND_FUNCTION , "İşlev bulunamadı: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Dizgiden URL oluşturulamadı: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "DTM ayrıştırıcısı için -E seçeneği desteklenmiyor" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "Değişken için belirtilen VariableReference bağlam dışı ya da tanımsız! Ad = {0}" } , { WG_UNSUPPORTED_ENCODING , "Desteklenmeyen kodlama: {0}" } , { "ui_language" , "tr" } , { "help_language" , "tr" } , { "language" , "tr" } , { "BAD_CODE" , "createMessage için kullanılan değiştirge sınırların dışında" } , { "FORMAT_FAILED" , "messageFormat çağrısı sırasında kural dışı durum yayınlandı" } , { "version" , ">>>>>>> Xalan Sürüm " } , { "version2" , "<<<<<<<" } , { "yes" , "yes" } , { "line" , "Satır #" } , { "column" , "Kolon #" } , { "xsldone" , "XSLProcessor: bitti" } , { "xpath_option" , "xpath seçenekleri: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath ifadesi]" } , { "optionMatch" , "   [-match eşleşme örüntüsü (eşleşme tanılaması için)]" } , { "optionAnyExpr" , "Ya da yalnızca xpath ifadesi de tanılama dökümü sağlar" } , { "noParsermsg1" , "XSL işlemi başarısız oldu." } , { "noParsermsg2" , "** Ayrıştırıcı bulunamadı **" } , { "noParsermsg3" , "Lütfen classpath değişkeninizi inceleyin." } , { "noParsermsg4" , "Sisteminizde IBM XML Parser for Java aracı yoksa, şu adresten yükleyebilirsiniz:" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "HATALI_KOD" ; public static final String FORMAT_FAILED = "BİÇİMLEME_BAŞARISIZ" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#hata" ; public static final String ERROR_HEADER = "Hata: " ; public static final String WARNING_HEADER = "Uyarı: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "ÖRÜNTÜ " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "tr" , "TR" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.246296296', '2125', '0', '0', '0.926829268', '0.333333333', '0', '0', '397', '2', '0.8', '2']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . LexicalHandler ; public class ToTextSAXHandler extends ToSAXHandler { public void endElement ( String elemName ) throws SAXException { if ( m_tracer != null ) super . fireEndElem ( elemName ) ; } public void endElement ( String arg0 , String arg1 , String arg2 ) throws SAXException { if ( m_tracer != null ) super . fireEndElem ( arg2 ) ; } public ToTextSAXHandler ( ContentHandler hdlr , LexicalHandler lex , String encoding ) { super ( hdlr , lex , encoding ) ; } public ToTextSAXHandler ( ContentHandler handler , String encoding ) { super ( handler , encoding ) ; } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( m_tracer != null ) super . fireCommentEvent ( ch , start , length ) ; } public void comment ( String data ) throws org . xml . sax . SAXException { final int length = data . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * 2 + 1 ] ; } data . getChars ( 0 , length , m_charsBuff , 0 ) ; comment ( m_charsBuff , 0 , length ) ; } public Properties getOutputFormat ( ) { return null ; } public OutputStream getOutputStream ( ) { return null ; } public Writer getWriter ( ) { return null ; } public void indent ( int n ) throws SAXException { } public boolean reset ( ) { return false ; } public void serialize ( Node node ) throws IOException { } public boolean setEscaping ( boolean escape ) { return false ; } public void setIndent ( boolean indent ) { } public void setOutputFormat ( Properties format ) { } public void setOutputStream ( OutputStream output ) { } public void setWriter ( Writer writer ) { } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) { } public void attributeDecl ( String arg0 , String arg1 , String arg2 , String arg3 , String arg4 ) throws SAXException { } public void elementDecl ( String arg0 , String arg1 ) throws SAXException { } public void externalEntityDecl ( String arg0 , String arg1 , String arg2 ) throws SAXException { } public void internalEntityDecl ( String arg0 , String arg1 ) throws SAXException { } public void endPrefixMapping ( String arg0 ) throws SAXException { } public void ignorableWhitespace ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { } public void processingInstruction ( String arg0 , String arg1 ) throws SAXException { if ( m_tracer != null ) super . fireEscapingEvent ( arg0 , arg1 ) ; } public void setDocumentLocator ( Locator arg0 ) { } public void skippedEntity ( String arg0 ) throws SAXException { } public void startElement ( String arg0 , String arg1 , String arg2 , Attributes arg3 ) throws SAXException { flushPending ( ) ; super . startElement ( arg0 , arg1 , arg2 , arg3 ) ; } public void endCDATA ( ) throws SAXException { } public void endDTD ( ) throws SAXException { } public void startCDATA ( ) throws SAXException { } public void startEntity ( String arg0 ) throws SAXException { } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { super . startElement ( elementNamespaceURI , elementLocalName , elementName ) ; } public void startElement ( String elementName ) throws SAXException { super . startElement ( elementName ) ; } public void endDocument ( ) throws SAXException { flushPending ( ) ; m_saxHandler . endDocument ( ) ; if ( m_tracer != null ) super . fireEndDoc ( ) ; } public void characters ( String characters ) throws SAXException { final int length = characters . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * 2 + 1 ] ; } characters . getChars ( 0 , length , m_charsBuff , 0 ) ; m_saxHandler . characters ( m_charsBuff , 0 , length ) ; } public void characters ( char [ ] characters , int offset , int length ) throws SAXException { m_saxHandler . characters ( characters , offset , length ) ; if ( m_tracer != null ) super . fireCharEvent ( characters , offset , length ) ; } public void addAttribute ( String name , String value ) { } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { return false ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { } public void namespaceAfterStartElement ( final String prefix , final String uri ) throws SAXException { } } 	1	['41', '3', '0', '4', '56', '784', '2', '2', '41', '2', '223', '0', '0', '0.74', '0.153846154', '2', '9', '4.43902439', '1', '0.9512', '2']
package org . apache . xml . utils ; public class XMLChar { public static final byte [ ] CHARS = new byte [ 1 << 16 ] ; public static final int MASK_VALID = 0x01 ; public static final int MASK_SPACE = 0x02 ; public static final int MASK_NAME_START = 0x04 ; public static final int MASK_NAME = 0x08 ; public static final int MASK_PUBID = 0x10 ; public static final int MASK_CONTENT = 0x20 ; public static final int MASK_NCNAME_START = 0x40 ; public static final int MASK_NCNAME = 0x80 ; static { int charRange [ ] = { 0x0009 , 0x000A , 0x000D , 0x000D , 0x0020 , 0xD7FF , 0xE000 , 0xFFFD , } ; int spaceChar [ ] = { 0x0020 , 0x0009 , 0x000D , 0x000A , } ; int nameChar [ ] = { 0x002D , 0x002E , } ; int nameStartChar [ ] = { 0x003A , 0x005F , } ; int pubidChar [ ] = { 0x000A , 0x000D , 0x0020 , 0x0021 , 0x0023 , 0x0024 , 0x0025 , 0x003D , 0x005F } ; int pubidRange [ ] = { 0x0027 , 0x003B , 0x003F , 0x005A , 0x0061 , 0x007A } ; int letterRange [ ] = { 0x0041 , 0x005A , 0x0061 , 0x007A , 0x00C0 , 0x00D6 , 0x00D8 , 0x00F6 , 0x00F8 , 0x0131 , 0x0134 , 0x013E , 0x0141 , 0x0148 , 0x014A , 0x017E , 0x0180 , 0x01C3 , 0x01CD , 0x01F0 , 0x01F4 , 0x01F5 , 0x01FA , 0x0217 , 0x0250 , 0x02A8 , 0x02BB , 0x02C1 , 0x0388 , 0x038A , 0x038E , 0x03A1 , 0x03A3 , 0x03CE , 0x03D0 , 0x03D6 , 0x03E2 , 0x03F3 , 0x0401 , 0x040C , 0x040E , 0x044F , 0x0451 , 0x045C , 0x045E , 0x0481 , 0x0490 , 0x04C4 , 0x04C7 , 0x04C8 , 0x04CB , 0x04CC , 0x04D0 , 0x04EB , 0x04EE , 0x04F5 , 0x04F8 , 0x04F9 , 0x0531 , 0x0556 , 0x0561 , 0x0586 , 0x05D0 , 0x05EA , 0x05F0 , 0x05F2 , 0x0621 , 0x063A , 0x0641 , 0x064A , 0x0671 , 0x06B7 , 0x06BA , 0x06BE , 0x06C0 , 0x06CE , 0x06D0 , 0x06D3 , 0x06E5 , 0x06E6 , 0x0905 , 0x0939 , 0x0958 , 0x0961 , 0x0985 , 0x098C , 0x098F , 0x0990 , 0x0993 , 0x09A8 , 0x09AA , 0x09B0 , 0x09B6 , 0x09B9 , 0x09DC , 0x09DD , 0x09DF , 0x09E1 , 0x09F0 , 0x09F1 , 0x0A05 , 0x0A0A , 0x0A0F , 0x0A10 , 0x0A13 , 0x0A28 , 0x0A2A , 0x0A30 , 0x0A32 , 0x0A33 , 0x0A35 , 0x0A36 , 0x0A38 , 0x0A39 , 0x0A59 , 0x0A5C , 0x0A72 , 0x0A74 , 0x0A85 , 0x0A8B , 0x0A8F , 0x0A91 , 0x0A93 , 0x0AA8 , 0x0AAA , 0x0AB0 , 0x0AB2 , 0x0AB3 , 0x0AB5 , 0x0AB9 , 0x0B05 , 0x0B0C , 0x0B0F , 0x0B10 , 0x0B13 , 0x0B28 , 0x0B2A , 0x0B30 , 0x0B32 , 0x0B33 , 0x0B36 , 0x0B39 , 0x0B5C , 0x0B5D , 0x0B5F , 0x0B61 , 0x0B85 , 0x0B8A , 0x0B8E , 0x0B90 , 0x0B92 , 0x0B95 , 0x0B99 , 0x0B9A , 0x0B9E , 0x0B9F , 0x0BA3 , 0x0BA4 , 0x0BA8 , 0x0BAA , 0x0BAE , 0x0BB5 , 0x0BB7 , 0x0BB9 , 0x0C05 , 0x0C0C , 0x0C0E , 0x0C10 , 0x0C12 , 0x0C28 , 0x0C2A , 0x0C33 , 0x0C35 , 0x0C39 , 0x0C60 , 0x0C61 , 0x0C85 , 0x0C8C , 0x0C8E , 0x0C90 , 0x0C92 , 0x0CA8 , 0x0CAA , 0x0CB3 , 0x0CB5 , 0x0CB9 , 0x0CE0 , 0x0CE1 , 0x0D05 , 0x0D0C , 0x0D0E , 0x0D10 , 0x0D12 , 0x0D28 , 0x0D2A , 0x0D39 , 0x0D60 , 0x0D61 , 0x0E01 , 0x0E2E , 0x0E32 , 0x0E33 , 0x0E40 , 0x0E45 , 0x0E81 , 0x0E82 , 0x0E87 , 0x0E88 , 0x0E94 , 0x0E97 , 0x0E99 , 0x0E9F , 0x0EA1 , 0x0EA3 , 0x0EAA , 0x0EAB , 0x0EAD , 0x0EAE , 0x0EB2 , 0x0EB3 , 0x0EC0 , 0x0EC4 , 0x0F40 , 0x0F47 , 0x0F49 , 0x0F69 , 0x10A0 , 0x10C5 , 0x10D0 , 0x10F6 , 0x1102 , 0x1103 , 0x1105 , 0x1107 , 0x110B , 0x110C , 0x110E , 0x1112 , 0x1154 , 0x1155 , 0x115F , 0x1161 , 0x116D , 0x116E , 0x1172 , 0x1173 , 0x11AE , 0x11AF , 0x11B7 , 0x11B8 , 0x11BC , 0x11C2 , 0x1E00 , 0x1E9B , 0x1EA0 , 0x1EF9 , 0x1F00 , 0x1F15 , 0x1F18 , 0x1F1D , 0x1F20 , 0x1F45 , 0x1F48 , 0x1F4D , 0x1F50 , 0x1F57 , 0x1F5F , 0x1F7D , 0x1F80 , 0x1FB4 , 0x1FB6 , 0x1FBC , 0x1FC2 , 0x1FC4 , 0x1FC6 , 0x1FCC , 0x1FD0 , 0x1FD3 , 0x1FD6 , 0x1FDB , 0x1FE0 , 0x1FEC , 0x1FF2 , 0x1FF4 , 0x1FF6 , 0x1FFC , 0x212A , 0x212B , 0x2180 , 0x2182 , 0x3041 , 0x3094 , 0x30A1 , 0x30FA , 0x3105 , 0x312C , 0xAC00 , 0xD7A3 , 0x3021 , 0x3029 , 0x4E00 , 0x9FA5 , } ; int letterChar [ ] = { 0x0386 , 0x038C , 0x03DA , 0x03DC , 0x03DE , 0x03E0 , 0x0559 , 0x06D5 , 0x093D , 0x09B2 , 0x0A5E , 0x0A8D , 0x0ABD , 0x0AE0 , 0x0B3D , 0x0B9C , 0x0CDE , 0x0E30 , 0x0E84 , 0x0E8A , 0x0E8D , 0x0EA5 , 0x0EA7 , 0x0EB0 , 0x0EBD , 0x1100 , 0x1109 , 0x113C , 0x113E , 0x1140 , 0x114C , 0x114E , 0x1150 , 0x1159 , 0x1163 , 0x1165 , 0x1167 , 0x1169 , 0x1175 , 0x119E , 0x11A8 , 0x11AB , 0x11BA , 0x11EB , 0x11F0 , 0x11F9 , 0x1F59 , 0x1F5B , 0x1F5D , 0x1FBE , 0x2126 , 0x212E , 0x3007 , } ; int combiningCharRange [ ] = { 0x0300 , 0x0345 , 0x0360 , 0x0361 , 0x0483 , 0x0486 , 0x0591 , 0x05A1 , 0x05A3 , 0x05B9 , 0x05BB , 0x05BD , 0x05C1 , 0x05C2 , 0x064B , 0x0652 , 0x06D6 , 0x06DC , 0x06DD , 0x06DF , 0x06E0 , 0x06E4 , 0x06E7 , 0x06E8 , 0x06EA , 0x06ED , 0x0901 , 0x0903 , 0x093E , 0x094C , 0x0951 , 0x0954 , 0x0962 , 0x0963 , 0x0981 , 0x0983 , 0x09C0 , 0x09C4 , 0x09C7 , 0x09C8 , 0x09CB , 0x09CD , 0x09E2 , 0x09E3 , 0x0A40 , 0x0A42 , 0x0A47 , 0x0A48 , 0x0A4B , 0x0A4D , 0x0A70 , 0x0A71 , 0x0A81 , 0x0A83 , 0x0ABE , 0x0AC5 , 0x0AC7 , 0x0AC9 , 0x0ACB , 0x0ACD , 0x0B01 , 0x0B03 , 0x0B3E , 0x0B43 , 0x0B47 , 0x0B48 , 0x0B4B , 0x0B4D , 0x0B56 , 0x0B57 , 0x0B82 , 0x0B83 , 0x0BBE , 0x0BC2 , 0x0BC6 , 0x0BC8 , 0x0BCA , 0x0BCD , 0x0C01 , 0x0C03 , 0x0C3E , 0x0C44 , 0x0C46 , 0x0C48 , 0x0C4A , 0x0C4D , 0x0C55 , 0x0C56 , 0x0C82 , 0x0C83 , 0x0CBE , 0x0CC4 , 0x0CC6 , 0x0CC8 , 0x0CCA , 0x0CCD , 0x0CD5 , 0x0CD6 , 0x0D02 , 0x0D03 , 0x0D3E , 0x0D43 , 0x0D46 , 0x0D48 , 0x0D4A , 0x0D4D , 0x0E34 , 0x0E3A , 0x0E47 , 0x0E4E , 0x0EB4 , 0x0EB9 , 0x0EBB , 0x0EBC , 0x0EC8 , 0x0ECD , 0x0F18 , 0x0F19 , 0x0F71 , 0x0F84 , 0x0F86 , 0x0F8B , 0x0F90 , 0x0F95 , 0x0F99 , 0x0FAD , 0x0FB1 , 0x0FB7 , 0x20D0 , 0x20DC , 0x302A , 0x302F , } ; int combiningCharChar [ ] = { 0x05BF , 0x05C4 , 0x0670 , 0x093C , 0x094D , 0x09BC , 0x09BE , 0x09BF , 0x09D7 , 0x0A02 , 0x0A3C , 0x0A3E , 0x0A3F , 0x0ABC , 0x0B3C , 0x0BD7 , 0x0D57 , 0x0E31 , 0x0EB1 , 0x0F35 , 0x0F37 , 0x0F39 , 0x0F3E , 0x0F3F , 0x0F97 , 0x0FB9 , 0x20E1 , 0x3099 , 0x309A , } ; int digitRange [ ] = { 0x0030 , 0x0039 , 0x0660 , 0x0669 , 0x06F0 , 0x06F9 , 0x0966 , 0x096F , 0x09E6 , 0x09EF , 0x0A66 , 0x0A6F , 0x0AE6 , 0x0AEF , 0x0B66 , 0x0B6F , 0x0BE7 , 0x0BEF , 0x0C66 , 0x0C6F , 0x0CE6 , 0x0CEF , 0x0D66 , 0x0D6F , 0x0E50 , 0x0E59 , 0x0ED0 , 0x0ED9 , 0x0F20 , 0x0F29 , } ; int extenderRange [ ] = { 0x3031 , 0x3035 , 0x309D , 0x309E , 0x30FC , 0x30FE , } ; int extenderChar [ ] = { 0x00B7 , 0x02D0 , 0x02D1 , 0x0387 , 0x0640 , 0x0E46 , 0x0EC6 , 0x3005 , } ; int specialChar [ ] = { '<' , '&' , '\n' , '\r' , ']' , } ; for ( int i = 0 ; i < charRange . length ; i += 2 ) { for ( int j = charRange [ i ] ; j <= charRange [ i + 1 ] ; j ++ ) { CHARS [ j ] |= MASK_VALID | MASK_CONTENT ; } } for ( int i = 0 ; i < specialChar . length ; i ++ ) { CHARS [ specialChar [ i ] ] = ( byte ) ( CHARS [ specialChar [ i ] ] & ~ MASK_CONTENT ) ; } for ( int i = 0 ; i < spaceChar . length ; i ++ ) { CHARS [ spaceChar [ i ] ] |= MASK_SPACE ; } for ( int i = 0 ; i < nameStartChar . length ; i ++ ) { CHARS [ nameStartChar [ i ] ] |= MASK_NAME_START | MASK_NAME | MASK_NCNAME_START | MASK_NCNAME ; } for ( int i = 0 ; i < letterRange . length ; i += 2 ) { for ( int j = letterRange [ i ] ; j <= letterRange [ i + 1 ] ; j ++ ) { CHARS [ j ] |= MASK_NAME_START | MASK_NAME | MASK_NCNAME_START | MASK_NCNAME ; } } for ( int i = 0 ; i < letterChar . length ; i ++ ) { CHARS [ letterChar [ i ] ] |= MASK_NAME_START | MASK_NAME | MASK_NCNAME_START | MASK_NCNAME ; } for ( int i = 0 ; i < nameChar . length ; i ++ ) { CHARS [ nameChar [ i ] ] |= MASK_NAME | MASK_NCNAME ; } for ( int i = 0 ; i < digitRange . length ; i += 2 ) { for ( int j = digitRange [ i ] ; j <= digitRange [ i + 1 ] ; j ++ ) { CHARS [ j ] |= MASK_NAME | MASK_NCNAME ; } } for ( int i = 0 ; i < combiningCharRange . length ; i += 2 ) { for ( int j = combiningCharRange [ i ] ; j <= combiningCharRange [ i + 1 ] ; j ++ ) { CHARS [ j ] |= MASK_NAME | MASK_NCNAME ; } } for ( int i = 0 ; i < combiningCharChar . length ; i ++ ) { CHARS [ combiningCharChar [ i ] ] |= MASK_NAME | MASK_NCNAME ; } for ( int i = 0 ; i < extenderRange . length ; i += 2 ) { for ( int j = extenderRange [ i ] ; j <= extenderRange [ i + 1 ] ; j ++ ) { CHARS [ j ] |= MASK_NAME | MASK_NCNAME ; } } for ( int i = 0 ; i < extenderChar . length ; i ++ ) { CHARS [ extenderChar [ i ] ] |= MASK_NAME | MASK_NCNAME ; } CHARS [ ':' ] &= ~ ( MASK_NCNAME_START | MASK_NCNAME ) ; for ( int i = 0 ; i < pubidChar . length ; i ++ ) { CHARS [ pubidChar [ i ] ] |= MASK_PUBID ; } for ( int i = 0 ; i < pubidRange . length ; i += 2 ) { for ( int j = pubidRange [ i ] ; j <= pubidRange [ i + 1 ] ; j ++ ) { CHARS [ j ] |= MASK_PUBID ; } } } public static boolean isSupplemental ( int c ) { return ( c >= 0x10000 && c <= 0x10FFFF ) ; } public static int supplemental ( char h , char l ) { return ( h - 0xD800 ) * 0x400 + ( l - 0xDC00 ) + 0x10000 ; } public static char highSurrogate ( int c ) { return ( char ) ( ( ( c - 0x00010000 ) > > 10 ) + 0xD800 ) ; } public static char lowSurrogate ( int c ) { return ( char ) ( ( ( c - 0x00010000 ) & 0x3FF ) + 0xDC00 ) ; } public static boolean isHighSurrogate ( int c ) { return ( 0xD800 <= c && c <= 0xDBFF ) ; } public static boolean isLowSurrogate ( int c ) { return ( 0xDC00 <= c && c <= 0xDFFF ) ; } public static boolean isValid ( int c ) { return ( c < 0x10000 && ( CHARS [ c ] & MASK_VALID ) != 0 ) || ( 0x10000 <= c && c <= 0x10FFFF ) ; } public static boolean isInvalid ( int c ) { return ! isValid ( c ) ; } public static boolean isContent ( int c ) { return ( c < 0x10000 && ( CHARS [ c ] & MASK_CONTENT ) != 0 ) || ( 0x10000 <= c && c <= 0x10FFFF ) ; } public static boolean isMarkup ( int c ) { return c == '<' || c == '&' || c == '%' ; } public static boolean isSpace ( int c ) { return c < 0x10000 && ( CHARS [ c ] & MASK_SPACE ) != 0 ; } public static boolean isNameStart ( int c ) { return c < 0x10000 && ( CHARS [ c ] & MASK_NAME_START ) != 0 ; } public static boolean isName ( int c ) { return c < 0x10000 && ( CHARS [ c ] & MASK_NAME ) != 0 ; } public static boolean isNCNameStart ( int c ) { return c < 0x10000 && ( CHARS [ c ] & MASK_NCNAME_START ) != 0 ; } public static boolean isNCName ( int c ) { return c < 0x10000 && ( CHARS [ c ] & MASK_NCNAME ) != 0 ; } public static boolean isPubid ( int c ) { return c < 0x10000 && ( CHARS [ c ] & MASK_PUBID ) != 0 ; } public static boolean isValidName ( String name ) { if ( name . length ( ) == 0 ) return false ; char ch = name . charAt ( 0 ) ; if ( isNameStart ( ch ) == false ) return false ; for ( int i = 1 ; i < name . length ( ) ; i ++ ) { ch = name . charAt ( i ) ; if ( isName ( ch ) == false ) { return false ; } } return true ; } public static boolean isValidNCName ( String ncName ) { if ( ncName . length ( ) == 0 ) return false ; char ch = ncName . charAt ( 0 ) ; if ( isNCNameStart ( ch ) == false ) return false ; for ( int i = 1 ; i < ncName . length ( ) ; i ++ ) { ch = ncName . charAt ( i ) ; if ( isNCName ( ch ) == false ) { return false ; } } return true ; } public static boolean isValidNmtoken ( String nmtoken ) { if ( nmtoken . length ( ) == 0 ) return false ; for ( int i = 0 ; i < nmtoken . length ( ) ; i ++ ) { char ch = nmtoken . charAt ( i ) ; if ( ! isName ( ch ) ) { return false ; } } return true ; } public static boolean isValidIANAEncoding ( String ianaEncoding ) { if ( ianaEncoding != null ) { int length = ianaEncoding . length ( ) ; if ( length > 0 ) { char c = ianaEncoding . charAt ( 0 ) ; if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) ) { for ( int i = 1 ; i < length ; i ++ ) { c = ianaEncoding . charAt ( i ) ; if ( ( c < 'A' || c > 'Z' ) && ( c < 'a' || c > 'z' ) && ( c < '0' || c > '9' ) && c != '.' && c != '_' && c != '-' ) { return false ; } } return true ; } } } return false ; } public static boolean isValidJavaEncoding ( String javaEncoding ) { if ( javaEncoding != null ) { int length = javaEncoding . length ( ) ; if ( length > 0 ) { for ( int i = 1 ; i < length ; i ++ ) { char c = javaEncoding . charAt ( i ) ; if ( ( c < 'A' || c > 'Z' ) && ( c < 'a' || c > 'z' ) && ( c < '0' || c > '9' ) && c != '.' && c != '_' && c != '-' ) { return false ; } } return true ; } } return false ; } public static boolean isValidQName ( String str ) { final int colon = str . indexOf ( ':' ) ; if ( colon == 0 || colon == str . length ( ) - 1 ) { return false ; } if ( colon > 0 ) { final String prefix = str . substring ( 0 , colon ) ; final String localPart = str . substring ( colon + 1 ) ; return isValidNCName ( prefix ) && isValidNCName ( localPart ) ; } else { return isValidNCName ( str ) ; } } } 	1	['24', '1', '0', '19', '30', '204', '19', '0', '23', '0.975845411', '3239', '0', '0', '0', '0.25', '0', '0', '133.5833333', '17', '4', '2']
package org . apache . xpath ; import java . io . Serializable ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . FunctionTable ; import org . apache . xpath . compiler . XPathParser ; import org . apache . xpath . functions . Function ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class XPath implements Serializable , ExpressionOwner { private Expression m_mainExp ; public Expression getExpression ( ) { return m_mainExp ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_mainExp . fixupVariables ( vars , globalsSize ) ; } public void setExpression ( Expression exp ) { if ( null != m_mainExp ) exp . exprSetParent ( m_mainExp . exprGetParent ( ) ) ; m_mainExp = exp ; } public SourceLocator getLocator ( ) { return m_mainExp ; } String m_patternString ; public String getPatternString ( ) { return m_patternString ; } public static final int SELECT = 0 ; public static final int MATCH = 1 ; public XPath ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type , ErrorListener errorListener ) throws javax . xml . transform . TransformerException { if ( null == errorListener ) errorListener = new org . apache . xml . utils . DefaultErrorHandler ( ) ; m_patternString = exprString ; XPathParser parser = new XPathParser ( errorListener , locator ) ; Compiler compiler = new Compiler ( errorListener , locator ) ; if ( SELECT == type ) parser . initXPath ( compiler , exprString , prefixResolver ) ; else if ( MATCH == type ) parser . initMatchPattern ( compiler , exprString , prefixResolver ) ; else throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANNOT_DEAL_XPATH_TYPE , new Object [ ] { Integer . toString ( type ) } ) ) ; Expression expr = compiler . compile ( 0 ) ; this . setExpression ( expr ) ; if ( ( null != locator ) && locator instanceof ExpressionNode ) { expr . exprSetParent ( ( ExpressionNode ) locator ) ; } } public XPath ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type ) throws javax . xml . transform . TransformerException { this ( exprString , locator , prefixResolver , type , null ) ; } public XPath ( Expression expr ) { this . setExpression ( expr ) ; } public XObject execute ( XPathContext xctxt , org . w3c . dom . Node contextNode , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { return execute ( xctxt , xctxt . getDTMHandleFromNode ( contextNode ) , namespaceContext ) ; } public XObject execute ( XPathContext xctxt , int contextNode , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { xctxt . pushNamespaceContext ( namespaceContext ) ; xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; XObject xobj = null ; try { xobj = m_mainExp . execute ( xctxt ) ; } catch ( TransformerException te ) { te . setLocator ( this . getLocator ( ) ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . error ( te ) ; } else throw te ; } catch ( Exception e ) { while ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) { e = ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ; } String msg = e . getMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { msg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_XPATH_ERROR , null ) ; } TransformerException te = new TransformerException ( msg , getLocator ( ) , e ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . fatalError ( te ) ; } else throw te ; } finally { xctxt . popNamespaceContext ( ) ; xctxt . popCurrentNodeAndExpression ( ) ; } return xobj ; } public boolean bool ( XPathContext xctxt , int contextNode , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { xctxt . pushNamespaceContext ( namespaceContext ) ; xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; try { return m_mainExp . bool ( xctxt ) ; } catch ( TransformerException te ) { te . setLocator ( this . getLocator ( ) ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . error ( te ) ; } else throw te ; } catch ( Exception e ) { while ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) { e = ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ; } String msg = e . getMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { msg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_XPATH_ERROR , null ) ; } TransformerException te = new TransformerException ( msg , getLocator ( ) , e ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . fatalError ( te ) ; } else throw te ; } finally { xctxt . popNamespaceContext ( ) ; xctxt . popCurrentNodeAndExpression ( ) ; } return false ; } private static final boolean DEBUG_MATCHES = false ; public double getMatchScore ( XPathContext xctxt , int context ) throws javax . xml . transform . TransformerException { xctxt . pushCurrentNode ( context ) ; xctxt . pushCurrentExpressionNode ( context ) ; try { XObject score = m_mainExp . execute ( xctxt ) ; if ( DEBUG_MATCHES ) { DTM dtm = xctxt . getDTM ( context ) ; System . out . println ( "score: " + score . num ( ) + " for " + dtm . getNodeName ( context ) + " for xpath " + this . getPatternString ( ) ) ; } return score . num ( ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . popCurrentExpressionNode ( ) ; } } public void installFunction ( String name , int funcIndex , Function func ) { FunctionTable . installFunction ( func , funcIndex ) ; } public void warn ( XPathContext xctxt , int sourceNode , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; ErrorListener ehandler = xctxt . getErrorListener ( ) ; if ( null != ehandler ) { ehandler . warning ( new TransformerException ( fmsg , ( SAXSourceLocator ) xctxt . getSAXLocator ( ) ) ) ; } } public void assertion ( boolean b , String msg ) { if ( ! b ) { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } public void error ( XPathContext xctxt , int sourceNode , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; ErrorListener ehandler = xctxt . getErrorListener ( ) ; if ( null != ehandler ) { ehandler . fatalError ( new TransformerException ( fmsg , ( SAXSourceLocator ) xctxt . getSAXLocator ( ) ) ) ; } else { SourceLocator slocator = xctxt . getSAXLocator ( ) ; System . out . println ( fmsg + "; file " + slocator . getSystemId ( ) + "; line " + slocator . getLineNumber ( ) + "; column " + slocator . getColumnNumber ( ) ) ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { m_mainExp . callVisitors ( this , visitor ) ; } public static final double MATCH_SCORE_NONE = Double . NEGATIVE_INFINITY ; public static final double MATCH_SCORE_QNAME = 0.0 ; public static final double MATCH_SCORE_NSWILD = - 0.25 ; public static final double MATCH_SCORE_NODETEST = - 0.5 ; public static final double MATCH_SCORE_OTHER = 0.5 ; } 	1	['17', '1', '0', '61', '64', '78', '46', '15', '17', '0.96875', '462', '0.2', '1', '0', '0.219607843', '0', '0', '25.58823529', '2', '0.9412', '1']
package org . apache . xml . dtm . ref . sax2dtm ; import org . apache . xml . dtm . * ; import org . apache . xml . dtm . ref . * ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringDefault ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . serializer . SerializationHandler ; import javax . xml . transform . Source ; import java . util . Vector ; import org . apache . xml . utils . IntStack ; import org . xml . sax . * ; public class SAX2DTM2 extends SAX2DTM { public final class ChildrenIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : _firstch2 ( makeNodeIdentity ( node ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode != NULL ) { int node = _currentNode ; _currentNode = _nextsib2 ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } return END ; } } public final class ParentIterator extends InternalAxisIteratorBase { private int _nodeType = DTM . NULL ; public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; if ( node != DTM . NULL ) _currentNode = _parent2 ( makeNodeIdentity ( node ) ) ; else _currentNode = DTM . NULL ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator setNodeType ( final int type ) { _nodeType = type ; return this ; } public int next ( ) { int result = _currentNode ; if ( result == END ) return DTM . NULL ; if ( _nodeType == NULL ) { _currentNode = END ; return returnNode ( makeNodeHandle ( result ) ) ; } else if ( _nodeType >= DTM . NTYPES ) { if ( _nodeType == _exptype2 ( result ) ) { _currentNode = END ; return returnNode ( makeNodeHandle ( result ) ) ; } } else { if ( _nodeType == _type2 ( result ) ) { _currentNode = END ; return returnNode ( makeNodeHandle ( result ) ) ; } } return DTM . NULL ; } } public final class TypedChildrenIterator extends InternalAxisIteratorBase { private final int _nodeType ; public TypedChildrenIterator ( int nodeType ) { _nodeType = nodeType ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : _firstch2 ( makeNodeIdentity ( _startNode ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; if ( node == DTM . NULL ) return DTM . NULL ; final int nodeType = _nodeType ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( node != DTM . NULL && _exptype2 ( node ) != nodeType ) { node = _nextsib2 ( node ) ; } } else { int eType ; while ( node != DTM . NULL ) { eType = _exptype2 ( node ) ; if ( eType >= DTM . NTYPES ) break ; else node = _nextsib2 ( node ) ; } } if ( node == DTM . NULL ) { _currentNode = DTM . NULL ; return DTM . NULL ; } else { _currentNode = _nextsib2 ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } public int getNodeByPosition ( int position ) { if ( position <= 0 ) return DTM . NULL ; int node = _currentNode ; int pos = 0 ; final int nodeType = _nodeType ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( node != DTM . NULL ) { if ( _exptype2 ( node ) == nodeType ) { pos ++ ; if ( pos == position ) return makeNodeHandle ( node ) ; } node = _nextsib2 ( node ) ; } return NULL ; } else { while ( node != DTM . NULL ) { if ( _exptype2 ( node ) >= DTM . NTYPES ) { pos ++ ; if ( pos == position ) return makeNodeHandle ( node ) ; } node = _nextsib2 ( node ) ; } return NULL ; } } } public class TypedRootIterator extends RootIterator { private final int _nodeType ; public TypedRootIterator ( int nodeType ) { super ( ) ; _nodeType = nodeType ; } public int next ( ) { if ( _startNode == _currentNode ) return NULL ; final int node = _startNode ; int expType = _exptype2 ( makeNodeIdentity ( node ) ) ; _currentNode = node ; if ( _nodeType >= DTM . NTYPES ) { if ( _nodeType == expType ) { return returnNode ( node ) ; } } else { if ( expType < DTM . NTYPES ) { if ( expType == _nodeType ) { return returnNode ( node ) ; } } else { if ( m_extendedTypes [ expType ] . getNodeType ( ) == _nodeType ) { return returnNode ( node ) ; } } } return NULL ; } } public class FollowingSiblingIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = makeNodeIdentity ( node ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { _currentNode = ( _currentNode == DTM . NULL ) ? DTM . NULL : _nextsib2 ( _currentNode ) ; return returnNode ( makeNodeHandle ( _currentNode ) ) ; } } public final class TypedFollowingSiblingIterator extends FollowingSiblingIterator { private final int _nodeType ; public TypedFollowingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { if ( _currentNode == DTM . NULL ) { return DTM . NULL ; } int node = _currentNode ; final int nodeType = _nodeType ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( ( node = _nextsib2 ( node ) ) != DTM . NULL && _exptype2 ( node ) != nodeType ) { } } else { while ( ( node = _nextsib2 ( node ) ) != DTM . NULL && _exptype2 ( node ) < DTM . NTYPES ) { } } _currentNode = node ; return ( node == DTM . NULL ) ? DTM . NULL : returnNode ( makeNodeHandle ( node ) ) ; } } public final class AttributeIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getFirstAttributeIdentity ( makeNodeIdentity ( node ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _currentNode ; if ( node != NULL ) { _currentNode = getNextAttributeIdentity ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } return NULL ; } } public final class TypedAttributeIterator extends InternalAxisIteratorBase { private final int _nodeType ; public TypedAttributeIterator ( int nodeType ) { _nodeType = nodeType ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = node ; _currentNode = getTypedAttribute ( node , _nodeType ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _currentNode ; _currentNode = NULL ; return returnNode ( node ) ; } } public class PrecedingSiblingIterator extends InternalAxisIteratorBase { protected int _startNodeID ; public boolean isReverse ( ) { return true ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; node = _startNodeID = makeNodeIdentity ( node ) ; if ( node == NULL ) { _currentNode = node ; return resetPosition ( ) ; } int type = _type2 ( node ) ; if ( ExpandedNameTable . ATTRIBUTE == type || ExpandedNameTable . NAMESPACE == type ) { _currentNode = node ; } else { _currentNode = _parent2 ( node ) ; if ( NULL != _currentNode ) _currentNode = _firstch2 ( _currentNode ) ; else _currentNode = node ; } return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode == _startNodeID || _currentNode == DTM . NULL ) { return NULL ; } else { final int node = _currentNode ; _currentNode = _nextsib2 ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } } public final class TypedPrecedingSiblingIterator extends PrecedingSiblingIterator { private final int _nodeType ; public TypedPrecedingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node = _currentNode ; final int nodeType = _nodeType ; final int startNodeID = _startNodeID ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( node != NULL && node != startNodeID && _exptype2 ( node ) != nodeType ) { node = _nextsib2 ( node ) ; } } else { while ( node != NULL && node != startNodeID && _exptype2 ( node ) < DTM . NTYPES ) { node = _nextsib2 ( node ) ; } } if ( node == DTM . NULL || node == startNodeID ) { _currentNode = NULL ; return NULL ; } else { _currentNode = _nextsib2 ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } public int getLast ( ) { if ( _last != - 1 ) return _last ; setMark ( ) ; int node = _currentNode ; final int nodeType = _nodeType ; final int startNodeID = _startNodeID ; int last = 0 ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( node != NULL && node != startNodeID ) { if ( _exptype2 ( node ) == nodeType ) { last ++ ; } node = _nextsib2 ( node ) ; } } else { while ( node != NULL && node != startNodeID ) { if ( _exptype2 ( node ) >= DTM . NTYPES ) { last ++ ; } node = _nextsib2 ( node ) ; } } gotoMark ( ) ; return ( _last = last ) ; } } public class PrecedingIterator extends InternalAxisIteratorBase { private final int _maxAncestors = 8 ; protected int [ ] _stack = new int [ _maxAncestors ] ; protected int _sp , _oldsp ; protected int _markedsp , _markedNode , _markedDescendant ; public boolean isReverse ( ) { return true ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final PrecedingIterator clone = ( PrecedingIterator ) super . clone ( ) ; final int [ ] stackCopy = new int [ _stack . length ] ; System . arraycopy ( _stack , 0 , stackCopy , 0 , _stack . length ) ; clone . _stack = stackCopy ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { node = makeNodeIdentity ( node ) ; int parent , index ; if ( _type2 ( node ) == DTM . ATTRIBUTE_NODE ) node = _parent2 ( node ) ; _startNode = node ; _stack [ index = 0 ] = node ; parent = node ; while ( ( parent = _parent2 ( parent ) ) != NULL ) { if ( ++ index == _stack . length ) { final int [ ] stack = new int [ index * 2 ] ; System . arraycopy ( _stack , 0 , stack , 0 , index ) ; _stack = stack ; } _stack [ index ] = parent ; } if ( index > 0 ) -- index ; _currentNode = _stack [ index ] ; _oldsp = _sp = index ; return resetPosition ( ) ; } return this ; } public int next ( ) { for ( ++ _currentNode ; _sp >= 0 ; ++ _currentNode ) { if ( _currentNode < _stack [ _sp ] ) { int type = _type2 ( _currentNode ) ; if ( type != ATTRIBUTE_NODE && type != NAMESPACE_NODE ) return returnNode ( makeNodeHandle ( _currentNode ) ) ; } else -- _sp ; } return NULL ; } public DTMAxisIterator reset ( ) { _sp = _oldsp ; return resetPosition ( ) ; } public void setMark ( ) { _markedsp = _sp ; _markedNode = _currentNode ; _markedDescendant = _stack [ 0 ] ; } public void gotoMark ( ) { _sp = _markedsp ; _currentNode = _markedNode ; } } public final class TypedPrecedingIterator extends PrecedingIterator { private final int _nodeType ; public TypedPrecedingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node = _currentNode ; final int nodeType = _nodeType ; if ( nodeType >= DTM . NTYPES ) { while ( true ) { node ++ ; if ( _sp < 0 ) { node = NULL ; break ; } else if ( node >= _stack [ _sp ] ) { if ( -- _sp < 0 ) { node = NULL ; break ; } } else if ( _exptype2 ( node ) == nodeType ) { break ; } } } else { int expType ; while ( true ) { node ++ ; if ( _sp < 0 ) { node = NULL ; break ; } else if ( node >= _stack [ _sp ] ) { if ( -- _sp < 0 ) { node = NULL ; break ; } } else { expType = _exptype2 ( node ) ; if ( expType < DTM . NTYPES ) { if ( expType == nodeType ) { break ; } } else { if ( m_extendedTypes [ expType ] . getNodeType ( ) == nodeType ) { break ; } } } } } _currentNode = node ; return ( node == NULL ) ? NULL : returnNode ( makeNodeHandle ( node ) ) ; } } public class FollowingIterator extends InternalAxisIteratorBase { public FollowingIterator ( ) { } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; node = makeNodeIdentity ( node ) ; int first ; int type = _type2 ( node ) ; if ( ( DTM . ATTRIBUTE_NODE == type ) || ( DTM . NAMESPACE_NODE == type ) ) { node = _parent2 ( node ) ; first = _firstch2 ( node ) ; if ( NULL != first ) { _currentNode = makeNodeHandle ( first ) ; return resetPosition ( ) ; } } do { first = _nextsib2 ( node ) ; if ( NULL == first ) node = _parent2 ( node ) ; } while ( NULL == first && NULL != node ) ; _currentNode = makeNodeHandle ( first ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; int current = makeNodeIdentity ( node ) ; while ( true ) { current ++ ; int type = _type2 ( current ) ; if ( NULL == type ) { _currentNode = NULL ; return returnNode ( node ) ; } if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) continue ; _currentNode = makeNodeHandle ( current ) ; return returnNode ( node ) ; } } } public final class TypedFollowingIterator extends FollowingIterator { private final int _nodeType ; public TypedFollowingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int current ; int node ; int type ; final int nodeType = _nodeType ; int currentNodeID = makeNodeIdentity ( _currentNode ) ; if ( nodeType >= DTM . NTYPES ) { do { node = currentNodeID ; current = node ; do { current ++ ; type = _type2 ( current ) ; } while ( type != NULL && ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) ) ; currentNodeID = ( type != NULL ) ? current : NULL ; } while ( node != DTM . NULL && _exptype2 ( node ) != nodeType ) ; } else { do { node = currentNodeID ; current = node ; do { current ++ ; type = _type2 ( current ) ; } while ( type != NULL && ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) ) ; currentNodeID = ( type != NULL ) ? current : NULL ; } while ( node != DTM . NULL && ( _exptype2 ( node ) != nodeType && _type2 ( node ) != nodeType ) ) ; } _currentNode = makeNodeHandle ( currentNodeID ) ; return ( node == DTM . NULL ? DTM . NULL : returnNode ( makeNodeHandle ( node ) ) ) ; } } public class AncestorIterator extends InternalAxisIteratorBase { private static final int m_blocksize = 32 ; int [ ] m_ancestors = new int [ m_blocksize ] ; int m_size = 0 ; int m_ancestorsPos ; int m_markedPos ; int m_realStartNode ; public int getStartNode ( ) { return m_realStartNode ; } public final boolean isReverse ( ) { return true ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final AncestorIterator clone = ( AncestorIterator ) super . clone ( ) ; clone . _startNode = _startNode ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; m_realStartNode = node ; if ( _isRestartable ) { int nodeID = makeNodeIdentity ( node ) ; m_size = 0 ; if ( nodeID == DTM . NULL ) { _currentNode = DTM . NULL ; m_ancestorsPos = 0 ; return this ; } if ( ! _includeSelf ) { nodeID = _parent2 ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } _startNode = node ; while ( nodeID != END ) { if ( m_size >= m_ancestors . length ) { int [ ] newAncestors = new int [ m_size * 2 ] ; System . arraycopy ( m_ancestors , 0 , newAncestors , 0 , m_ancestors . length ) ; m_ancestors = newAncestors ; } m_ancestors [ m_size ++ ] = node ; nodeID = _parent2 ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } m_ancestorsPos = m_size - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { m_ancestorsPos = m_size - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; return resetPosition ( ) ; } public int next ( ) { int next = _currentNode ; int pos = -- m_ancestorsPos ; _currentNode = ( pos >= 0 ) ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; return returnNode ( next ) ; } public void setMark ( ) { m_markedPos = m_ancestorsPos ; } public void gotoMark ( ) { m_ancestorsPos = m_markedPos ; _currentNode = m_ancestorsPos >= 0 ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; } } public final class TypedAncestorIterator extends AncestorIterator { private final int _nodeType ; public TypedAncestorIterator ( int type ) { _nodeType = type ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; m_realStartNode = node ; if ( _isRestartable ) { int nodeID = makeNodeIdentity ( node ) ; m_size = 0 ; if ( nodeID == DTM . NULL ) { _currentNode = DTM . NULL ; m_ancestorsPos = 0 ; return this ; } final int nodeType = _nodeType ; if ( ! _includeSelf ) { nodeID = _parent2 ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } _startNode = node ; if ( nodeType >= DTM . NTYPES ) { while ( nodeID != END ) { int eType = _exptype2 ( nodeID ) ; if ( eType == nodeType ) { if ( m_size >= m_ancestors . length ) { int [ ] newAncestors = new int [ m_size * 2 ] ; System . arraycopy ( m_ancestors , 0 , newAncestors , 0 , m_ancestors . length ) ; m_ancestors = newAncestors ; } m_ancestors [ m_size ++ ] = makeNodeHandle ( nodeID ) ; } nodeID = _parent2 ( nodeID ) ; } } else { while ( nodeID != END ) { int eType = _exptype2 ( nodeID ) ; if ( ( eType < DTM . NTYPES && eType == nodeType ) || ( eType >= DTM . NTYPES && m_extendedTypes [ eType ] . getNodeType ( ) == nodeType ) ) { if ( m_size >= m_ancestors . length ) { int [ ] newAncestors = new int [ m_size * 2 ] ; System . arraycopy ( m_ancestors , 0 , newAncestors , 0 , m_ancestors . length ) ; m_ancestors = newAncestors ; } m_ancestors [ m_size ++ ] = makeNodeHandle ( nodeID ) ; } nodeID = _parent2 ( nodeID ) ; } } m_ancestorsPos = m_size - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; return resetPosition ( ) ; } return this ; } public int getNodeByPosition ( int position ) { if ( position > 0 && position <= m_size ) { return m_ancestors [ position - 1 ] ; } else return DTM . NULL ; } public int getLast ( ) { return m_size ; } } public class DescendantIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { node = makeNodeIdentity ( node ) ; _startNode = node ; if ( _includeSelf ) node -- ; _currentNode = node ; return resetPosition ( ) ; } return this ; } protected final boolean isDescendant ( int identity ) { return ( _parent2 ( identity ) >= _startNode ) || ( _startNode == identity ) ; } public int next ( ) { final int startNode = _startNode ; if ( startNode == NULL ) { return NULL ; } if ( _includeSelf && ( _currentNode + 1 ) == startNode ) return returnNode ( makeNodeHandle ( ++ _currentNode ) ) ; int node = _currentNode ; int type ; if ( startNode == ROOTNODE ) { int eType ; do { node ++ ; eType = _exptype2 ( node ) ; if ( NULL == eType ) { _currentNode = NULL ; return END ; } } while ( eType == TEXT_NODE || ( type = m_extendedTypes [ eType ] . getNodeType ( ) ) == ATTRIBUTE_NODE || type == NAMESPACE_NODE ) ; } else { do { node ++ ; type = _type2 ( node ) ; if ( NULL == type || ! isDescendant ( node ) ) { _currentNode = NULL ; return END ; } } while ( ATTRIBUTE_NODE == type || TEXT_NODE == type || NAMESPACE_NODE == type ) ; } _currentNode = node ; return returnNode ( makeNodeHandle ( node ) ) ; } public DTMAxisIterator reset ( ) { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( makeNodeHandle ( _startNode ) ) ; _isRestartable = temp ; return this ; } } public final class TypedDescendantIterator extends DescendantIterator { private final int _nodeType ; public TypedDescendantIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { final int startNode = _startNode ; if ( _startNode == NULL ) { return NULL ; } int node = _currentNode ; int expType ; final int nodeType = _nodeType ; if ( nodeType != DTM . ELEMENT_NODE ) { do { node ++ ; expType = _exptype2 ( node ) ; if ( NULL == expType || _parent2 ( node ) < startNode && startNode != node ) { _currentNode = NULL ; return END ; } } while ( expType != nodeType ) ; } else if ( startNode == DTMDefaultBase . ROOTNODE ) { do { node ++ ; expType = _exptype2 ( node ) ; if ( NULL == expType ) { _currentNode = NULL ; return END ; } } while ( expType < DTM . NTYPES || m_extendedTypes [ expType ] . getNodeType ( ) != DTM . ELEMENT_NODE ) ; } else { do { node ++ ; expType = _exptype2 ( node ) ; if ( NULL == expType || _parent2 ( node ) < startNode && startNode != node ) { _currentNode = NULL ; return END ; } } while ( expType < DTM . NTYPES || m_extendedTypes [ expType ] . getNodeType ( ) != DTM . ELEMENT_NODE ) ; } _currentNode = node ; return returnNode ( makeNodeHandle ( node ) ) ; } } public final class TypedSingletonIterator extends SingletonIterator { private final int _nodeType ; public TypedSingletonIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { final int result = _currentNode ; if ( result == END ) return DTM . NULL ; _currentNode = END ; if ( _nodeType >= DTM . NTYPES ) { if ( _exptype2 ( makeNodeIdentity ( result ) ) == _nodeType ) { return returnNode ( result ) ; } } else { if ( _type2 ( makeNodeIdentity ( result ) ) == _nodeType ) { return returnNode ( result ) ; } } return NULL ; } } private int [ ] m_exptype_map0 ; private int [ ] m_nextsib_map0 ; private int [ ] m_firstch_map0 ; private int [ ] m_parent_map0 ; private int [ ] [ ] m_exptype_map ; private int [ ] [ ] m_nextsib_map ; private int [ ] [ ] m_firstch_map ; private int [ ] [ ] m_parent_map ; protected ExtendedType [ ] m_extendedTypes ; protected Vector m_values ; private int m_valueIndex = 0 ; private int m_maxNodeIndex ; protected int m_SHIFT ; protected int m_MASK ; protected int m_blocksize ; protected final static int TEXT_LENGTH_BITS = 10 ; protected final static int TEXT_OFFSET_BITS = 21 ; protected final static int TEXT_LENGTH_MAX = ( 1 << TEXT_LENGTH_BITS ) - 1 ; protected final static int TEXT_OFFSET_MAX = ( 1 << TEXT_OFFSET_BITS ) - 1 ; protected boolean m_buildIdIndex = true ; private static final String EMPTY_STR = "" ; private static final XMLString EMPTY_XML_STR = new XMLStringDefault ( "" ) ; public SAX2DTM2 ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { this ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , DEFAULT_BLOCKSIZE , true , true , false ) ; } public SAX2DTM2 ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib , boolean buildIdIndex , boolean newNameTable ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , usePrevsib , newNameTable ) ; int shift ; for ( shift = 0 ; ( blocksize >>>= 1 ) != 0 ; ++ shift ) ; m_blocksize = 1 << shift ; m_SHIFT = shift ; m_MASK = m_blocksize - 1 ; m_buildIdIndex = buildIdIndex ; m_values = new Vector ( 32 , 512 ) ; m_maxNodeIndex = 1 << DTMManager . IDENT_DTM_NODE_BITS ; m_exptype_map0 = m_exptype . getMap0 ( ) ; m_nextsib_map0 = m_nextsib . getMap0 ( ) ; m_firstch_map0 = m_firstch . getMap0 ( ) ; m_parent_map0 = m_parent . getMap0 ( ) ; } public final int _exptype ( int identity ) { return m_exptype . elementAt ( identity ) ; } public final int _exptype2 ( int identity ) { if ( identity < m_blocksize ) return m_exptype_map0 [ identity ] ; else return m_exptype_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; } public final int _nextsib2 ( int identity ) { if ( identity < m_blocksize ) return m_nextsib_map0 [ identity ] ; else return m_nextsib_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; } public final int _firstch2 ( int identity ) { if ( identity < m_blocksize ) return m_firstch_map0 [ identity ] ; else return m_firstch_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; } public final int _parent2 ( int identity ) { if ( identity < m_blocksize ) return m_parent_map0 [ identity ] ; else return m_parent_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; } public final int _type2 ( int identity ) { int eType ; if ( identity < m_blocksize ) eType = m_exptype_map0 [ identity ] ; else eType = m_exptype_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; if ( NULL != eType ) return m_extendedTypes [ eType ] . getNodeType ( ) ; else return NULL ; } public final int getExpandedTypeID2 ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; if ( nodeID != NULL ) { if ( nodeID < m_blocksize ) return m_exptype_map0 [ nodeID ] ; else return m_exptype_map [ nodeID > > > m_SHIFT ] [ nodeID & m_MASK ] ; } else return NULL ; } public final int _exptype2Type ( int exptype ) { if ( NULL != exptype ) return m_extendedTypes [ exptype ] . getNodeType ( ) ; else return NULL ; } public int getIdForNamespace ( String uri ) { int index = m_values . indexOf ( uri ) ; if ( index < 0 ) { m_values . addElement ( uri ) ; return m_valueIndex ++ ; } else return index ; } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( uri , localName , DTM . ELEMENT_NODE ) ; int prefixIndex = ( qName . length ( ) != localName . length ( ) ) ? m_valuesOrPrefixes . stringToIndex ( qName ) : 0 ; int elemNode = addNode ( DTM . ELEMENT_NODE , exName , m_parents . peek ( ) , m_previous , prefixIndex , true ) ; if ( m_indexing ) indexNode ( exName , elemNode ) ; m_parents . push ( elemNode ) ; int startDecls = m_contextIndexes . peek ( ) ; int nDecls = m_prefixMappings . size ( ) ; String prefix ; if ( ! m_pastFirstElement ) { prefix = "xml" ; String declURL = "http://www.w3.org/XML/1998/namespace" ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; m_values . addElement ( declURL ) ; int val = m_valueIndex ++ ; addNode ( DTM . NAMESPACE_NODE , exName , elemNode , DTM . NULL , val , false ) ; m_pastFirstElement = true ; } for ( int i = startDecls ; i < nDecls ; i += 2 ) { prefix = ( String ) m_prefixMappings . elementAt ( i ) ; if ( prefix == null ) continue ; String declURL = ( String ) m_prefixMappings . elementAt ( i + 1 ) ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; m_values . addElement ( declURL ) ; int val = m_valueIndex ++ ; addNode ( DTM . NAMESPACE_NODE , exName , elemNode , DTM . NULL , val , false ) ; } int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String attrUri = attributes . getURI ( i ) ; String attrQName = attributes . getQName ( i ) ; String valString = attributes . getValue ( i ) ; int nodeType ; String attrLocalName = attributes . getLocalName ( i ) ; if ( ( null != attrQName ) && ( attrQName . equals ( "xmlns" ) || attrQName . startsWith ( "xmlns:" ) ) ) { prefix = getPrefix ( attrQName , attrUri ) ; if ( declAlreadyDeclared ( prefix ) ) continue ; nodeType = DTM . NAMESPACE_NODE ; } else { nodeType = DTM . ATTRIBUTE_NODE ; if ( m_buildIdIndex && attributes . getType ( i ) . equalsIgnoreCase ( "ID" ) ) setIDAttribute ( valString , elemNode ) ; } if ( null == valString ) valString = "" ; m_values . addElement ( valString ) ; int val = m_valueIndex ++ ; if ( attrLocalName . length ( ) != attrQName . length ( ) ) { prefixIndex = m_valuesOrPrefixes . stringToIndex ( attrQName ) ; int dataIndex = m_data . size ( ) ; m_data . addElement ( prefixIndex ) ; m_data . addElement ( val ) ; val = - dataIndex ; } exName = m_expandedNameTable . getExpandedTypeID ( attrUri , attrLocalName , nodeType ) ; addNode ( nodeType , exName , elemNode , DTM . NULL , val , false ) ; } if ( null != m_wsfilter ) { short wsv = m_wsfilter . getShouldStripSpace ( makeNodeHandle ( elemNode ) , this ) ; boolean shouldStrip = ( DTMWSFilter . INHERIT == wsv ) ? getShouldStripWhitespace ( ) : ( DTMWSFilter . STRIP == wsv ) ; pushShouldStripWhitespace ( shouldStrip ) ; } m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { charactersFlush ( ) ; m_contextIndexes . quickPop ( 1 ) ; int topContextIndex = m_contextIndexes . peek ( ) ; if ( topContextIndex != m_prefixMappings . size ( ) ) { m_prefixMappings . setSize ( topContextIndex ) ; } m_previous = m_parents . pop ( ) ; popShouldStripWhitespace ( ) ; } public void comment ( char ch [ ] , int start , int length ) throws SAXException { if ( m_insideDTD ) return ; charactersFlush ( ) ; m_values . addElement ( new String ( ch , start , length ) ) ; int dataIndex = m_valueIndex ++ ; m_previous = addNode ( DTM . COMMENT_NODE , DTM . COMMENT_NODE , m_parents . peek ( ) , m_previous , dataIndex , false ) ; } public void startDocument ( ) throws SAXException { int doc = addNode ( DTM . DOCUMENT_NODE , DTM . DOCUMENT_NODE , DTM . NULL , DTM . NULL , 0 , true ) ; m_parents . push ( doc ) ; m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endDocument ( ) throws SAXException { super . endDocument ( ) ; m_exptype . addElement ( NULL ) ; m_parent . addElement ( NULL ) ; m_nextsib . addElement ( NULL ) ; m_firstch . addElement ( NULL ) ; m_extendedTypes = m_expandedNameTable . getExtendedTypes ( ) ; m_exptype_map = m_exptype . getMap ( ) ; m_nextsib_map = m_nextsib . getMap ( ) ; m_firstch_map = m_firstch . getMap ( ) ; m_parent_map = m_parent . getMap ( ) ; } protected final int addNode ( int type , int expandedTypeID , int parentIndex , int previousSibling , int dataOrPrefix , boolean canHaveFirstChild ) { int nodeIndex = m_size ++ ; if ( nodeIndex == m_maxNodeIndex ) { addNewDTMID ( nodeIndex ) ; m_maxNodeIndex += ( 1 << DTMManager . IDENT_DTM_NODE_BITS ) ; } m_firstch . addElement ( DTM . NULL ) ; m_nextsib . addElement ( DTM . NULL ) ; m_parent . addElement ( parentIndex ) ; m_exptype . addElement ( expandedTypeID ) ; m_dataOrQName . addElement ( dataOrPrefix ) ; if ( m_prevsib != null ) { m_prevsib . addElement ( previousSibling ) ; } if ( m_locator != null && m_useSourceLocationProperty ) { setSourceLocation ( ) ; } switch ( type ) { case DTM . NAMESPACE_NODE : declareNamespaceInContext ( parentIndex , nodeIndex ) ; break ; case DTM . ATTRIBUTE_NODE : break ; default : if ( DTM . NULL != previousSibling ) { m_nextsib . setElementAt ( nodeIndex , previousSibling ) ; } else if ( DTM . NULL != parentIndex ) { m_firstch . setElementAt ( nodeIndex , parentIndex ) ; } break ; } return nodeIndex ; } protected final void charactersFlush ( ) { if ( m_textPendingStart >= 0 ) { int length = m_chars . size ( ) - m_textPendingStart ; boolean doStrip = false ; if ( getShouldStripWhitespace ( ) ) { doStrip = m_chars . isWhitespace ( m_textPendingStart , length ) ; } if ( doStrip ) m_chars . setLength ( m_textPendingStart ) ; else { if ( length <= TEXT_LENGTH_MAX && m_textPendingStart <= TEXT_OFFSET_MAX ) { m_previous = addNode ( m_coalescedTextType , DTM . TEXT_NODE , m_parents . peek ( ) , m_previous , length + ( m_textPendingStart << TEXT_LENGTH_BITS ) , false ) ; } else { int dataIndex = m_data . size ( ) ; m_previous = addNode ( m_coalescedTextType , DTM . TEXT_NODE , m_parents . peek ( ) , m_previous , - dataIndex , false ) ; m_data . addElement ( m_textPendingStart ) ; m_data . addElement ( length ) ; } } m_textPendingStart = - 1 ; m_textType = m_coalescedTextType = DTM . TEXT_NODE ; } } public void processingInstruction ( String target , String data ) throws SAXException { charactersFlush ( ) ; int dataIndex = m_data . size ( ) ; m_previous = addNode ( DTM . PROCESSING_INSTRUCTION_NODE , DTM . PROCESSING_INSTRUCTION_NODE , m_parents . peek ( ) , m_previous , - dataIndex , false ) ; m_data . addElement ( m_valuesOrPrefixes . stringToIndex ( target ) ) ; m_values . addElement ( data ) ; m_data . addElement ( m_valueIndex ++ ) ; } public final int getFirstAttribute ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; if ( nodeID == DTM . NULL ) return DTM . NULL ; int type = _type2 ( nodeID ) ; if ( DTM . ELEMENT_NODE == type ) { while ( true ) { nodeID ++ ; type = _type2 ( nodeID ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return makeNodeHandle ( nodeID ) ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } protected int getFirstAttributeIdentity ( int identity ) { if ( identity == NULL ) { return NULL ; } int type = _type2 ( identity ) ; if ( DTM . ELEMENT_NODE == type ) { while ( true ) { identity ++ ; type = _type2 ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return identity ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } protected int getNextAttributeIdentity ( int identity ) { while ( true ) { identity ++ ; int type = _type2 ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return identity ; } else if ( type != DTM . NAMESPACE_NODE ) { break ; } } return DTM . NULL ; } protected final int getTypedAttribute ( int nodeHandle , int attType ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; if ( nodeID == DTM . NULL ) return DTM . NULL ; int type = _type2 ( nodeID ) ; if ( DTM . ELEMENT_NODE == type ) { int expType ; while ( true ) { nodeID ++ ; expType = _exptype2 ( nodeID ) ; if ( expType != DTM . NULL ) type = m_extendedTypes [ expType ] . getNodeType ( ) ; else return DTM . NULL ; if ( type == DTM . ATTRIBUTE_NODE ) { if ( expType == attType ) return makeNodeHandle ( nodeID ) ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } public String getLocalName ( int nodeHandle ) { int expType = _exptype ( makeNodeIdentity ( nodeHandle ) ) ; if ( expType == DTM . PROCESSING_INSTRUCTION_NODE ) { int dataIndex = _dataOrQName ( makeNodeIdentity ( nodeHandle ) ) ; dataIndex = m_data . elementAt ( - dataIndex ) ; return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } else return m_expandedNameTable . getLocalName ( expType ) ; } public final String getNodeNameX ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; int eType = _exptype2 ( nodeID ) ; if ( eType == DTM . PROCESSING_INSTRUCTION_NODE ) { int dataIndex = _dataOrQName ( nodeID ) ; dataIndex = m_data . elementAt ( - dataIndex ) ; return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } final ExtendedType extType = m_extendedTypes [ eType ] ; if ( extType . getNamespace ( ) . length ( ) == 0 ) { return extType . getLocalName ( ) ; } else { int qnameIndex = m_dataOrQName . elementAt ( nodeID ) ; if ( qnameIndex == 0 ) return extType . getLocalName ( ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public String getNodeName ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; int eType = _exptype2 ( nodeID ) ; final ExtendedType extType = m_extendedTypes [ eType ] ; if ( extType . getNamespace ( ) . length ( ) == 0 ) { int type = extType . getNodeType ( ) ; String localName = extType . getLocalName ( ) ; if ( type == DTM . NAMESPACE_NODE ) { if ( localName . length ( ) == 0 ) return "xmlns" ; else return "xmlns:" + localName ; } else if ( type == DTM . PROCESSING_INSTRUCTION_NODE ) { int dataIndex = _dataOrQName ( nodeID ) ; dataIndex = m_data . elementAt ( - dataIndex ) ; return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } else if ( localName . length ( ) == 0 ) { return m_fixednames [ type ] ; } else return localName ; } else { int qnameIndex = m_dataOrQName . elementAt ( nodeID ) ; if ( qnameIndex == 0 ) return extType . getLocalName ( ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public XMLString getStringValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return EMPTY_XML_STR ; int type = _type2 ( identity ) ; if ( type == DTM . ELEMENT_NODE || type == DTM . DOCUMENT_NODE ) { int startNode = identity ; identity = _firstch2 ( identity ) ; if ( DTM . NULL != identity ) { int offset = - 1 ; int length = 0 ; do { type = _exptype2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( - 1 == offset ) { offset = dataIndex > > > TEXT_LENGTH_BITS ; } length += dataIndex & TEXT_LENGTH_MAX ; } else { if ( - 1 == offset ) { offset = m_data . elementAt ( - dataIndex ) ; } length += m_data . elementAt ( - dataIndex + 1 ) ; } } identity ++ ; } while ( _parent2 ( identity ) >= startNode ) ; if ( length > 0 ) { if ( m_xstrf != null ) return m_xstrf . newstr ( m_chars , offset , length ) ; else return new XMLStringDefault ( m_chars . getString ( offset , length ) ) ; } else return EMPTY_XML_STR ; } else return EMPTY_XML_STR ; } else if ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( m_xstrf != null ) return m_xstrf . newstr ( m_chars , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; else return new XMLStringDefault ( m_chars . getString ( dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ) ; } else { if ( m_xstrf != null ) return m_xstrf . newstr ( m_chars , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; else return new XMLStringDefault ( m_chars . getString ( m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ) ; } } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } if ( m_xstrf != null ) return m_xstrf . newstr ( ( String ) m_values . elementAt ( dataIndex ) ) ; else return new XMLStringDefault ( ( String ) m_values . elementAt ( dataIndex ) ) ; } } public final String getStringValueX ( final int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return EMPTY_STR ; int type = _type2 ( identity ) ; if ( type == DTM . ELEMENT_NODE || type == DTM . DOCUMENT_NODE ) { int startNode = identity ; identity = _firstch2 ( identity ) ; if ( DTM . NULL != identity ) { int offset = - 1 ; int length = 0 ; do { type = _exptype2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( - 1 == offset ) { offset = dataIndex > > > TEXT_LENGTH_BITS ; } length += dataIndex & TEXT_LENGTH_MAX ; } else { if ( - 1 == offset ) { offset = m_data . elementAt ( - dataIndex ) ; } length += m_data . elementAt ( - dataIndex + 1 ) ; } } identity ++ ; } while ( _parent2 ( identity ) >= startNode ) ; if ( length > 0 ) { return m_chars . getString ( offset , length ) ; } else return EMPTY_STR ; } else return EMPTY_STR ; } else if ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { return m_chars . getString ( dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { return m_chars . getString ( m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return ( String ) m_values . elementAt ( dataIndex ) ; } } public String getStringValue ( ) { int child = _firstch2 ( ROOTNODE ) ; if ( child == DTM . NULL ) return EMPTY_STR ; if ( ( _exptype2 ( child ) == DTM . TEXT_NODE ) && ( _nextsib2 ( child ) == DTM . NULL ) ) { int dataIndex = m_dataOrQName . elementAt ( child ) ; if ( dataIndex > 0 ) return m_chars . getString ( dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; else return m_chars . getString ( m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } else return getStringValueX ( getDocument ( ) ) ; } public final void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws SAXException { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return ; int type = _type2 ( identity ) ; if ( type == DTM . ELEMENT_NODE || type == DTM . DOCUMENT_NODE ) { int startNode = identity ; identity = _firstch2 ( identity ) ; if ( DTM . NULL != identity ) { int offset = - 1 ; int length = 0 ; do { type = _exptype2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( - 1 == offset ) { offset = dataIndex > > > TEXT_LENGTH_BITS ; } length += dataIndex & TEXT_LENGTH_MAX ; } else { if ( - 1 == offset ) { offset = m_data . elementAt ( - dataIndex ) ; } length += m_data . elementAt ( - dataIndex + 1 ) ; } } identity ++ ; } while ( _parent2 ( identity ) >= startNode ) ; if ( length > 0 ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } } } else if ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; else m_chars . sendSAXcharacters ( ch , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; else m_chars . sendSAXcharacters ( ch , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } String str = ( String ) m_values . elementAt ( dataIndex ) ; if ( normalize ) FastStringBuffer . sendNormalizedSAXcharacters ( str . toCharArray ( ) , 0 , str . length ( ) , ch ) ; else ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } } public String getNodeValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type = _type2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex > 0 ) { return m_chars . getString ( dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { return m_chars . getString ( m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } } else if ( DTM . ELEMENT_NODE == type || DTM . DOCUMENT_FRAGMENT_NODE == type || DTM . DOCUMENT_NODE == type ) { return null ; } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return ( String ) m_values . elementAt ( dataIndex ) ; } } protected final void copyTextNode ( final int nodeID , SerializationHandler handler ) throws SAXException { if ( nodeID != DTM . NULL ) { int dataIndex = m_dataOrQName . elementAt ( nodeID ) ; if ( dataIndex > 0 ) { m_chars . sendSAXcharacters ( handler , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { m_chars . sendSAXcharacters ( handler , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } } } protected final String copyElement ( int nodeID , int exptype , SerializationHandler handler ) throws SAXException { final ExtendedType extType = m_extendedTypes [ exptype ] ; String uri = extType . getNamespace ( ) ; String name = extType . getLocalName ( ) ; if ( uri . length ( ) == 0 ) { handler . startElement ( name ) ; return name ; } else { int qnameIndex = m_dataOrQName . elementAt ( nodeID ) ; if ( qnameIndex == 0 ) { handler . startElement ( name ) ; handler . namespaceAfterStartElement ( EMPTY_STR , uri ) ; return name ; } if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } String qName = m_valuesOrPrefixes . indexToString ( qnameIndex ) ; handler . startElement ( qName ) ; int prefixIndex = qName . indexOf ( ':' ) ; String prefix ; if ( prefixIndex > 0 ) { prefix = qName . substring ( 0 , prefixIndex ) ; } else { prefix = null ; } handler . namespaceAfterStartElement ( prefix , uri ) ; return qName ; } } protected final void copyNS ( final int nodeID , SerializationHandler handler , boolean inScope ) throws SAXException { final int node = makeNodeHandle ( nodeID ) ; for ( int current = getFirstNamespaceNode ( node , inScope ) ; current != DTM . NULL ; current = getNextNamespaceNode ( node , current , inScope ) ) { handler . namespaceAfterStartElement ( getNodeNameX ( current ) , getNodeValue ( current ) ) ; } } protected final void copyAttributes ( final int nodeID , SerializationHandler handler ) throws SAXException { for ( int current = getFirstAttributeIdentity ( nodeID ) ; current != DTM . NULL ; current = getNextAttributeIdentity ( current ) ) { int eType = _exptype2 ( current ) ; copyAttribute ( current , eType , handler ) ; } } protected final void copyAttribute ( int nodeID , int exptype , SerializationHandler handler ) throws SAXException { final ExtendedType extType = m_extendedTypes [ exptype ] ; final String uri = extType . getNamespace ( ) ; final String localName = extType . getLocalName ( ) ; String prefix = null ; String qname = null ; int dataIndex = _dataOrQName ( nodeID ) ; int valueIndex = dataIndex ; if ( uri . length ( ) != 0 ) { if ( dataIndex <= 0 ) { int prefixIndex = m_data . elementAt ( - dataIndex ) ; valueIndex = m_data . elementAt ( - dataIndex + 1 ) ; qname = m_valuesOrPrefixes . indexToString ( prefixIndex ) ; int colonIndex = qname . indexOf ( ':' ) ; if ( colonIndex > 0 ) { prefix = qname . substring ( 0 , colonIndex ) ; } } handler . namespaceAfterStartElement ( prefix , uri ) ; } String nodeName = ( prefix != null ) ? qname : localName ; String nodeValue = ( String ) m_values . elementAt ( valueIndex ) ; handler . addAttribute ( nodeName , nodeValue ) ; } } 	1	['37', '5', '1', '34', '111', '284', '20', '14', '26', '0.797979798', '2307', '1', '2', '0.830845771', '0.206018519', '2', '33', '60.75675676', '20', '3.5135', '3']
package org . apache . xml . serializer ; public final class Method { public static final String XML = "xml" ; public static final String HTML = "html" ; public static final String XHTML = "xhtml" ; public static final String TEXT = "text" ; public static final String UNKNOWN = "" ; } 	1	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '9', '0', '0', '0', '1', '0', '0', '3', '0', '0', '1']
package org . apache . xpath . compiler ; public class OpMapVector { protected int m_blocksize ; protected int m_map [ ] ; protected int m_lengthPos = 0 ; protected int m_mapSize ; public OpMapVector ( int blocksize , int increaseSize , int lengthPos ) { m_blocksize = increaseSize ; m_mapSize = blocksize ; m_lengthPos = lengthPos ; m_map = new int [ blocksize ] ; } public final int elementAt ( int i ) { return m_map [ i ] ; } public final void setElementAt ( int value , int index ) { if ( index >= m_mapSize ) { int oldSize = m_mapSize ; m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , oldSize ) ; m_map = newMap ; } m_map [ index ] = value ; } public final void setToSize ( int size ) { int newMap [ ] = new int [ size ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map [ m_lengthPos ] ) ; m_mapSize = size ; m_map = newMap ; } } 	1	['4', '1', '0', '2', '6', '0', '2', '0', '4', '0.416666667', '87', '1', '0', '0', '1', '0', '0', '19.75', '2', '1', '1']
package org . apache . xml . utils ; import java . io . PrintStream ; import java . io . PrintWriter ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class DefaultErrorHandler implements ErrorHandler , ErrorListener { PrintWriter m_pw ; public DefaultErrorHandler ( PrintWriter pw ) { m_pw = pw ; } public DefaultErrorHandler ( PrintStream pw ) { m_pw = new PrintWriter ( pw , true ) ; } public DefaultErrorHandler ( ) { m_pw = new PrintWriter ( System . err , true ) ; } public void warning ( SAXParseException exception ) throws SAXException { printLocation ( m_pw , exception ) ; m_pw . println ( "Parser warning: " + exception . getMessage ( ) ) ; } public void error ( SAXParseException exception ) throws SAXException { throw exception ; } public void fatalError ( SAXParseException exception ) throws SAXException { throw exception ; } public void warning ( TransformerException exception ) throws TransformerException { printLocation ( m_pw , exception ) ; m_pw . println ( exception . getMessage ( ) ) ; } public void error ( TransformerException exception ) throws TransformerException { throw exception ; } public void fatalError ( TransformerException exception ) throws TransformerException { throw exception ; } public static void ensureLocationSet ( TransformerException exception ) { SourceLocator locator = null ; Throwable cause = exception ; do { if ( cause instanceof SAXParseException ) { locator = new SAXSourceLocator ( ( SAXParseException ) cause ) ; } else if ( cause instanceof TransformerException ) { SourceLocator causeLocator = ( ( TransformerException ) cause ) . getLocator ( ) ; if ( null != causeLocator ) locator = causeLocator ; } if ( cause instanceof TransformerException ) cause = ( ( TransformerException ) cause ) . getCause ( ) ; else if ( cause instanceof SAXException ) cause = ( ( SAXException ) cause ) . getException ( ) ; else cause = null ; } while ( null != cause ) ; exception . setLocator ( locator ) ; } public static void printLocation ( PrintStream pw , TransformerException exception ) { printLocation ( new PrintWriter ( pw ) , exception ) ; } public static void printLocation ( java . io . PrintStream pw , org . xml . sax . SAXParseException exception ) { printLocation ( new PrintWriter ( pw ) , exception ) ; } public static void printLocation ( PrintWriter pw , Throwable exception ) { SourceLocator locator = null ; Throwable cause = exception ; do { if ( cause instanceof SAXParseException ) { locator = new SAXSourceLocator ( ( SAXParseException ) cause ) ; } else if ( cause instanceof TransformerException ) { SourceLocator causeLocator = ( ( TransformerException ) cause ) . getLocator ( ) ; if ( null != causeLocator ) locator = causeLocator ; } if ( cause instanceof TransformerException ) cause = ( ( TransformerException ) cause ) . getCause ( ) ; else if ( cause instanceof WrappedRuntimeException ) cause = ( ( WrappedRuntimeException ) cause ) . getException ( ) ; else if ( cause instanceof SAXException ) cause = ( ( SAXException ) cause ) . getException ( ) ; else cause = null ; } while ( null != cause ) ; if ( null != locator ) { String id = ( null != locator . getPublicId ( ) ) ? locator . getPublicId ( ) : ( null != locator . getSystemId ( ) ) ? locator . getSystemId ( ) : XMLMessages . createXMLMessage ( XMLErrorResources . ER_SYSTEMID_UNKNOWN , null ) ; pw . print ( id + "; " + XMLMessages . createXMLMessage ( "line" , null ) + locator . getLineNumber ( ) + "; " + XMLMessages . createXMLMessage ( "column" , null ) + locator . getColumnNumber ( ) + "; " ) ; } else pw . print ( "(" + XMLMessages . createXMLMessage ( XMLErrorResources . ER_LOCATION_UNKNOWN , null ) + ")" ) ; } } 	1	['13', '1', '0', '10', '35', '58', '7', '3', '13', '0.666666667', '260', '0', '0', '0', '0.307692308', '0', '0', '18.92307692', '11', '2', '1']
package org . apache . xalan . trace ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; public class SelectionEvent implements java . util . EventListener { public final ElemTemplateElement m_styleNode ; public final TransformerImpl m_processor ; public final Node m_sourceNode ; public final String m_attributeName ; public final XPath m_xpath ; public final XObject m_selection ; public SelectionEvent ( TransformerImpl processor , Node sourceNode , ElemTemplateElement styleNode , String attributeName , XPath xpath , XObject selection ) { this . m_processor = processor ; this . m_sourceNode = sourceNode ; this . m_styleNode = styleNode ; this . m_attributeName = attributeName ; this . m_xpath = xpath ; this . m_selection = selection ; } } 	1	['1', '1', '1', '8', '2', '0', '4', '4', '1', '2', '28', '0', '4', '0', '1', '0', '0', '21', '0', '0', '1']
package org . apache . xml . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XMLErrorResources_ko extends ListResourceBundle { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_CANNOT_OVERWRITE_CAUSE = "ER_CANNOT_OVERWRITE_CAUSE" ; public static final String ER_NO_DEFAULT_IMPL = "ER_NO_DEFAULT_IMPL" ; public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = "ER_CHUNKEDINTARRAY_NOT_SUPPORTED" ; public static final String ER_OFFSET_BIGGER_THAN_SLOT = "ER_OFFSET_BIGGER_THAN_SLOT" ; public static final String ER_COROUTINE_NOT_AVAIL = "ER_COROUTINE_NOT_AVAIL" ; public static final String ER_COROUTINE_CO_EXIT = "ER_COROUTINE_CO_EXIT" ; public static final String ER_COJOINROUTINESET_FAILED = "ER_COJOINROUTINESET_FAILED" ; public static final String ER_COROUTINE_PARAM = "ER_COROUTINE_PARAM" ; public static final String ER_PARSER_DOTERMINATE_ANSWERS = "ER_PARSER_DOTERMINATE_ANSWERS" ; public static final String ER_NO_PARSE_CALL_WHILE_PARSING = "ER_NO_PARSE_CALL_WHILE_PARSING" ; public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = "ER_ITERATOR_AXIS_NOT_IMPLEMENTED" ; public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = "ER_ITERATOR_CLONE_NOT_SUPPORTED" ; public static final String ER_UNKNOWN_AXIS_TYPE = "ER_UNKNOWN_AXIS_TYPE" ; public static final String ER_AXIS_NOT_SUPPORTED = "ER_AXIS_NOT_SUPPORTED" ; public static final String ER_NO_DTMIDS_AVAIL = "ER_NO_DTMIDS_AVAIL" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_NODE_NON_NULL = "ER_NODE_NON_NULL" ; public static final String ER_COULD_NOT_RESOLVE_NODE = "ER_COULD_NOT_RESOLVE_NODE" ; public static final String ER_STARTPARSE_WHILE_PARSING = "ER_STARTPARSE_WHILE_PARSING" ; public static final String ER_STARTPARSE_NEEDS_SAXPARSER = "ER_STARTPARSE_NEEDS_SAXPARSER" ; public static final String ER_COULD_NOT_INIT_PARSER = "ER_COULD_NOT_INIT_PARSER" ; public static final String ER_EXCEPTION_CREATING_POOL = "ER_EXCEPTION_CREATING_POOL" ; public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = "ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE" ; public static final String ER_SCHEME_REQUIRED = "ER_SCHEME_REQUIRED" ; public static final String ER_NO_SCHEME_IN_URI = "ER_NO_SCHEME_IN_URI" ; public static final String ER_NO_SCHEME_INURI = "ER_NO_SCHEME_INURI" ; public static final String ER_PATH_INVALID_CHAR = "ER_PATH_INVALID_CHAR" ; public static final String ER_SCHEME_FROM_NULL_STRING = "ER_SCHEME_FROM_NULL_STRING" ; public static final String ER_SCHEME_NOT_CONFORMANT = "ER_SCHEME_NOT_CONFORMANT" ; public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = "ER_HOST_ADDRESS_NOT_WELLFORMED" ; public static final String ER_PORT_WHEN_HOST_NULL = "ER_PORT_WHEN_HOST_NULL" ; public static final String ER_INVALID_PORT = "ER_INVALID_PORT" ; public static final String ER_FRAG_FOR_GENERIC_URI = "ER_FRAG_FOR_GENERIC_URI" ; public static final String ER_FRAG_WHEN_PATH_NULL = "ER_FRAG_WHEN_PATH_NULL" ; public static final String ER_FRAG_INVALID_CHAR = "ER_FRAG_INVALID_CHAR" ; public static final String ER_PARSER_IN_USE = "ER_PARSER_IN_USE" ; public static final String ER_CANNOT_CHANGE_WHILE_PARSING = "ER_CANNOT_CHANGE_WHILE_PARSING" ; public static final String ER_SELF_CAUSATION_NOT_PERMITTED = "ER_SELF_CAUSATION_NOT_PERMITTED" ; public static final String ER_NO_USERINFO_IF_NO_HOST = "ER_NO_USERINFO_IF_NO_HOST" ; public static final String ER_NO_PORT_IF_NO_HOST = "ER_NO_PORT_IF_NO_HOST" ; public static final String ER_NO_QUERY_STRING_IN_PATH = "ER_NO_QUERY_STRING_IN_PATH" ; public static final String ER_NO_FRAGMENT_STRING_IN_PATH = "ER_NO_FRAGMENT_STRING_IN_PATH" ; public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = "ER_CANNOT_INIT_URI_EMPTY_PARMS" ; public static final String ER_METHOD_NOT_SUPPORTED = "ER_METHOD_NOT_SUPPORTED" ; public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = "ER_INCRSAXSRCFILTER_NOT_RESTARTABLE" ; public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = "ER_XMLRDR_NOT_BEFORE_STARTPARSE" ; public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = "ER_AXIS_TRAVERSER_NOT_SUPPORTED" ; public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = "ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER" ; public static final String ER_SYSTEMID_UNKNOWN = "ER_SYSTEMID_UNKNOWN" ; public static final String ER_LOCATION_UNKNOWN = "ER_LOCATION_UNKNOWN" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = "ER_CREATEDOCUMENT_NOT_SUPPORTED" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT" ; public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = "ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT" ; public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = "ER_CANT_OUTPUT_TEXT_BEFORE_DOC" ; public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = "ER_CANT_HAVE_MORE_THAN_ONE_ROOT" ; public static final String ER_ARG_LOCALNAME_NULL = "ER_ARG_LOCALNAME_NULL" ; public static final String ER_ARG_LOCALNAME_INVALID = "ER_ARG_LOCALNAME_INVALID" ; public static final String ER_ARG_PREFIX_INVALID = "ER_ARG_PREFIX_INVALID" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_NAMESPACE_PREFIX = "ER_NAMESPACE_PREFIX" ; public static final String ER_STRAY_ATTRIBUTE = "ER_STRAY_ATTIRBUTE" ; public static final String ER_STRAY_NAMESPACE = "ER_STRAY_NAMESPACE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = "ER_COULD_NOT_LOAD_METHOD_PROPERTY" ; public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = "ER_SERIALIZER_NOT_CONTENTHANDLER" ; public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = "ER_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "함수가 지원되지 않습니다!" } , { ER_CANNOT_OVERWRITE_CAUSE , "원인을 겹쳐쓸 수 없습니다." } , { ER_NO_DEFAULT_IMPL , "기본 구현이 없습니다. " } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0})가 현재 지원되지 않습니다." } , { ER_OFFSET_BIGGER_THAN_SLOT , "오프셋이 슬롯보다 큽니다." } , { ER_COROUTINE_NOT_AVAIL , "Coroutine을 사용할 수 없습니다, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager가 co_exit() 요청을 받았습니다." } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet()가 실패했습니다." } , { ER_COROUTINE_PARAM , "Coroutine 매개변수 오류({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nUNEXPECTED: 구분 분석기 doTerminate가 {0}에 응답합니다." } , { ER_NO_PARSE_CALL_WHILE_PARSING , "구문 분석 중에는 parse를 호출할 수 없습니다." } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "오류: {0} 축에 대해 유형화된 반복기를 구현할 수 없습니다." } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "오류: {0} 축에 대한 반복기를 구현할 수 없습니다. " } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "반복기 복제가 지원되지 않습니다." } , { ER_UNKNOWN_AXIS_TYPE , "알 수 없는 axis traversal 유형: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Axis traverser가 지원되지 않습니다: {0}" } , { ER_NO_DTMIDS_AVAIL , "사용 가능한 추가 DTM ID가 없습니다." } , { ER_NOT_SUPPORTED , "지원되지 않습니다: {0}" } , { ER_NODE_NON_NULL , "getDTMHandleFromNode의 노드는 널(null) 이외의 값이어야 합니다." } , { ER_COULD_NOT_RESOLVE_NODE , "노드를 핸들로 분석할 수 없습니다." } , { ER_STARTPARSE_WHILE_PARSING , "구문 분석 중에는 startParse를 호출할 수 없습니다." } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse는 널(null)이 아닌 SAXParser를 필요로 합니다." } , { ER_COULD_NOT_INIT_PARSER , "구문 분석기를 초기화할 수 없습니다." } , { ER_EXCEPTION_CREATING_POOL , "풀의 새 인스턴스 작성 중 예외" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "경로에 잘못된 이스케이프 순서가 있습니다." } , { ER_SCHEME_REQUIRED , "설계가 필요합니다!" } , { ER_NO_SCHEME_IN_URI , "URI에 설계가 없습니다: {0}" } , { ER_NO_SCHEME_INURI , "URI에 설계가 없습니다." } , { ER_PATH_INVALID_CHAR , "경로에 잘못된 문자가 있습니다: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "널(null) 문자열에서 설계를 설정할 수 없습니다." } , { ER_SCHEME_NOT_CONFORMANT , "설계가 일치하지 않습니다." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "호스트가 완전한 주소가 아닙니다." } , { ER_PORT_WHEN_HOST_NULL , "호스트가 널(null)이면 포트를 설정할 수 없습니다." } , { ER_INVALID_PORT , "잘못된 포트 번호" } , { ER_FRAG_FOR_GENERIC_URI , "일반 URI에 대해서만 단편을 설정할 수 있습니다." } , { ER_FRAG_WHEN_PATH_NULL , "경로가 널(null)이면 단편을 설정할 수 없습니다." } , { ER_FRAG_INVALID_CHAR , "단편에 잘못된 문자가 있습니다." } , { ER_PARSER_IN_USE , "구문 분석기가 이미 사용 중입니다." } , { ER_CANNOT_CHANGE_WHILE_PARSING , "구문 분석 중에는 {0} {1}을(를) 변경할 수 없습니다." } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Self-causation이 허용되지 않습니다." } , { ER_NO_USERINFO_IF_NO_HOST , "호스트를 지정하지 않은 경우에는 Userinfo를 지정할 수 없습니다." } , { ER_NO_PORT_IF_NO_HOST , "호스트를 지정하지 않은 경우에는 포트를 지정할 수 없습니다." } , { ER_NO_QUERY_STRING_IN_PATH , "경로 및 조회 문자열에 조회 문자열을 지정할 수 없습니다." } , { ER_NO_FRAGMENT_STRING_IN_PATH , "경로 및 단편 둘 다에 단편을 지정할 수 없습니다." } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "빈 매개변수로 URI를 초기화할 수 없습니다." } , { ER_METHOD_NOT_SUPPORTED , "아직 메소드가 지원되지 않았습니다. " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "현재 IncrementalSAXSource_Filter를 다시 시작할 수 없습니다." } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "startParse 요청 전에 XMLReader를 시작했습니다." } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Axis traverser가 지원되지 않습니다: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "널(null) PrintWriter로 ListingErrorHandler를 작성했습니다!" } , { ER_SYSTEMID_UNKNOWN , "SystemId를 알 수 없습니다." } , { ER_LOCATION_UNKNOWN , "오류의 위치를 알 수 없습니다." } , { ER_PREFIX_MUST_RESOLVE , "접두부는 이름 공간으로 분석되어야 합니다: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "XPathContext에서 createDocument()가 지원되지 않습니다!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "하위 속성에 소유자 문서가 없습니다!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "하위 속성에 소유자 문서 요소가 없습니다!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "경고: 문서 요소 앞에 텍스트를 출력할 수 없습니다! 무시 중..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "DOM에 둘 이상의 루트가 있을 수 없습니다!" } , { ER_ARG_LOCALNAME_NULL , "'localName' 인수가 널(null)입니다." } , { ER_ARG_LOCALNAME_INVALID , "QNAME의 로컬 이름은 올바른 NCName이어야 합니다." } , { ER_ARG_PREFIX_INVALID , "QNAME의 접두부는 올바른 NCName이어야 합니다." } , { "BAD_CODE" , "createMessage에 대한 매개변수가 범위를 벗어납니다." } , { "FORMAT_FAILED" , "messageFormat 호출 중 예외 발생" } , { "line" , "행 #" } , { "column" , "열 #" } , { ER_SERIALIZER_NOT_CONTENTHANDLER , "''{0}'' 직렬화 프로그램 클래스가 org.xml.sax.ContentHandler를 구현하지 않습니다." } , { ER_RESOURCE_COULD_NOT_FIND , "[ {0} ] 자원을 찾을 수 없습니다.\n {1}" } , { ER_RESOURCE_COULD_NOT_LOAD , "[ {0} ] 자원이 {1} \n {2} \t {3}을(를) 로드할 수 없습니다. " } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "버퍼 크기 <=0" } , { ER_INVALID_UTF16_SURROGATE , "잘못된 UTF-16 대리자(surrogate)가 발견되었습니다: {0} ?" } , { ER_OIERROR , "IO 오류" } , { ER_ILLEGAL_ATTRIBUTE_POSITION , "하위 노드가 생성된 이후 또는 요소가 작성되기 이전에 {0} 속성을 추가할 수 없습니다. 속성이 무시됩니다." } , { ER_NAMESPACE_PREFIX , "''{0}'' 접두부에 대한 이름 공간이 선언되지 않았습니다." } , { ER_STRAY_ATTRIBUTE , "''{0}'' 속성이 요소의 외부에 있습니다." } , { ER_STRAY_NAMESPACE , "''{0}''=''{1}'' 이름 공간 선언이 요소의 외부에 있습니다." } , { ER_COULD_NOT_LOAD_RESOURCE , "''{0}''(CLASSPATH 확인)을(를) 로드할 수 없으므로, 현재 기본값만을 사용 중입니다." } , { ER_COULD_NOT_LOAD_METHOD_PROPERTY , "''{1}''출력 메소드(CLASSPATH 확인)에 대한 ''{0}'' 특성 파일을 로드할 수 없습니다." } } ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XMLErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XMLErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "ko" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.243589744', '1171', '0', '0', '0.926829268', '0.333333333', '0', '0', '217.6', '2', '0.8', '1']
package org . apache . xml . utils . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XResourceBundle extends ListResourceBundle { public static final String ERROR_RESOURCES = "org.apache.xalan.res.XSLTErrorResources" , XSLT_RESOURCE = "org.apache.xml.utils.res.XResourceBundle" , LANG_BUNDLE_NAME = "org.apache.xml.utils.res.XResources" , MULT_ORDER = "multiplierOrder" , MULT_PRECEDES = "precedes" , MULT_FOLLOWS = "follows" , LANG_ORIENTATION = "orientation" , LANG_RIGHTTOLEFT = "rightToLeft" , LANG_LEFTTORIGHT = "leftToRight" , LANG_NUMBERING = "numbering" , LANG_ADDITIVE = "additive" , LANG_MULT_ADD = "multiplicative-additive" , LANG_MULTIPLIER = "multiplier" , LANG_MULTIPLIER_CHAR = "multiplierChar" , LANG_NUMBERGROUPS = "numberGroups" , LANG_NUM_TABLES = "tables" , LANG_ALPHABET = "alphabet" , LANG_TRAD_ALPHABET = "tradAlphabet" ; public static final XResourceBundle loadResourceBundle ( String className , Locale locale ) throws MissingResourceException { String suffix = getResourceSuffix ( locale ) ; try { String resourceName = className + suffix ; return ( XResourceBundle ) ResourceBundle . getBundle ( resourceName , locale ) ; } catch ( MissingResourceException e ) { try { return ( XResourceBundle ) ResourceBundle . getBundle ( XSLT_RESOURCE , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String lang = locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; String variant = locale . getVariant ( ) ; String suffix = "_" + locale . getLanguage ( ) ; if ( lang . equals ( "zh" ) ) suffix += "_" + country ; if ( country . equals ( "JP" ) ) suffix += "_" + country + "_" + variant ; return suffix ; } public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['5', '3', '18', '19', '16', '8', '19', '0', '3', '1.223684211', '424', '0', '0', '0.926829268', '0.416666667', '0', '0', '80', '3', '1', '1']
package org . apache . xpath . objects ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . axes . NodeSequence ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class XNodeSet extends NodeSequence { protected XNodeSet ( ) { } public XNodeSet ( DTMIterator val ) { super ( ) ; if ( val instanceof XNodeSet ) { setIter ( ( ( XNodeSet ) val ) . m_iter ) ; m_dtmMgr = ( ( XNodeSet ) val ) . m_dtmMgr ; m_last = ( ( XNodeSet ) val ) . m_last ; if ( ! ( ( XNodeSet ) val ) . hasCache ( ) ) ( ( XNodeSet ) val ) . setShouldCacheNodes ( true ) ; m_obj = ( ( XNodeSet ) val ) . m_obj ; } else setIter ( val ) ; } public XNodeSet ( XNodeSet val ) { super ( ) ; setIter ( val . m_iter ) ; m_dtmMgr = val . m_dtmMgr ; m_last = val . m_last ; if ( ! val . hasCache ( ) ) val . setShouldCacheNodes ( true ) ; m_obj = val . m_obj ; } public XNodeSet ( DTMManager dtmMgr ) { this ( DTM . NULL , dtmMgr ) ; } public XNodeSet ( int n , DTMManager dtmMgr ) { super ( new NodeSetDTM ( dtmMgr ) ) ; m_dtmMgr = dtmMgr ; if ( DTM . NULL != n ) { ( ( NodeSetDTM ) m_obj ) . addNode ( n ) ; m_last = 1 ; } else m_last = 0 ; } public int getType ( ) { return CLASS_NODESET ; } public String getTypeString ( ) { return "#NODESET" ; } public double getNumberFromNode ( int n ) { XMLString xstr = m_dtmMgr . getDTM ( n ) . getStringValue ( n ) ; return xstr . toDouble ( ) ; } public double num ( ) { int node = item ( 0 ) ; return ( node != DTM . NULL ) ? getNumberFromNode ( node ) : Double . NaN ; } public double numWithSideEffects ( ) { int node = nextNode ( ) ; return ( node != DTM . NULL ) ? getNumberFromNode ( node ) : Double . NaN ; } public boolean bool ( ) { return ( item ( 0 ) != DTM . NULL ) ; } public boolean boolWithSideEffects ( ) { return ( nextNode ( ) != DTM . NULL ) ; } public XMLString getStringFromNode ( int n ) { if ( DTM . NULL != n ) { return m_dtmMgr . getDTM ( n ) . getStringValue ( n ) ; } else { return org . apache . xpath . objects . XString . EMPTYSTRING ; } } public void dispatchCharactersEvents ( org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { int node = item ( 0 ) ; if ( node != DTM . NULL ) { m_dtmMgr . getDTM ( node ) . dispatchCharactersEvents ( node , ch , false ) ; } } public XMLString xstr ( ) { int node = item ( 0 ) ; return ( node != DTM . NULL ) ? getStringFromNode ( node ) : XString . EMPTYSTRING ; } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { XString xstring = ( XString ) xstr ( ) ; xstring . appendToFsb ( fsb ) ; } public String str ( ) { int node = item ( 0 ) ; return ( node != DTM . NULL ) ? getStringFromNode ( node ) . toString ( ) : "" ; } public Object object ( ) { if ( null == m_obj ) return this ; else return m_obj ; } public NodeIterator nodeset ( ) throws javax . xml . transform . TransformerException { return new org . apache . xml . dtm . ref . DTMNodeIterator ( iter ( ) ) ; } public NodeList nodelist ( ) throws javax . xml . transform . TransformerException { org . apache . xml . dtm . ref . DTMNodeList nodelist = new org . apache . xml . dtm . ref . DTMNodeList ( this ) ; XNodeSet clone = ( XNodeSet ) nodelist . getDTMIterator ( ) ; SetVector ( clone . getVector ( ) ) ; return nodelist ; } public DTMIterator iterRaw ( ) { return this ; } public void release ( DTMIterator iter ) { } public DTMIterator iter ( ) { try { if ( hasCache ( ) ) return cloneWithReset ( ) ; else return this ; } catch ( CloneNotSupportedException cnse ) { throw new RuntimeException ( cnse . getMessage ( ) ) ; } } public XObject getFresh ( ) { try { if ( hasCache ( ) ) return ( XObject ) cloneWithReset ( ) ; else return this ; } catch ( CloneNotSupportedException cnse ) { throw new RuntimeException ( cnse . getMessage ( ) ) ; } } public NodeSetDTM mutableNodeset ( ) { NodeSetDTM mnl ; if ( m_obj instanceof NodeSetDTM ) { mnl = ( NodeSetDTM ) m_obj ; } else { mnl = new NodeSetDTM ( iter ( ) ) ; m_obj = mnl ; setCurrentPos ( 0 ) ; } return mnl ; } static LessThanComparator S_LT = new LessThanComparator ( ) ; static LessThanOrEqualComparator S_LTE = new LessThanOrEqualComparator ( ) ; static GreaterThanComparator S_GT = new GreaterThanComparator ( ) ; static GreaterThanOrEqualComparator S_GTE = new GreaterThanOrEqualComparator ( ) ; static EqualComparator S_EQ = new EqualComparator ( ) ; static NotEqualComparator S_NEQ = new NotEqualComparator ( ) ; public boolean compare ( XObject obj2 , Comparator comparator ) throws javax . xml . transform . TransformerException { boolean result = false ; int type = obj2 . getType ( ) ; if ( XObject . CLASS_NODESET == type ) { DTMIterator list1 = iterRaw ( ) ; DTMIterator list2 = ( ( XNodeSet ) obj2 ) . iterRaw ( ) ; int node1 ; java . util . Vector node2Strings = null ; while ( DTM . NULL != ( node1 = list1 . nextNode ( ) ) ) { XMLString s1 = getStringFromNode ( node1 ) ; if ( null == node2Strings ) { int node2 ; while ( DTM . NULL != ( node2 = list2 . nextNode ( ) ) ) { XMLString s2 = getStringFromNode ( node2 ) ; if ( comparator . compareStrings ( s1 , s2 ) ) { result = true ; break ; } if ( null == node2Strings ) node2Strings = new java . util . Vector ( ) ; node2Strings . addElement ( s2 ) ; } } else { int n = node2Strings . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( comparator . compareStrings ( s1 , ( XMLString ) node2Strings . elementAt ( i ) ) ) { result = true ; break ; } } } } list1 . reset ( ) ; list2 . reset ( ) ; } else if ( XObject . CLASS_BOOLEAN == type ) { double num1 = bool ( ) ? 1.0 : 0.0 ; double num2 = obj2 . num ( ) ; result = comparator . compareNumbers ( num1 , num2 ) ; } else if ( XObject . CLASS_NUMBER == type ) { DTMIterator list1 = iterRaw ( ) ; double num2 = obj2 . num ( ) ; int node ; while ( DTM . NULL != ( node = list1 . nextNode ( ) ) ) { double num1 = getNumberFromNode ( node ) ; if ( comparator . compareNumbers ( num1 , num2 ) ) { result = true ; break ; } } list1 . reset ( ) ; } else if ( XObject . CLASS_RTREEFRAG == type ) { XMLString s2 = obj2 . xstr ( ) ; DTMIterator list1 = iterRaw ( ) ; int node ; while ( DTM . NULL != ( node = list1 . nextNode ( ) ) ) { XMLString s1 = getStringFromNode ( node ) ; if ( comparator . compareStrings ( s1 , s2 ) ) { result = true ; break ; } } list1 . reset ( ) ; } else if ( XObject . CLASS_STRING == type ) { XMLString s2 = obj2 . xstr ( ) ; DTMIterator list1 = iterRaw ( ) ; int node ; while ( DTM . NULL != ( node = list1 . nextNode ( ) ) ) { XMLString s1 = getStringFromNode ( node ) ; if ( comparator . compareStrings ( s1 , s2 ) ) { result = true ; break ; } } list1 . reset ( ) ; } else { result = comparator . compareNumbers ( this . num ( ) , obj2 . num ( ) ) ; } return result ; } public boolean lessThan ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_LT ) ; } public boolean lessThanOrEqual ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_LTE ) ; } public boolean greaterThan ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_GT ) ; } public boolean greaterThanOrEqual ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_GTE ) ; } public boolean equals ( XObject obj2 ) { try { return compare ( obj2 , S_EQ ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } public boolean notEquals ( XObject obj2 ) throws javax . xml . transform . TransformerException { return compare ( obj2 , S_NEQ ) ; } } abstract class Comparator { abstract boolean compareStrings ( XMLString s1 , XMLString s2 ) ; abstract boolean compareNumbers ( double n1 , double n2 ) ; } class LessThanComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ( s1 . toDouble ( ) < s2 . toDouble ( ) ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 < n2 ; } } class LessThanOrEqualComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ( s1 . toDouble ( ) <= s2 . toDouble ( ) ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 <= n2 ; } } class GreaterThanComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ( s1 . toDouble ( ) > s2 . toDouble ( ) ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 > n2 ; } } class GreaterThanOrEqualComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ( s1 . toDouble ( ) >= s2 . toDouble ( ) ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 >= n2 ; } } class EqualComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return s1 . equals ( s2 ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 == n2 ; } } class NotEqualComparator extends Comparator { boolean compareStrings ( XMLString s1 , XMLString s2 ) { return ! s1 . equals ( s2 ) ; } boolean compareNumbers ( double n1 , double n2 ) { return n1 != n2 ; } } 	1	['33', '4', '3', '44', '76', '472', '25', '20', '31', '0.96875', '610', '0', '6', '0.801470588', '0.173611111', '3', '30', '17.3030303', '2', '1.1515', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . generic . ANEWARRAY ; import org . apache . bcel . generic . BasicType ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . DUP_X1 ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . NEWARRAY ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . DOM ; import org . xml . sax . Attributes ; public abstract class SyntaxTreeNode implements Constants { private Parser _parser ; protected SyntaxTreeNode _parent ; private Stylesheet _stylesheet ; private Template _template ; private final Vector _contents = new Vector ( 2 ) ; protected QName _qname ; private int _line ; protected Attributes _attributes = null ; private Hashtable _prefixMapping = null ; protected static final SyntaxTreeNode Dummy = new AbsolutePathPattern ( null ) ; protected static final int IndentIncrement = 4 ; private static final char [ ] _spaces = "                                                       " . toCharArray ( ) ; public SyntaxTreeNode ( ) { _line = 0 ; _qname = null ; } public SyntaxTreeNode ( int line ) { _line = line ; _qname = null ; } public SyntaxTreeNode ( String uri , String prefix , String local ) { _line = 0 ; setQName ( uri , prefix , local ) ; } protected final void setLineNumber ( int line ) { _line = line ; } public final int getLineNumber ( ) { return _line ; } protected void setQName ( QName qname ) { _qname = qname ; } protected void setQName ( String uri , String prefix , String localname ) { _qname = new QName ( uri , prefix , localname ) ; } protected QName getQName ( ) { return ( _qname ) ; } protected void setAttributes ( Attributes attributes ) { _attributes = attributes ; } protected String getAttribute ( String qname ) { if ( _attributes == null ) { return EMPTYSTRING ; } final String value = _attributes . getValue ( qname ) ; return ( value == null || value . equals ( EMPTYSTRING ) ) ? EMPTYSTRING : value ; } protected boolean hasAttribute ( String qname ) { return ( _attributes != null && _attributes . getValue ( qname ) != null ) ; } protected Attributes getAttributes ( ) { return ( _attributes ) ; } protected void setPrefixMapping ( Hashtable mapping ) { _prefixMapping = mapping ; } protected Hashtable getPrefixMapping ( ) { return _prefixMapping ; } protected void addPrefixMapping ( String prefix , String uri ) { if ( _prefixMapping == null ) _prefixMapping = new Hashtable ( ) ; _prefixMapping . put ( prefix , uri ) ; } protected String lookupNamespace ( String prefix ) { String uri = null ; if ( _prefixMapping != null ) uri = ( String ) _prefixMapping . get ( prefix ) ; if ( ( uri == null ) && ( _parent != null ) ) { uri = _parent . lookupNamespace ( prefix ) ; if ( ( prefix == Constants . EMPTYSTRING ) && ( uri == null ) ) uri = Constants . EMPTYSTRING ; } return ( uri ) ; } protected String lookupPrefix ( String uri ) { String prefix = null ; if ( ( _prefixMapping != null ) && ( _prefixMapping . contains ( uri ) ) ) { Enumeration prefixes = _prefixMapping . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { prefix = ( String ) prefixes . nextElement ( ) ; String mapsTo = ( String ) _prefixMapping . get ( prefix ) ; if ( mapsTo . equals ( uri ) ) return ( prefix ) ; } } else if ( _parent != null ) { prefix = _parent . lookupPrefix ( uri ) ; if ( ( uri == Constants . EMPTYSTRING ) && ( prefix == null ) ) prefix = Constants . EMPTYSTRING ; } return ( prefix ) ; } protected void setParser ( Parser parser ) { _parser = parser ; } public final Parser getParser ( ) { return _parser ; } protected void setParent ( SyntaxTreeNode parent ) { if ( _parent == null ) _parent = parent ; } protected final SyntaxTreeNode getParent ( ) { return _parent ; } protected final boolean isDummy ( ) { return this == Dummy ; } protected int getImportPrecedence ( ) { Stylesheet stylesheet = getStylesheet ( ) ; if ( stylesheet == null ) return Integer . MIN_VALUE ; return stylesheet . getImportPrecedence ( ) ; } public Stylesheet getStylesheet ( ) { if ( _stylesheet == null ) { SyntaxTreeNode parent = this ; while ( parent != null ) { if ( parent instanceof Stylesheet ) return ( ( Stylesheet ) parent ) ; parent = parent . getParent ( ) ; } _stylesheet = ( Stylesheet ) parent ; } return ( _stylesheet ) ; } protected Template getTemplate ( ) { if ( _template == null ) { SyntaxTreeNode parent = this ; while ( ( parent != null ) && ( ! ( parent instanceof Template ) ) ) parent = parent . getParent ( ) ; _template = ( Template ) parent ; } return ( _template ) ; } protected final XSLTC getXSLTC ( ) { return _parser . getXSLTC ( ) ; } protected final SymbolTable getSymbolTable ( ) { return ( _parser == null ) ? null : _parser . getSymbolTable ( ) ; } public void parseContents ( Parser parser ) { parseChildren ( parser ) ; } protected final void parseChildren ( Parser parser ) { Vector locals = null ; final int count = _contents . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; final QName varOrParamName = updateScope ( parser , child ) ; if ( varOrParamName != null ) { if ( locals == null ) { locals = new Vector ( 2 ) ; } locals . addElement ( varOrParamName ) ; } } parser . getSymbolTable ( ) . setCurrentNode ( this ) ; if ( locals != null ) { final int nLocals = locals . size ( ) ; for ( int i = 0 ; i < nLocals ; i ++ ) { parser . removeVariable ( ( QName ) locals . elementAt ( i ) ) ; } } } protected QName updateScope ( Parser parser , SyntaxTreeNode node ) { if ( node instanceof Variable ) { final Variable var = ( Variable ) node ; parser . addVariable ( var ) ; return var . getName ( ) ; } else if ( node instanceof Param ) { final Param param = ( Param ) node ; parser . addParameter ( param ) ; return param . getName ( ) ; } else { return null ; } } public abstract Type typeCheck ( SymbolTable stable ) throws TypeCheckError ; protected Type typeCheckContents ( SymbolTable stable ) throws TypeCheckError { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; item . typeCheck ( stable ) ; } return Type . Void ; } public abstract void translate ( ClassGenerator classGen , MethodGenerator methodGen ) ; protected void translateContents ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final SyntaxTreeNode item = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; item . translate ( classGen , methodGen ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( _contents . elementAt ( i ) instanceof VariableBase ) { final VariableBase var = ( VariableBase ) _contents . elementAt ( i ) ; var . unmapRegister ( methodGen ) ; } } } private boolean isSimpleRTF ( SyntaxTreeNode node ) { Vector contents = node . getContents ( ) ; for ( int i = 0 ; i < contents . size ( ) ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ! isTextElement ( item , false ) ) return false ; } return true ; } private boolean isAdaptiveRTF ( SyntaxTreeNode node ) { Vector contents = node . getContents ( ) ; for ( int i = 0 ; i < contents . size ( ) ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ! isTextElement ( item , true ) ) return false ; } return true ; } private boolean isTextElement ( SyntaxTreeNode node , boolean doExtendedCheck ) { if ( node instanceof ValueOf || node instanceof Number || node instanceof Text ) { return true ; } else if ( node instanceof If ) { return doExtendedCheck ? isAdaptiveRTF ( node ) : isSimpleRTF ( node ) ; } else if ( node instanceof Choose ) { Vector contents = node . getContents ( ) ; for ( int i = 0 ; i < contents . size ( ) ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( item instanceof Text || ( ( item instanceof When || item instanceof Otherwise ) && ( ( doExtendedCheck && isAdaptiveRTF ( item ) ) || ( ! doExtendedCheck && isSimpleRTF ( item ) ) ) ) ) continue ; else return false ; } return true ; } else if ( doExtendedCheck && ( node instanceof CallTemplate || node instanceof ApplyTemplates ) ) return true ; else return false ; } protected void compileResultTree ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final Stylesheet stylesheet = classGen . getStylesheet ( ) ; boolean isSimple = isSimpleRTF ( this ) ; boolean isAdaptive = false ; if ( ! isSimple ) { isAdaptive = isAdaptiveRTF ( this ) ; } int rtfType = isSimple ? DOM . SIMPLE_RTF : ( isAdaptive ? DOM . ADAPTIVE_RTF : DOM . TREE_RTF ) ; il . append ( methodGen . loadHandler ( ) ) ; final String DOM_CLASS = classGen . getDOMClass ( ) ; il . append ( methodGen . loadDOM ( ) ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , "getResultTreeFrag" , "(IIZ)" + DOM_INTF_SIG ) ; il . append ( new PUSH ( cpg , RTF_INITIAL_SIZE ) ) ; il . append ( new PUSH ( cpg , rtfType ) ) ; il . append ( new PUSH ( cpg , stylesheet . callsNodeset ( ) ) ) ; il . append ( new INVOKEINTERFACE ( index , 4 ) ) ; il . append ( DUP ) ; index = cpg . addInterfaceMethodref ( DOM_INTF , "getOutputDomBuilder" , "()" + TRANSLET_OUTPUT_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeHandler ( ) ) ; il . append ( methodGen . startDocument ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . endDocument ( ) ) ; if ( stylesheet . callsNodeset ( ) && ! DOM_CLASS . equals ( DOM_IMPL_CLASS ) ) { index = cpg . addMethodref ( DOM_ADAPTER_CLASS , "<init>" , "(" + DOM_INTF_SIG + "[" + STRING_SIG + "[" + STRING_SIG + "[I" + "[" + STRING_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( DOM_ADAPTER_CLASS ) ) ) ; il . append ( new DUP_X1 ( ) ) ; il . append ( SWAP ) ; if ( ! stylesheet . callsNodeset ( ) ) { il . append ( new ICONST ( 0 ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; il . append ( new ICONST ( 0 ) ) ; il . append ( new NEWARRAY ( BasicType . INT ) ) ; il . append ( SWAP ) ; il . append ( new INVOKESPECIAL ( index ) ) ; } else { il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMES_INDEX , NAMES_INDEX_SIG ) ) ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , URIS_INDEX , URIS_INDEX_SIG ) ) ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , TYPES_INDEX , TYPES_INDEX_SIG ) ) ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMESPACE_INDEX , NAMESPACE_INDEX_SIG ) ) ) ; il . append ( new INVOKESPECIAL ( index ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new CHECKCAST ( cpg . addClass ( classGen . getDOMClass ( ) ) ) ) ; il . append ( SWAP ) ; index = cpg . addMethodref ( MULTI_DOM_CLASS , "addDOMAdapter" , "(" + DOM_ADAPTER_SIG + ")I" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; il . append ( POP ) ; } } il . append ( SWAP ) ; il . append ( methodGen . storeHandler ( ) ) ; } protected boolean contextDependent ( ) { return true ; } protected boolean dependentContents ( ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final SyntaxTreeNode item = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; if ( item . contextDependent ( ) ) { return true ; } } return false ; } protected final void addElement ( SyntaxTreeNode element ) { _contents . addElement ( element ) ; element . setParent ( this ) ; } protected final void setFirstElement ( SyntaxTreeNode element ) { _contents . insertElementAt ( element , 0 ) ; element . setParent ( this ) ; } protected final void removeElement ( SyntaxTreeNode element ) { _contents . remove ( element ) ; element . setParent ( null ) ; } protected final Vector getContents ( ) { return _contents ; } protected final boolean hasContents ( ) { return elementCount ( ) > 0 ; } protected final int elementCount ( ) { return _contents . size ( ) ; } protected final Enumeration elements ( ) { return _contents . elements ( ) ; } protected final Object elementAt ( int pos ) { return _contents . elementAt ( pos ) ; } protected final SyntaxTreeNode lastChild ( ) { if ( _contents . size ( ) == 0 ) return null ; return ( SyntaxTreeNode ) _contents . lastElement ( ) ; } public void display ( int indent ) { displayContents ( indent ) ; } protected void displayContents ( int indent ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SyntaxTreeNode item = ( SyntaxTreeNode ) _contents . elementAt ( i ) ; item . display ( indent ) ; } } protected final void indent ( int indent ) { System . out . print ( new String ( _spaces , 0 , indent ) ) ; } protected void reportError ( SyntaxTreeNode element , Parser parser , String errorCode , String message ) { final ErrorMsg error = new ErrorMsg ( errorCode , message , element ) ; parser . reportError ( Constants . ERROR , error ) ; } protected void reportWarning ( SyntaxTreeNode element , Parser parser , String errorCode , String message ) { final ErrorMsg error = new ErrorMsg ( errorCode , message , element ) ; parser . reportError ( Constants . WARNING , error ) ; } } 	1	['55', '1', '5', '100', '118', '1101', '75', '45', '10', '0.912037037', '1164', '1', '6', '0', '0.149691358', '0', '0', '19.94545455', '18', '2.1636', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemIf extends ElemTemplateElement { private XPath m_test = null ; public void setTest ( XPath v ) { m_test = v ; } public XPath getTest ( ) { return m_test ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_test ) m_test . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_IF ; } public String getNodeName ( ) { return Constants . ELEMNAME_IF_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; if ( TransformerImpl . S_DEBUG ) { XObject test = m_test . execute ( xctxt , sourceNode , this ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "test" , m_test , test ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; if ( test . bool ( ) ) { transformer . executeChildTemplates ( this , true ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } else if ( m_test . bool ( xctxt , sourceNode , this ) ) { transformer . executeChildTemplates ( this , true ) ; } } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) m_test . getExpression ( ) . callVisitors ( m_test , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['8', '3', '0', '13', '27', '0', '0', '13', '7', '0.285714286', '117', '1', '1', '0.965517241', '0.270833333', '2', '5', '13.5', '2', '1', '2']
package org . apache . xml . utils ; public class XMLCharacterRecognizer { public static boolean isWhiteSpace ( char ch ) { return ( ch == 0x20 ) || ( ch == 0x09 ) || ( ch == 0xD ) || ( ch == 0xA ) ; } public static boolean isWhiteSpace ( char ch [ ] , int start , int length ) { int end = start + length ; for ( int s = start ; s < end ; s ++ ) { if ( ! isWhiteSpace ( ch [ s ] ) ) return false ; } return true ; } public static boolean isWhiteSpace ( StringBuffer buf ) { int n = buf . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! isWhiteSpace ( buf . charAt ( i ) ) ) return false ; } return true ; } public static boolean isWhiteSpace ( String s ) { if ( null != s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! isWhiteSpace ( s . charAt ( i ) ) ) return false ; } } return true ; } } 	1	['5', '1', '0', '7', '10', '10', '7', '0', '5', '2', '85', '0', '0', '0', '0.2', '0', '0', '16', '5', '3', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . NodeConsumer ; import org . apache . xml . utils . XMLString ; import org . xml . sax . ContentHandler ; import org . xml . sax . ext . LexicalHandler ; public class DTMTreeWalker { private ContentHandler m_contentHandler = null ; protected DTM m_dtm ; public void setDTM ( DTM dtm ) { m_dtm = dtm ; } public ContentHandler getcontentHandler ( ) { return m_contentHandler ; } public void setcontentHandler ( ContentHandler ch ) { m_contentHandler = ch ; } public DTMTreeWalker ( ) { } public DTMTreeWalker ( ContentHandler contentHandler , DTM dtm ) { this . m_contentHandler = contentHandler ; m_dtm = dtm ; } public void traverse ( int pos ) throws org . xml . sax . SAXException { int top = pos ; while ( DTM . NULL != pos ) { startNode ( pos ) ; int nextNode = m_dtm . getFirstChild ( pos ) ; while ( DTM . NULL == nextNode ) { endNode ( pos ) ; if ( top == pos ) break ; nextNode = m_dtm . getNextSibling ( pos ) ; if ( DTM . NULL == nextNode ) { pos = m_dtm . getParent ( pos ) ; if ( ( DTM . NULL == pos ) || ( top == pos ) ) { if ( DTM . NULL != pos ) endNode ( pos ) ; nextNode = DTM . NULL ; break ; } } } pos = nextNode ; } } public void traverse ( int pos , int top ) throws org . xml . sax . SAXException { while ( DTM . NULL != pos ) { startNode ( pos ) ; int nextNode = m_dtm . getFirstChild ( pos ) ; while ( DTM . NULL == nextNode ) { endNode ( pos ) ; if ( ( DTM . NULL != top ) && top == pos ) break ; nextNode = m_dtm . getNextSibling ( pos ) ; if ( DTM . NULL == nextNode ) { pos = m_dtm . getParent ( pos ) ; if ( ( DTM . NULL == pos ) || ( ( DTM . NULL != top ) && ( top == pos ) ) ) { nextNode = DTM . NULL ; break ; } } } pos = nextNode ; } } boolean nextIsRaw = false ; private final void dispatachChars ( int node ) throws org . xml . sax . SAXException { m_dtm . dispatchCharactersEvents ( node , m_contentHandler , false ) ; } protected void startNode ( int node ) throws org . xml . sax . SAXException { if ( m_contentHandler instanceof NodeConsumer ) { } switch ( m_dtm . getNodeType ( node ) ) { case DTM . COMMENT_NODE : { XMLString data = m_dtm . getStringValue ( node ) ; if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; data . dispatchAsComment ( lh ) ; } } break ; case DTM . DOCUMENT_FRAGMENT_NODE : break ; case DTM . DOCUMENT_NODE : this . m_contentHandler . startDocument ( ) ; break ; case DTM . ELEMENT_NODE : DTM dtm = m_dtm ; for ( int nsn = dtm . getFirstNamespaceNode ( node , true ) ; DTM . NULL != nsn ; nsn = dtm . getNextNamespaceNode ( node , nsn , true ) ) { String prefix = dtm . getNodeNameX ( nsn ) ; this . m_contentHandler . startPrefixMapping ( prefix , dtm . getNodeValue ( nsn ) ) ; } String ns = dtm . getNamespaceURI ( node ) ; if ( null == ns ) ns = "" ; org . xml . sax . helpers . AttributesImpl attrs = new org . xml . sax . helpers . AttributesImpl ( ) ; for ( int i = dtm . getFirstAttribute ( node ) ; i != DTM . NULL ; i = dtm . getNextAttribute ( i ) ) { attrs . addAttribute ( dtm . getNamespaceURI ( i ) , dtm . getLocalName ( i ) , dtm . getNodeName ( i ) , "CDATA" , dtm . getNodeValue ( i ) ) ; } this . m_contentHandler . startElement ( ns , m_dtm . getLocalName ( node ) , m_dtm . getNodeName ( node ) , attrs ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : { String name = m_dtm . getNodeName ( node ) ; if ( name . equals ( "xslt-next-is-raw" ) ) { nextIsRaw = true ; } else { this . m_contentHandler . processingInstruction ( name , m_dtm . getNodeValue ( node ) ) ; } } break ; case DTM . CDATA_SECTION_NODE : { boolean isLexH = ( m_contentHandler instanceof LexicalHandler ) ; LexicalHandler lh = isLexH ? ( ( LexicalHandler ) this . m_contentHandler ) : null ; if ( isLexH ) { lh . startCDATA ( ) ; } dispatachChars ( node ) ; { if ( isLexH ) { lh . endCDATA ( ) ; } } } break ; case DTM . TEXT_NODE : { if ( nextIsRaw ) { nextIsRaw = false ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; dispatachChars ( node ) ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } else { dispatachChars ( node ) ; } } break ; case DTM . ENTITY_REFERENCE_NODE : { if ( m_contentHandler instanceof LexicalHandler ) { ( ( LexicalHandler ) this . m_contentHandler ) . startEntity ( m_dtm . getNodeName ( node ) ) ; } else { } } break ; default : } } protected void endNode ( int node ) throws org . xml . sax . SAXException { switch ( m_dtm . getNodeType ( node ) ) { case DTM . DOCUMENT_NODE : this . m_contentHandler . endDocument ( ) ; break ; case DTM . ELEMENT_NODE : String ns = m_dtm . getNamespaceURI ( node ) ; if ( null == ns ) ns = "" ; this . m_contentHandler . endElement ( ns , m_dtm . getLocalName ( node ) , m_dtm . getNodeName ( node ) ) ; for ( int nsn = m_dtm . getFirstNamespaceNode ( node , true ) ; DTM . NULL != nsn ; nsn = m_dtm . getNextNamespaceNode ( node , nsn , true ) ) { String prefix = m_dtm . getNodeNameX ( nsn ) ; this . m_contentHandler . endPrefixMapping ( prefix ) ; } break ; case DTM . CDATA_SECTION_NODE : break ; case DTM . ENTITY_REFERENCE_NODE : { if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; lh . endEntity ( m_dtm . getNodeName ( node ) ) ; } } break ; default : } } } 	1	['10', '1', '1', '6', '41', '0', '3', '3', '7', '0.333333333', '437', '0.666666667', '1', '0', '0.475', '0', '0', '42.4', '1', '0.8', '1']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . util . IntegerArray ; import org . apache . xml . dtm . DTMAxisIterator ; public abstract class MultipleNodeCounter extends NodeCounter { private DTMAxisIterator _precSiblings = null ; public MultipleNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } public NodeCounter setStartNode ( int node ) { _node = node ; _nodeType = _document . getExpandedTypeID ( node ) ; _precSiblings = _document . getAxisIterator ( PRECEDINGSIBLING ) ; return this ; } public String getCounter ( ) { if ( _value != Integer . MIN_VALUE ) { return formatNumbers ( _value ) ; } IntegerArray ancestors = new IntegerArray ( ) ; int next = _node ; ancestors . add ( next ) ; while ( ( next = _document . getParent ( next ) ) > END && ! matchesFrom ( next ) ) { ancestors . add ( next ) ; } final int nAncestors = ancestors . cardinality ( ) ; final int [ ] counters = new int [ nAncestors ] ; for ( int i = 0 ; i < nAncestors ; i ++ ) { counters [ i ] = Integer . MIN_VALUE ; } for ( int j = 0 , i = nAncestors - 1 ; i >= 0 ; i -- , j ++ ) { final int counter = counters [ j ] ; final int ancestor = ancestors . at ( i ) ; if ( matchesCount ( ancestor ) ) { _precSiblings . setStartNode ( ancestor ) ; while ( ( next = _precSiblings . next ( ) ) != END ) { if ( matchesCount ( next ) ) { counters [ j ] = ( counters [ j ] == Integer . MIN_VALUE ) ? 1 : counters [ j ] + 1 ; } } counters [ j ] = counters [ j ] == Integer . MIN_VALUE ? 1 : counters [ j ] + 1 ; } } return formatNumbers ( counters ) ; } public static NodeCounter getDefaultNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { return new DefaultMultipleNodeCounter ( translet , document , iterator ) ; } static class DefaultMultipleNodeCounter extends MultipleNodeCounter { public DefaultMultipleNodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { super ( translet , document , iterator ) ; } } } 	1	['4', '2', '1', '6', '19', '0', '1', '6', '4', '0.333333333', '164', '1', '1', '0.823529412', '0.5', '1', '4', '39.75', '11', '3.25', '2']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_es extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Error interno de ejecución en ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Error de ejecución al ejecutar <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Conversión no válida de ''{0}'' a ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "Función externa ''{0}'' no soportada por XSLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Tipo de argumento desconocido en expresión de igualdad." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Tipo de argumento ''{0}'' no válido en llamada a ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Intento de formatear el número ''{0}'' utilizando el patrón ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "No se puede replicar el iterador ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Iterador para el eje ''{0}'' no soportado." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Iterador para el eje escrito ''{0}'' no soportado." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Atributo ''{0}'' fuera del elemento." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Declaración del espacio de nombres ''{0}''=''{1}'' fuera del elemento." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "No se ha declarado el espacio de nombres para el prefijo ''{0}''." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter creado mediante un tipo incorrecto de DOM origen." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "El analizador SAX utilizado no maneja sucesos de declaración DTD." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "El analizador SAX utilizado no tiene soporte de espacios de nombres XML." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "No se ha podido resolver la referencia de URI ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Result ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . SAXException ; public class ToXMLStream extends ToStream { boolean m_cdataTagOpen = false ; protected static CharInfo m_xmlcharInfo = CharInfo . getCharInfo ( CharInfo . XML_ENTITIES_RESOURCE , Method . XML ) ; public ToXMLStream ( ) { m_charInfo = m_xmlcharInfo ; initCDATA ( ) ; m_prefixMap = new NamespaceMappings ( ) ; } public void CopyFrom ( ToXMLStream xmlListener ) { m_writer = xmlListener . m_writer ; String encoding = xmlListener . getEncoding ( ) ; setEncoding ( encoding ) ; setOmitXMLDeclaration ( xmlListener . getOmitXMLDeclaration ( ) ) ; m_ispreserve = xmlListener . m_ispreserve ; m_preserves = xmlListener . m_preserves ; m_isprevtext = xmlListener . m_isprevtext ; m_doIndent = xmlListener . m_doIndent ; setIndentAmount ( xmlListener . getIndentAmount ( ) ) ; m_startNewLine = xmlListener . m_startNewLine ; m_needToOutputDocTypeDecl = xmlListener . m_needToOutputDocTypeDecl ; setDoctypeSystem ( xmlListener . getDoctypeSystem ( ) ) ; setDoctypePublic ( xmlListener . getDoctypePublic ( ) ) ; setStandalone ( xmlListener . getStandalone ( ) ) ; setMediaType ( xmlListener . getMediaType ( ) ) ; m_maxCharacter = xmlListener . m_maxCharacter ; m_spaceBeforeClose = xmlListener . m_spaceBeforeClose ; m_cdataStartCalled = xmlListener . m_cdataStartCalled ; } public void startDocumentInternal ( ) throws org . xml . sax . SAXException { if ( m_needToCallStartDocument ) { super . startDocumentInternal ( ) ; m_needToCallStartDocument = false ; if ( m_inEntityRef ) return ; m_needToOutputDocTypeDecl = true ; m_startNewLine = false ; if ( getOmitXMLDeclaration ( ) == false ) { String encoding = Encodings . getMimeEncoding ( getEncoding ( ) ) ; String version = getVersion ( ) ; if ( version == null ) version = "1.0" ; String standalone ; if ( m_standaloneWasSpecified ) { standalone = " standalone=\"" + getStandalone ( ) + "\"" ; } else { standalone = "" ; } try { final java . io . Writer writer = m_writer ; writer . write ( "<?xml version=\"" ) ; writer . write ( version ) ; writer . write ( "\" encoding=\"" ) ; writer . write ( encoding ) ; writer . write ( '\"' ) ; writer . write ( standalone ) ; writer . write ( "?>" ) ; if ( m_doIndent ) writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } } } public void endDocument ( ) throws org . xml . sax . SAXException { flushPending ( ) ; if ( m_doIndent && ! m_isprevtext ) { try { outputLineSep ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } flushWriter ( ) ; if ( m_tracer != null ) super . fireEndDoc ( ) ; } public void startPreserving ( ) throws org . xml . sax . SAXException { m_preserves . push ( true ) ; m_ispreserve = true ; } public void endPreserving ( ) throws org . xml . sax . SAXException { m_ispreserve = m_preserves . isEmpty ( ) ? false : m_preserves . pop ( ) ; } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; flushPending ( ) ; if ( target . equals ( Result . PI_DISABLE_OUTPUT_ESCAPING ) ) { startNonEscaping ( ) ; } else if ( target . equals ( Result . PI_ENABLE_OUTPUT_ESCAPING ) ) { endNonEscaping ( ) ; } else { try { if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } if ( shouldIndent ( ) ) indent ( ) ; final java . io . Writer writer = m_writer ; writer . write ( "<?" ) ; writer . write ( target ) ; if ( data . length ( ) > 0 && ! Character . isSpaceChar ( data . charAt ( 0 ) ) ) writer . write ( ' ' ) ; int indexOfQLT = data . indexOf ( "?>" ) ; if ( indexOfQLT >= 0 ) { if ( indexOfQLT > 0 ) { writer . write ( data . substring ( 0 , indexOfQLT ) ) ; } writer . write ( "? >" ) ; if ( ( indexOfQLT + 2 ) < data . length ( ) ) { writer . write ( data . substring ( indexOfQLT + 2 ) ) ; } } else { writer . write ( data ) ; } writer . write ( '?' ) ; writer . write ( '>' ) ; if ( m_elemContext . m_currentElemDepth <= 0 ) writer . write ( m_lineSep , 0 , m_lineSepLen ) ; m_startNewLine = true ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } if ( m_tracer != null ) super . fireEscapingEvent ( target , data ) ; } public void entityReference ( String name ) throws org . xml . sax . SAXException { if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } try { if ( shouldIndent ( ) ) indent ( ) ; final java . io . Writer writer = m_writer ; writer . write ( '&' ) ; writer . write ( name ) ; writer . write ( ';' ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } if ( m_tracer != null ) super . fireEntityReference ( name ) ; } public void addUniqueAttribute ( String name , String value , int flags ) throws SAXException { if ( m_elemContext . m_startTagOpen ) { try { final String patchedName = patchName ( name ) ; final java . io . Writer writer = m_writer ; if ( ( flags & NO_BAD_CHARS ) > 0 && m_xmlcharInfo . onlyQuotAmpLtGt ) { writer . write ( ' ' ) ; writer . write ( patchedName ) ; writer . write ( "=\"" ) ; writer . write ( value ) ; writer . write ( '"' ) ; } else { writer . write ( ' ' ) ; writer . write ( patchedName ) ; writer . write ( "=\"" ) ; writeAttrString ( writer , value , this . getEncoding ( ) ) ; writer . write ( '"' ) ; } } catch ( IOException e ) { throw new SAXException ( e ) ; } } } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { if ( m_elemContext . m_startTagOpen ) { if ( ! rawName . startsWith ( "xmlns" ) ) { String prefixUsed = ensureAttributesNamespaceIsDeclared ( uri , localName , rawName ) ; if ( prefixUsed != null && rawName != null && ! rawName . startsWith ( prefixUsed ) ) { rawName = prefixUsed + ":" + localName ; } } addAttributeAlways ( uri , localName , rawName , type , value ) ; } else { String msg = XMLMessages . createXMLMessage ( XMLErrorResources . ER_ILLEGAL_ATTRIBUTE_POSITION , new Object [ ] { localName } ) ; try { Transformer tran = super . getTransformer ( ) ; ErrorListener errHandler = tran . getErrorListener ( ) ; if ( null != errHandler && m_sourceLocator != null ) errHandler . warning ( new TransformerException ( msg , m_sourceLocator ) ) ; else System . out . println ( msg ) ; } catch ( Exception e ) { } } } public void endElement ( String elemName ) throws SAXException { endElement ( null , null , elemName ) ; } public void namespaceAfterStartElement ( final String prefix , final String uri ) throws SAXException { if ( m_elemContext . m_elementURI == null ) { String prefix1 = getPrefixPart ( m_elemContext . m_elementName ) ; if ( prefix1 == null && EMPTYSTRING . equals ( prefix ) ) { m_elemContext . m_elementURI = uri ; } } startPrefixMapping ( prefix , uri , false ) ; return ; } protected boolean pushNamespace ( String prefix , String uri ) { try { if ( m_prefixMap . pushNamespace ( prefix , uri , m_elemContext . m_currentElemDepth ) ) { startPrefixMapping ( prefix , uri ) ; return true ; } } catch ( SAXException e ) { } return false ; } public boolean reset ( ) { boolean wasReset = false ; if ( super . reset ( ) ) { resetToXMLStream ( ) ; wasReset = true ; } return wasReset ; } private void resetToXMLStream ( ) { this . m_cdataTagOpen = false ; } } 	1	['16', '3', '0', '10', '82', '52', '2', '8', '13', '0.866666667', '616', '0.5', '1', '0.923497268', '0.4', '3', '30', '37.375', '2', '0.9375', '5']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . utils . XMLChar ; class VariableBase extends TopLevelElement { protected QName _name ; protected String _escapedName ; protected Type _type ; protected boolean _isLocal ; protected LocalVariableGen _local ; protected Instruction _loadInstruction ; protected Instruction _storeInstruction ; protected Expression _select ; protected String select ; protected Vector _refs = new Vector ( 2 ) ; protected Vector _dependencies = null ; protected boolean _ignore = false ; protected int _weight = 0 ; public void disable ( ) { _ignore = true ; } public void addReference ( VariableRefBase vref ) { _refs . addElement ( vref ) ; } public void removeReference ( VariableRefBase vref ) { _refs . remove ( vref ) ; } public void addDependency ( VariableBase other ) { if ( _dependencies == null ) { _dependencies = new Vector ( ) ; } if ( ! _dependencies . contains ( other ) ) { _dependencies . addElement ( other ) ; } } public Vector getDependencies ( ) { return _dependencies ; } public void mapRegister ( MethodGenerator methodGen ) { if ( _local == null ) { final InstructionList il = methodGen . getInstructionList ( ) ; final String name = getEscapedName ( ) ; final org . apache . bcel . generic . Type varType = _type . toJCType ( ) ; _local = methodGen . addLocalVariable2 ( name , varType , il . getEnd ( ) ) ; } } public void unmapRegister ( MethodGenerator methodGen ) { if ( _refs . isEmpty ( ) && ( _local != null ) ) { _local . setEnd ( methodGen . getInstructionList ( ) . getEnd ( ) ) ; methodGen . removeLocalVariable ( _local ) ; _refs = null ; _local = null ; } } public Instruction loadInstruction ( ) { final Instruction instr = _loadInstruction ; if ( _loadInstruction == null ) { _loadInstruction = _type . LOAD ( _local . getIndex ( ) ) ; } return _loadInstruction ; } public Instruction storeInstruction ( ) { final Instruction instr = _storeInstruction ; if ( _storeInstruction == null ) { _storeInstruction = _type . STORE ( _local . getIndex ( ) ) ; } return _storeInstruction ; } public Expression getExpression ( ) { return ( _select ) ; } public String toString ( ) { return ( "variable(" + _name + ")" ) ; } public void display ( int indent ) { indent ( indent ) ; System . out . println ( "Variable " + _name ) ; if ( _select != null ) { indent ( indent + IndentIncrement ) ; System . out . println ( "select " + _select . toString ( ) ) ; } displayContents ( indent + IndentIncrement ) ; } public Type getType ( ) { return _type ; } public QName getName ( ) { return _name ; } public String getEscapedName ( ) { return _escapedName ; } public void setName ( QName name ) { _name = name ; _escapedName = Util . escape ( name . getStringRep ( ) ) ; } public boolean isLocal ( ) { return _isLocal ; } public void parseContents ( Parser parser ) { String name = getAttribute ( "name" ) ; if ( name . length ( ) > 0 ) { if ( ! XMLChar . isValidQName ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , name , this ) ; parser . reportError ( Constants . ERROR , err ) ; } setName ( parser . getQNameIgnoreDefaultNs ( name ) ) ; } else reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "name" ) ; VariableBase other = parser . lookupVariable ( _name ) ; if ( ( other != null ) && ( other . getParent ( ) == getParent ( ) ) ) { reportError ( this , parser , ErrorMsg . VARIABLE_REDEF_ERR , name ) ; } select = getAttribute ( "select" ) ; if ( select . length ( ) > 0 ) { _select = getParser ( ) . parseExpression ( this , "select" , null ) ; if ( _select . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "select" ) ; return ; } } parseChildren ( parser ) ; } public void translateValue ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _select != null ) { _select . translate ( classGen , methodGen ) ; if ( _select . getType ( ) instanceof NodeSetType ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int initCNI = cpg . addMethodref ( CACHED_NODE_LIST_ITERATOR_CLASS , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( CACHED_NODE_LIST_ITERATOR_CLASS ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; il . append ( new INVOKESPECIAL ( initCNI ) ) ; } _select . startIterator ( classGen , methodGen ) ; } else if ( hasContents ( ) ) { compileResultTree ( classGen , methodGen ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; } } } 	1	['20', '3', '2', '35', '72', '120', '14', '24', '19', '0.910931174', '404', '1', '3', '0.759493671', '0.1875', '1', '4', '18.55', '7', '1.8', '1']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; final class Step extends RelativeLocationPath { private int _axis ; private Vector _predicates ; private boolean _hadPredicates = false ; private int _nodeType ; public Step ( int axis , int nodeType , Vector predicates ) { _axis = axis ; _nodeType = nodeType ; _predicates = predicates ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate exp = ( Predicate ) _predicates . elementAt ( i ) ; exp . setParser ( parser ) ; exp . setParent ( this ) ; } } } public int getAxis ( ) { return _axis ; } public void setAxis ( int axis ) { _axis = axis ; } public int getNodeType ( ) { return _nodeType ; } public Vector getPredicates ( ) { return _predicates ; } public void addPredicates ( Vector predicates ) { if ( _predicates == null ) { _predicates = predicates ; } else { _predicates . addAll ( predicates ) ; } } private boolean hasParentPattern ( ) { final SyntaxTreeNode parent = getParent ( ) ; return ( parent instanceof ParentPattern || parent instanceof ParentLocationPath || parent instanceof UnionPathExpr || parent instanceof FilterParentPath ) ; } private boolean hasPredicates ( ) { return _predicates != null && _predicates . size ( ) > 0 ; } private boolean isPredicate ( ) { SyntaxTreeNode parent = this ; while ( parent != null ) { parent = parent . getParent ( ) ; if ( parent instanceof Predicate ) return true ; } return false ; } public boolean isAbbreviatedDot ( ) { return _nodeType == NodeTest . ANODE && _axis == Axis . SELF ; } public boolean isAbbreviatedDDot ( ) { return _nodeType == NodeTest . ANODE && _axis == Axis . PARENT ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _hadPredicates = hasPredicates ( ) ; if ( isAbbreviatedDot ( ) ) { _type = ( hasParentPattern ( ) || hasPredicates ( ) ) ? Type . NodeSet : Type . Node ; } else { _type = Type . NodeSet ; } if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression pred = ( Expression ) _predicates . elementAt ( i ) ; pred . typeCheck ( stable ) ; } } return _type ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( hasPredicates ( ) ) { translatePredicates ( classGen , methodGen ) ; } else { int star = 0 ; String name = null ; final XSLTC xsltc = getParser ( ) . getXSLTC ( ) ; if ( _nodeType >= DTM . NTYPES ) { final Vector ni = xsltc . getNamesIndex ( ) ; name = ( String ) ni . elementAt ( _nodeType - DTM . NTYPES ) ; star = name . lastIndexOf ( '*' ) ; } if ( _axis == Axis . ATTRIBUTE && _nodeType != NodeTest . ATTRIBUTE && _nodeType != NodeTest . ANODE && ! hasParentPattern ( ) && star == 0 ) { int iter = cpg . addInterfaceMethodref ( DOM_INTF , "getTypedAxisIterator" , "(II)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , Axis . ATTRIBUTE ) ) ; il . append ( new PUSH ( cpg , _nodeType ) ) ; il . append ( new INVOKEINTERFACE ( iter , 3 ) ) ; return ; } if ( isAbbreviatedDot ( ) ) { if ( _type == Type . Node ) { il . append ( methodGen . loadContextNode ( ) ) ; } else { int init = cpg . addMethodref ( SINGLETON_ITERATOR , "<init>" , "(" + NODE_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( SINGLETON_ITERATOR ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } return ; } SyntaxTreeNode parent = getParent ( ) ; if ( ( parent instanceof ParentLocationPath ) && ( parent . getParent ( ) instanceof ParentLocationPath ) ) { if ( ( _nodeType == NodeTest . ELEMENT ) && ( ! _hadPredicates ) ) { _nodeType = NodeTest . ANODE ; } } switch ( _nodeType ) { case NodeTest . ATTRIBUTE : _axis = Axis . ATTRIBUTE ; case NodeTest . ANODE : int git = cpg . addInterfaceMethodref ( DOM_INTF , "getAxisIterator" , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , _axis ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; break ; default : if ( star > 1 ) { final String namespace ; if ( _axis == Axis . ATTRIBUTE ) namespace = name . substring ( 0 , star - 2 ) ; else namespace = name . substring ( 0 , star - 1 ) ; final int nsType = xsltc . registerNamespace ( namespace ) ; final int ns = cpg . addInterfaceMethodref ( DOM_INTF , "getNamespaceAxisIterator" , "(II)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , _axis ) ) ; il . append ( new PUSH ( cpg , nsType ) ) ; il . append ( new INVOKEINTERFACE ( ns , 3 ) ) ; break ; } case NodeTest . ELEMENT : final int ty = cpg . addInterfaceMethodref ( DOM_INTF , "getTypedAxisIterator" , "(II)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , _axis ) ) ; il . append ( new PUSH ( cpg , _nodeType ) ) ; il . append ( new INVOKEINTERFACE ( ty , 3 ) ) ; break ; } } } public void translatePredicates ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int idx = 0 ; if ( _predicates . size ( ) == 0 ) { translate ( classGen , methodGen ) ; } else { final Predicate predicate = ( Predicate ) _predicates . lastElement ( ) ; _predicates . remove ( predicate ) ; if ( predicate . isNodeValueTest ( ) ) { Step step = predicate . getStep ( ) ; il . append ( methodGen . loadDOM ( ) ) ; if ( step . isAbbreviatedDot ( ) ) { translate ( classGen , methodGen ) ; il . append ( new ICONST ( DOM . RETURN_CURRENT ) ) ; } else { ParentLocationPath path = new ParentLocationPath ( this , step ) ; try { path . typeCheck ( getParser ( ) . getSymbolTable ( ) ) ; } catch ( TypeCheckError e ) { } path . translate ( classGen , methodGen ) ; il . append ( new ICONST ( DOM . RETURN_PARENT ) ) ; } predicate . translate ( classGen , methodGen ) ; idx = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE_ITERATOR , GET_NODE_VALUE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( idx , 5 ) ) ; } else if ( predicate . isNthDescendant ( ) ) { il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ICONST ( predicate . getPosType ( ) ) ) ; predicate . translate ( classGen , methodGen ) ; il . append ( new ICONST ( 0 ) ) ; idx = cpg . addInterfaceMethodref ( DOM_INTF , "getNthDescendant" , "(IIZ)" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( idx , 4 ) ) ; } else if ( predicate . isNthPositionFilter ( ) ) { idx = cpg . addMethodref ( NTH_ITERATOR_CLASS , "<init>" , "(" + NODE_ITERATOR_SIG + "I)V" ) ; il . append ( new NEW ( cpg . addClass ( NTH_ITERATOR_CLASS ) ) ) ; il . append ( DUP ) ; translatePredicates ( classGen , methodGen ) ; predicate . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( idx ) ) ; } else { idx = cpg . addMethodref ( CURRENT_NODE_LIST_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + CURRENT_NODE_LIST_FILTER_SIG + NODE_SIG + TRANSLET_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( CURRENT_NODE_LIST_ITERATOR ) ) ) ; il . append ( DUP ) ; translatePredicates ( classGen , methodGen ) ; predicate . translateFilter ( classGen , methodGen ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { final String className = classGen . getClassName ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( new INVOKESPECIAL ( idx ) ) ; } } } public String toString ( ) { final StringBuffer buffer = new StringBuffer ( "step(\"" ) ; buffer . append ( Axis . names [ _axis ] ) . append ( "\", " ) . append ( _nodeType ) ; if ( _predicates != null ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; buffer . append ( ", " ) . append ( pred . toString ( ) ) ; } } return buffer . append ( ')' ) . toString ( ) ; } } 	1	['16', '4', '0', '30', '70', '10', '5', '28', '13', '0.566666667', '790', '1', '0', '0.829545455', '0.232142857', '2', '9', '48.125', '17', '3.375', '3']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class FilterParentPath extends Expression { private Expression _filterExpr ; private Expression _path ; private boolean _hasDescendantAxis = false ; public FilterParentPath ( Expression filterExpr , Expression path ) { ( _path = path ) . setParent ( this ) ; ( _filterExpr = filterExpr ) . setParent ( this ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _filterExpr . setParser ( parser ) ; _path . setParser ( parser ) ; } public String toString ( ) { return "FilterParentPath(" + _filterExpr + ", " + _path + ')' ; } public void setDescendantAxis ( ) { _hasDescendantAxis = true ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type ftype = _filterExpr . typeCheck ( stable ) ; if ( ftype instanceof NodeSetType == false ) { if ( ftype instanceof ReferenceType ) { _filterExpr = new CastExpr ( _filterExpr , Type . NodeSet ) ; } else if ( ftype instanceof NodeType ) { _filterExpr = new CastExpr ( _filterExpr , Type . NodeSet ) ; } else { throw new TypeCheckError ( this ) ; } } final Type ptype = _path . typeCheck ( stable ) ; if ( ! ( ptype instanceof NodeSetType ) ) { _path = new CastExpr ( _path , Type . NodeSet ) ; } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int initSI = cpg . addMethodref ( STEP_ITERATOR_CLASS , "<init>" , "(" + NODE_ITERATOR_SIG + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( STEP_ITERATOR_CLASS ) ) ) ; il . append ( DUP ) ; _filterExpr . translate ( classGen , methodGen ) ; _path . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( initSI ) ) ; if ( _hasDescendantAxis ) { final int incl = cpg . addMethodref ( NODE_ITERATOR_BASE , "includeSelf" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEVIRTUAL ( incl ) ) ; } if ( ! ( getParent ( ) instanceof RelativeLocationPath ) && ! ( getParent ( ) instanceof FilterParentPath ) ) { final int order = cpg . addInterfaceMethodref ( DOM_INTF , ORDER_ITERATOR , ORDER_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( order , 3 ) ) ; } } } 	1	['6', '3', '0', '23', '31', '0', '1', '22', '6', '0.333333333', '213', '1', '2', '0.934210526', '0.305555556', '2', '7', '34', '4', '1.3333', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import javax . xml . transform . Result ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . LexicalHandler ; public class ToHTMLSAXHandler extends ToSAXHandler { protected boolean m_escapeSetting = false ; public Properties getOutputFormat ( ) { return null ; } public OutputStream getOutputStream ( ) { return null ; } public Writer getWriter ( ) { return null ; } public void indent ( int n ) throws SAXException { } public void serialize ( Node node ) throws IOException { return ; } public boolean setEscaping ( boolean escape ) throws SAXException { boolean oldEscapeSetting = m_escapeSetting ; m_escapeSetting = escape ; if ( escape ) { processingInstruction ( Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } else { processingInstruction ( Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; } return oldEscapeSetting ; } public void setIndent ( boolean indent ) { } public void setOutputFormat ( Properties format ) { } public void setOutputStream ( OutputStream output ) { } public void setWriter ( Writer writer ) { } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { } public void elementDecl ( String name , String model ) throws SAXException { return ; } public void externalEntityDecl ( String arg0 , String arg1 , String arg2 ) throws SAXException { } public void internalEntityDecl ( String name , String value ) throws SAXException { } public void endElement ( String uri , String localName , String qName ) throws SAXException { flushPending ( ) ; m_saxHandler . endElement ( uri , localName , qName ) ; if ( m_tracer != null ) super . fireEndElem ( qName ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { } public void processingInstruction ( String arg0 , String arg1 ) throws SAXException { flushPending ( ) ; m_saxHandler . processingInstruction ( arg0 , arg1 ) ; if ( m_tracer != null ) super . fireEscapingEvent ( arg0 , arg1 ) ; } public void setDocumentLocator ( Locator arg0 ) { } public void skippedEntity ( String arg0 ) throws SAXException { } public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws SAXException { flushPending ( ) ; super . startElement ( namespaceURI , localName , qName , atts ) ; m_saxHandler . startElement ( namespaceURI , localName , qName , atts ) ; m_elemContext . m_startTagOpen = false ; } public void comment ( char [ ] ch , int start , int length ) throws SAXException { flushPending ( ) ; m_lexHandler . comment ( ch , start , length ) ; if ( m_tracer != null ) super . fireCommentEvent ( ch , start , length ) ; return ; } public void endCDATA ( ) throws SAXException { return ; } public void endDTD ( ) throws SAXException { } public void startCDATA ( ) throws SAXException { } public void startEntity ( String arg0 ) throws SAXException { } public void endDocument ( ) throws SAXException { flushPending ( ) ; m_saxHandler . endDocument ( ) ; if ( m_tracer != null ) super . fireEndDoc ( ) ; } protected void closeStartTag ( ) throws SAXException { m_elemContext . m_startTagOpen = false ; m_saxHandler . startElement ( EMPTYSTRING , m_elemContext . m_elementName , m_elemContext . m_elementName , m_attributes ) ; m_attributes . clear ( ) ; } public void close ( ) { return ; } public void characters ( final String chars ) throws SAXException { final int length = chars . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * 2 + 1 ] ; } chars . getChars ( 0 , length , m_charsBuff , 0 ) ; this . characters ( m_charsBuff , 0 , length ) ; } public ToHTMLSAXHandler ( ContentHandler handler , String encoding ) { super ( handler , encoding ) ; } public ToHTMLSAXHandler ( ContentHandler handler , LexicalHandler lex , String encoding ) { super ( handler , lex , encoding ) ; } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { super . startElement ( elementNamespaceURI , elementLocalName , elementName ) ; flushPending ( ) ; if ( m_lexHandler != null ) { String doctypeSystem = getDoctypeSystem ( ) ; String doctypePublic = getDoctypePublic ( ) ; if ( ( doctypeSystem != null ) || ( doctypePublic != null ) ) m_lexHandler . startDTD ( elementName , doctypePublic , doctypeSystem ) ; m_lexHandler = null ; } m_elemContext = m_elemContext . push ( elementNamespaceURI , elementLocalName , elementName ) ; } public void startElement ( String elementName ) throws SAXException { this . startElement ( null , null , elementName ) ; } public void endElement ( String elementName ) throws SAXException { flushPending ( ) ; m_saxHandler . endElement ( EMPTYSTRING , elementName , elementName ) ; if ( m_tracer != null ) super . fireEndElem ( elementName ) ; } public void characters ( char [ ] ch , int off , int len ) throws SAXException { flushPending ( ) ; m_saxHandler . characters ( ch , off , len ) ; if ( m_tracer != null ) super . fireCharEvent ( ch , off , len ) ; } public void flushPending ( ) throws SAXException { if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { if ( shouldFlush ) flushPending ( ) ; m_saxHandler . startPrefixMapping ( prefix , uri ) ; return false ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { startPrefixMapping ( prefix , uri , true ) ; } public void namespaceAfterStartElement ( final String prefix , final String uri ) throws SAXException { if ( m_elemContext . m_elementURI == null ) { String prefix1 = getPrefixPart ( m_elemContext . m_elementName ) ; if ( prefix1 == null && EMPTYSTRING . equals ( prefix ) ) { m_elemContext . m_elementURI = uri ; } } startPrefixMapping ( prefix , uri , false ) ; } public boolean reset ( ) { boolean wasReset = false ; if ( super . reset ( ) ) { resetToHTMLSAXHandler ( ) ; wasReset = true ; } return wasReset ; } private void resetToHTMLSAXHandler ( ) { this . m_escapeSetting = false ; } } 	1	['42', '3', '0', '6', '69', '763', '2', '4', '40', '0.902439024', '386', '1', '0', '0.735099338', '0.146520147', '3', '16', '8.166666667', '2', '0.9762', '3']
package org . apache . xml . utils ; import org . w3c . dom . Attr ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; public class AttList implements Attributes { NamedNodeMap m_attrs ; int m_lastIndex ; DOMHelper m_dh ; public AttList ( NamedNodeMap attrs , DOMHelper dh ) { m_attrs = attrs ; m_lastIndex = m_attrs . getLength ( ) - 1 ; m_dh = dh ; } public int getLength ( ) { return m_attrs . getLength ( ) ; } public String getURI ( int index ) { String ns = m_dh . getNamespaceOfNode ( ( ( Attr ) m_attrs . item ( index ) ) ) ; if ( null == ns ) ns = "" ; return ns ; } public String getLocalName ( int index ) { return m_dh . getLocalNameOfNode ( ( ( Attr ) m_attrs . item ( index ) ) ) ; } public String getQName ( int i ) { return ( ( Attr ) m_attrs . item ( i ) ) . getName ( ) ; } public String getType ( int i ) { return "CDATA" ; } public String getValue ( int i ) { return ( ( Attr ) m_attrs . item ( i ) ) . getValue ( ) ; } public String getType ( String name ) { return "CDATA" ; } public String getType ( String uri , String localName ) { return "CDATA" ; } public String getValue ( String name ) { Attr attr = ( ( Attr ) m_attrs . getNamedItem ( name ) ) ; return ( null != attr ) ? attr . getValue ( ) : null ; } public String getValue ( String uri , String localName ) { Node a = m_attrs . getNamedItemNS ( uri , localName ) ; return ( a == null ) ? null : a . getNodeValue ( ) ; } public int getIndex ( String uri , String localPart ) { for ( int i = m_attrs . getLength ( ) - 1 ; i >= 0 ; -- i ) { Node a = m_attrs . item ( i ) ; String u = a . getNamespaceURI ( ) ; if ( ( u == null ? uri == null : u . equals ( uri ) ) && a . getLocalName ( ) . equals ( localPart ) ) return i ; } return - 1 ; } public int getIndex ( String qName ) { for ( int i = m_attrs . getLength ( ) - 1 ; i >= 0 ; -- i ) { Node a = m_attrs . item ( i ) ; if ( a . getNodeName ( ) . equals ( qName ) ) return i ; } return - 1 ; } } 	1	['13', '1', '0', '2', '27', '0', '1', '1', '13', '0.694444444', '168', '0', '1', '0', '0.4', '0', '0', '11.69230769', '6', '1.6923', '1']
package org . apache . xalan . xsltc . trax ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . TemplatesHandler ; import org . apache . xalan . xsltc . compiler . CompilerException ; import org . apache . xalan . xsltc . compiler . Parser ; import org . apache . xalan . xsltc . compiler . SourceLoader ; import org . apache . xalan . xsltc . compiler . Stylesheet ; import org . apache . xalan . xsltc . compiler . SyntaxTreeNode ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . Attributes ; import java . util . Vector ; public class TemplatesHandlerImpl implements ContentHandler , TemplatesHandler , SourceLoader { private String _systemId ; private int _indentNumber ; private URIResolver _uriResolver = null ; private TransformerFactoryImpl _tfactory = null ; private Parser _parser = null ; private TemplatesImpl _templates = null ; protected TemplatesHandlerImpl ( int indentNumber , TransformerFactoryImpl tfactory ) { _indentNumber = indentNumber ; _tfactory = tfactory ; _parser = new XSLTC ( ) . getParser ( ) ; } public String getSystemId ( ) { return _systemId ; } public void setSystemId ( String id ) { _systemId = id ; } public void setURIResolver ( URIResolver resolver ) { _uriResolver = resolver ; } public Templates getTemplates ( ) { return _templates ; } public InputSource loadSource ( String href , String context , XSLTC xsltc ) { try { final Source source = _uriResolver . resolve ( href , context ) ; if ( source != null ) { return Util . getInputSource ( xsltc , source ) ; } } catch ( TransformerException e ) { } return null ; } public void startDocument ( ) { XSLTC xsltc = _parser . getXSLTC ( ) ; xsltc . init ( ) ; xsltc . setOutputType ( XSLTC . BYTEARRAY_OUTPUT ) ; _parser . startDocument ( ) ; } public void endDocument ( ) throws SAXException { _parser . endDocument ( ) ; try { XSLTC xsltc = _parser . getXSLTC ( ) ; String transletName = null ; if ( _systemId != null ) { transletName = Util . baseName ( _systemId ) ; } else { transletName = ( String ) _tfactory . getAttribute ( "translet-name" ) ; } xsltc . setClassName ( transletName ) ; transletName = xsltc . getClassName ( ) ; Stylesheet stylesheet = null ; SyntaxTreeNode root = _parser . getDocumentRoot ( ) ; if ( ! _parser . errorsFound ( ) && root != null ) { stylesheet = _parser . makeStylesheet ( root ) ; stylesheet . setSystemId ( _systemId ) ; stylesheet . setParentStylesheet ( null ) ; if ( _uriResolver != null ) { stylesheet . setSourceLoader ( this ) ; } _parser . setCurrentStylesheet ( stylesheet ) ; xsltc . setStylesheet ( stylesheet ) ; _parser . createAST ( stylesheet ) ; } if ( ! _parser . errorsFound ( ) && stylesheet != null ) { stylesheet . setMultiDocument ( xsltc . isMultiDocument ( ) ) ; stylesheet . setHasIdCall ( xsltc . hasIdCall ( ) ) ; synchronized ( xsltc . getClass ( ) ) { stylesheet . translate ( ) ; } } if ( ! _parser . errorsFound ( ) ) { final byte [ ] [ ] bytecodes = xsltc . getBytecodes ( ) ; if ( bytecodes != null ) { _templates = new TemplatesImpl ( xsltc . getBytecodes ( ) , transletName , _parser . getOutputProperties ( ) , _indentNumber , _tfactory ) ; if ( _uriResolver != null ) { _templates . setURIResolver ( _uriResolver ) ; } } } else { StringBuffer errorMessage = new StringBuffer ( ) ; Vector errors = _parser . getErrors ( ) ; final int count = errors . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { if ( errorMessage . length ( ) > 0 ) errorMessage . append ( '\n' ) ; errorMessage . append ( errors . elementAt ( i ) . toString ( ) ) ; } throw new SAXException ( ErrorMsg . JAXP_COMPILE_ERR , new TransformerException ( errorMessage . toString ( ) ) ) ; } } catch ( CompilerException e ) { throw new SAXException ( ErrorMsg . JAXP_COMPILE_ERR , e ) ; } } public void startPrefixMapping ( String prefix , String uri ) { _parser . startPrefixMapping ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) { _parser . endPrefixMapping ( prefix ) ; } public void startElement ( String uri , String localname , String qname , Attributes attributes ) throws SAXException { _parser . startElement ( uri , localname , qname , attributes ) ; } public void endElement ( String uri , String localname , String qname ) { _parser . endElement ( uri , localname , qname ) ; } public void characters ( char [ ] ch , int start , int length ) { _parser . characters ( ch , start , length ) ; } public void processingInstruction ( String name , String value ) { _parser . processingInstruction ( name , value ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) { _parser . ignorableWhitespace ( ch , start , length ) ; } public void skippedEntity ( String name ) { _parser . skippedEntity ( name ) ; } public void setDocumentLocator ( Locator locator ) { setSystemId ( locator . getSystemId ( ) ) ; _parser . setDocumentLocator ( locator ) ; } } 	1	['17', '1', '0', '9', '71', '0', '1', '9', '16', '0.78125', '336', '1', '3', '0', '0.22875817', '0', '0', '18.41176471', '1', '0.9412', '1']
package org . apache . xml . serializer ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Stack ; import org . xml . sax . ContentHandler ; import org . xml . sax . SAXException ; public class NamespaceMappings { private int count = 0 ; private java . util . Stack m_prefixStack = new Stack ( ) ; private Hashtable m_namespaces = new Hashtable ( ) ; private Stack m_nodeStack = new Stack ( ) ; private static final String EMPTYSTRING = "" ; private static final String XML_PREFIX = "xml" ; public NamespaceMappings ( ) { initNamespaces ( ) ; } private void initNamespaces ( ) { Stack stack ; m_namespaces . put ( EMPTYSTRING , stack = new Stack ( ) ) ; stack . push ( EMPTYSTRING ) ; m_prefixStack . push ( EMPTYSTRING ) ; m_namespaces . put ( XML_PREFIX , stack = new Stack ( ) ) ; stack . push ( "http://www.w3.org/XML/1998/namespace" ) ; m_prefixStack . push ( XML_PREFIX ) ; m_nodeStack . push ( new Integer ( - 1 ) ) ; } public String lookupNamespace ( String prefix ) { final Stack stack = ( Stack ) m_namespaces . get ( prefix ) ; return stack != null && ! stack . isEmpty ( ) ? ( String ) stack . peek ( ) : null ; } public String lookupPrefix ( String uri ) { String foundPrefix = null ; Enumeration prefixes = m_namespaces . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; String uri2 = lookupNamespace ( prefix ) ; if ( uri2 != null && uri2 . equals ( uri ) ) { foundPrefix = prefix ; break ; } } return foundPrefix ; } public boolean popNamespace ( String prefix ) { if ( prefix . startsWith ( XML_PREFIX ) ) { return false ; } Stack stack ; if ( ( stack = ( Stack ) m_namespaces . get ( prefix ) ) != null ) { stack . pop ( ) ; return true ; } return false ; } public boolean pushNamespace ( String prefix , String uri , int elemDepth ) { if ( prefix . startsWith ( XML_PREFIX ) ) { return false ; } Stack stack ; if ( ( stack = ( Stack ) m_namespaces . get ( prefix ) ) == null ) { m_namespaces . put ( prefix , stack = new Stack ( ) ) ; } if ( ! stack . empty ( ) && uri . equals ( stack . peek ( ) ) ) { return false ; } stack . push ( uri ) ; m_prefixStack . push ( prefix ) ; m_nodeStack . push ( new Integer ( elemDepth ) ) ; return true ; } public void popNamespaces ( int elemDepth , ContentHandler saxHandler ) { while ( true ) { if ( m_nodeStack . isEmpty ( ) ) return ; Integer i = ( Integer ) ( m_nodeStack . peek ( ) ) ; if ( i . intValue ( ) < elemDepth ) return ; m_nodeStack . pop ( ) ; final String prefix = ( String ) m_prefixStack . pop ( ) ; popNamespace ( prefix ) ; if ( saxHandler != null ) { try { saxHandler . endPrefixMapping ( prefix ) ; } catch ( SAXException e ) { } } } } public String generateNextPrefix ( ) { return "ns" + ( count ++ ) ; } public Object clone ( ) throws CloneNotSupportedException { NamespaceMappings clone = new NamespaceMappings ( ) ; clone . m_prefixStack = ( Stack ) m_prefixStack . clone ( ) ; clone . m_nodeStack = ( Stack ) m_nodeStack . clone ( ) ; clone . m_namespaces = ( Hashtable ) m_namespaces . clone ( ) ; clone . count = count ; return clone ; } public final void reset ( ) { this . count = 0 ; this . m_namespaces . clear ( ) ; this . m_nodeStack . clear ( ) ; this . m_prefixStack . clear ( ) ; initNamespaces ( ) ; } } 	1	['10', '1', '0', '14', '36', '0', '14', '0', '9', '0.648148148', '301', '1', '0', '0', '0.425', '0', '0', '28.5', '5', '2', '2']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . utils . XMLChar ; final class XslElement extends Instruction { private String _prefix ; private boolean _ignore = false ; private boolean _isLiteralName = true ; private AttributeValueTemplate _name ; private AttributeValueTemplate _namespace ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "Element " + _name ) ; displayContents ( indent + IndentIncrement ) ; } public boolean declaresDefaultNS ( ) { return false ; } public void parseContents ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; String name = getAttribute ( "name" ) ; if ( name == EMPTYSTRING ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_ELEM_NAME_ERR , name , this ) ; parser . reportError ( WARNING , msg ) ; parseChildren ( parser ) ; _ignore = true ; return ; } String namespace = getAttribute ( "namespace" ) ; _isLiteralName = Util . isLiteral ( name ) ; if ( _isLiteralName ) { if ( ! XMLChar . isValidQName ( name ) ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_ELEM_NAME_ERR , name , this ) ; parser . reportError ( WARNING , msg ) ; parseChildren ( parser ) ; _ignore = true ; return ; } final QName qname = parser . getQNameSafe ( name ) ; String prefix = qname . getPrefix ( ) ; String local = qname . getLocalPart ( ) ; if ( prefix == null ) { prefix = EMPTYSTRING ; } if ( ! hasAttribute ( "namespace" ) ) { namespace = lookupNamespace ( prefix ) ; if ( namespace == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NAMESPACE_UNDEF_ERR , prefix , this ) ; parser . reportError ( WARNING , err ) ; parseChildren ( parser ) ; _ignore = true ; return ; } _prefix = prefix ; _namespace = new AttributeValueTemplate ( namespace , parser , this ) ; } else { if ( prefix == EMPTYSTRING ) { if ( Util . isLiteral ( namespace ) ) { prefix = lookupPrefix ( namespace ) ; if ( prefix == null ) { prefix = stable . generateNamespacePrefix ( ) ; } } final StringBuffer newName = new StringBuffer ( prefix ) ; if ( prefix != EMPTYSTRING ) { newName . append ( ':' ) ; } name = newName . append ( local ) . toString ( ) ; } _prefix = prefix ; _namespace = new AttributeValueTemplate ( namespace , parser , this ) ; } } else { _namespace = ( namespace == EMPTYSTRING ) ? null : new AttributeValueTemplate ( namespace , parser , this ) ; } _name = new AttributeValueTemplate ( name , parser , this ) ; final String useSets = getAttribute ( "use-attribute-sets" ) ; if ( useSets . length ( ) > 0 ) { if ( ! Util . isValidQNames ( useSets ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , useSets , this ) ; parser . reportError ( Constants . ERROR , err ) ; } setFirstElement ( new UseAttributeSets ( useSets , parser ) ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( ! _ignore ) { _name . typeCheck ( stable ) ; if ( _namespace != null ) { _namespace . typeCheck ( stable ) ; } } typeCheckContents ( stable ) ; return Type . Void ; } public void translateLiteral ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( ! _ignore ) { il . append ( methodGen . loadHandler ( ) ) ; _name . translate ( classGen , methodGen ) ; il . append ( DUP2 ) ; il . append ( methodGen . startElement ( ) ) ; if ( _namespace != null ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _prefix ) ) ; _namespace . translate ( classGen , methodGen ) ; il . append ( methodGen . namespace ( ) ) ; } } translateContents ( classGen , methodGen ) ; if ( ! _ignore ) { il . append ( methodGen . endElement ( ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { LocalVariableGen local = null ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _isLiteralName ) { translateLiteral ( classGen , methodGen ) ; return ; } if ( ! _ignore ) { LocalVariableGen nameValue = methodGen . addLocalVariable2 ( "nameValue" , Util . getJCRefType ( STRING_SIG ) , il . getEnd ( ) ) ; _name . translate ( classGen , methodGen ) ; il . append ( new ASTORE ( nameValue . getIndex ( ) ) ) ; il . append ( new ALOAD ( nameValue . getIndex ( ) ) ) ; final int check = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "checkQName" , "(" + STRING_SIG + ")V" ) ; il . append ( new INVOKESTATIC ( check ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new ALOAD ( nameValue . getIndex ( ) ) ) ; if ( _namespace != null ) { _namespace . translate ( classGen , methodGen ) ; } else { il . append ( ACONST_NULL ) ; } il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "startXslElement" , "(" + STRING_SIG + STRING_SIG + TRANSLET_OUTPUT_SIG + DOM_INTF_SIG + "I)" + STRING_SIG ) ) ) ; } translateContents ( classGen , methodGen ) ; if ( ! _ignore ) { il . append ( methodGen . endElement ( ) ) ; } } public void translateContents ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final SyntaxTreeNode item = ( SyntaxTreeNode ) getContents ( ) . elementAt ( i ) ; if ( _ignore && item instanceof XslAttribute ) continue ; item . translate ( classGen , methodGen ) ; } } } 	1	['8', '3', '0', '28', '65', '0', '1', '27', '7', '0.542857143', '498', '1', '2', '0.888888889', '0.354166667', '1', '9', '60.625', '14', '3.75', '1']
package org . apache . xml . utils . res ; public class XResources_it extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "it" } , { "help_language" , "it" } , { "language" , "it" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '314', '0', '0', '0.976190476', '1', '0', '0', '103.3333333', '1', '0.3333', '1']
package org . apache . xml . utils . res ; public class XResources_ko extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ko" } , { "help_language" , "ko" } , { "language" , "ko" } , { "alphabet" , new char [ ] { 0x3131 , 0x3134 , 0x3137 , 0x3139 , 0x3141 , 0x3142 , 0x3145 , 0x3147 , 0x3148 , 0x314a , 0x314b , 0x314c , 0x314d , 0x314e , 0x314f , 0x3151 , 0x3153 , 0x3155 , 0x3157 , 0x315b , 0x315c , 0x3160 , 0x3161 , 0x3163 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "zero" , new char [ 0 ] } , { "multiplier" , new int [ ] { 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0xc5b5 , 0xb9cc , 0xcc9c , 0xbc31 , 0xc2ed } } , { "digits" , new char [ ] { 0xc77c , 0xc774 , 0xc0bc , 0xc0ac , 0xc624 , 0xc721 , 0xce60 , 0xd314 , 0xad6c } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '487', '0', '0', '0.976190476', '1', '0', '0', '161', '1', '0.3333', '1']
package org . apache . xml . utils . res ; public class XResources_ka extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ka" } , { "help_language" , "ka" } , { "language" , "ka" } , { "alphabet" , new char [ ] { 0x10D0 , 0x10D1 , 0x10D2 , 0x10D3 , 0x10D4 , 0x10D5 , 0x10D6 , 0x10f1 , 0x10D7 , 0x10D8 , 0x10D9 , 0x10DA , 0x10DB , 0x10DC , 0x10f2 , 0x10DD , 0x10DE , 0x10DF , 0x10E0 , 0x10E1 , 0x10E2 , 0x10E3 , 0x10E4 , 0x10E5 , 0x10E6 , 0x10E7 , 0x10E8 , 0x10E9 , 0x10EA , 0x10EB , 0x10EC , 0x10ED , 0x10EE , 0x10F4 , 0x10EF , 0x10F0 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , { "numberGroups" , new int [ ] { 1000 , 100 , 10 , 1 } } , { "digits" , new char [ ] { 0x10D0 , 0x10D1 , 0x10D2 , 0x10D3 , 0x10D4 , 0x10D5 , 0x10D6 , 0x10f1 , 0x10D7 } } , { "tens" , new char [ ] { 0x10D8 , 0x10D9 , 0x10DA , 0x10DB , 0x10DC , 0x10f2 , 0x10DD , 0x10DE , 0x10DF } } , { "hundreds" , new char [ ] { 0x10E0 , 0x10E1 , 0x10E2 , 0x10E3 , 0x10E4 , 0x10E5 , 0x10E6 , 0x10E7 , 0x10E8 } } , { "thousands" , new char [ ] { 0x10E9 , 0x10EA , 0x10EB , 0x10EC , 0x10ED , 0x10EE , 0x10F4 , 0x10EF , 0x10F0 } } , { "tables" , new String [ ] { "thousands" , "hundreds" , "tens" , "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '614', '0', '0', '0.976190476', '1', '0', '0', '203.3333333', '1', '0.3333', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchInstruction ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . RealType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . runtime . Operators ; final class RelationalExpr extends Expression implements Operators { private int _op ; private Expression _left , _right ; public RelationalExpr ( int op , Expression left , Expression right ) { _op = op ; ( _left = left ) . setParent ( this ) ; ( _right = right ) . setParent ( this ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public boolean hasPositionCall ( ) { if ( _left . hasPositionCall ( ) ) return true ; if ( _right . hasPositionCall ( ) ) return true ; return false ; } public boolean hasLastCall ( ) { return ( _left . hasLastCall ( ) || _right . hasLastCall ( ) ) ; } public boolean hasReferenceArgs ( ) { return _left . getType ( ) instanceof ReferenceType || _right . getType ( ) instanceof ReferenceType ; } public boolean hasNodeArgs ( ) { return _left . getType ( ) instanceof NodeType || _right . getType ( ) instanceof NodeType ; } public boolean hasNodeSetArgs ( ) { return _left . getType ( ) instanceof NodeSetType || _right . getType ( ) instanceof NodeSetType ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type tleft = _left . typeCheck ( stable ) ; Type tright = _right . typeCheck ( stable ) ; if ( tleft instanceof ResultTreeType && tright instanceof ResultTreeType ) { _right = new CastExpr ( _right , Type . Real ) ; _left = new CastExpr ( _left , Type . Real ) ; return _type = Type . Boolean ; } if ( hasReferenceArgs ( ) ) { Type type = null ; Type typeL = null ; Type typeR = null ; if ( tleft instanceof ReferenceType ) { if ( _left instanceof VariableRefBase ) { VariableRefBase ref = ( VariableRefBase ) _left ; VariableBase var = ref . getVariable ( ) ; typeL = var . getType ( ) ; } } if ( tright instanceof ReferenceType ) { if ( _right instanceof VariableRefBase ) { VariableRefBase ref = ( VariableRefBase ) _right ; VariableBase var = ref . getVariable ( ) ; typeR = var . getType ( ) ; } } if ( typeL == null ) type = typeR ; else if ( typeR == null ) type = typeL ; else { type = Type . Real ; } if ( type == null ) type = Type . Real ; _right = new CastExpr ( _right , type ) ; _left = new CastExpr ( _left , type ) ; return _type = Type . Boolean ; } if ( hasNodeSetArgs ( ) ) { if ( tright instanceof NodeSetType ) { final Expression temp = _right ; _right = _left ; _left = temp ; _op = ( _op == Operators . GT ) ? Operators . LT : ( _op == Operators . LT ) ? Operators . GT : ( _op == Operators . GE ) ? Operators . LE : Operators . GE ; tright = _right . getType ( ) ; } if ( tright instanceof NodeType ) { _right = new CastExpr ( _right , Type . NodeSet ) ; } if ( tright instanceof IntType ) { _right = new CastExpr ( _right , Type . Real ) ; } if ( tright instanceof ResultTreeType ) { _right = new CastExpr ( _right , Type . String ) ; } return _type = Type . Boolean ; } if ( hasNodeArgs ( ) ) { if ( tleft instanceof BooleanType ) { _right = new CastExpr ( _right , Type . Boolean ) ; tright = Type . Boolean ; } if ( tright instanceof BooleanType ) { _left = new CastExpr ( _left , Type . Boolean ) ; tleft = Type . Boolean ; } } MethodType ptype = lookupPrimop ( stable , Operators . names [ _op ] , new MethodType ( Type . Void , tleft , tright ) ) ; if ( ptype != null ) { Type arg1 = ( Type ) ptype . argsType ( ) . elementAt ( 0 ) ; if ( ! arg1 . identicalTo ( tleft ) ) { _left = new CastExpr ( _left , arg1 ) ; } Type arg2 = ( Type ) ptype . argsType ( ) . elementAt ( 1 ) ; if ( ! arg2 . identicalTo ( tright ) ) { _right = new CastExpr ( _right , arg1 ) ; } return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( hasNodeSetArgs ( ) || hasReferenceArgs ( ) ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; _left . startIterator ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; _right . startIterator ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , _op ) ) ; il . append ( methodGen . loadDOM ( ) ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "compare" , "(" + _left . getType ( ) . toSignature ( ) + _right . getType ( ) . toSignature ( ) + "I" + DOM_INTF_SIG + ")Z" ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else { translateDesynthesized ( classGen , methodGen ) ; synthesize ( classGen , methodGen ) ; } } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( hasNodeSetArgs ( ) || hasReferenceArgs ( ) ) { translate ( classGen , methodGen ) ; desynthesize ( classGen , methodGen ) ; } else { BranchInstruction bi = null ; final InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; boolean tozero = false ; Type tleft = _left . getType ( ) ; if ( tleft instanceof RealType ) { il . append ( tleft . CMP ( _op == LT || _op == LE ) ) ; tleft = Type . Int ; tozero = true ; } switch ( _op ) { case LT : bi = tleft . GE ( tozero ) ; break ; case GT : bi = tleft . LE ( tozero ) ; break ; case LE : bi = tleft . GT ( tozero ) ; break ; case GE : bi = tleft . LT ( tozero ) ; break ; default : ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_RELAT_OP_ERR , this ) ; getParser ( ) . reportError ( Constants . FATAL , msg ) ; } _falseList . add ( il . append ( bi ) ) ; } } public String toString ( ) { return Operators . names [ _op ] + '(' + _left + ", " + _right + ')' ; } } 	1	['11', '3', '0', '31', '56', '0', '0', '31', '11', '0.2', '613', '1', '2', '0.87654321', '0.246753247', '2', '9', '54.45454545', '7', '2.5455', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_tr extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Hata: İfade içinde '{' olamaz" } , { ER_ILLEGAL_ATTRIBUTE , "{0} geçersiz {1} özniteliğini içeriyor" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "xsl:apply-imports içinde sourceNode boş değerli!" } , { ER_CANNOT_ADD , "{0}, {1} içine eklenemiyor" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "handleApplyTemplatesInstruction içinde sourceNode boş değerli!" } , { ER_NO_NAME_ATTRIB , "{0} için öznitelik belirtilmeli." } , { ER_TEMPLATE_NOT_FOUND , "Adı {0} olan şablon bulunamadı" } , { ER_CANT_RESOLVE_NAME_AVT , "xsl:call-template içinde AVT adı çözülemedi." } , { ER_REQUIRES_ATTRIB , "{0} için {1} özniteliği gerekiyor." } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} için ''test'' özniteliği gerekiyor." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "{0} düzey özniteliğinde hatalı değer." } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "processing-instruction adı 'xml' olamaz" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "processing-instruction adı geçerli bir NCName olmalıdır: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} kip içeriyorsa match özniteliği olması gerekir." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} için name ya da match özniteliği gerekiyor." } , { ER_CANT_RESOLVE_NSPREFIX , "Ad alanı öneki {0} çözülemiyor." } , { ER_ILLEGAL_VALUE , "xml:space geçersiz {0} değerini içeriyor." } , { ER_NO_OWNERDOC , "Alt düğümün iye belgesi yok!" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement hatası: {0}" } , { ER_NULL_CHILD , "Boş değerli (null) alt öğe ekleme girişimi!" } , { ER_NEED_SELECT_ATTRIB , "{0} için select özniteliği gerekiyor." } , { ER_NEED_TEST_ATTRIB , "xsl:when için 'test' özniteliği gereklidir." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param için 'name' özniteliği gereklidir." } , { ER_NO_CONTEXT_OWNERDOC , "Bağlamın iye belgesi yok!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "XML TransformerFactory ilişkisi {0} yaratılamadı" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: Process başarılı olmadı." } , { ER_NOT_SUCCESSFUL , "Xalan: başarılı olmadı." } , { ER_ENCODING_NOT_SUPPORTED , "{0} kodlaması desteklenmiyor." } , { ER_COULD_NOT_CREATE_TRACELISTENER , "TraceListener {0} yaratılamadı." } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key için 'name' özniteliği gerekiyor!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key için 'match' özniteliği gerekiyor!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key için 'use' özniteliği gerekiyor!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} için ''elements'' özniteliği gerekiyor!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} özniteliği ''prefix'' eksik" } , { ER_BAD_STYLESHEET_URL , "Biçem yaprağı URL adresi {0} geçersiz" } , { ER_FILE_NOT_FOUND , "Biçem yaprağı dosyası bulunamadı: {0}" } , { ER_IOEXCEPTION , "Biçem yaprağı dosyası {0} ile GÇ kural dışı durumu oluştu" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) {0} için href özniteliği bulunamadı" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} doğrudan ya da dolaylı olarak kendisini içeriyor!" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude hatası, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} özniteliği ''lang'' eksik" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) {0} öğesinin yeri yanlış? taşıyıcı öğesi ''component'' eksik" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Çıkış yalnızca şunlara yöneltilebilir: Element, DocumentFragment, Document ya da PrintWriter." } , { ER_PROCESS_ERROR , "StylesheetRoot.process hatası" } , { ER_UNIMPLNODE_ERROR , "UnImplNode hatası: {0}" } , { ER_NO_SELECT_EXPRESSION , "Hata! xpath select ifadesi (-select) bulunamadı." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "XSLProcessor diziselleştirilemez!" } , { ER_NO_INPUT_STYLESHEET , "Biçem yaprağı girişi belirtilmedi!" } , { ER_FAILED_PROCESS_STYLESHEET , "Biçem yaprağı işlenemedi!" } , { ER_COULDNT_PARSE_DOC , "{0} belgesi ayrıştırılamadı!" } , { ER_COULDNT_FIND_FRAGMENT , "Parça bulunamadı: {0}" } , { ER_NODE_NOT_ELEMENT , "Parça tanıtıcısının gösterdiği düğüm bir öğe değildi: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each için eşleşme ya da ad özniteliği gerekir" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "templates için eşleşme ya da ad özniteliği gerekir" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Belge parçasının eşkopyası değil!" } , { ER_CANT_CREATE_ITEM , "Sonuç ağacında öğe yaratılamıyor: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "Kaynak XML içinde xml:space geçersiz değer içeriyor: {0}" } , { ER_NO_XSLKEY_DECLARATION , "{0} için xsl:key bildirimi yok!" } , { ER_CANT_CREATE_URL , "Hata! İlgili url yaratılamıyor: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions desteklenmiyor" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory Hatası" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} biçem yaprağı içinde olamaz!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns artık desteklenmiyor! Yerine xsl:output kullanın." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space artık desteklenmiyor!  Yerine xsl:strip-space ya da xsl:preserve-space kullanın." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result artık desteklenmiyor!  Yerine xsl:output kullanın." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} geçersiz {1} özniteliğini içeriyor" } , { ER_UNKNOWN_XSL_ELEM , "Bilinmeyen XSL öğesi: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort yalnızca xsl:apply-templates ya da xsl:for-each ile kullanılabilir." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when yeri yanlış!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when öğesinin üst öğesi xsl:choose değil!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise yeri yanlış!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise öğesinin üst öğesi xsl:choose değil!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} şablon içinde kullanılamaz!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} eklenti ad alanı öneki {1} bilinmiyor" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Import öğeleri, biçem yaprağının ilk öğeleri olarak geçebilir!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} doğrudan ya da dolaylı olarak kendisini içe aktarıyor!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:space geçersiz {0} değerini içeriyor" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet başarısız oldu!" } , { ER_SAX_EXCEPTION , "SAX kural dışı durumu" } , { ER_XSLT_ERROR , "XSLT hatası" } , { ER_CURRENCY_SIGN_ILLEGAL , "Biçim örüntüsü dizgisinde para birimi simgesi olamaz" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Stylesheet DOM belge işlevini desteklemiyor!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Önek dışı çözücünün öneki çözülemez." } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Yeniden yönlendirme eklentisi: Dosya adı alınamadı - file ya da select özniteliği geçerli bir dizgi döndürmelidir." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Yeniden yönlendirme eklentisinde FormatterListener oluşturulamadı!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "exclude-result-prefixes içindeki önek geçerli değil: {0}" } , { ER_MISSING_NS_URI , "Belirtilen önek için ad alanı URI eksik" } , { ER_MISSING_ARG_FOR_OPTION , "{0} seçeneği için bağımsız değişken eksik" } , { ER_INVALID_OPTION , "Geçersiz seçenek: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Bozuk biçimli biçim dizgisi: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet için 'version' özniteliği gerekiyor!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "{0} özniteliği geçersiz {1} değerini içeriyor" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose için xsl:when gerekiyor" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports, xsl:for-each içinde kullanılamaz" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Çıkış DOM düğümü için DTMLiaison kullanılamaz... onun yerine org.apache.xpath.DOM2Helper aktarın!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Giriş DOM düğümü için DTMLiaison kullanılamaz... onun yerine org.apache.xpath.DOM2Helper aktarın!" } , { ER_CALL_TO_EXT_FAILED , "Eklenti öğesine çağrı başarısız oldu: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Önek bir ad alanına çözülmelidir: {0}" } , { ER_INVALID_UTF16_SURROGATE , "UTF-16 yerine kullanılan değer geçersiz: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} kendisini kullandı, sonsuz döngü oluşacak." } , { ER_CANNOT_MIX_XERCESDOM , "Xerces-DOM dışı giriş Xerces-DOM çıkışla birleştirilemez!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "ElemTemplateElement.readObject içinde: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Bu adı taşıyan birden çok şablon saptandı: {0}" } , { ER_INVALID_KEY_CALL , "Geçersiz işlev çağrısı: Özyineli key() çağrılarına izin verilmez" } , { ER_REFERENCING_ITSELF , "{0} değişkeni doğrudan ya da dolaylı olarak kendisine başvuruda bulunuyor!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "newTemplates ile ilgili DOMSource için giriş düğümü boş değerli olamaz!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "{0} seçeneği için sınıf dosyası bulunamadı" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Gerekli öğe bulunamadı: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream boş değerli olamaz" } , { ER_URI_CANNOT_BE_NULL , "URI boş değerli olamaz" } , { ER_FILE_CANNOT_BE_NULL , "Dosya boş değerli olamaz" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource boş değerli olamaz" } , { ER_CANNOT_INIT_BSFMGR , "BSF Manager kullanıma hazırlanamadı" } , { ER_CANNOT_CMPL_EXTENSN , "Eklenti derlenemedi" } , { ER_CANNOT_CREATE_EXTENSN , "Eklenti yaratılamadı: {0} nedeni: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "{0} yöntemine yönelik Instance yöntemi, birincil bağımsız değişkenin somutlaşan nesne örneği olmasını gerektirir" } , { ER_INVALID_ELEMENT_NAME , "Belirtilen öğe adı geçersiz {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Öğe adı yöntemi durağan {0} olmalı" } , { ER_EXTENSION_FUNC_UNKNOWN , "Eklenti işlevi {0} : {1} bilinmiyor" } , { ER_MORE_MATCH_CONSTRUCTOR , "{0} ile ilgili oluşturucu için en iyi eşleşme sayısı birden çok" } , { ER_MORE_MATCH_METHOD , "{0} yöntemi için en iyi eşleşme sayısı birden çok" } , { ER_MORE_MATCH_ELEMENT , "{0} öğe yöntemi için en iyi eşleşme sayısı birden çok" } , { ER_INVALID_CONTEXT_PASSED , "{0} değerlendirmesi için geçersiz bağlam aktarıldı" } , { ER_POOL_EXISTS , "Havuz zaten var" } , { ER_NO_DRIVER_NAME , "Sürücü adı belirtilmedi" } , { ER_NO_URL , "URL belirtilmedi" } , { ER_POOL_SIZE_LESSTHAN_ONE , "Havuz büyüklüğü birden az!" } , { ER_INVALID_DRIVER , "Belirtilen sürücü adı geçersiz!" } , { ER_NO_STYLESHEETROOT , "Biçem yaprağı kökü bulunamadı!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "xml:space için geçersiz değer" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode başarısız oldu" } , { ER_RESOURCE_COULD_NOT_LOAD , "Kaynak [ {0} ] yükleyemedi: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Arabellek büyüklüğü <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Eklenti çağrılırken bilinmeyen hata" } , { ER_NO_NAMESPACE_DECL , "{0} önekinin ilişkili bir ad alanı bildirimi yok" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "lang=javaclass {0} için öğe içeriğine izin verilmiyor" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Biçem yaprağı yönlendirmeli sonlandırma" } , { ER_ONE_OR_TWO , "1 ya da 2" } , { ER_TWO_OR_THREE , "2 ya da 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "{0} yüklenemedi (CLASSPATH değişkenini inceleyin), yalnızca varsayılanlar kullanılıyor" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Varsayılan şablonlar kullanıma hazırlanamıyor" } , { ER_RESULT_NULL , "Sonuç boş değerli olmamalı" } , { ER_RESULT_COULD_NOT_BE_SET , "Sonuç tanımlanamadı" } , { ER_NO_OUTPUT_SPECIFIED , "Çıkış belirtilmedi" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "{0} tipi sonuca dönüştürülemiyor" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "{0} tipi kaynak dönüştürülemiyor" } , { ER_NULL_CONTENT_HANDLER , "Boş değerli içerik işleyici" } , { ER_NULL_ERROR_HANDLER , "Boş değerli hata işleyici" } , { ER_CANNOT_CALL_PARSE , "ContentHandler tanımlanmadıysa parse çağrılamaz" } , { ER_NO_PARENT_FOR_FILTER , "Süzgecin üst öğesi yok" } , { ER_NO_STYLESHEET_IN_MEDIA , "Biçem yaprağı burada bulunamadı: {0}, ortam= {1}" } , { ER_NO_STYLESHEET_PI , "xml-stylesheet PI burada bulunamadı: {0}" } , { ER_NOT_SUPPORTED , "Desteklenmiyor: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "{0} özelliğinin değeri Boole somut örneği olmalı" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "{0} içinde dış komut dosyasına ulaşılamadı" } , { ER_RESOURCE_COULD_NOT_FIND , "Kaynak [ {0} ] bulunamadı.\n{1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Çıkış özelliği tanınmıyor: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "ElemLiteralResult somut örneği yaratılması başarısız oldu" } , { ER_VALUE_SHOULD_BE_NUMBER , "{0} değeri ayrıştırılabilir bir sayı içermelidir" } , { ER_VALUE_SHOULD_EQUAL , "{0} değeri yes ya da no olmalı" } , { ER_FAILED_CALLING_METHOD , "{0} yöntemi çağrısı başarısız oldu" } , { ER_FAILED_CREATING_ELEMTMPL , "ElemTemplateElement somut örneği yaratılması başarısız oldu" } , { ER_CHARS_NOT_ALLOWED , "Belgenin bu noktasında karakterlere izin verilmez" } , { ER_ATTR_NOT_ALLOWED , "\"{0}\" özniteliği {1} öğesinde kullanılamaz!" } , { ER_BAD_VALUE , "{0} hatalı değer {1}" } , { ER_ATTRIB_VALUE_NOT_FOUND , "{0} öznitelik değeri bulunamadı" } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "{0} öznitelik değeri tanınmıyor" } , { ER_NULL_URI_NAMESPACE , "Boş değerli URI ile ad alanı öneki oluşturma girişimi" } , { ER_NUMBER_TOO_BIG , "En büyük uzun tamsayıdan daha büyük bir sayı biçimleme girişimi" } , { ER_CANNOT_FIND_SAX1_DRIVER , "SAX1 sürücü sınıfı {0} bulunamıyor" } , { ER_SAX1_DRIVER_NOT_LOADED , "SAX1 sürücü sınıfı {0} bulundu, ancak yüklenemiyor" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "SAX1 sürücü sınıfı {0} yüklendi, ancak somutlaştırılamıyor" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1 sürücü sınıfı {0} org.xml.sax.Parser özelliğini uygulamıyor" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Sistem özelliği org.xml.sax.parser belirtilmedi" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Ayrıştırıcı (Parser) bağımsız değişkeni boş değerli olmamalı" } , { ER_FEATURE , "Özellik: {0}" } , { ER_PROPERTY , "Özellik: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Boş değerli varlık çözücü" } , { ER_NULL_DTD_HANDLER , "Boş değerli DTD işleyici" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Sürücü adı belirtilmedi!" } , { ER_NO_URL_SPECIFIED , "URL belirtilmedi!" } , { ER_POOLSIZE_LESS_THAN_ONE , "Havuz büyüklüğü birden az!" } , { ER_INVALID_DRIVER_NAME , "Belirtilen sürücü adı geçersiz!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Programcı hatası! expr için ElemTemplateElement üst öğesi yok!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "RundundentExprEliminator içinde programcı değerlendirmesi: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} biçem yaprağında bu konumda bulunamaz!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Beyaz alan dışı metin biçem yaprağında bu konumda bulunamaz!" } , { INVALID_TCHAR , "CHAR özniteliği {0} için geçersiz {1} değeri kullanıldı. CHAR tipinde bir öznitelik yalnızca 1 karakter olmalıdır!" } , { INVALID_QNAME , "QNAME özniteliği {0} için geçersiz {1} değeri kullanıldı" } , { INVALID_ENUM , "ENUM özniteliği {0} için geçersiz {1} değeri kullanıldı. Geçerli değerler: {2}." } , { INVALID_NMTOKEN , "NMTOKEN özniteliği {0} için geçersiz {1} değeri kullanıldı" } , { INVALID_NCNAME , "NCNAME özniteliği {0} için geçersiz {1} değeri kullanıldı" } , { INVALID_BOOLEAN , "boolean özniteliği {0} için geçersiz {1} değeri kullanıldı" } , { INVALID_NUMBER , "number özniteliği {0} için geçersiz {1} değeri kullanıldı" } , { ER_ARG_LITERAL , "Eşleşme örüntüsünde {0} işlevine ilişkin bağımsız değişken bir hazır bilgi olmalıdır." } , { ER_DUPLICATE_GLOBAL_VAR , "Yinelenen genel değişken bildirimi." } , { ER_DUPLICATE_VAR , "Yinelenen değişken bildirimi." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template bir name ya da match özniteliği (ya da her ikisini) içermelidir" } , { ER_INVALID_PREFIX , "exclude-result-prefixes içindeki önek geçerli değil: {0}" } , { ER_NO_ATTRIB_SET , "{0} adlı öznitelik kümesi yok" } , { WG_FOUND_CURLYBRACE , "'}' bulundu, ancak açık öznitelik şablonu yok!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Uyarı: count özniteliği xsl:number içindeki bir üst öznitelikle eşleşmiyor! Hedef = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Eski sözdizimi: 'expr' özniteliğinin adı 'select' olarak değiştirildi." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan henüz format-number işlevinde ülke değeri adını işlemiyor." } , { WG_LOCALE_NOT_FOUND , "Uyarı: xml:lang={0} ile ilgili ülke değeri bulunamadı" } , { WG_CANNOT_MAKE_URL_FROM , "Dizgiden URL oluşturulamadı: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "İstenen belge yüklenemiyor: {0}" } , { WG_CANNOT_FIND_COLLATOR , "<sort xml:lang={0} için Collator bulunamadı" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Eski sözdizimi: functions yönergesi {0} url adresini kullanmalıdır" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "{0} kodlaması desteklenmiyor, UTF-8 kullanılıyor" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "{0} kodlaması desteklenmiyor, Java {1} kullanılıyor" } , { WG_SPECIFICITY_CONFLICTS , "Belirtim çatışmaları saptandı: {0} Biçem yaprağında son bulunan kullanılacak." } , { WG_PARSING_AND_PREPARING , "========= {0} ayrıştırılıyor ve hazırlanıyor ==========" } , { WG_ATTR_TEMPLATE , "Öznitelik şablonu, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "xsl:strip-space ile xsl:preserve-space arasında eşleşme çatışması" } , { WG_ATTRIB_NOT_HANDLED , "Xalan henüz {0} özniteliğini işlemiyor!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Onlu biçimi için bildirim bulunamadı: {0}" } , { WG_OLD_XSLT_NS , "Eksik ya da yanlış XSLT ad alanı." } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Varsayılan tek bir xsl:decimal-format bildirimine izin verilir." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format adları benzersiz olmalıdır. \"{0}\" adı yineleniyor." } , { WG_ILLEGAL_ATTRIBUTE , "{0} geçersiz {1} özniteliğini içeriyor" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Ad alanı öneki {0} çözülemedi. Düğüm yoksayılacak." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet için 'version' özniteliği gerekiyor!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Geçersiz öznitelik adı: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "{0} özniteliği için geçersiz {1} değeri kullanıldı" } , { WG_EMPTY_SECOND_ARG , "Belge işlevinin ikinci bağımsız değişkeninden sonuçlanan düğüm kümesi (nodeset) boş. Boş düğüm kümesi döndürür." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "xsl:processing-instruction adının 'name' özniteliği değeri 'xml' olmamalıdır" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "xsl:processing-instruction ile ilgili 'name' özniteliği değeri geçerli bir NCName olmalıdır: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Alt düğümlerden sonra ya da bir öğe üretilmeden önce {0} özniteliği eklenemez. Öznitelik yoksayılacak." } , { "ui_language" , "tr" } , { "help_language" , "tr" } , { "language" , "tr" } , { "BAD_CODE" , "createMessage için kullanılan değiştirge sınırların dışında" } , { "FORMAT_FAILED" , "messageFormat çağrısı sırasında kural dışı durum yayınlandı" } , { "version" , ">>>>>>> Xalan Sürüm " } , { "version2" , "<<<<<<<" } , { "yes" , "yes" } , { "line" , "Satır #" } , { "column" , "Kolon #" } , { "xsldone" , "XSLProcessor: bitti" } , { "xslProc_option" , "Xalan-J komut satırı Process sınıfı seçenekleri: " } , { "xslProc_option" , "Xalan-J komut satırı işlem sınıfı seçenekleri:" } , { "xslProc_invalid_xsltc_option" , "{0} seçeneği XSLTC kipinde desteklenmez." } , { "xslProc_invalid_xalan_option" , "{0} seçeneği yalnızca -XSLTC ile kullanılabilir." } , { "xslProc_no_input" , "Hata: Biçem yaprağı ya da giriş xml belirtilmedi. Kullanım yönergeleri için, bu komutu seçenek belirtmeden çalıştırın." } , { "xslProc_common_options" , "-Ortak Seçenekler-" } , { "xslProc_xalan_options" , "-Xalan Seçenekleri-" } , { "xslProc_xsltc_options" , "-XSLTC Seçenekleri-" } , { "xslProc_return_to_continue" , "(devam etmek için <Enter> tuşuna basın)" } , { "optionXSLTC" , "[-XSLTC (XSLTC dönüştürmede kullanılır)]" } , { "optionIN" , "[-IN inputXMLURL]" } , { "optionXSL" , "[-XSL XSLTransformationURL]" } , { "optionOUT" , "[-OUT outputFileName]" } , { "optionLXCIN" , "[-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "[-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "[-PARSER ayrıştırıcı ilişkisinin tam olarak nitelenmiş sınıf adı]" } , { "optionE" , "[-E (Varlık başvuruları genişletilmez)]" } , { "optionV" , "[-E (Varlık başvuruları genişletilmez)]" } , { "optionQC" , "[-QC (Sessiz örüntü çatışmaları uyarısı)]" } , { "optionQ" , "[-Q  (Sessiz kip)]" } , { "optionLF" , "   [-LF (satır besleme yalnızca çıkışta kullanılır {varsayılan CR/LF})]" } , { "optionCR" , "   [-CR (Satırbaşı yalnızca çıkışta kullanılır {varsayılan CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Kaçış karakterleri {varsayılan <>&\"\'\\r\\n}]" } , { "optionINDENT" , "[-INDENT (Girintili yazarken kullanılacak boşluk sayısı {varsayılan 0})]" } , { "optionTT" , "[-TT (Şablonlar çağrılırken izlenir.)]" } , { "optionTG" , "[-TG (Her oluşturma olayı izlenir.)]" } , { "optionTS" , "[-TS (Her seçim olayı izlenir.)]" } , { "optionTTC" , "[-TTC (Şablon alt öğeleri işlenirken izlenir.)]" } , { "optionTCLASS" , "[-TCLASS (İzleme eklentileri için TraceListener sınıfı.)]" } , { "optionVALIDATE" , "[-VALIDATE (Geçerlilik denetimi yapılıp yapılmayacağını belirler. Varsayılan olarak, geçerlilik denetimi kapalıdır.)]" } , { "optionEDUMP" , "[-EDUMP {isteğe bağlı dosya adı} (Hata durumunda yığın dökümü gerçekleştirilir.)]" } , { "optionXML" , "[-XML (XML biçimleyici kullanılır ve XML üstbilgisi eklenir.)]" } , { "optionTEXT" , "[-TEXT (Yalın metin biçimleyici kullanılır.)]" } , { "optionHTML" , "[-HTML (HTML biçimleyici kullanılır.)]" } , { "optionPARAM" , "[-PARAM ad ifadesi (Biçem yaprağı değiştirgesi belirlenir.)]" } , { "noParsermsg1" , "XSL işlemi başarısız oldu." } , { "noParsermsg2" , "** Ayrıştırıcı bulunamadı **" } , { "noParsermsg3" , "Lütfen classpath değişkeninizi inceleyin." } , { "noParsermsg4" , "Sisteminizde IBM XML Parser for Java aracı yoksa, şu adresten yükleyebilirsiniz:" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "[-URIRESOLVER tam sınıf adı (URI çözmekte kullanılacak URIResolver)]" } , { "optionENTITYRESOLVER" , "[-ENTITYRESOLVER tam sınıf adı (Varlıkları çözmekte kullanılacak EntityResolver)]" } , { "optionCONTENTHANDLER" , "[-CONTENTHANDLER tam sınıf adı (Çıkışı diziselleştirmekte kullanılacak ContentHandler)]" } , { "optionLINENUMBERS" , "[-L kaynak belge için satır numaraları kullanılır]" } , { "optionMEDIA" , "   [-MEDIA mediaType (Ortam özniteliği, bir belgeyle ilişkili biçem yaprağını bulmak için kullanılır.)]" } , { "optionFLAVOR" , "   [-FLAVOR flavorName (Dönüştürmeyi gerçekleştirmek için belirtik olarak s2s=SAX ya da d2d=DOM kullanılır.)] " } , { "optionDIAG" , "   [-DIAG (Dönüştürmenin kaç milisaniye sürdüğünü yazdırır.)]" } , { "optionINCREMENTAL" , "  [-INCREMENTAL (http://xml.apache.org/xalan/features/incremental true tanımlayarak artımsal DTM oluşturulması istenir.)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE (http://xml.apache.org/xalan/features/optimize false tanımlayarak biçem yaprağı eniyileme işlemi olmaması istenir.)]" } , { "optionRL" , "   [-RL recursionlimit (Biçem yaprağı özyineleme derinliğine sayısal sınır koyar.)]" } , { "optionXO" , "[-XO [derleme sonucu sınıf dosyası adı] (Oluşturulan sınıf dosyasına bu adı atar.)]" } , { "optionXD" , "[-XD destinationDirectory (Derleme sonucu sınıf dosyası için hedef dizin belirtir.)]" } , { "optionXJ" , "[-XJ jardsy (Derleme sonucu üretilen sınıfları <jardsy> adlı jar dosyasında paketler.)]" } , { "optionXP" , "[-XP paket (Derleme sonucunda üretilen tüm sınıflar için bir paket adı öneki belirtir.)]" } , { "optionXN" , "[-XN (Şablona doğrudan yerleştirmeyi açar.)]" } , { "optionXX" , "[-XX (Ek hata ayıklama iletisi çıkışını açar.)]" } , { "optionXT" , "[-XT (Yapılabiliyorsa, dönüştürme için derleme sonucu sınıf dosyasını kullanır.)]" } , { "diagTiming" , "--------- {1} ile {0} dönüştürme işlemi {2} ms sürdü" } , { "recursionTooDeep" , "Şablon içiçe kullanım derinliği çok fazla. İçiçe kullanım = {0}, şablon {1} {2}" } , { "nameIs" , "adı" } , { "matchPatternIs" , "eşleşme örüntüsü" } } ; public static final String BAD_CODE = "HATALI_KOD" ; public static final String FORMAT_FAILED = "BİÇİMLEME_BAŞARISIZ" ; public static final String ERROR_STRING = "#hata" ; public static final String ERROR_HEADER = "Hata: " ; public static final String WARNING_HEADER = "Uyarı: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "ÖRÜNTÜ " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "tr" , "TR" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_ja extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "''{0}'' でランタイム内部エラー" } , { BasisLibrary . RUN_TIME_COPY_ERR , "<xsl:copy> を実行時にランタイム・エラー。" } , { BasisLibrary . DATA_CONVERSION_ERR , "''{0}'' から ''{1}'' への変換が無効です。" } , { BasisLibrary . EXTERNAL_FUNC_ERR , "外部関数 ''{0}'' は XSLTC によりサポートされていません。" } , { BasisLibrary . EQUALITY_EXPR_ERR , "等式内の引き数が不明です。" } , { BasisLibrary . INVALID_ARGUMENT_ERR , "''{1}'' への呼び出し中の引き数タイプ ''{0}'' が無効です" } , { BasisLibrary . FORMAT_NUMBER_ERR , "数値 ''{0}'' をパターン ''{1}'' を使用してフォーマット設定しようとしています。" } , { BasisLibrary . ITERATOR_CLONE_ERR , "イテレーター ''{0}'' を複製できません。" } , { BasisLibrary . AXIS_SUPPORT_ERR , "軸 ''{0}'' のイテレーターはサポートされていません。" } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "型付きの軸 ''{0}'' のイテレーターはサポートされていません。" } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "属性 ''{0}'' がエレメントの外側です。" } , { BasisLibrary . STRAY_NAMESPACE_ERR , "ネーム・スペース宣言 ''{0}''=''{1}'' がエレメントの外側です。" } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "接頭部 ''{0}'' のネーム・スペースが宣言されていません。" } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter が間違ったタイプのソース DOM を使用して作成されました。" } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "使用中の SAX パーサーは DTD 宣言イベントを処理しません。" } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "使用中の SAX パーサーには XML ネーム・スペースのサポートがありません。" } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "URI 参照 ''{0}'' を解決できませんでした。" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ToTextStream extends ToStream { public ToTextStream ( ) { super ( ) ; } protected void startDocumentInternal ( ) throws org . xml . sax . SAXException { super . startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } public void endDocument ( ) throws org . xml . sax . SAXException { flushPending ( ) ; flushWriter ( ) ; if ( m_tracer != null ) super . fireEndDoc ( ) ; } public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { if ( m_tracer != null ) { super . fireStartElem ( name ) ; this . firePseudoAttributes ( ) ; } return ; } public void endElement ( String namespaceURI , String localName , String name ) throws org . xml . sax . SAXException { if ( m_tracer != null ) super . fireEndElem ( name ) ; } public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { flushPending ( ) ; try { writeNormalizedChars ( ch , start , length , false , m_lineSepUse ) ; if ( m_tracer != null ) super . fireCharEvent ( ch , start , length ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { try { writeNormalizedChars ( ch , start , length , false , m_lineSepUse ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } void writeNormalizedChars ( final char ch [ ] , final int start , final int length , final boolean isCData , final boolean useLineSep ) throws IOException , org . xml . sax . SAXException { final java . io . Writer writer = m_writer ; final int end = start + length ; final char S_LINEFEED = CharInfo . S_LINEFEED ; final int M_MAXCHARACTER = this . m_maxCharacter ; if ( isCData ) { for ( int i = start ; i < end ; i ++ ) { final char c = ch [ i ] ; if ( S_LINEFEED == c && useLineSep ) { writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else if ( c > M_MAXCHARACTER ) { if ( i != 0 ) closeCDATA ( ) ; if ( isUTF16Surrogate ( c ) ) { writeUTF16Surrogate ( c , ch , i , end ) ; i ++ ; } else { writer . write ( c ) ; } if ( ( i != 0 ) && ( i < ( end - 1 ) ) ) { writer . write ( CDATA_DELIMITER_OPEN ) ; m_cdataTagOpen = true ; } } else if ( ( ( i < ( end - 2 ) ) && ( ']' == c ) && ( ']' == ch [ i + 1 ] ) && ( '>' == ch [ i + 2 ] ) ) ) { writer . write ( CDATA_CONTINUE ) ; i += 2 ; } else { if ( c <= M_MAXCHARACTER ) { writer . write ( c ) ; } else if ( isUTF16Surrogate ( c ) ) { writeUTF16Surrogate ( c , ch , i , end ) ; i ++ ; } else { String encoding = getEncoding ( ) ; if ( encoding != null ) { String integralValue = Integer . toString ( c ) ; throw new SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ILLEGAL_CHARACTER , new Object [ ] { integralValue , encoding } ) ) ; } else { writer . write ( c ) ; } } } } } else { for ( int i = start ; i < end ; i ++ ) { final char c = ch [ i ] ; if ( S_LINEFEED == c && useLineSep ) { writer . write ( m_lineSep , 0 , m_lineSepLen ) ; } else if ( c <= M_MAXCHARACTER ) { writer . write ( c ) ; } else if ( isUTF16Surrogate ( c ) ) { writeUTF16Surrogate ( c , ch , i , end ) ; i ++ ; } else { String encoding = getEncoding ( ) ; if ( encoding != null ) { String integralValue = Integer . toString ( c ) ; throw new SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ILLEGAL_CHARACTER , new Object [ ] { integralValue , encoding } ) ) ; } else { writer . write ( c ) ; } } } } } public void cdata ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { try { writeNormalizedChars ( ch , start , length , false , m_lineSepUse ) ; if ( m_tracer != null ) super . fireCDATAEvent ( ch , start , length ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { try { writeNormalizedChars ( ch , start , length , false , m_lineSepUse ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { flushPending ( ) ; if ( m_tracer != null ) super . fireEscapingEvent ( target , data ) ; } public void comment ( String data ) throws org . xml . sax . SAXException { final int length = data . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * 2 + 1 ] ; } data . getChars ( 0 , length , m_charsBuff , 0 ) ; comment ( m_charsBuff , 0 , length ) ; } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { flushPending ( ) ; if ( m_tracer != null ) super . fireCommentEvent ( ch , start , length ) ; } public void entityReference ( String name ) throws org . xml . sax . SAXException { if ( m_tracer != null ) super . fireEntityReference ( name ) ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) { } public void endCDATA ( ) throws SAXException { } public void endElement ( String elemName ) throws SAXException { if ( m_tracer != null ) super . fireEndElem ( elemName ) ; } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { if ( m_needToCallStartDocument ) startDocumentInternal ( ) ; if ( m_tracer != null ) { super . fireStartElem ( elementName ) ; this . firePseudoAttributes ( ) ; } return ; } public void characters ( String characters ) throws SAXException { final int length = characters . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * 2 + 1 ] ; } characters . getChars ( 0 , length , m_charsBuff , 0 ) ; characters ( m_charsBuff , 0 , length ) ; } public void addAttribute ( String name , String value ) { } public void addUniqueAttribute ( String qName , String value , int flags ) throws SAXException { } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException { return false ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { } public void namespaceAfterStartElement ( final String prefix , final String uri ) throws SAXException { } public void flushPending ( ) throws org . xml . sax . SAXException { if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } } } 	1	['25', '3', '0', '5', '50', '192', '2', '3', '23', '2', '484', '0', '0', '0.875647668', '0.366666667', '2', '17', '18.36', '1', '0.96', '4']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_it extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Errore run-time interno in ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Errore run-time durante l'esecuzione di <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Conversione non valida da ''{0}'' a ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "Funzione esterna ''{0}'' non supportata da XSLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Tipo di argomento sconosciuto nell'espressione di uguaglianza. " } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Tipo di argomento ''{0}'' non valido nella chiamata a ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Tentativo di formattazione del numero ''{0}'' utilizzando il modello ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Impossibile clonare l''iteratore ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Iteratore per l''asse ''{0}'' non supportato. " } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Iteratore per l''asse immesso ''{0}'' non supportato. " } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Attributo ''{0}'' al di fuori dell''elemento. " } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Dichiarazione dello spazio nome ''{0}''=''{1}'' al di fuori dell''elemento. " } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "Lo spazio nomi per il prefisso ''{0}'' non è stato dichiarato. " } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter creato utilizzando il tipo di origine DOM errato." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "Il parser SAX utilizzato non gestisce gli eventi di dichiarazione DTD. " } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "Il parser SAX utilizzato non dispone del supporto per gli spazi nome XML. " } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "Impossibile risolvere il riferimento URI ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xml . utils . res ; public class XResources_en extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '314', '0', '0', '0.976190476', '1', '0', '0', '103.3333333', '1', '0.3333', '1']
package org . apache . xml . utils . res ; public class XResources_es extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "es" } , { "help_language" , "es" } , { "language" , "es" } , { "alphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '314', '0', '0', '0.976190476', '1', '0', '0', '103.3333333', '1', '0.3333', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_es extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Error: No puede haber '{' dentro de la expresión" } , { ER_ILLEGAL_ATTRIBUTE , "{0} tiene un atributo no permitido: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "¡sourceNode es nulo en xsl:apply-imports!" } , { ER_CANNOT_ADD , "No se puede añadir {0} a {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "¡sourceNode es nulo en handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "{0} debe tener un atributo de nombre." } , { ER_TEMPLATE_NOT_FOUND , "No se ha podido encontrar la plantilla: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "No se ha podido resolver AVT de nombre en xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} necesita un atributo: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} debe tener un atributo ''test''." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Valor incorrecto en atributo de nivel: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Nombre de processing-instruction no puede ser 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Nombre de processing-instruction debe ser un NCName válido: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} debe tener un atributo de coincidencia si tiene una modalidad." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} necesita un atributo de nombre o de coincidencia." } , { ER_CANT_RESOLVE_NSPREFIX , "No se puede resolver el prefijo del espacio de nombres: {0}" } , { ER_ILLEGAL_VALUE , "xml:space tiene un valor no permitido: {0}" } , { ER_NO_OWNERDOC , "¡El nodo hijo no tiene un documento propietario!" } , { ER_ELEMTEMPLATEELEM_ERR , "Error de ElemTemplateElement: {0}" } , { ER_NULL_CHILD , "¡Intentando añadir un hijo nulo!" } , { ER_NEED_SELECT_ATTRIB , "{0} necesita un atributo de selección." } , { ER_NEED_TEST_ATTRIB , "xsl:when debe tener un atributo 'test'." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param debe tener un atributo 'name'." } , { ER_NO_CONTEXT_OWNERDOC , "¡El contexto no tiene un documento propietario!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "No se ha podido crear Liaison TransformerFactory XML: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "El proceso Xalan no ha sido satisfactorio." } , { ER_NOT_SUCCESSFUL , "Xalan no ha sido satisfactorio." } , { ER_ENCODING_NOT_SUPPORTED , "Codificación no soportada: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "No se ha podido crear TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "¡xsl:key necesita un atributo 'name'!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "¡xsl:key necesita un atributo 'match'!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "¡xsl:key necesita un atributo 'use'!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "¡(StylesheetHandler) ¡{0} necesita un atributo ''elements''!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) Falta el atributo ''prefix'' de {0}" } , { ER_BAD_STYLESHEET_URL , "El URL de la hoja de estilos es incorrecto: {0}" } , { ER_FILE_NOT_FOUND , "No se ha encontrado el archivo de hoja de estilos: {0}" } , { ER_IOEXCEPTION , "Se ha producido una excepción de ES con el archivo de hoja de estilos: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) No se ha podido encontrar el atributo href para {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) ¡Inclusión propia de {0} directa o indirectamente!" } , { ER_PROCESSINCLUDE_ERROR , "Error de StylesheetHandler.processInclude, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) Falta el atributo ''lang'' de {0}" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) Elemento {0} incorrecto. Falta el elemento de contenedor ''component''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Sólo se puede dar salida hacia Element, DocumentFragment, Document o PrintWriter." } , { ER_PROCESS_ERROR , "Error de StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "Error de UnImplNode: {0}" } , { ER_NO_SELECT_EXPRESSION , "¡Error! No se ha encontrado la expresión de selección (-select) de xpath." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "¡No se puede serializar un XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "¡No se ha especificado la entrada de hoja de estilos!" } , { ER_FAILED_PROCESS_STYLESHEET , "¡No se ha podido procesar la hoja de estilos!" } , { ER_COULDNT_PARSE_DOC , "¡No se ha podido analizar el documento {0}!" } , { ER_COULDNT_FIND_FRAGMENT , "No se ha podido encontrar el fragmento: {0}" } , { ER_NODE_NOT_ELEMENT , "El nodo señalado por un identificador de fragmento no es un elemento: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each debe tener un atributo de coincidencia o de nombre" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "templates debe tener un atributo de coincidencia o de nombre" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "¡No es réplica de un fragmento de documento!" } , { ER_CANT_CREATE_ITEM , "No se puede crear el elemento en el árbol de resultados: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space en el XML fuente tiene un valor no permitido: {0}" } , { ER_NO_XSLKEY_DECLARATION , "¡No hay declaración xsl:key para {0}!" } , { ER_CANT_CREATE_URL , "¡Error! No se puede crear url para: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions no está soportado" } , { ER_PROCESSOR_ERROR , "Error de XSLT TransformerFactory" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) ¡{0} no permitido dentro de una hoja de estilos!" } , { ER_RESULTNS_NOT_SUPPORTED , "¡Ya no se soporta result-ns! Utilice xsl:output en su lugar." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "¡Ya no se soporta default-space! Utilice xsl:strip-space o xsl:preserve-space en su lugar." } , { ER_INDENTRESULT_NOT_SUPPORTED , "¡Ya no se soporta indent-result! Utilice xsl:output en su lugar." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} tiene un atributo no permitido: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Elemento XSL desconocido: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort sólo puede utilizarse con xsl:apply-templates o xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) ¡xsl:when equivocado!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) ¡xsl:when no emparentado por xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) ¡xsl:otherwise equivocado!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) ¡xsl:otherwise no emparentado por xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) ¡{0} no permitido dentro de una plantilla!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) Prefijo {1} de espacio de nombres de extensión {0} desconocido" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) ¡Las importaciones sólo pueden aparecer como primeros elementos de la hoja de estilos!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) ¡Importación propia de {0} directa o indirectamente!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:space tiene un valor no permitido: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "¡processStylesheet no satisfactorio!" } , { ER_SAX_EXCEPTION , "Excepción SAX" } , { ER_XSLT_ERROR , "Error de XSLT" } , { ER_CURRENCY_SIGN_ILLEGAL , "El signo monetario no está permitido en la serie del patrón de formato" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "¡La función de documento no está soportada en DOM de hoja de estilos!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "¡No se puede resolver el prefijo de un resolucionador sin prefijo!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Extensión Redirect: No se ha podido obtener el nombre de archivo - el atributo de archivo o de selección debe devolver una serie válida." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "¡No se puede crear FormatterListener en extensión Redirect!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "El prefijo en exclude-result-prefixes no es válido: {0}" } , { ER_MISSING_NS_URI , "Falta el URI del espacio de nombres para el prefijo especificado" } , { ER_MISSING_ARG_FOR_OPTION , "Falta un argumento para la opción: {0}" } , { ER_INVALID_OPTION , "Opción no válida: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Serie de formato mal formada: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "¡xsl:stylesheet necesita un atributo 'version'!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Atributo: {0} tiene un valor no permitido: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose necesita un xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports no permitido en xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "No se puede utilizar DTMLiaison para un nodo DOM de salida... ¡Pase org.apache.xpath.DOM2Helper en su lugar!" } , { ER_CANT_USE_DTM_FOR_INPUT , "No se puede utilizar DTMLiaison para un nodo DOM de entrada... ¡Pase org.apache.xpath.DOM2Helper en su lugar!" } , { ER_CALL_TO_EXT_FAILED , "Anomalía al llamar al elemento de extensión: {0}" } , { ER_PREFIX_MUST_RESOLVE , "El prefijo debe resolverse como un espacio de nombres: {0}" } , { ER_INVALID_UTF16_SURROGATE , "¿Se ha detectado un sustituto UTF-16 no válido: {0}?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} se ha utilizado a sí mismo lo que puede provocar un bucle infinito." } , { ER_CANNOT_MIX_XERCESDOM , "¡No se puede mezclar la entrada Xerces-DOM con la salida Xerces-DOM!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "En ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Se ha encontrado más de una plantilla con el nombre: {0}" } , { ER_INVALID_KEY_CALL , "Llamada de función no válida: no están permitidas las llamadas key() recursivas" } , { ER_REFERENCING_ITSELF , "¡La variable {0} se está referenciando a sí misma directa o indirectamente!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "¡El nodo de entrada no puede ser nulo para DOMSource de newTemplates!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "No se ha encontrado el archivo de clase para la opción {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "No se ha encontrado un elemento necesario: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream no puede ser nulo" } , { ER_URI_CANNOT_BE_NULL , "URI no puede ser nulo" } , { ER_FILE_CANNOT_BE_NULL , "Archivo no puede ser nulo" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource no puede ser nulo" } , { ER_CANNOT_INIT_BSFMGR , "No se ha podido inicializar el Gestor BSF" } , { ER_CANNOT_CMPL_EXTENSN , "No se ha podido compilar la extensión" } , { ER_CANNOT_CREATE_EXTENSN , "No se ha podido crear la extensión: {0} como consecuencia de: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "La llamada del método de instancia al método {0} necesita una instancia Object como primer argumento" } , { ER_INVALID_ELEMENT_NAME , "Se ha especificado un nombre de elemento no válido {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "El método del nombre de elemento debe ser estático {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Función de extensión {0} : {1} desconocida" } , { ER_MORE_MATCH_CONSTRUCTOR , "Hay más de una coincidencia máxima para el constructor de {0}" } , { ER_MORE_MATCH_METHOD , "Hay más de una coincidencia máxima para el método {0}" } , { ER_MORE_MATCH_ELEMENT , "Hay más de una coincidencia máxima para el método de elemento {0}" } , { ER_INVALID_CONTEXT_PASSED , "Se ha pasado un contexto no válido para evaluar {0}" } , { ER_POOL_EXISTS , "La agrupación ya existe" } , { ER_NO_DRIVER_NAME , "No se ha especificado un nombre de controlador" } , { ER_NO_URL , "No se ha especificado un URL" } , { ER_POOL_SIZE_LESSTHAN_ONE , "¡El tamaño de la agrupación es menor que uno!" } , { ER_INVALID_DRIVER , "¡Se ha especificado un nombre de controlador no válido!" } , { ER_NO_STYLESHEETROOT , "¡No se ha encontrado la raíz de la hoja de estilos!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Valor no permitido para xml:space" } , { ER_PROCESSFROMNODE_FAILED , "Anomalía de processFromNode" } , { ER_RESOURCE_COULD_NOT_LOAD , "No se ha podido cargar el recurso [ {0} ]: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Tamaño de almacenamiento intermedio <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Error desconocido al llamar a la extensión" } , { ER_NO_NAMESPACE_DECL , "El prefijo {0} no tiene una declaración de espacio de nombres correspondiente" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "No se permite el contenido del elemento para lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Terminación de hoja de estilos dirigida" } , { ER_ONE_OR_TWO , "1 ó 2" } , { ER_TWO_OR_THREE , "2 ó 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "No se ha podido cargar {0} (compruebe la CLASSPATH), ahora sólo se están utilizando los valores por omisión" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "No se han podido inicializar las plantillas por omisión" } , { ER_RESULT_NULL , "El resultado no debería ser nulo" } , { ER_RESULT_COULD_NOT_BE_SET , "No se ha podido establecer el resultado" } , { ER_NO_OUTPUT_SPECIFIED , "No se ha especificado salida" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "No se puede transformar un resultado de tipo {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "No se puede transformar un fuente de tipo {0}" } , { ER_NULL_CONTENT_HANDLER , "Manejador de contenido nulo" } , { ER_NULL_ERROR_HANDLER , "Manejador de error nulo" } , { ER_CANNOT_CALL_PARSE , "No se puede llamar a parse si no se ha establecido ContentHandler" } , { ER_NO_PARENT_FOR_FILTER , "No hay padre para el filtro" } , { ER_NO_STYLESHEET_IN_MEDIA , "No se han encontrado hojas de estilos en: {0}, soporte= {1}" } , { ER_NO_STYLESHEET_PI , "No se ha encontrado xml-stylesheet PI en: {0}" } , { ER_NOT_SUPPORTED , "No soportado: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "El valor de la propiedad {0} debería ser una instancia Boolean" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "No se ha podido encontrar el script externo en {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "No se ha podido cargar el recurso [ {0} ].\n{1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "No se reconoce la propiedad de salida: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Anomalía al crear la instancia ElemLiteralResult" } , { ER_VALUE_SHOULD_BE_NUMBER , "El valor para {0} debería contener un número analizable" } , { ER_VALUE_SHOULD_EQUAL , "El valor de {0} debería ser sí o no" } , { ER_FAILED_CALLING_METHOD , "Anomalía al llamar al método {0}" } , { ER_FAILED_CREATING_ELEMTMPL , "Anomalía al crear la instancia ElemTemplateElement" } , { ER_CHARS_NOT_ALLOWED , "No se permiten caracteres en este punto del documento" } , { ER_ATTR_NOT_ALLOWED , "¡El atributo \"{0}\" no está permitido en el elemento {1}!" } , { ER_BAD_VALUE , "{0} valor incorrecto {1}" } , { ER_ATTRIB_VALUE_NOT_FOUND , "No se ha encontrado el valor del atributo {0}" } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "No se ha reconocido el valor del atributo {0}" } , { ER_NULL_URI_NAMESPACE , "Se ha intentado generar un prefijo de espacio de nombres con un URI nulo" } , { ER_NUMBER_TOO_BIG , "Se ha intentado formatear un número mayor que el entero largo más grande" } , { ER_CANNOT_FIND_SAX1_DRIVER , "No se ha podido encontrar la clase de controlador SAX1 {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "Se ha encontrado la clase de controlador SAX1 {0} pero no se ha podido cargar" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "Se ha cargado la clase de controlador SAX1 {0} pero no se ha podido crear una instancia" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "La clase de controlador SAX1 {0} no implementa org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "No se ha especificado la propiedad del sistema org.xml.sax.parser" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "El argumento del analizador no debe ser nulo" } , { ER_FEATURE , "Característica: {0}" } , { ER_PROPERTY , "Propiedad: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Resolucionador de entidad nulo" } , { ER_NULL_DTD_HANDLER , "Manejador DTD nulo" } , { ER_NO_DRIVER_NAME_SPECIFIED , "¡No se ha especificado un nombre de controlador!" } , { ER_NO_URL_SPECIFIED , "¡No se ha especificado un URL!" } , { ER_POOLSIZE_LESS_THAN_ONE , "¡El tamaño de la agrupación es menor que 1!" } , { ER_INVALID_DRIVER_NAME , "¡Se ha especificado un nombre de controlador no válido!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "¡Error del programador! ¡La expresión no tiene un padre ElemTemplateElement!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Aserción del programador en RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "¡{0} no está permitido en esta posición de la hoja de estilos!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "¡No está permitido texto sin espacios en blanco en esta posición de la hoja de estilos!" } , { INVALID_TCHAR , "Valor no permitido: se ha utilizado {1} para el atributo CHAR: {0}. ¡Un atributo de tipo CHAR debe ser de un solo carácter!" } , { INVALID_QNAME , "Valor no permitido: se ha utilizado {1} para el atributo QNAME: {0}" } , { INVALID_ENUM , "Valor no permitido: se ha utilizado {1} para el atributo ENUM: {0}. Los valores válidos son: {2}." } , { INVALID_NMTOKEN , "Valor no permitido: se ha utilizado {1} para el atributo NMTOKEN: {0}" } , { INVALID_NCNAME , "Valor no permitido: se ha utilizado {1} para el atributo NCNAME: {0}" } , { INVALID_BOOLEAN , "Valor no permitido: se ha utilizado {1} para el atributo boolean: {0}" } , { INVALID_NUMBER , "Valor no permitido: se ha utilizado {1} para el atributo number: {0}" } , { ER_ARG_LITERAL , "El argumento para {0} en el patrón de coincidencia debe ser un literal." } , { ER_DUPLICATE_GLOBAL_VAR , "Declaración de variable global duplicada." } , { ER_DUPLICATE_VAR , "Declaración de variable duplicada." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template debe tener un atributo name o match (o ambos)" } , { ER_INVALID_PREFIX , "El prefijo en exclude-result-prefixes no es válido: {0}" } , { ER_NO_ATTRIB_SET , "attribute-set de nombre {0} no existe" } , { WG_FOUND_CURLYBRACE , "¡Se ha encontrado '}' pero no se ha abierto una plantilla de atributos!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Aviso: ¡El atributo count no coincide con un antecesor en xsl:number! Destino = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Sintaxis antigua: El nombre del atributo 'expr' se ha cambiado por 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan no maneja aún el nombre de entorno local en la función format-number." } , { WG_LOCALE_NOT_FOUND , "Aviso: No se ha podido encontrar el entorno local para xml:lang={0}" } , { WG_CANNOT_MAKE_URL_FROM , "No se puede crear URL desde: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "No se puede cargar el doc solicitado: {0}" } , { WG_CANNOT_FIND_COLLATOR , "No se ha podido encontrar clasificador para <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Sintaxis antigua: La instrucción functions debería utilizar un url de {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "Codificación no soportada: {0}, se utiliza UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "Codificación no soportada: {0}, se utiliza Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Se han encontrado conflictos de especificación: {0} Se utilizará lo último encontrado en la hoja de estilos." } , { WG_PARSING_AND_PREPARING , "========= Analizando y preparando {0} ==========" } , { WG_ATTR_TEMPLATE , "Plantilla de atributos, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Conflicto de coincidencia entre xsl:strip-space y xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "¡Xalan no maneja aún el atributo {0}!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "No se ha encontrado declaración para el formato decimal: {0}" } , { WG_OLD_XSLT_NS , "Falta el espacio de nombres XSLT o es incorrecto." } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Sólo se permite una declaración xsl:decimal-format por omisión." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "Los nombres de xsl:decimal-format deben ser únicos. El nombre \"{0}\" se ha duplicado." } , { WG_ILLEGAL_ATTRIBUTE , "{0} tiene un atributo no permitido: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "No se ha podido resolver el prefijo del espacio de nombres: {0}. Se ignorará el nodo." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "¡xsl:stylesheet necesita un atributo 'version'!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Nombre de atributo no permitido: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Se ha utilizado un valor no permitido para el atributo {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "El NodeSet resultante del segundo argumento de la función del documento está vacío. Devuelve un conjunto de nodos vacío." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "El valor del atributo 'name' de nombre xsl:processing-instruction no debe ser 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "El valor del atributo 'name' de xsl:processing-instruction debe ser un NCName válido: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "No se puede añadir el atributo {0} después de nodos hijo o antes de que se produzca un elemento. Se ignorará el atributo." } , { "ui_language" , "es" } , { "help_language" , "es" } , { "language" , "es" } , { "BAD_CODE" , "El parámetro para createMessage estaba fuera de los límites" } , { "FORMAT_FAILED" , "Se ha generado una excepción durante la llamada messageFormat" } , { "version" , ">>>>>>> Xalan versión" } , { "version2" , "<<<<<<<" } , { "yes" , "sí" } , { "line" , "Línea núm." } , { "column" , "Columna núm." } , { "xsldone" , "XSLProcessor: terminado" } , { "xslProc_option" , "Opciones de la clase Process de la línea de mandatos Xalan-J:" } , { "xslProc_option" , "Opciones de la clase Process de la línea de mandatos Xalan-J:" } , { "xslProc_invalid_xsltc_option" , "La opción {0} no está soportada en modalidad XSLTC." } , { "xslProc_invalid_xalan_option" , "La opción {0} sólo puede utilizarse con -XSLTC." } , { "xslProc_no_input" , "Error: No se ha especificado ninguna hoja de estilos ni xml de entrada. Ejecute este mandato sin opciones para ver las instrucciones de uso." } , { "xslProc_common_options" , "-Opciones comunes-" } , { "xslProc_xalan_options" , "-Opciones para Xalan-" } , { "xslProc_xsltc_options" , "-Opciones para XSLTC-" } , { "xslProc_return_to_continue" , "(pulse <Intro> para continuar)" } , { "optionXSLTC" , "[-XSLTC (Utilizar XSLTC para transformación)]" } , { "optionIN" , "[-IN URLXMLentrada]" } , { "optionXSL" , "[-XSL URLTransformaciónXSL]" } , { "optionOUT" , "[-OUT nombreArchivoSalida]" } , { "optionLXCIN" , "[-LXCIN entradaNombreArchivoHojaEstilosCompilada]" } , { "optionLXCOUT" , "[-LXCOUT salidaNombreArchivoHojaEstilosCompilada]" } , { "optionPARSER" , "[-PARSER nombre de clase completamente cualificado del enlace del analizador]" } , { "optionE" , "[-E (No expandir referencias de entidades)]" } , { "optionV" , "[-E (No expandir referencias de entidades)]" } , { "optionQC" , "[-QC (Avisos silenciosos de conflictos de patrones)]" } , { "optionQ" , "[-Q  (Modalidad silenciosa)]" } , { "optionLF" , "[-LF (Utilizar sólo avances de línea en la salida {por omisión es CR/LF})]" } , { "optionCR" , "[-CR (Utilizar sólo retornos de carro en la salida {por omisión es CR/LF})]" } , { "optionESCAPE" , "[-ESCAPE (Caracteres con escape {por omisión es <>&\"\'\\r\\n}]" } , { "optionINDENT" , "[-INDENT (Controlar el número de espacios de sangrado {por omisión es 0})]" } , { "optionTT" , "[-TT (Rastrear las plantillas a medida que se llaman.)]" } , { "optionTG" , "[-TG (Rastrear cada suceso de generación.)]" } , { "optionTS" , "[-TS (Rastrear cada suceso de selección.)]" } , { "optionTTC" , "[-TTC (Rastrear los hijos de plantillas a medida que se procesan.)]" } , { "optionTCLASS" , "[-TCLASS (Clase TraceListener para extensiones de rastreo.)]" } , { "optionVALIDATE" , "[-VALIDATE (Establecer si se realiza la validación. Por omisión la validación está desactivada.)]" } , { "optionEDUMP" , "[-EDUMP {nombre de archivo opcional} (Realizar vuelco de pila si se produce un error.)]" } , { "optionXML" , "[-XML (Utilizar el formateador XML y añadir la cabecera XML.)]" } , { "optionTEXT" , "[-TEXT (Utilizar el formateador de texto sencillo.)]" } , { "optionHTML" , "[-HTML (Utilizar el formateador HTML.)]" } , { "optionPARAM" , "[-PARAM expresión de nombre (Establecer un parámetro de hoja de estilos)]" } , { "noParsermsg1" , "El proceso XSL no ha sido satisfactorio." } , { "noParsermsg2" , "** No se ha podido encontrar el analizador **" } , { "noParsermsg3" , "Compruebe la classpath." } , { "noParsermsg4" , "Si no dispone del analizador XML para Java de IBM, puede bajarlo de " } , { "noParsermsg5" , "IBM AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "[-URIRESOLVER nombre de clase completo (URIResolver a utilizar para resolver URI)]" } , { "optionENTITYRESOLVER" , "[-ENTITYRESOLVER nombre de clase completo (EntityResolver a utilizar para resolver entidades)]" } , { "optionCONTENTHANDLER" , "[-CONTENTHANDLER nombre de clase completo (ContentHandler a utilizar para serializar la salida)]" } , { "optionLINENUMBERS" , "[-L utilizar números de línea para el documento fuente]" } , { "optionMEDIA" , "[-MEDIA tipoSoporte (Utilizar el atributo de soporte para encontrar la hoja de estilos asociada con un documento.)]" } , { "optionFLAVOR" , "[-FLAVOR nombreEstilo (Utilizar explícitamente s2s=SAX o d2d=DOM para realizar la transformación.)]" } , { "optionDIAG" , "[-DIAG (Imprimir el total de milisegundos que lleva la transformación.)]" } , { "optionINCREMENTAL" , "[-INCREMENTAL (Solicitar construcción DTM incremental estableciendo http://xml.apache.org/xalan/features/incremental como verdadero.)]" } , { "optionNOOPTIMIMIZE" , "[-NOOPTIMIMIZE (Solicitar proceso de optimización de hoja de estilos estableciendo http://xml.apache.org/xalan/features/optimize como falso.)]" } , { "optionRL" , "[-RL límiteRecursión (Límite numérico de aserción sobre profundidad de recursión de hoja de estilos.)]" } , { "optionXO" , "[-XO [nombreTranslet] (Asignar el nombre al translet generado)]" } , { "optionXD" , "[-XD directorioDestino (Especificar un directorio de destino para translet)]" } , { "optionXJ" , "[-XJ archivoJar (Empaqueta las clases translet en un archivo jar de nombre <archivoJar>)]" } , { "optionXP" , "[-XP paquete (Especifica un prefijo para el nombre del paquete de todas las clases translet generadas)]" } , { "optionXN" , "[-XN (habilita la inclusión en línea de plantillas)]" } , { "optionXX" , "[-XX (activa la salida de mensajes de depuración adicionales)]" } , { "optionXT" , "[-XT (utilizar translet para transformar si es posible)]" } , { "diagTiming" , "--------- La transformación de {0} mediante {1} ha durado {2} ms" } , { "recursionTooDeep" , "Anidado de plantilla demasiado profundo. anidado = {0}, plantilla {1} {2}" } , { "nameIs" , "el nombre es " } , { "matchPatternIs" , "el patrón de coincidencia es " } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Aviso: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "es" , "ES" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ClassGen ; import org . apache . bcel . generic . Instruction ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . Parser ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public class ClassGenerator extends ClassGen { protected static int TRANSLET_INDEX = 0 ; protected static int INVALID_INDEX = - 1 ; private Stylesheet _stylesheet ; private final Parser _parser ; private final Instruction _aloadTranslet ; private final String _domClass ; private final String _domClassSig ; private final String _applyTemplatesSig ; public ClassGenerator ( String class_name , String super_class_name , String file_name , int access_flags , String [ ] interfaces , Stylesheet stylesheet ) { super ( class_name , super_class_name , file_name , access_flags , interfaces ) ; _stylesheet = stylesheet ; _parser = stylesheet . getParser ( ) ; _aloadTranslet = new ALOAD ( TRANSLET_INDEX ) ; if ( stylesheet . isMultiDocument ( ) ) { _domClass = "org.apache.xalan.xsltc.dom.MultiDOM" ; _domClassSig = "Lorg/apache/xalan/xsltc/dom/MultiDOM;" ; } else { _domClass = "org.apache.xalan.xsltc.dom.DOMAdapter" ; _domClassSig = "Lorg/apache/xalan/xsltc/dom/DOMAdapter;" ; } _applyTemplatesSig = "(" + Constants . DOM_INTF_SIG + Constants . NODE_ITERATOR_SIG + Constants . TRANSLET_OUTPUT_SIG + ")V" ; } public final Parser getParser ( ) { return _parser ; } public final Stylesheet getStylesheet ( ) { return _stylesheet ; } public final String getClassName ( ) { return _stylesheet . getClassName ( ) ; } public Instruction loadTranslet ( ) { return _aloadTranslet ; } public final String getDOMClass ( ) { return _domClass ; } public final String getDOMClassSig ( ) { return _domClassSig ; } public final String getApplyTemplatesSig ( ) { return _applyTemplatesSig ; } public boolean isExternal ( ) { return false ; } } 	1	['10', '3', '4', '124', '15', '27', '120', '5', '9', '0.888888889', '87', '1', '2', '0.898734177', '0.288888889', '0', '0', '6.9', '1', '0.8', '2']
package org . apache . xalan . xsltc . util ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; public class JavaCupRedirect { private final static String ERRMSG = "You must supply a filename with the -stdin option." ; public static void main ( String args [ ] ) { boolean systemExitOK = true ; InputStream input = null ; final int argc = args . length ; String [ ] new_args = new String [ argc - 2 ] ; int new_argc = 0 ; for ( int i = 0 ; i < argc ; i ++ ) { if ( args [ i ] . equals ( "-stdin" ) ) { if ( ( ++ i >= argc ) || ( args [ i ] . startsWith ( "-" ) ) ) { System . err . println ( ERRMSG ) ; doSystemExit ( systemExitOK ) ; } try { input = new FileInputStream ( args [ i ] ) ; } catch ( FileNotFoundException e ) { System . err . println ( "Could not open file " + args [ i ] ) ; doSystemExit ( systemExitOK ) ; } catch ( SecurityException e ) { System . err . println ( "No permission to file " + args [ i ] ) ; doSystemExit ( systemExitOK ) ; } } else { if ( new_argc == new_args . length ) { System . err . println ( "Missing -stdin option!" ) ; doSystemExit ( systemExitOK ) ; } new_args [ new_argc ++ ] = args [ i ] ; } } System . setIn ( input ) ; try { java_cup . Main . main ( new_args ) ; } catch ( Exception e ) { System . err . println ( "Error running JavaCUP:" ) ; e . printStackTrace ( ) ; doSystemExit ( systemExitOK ) ; } } public static void doSystemExit ( boolean doExit ) { if ( doExit ) System . exit ( - 1 ) ; } } 	1	['3', '1', '0', '1', '15', '3', '0', '1', '3', '1.5', '124', '1', '0', '0', '0.333333333', '0', '0', '40', '6', '2.6667', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . compiler . Compiler ; public class ChildTestIterator extends BasicTestIterator { transient protected DTMAxisTraverser m_traverser ; ChildTestIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; } public ChildTestIterator ( DTMAxisTraverser traverser ) { super ( null ) ; m_traverser = traverser ; } protected int getNextNode ( ) { if ( true ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; } return m_lastFetched ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { ChildTestIterator clone = ( ChildTestIterator ) super . cloneWithReset ( ) ; clone . m_traverser = m_traverser ; return clone ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( Axis . CHILD ) ; } public int getAxis ( ) { return org . apache . xml . dtm . Axis . CHILD ; } public void detach ( ) { if ( m_allowDetach ) { m_traverser = null ; super . detach ( ) ; } } } 	1	['7', '6', '5', '12', '15', '1', '7', '6', '5', '0.333333333', '75', '1', '1', '0.962406015', '0.342857143', '2', '5', '9.571428571', '2', '1', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_pl extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Wewnętrzny błąd czasu wykonania w ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Błąd czasu wykonania podczas wykonywania <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Niepoprawna konwersja z ''{0}'' do ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "Funkcja zewnętrzna ''{0}'' nieobsługiwana przez XSLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Nieznany typ argumentu w wyrażeniu równości." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Niepoprawny typ argumentu ''{0}'' w wywołaniu ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Próba sformatowania liczby ''{0}'' za pomocą wzorca ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Nie można utworzyć kopii iteratora ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Iterator osi ''{0}'' nie jest obsługiwany." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Iterator osi ''{0}'' określonego typu nie jest obsługiwany." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Atrybut ''{0}'' poza elementem." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Deklaracja przestrzeni nazw ''{0}''=''{1}'' poza elementem." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "Nie zadeklarowano przestrzeni nazw dla przedrostka ''{0}''." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "Utworzono DOMAdapter za pomocą źródłowego DOM o błędnym typie." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "Używany analizator składni SAX nie obsługuje zdarzeń deklaracji DTD." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "Używany analizator składni SAX nie obsługuje przestrzeni nazw XML." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "Nie można przetłumaczyć odniesienia do URI ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xalan . xsltc . dom ; import java . io . File ; import java . io . PrintWriter ; import java . net . URL ; import java . net . URLConnection ; import java . net . URLDecoder ; import java . util . Date ; import java . util . Hashtable ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . TransformerException ; import javax . xml . transform . sax . SAXSource ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMCache ; import org . apache . xalan . xsltc . DOMEnhancedForDTM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . runtime . Constants ; import org . apache . xml . utils . SystemIDResolver ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public final class DocumentCache implements DOMCache { private int _size ; private Hashtable _references ; private String [ ] _URIs ; private int _count ; private int _current ; private SAXParser _parser ; private XMLReader _reader ; private XSLTCDTMManager _dtmManager ; private static final int REFRESH_INTERVAL = 1000 ; public final class CachedDocument { private long _firstReferenced ; private long _lastReferenced ; private long _accessCount ; private long _lastModified ; private long _lastChecked ; private long _buildTime ; private DOMEnhancedForDTM _dom = null ; public CachedDocument ( String uri ) { final long stamp = System . currentTimeMillis ( ) ; _firstReferenced = stamp ; _lastReferenced = stamp ; _accessCount = 0 ; loadDocument ( uri ) ; _buildTime = System . currentTimeMillis ( ) - stamp ; } public void loadDocument ( String uri ) { try { final long stamp = System . currentTimeMillis ( ) ; _dom = ( DOMEnhancedForDTM ) _dtmManager . getDTM ( new SAXSource ( _reader , new InputSource ( uri ) ) , false , null , true , false ) ; _dom . setDocumentURI ( uri ) ; final long thisTime = System . currentTimeMillis ( ) - stamp ; if ( _buildTime > 0 ) _buildTime = ( _buildTime + thisTime ) > > > 1 ; else _buildTime = thisTime ; } catch ( Exception e ) { _dom = null ; } } public DOM getDocument ( ) { return ( _dom ) ; } public long getFirstReferenced ( ) { return ( _firstReferenced ) ; } public long getLastReferenced ( ) { return ( _lastReferenced ) ; } public long getAccessCount ( ) { return ( _accessCount ) ; } public void incAccessCount ( ) { _accessCount ++ ; } public long getLastModified ( ) { return ( _lastModified ) ; } public void setLastModified ( long t ) { _lastModified = t ; } public long getLatency ( ) { return ( _buildTime ) ; } public long getLastChecked ( ) { return ( _lastChecked ) ; } public void setLastChecked ( long t ) { _lastChecked = t ; } public long getEstimatedSize ( ) { if ( _dom != null ) return ( _dom . getSize ( ) << 5 ) ; else return ( 0 ) ; } } public DocumentCache ( int size ) throws SAXException { this ( size , null ) ; try { _dtmManager = ( XSLTCDTMManager ) XSLTCDTMManager . getDTMManagerClass ( ) . newInstance ( ) ; } catch ( Exception e ) { throw new SAXException ( e ) ; } } public DocumentCache ( int size , XSLTCDTMManager dtmManager ) throws SAXException { _dtmManager = dtmManager ; _count = 0 ; _current = 0 ; _size = size ; _references = new Hashtable ( _size + 2 ) ; _URIs = new String [ _size ] ; try { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { factory . setFeature ( Constants . NAMESPACE_FEATURE , true ) ; } catch ( Exception e ) { factory . setNamespaceAware ( true ) ; } _parser = factory . newSAXParser ( ) ; _reader = _parser . getXMLReader ( ) ; } catch ( ParserConfigurationException e ) { BasisLibrary . runTimeError ( BasisLibrary . NAMESPACES_SUPPORT_ERR ) ; System . exit ( - 1 ) ; } } private final long getLastModified ( String uri ) { try { URL url = new URL ( uri ) ; URLConnection connection = url . openConnection ( ) ; long timestamp = connection . getLastModified ( ) ; if ( timestamp == 0 ) { if ( "file" . equals ( url . getProtocol ( ) ) ) { File localfile = new File ( URLDecoder . decode ( url . getFile ( ) ) ) ; timestamp = localfile . lastModified ( ) ; } } return ( timestamp ) ; } catch ( Exception e ) { return ( System . currentTimeMillis ( ) ) ; } } private CachedDocument lookupDocument ( String uri ) { return ( ( CachedDocument ) _references . get ( uri ) ) ; } private synchronized void insertDocument ( String uri , CachedDocument doc ) { if ( _count < _size ) { _URIs [ _count ++ ] = uri ; _current = 0 ; } else { _references . remove ( _URIs [ _current ] ) ; _URIs [ _current ] = uri ; if ( ++ _current >= _size ) _current = 0 ; } _references . put ( uri , doc ) ; } private synchronized void replaceDocument ( String uri , CachedDocument doc ) { CachedDocument old = ( CachedDocument ) _references . get ( uri ) ; if ( doc == null ) insertDocument ( uri , doc ) ; else _references . put ( uri , doc ) ; } public DOM retrieveDocument ( String baseURI , String href , Translet trs ) { CachedDocument doc ; String uri = href ; if ( baseURI != null && ! baseURI . equals ( "" ) ) { try { uri = SystemIDResolver . getAbsoluteURI ( uri , baseURI ) ; } catch ( TransformerException te ) { } } if ( ( doc = lookupDocument ( uri ) ) == null ) { doc = new CachedDocument ( uri ) ; if ( doc == null ) return null ; doc . setLastModified ( getLastModified ( uri ) ) ; insertDocument ( uri , doc ) ; } else { long now = System . currentTimeMillis ( ) ; long chk = doc . getLastChecked ( ) ; doc . setLastChecked ( now ) ; if ( now > ( chk + REFRESH_INTERVAL ) ) { doc . setLastChecked ( now ) ; long last = getLastModified ( uri ) ; if ( last > doc . getLastModified ( ) ) { doc = new CachedDocument ( uri ) ; if ( doc == null ) return null ; doc . setLastModified ( getLastModified ( uri ) ) ; replaceDocument ( uri , doc ) ; } } } final DOM dom = doc . getDocument ( ) ; if ( dom == null ) return null ; doc . incAccessCount ( ) ; final AbstractTranslet translet = ( AbstractTranslet ) trs ; translet . prepassDocument ( dom ) ; return ( doc . getDocument ( ) ) ; } public void getStatistics ( PrintWriter out ) { out . println ( "<h2>DOM cache statistics</h2><center><table border=\"2\">" + "<tr><td><b>Document URI</b></td>" + "<td><center><b>Build time</b></center></td>" + "<td><center><b>Access count</b></center></td>" + "<td><center><b>Last accessed</b></center></td>" + "<td><center><b>Last modified</b></center></td></tr>" ) ; for ( int i = 0 ; i < _count ; i ++ ) { CachedDocument doc = ( CachedDocument ) _references . get ( _URIs [ i ] ) ; out . print ( "<tr><td><a href=\"" + _URIs [ i ] + "\">" + "<font size=-1>" + _URIs [ i ] + "</font></a></td>" ) ; out . print ( "<td><center>" + doc . getLatency ( ) + "ms</center></td>" ) ; out . print ( "<td><center>" + doc . getAccessCount ( ) + "</center></td>" ) ; out . print ( "<td><center>" + ( new Date ( doc . getLastReferenced ( ) ) ) + "</center></td>" ) ; out . print ( "<td><center>" + ( new Date ( doc . getLastModified ( ) ) ) + "</center></td>" ) ; out . println ( "</tr>" ) ; } out . println ( "</table></center>" ) ; } } 	1	['10', '1', '0', '8', '55', '17', '1', '8', '4', '0.654320988', '425', '1', '1', '0', '0.275', '0', '0', '40.6', '9', '2.2', '1']
package org . apache . xpath . objects ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; public class XNumber extends XObject { double m_val ; public XNumber ( double d ) { super ( ) ; m_val = d ; } public XNumber ( Number num ) { super ( ) ; m_val = num . doubleValue ( ) ; m_obj = num ; } public int getType ( ) { return CLASS_NUMBER ; } public String getTypeString ( ) { return "#NUMBER" ; } public double num ( ) { return m_val ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_val ; } public boolean bool ( ) { return ( Double . isNaN ( m_val ) || ( m_val == 0.0 ) ) ? false : true ; } public String str ( ) { if ( Double . isNaN ( m_val ) ) { return "NaN" ; } else if ( Double . isInfinite ( m_val ) ) { if ( m_val > 0 ) return "Infinity" ; else return "-Infinity" ; } double num = m_val ; String s = Double . toString ( num ) ; int len = s . length ( ) ; if ( s . charAt ( len - 2 ) == '.' && s . charAt ( len - 1 ) == '0' ) { s = s . substring ( 0 , len - 2 ) ; if ( s . equals ( "-0" ) ) return "0" ; return s ; } int e = s . indexOf ( 'E' ) ; if ( e < 0 ) { if ( s . charAt ( len - 1 ) == '0' ) return s . substring ( 0 , len - 1 ) ; else return s ; } int exp = Integer . parseInt ( s . substring ( e + 1 ) ) ; String sign ; if ( s . charAt ( 0 ) == '-' ) { sign = "-" ; s = s . substring ( 1 ) ; -- e ; } else sign = "" ; int nDigits = e - 2 ; if ( exp >= nDigits ) return sign + s . substring ( 0 , 1 ) + s . substring ( 2 , e ) + zeros ( exp - nDigits ) ; while ( s . charAt ( e - 1 ) == '0' ) e -- ; if ( exp > 0 ) return sign + s . substring ( 0 , 1 ) + s . substring ( 2 , 2 + exp ) + "." + s . substring ( 2 + exp , e ) ; return sign + "0." + zeros ( - 1 - exp ) + s . substring ( 0 , 1 ) + s . substring ( 2 , e ) ; } static private String zeros ( int n ) { if ( n < 1 ) return "" ; char [ ] buf = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { buf [ i ] = '0' ; } return new String ( buf ) ; } public Object object ( ) { if ( null == m_obj ) m_obj = new Double ( m_val ) ; return m_obj ; } public boolean equals ( XObject obj2 ) { int t = obj2 . getType ( ) ; try { if ( t == XObject . CLASS_NODESET ) return obj2 . equals ( this ) ; else if ( t == XObject . CLASS_BOOLEAN ) return obj2 . bool ( ) == bool ( ) ; else return m_val == obj2 . num ( ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } public boolean isStableNumber ( ) { return true ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { visitor . visitNumberLiteral ( owner , this ) ; } } 	1	['13', '3', '0', '41', '36', '22', '37', '5', '12', '0.416666667', '330', '0', '0', '0.865853659', '0.182692308', '2', '22', '24.30769231', '13', '2.4615', '1']
package org . apache . xml . utils . res ; public class XResources_ja_JP_A extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "alphabet" , new char [ ] { 0x30a2 , 0x30a4 , 0x30a6 , 0x30a8 , 0x30aa , 0x30ab , 0x30ad , 0x30af , 0x30b1 , 0x30b3 , 0x30b5 , 0x30b7 , 0x30b9 , 0x30bb , 0x30bd , 0x30bf , 0x30c1 , 0x30c4 , 0x30c6 , 0x30c8 , 0x30ca , 0x30cb , 0x30cc , 0x30cd , 0x30ce , 0x30cf , 0x30d2 , 0x30d5 , 0x30d8 , 0x30db , 0x30de , 0x30df , 0x30e0 , 0x30e1 , 0x30e2 , 0x30e4 , 0x30e6 , 0x30e8 , 0x30e9 , 0x30ea , 0x30eb , 0x30ec , 0x30ed , 0x30ef , 0x30f0 , 0x30f1 , 0x30f2 , 0x30f3 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "multiplier" , new long [ ] { Long . MAX_VALUE , Long . MAX_VALUE , 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4EAC , 0x5146 , 0x5104 , 0x4E07 , 0x5343 , 0x767e , 0x5341 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x4E00 , 0x4E8C , 0x4E09 , 0x56DB , 0x4E94 , 0x516D , 0x4E03 , 0x516B , 0x4E5D } } , { "tables" , new String [ ] { "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '599', '0', '0', '0.976190476', '1', '0', '0', '198.3333333', '1', '0.3333', '1']
package org . apache . xml . utils . res ; public class XResources_hy extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "hy" } , { "help_language" , "hy" } , { "language" , "hy" } , { "alphabet" , new char [ ] { 0x0561 , 0x0562 , 0x0563 , 0x0564 , 0x0565 , 0x0566 , 0x0567 , 0x0568 , 0x0569 , 0x056A , 0x056B , 0x056C , 0x056D , 0x056E , 0x056F , 0x0567 , 0x0568 , 0x0572 , 0x0573 , 0x0574 , 0x0575 , 0x0576 , 0x0577 , 0x0578 , 0x0579 , 0x057A , 0x057B , 0x057C , 0x057D , 0x057E , 0x057F , 0x0580 , 0x0581 , 0x0582 , 0x0583 , 0x0584 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "additive" } , { "numberGroups" , new int [ ] { 1000 , 100 , 10 , 1 } } , { "digits" , new char [ ] { 0x0561 , 0x0562 , 0x0563 , 0x0564 , 0x0565 , 0x0566 , 0x0567 , 0x0568 , 0x0569 } } , { "tens" , new char [ ] { 0x056A , 0x056B , 0x056C , 0x056D , 0x056E , 0x056F , 0x0567 , 0x0568 , 0x0572 } } , { "hundreds" , new char [ ] { 0x0573 , 0x0574 , 0x0575 , 0x0576 , 0x0577 , 0x0578 , 0x0579 , 0x057A , 0x057B } } , { "thousands" , new char [ ] { 0x057C , 0x057D , 0x057E , 0x057F , 0x0580 , 0x0581 , 0x0582 , 0x0583 , 0x0584 } } , { "tables" , new String [ ] { "thousands" , "hundreds" , "tens" , "digits" } } } ; } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '614', '0', '0', '0.976190476', '1', '0', '0', '203.3333333', '1', '0.3333', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xpath . Expression ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . xml . sax . SAXException ; public class ElemValueOf extends ElemTemplateElement { private XPath m_selectExpression = null ; private boolean m_isDot = false ; public void setSelect ( XPath v ) { if ( null != v ) { String s = v . getPatternString ( ) ; m_isDot = ( null != s ) && s . equals ( "." ) ; } m_selectExpression = v ; } public XPath getSelect ( ) { return m_selectExpression ; } private boolean m_disableOutputEscaping = false ; public void setDisableOutputEscaping ( boolean v ) { m_disableOutputEscaping = v ; } public boolean getDisableOutputEscaping ( ) { return m_disableOutputEscaping ; } public int getXSLToken ( ) { return Constants . ELEMNAME_VALUEOF ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_selectExpression ) m_selectExpression . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public String getNodeName ( ) { return Constants . ELEMNAME_VALUEOF_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext xctxt = transformer . getXPathContext ( ) ; SerializationHandler rth = transformer . getResultTreeHandler ( ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { if ( false && m_isDot && ! TransformerImpl . S_DEBUG ) { int child = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( child ) ; xctxt . pushCurrentNode ( child ) ; if ( m_disableOutputEscaping ) rth . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; try { dtm . dispatchCharactersEvents ( child , rth , false ) ; } finally { if ( m_disableOutputEscaping ) rth . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; xctxt . popCurrentNode ( ) ; } } else { xctxt . pushNamespaceContext ( this ) ; int current = xctxt . getCurrentNode ( ) ; xctxt . pushCurrentNodeAndExpression ( current , current ) ; if ( m_disableOutputEscaping ) rth . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; try { Expression expr = m_selectExpression . getExpression ( ) ; if ( TransformerImpl . S_DEBUG ) { XObject obj = expr . execute ( xctxt ) ; transformer . getTraceManager ( ) . fireSelectedEvent ( current , this , "select" , m_selectExpression , obj ) ; obj . dispatchCharactersEvents ( rth ) ; } else { expr . executeCharsToContentHandler ( xctxt , rth ) ; } } finally { if ( m_disableOutputEscaping ) rth . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; xctxt . popNamespaceContext ( ) ; xctxt . popCurrentNodeAndExpression ( ) ; } } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } catch ( RuntimeException re ) { TransformerException te = new TransformerException ( re ) ; te . setLocator ( this ) ; throw te ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; return null ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) m_selectExpression . getExpression ( ) . callVisitors ( m_selectExpression , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['11', '3', '0', '16', '41', '15', '3', '14', '10', '0.7', '228', '1', '1', '0.951456311', '0.233766234', '2', '6', '19.45454545', '4', '1.2727', '2']
package org . apache . xml . utils ; public class FastStringBuffer { static final int DEBUG_FORCE_INIT_BITS = 0 ; static boolean DEBUG_FORCE_FIXED_CHUNKSIZE = true ; public static final int SUPPRESS_LEADING_WS = 0x01 ; public static final int SUPPRESS_TRAILING_WS = 0x02 ; public static final int SUPPRESS_BOTH = SUPPRESS_LEADING_WS | SUPPRESS_TRAILING_WS ; private static final int CARRY_WS = 0x04 ; int m_chunkBits = 15 ; int m_maxChunkBits = 15 ; int m_rebundleBits = 2 ; int m_chunkSize ; int m_chunkMask ; char [ ] [ ] m_array ; int m_lastChunk = 0 ; int m_firstFree = 0 ; FastStringBuffer m_innerFSB = null ; public FastStringBuffer ( int initChunkBits , int maxChunkBits , int rebundleBits ) { if ( DEBUG_FORCE_INIT_BITS != 0 ) initChunkBits = DEBUG_FORCE_INIT_BITS ; if ( DEBUG_FORCE_FIXED_CHUNKSIZE ) maxChunkBits = initChunkBits ; m_array = new char [ 16 ] [ ] ; if ( initChunkBits > maxChunkBits ) initChunkBits = maxChunkBits ; m_chunkBits = initChunkBits ; m_maxChunkBits = maxChunkBits ; m_rebundleBits = rebundleBits ; m_chunkSize = 1 << ( initChunkBits ) ; m_chunkMask = m_chunkSize - 1 ; m_array [ 0 ] = new char [ m_chunkSize ] ; } public FastStringBuffer ( int initChunkBits , int maxChunkBits ) { this ( initChunkBits , maxChunkBits , 2 ) ; } public FastStringBuffer ( int initChunkBits ) { this ( initChunkBits , 15 , 2 ) ; } public FastStringBuffer ( ) { this ( 10 , 15 , 2 ) ; } public final int size ( ) { return ( m_lastChunk << m_chunkBits ) + m_firstFree ; } public final int length ( ) { return ( m_lastChunk << m_chunkBits ) + m_firstFree ; } public final void reset ( ) { m_lastChunk = 0 ; m_firstFree = 0 ; FastStringBuffer innermost = this ; while ( innermost . m_innerFSB != null ) { innermost = innermost . m_innerFSB ; } m_chunkBits = innermost . m_chunkBits ; m_chunkSize = innermost . m_chunkSize ; m_chunkMask = innermost . m_chunkMask ; m_innerFSB = null ; m_array = new char [ 16 ] [ 0 ] ; m_array [ 0 ] = new char [ m_chunkSize ] ; } public final void setLength ( int l ) { m_lastChunk = l > > > m_chunkBits ; if ( m_lastChunk == 0 && m_innerFSB != null ) { m_innerFSB . setLength ( l , this ) ; } else { m_firstFree = l & m_chunkMask ; if ( m_firstFree == 0 && m_lastChunk > 0 ) { -- m_lastChunk ; m_firstFree = m_chunkSize ; } } } private final void setLength ( int l , FastStringBuffer rootFSB ) { m_lastChunk = l > > > m_chunkBits ; if ( m_lastChunk == 0 && m_innerFSB != null ) { m_innerFSB . setLength ( l , rootFSB ) ; } else { rootFSB . m_chunkBits = m_chunkBits ; rootFSB . m_maxChunkBits = m_maxChunkBits ; rootFSB . m_rebundleBits = m_rebundleBits ; rootFSB . m_chunkSize = m_chunkSize ; rootFSB . m_chunkMask = m_chunkMask ; rootFSB . m_array = m_array ; rootFSB . m_innerFSB = m_innerFSB ; rootFSB . m_lastChunk = m_lastChunk ; rootFSB . m_firstFree = l & m_chunkMask ; } } public final String toString ( ) { int length = ( m_lastChunk << m_chunkBits ) + m_firstFree ; return getString ( new StringBuffer ( length ) , 0 , 0 , length ) . toString ( ) ; } public final void append ( char value ) { char [ ] chunk ; boolean lastchunk = ( m_lastChunk + 1 == m_array . length ) ; if ( m_firstFree < m_chunkSize ) chunk = m_array [ m_lastChunk ] ; else { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } m_firstFree = 0 ; } chunk [ m_firstFree ++ ] = value ; } public final void append ( String value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( 0 == strlen ) return ; int copyfrom = 0 ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; value . getChars ( copyfrom , copyfrom + available , m_array [ m_lastChunk ] , m_firstFree ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public final void append ( StringBuffer value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( 0 == strlen ) return ; int copyfrom = 0 ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; value . getChars ( copyfrom , copyfrom + available , m_array [ m_lastChunk ] , m_firstFree ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public final void append ( char [ ] chars , int start , int length ) { int strlen = length ; if ( 0 == strlen ) return ; int copyfrom = start ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; System . arraycopy ( chars , copyfrom , m_array [ m_lastChunk ] , m_firstFree , available ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public final void append ( FastStringBuffer value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( 0 == strlen ) return ; int copyfrom = 0 ; char [ ] chunk = m_array [ m_lastChunk ] ; int available = m_chunkSize - m_firstFree ; while ( strlen > 0 ) { if ( available > strlen ) available = strlen ; int sourcechunk = ( copyfrom + value . m_chunkSize - 1 ) > > > value . m_chunkBits ; int sourcecolumn = copyfrom & value . m_chunkMask ; int runlength = value . m_chunkSize - sourcecolumn ; if ( runlength > available ) runlength = available ; System . arraycopy ( value . m_array [ sourcechunk ] , sourcecolumn , m_array [ m_lastChunk ] , m_firstFree , runlength ) ; if ( runlength != available ) System . arraycopy ( value . m_array [ sourcechunk + 1 ] , 0 , m_array [ m_lastChunk ] , m_firstFree + runlength , available - runlength ) ; strlen -= available ; copyfrom += available ; if ( strlen > 0 ) { int i = m_array . length ; if ( m_lastChunk + 1 == i ) { char [ ] [ ] newarray = new char [ i + 16 ] [ ] ; System . arraycopy ( m_array , 0 , newarray , 0 , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastChunk ] ; if ( chunk == null ) { if ( m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits ) { m_innerFSB = new FastStringBuffer ( this ) ; } chunk = m_array [ m_lastChunk ] = new char [ m_chunkSize ] ; } available = m_chunkSize ; m_firstFree = 0 ; } } m_firstFree += available ; } public boolean isWhitespace ( int start , int length ) { int sourcechunk = start > > > m_chunkBits ; int sourcecolumn = start & m_chunkMask ; int available = m_chunkSize - sourcecolumn ; boolean chunkOK ; while ( length > 0 ) { int runlength = ( length <= available ) ? length : available ; if ( sourcechunk == 0 && m_innerFSB != null ) chunkOK = m_innerFSB . isWhitespace ( sourcecolumn , runlength ) ; else chunkOK = org . apache . xml . utils . XMLCharacterRecognizer . isWhiteSpace ( m_array [ sourcechunk ] , sourcecolumn , runlength ) ; if ( ! chunkOK ) return false ; length -= runlength ; ++ sourcechunk ; sourcecolumn = 0 ; available = m_chunkSize ; } return true ; } public String getString ( int start , int length ) { int startColumn = start & m_chunkMask ; int startChunk = start > > > m_chunkBits ; if ( startColumn + length < m_chunkMask && m_innerFSB == null ) { return getOneChunkString ( startChunk , startColumn , length ) ; } return getString ( new StringBuffer ( length ) , startChunk , startColumn , length ) . toString ( ) ; } protected String getOneChunkString ( int startChunk , int startColumn , int length ) { return new String ( m_array [ startChunk ] , startColumn , length ) ; } StringBuffer getString ( StringBuffer sb , int start , int length ) { return getString ( sb , start > > > m_chunkBits , start & m_chunkMask , length ) ; } StringBuffer getString ( StringBuffer sb , int startChunk , int startColumn , int length ) { int stop = ( startChunk << m_chunkBits ) + startColumn + length ; int stopChunk = stop > > > m_chunkBits ; int stopColumn = stop & m_chunkMask ; for ( int i = startChunk ; i < stopChunk ; ++ i ) { if ( i == 0 && m_innerFSB != null ) m_innerFSB . getString ( sb , startColumn , m_chunkSize - startColumn ) ; else sb . append ( m_array [ i ] , startColumn , m_chunkSize - startColumn ) ; startColumn = 0 ; } if ( stopChunk == 0 && m_innerFSB != null ) m_innerFSB . getString ( sb , startColumn , stopColumn - startColumn ) ; else if ( stopColumn > startColumn ) sb . append ( m_array [ stopChunk ] , startColumn , stopColumn - startColumn ) ; return sb ; } public char charAt ( int pos ) { int startChunk = pos > > > m_chunkBits ; if ( startChunk == 0 && m_innerFSB != null ) return m_innerFSB . charAt ( pos & m_chunkMask ) ; else return m_array [ startChunk ] [ pos & m_chunkMask ] ; } public void sendSAXcharacters ( org . xml . sax . ContentHandler ch , int start , int length ) throws org . xml . sax . SAXException { int startChunk = start > > > m_chunkBits ; int startColumn = start & m_chunkMask ; if ( startColumn + length < m_chunkMask && m_innerFSB == null ) { ch . characters ( m_array [ startChunk ] , startColumn , length ) ; return ; } int stop = start + length ; int stopChunk = stop > > > m_chunkBits ; int stopColumn = stop & m_chunkMask ; for ( int i = startChunk ; i < stopChunk ; ++ i ) { if ( i == 0 && m_innerFSB != null ) m_innerFSB . sendSAXcharacters ( ch , startColumn , m_chunkSize - startColumn ) ; else ch . characters ( m_array [ i ] , startColumn , m_chunkSize - startColumn ) ; startColumn = 0 ; } if ( stopChunk == 0 && m_innerFSB != null ) m_innerFSB . sendSAXcharacters ( ch , startColumn , stopColumn - startColumn ) ; else if ( stopColumn > startColumn ) { ch . characters ( m_array [ stopChunk ] , startColumn , stopColumn - startColumn ) ; } } public int sendNormalizedSAXcharacters ( org . xml . sax . ContentHandler ch , int start , int length ) throws org . xml . sax . SAXException { int stateForNextChunk = SUPPRESS_LEADING_WS ; int stop = start + length ; int startChunk = start > > > m_chunkBits ; int startColumn = start & m_chunkMask ; int stopChunk = stop > > > m_chunkBits ; int stopColumn = stop & m_chunkMask ; for ( int i = startChunk ; i < stopChunk ; ++ i ) { if ( i == 0 && m_innerFSB != null ) stateForNextChunk = m_innerFSB . sendNormalizedSAXcharacters ( ch , startColumn , m_chunkSize - startColumn ) ; else stateForNextChunk = sendNormalizedSAXcharacters ( m_array [ i ] , startColumn , m_chunkSize - startColumn , ch , stateForNextChunk ) ; startColumn = 0 ; } if ( stopChunk == 0 && m_innerFSB != null ) stateForNextChunk = m_innerFSB . sendNormalizedSAXcharacters ( ch , startColumn , stopColumn - startColumn ) ; else if ( stopColumn > startColumn ) { stateForNextChunk = sendNormalizedSAXcharacters ( m_array [ stopChunk ] , startColumn , stopColumn - startColumn , ch , stateForNextChunk | SUPPRESS_TRAILING_WS ) ; } return stateForNextChunk ; } static final char [ ] SINGLE_SPACE = { ' ' } ; static int sendNormalizedSAXcharacters ( char ch [ ] , int start , int length , org . xml . sax . ContentHandler handler , int edgeTreatmentFlags ) throws org . xml . sax . SAXException { boolean processingLeadingWhitespace = ( ( edgeTreatmentFlags & SUPPRESS_LEADING_WS ) != 0 ) ; boolean seenWhitespace = ( ( edgeTreatmentFlags & CARRY_WS ) != 0 ) ; boolean suppressTrailingWhitespace = ( ( edgeTreatmentFlags & SUPPRESS_TRAILING_WS ) != 0 ) ; int currPos = start ; int limit = start + length ; if ( processingLeadingWhitespace ) { for ( ; currPos < limit && XMLCharacterRecognizer . isWhiteSpace ( ch [ currPos ] ) ; currPos ++ ) { } if ( currPos == limit ) { return edgeTreatmentFlags ; } } while ( currPos < limit ) { int startNonWhitespace = currPos ; for ( ; currPos < limit && ! XMLCharacterRecognizer . isWhiteSpace ( ch [ currPos ] ) ; currPos ++ ) { } if ( startNonWhitespace != currPos ) { if ( seenWhitespace ) { handler . characters ( SINGLE_SPACE , 0 , 1 ) ; seenWhitespace = false ; } handler . characters ( ch , startNonWhitespace , currPos - startNonWhitespace ) ; } int startWhitespace = currPos ; for ( ; currPos < limit && XMLCharacterRecognizer . isWhiteSpace ( ch [ currPos ] ) ; currPos ++ ) { } if ( startWhitespace != currPos ) { seenWhitespace = true ; } } return ( seenWhitespace ? CARRY_WS : 0 ) | ( edgeTreatmentFlags & SUPPRESS_TRAILING_WS ) ; } public static void sendNormalizedSAXcharacters ( char ch [ ] , int start , int length , org . xml . sax . ContentHandler handler ) throws org . xml . sax . SAXException { sendNormalizedSAXcharacters ( ch , start , length , handler , SUPPRESS_BOTH ) ; } public void sendSAXComment ( org . xml . sax . ext . LexicalHandler ch , int start , int length ) throws org . xml . sax . SAXException { String comment = getString ( start , length ) ; ch . comment ( comment . toCharArray ( ) , 0 , length ) ; } private void getChars ( int srcBegin , int srcEnd , char dst [ ] , int dstBegin ) { } private FastStringBuffer ( FastStringBuffer source ) { m_chunkBits = source . m_chunkBits ; m_maxChunkBits = source . m_maxChunkBits ; m_rebundleBits = source . m_rebundleBits ; m_chunkSize = source . m_chunkSize ; m_chunkMask = source . m_chunkMask ; m_array = source . m_array ; m_innerFSB = source . m_innerFSB ; m_lastChunk = source . m_lastChunk - 1 ; m_firstFree = source . m_chunkSize ; source . m_array = new char [ 16 ] [ ] ; source . m_innerFSB = this ; source . m_lastChunk = 1 ; source . m_firstFree = 0 ; source . m_chunkBits += m_rebundleBits ; source . m_chunkSize = 1 << ( source . m_chunkBits ) ; source . m_chunkMask = source . m_chunkSize - 1 ; } } 	1	['29', '1', '0', '24', '44', '0', '23', '1', '21', '0.640625', '1655', '0.0625', '1', '0', '0.242063492', '0', '0', '55.51724138', '11', '3', '2']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import javax . xml . transform . Result ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . LexicalHandler ; public class ToXMLSAXHandler extends ToSAXHandler { protected boolean m_escapeSetting = false ; public ToXMLSAXHandler ( ) { m_prefixMap = new NamespaceMappings ( ) ; initCDATA ( ) ; } public Properties getOutputFormat ( ) { return null ; } public OutputStream getOutputStream ( ) { return null ; } public Writer getWriter ( ) { return null ; } public void indent ( int n ) throws SAXException { } public void serialize ( Node node ) throws IOException { } public boolean setEscaping ( boolean escape ) throws SAXException { boolean oldEscapeSetting = m_escapeSetting ; m_escapeSetting = escape ; if ( escape ) { processingInstruction ( Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } else { processingInstruction ( Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; } return oldEscapeSetting ; } public void setOutputFormat ( Properties format ) { } public void setOutputStream ( OutputStream output ) { } public void setWriter ( Writer writer ) { } public void attributeDecl ( String arg0 , String arg1 , String arg2 , String arg3 , String arg4 ) throws SAXException { } public void elementDecl ( String arg0 , String arg1 ) throws SAXException { } public void externalEntityDecl ( String arg0 , String arg1 , String arg2 ) throws SAXException { } public void internalEntityDecl ( String arg0 , String arg1 ) throws SAXException { } public void endDocument ( ) throws SAXException { flushPending ( ) ; m_saxHandler . endDocument ( ) ; if ( m_tracer != null ) super . fireEndDoc ( ) ; } protected void closeStartTag ( ) throws SAXException { m_elemContext . m_startTagOpen = false ; final String localName = getLocalName ( m_elemContext . m_elementName ) ; final String uri = getNamespaceURI ( m_elemContext . m_elementName , true ) ; if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; } m_saxHandler . startElement ( uri , localName , m_elemContext . m_elementName , m_attributes ) ; m_attributes . clear ( ) ; if ( m_state != null ) m_state . setCurrentNode ( null ) ; } public void closeCDATA ( ) throws SAXException { if ( m_lexHandler != null && m_cdataTagOpen ) { m_lexHandler . endCDATA ( ) ; } m_cdataTagOpen = false ; } public void endElement ( String namespaceURI , String localName , String qName ) throws SAXException { flushPending ( ) ; if ( namespaceURI == null ) { if ( m_elemContext . m_elementURI != null ) namespaceURI = m_elemContext . m_elementURI ; else namespaceURI = getNamespaceURI ( qName , true ) ; } if ( localName == null ) { if ( m_elemContext . m_elementLocalName != null ) localName = m_elemContext . m_elementLocalName ; else localName = getLocalName ( qName ) ; } m_saxHandler . endElement ( namespaceURI , localName , qName ) ; if ( m_tracer != null ) super . fireEndElem ( qName ) ; m_prefixMap . popNamespaces ( m_elemContext . m_currentElemDepth , m_saxHandler ) ; m_elemContext = m_elemContext . m_prev ; } public void endPrefixMapping ( String prefix ) throws SAXException { return ; } public void ignorableWhitespace ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { m_saxHandler . ignorableWhitespace ( arg0 , arg1 , arg2 ) ; } public void setDocumentLocator ( Locator arg0 ) { m_saxHandler . setDocumentLocator ( arg0 ) ; } public void skippedEntity ( String arg0 ) throws SAXException { m_saxHandler . skippedEntity ( arg0 ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { startPrefixMapping ( prefix , uri , true ) ; } public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws org . xml . sax . SAXException { boolean pushed ; int pushDepth ; if ( shouldFlush ) { flushPending ( ) ; pushDepth = m_elemContext . m_currentElemDepth + 1 ; } else { pushDepth = m_elemContext . m_currentElemDepth ; } pushed = m_prefixMap . pushNamespace ( prefix , uri , pushDepth ) ; if ( pushed ) { m_saxHandler . startPrefixMapping ( prefix , uri ) ; if ( getShouldOutputNSAttr ( ) ) { String name ; if ( EMPTYSTRING . equals ( prefix ) ) { name = "xmlns" ; addAttributeAlways ( XMLNS_URI , prefix , name , "CDATA" , uri ) ; } else { if ( ! EMPTYSTRING . equals ( uri ) ) { name = "xmlns:" + prefix ; addAttributeAlways ( XMLNS_URI , prefix , name , "CDATA" , uri ) ; } } } } return pushed ; } public void comment ( char [ ] arg0 , int arg1 , int arg2 ) throws SAXException { flushPending ( ) ; if ( m_lexHandler != null ) m_lexHandler . comment ( arg0 , arg1 , arg2 ) ; if ( m_tracer != null ) super . fireCommentEvent ( arg0 , arg1 , arg2 ) ; } public void endCDATA ( ) throws SAXException { } public void endDTD ( ) throws SAXException { if ( m_lexHandler != null ) m_lexHandler . endDTD ( ) ; } public void startEntity ( String arg0 ) throws SAXException { if ( m_lexHandler != null ) m_lexHandler . startEntity ( arg0 ) ; } public void characters ( String chars ) throws SAXException { final int length = chars . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * 2 + 1 ] ; } chars . getChars ( 0 , length , m_charsBuff , 0 ) ; this . characters ( m_charsBuff , 0 , length ) ; } public ToXMLSAXHandler ( ContentHandler handler , String encoding ) { super ( handler , encoding ) ; initCDATA ( ) ; m_prefixMap = new NamespaceMappings ( ) ; } public ToXMLSAXHandler ( ContentHandler handler , LexicalHandler lex , String encoding ) { super ( handler , lex , encoding ) ; initCDATA ( ) ; m_prefixMap = new NamespaceMappings ( ) ; } public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { startElement ( elementNamespaceURI , elementLocalName , elementName , null ) ; } public void startElement ( String elementName ) throws SAXException { startElement ( null , null , elementName , null ) ; } public void characters ( char [ ] ch , int off , int len ) throws SAXException { if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } if ( m_elemContext . m_isCdataSection && ! m_cdataTagOpen && m_lexHandler != null ) { m_lexHandler . startCDATA ( ) ; m_cdataTagOpen = true ; } m_saxHandler . characters ( ch , off , len ) ; if ( m_tracer != null ) fireCharEvent ( ch , off , len ) ; } public void endElement ( String elemName ) throws SAXException { endElement ( null , null , elemName ) ; } public void namespaceAfterStartElement ( final String prefix , final String uri ) throws SAXException { startPrefixMapping ( prefix , uri , false ) ; } public void processingInstruction ( String target , String data ) throws SAXException { flushPending ( ) ; m_saxHandler . processingInstruction ( target , data ) ; if ( m_tracer != null ) super . fireEscapingEvent ( target , data ) ; } protected boolean popNamespace ( String prefix ) { try { if ( m_prefixMap . popNamespace ( prefix ) ) { m_saxHandler . endPrefixMapping ( prefix ) ; return true ; } } catch ( SAXException e ) { } return false ; } public void startCDATA ( ) throws SAXException { if ( ! m_cdataTagOpen ) { flushPending ( ) ; if ( m_lexHandler != null ) { m_lexHandler . startCDATA ( ) ; m_cdataTagOpen = true ; } } } public void startElement ( String namespaceURI , String localName , String name , Attributes atts ) throws SAXException { flushPending ( ) ; super . startElement ( namespaceURI , localName , name , atts ) ; if ( m_needToOutputDocTypeDecl ) { String doctypeSystem = getDoctypeSystem ( ) ; if ( doctypeSystem != null && m_lexHandler != null ) { String doctypePublic = getDoctypePublic ( ) ; if ( doctypeSystem != null ) m_lexHandler . startDTD ( name , doctypePublic , doctypeSystem ) ; } m_needToOutputDocTypeDecl = false ; } m_elemContext = m_elemContext . push ( namespaceURI , localName , name ) ; if ( namespaceURI != null ) ensurePrefixIsDeclared ( namespaceURI , name ) ; if ( atts != null ) addAttributes ( atts ) ; m_elemContext . m_isCdataSection = isCdataSection ( ) ; } private void ensurePrefixIsDeclared ( String ns , String rawName ) throws org . xml . sax . SAXException { if ( ns != null && ns . length ( ) > 0 ) { int index ; String prefix = ( index = rawName . indexOf ( ":" ) ) < 0 ? "" : rawName . substring ( 0 , index ) ; if ( null != prefix ) { String foundURI = m_prefixMap . lookupNamespace ( prefix ) ; if ( ( null == foundURI ) || ! foundURI . equals ( ns ) ) { this . startPrefixMapping ( prefix , ns , false ) ; if ( getShouldOutputNSAttr ( ) ) { this . addAttributeAlways ( "http://www.w3.org/2000/xmlns/" , prefix , "xmlns" + ( prefix . length ( ) == 0 ? "" : ":" ) + prefix , "CDATA" , ns ) ; } } } } } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { if ( m_elemContext . m_startTagOpen ) { ensurePrefixIsDeclared ( uri , rawName ) ; addAttributeAlways ( uri , localName , rawName , type , value ) ; } } public boolean reset ( ) { boolean wasReset = false ; if ( super . reset ( ) ) { resetToXMLSAXHandler ( ) ; wasReset = true ; } return wasReset ; } private void resetToXMLSAXHandler ( ) { this . m_escapeSetting = false ; } } 	1	['44', '3', '0', '9', '97', '742', '3', '6', '40', '0.88372093', '680', '1', '0', '0.730263158', '0.146853147', '2', '13', '14.43181818', '2', '0.9545', '2']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . serializer . NamespaceMappings ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLChar ; import org . xml . sax . SAXException ; public class ElemAttribute extends ElemElement { public int getXSLToken ( ) { return Constants . ELEMNAME_ATTRIBUTE ; } public String getNodeName ( ) { return Constants . ELEMNAME_ATTRIBUTE_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { SerializationHandler rhandler = transformer . getSerializationHandler ( ) ; super . execute ( transformer ) ; } protected String resolvePrefix ( SerializationHandler rhandler , String prefix , String nodeNamespace ) throws TransformerException { if ( null != prefix && ( prefix . length ( ) == 0 || prefix . equals ( "xmlns" ) ) ) { prefix = rhandler . getPrefix ( nodeNamespace ) ; if ( null == prefix || prefix . length ( ) == 0 || prefix . equals ( "xmlns" ) ) { if ( nodeNamespace . length ( ) > 0 ) { NamespaceMappings prefixMapping = rhandler . getNamespaceMappings ( ) ; prefix = prefixMapping . generateNextPrefix ( ) ; } else prefix = "" ; } } return prefix ; } protected boolean validateNodeName ( String nodeName ) { if ( null == nodeName ) return false ; if ( nodeName . equals ( "xmlns" ) ) return false ; return XMLChar . isValidQName ( nodeName ) ; } void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { if ( null != nodeName && nodeName . length ( ) > 0 ) { SerializationHandler rhandler = transformer . getSerializationHandler ( ) ; if ( prefix != null && prefix . length ( ) > 0 ) { try { rhandler . startPrefixMapping ( prefix , nodeNamespace , false ) ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } } String val = transformer . transformToString ( this ) ; String localName = QName . getLocalPart ( nodeName ) ; try { if ( prefix != null && prefix . length ( ) > 0 ) { rhandler . addAttribute ( nodeNamespace , localName , nodeName , "CDATA" , val ) ; } else { rhandler . addAttribute ( "" , localName , nodeName , "CDATA" , val ) ; } } catch ( SAXException e ) { } } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEXTLITERALRESULT : case Constants . ELEMNAME_APPLY_TEMPLATES : case Constants . ELEMNAME_APPLY_IMPORTS : case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_FOREACH : case Constants . ELEMNAME_VALUEOF : case Constants . ELEMNAME_COPY_OF : case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_CHOOSE : case Constants . ELEMNAME_IF : case Constants . ELEMNAME_TEXT : case Constants . ELEMNAME_COPY : case Constants . ELEMNAME_VARIABLE : case Constants . ELEMNAME_MESSAGE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } public void setName ( AVT v ) { if ( v . isSimple ( ) ) { if ( v . getSimpleString ( ) . equals ( "xmlns" ) ) { throw new IllegalArgumentException ( ) ; } } super . setName ( v ) ; } } 	1	['9', '5', '0', '10', '31', '36', '2', '8', '6', '2', '173', '0', '0', '0.963800905', '0.314814815', '4', '10', '18.22222222', '16', '3', '2']
package org . apache . xalan . res ; public class XSLTErrorResources_sv extends XSLTErrorResources { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_NO_CURLYBRACE , "Fel: Kan inte ha '{' inuti uttryck" } , { ER_ILLEGAL_ATTRIBUTE , "{0} har ett otillåtet attribut: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode är null i xsl:apply-imports!" } , { ER_CANNOT_ADD , "Kan inte lägga {0} till {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode är null i handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "{0} måste ha ett namn-attribut." } , { ER_TEMPLATE_NOT_FOUND , "Hittade inte mallen med namn: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Kunde inte lösa namn-AVT i xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} kräver attribut: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} måste ha ett ''test''-attribut." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Dåligt värde på nivå-attribut: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Namn på behandlande instruktion får inte vara 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Namn på behandlande instruktion måste vara ett giltigt NCNamn: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} måste ha ett matchningsattribut om det har ett tillstånd." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} kräver antingen ett namn eller ett matchningsattribut." } , { ER_CANT_RESOLVE_NSPREFIX , "Kan inte lösa namnrymdsprefix: {0}" } , { ER_ILLEGAL_VALUE , "xml:space har ett otillåtet värde: {0}" } , { ER_NO_OWNERDOC , "Barnnod saknar ägardokument!" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement-fel: {0}" } , { ER_NULL_CHILD , "Försöker lägga till ett null-barn!" } , { ER_NEED_SELECT_ATTRIB , "{0} kräver ett valattribut." } , { ER_NEED_TEST_ATTRIB , "xsl:when måste ha ett 'test'-attribut." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param måste ha ett 'namn'-attribut." } , { ER_NO_CONTEXT_OWNERDOC , "Kontext saknar ägardokument!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Kunde inte skapa XML TransformerFactory Liaison: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: Process misslyckades." } , { ER_NOT_SUCCESSFUL , "Xalan: misslyckades." } , { ER_ENCODING_NOT_SUPPORTED , "Kodning inte understödd: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Kunde inte skapa TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key måste ha ett 'namn'-attribut." } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key måste ha ett 'matcha'-attribut." } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key måste ha ett 'använd'-attribut." } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} kräver ett ''element''-attribut!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} ''prefix''-attribut saknas" } , { ER_BAD_STYLESHEET_URL , "Stylesheet URL är dålig: {0}" } , { ER_FILE_NOT_FOUND , "Stylesheet-fil saknas: {0}" } , { ER_IOEXCEPTION , "Fick IO-Undantag med stylesheet-fil: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Hittade inte href-attribute för {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} inkluderar, direkt eller indirekt, sig själv!" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude-fel, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} ''lang''-attribut' saknas" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) felplacerade {0} element?? Saknar behållarelement  ''komponent''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Kan endast skicka utdata till ett Element, ett DocumentFragment, ett Document, eller en PrintWriter." } , { ER_PROCESS_ERROR , "StylesheetRoot.process-fel" } , { ER_UNIMPLNODE_ERROR , "UnImplNode-fel: {0}" } , { ER_NO_SELECT_EXPRESSION , "Fel! Hittade inte xpath select-uttryck (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Kan inte serialisera en XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "Stylesheet-indata ej angiven!" } , { ER_FAILED_PROCESS_STYLESHEET , "Kunde inte behandla stylesheet!" } , { ER_COULDNT_PARSE_DOC , "Kunde inte tolka {0} dokument!" } , { ER_COULDNT_FIND_FRAGMENT , "Hittade inte fragment: {0}" } , { ER_NODE_NOT_ELEMENT , "Nod som pekades på av fragment-identifierare var inte ett element: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each kräver antingen en matchning eller ett namnattribut." } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "mallar kräver antingen en matchning eller ett namnattribut." } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Ingen klon av ett dokumentfragment!" } , { ER_CANT_CREATE_ITEM , "Kan inte skapa element i resultatträd: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space i käll-XML har ett otillåtet värde: {0}" } , { ER_NO_XSLKEY_DECLARATION , "Det finns ingen xsl:key-deklaration för {0}!" } , { ER_CANT_CREATE_URL , "Fel! Kan inte skapa url för: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions är inte understödd" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory-Fel" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} är inte tillåten inne i ett stylesheet!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns inte längre understödd!  Använd xsl:output istället." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space inte längre understödd!  Använd xsl:strip-space eller xsl:preserve-space istället." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result inte längre understödd!  Använd xsl:output istället." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} har ett otillåtet attribut: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Okänt XSL-element: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort kan endast användas med xsl:apply-templates eller xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) felplacerade xsl:when!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when härstammar inte från xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) felplacerade xsl:otherwise!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise härstammar inte från xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} är inte tillåten inne i en mall!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} utbyggnadsnamnrymdsprefix {1} okänt" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Imports kan endast förekomma som de första elementen i ett stylesheet!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} importerar, direkt eller indirekt, sig själv!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space har ett otillåtet värde: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet misslyckades!" } , { ER_SAX_EXCEPTION , "SAX-Undantag" } , { ER_XSLT_ERROR , "XSLT-fel" } , { ER_CURRENCY_SIGN_ILLEGAL , "valutatecken är inte tillåtet i formatmönstersträng" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Dokumentfunktion inte understödd i Stylesheet DOM!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Kan inte lösa prefix i icke-Prefixlösare!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Redirect extension: Hittade inte filnamn - fil eller valattribut måste returnera vald  sträng." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Kan inte bygga FormatterListener i Redirect extension!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Prefix i exkludera-resultat-prefix är inte giltig: {0}" } , { ER_MISSING_NS_URI , "Namnrymds-URI saknas för angivna prefix" } , { ER_MISSING_ARG_FOR_OPTION , "Argument saknas för alternativ: {0}" } , { ER_INVALID_OPTION , "Ogiltigt alternativ: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Fel format på formatsträng: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet måste ha ett 'version'-attribut!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Attribut: {0} har ett otillåtet värde: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose kräver ett xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports inte tillåtet i ett xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Kan inte använda DTMLiaison till en DOM utdatanod... skicka en org.apache.xpath.DOM2Helper istället!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Kan inte använda DTMLiaison till en DOM indatanod... skicka en org.apache.xpath.DOM2Helper istället!" } , { ER_CALL_TO_EXT_FAILED , "Anrop till anslutningselement misslyckades: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Prefix måste lösa till en mamnrymd: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Ogiltigt UTF-16-surrogat upptäckt: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} använde sig självt, vilket kommer att orsaka en  oändlig loop." } , { ER_CANNOT_MIX_XERCESDOM , "Kan inte blanda icke-Xerces-DOM-indata med Xerces-DOM-utdata!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "I ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Hittade mer än en mall med namnet: {0}" } , { ER_INVALID_KEY_CALL , "Ogiltigt funktionsanrop: rekursiva key()-anrop är inte tillåtna" } , { ER_REFERENCING_ITSELF , "Variabel {0} hänvisar, direkt eller indirekt, till sig själv!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Indatanoden till en DOMSource för newTemplates får inte vara null!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Klassfil för alternativ {0} saknas" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Nödvändigt element saknas: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream får inte vara null" } , { ER_URI_CANNOT_BE_NULL , "URI får inte vara null" } , { ER_FILE_CANNOT_BE_NULL , "Fil får inte vara null" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource får inte vara null" } , { ER_CANNOT_INIT_BSFMGR , "Kan inte initialisera BSF Manager" } , { ER_CANNOT_CMPL_EXTENSN , "Kunde inte kompilera anslutning" } , { ER_CANNOT_CREATE_EXTENSN , "Kunde inte skapa anslutning: {0} på grund av: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "Instansmetodanrop till metod {0} kräver en Objektinstans som första argument" } , { ER_INVALID_ELEMENT_NAME , "Ogiltigt elementnamn angivet {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Elementnamnmetod måste vara static {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Anslutningsfunktion {0} : {1} är okänd" } , { ER_MORE_MATCH_CONSTRUCTOR , "Fler än en bästa matchning för konstruktor för {0}" } , { ER_MORE_MATCH_METHOD , "Fler än en bästa matchning för metod {0}" } , { ER_MORE_MATCH_ELEMENT , "Fler än en bästa matchning för elementmetod {0}" } , { ER_INVALID_CONTEXT_PASSED , "Ogiltig kontext skickad för att utvärdera {0}" } , { ER_POOL_EXISTS , "Pool finns redan" } , { ER_NO_DRIVER_NAME , "Inget driver-namn angivet" } , { ER_NO_URL , "Ingen URL angiven" } , { ER_POOL_SIZE_LESSTHAN_ONE , "Poolstorlek är mindre än ett!" } , { ER_INVALID_DRIVER , "Ogiltigt driver-namn angivet" } , { ER_NO_STYLESHEETROOT , "Hittade inte stylesheet-roten!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Ogiltigt värde för xml:space" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode misslyckades" } , { ER_RESOURCE_COULD_NOT_LOAD , "Resursen [ {0} ] kunde inte laddas: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Bufferstorlek <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Okänt fel vid anslutningsanrop" } , { ER_NO_NAMESPACE_DECL , "Prefix{0} har inte en motsvarande namnrymdsdeklaration" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Elementinnehåll är inte tillåtet för lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Stylesheet-ledd avslutning" } , { ER_ONE_OR_TWO , "1 eller 2" } , { ER_TWO_OR_THREE , "2 eller 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Kunde inte ladda {0} (kontrollera CLASSPATH), använder nu enbart standard" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Kan inte initialisera standardmallar" } , { ER_RESULT_NULL , "Result borde inte vara null" } , { ER_RESULT_COULD_NOT_BE_SET , "Result kunde inte sättas" } , { ER_NO_OUTPUT_SPECIFIED , "Ingen utdata angiven" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Kan inte omvandla till en Result av typ {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Kan inte omvandla en Source av typ {0}" } , { ER_NULL_CONTENT_HANDLER , "Innehållshanterare med värde null" } , { ER_NULL_ERROR_HANDLER , "Felhanterare med värde null" } , { ER_CANNOT_CALL_PARSE , "parse kan inte anropas om ContentHandler inte har satts" } , { ER_NO_PARENT_FOR_FILTER , "Ingen förälder till filter" } , { ER_NO_STYLESHEET_IN_MEDIA , "Stylesheet saknas i: {0}, media= {1}" } , { ER_NO_STYLESHEET_PI , "xml-stylesheet PI saknas i: {0}" } , { ER_NOT_SUPPORTED , "Understöds inte: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Värde på egenskap {0} borde vara en Boolesk instans" } , { "ER_SRC_ATTRIB_NOT_SUPPORTED" , "src-attributet understöds ännu inte för {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "Resursen [ {0} ] saknas. \n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Utdata-egenskap känns inte igen: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Kunde inte skapa instans av ElemLiteralResult" } , { ER_VALUE_SHOULD_BE_NUMBER , "Värdet för {0} bör innehålla en siffra som inte kan tolkas" } , { ER_VALUE_SHOULD_EQUAL , "Värde på {0} borde motsvara ja eller nej" } , { ER_FAILED_CALLING_METHOD , " Kunde inte anropa metoden {0}" } , { ER_FAILED_CREATING_ELEMTMPL , "Kunde inte skapa instans av ElemTemplateElement" } , { ER_CHARS_NOT_ALLOWED , "Tecken är inte tillåtna i dokumentet vid den här tidpunkten" } , { ER_ATTR_NOT_ALLOWED , "Attributet \"{0}\" är inte tillåten i det {1} elementet!" } , { ER_BAD_VALUE , "{0} dåligt värde {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "Attributet {0} saknas " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "Attributvärdet {0} känns inte igen " } , { ER_NULL_URI_NAMESPACE , "Försöker generera ett namnområdesprefix med en null-URI" } , { ER_NUMBER_TOO_BIG , "Försöker formatera en siffra som är större än det största långa heltalet" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Det går inte att hitta SAX1-drivrutinen klass {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "SAX1-drivrutinen klass {0} hittades men kan inte laddas" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "SAX1-drivrutinen klass {0} hittades men kan inte instansieras" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1-drivrutinen klass {0} implementerar inte org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Systemegenskapen org.xml.sax.parser är inte angiven" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Tolkningsargumentet får inte vara null" } , { ER_FEATURE , "Funktion:a {0}" } , { ER_PROPERTY , "Egenskap:a {0}" } , { ER_NULL_ENTITY_RESOLVER , "Nullenhetslösare" } , { ER_NULL_DTD_HANDLER , "Null-DTD-hanterare" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Inget drivrutinsnamn är angett!" } , { ER_NO_URL_SPECIFIED , "Ingen URL har angetts!" } , { ER_POOLSIZE_LESS_THAN_ONE , "Poolstorleken är mindre än 1!" } , { ER_INVALID_DRIVER_NAME , "Ett ogiltigt drivrutinsnamn har angetts!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Programmerarfel! expr har inget överordnat ElemTemplateElement!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Programmerarkontroll i RundundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} är inte tillåten i denna position i formatmallen!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Text utan blanksteg är inte tillåten i denna position i formatmallen!" } , { INVALID_TCHAR , "Ogiltigt värde: {1} används för CHAR-attributet: {0}.  Ett attribut av CHAR-typ får bara ha 1 tecken!" } , { INVALID_QNAME , "Ogiltigt värde:a {1} används för QNAME-attributet:a {0}" } , { INVALID_ENUM , "Ogiltigt värde:a  {1} används för ENUM-attributet:a {0}.  Giltiga värden är:a {2}." } , { INVALID_NMTOKEN , "Ogiltigt värde:a {1} används för NMTOKEN-attributet:a {0} " } , { INVALID_NCNAME , "Ogiltigt värde:a {1} används för NCNAME-attributet:a {0} " } , { INVALID_BOOLEAN , "Ogiltigt värde:a {1} används som Booleskt attribut:a {0} " } , { INVALID_NUMBER , "Ogiltigt värde:a {1} används som sifferattribut:a {0} " } , { ER_ARG_LITERAL , "Argument för {0} i matchningsmönstret måste vara literalt." } , { ER_DUPLICATE_GLOBAL_VAR , "Dubbel deklaration av global variabel." } , { ER_DUPLICATE_VAR , "Dubbel variabeldeklaration." } , { ER_TEMPLATE_NAME_MATCH , "xsl: en mall måste ha ett namn och ett matchningsattribut (eller både och)" } , { ER_INVALID_PREFIX , "Prefix i exclude-result-prefixes är ogiltigt:a {0}" } , { ER_NO_ATTRIB_SET , "attributserien {0} finns inte" } , { WG_FOUND_CURLYBRACE , "Hittade '}' men ingen attributmall är öppen!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Varning: räknarattribut matchar inte en förfäder in xsl:number! Target = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Gammal syntax: Namnet på  'expr'-attributet har ändrats till 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan hanterar ännu inte locale-namnet i funktionen format-number." } , { WG_LOCALE_NOT_FOUND , "Varning: Hittade inte locale för xml:lang{0}" } , { WG_CANNOT_MAKE_URL_FROM , "Kan inte skapa URL från: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Kan inte ladda begärd doc: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Hittade inte Collator för <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Gammal syntax: Funktionsinstruktionen borde använda en url av {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "kodning understöds inte: {0}, använder UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "kodning understöds inte: {0}, använder Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Hittade specificitetskonflikter: {0} Senast hittade i stylesheet kommer att användas." } , { WG_PARSING_AND_PREPARING , "========= Tolkar och förbereder {0} ==========" } , { WG_ATTR_TEMPLATE , "Attributmall, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Matcha konflikter mellan xsl:strip-space och xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan hanterar ännu inte attributet {0}!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "Deklaration saknas för decimalformat: {0}" } , { WG_OLD_XSLT_NS , "XSLT-Namnrymd saknas eller är inkorrekt " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Endast en standarddeklaration av xsl:decimal-format är tillåten." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-formatnamn måste vara unika. Namnet \"{0}\" har blivit duplicerat." } , { WG_ILLEGAL_ATTRIBUTE , "{0} har ett otillåtet attribut: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Kan inte lösa namnrymdsprefix: {0}. Noden kommer att ignoreras." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet måste ha ett 'version'-attribut!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Otillåtet attributnamn: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Ogiltigt värde använt för attribut {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "Den resulterande nodmängden från dokumentfunktions andra argument är tomt. Det första argumentet kommer att användas." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Värdet på attributet 'name' i xsl:processing-instruction får inte vara 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Värdet på attributet  ''name'' i xsl:processing-instruction måste vara ett giltigt NCName:a {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Det går inte att lägga till attributet {0} efter undernoder eller innan ett element produceras. Attributet ignoreras." } , { "ui_language" , "sv" } , { "help_language" , "sv" } , { "language" , "sv" } , { "BAD_CODE" , "Parameter till createMessage ligger utanför tillåtet intervall" } , { "FORMAT_FAILED" , "Undantag utlöst vid messageFormat-anrop" } , { "version" , ">>>>>>> Xalan Version" } , { "version2" , "<<<<<<<" } , { "yes" , "ja" } , { "line" , "Rad #" } , { "column" , "Kolumn #" } , { "xsldone" , "XSLProcessor: färdig" } , { "xslProc_option" , "Xalan-J kommando linje Process klass alternativ:" } , { "optionIN" , "    -IN inputXMLURL" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT utdataFilnamn]" } , { "optionLXCIN" , "   [-LXCIN kompileratStylesheetFilnameIn]" } , { "optionLXCOUT" , "   [-LXCOUT kompileratStylesheetFilenameUt]" } , { "optionPARSER" , "   [-PARSER fullt kvalificerat klassnamn eller tolkförbindelse]" } , { "optionE" , "   [-E (Utöka inte enhetsreferenser)]" } , { "optionV" , "   [-E (Utöka inte enhetsreferenser)]" } , { "optionQC" , "   [-QC (Tysta Mönsterkonfliktvarningar)]" } , { "optionQ" , "   [-Q  (Tyst Tillstånd)]" } , { "optionLF" , "   [-LF (Använd radframmatning enbart på utdata {standard är CR/LF})]" } , { "optionCR" , "   [-CR (Använd vagnretur enbart på utdata {standard är CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Vilka tecken är skiftningstecken {standard är <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Bestäm antal blanksteg för att tabulera {standard är 0})]" } , { "optionTT" , "   [-TT (Spåra mallarna allt eftersom de blir anropade.)]" } , { "optionTG" , "   [-TG (Spåra varje generationshändelse.)]" } , { "optionTS" , "   [-TS (Spåra varje valhändelse.)]" } , { "optionTTC" , "   [-TTC (Spåra mallbarnen allt eftersom de blir behandlade.)]" } , { "optionTCLASS" , "   [-TCLASS (TraceListener-klass för spårningsanslutningar.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Sätt om validering ska ske.  Standard är att validering är avstängd)]" } , { "optionEDUMP" , "   [-EDUMP {valfritt filnamn) (Gör stackdump vid fel.)]" } , { "optionXML" , "   [-XML (Använd XML-formaterare och lägg till XML-huvud.)]" } , { "optionTEXT" , "   [-XML (Använd enkel Text-formaterare.)]" } , { "optionHTML" , "   [-HTML (Använd HTML-formaterare)]" } , { "optionPARAM" , "   [-PARAM namn uttryck (Sätt en stylesheet-parameter)]" } , { "noParsermsg1" , "XSL-Process misslyckades." } , { "noParsermsg2" , "** Hittade inte tolk **" } , { "noParsermsg3" , "Vänligen kontrollera din classpath" } , { "noParsermsg4" , "Om du inte har IBMs XML-Tolk för Java, kan du ladda ner den från" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER fullständigt klassnamn (URIResolver som ska användas för att lösa URI-er)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER fullständigt klassnamn (EntityResolver som ska användas för att lösa enheter)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTRESOLVER fullständigt klassnamn (ContentHandler som ska användas för att serialisera utdata)]" } , { "optionLINENUMBERS" , "   [-L använd radnummer i källdokument]" } , { "optionMEDIA" , " [-MEDIA mediaType (använd medieattribut för att hitta en formatmall som är associerad med ett dokument.)]" } , { "optionFLAVOR" , " [-FLAVOR flavorName (Använd s2s=SAX eller d2d=DOM för transformationen.)] " } , { "optionDIAG" , " [-DIAG (Skriv ut totala transformationer, millisekunder.)]" } , { "optionINCREMENTAL" , " [-INCREMENTAL (begär inkrementell DTM-konstruktion genom att ange http://xml.apache.org/xalan/features/incremental true.)]" } , { "optionNOOPTIMIMIZE" , " [-NOOPTIMIMIZE (begär ingen formatmallsoptimering genom att ange http://xml.apache.org/xalan/features/optimize false.)]" } , { "optionRL" , " [-RL recursionlimit (kontrollera numerisk gräns på formatmallens rekursionsdjup.)]" } , { "optionXO" , " [-XO [transletName] (tilldela namnet till genererad translet)]" } , { "optionXD" , " [-XD destinationDirectory (ange målkatalog för translet)]" } , { "optionXJ" , " [-XJ jarfile (paketerar transletklasserna i en jar-fil med namnet <jarfile>)]" } , { "optionXP" , " [-XP-paket (anger ett paketnamnsprefix för alla genererade transletklasser)]" } } ; public static final String BAD_CODE = "DÅLIG_KOD" ; public static final String FORMAT_FAILED = "FORMATERING_MISSLYCKADES" ; public static final String ERROR_STRING = "#fel" ; public static final String ERROR_HEADER = "Fel: " ; public static final String WARNING_HEADER = "Varning: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MÖNSTER " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '1.423076923', '3769', '0', '0', '0.976190476', '1', '0', '0', '1251', '1', '0.3333', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_sk extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Interná chyba času spustenia v ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Chyba času spustenia pri spúšťaní <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Neplatná konverzia z ''{0}'' na ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "XSLTC nepodporuje externú funkciu ''{0}''." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Neznámy typ argumentu je výrazom rovnosti." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Neplatný typ argumentu ''{0}'' vo volaní do ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Pokus o formátovanie čísla ''{0}'' pomocou vzoru ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Nie je možné klonovať iterátor ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Iterátor pre os ''{0}'' nie je podporovaný." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Iterátor pre napísanú os ''{0}'' nie je podporovaný." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Atribút ''{0}'' je mimo elementu." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Deklarácia názvového priestoru ''{0}''=''{1}'' je mimo elementu." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "Názvový priestor pre predponu ''{0}'' nebol deklarovaný." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter bol vytvorený pomocou nesprávneho typu zdrojového DOM." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "Analyzátor SAX, ktorý používate, nespracúva udalosti deklarácie DTD." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "Analyzátor SAX, ktorý používate, nemá podporu pre názvové priestory XML." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "Nebolo možné rozlíšiť referenciu URI ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_it extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Errore: '{' non può essere contenuto in un'espressione " } , { ER_ILLEGAL_ATTRIBUTE , "{0} ha un attributo non valido: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode nullo in xsl:apply-imports!" } , { ER_CANNOT_ADD , "Impossibile aggiungere {0} a {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode nullo in handleApplyTemplatesInstruction." } , { ER_NO_NAME_ATTRIB , "{0} deve avere un attributo name." } , { ER_TEMPLATE_NOT_FOUND , "Impossibile trovare la maschera: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Impossibile risolvere il nome AVT in xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} richiede l''attributo: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} deve avere un attributo ''test''. " } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Valore errato nell''attributo livello: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Il nome dell'istruzione di elaborazione non può essere 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "il nome dell''istruzione di elaborazione deve essere un NCName valido: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} deve avere un attributo match nel caso abbia un modo." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} richiede un attributo match o name." } , { ER_CANT_RESOLVE_NSPREFIX , "Impossibile risolvere il prefisso dello spazio nomi: {0}" } , { ER_ILLEGAL_VALUE , "xml:space ha un valore non valido: {0}" } , { ER_NO_OWNERDOC , "Il nodo secondario non ha un documento proprietario." } , { ER_ELEMTEMPLATEELEM_ERR , "Errore ElemTemplateElement: {0}" } , { ER_NULL_CHILD , "E' stato effettuato un tentativo di aggiungere un secondario nullo." } , { ER_NEED_SELECT_ATTRIB , "{0} richiede un attributo select." } , { ER_NEED_TEST_ATTRIB , "xsl:when deve avere un attributo 'test'. " } , { ER_NEED_NAME_ATTRIB , "xsl:with-param deve avere un attributo 'name'. " } , { ER_NO_CONTEXT_OWNERDOC , "il contesto non ha un documento proprietario." } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Impossibile creare XML TransformerFactory Liaison: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: Processo non eseguito correttamente. " } , { ER_NOT_SUCCESSFUL , "Xalan: non eseguito correttamente. " } , { ER_ENCODING_NOT_SUPPORTED , "Codifica non supportata: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Impossibile creare TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key richiede un attributo 'name'. " } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key richiede un attributo 'match'. " } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key richiede un attributo 'use'. " } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} richiede un attributo ''elements''. " } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} attributo ''prefix'' mancante " } , { ER_BAD_STYLESHEET_URL , "URL del foglio di stile errato: {0}" } , { ER_FILE_NOT_FOUND , "File del foglio di stile non trovato: {0}" } , { ER_IOEXCEPTION , "Eccezione IO nel file del foglio di stile: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Impossibile trovare l''attributo href per {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} sta direttamente o indirettamente includendo se stesso." } , { ER_PROCESSINCLUDE_ERROR , "Errore StylesheetHandler.processInclude, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} attributo ''lang'' mancante " } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) elemento {0} non ubicato correttamente. Elemento contenitore ''component'' mancante " } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "L'emissione è consentita solo in un elemento, frammento di documento, documento o stampante." } , { ER_PROCESS_ERROR , "Errore StylesheetRoot.process" } , { ER_UNIMPLNODE_ERROR , "Errore UnImplNode: {0}" } , { ER_NO_SELECT_EXPRESSION , "Errore! Impossibile trovare espressione selezione xpath (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Impossibile serializzare XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "Input del foglio di stile non specificato." } , { ER_FAILED_PROCESS_STYLESHEET , "Impossibile elaborare il foglio di stile." } , { ER_COULDNT_PARSE_DOC , "Impossibile analizzare il documento {0}." } , { ER_COULDNT_FIND_FRAGMENT , "Impossibile trovare il frammento: {0}" } , { ER_NODE_NOT_ELEMENT , "Il nodo a cui fa riferimento l''identificativo del frammento non è un elemento: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each deve avere un attributo match o name" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "le maschere devono avere un attributo match o name" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "Non è possibile avere un clone di un frammento di documento." } , { ER_CANT_CREATE_ITEM , "Impossibile creare la voce nella struttura dei risultati: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space in XML di origine ha un valore non valido: {0}" } , { ER_NO_XSLKEY_DECLARATION , "Nessuna dichiarazione xsl:key per {0}!" } , { ER_CANT_CREATE_URL , "Errore! Impossibile creare url per: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions non supportato " } , { ER_PROCESSOR_ERROR , "Errore XSLT TransformerFactory" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} non consentito nel foglio di stile." } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns non è più supportato.  Utilizzare xsl:output. " } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space non è più supportato.  Utilizzare xsl:strip-space oppure xsl:preserve-space. " } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result non è più supportato.  Utilizzare xsl:output. " } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} ha un attributo non valido: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Elemento XSL sconosciuto: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort può essere utilizzato solo con xsl:apply-templates oppure xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when posizionato in modo non corretto. " } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when non reso principale da xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise posizionato in modo non corretto. " } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise non reso principale da xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} non è consentito in una maschera." } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} prefisso namespace estensione {1} sconosciuto" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Le importazioni possono verificarsi solo come primi elementi nel foglio di stile." } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} sta direttamente o indirettamente importando se stesso." } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:space ha un valore non valido: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet con esito negativo." } , { ER_SAX_EXCEPTION , "Eccezione SAX" } , { ER_XSLT_ERROR , "Errore XSLT" } , { ER_CURRENCY_SIGN_ILLEGAL , "il simbolo della valuta non è consentito nella stringa modello formato." } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "La funzione documento non è supportata nel DOM del foglio di stile." } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Impossibile risolvere il prefisso di un resolver non di prefisso." } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Redirect extension: Impossibile richiamare il nome file - l'attributo file o select deve restituire una stringa valida. " } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Impossibile creare FormatterListener in Redirect extension!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Prefisso in exclude-result-prefixes non valido: {0}" } , { ER_MISSING_NS_URI , "URI spazio nome mancante per il prefisso specificato" } , { ER_MISSING_ARG_FOR_OPTION , "Argomento mancante per l''opzione: {0}" } , { ER_INVALID_OPTION , "Opzione non valida: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Stringa di formato errato: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet richiede un attributo 'version'. " } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "L'attributo: {0} ha un valore non valido: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose richiede xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports non consentito in xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Impossibile utilizzare DTMLiaison per un nodo DOM di output... utilizzare invece org.apache.xpath.DOM2Helper." } , { ER_CANT_USE_DTM_FOR_INPUT , "Impossibile utilizzare DTMLiaison per un nodo DON di input... utilizzare invece org.apache.xpath.DOM2Helper." } , { ER_CALL_TO_EXT_FAILED , "Chiamata all''elemento estensione non riuscita: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Il prefisso deve risolvere in uno spazio nomi: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Rilevato surrogato UTF-16 non valido: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} sta utilizzando se stesso, determinando un loop infinito. " } , { ER_CANNOT_MIX_XERCESDOM , "Impossibile unire input non Xerces-DOM con output Xerces-DOM." } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "In ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Sono state rilevate più maschere denominate: {0}" } , { ER_INVALID_KEY_CALL , "Chiamata funzione non valida: le chiamate key() ricorsive non sono consentite " } , { ER_REFERENCING_ITSELF , "La variabile {0} sta direttamente o indirettamente facendo riferimento a se stessa." } , { ER_ILLEGAL_DOMSOURCE_INPUT , "Il nodo di input non può essere nullo per DOMSource per newTemplates." } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "File di classe non trovato per l'opzione {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Elemento richiesto non trovato: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream non può essere nullo" } , { ER_URI_CANNOT_BE_NULL , "URI non può essere nullo" } , { ER_FILE_CANNOT_BE_NULL , "File non può essere nullo" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource non può essere nullo" } , { ER_CANNOT_INIT_BSFMGR , "Impossibile inizializzare BSF Manager" } , { ER_CANNOT_CMPL_EXTENSN , "Impossibile compilare l'estensione" } , { ER_CANNOT_CREATE_EXTENSN , "Impossibile creare l''estensione: {0} a causa di: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "La chiamata metodo istanza al metodo {0} richiede un'istanza Object come primo argomento" } , { ER_INVALID_ELEMENT_NAME , "Specificato nome elemento non valido {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Il metodo nome elemento deve essere statico {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Funzione estensione {0} : {1} sconosciuta " } , { ER_MORE_MATCH_CONSTRUCTOR , "E'' stata trovata più di una corrispondenza migliore per il costruttore per {0}" } , { ER_MORE_MATCH_METHOD , "E'' stata trovata più di una corrispondenza migliore per il metodo {0}" } , { ER_MORE_MATCH_ELEMENT , "E'' stata trovata più di una corrispondenza migliore per il metodo elemento {0}" } , { ER_INVALID_CONTEXT_PASSED , "Specificato contesto non valido per valutare {0}" } , { ER_POOL_EXISTS , "Pool già esistente" } , { ER_NO_DRIVER_NAME , "Non è stato specificato alcun Nome driver" } , { ER_NO_URL , "Non è stata specificata alcuna URL" } , { ER_POOL_SIZE_LESSTHAN_ONE , "La dimensione del pool è inferiore a uno." } , { ER_INVALID_DRIVER , "Specificato nome driver non valido." } , { ER_NO_STYLESHEETROOT , "Impossibile trovare la root del foglio di stile." } , { ER_ILLEGAL_XMLSPACE_VALUE , "Valore non valido per xml:space" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode non riuscito" } , { ER_RESOURCE_COULD_NOT_LOAD , "Impossibile caricare la risorsa [ {0} ]: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Dimensione buffer <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Errore sconosciuto durante la chiamata all'estensione" } , { ER_NO_NAMESPACE_DECL , "Il prefisso {0} non ha una dichiarazione namaspace corrispondente" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Contenuto elemento non consentito per lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Il foglio di stile ha indirizzato l'interruzione" } , { ER_ONE_OR_TWO , "1 o 2" } , { ER_TWO_OR_THREE , "2 o 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Impossibile caricare {0} (controllare CLASSPATH), verranno utilizzati i valori predefiniti." } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Impossibile inizializzare le maschere predefinite" } , { ER_RESULT_NULL , "Il risultato non può essere nullo" } , { ER_RESULT_COULD_NOT_BE_SET , "Impossibile impostare il risultato" } , { ER_NO_OUTPUT_SPECIFIED , "Non è stato specificato alcun output" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Impossibile trasformare in un risultato di tipo {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Impossibile trasformare un''origine di tipo {0}" } , { ER_NULL_CONTENT_HANDLER , "Handler contenuto nullo" } , { ER_NULL_ERROR_HANDLER , "Handler errori nullo" } , { ER_CANNOT_CALL_PARSE , "non è possibile richiamare l'analisi se ContentHandler non è stato impostato" } , { ER_NO_PARENT_FOR_FILTER , "Nessun principale per il filtro" } , { ER_NO_STYLESHEET_IN_MEDIA , "Nessun foglio di stile trovato in: {0}, supporto= {1}" } , { ER_NO_STYLESHEET_PI , "Nessun PI xml-stylesheet trovato in: {0}" } , { ER_NOT_SUPPORTED , "Non supportato: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Il valore della proprietà {0} deve essere una istanza booleana" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "Impossibile richiamare lo script esterno in {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "Risorsa [ {0} ] non trovata.\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Proprietà Output non riconosciuta: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Creazione dell'istanza ElemLiteralResult non riuscita" } , { ER_VALUE_SHOULD_BE_NUMBER , "Il valore di {0} deve contenere un numero analizzabile " } , { ER_VALUE_SHOULD_EQUAL , "Il valore di {0} deve essere uguale a yes o no" } , { ER_FAILED_CALLING_METHOD , "Chiamata al metodo {0} non riuscita" } , { ER_FAILED_CREATING_ELEMTMPL , "Creazione dell'istanza ElemTemplateElement non riuscita" } , { ER_CHARS_NOT_ALLOWED , "I caratteri non sono consentiti in questo punto del documento" } , { ER_ATTR_NOT_ALLOWED , "L''attributo \"{0}\" non è consentito nell''elemento {1}." } , { ER_BAD_VALUE , "{0} valore errato {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "Valore attributo {0} non trovato " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "Valore attributo {0} non riconosciuto " } , { ER_NULL_URI_NAMESPACE , "E' stato effettuato un tentativo di generare un prefisso spazio nome con un URI nullo" } , { ER_NUMBER_TOO_BIG , "Si sta effettuando un tentativo di formattare un numero superiore all'intero Long più grande" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Impossibile trovare la classe driver SAX1 {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "La classe driver SAX1 {0} è stata trovata ma non è stato possibile caricarla" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "La classe driver SAX1 {0} è stata caricata ma non è stato possibile instanziarla" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "La classe driver SAX1 {0} non implementa org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "Proprietà di sistema org.xml.sax.parser non specificata" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "L'argomento Parser non può essere nullo" } , { ER_FEATURE , "Funzione: {0}" } , { ER_PROPERTY , "Proprietà: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Resolver entità nullo" } , { ER_NULL_DTD_HANDLER , "Handler DTD nullo" } , { ER_NO_DRIVER_NAME_SPECIFIED , "Non è stato specificato alcun nome driver." } , { ER_NO_URL_SPECIFIED , "Non è stato specificato alcun URL." } , { ER_POOLSIZE_LESS_THAN_ONE , "La dimensione del pool è inferiore a 1." } , { ER_INVALID_DRIVER_NAME , "Specificato nome driver non valido." } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Errore di programmazione. expr senza ElemTemplateElement principale." } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Asserzione di programma in RedundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0}non è consentito in questa posizione in stylesheet" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Testo Non-whitespace non consentito in questa posizione in stylesheet" } , { INVALID_TCHAR , "Valore non valido: {1} utilizzato per l''attributo CHAR: {0}. Un attributo di tipo CHAR deve essere di 1 solo carattere. " } , { INVALID_QNAME , "Valore non valido: {1} utilizzato per l''attributo QNAME: {0}" } , { INVALID_ENUM , "Valore non valido: {1} utilizzato per l''attributo ENUM: {0}.  I valori validi sono: {2}." } , { INVALID_NMTOKEN , "Valore non valido: {1} utilizzato per l''attributo NMTOKEN: {0} " } , { INVALID_NCNAME , "Valore non valido: {1} utilizzato per l''attributo NCNAME: {0} " } , { INVALID_BOOLEAN , "Valore non valido: {1} utilizzato per l''attributo boolean: {0} " } , { INVALID_NUMBER , "Valore non valido: {1} utilizzato per l''attributo number: {0} " } , { ER_ARG_LITERAL , "L''argomento di {0} nel modello di corrispondenza deve essere letterale. " } , { ER_DUPLICATE_GLOBAL_VAR , "Dichiarazione di variabile globale duplicata. " } , { ER_DUPLICATE_VAR , "Dichiarazione di variabile duplicata. " } , { ER_TEMPLATE_NAME_MATCH , "xsl:template deve avere un attributo name oppure match (o entrambi)" } , { ER_INVALID_PREFIX , "Prefisso in exclude-result-prefixes non valido: {0}" } , { ER_NO_ATTRIB_SET , "attribute-set denominato {0} non esiste " } , { WG_FOUND_CURLYBRACE , "Rilevato '}' senza una maschera attributo aperta." } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Attenzione: l'attributo count non corrisponde ad un predecessore in xsl:number! Destinazione = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Sintassi obsoleta: Il nome dell'attributo 'expr' è stato modificato in 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan non gestisce ancora il nome locale nella funzione formato-numero." } , { WG_LOCALE_NOT_FOUND , "Attenzione: Impossibile trovare la locale per xml:lang={0}" } , { WG_CANNOT_MAKE_URL_FROM , "Impossibile ricavare l''URL da: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Impossibile caricare il documento richiesto: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Impossibile trovare Collator per <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Sintassi obsoleta: l'istruzione functions deve utilizzare un url di {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "codifica non supportata: {0}, viene utilizzato UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "codifica non supportata: {0}, viene utilizzato Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Sono stati rilevati conflitti di specificità: {0} Verrà utilizzato l'ultimo trovato nel foglio di stile. " } , { WG_PARSING_AND_PREPARING , "========= Analisi e preparazione {0} ==========" } , { WG_ATTR_TEMPLATE , "Maschera attributo, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Conflitto di corrispondenza tra xsl:strip-space e xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan non può ancora gestire l''attributo {0}." } , { WG_NO_DECIMALFORMAT_DECLARATION , "Nessuna dichiarazione trovata per il formato decimale: {0}" } , { WG_OLD_XSLT_NS , "XSLT Namespace mancante o non corretto. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "E' consentita una sola dichiarazione xsl:decimal-format predefinita. " } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "I nomi xsl:decimal-format devono essere univoci. Il nome \"{0}\" è stato duplicato." } , { WG_ILLEGAL_ATTRIBUTE , "{0} ha un attributo non valido: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Impossibile risolvere il prefisso dello spazio nome: {0}. Il nodo verrà ignorato." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet richiede un attributo 'version'. " } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Nome attributo non valido: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Valore non valido utilizzato per l''attributo {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "Il nodeset che risulta dal secondo argomento della funzione documento è vuoto. Restituisce un nodeset vuoto. " } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "Il valore dell'attributo 'name' del nome xsl:processing-instruction non deve essere 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "Il valore dell'attributo 'name' di xsl:processing-instruction deve essere un NCName valido: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Impossibile aggiungere l''attributo {0} dopo i nodi secondari o prima che sia prodotto un elemento. L''attributo verrà ignorato. " } , { "ui_language" , "it" } , { "help_language" , "it" } , { "language" , "it" } , { "BAD_CODE" , "Il parametro per createMessage fuori limite" } , { "FORMAT_FAILED" , "Rilevata eccezione durante la chiamata messageFormat" } , { "version" , ">>>>>>> Versione Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "sì" } , { "line" , "Riga #" } , { "column" , "Colonna #" } , { "xsldone" , "XSLProcessor: eseguito" } , { "xslProc_option" , "Opzioni classe Process riga comandi Xalan-J: " } , { "xslProc_option" , "Opzioni classe Process riga comandi Xalan-J:" } , { "xslProc_invalid_xsltc_option" , "Opzione {0} non supportata in modalità. " } , { "xslProc_invalid_xalan_option" , "L''opzione {0} può essere utilizzata solo con -XSLTC." } , { "xslProc_no_input" , "Errore: Nessun foglio di stile o xml di immissione specificato. Eseguire questo comando senza opzioni per istruzioni sull'utilizzo. " } , { "xslProc_common_options" , "-Opzioni comuni-" } , { "xslProc_xalan_options" , "-Opzioni per Xalan-" } , { "xslProc_xsltc_options" , "-Opzioni per XSLTC-" } , { "xslProc_return_to_continue" , "(premere <invio> per continuare)" } , { "optionXSLTC" , "   [-XSLTC (utilizza XSLTC per la trasformazioni)]" } , { "optionIN" , "   [-IN inputXMLURL]" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER nome classe completo del collegamento parser]" } , { "optionE" , "   [-E (non espandere i riferimenti entità)]" } , { "optionV" , "   [-E (non espandere i riferimenti entità)]" } , { "optionQC" , "   [-QC (Non visualizzare avvertenze conflitti modelli)]" } , { "optionQ" , "   [-Q  (Modalità non interattiva)]" } , { "optionLF" , "   [-LF (Utilizza il caricamento riga solo sull'output {valore predefinito: CR/LF})]" } , { "optionCR" , "   [-CR (Utilizza il ritorno a capo solo sull'output {valore predefinito: CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (specifica quali caratteri saltare {valore predefinito: <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Controlla il numero dei rientri {valore predefinito: 0})]" } , { "optionTT" , "   [-TT (Traccia le maschere quando vengono richiamate.)]" } , { "optionTG" , "   [-TG (Traccia ogni evento di generazione.)]" } , { "optionTS" , "   [-TS (Traccia ogni evento di selezione.)]" } , { "optionTTC" , "   [-TTC (Traccia il secondario della maschera quando viene elaborato.)]" } , { "optionTCLASS" , "   [-TCLASS (classe TraceListener per le estensioni di traccia.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Imposta se eseguire la convalida.  Il valore predefinito per la convalida è disattivato.)]" } , { "optionEDUMP" , "   [-EDUMP {nome file facoltativo} (Eseguire stackdump in caso di errori.)]" } , { "optionXML" , "   [-XML (Utilizza la formattazione XML e aggiunge intestazione XML.)]" } , { "optionTEXT" , "   [-TEXT (Utilizza la formattazione Testo semplice.)]" } , { "optionHTML" , "   [-HTML (Utilizza la formattazione HTML.)]" } , { "optionPARAM" , "   [-PARAM nome espressione (imposta un parametro del foglio di stile)]" } , { "noParsermsg1" , "Elaborazione XSL non riuscita." } , { "noParsermsg2" , "** Impossibile trovare il parser **" } , { "noParsermsg3" , "Controllare il classpath." } , { "noParsermsg4" , "Se non si possiede IBM XML Parser per Java, è possibile scaricarlo da" } , { "noParsermsg5" , "IBM AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER nome classe completo (URIResolver da utilizzare per risolvere gli URI)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER nome classe completo (EntityResolver da utilizzare per risolvere le entità)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER nome classe completo (ContentHandler da utilizzare per serializzare l'output)]" } , { "optionLINENUMBERS" , "   [-L utilizza i numeri riga per il documento di origine]" } , { "optionMEDIA" , "   [-MEDIA mediaType (utilizza l'attributo media per individuare il foglio di stile associato ad un documento.)]" } , { "optionFLAVOR" , "   [-FLAVOR flavorName (Utilizza in modo esplicito s2s=SAX oppure d2d=DOM per eseguire la trasformazione.)] " } , { "optionDIAG" , "   [-DIAG (Visualizza il tempo impiegato in millisecondi per la trasformazione.)]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL (richiede la costruzione DTM incrementale impostando http://xml.apache.org/xalan/features/incremental true.)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE (non richiede alcuna elaborazione di ottimizzazione del foglio di stile impostando http://xml.apache.org/xalan/features/optimize false.)]" } , { "optionRL" , "   [-RL recursionlimit (limite numerico asserzioni nella profondità ricorsiva del foglio di stile.)]" } , { "optionXO" , "   [-XO [transletName] (assegna il nome al translet generato)]" } , { "optionXD" , "   [-XD destinationDirectory (specifica una directory di destinazione per il translet)]" } , { "optionXJ" , "   [-XJ jarfile (raggruppa la classi translet in un file jar di nome <jarfile>)]" } , { "optionXP" , "   [-XP package (specifica un prefisso di nome pacchetto per tutte le classi translet generate)]" } , { "optionXN" , "   [-XN (abilita l'allineamento della maschera)]" } , { "optionXX" , "   [-XX (attiva ulteriori emissioni di messaggi di debug)]" } , { "optionXT" , "   [-XT (utilizza il translet per la trasformazione, se possibile)]" } , { "diagTiming" , " --------- La trasformazione di {0} utilizzando {1} ha impiegato {2} ms" } , { "recursionTooDeep" , "Nidificazione della maschera troppo elevata. nesting = {0}, maschera {1} {2}" } , { "nameIs" , "il nome è " } , { "matchPatternIs" , "il modello di corrispondenza è " } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Errore: " ; public static final String WARNING_HEADER = "Avvertenza: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MODELLO " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "it" , "IT" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xalan . transformer ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Properties ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamSource ; import javax . xml . transform . stream . StreamResult ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . OutputProperties ; import org . apache . xml . serializer . Serializer ; import org . apache . xml . serializer . SerializerFactory ; import org . apache . xml . serializer . Method ; import org . apache . xml . utils . DOMBuilder ; import org . apache . xml . utils . TreeWalker ; import org . apache . xml . utils . XMLReaderManager ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; public class TransformerIdentityImpl extends Transformer implements TransformerHandler , DeclHandler { public TransformerIdentityImpl ( ) { m_outputFormat = new OutputProperties ( Method . XML ) ; } public void setResult ( Result result ) throws IllegalArgumentException { if ( null == result ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_RESULT_NULL , null ) ) ; m_result = result ; } public void setSystemId ( String systemID ) { m_systemID = systemID ; } public String getSystemId ( ) { return m_systemID ; } public Transformer getTransformer ( ) { return this ; } private void createResultContentHandler ( Result outputTarget ) throws TransformerException { if ( outputTarget instanceof SAXResult ) { SAXResult saxResult = ( SAXResult ) outputTarget ; m_resultContentHandler = saxResult . getHandler ( ) ; m_resultLexicalHandler = saxResult . getLexicalHandler ( ) ; if ( m_resultContentHandler instanceof Serializer ) { m_serializer = ( Serializer ) m_resultContentHandler ; } } else if ( outputTarget instanceof DOMResult ) { DOMResult domResult = ( DOMResult ) outputTarget ; Node outputNode = domResult . getNode ( ) ; Document doc ; short type ; if ( null != outputNode ) { type = outputNode . getNodeType ( ) ; doc = ( Node . DOCUMENT_NODE == type ) ? ( Document ) outputNode : outputNode . getOwnerDocument ( ) ; } else { try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setNamespaceAware ( true ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; doc = db . newDocument ( ) ; } catch ( ParserConfigurationException pce ) { throw new TransformerException ( pce ) ; } outputNode = doc ; type = outputNode . getNodeType ( ) ; ( ( DOMResult ) outputTarget ) . setNode ( outputNode ) ; } m_resultContentHandler = ( Node . DOCUMENT_FRAGMENT_NODE == type ) ? new DOMBuilder ( doc , ( DocumentFragment ) outputNode ) : new DOMBuilder ( doc , outputNode ) ; m_resultLexicalHandler = ( LexicalHandler ) m_resultContentHandler ; } else if ( outputTarget instanceof StreamResult ) { StreamResult sresult = ( StreamResult ) outputTarget ; String method = m_outputFormat . getProperty ( OutputKeys . METHOD ) ; try { Serializer serializer = SerializerFactory . getSerializer ( m_outputFormat . getProperties ( ) ) ; m_serializer = serializer ; if ( null != sresult . getWriter ( ) ) serializer . setWriter ( sresult . getWriter ( ) ) ; else if ( null != sresult . getOutputStream ( ) ) serializer . setOutputStream ( sresult . getOutputStream ( ) ) ; else if ( null != sresult . getSystemId ( ) ) { String fileURL = sresult . getSystemId ( ) ; if ( fileURL . startsWith ( "file:///" ) ) { if ( fileURL . substring ( 8 ) . indexOf ( ":" ) > 0 ) fileURL = fileURL . substring ( 8 ) ; else fileURL = fileURL . substring ( 7 ) ; } m_outputStream = new java . io . FileOutputStream ( fileURL ) ; serializer . setOutputStream ( m_outputStream ) ; } else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_OUTPUT_SPECIFIED , null ) ) ; m_resultContentHandler = serializer . asContentHandler ( ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } } else { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , new Object [ ] { outputTarget . getClass ( ) . getName ( ) } ) ) ; } if ( m_resultContentHandler instanceof DTDHandler ) m_resultDTDHandler = ( DTDHandler ) m_resultContentHandler ; if ( m_resultContentHandler instanceof DeclHandler ) m_resultDeclHandler = ( DeclHandler ) m_resultContentHandler ; if ( m_resultContentHandler instanceof LexicalHandler ) m_resultLexicalHandler = ( LexicalHandler ) m_resultContentHandler ; } public void transform ( Source source , Result outputTarget ) throws TransformerException { createResultContentHandler ( outputTarget ) ; if ( ( source instanceof StreamSource && source . getSystemId ( ) == null && ( ( StreamSource ) source ) . getInputStream ( ) == null && ( ( StreamSource ) source ) . getReader ( ) == null ) || ( source instanceof SAXSource && ( ( SAXSource ) source ) . getInputSource ( ) == null && ( ( SAXSource ) source ) . getXMLReader ( ) == null ) || ( source instanceof DOMSource && ( ( DOMSource ) source ) . getNode ( ) == null ) ) { try { DocumentBuilderFactory builderF = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = builderF . newDocumentBuilder ( ) ; String systemID = source . getSystemId ( ) ; source = new DOMSource ( builder . newDocument ( ) ) ; if ( systemID != null ) { source . setSystemId ( systemID ) ; } } catch ( ParserConfigurationException e ) { throw new TransformerException ( e . getMessage ( ) ) ; } } try { if ( source instanceof DOMSource ) { DOMSource dsource = ( DOMSource ) source ; m_systemID = dsource . getSystemId ( ) ; Node dNode = dsource . getNode ( ) ; if ( null != dNode ) { try { if ( dNode . getNodeType ( ) == Node . ATTRIBUTE_NODE ) this . startDocument ( ) ; try { if ( dNode . getNodeType ( ) == Node . ATTRIBUTE_NODE ) { String data = dNode . getNodeValue ( ) ; char [ ] chars = data . toCharArray ( ) ; characters ( chars , 0 , chars . length ) ; } else { TreeWalker walker = new TreeWalker ( this , new org . apache . xml . utils . DOM2Helper ( ) , m_systemID ) ; walker . traverse ( dNode ) ; } } finally { if ( dNode . getNodeType ( ) == Node . ATTRIBUTE_NODE ) this . endDocument ( ) ; } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } return ; } else { String messageStr = XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_DOMSOURCE_INPUT , null ) ; throw new IllegalArgumentException ( messageStr ) ; } } InputSource xmlSource = SAXSource . sourceToInputSource ( source ) ; if ( null == xmlSource ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_CANNOT_TRANSFORM_SOURCE_TYPE , new Object [ ] { source . getClass ( ) . getName ( ) } ) ) ; } if ( null != xmlSource . getSystemId ( ) ) m_systemID = xmlSource . getSystemId ( ) ; XMLReader reader = null ; boolean managedReader = false ; try { if ( source instanceof SAXSource ) { reader = ( ( SAXSource ) source ) . getXMLReader ( ) ; } if ( null == reader ) { try { reader = XMLReaderManager . getInstance ( ) . getXMLReader ( ) ; managedReader = true ; } catch ( SAXException se ) { throw new TransformerException ( se ) ; } } else { try { reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } } ContentHandler inputHandler = this ; reader . setContentHandler ( inputHandler ) ; if ( inputHandler instanceof org . xml . sax . DTDHandler ) reader . setDTDHandler ( ( org . xml . sax . DTDHandler ) inputHandler ) ; try { if ( inputHandler instanceof org . xml . sax . ext . LexicalHandler ) reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , inputHandler ) ; if ( inputHandler instanceof org . xml . sax . ext . DeclHandler ) reader . setProperty ( "http://xml.org/sax/properties/declaration-handler" , inputHandler ) ; } catch ( org . xml . sax . SAXException se ) { } try { if ( inputHandler instanceof org . xml . sax . ext . LexicalHandler ) reader . setProperty ( "http://xml.org/sax/handlers/LexicalHandler" , inputHandler ) ; if ( inputHandler instanceof org . xml . sax . ext . DeclHandler ) reader . setProperty ( "http://xml.org/sax/handlers/DeclHandler" , inputHandler ) ; } catch ( org . xml . sax . SAXNotRecognizedException snre ) { } reader . parse ( xmlSource ) ; } catch ( org . apache . xml . utils . WrappedRuntimeException wre ) { Throwable throwable = wre . getException ( ) ; while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } throw new TransformerException ( wre . getException ( ) ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } finally { if ( managedReader ) { XMLReaderManager . getInstance ( ) . releaseXMLReader ( reader ) ; } } } finally { if ( null != m_outputStream ) { try { m_outputStream . close ( ) ; } catch ( IOException ioe ) { } m_outputStream = null ; } } } public void setParameter ( String name , Object value ) { if ( value == null ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_SET_PARAM_VALUE , new Object [ ] { name } ) ) ; } if ( null == m_params ) { m_params = new Hashtable ( ) ; } m_params . put ( name , value ) ; } public Object getParameter ( String name ) { if ( null == m_params ) return null ; return m_params . get ( name ) ; } public void clearParameters ( ) { if ( null == m_params ) return ; m_params . clear ( ) ; } public void setURIResolver ( URIResolver resolver ) { m_URIResolver = resolver ; } public URIResolver getURIResolver ( ) { return m_URIResolver ; } public void setOutputProperties ( Properties oformat ) throws IllegalArgumentException { if ( null != oformat ) { String method = ( String ) oformat . get ( OutputKeys . METHOD ) ; if ( null != method ) m_outputFormat = new OutputProperties ( method ) ; else m_outputFormat = new OutputProperties ( ) ; m_outputFormat . copyFrom ( oformat ) ; } else { m_outputFormat = null ; } } public Properties getOutputProperties ( ) { return ( Properties ) m_outputFormat . getProperties ( ) . clone ( ) ; } public void setOutputProperty ( String name , String value ) throws IllegalArgumentException { if ( ! m_outputFormat . isLegalPropertyKey ( name ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; m_outputFormat . setProperty ( name , value ) ; } public String getOutputProperty ( String name ) throws IllegalArgumentException { String value = null ; OutputProperties props = m_outputFormat ; value = props . getProperty ( name ) ; if ( null == value ) { if ( ! props . isLegalPropertyKey ( name ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; } return value ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( listener == null ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NULL_ERROR_HANDLER , null ) ) ; else m_errorListener = listener ; } public ErrorListener getErrorListener ( ) { return m_errorListener ; } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { if ( null != m_resultDTDHandler ) m_resultDTDHandler . notationDecl ( name , publicId , systemId ) ; } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( null != m_resultDTDHandler ) m_resultDTDHandler . unparsedEntityDecl ( name , publicId , systemId , notationName ) ; } public void setDocumentLocator ( Locator locator ) { try { if ( null == m_resultContentHandler ) createResultContentHandler ( m_result ) ; } catch ( TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } m_resultContentHandler . setDocumentLocator ( locator ) ; } public void startDocument ( ) throws SAXException { try { if ( null == m_resultContentHandler ) createResultContentHandler ( m_result ) ; } catch ( TransformerException te ) { throw new SAXException ( te . getMessage ( ) , te ) ; } m_flushedStartDoc = false ; m_foundFirstElement = false ; } boolean m_flushedStartDoc = false ; protected final void flushStartDoc ( ) throws SAXException { if ( ! m_flushedStartDoc ) { if ( m_resultContentHandler == null ) { try { createResultContentHandler ( m_result ) ; } catch ( TransformerException te ) { throw new SAXException ( te ) ; } } m_resultContentHandler . startDocument ( ) ; m_flushedStartDoc = true ; } } public void endDocument ( ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . endDocument ( ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . startPrefixMapping ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . endPrefixMapping ( prefix ) ; } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( ! m_foundFirstElement && null != m_serializer ) { m_foundFirstElement = true ; Serializer newSerializer ; try { newSerializer = SerializerSwitcher . switchSerializerIfHTML ( uri , localName , m_outputFormat . getProperties ( ) , m_serializer ) ; } catch ( TransformerException te ) { throw new SAXException ( te ) ; } if ( newSerializer != m_serializer ) { try { m_resultContentHandler = newSerializer . asContentHandler ( ) ; } catch ( IOException ioe ) { throw new SAXException ( ioe ) ; } if ( m_resultContentHandler instanceof DTDHandler ) m_resultDTDHandler = ( DTDHandler ) m_resultContentHandler ; if ( m_resultContentHandler instanceof LexicalHandler ) m_resultLexicalHandler = ( LexicalHandler ) m_resultContentHandler ; m_serializer = newSerializer ; } } flushStartDoc ( ) ; m_resultContentHandler . startElement ( uri , localName , qName , attributes ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { m_resultContentHandler . endElement ( uri , localName , qName ) ; } public void characters ( char ch [ ] , int start , int length ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . characters ( ch , start , length ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { m_resultContentHandler . ignorableWhitespace ( ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . processingInstruction ( target , data ) ; } public void skippedEntity ( String name ) throws SAXException { flushStartDoc ( ) ; m_resultContentHandler . skippedEntity ( name ) ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { flushStartDoc ( ) ; if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . startDTD ( name , publicId , systemId ) ; } public void endDTD ( ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . endDTD ( ) ; } public void startEntity ( String name ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . startEntity ( name ) ; } public void endEntity ( String name ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . endEntity ( name ) ; } public void startCDATA ( ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . startCDATA ( ) ; } public void endCDATA ( ) throws SAXException { if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . endCDATA ( ) ; } public void comment ( char ch [ ] , int start , int length ) throws SAXException { flushStartDoc ( ) ; if ( null != m_resultLexicalHandler ) m_resultLexicalHandler . comment ( ch , start , length ) ; } public void elementDecl ( String name , String model ) throws SAXException { if ( null != m_resultDeclHandler ) m_resultDeclHandler . elementDecl ( name , model ) ; } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( null != m_resultDeclHandler ) m_resultDeclHandler . attributeDecl ( eName , aName , type , valueDefault , value ) ; } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( null != m_resultDeclHandler ) m_resultDeclHandler . internalEntityDecl ( name , value ) ; } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { if ( null != m_resultDeclHandler ) m_resultDeclHandler . externalEntityDecl ( name , publicId , systemId ) ; } private java . io . FileOutputStream m_outputStream = null ; private ContentHandler m_resultContentHandler ; private LexicalHandler m_resultLexicalHandler ; private DTDHandler m_resultDTDHandler ; private DeclHandler m_resultDeclHandler ; private Serializer m_serializer ; private Result m_result ; private String m_systemID ; private Hashtable m_params ; private ErrorListener m_errorListener = new org . apache . xml . utils . DefaultErrorHandler ( ) ; URIResolver m_URIResolver ; private OutputProperties m_outputFormat ; boolean m_foundFirstElement ; } 	1	['43', '2', '0', '13', '143', '573', '1', '12', '41', '0.755102041', '1173', '0.785714286', '2', '0.236363636', '0.153100775', '0', '0', '25.95348837', '3', '1.0698', '5']
package org . apache . xml . utils ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . w3c . dom . Attr ; import org . w3c . dom . DOMImplementation ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . Entity ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . Text ; public class DOMHelper { public static Document createDocument ( ) { try { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; dfactory . setNamespaceAware ( true ) ; dfactory . setValidating ( true ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; Document outNode = docBuilder . newDocument ( ) ; return outNode ; } catch ( ParserConfigurationException pce ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CREATEDOCUMENT_NOT_SUPPORTED , null ) ) ; } } public boolean shouldStripSourceNode ( Node textNode ) throws javax . xml . transform . TransformerException { return false ; } public String getUniqueID ( Node node ) { return "N" + Integer . toHexString ( node . hashCode ( ) ) . toUpperCase ( ) ; } public static boolean isNodeAfter ( Node node1 , Node node2 ) { if ( node1 == node2 || isNodeTheSame ( node1 , node2 ) ) return true ; boolean isNodeAfter = true ; Node parent1 = getParentOfNode ( node1 ) ; Node parent2 = getParentOfNode ( node2 ) ; if ( parent1 == parent2 || isNodeTheSame ( parent1 , parent2 ) ) { if ( null != parent1 ) isNodeAfter = isNodeAfterSibling ( parent1 , node1 , node2 ) ; else { } } else { int nParents1 = 2 , nParents2 = 2 ; while ( parent1 != null ) { nParents1 ++ ; parent1 = getParentOfNode ( parent1 ) ; } while ( parent2 != null ) { nParents2 ++ ; parent2 = getParentOfNode ( parent2 ) ; } Node startNode1 = node1 , startNode2 = node2 ; if ( nParents1 < nParents2 ) { int adjust = nParents2 - nParents1 ; for ( int i = 0 ; i < adjust ; i ++ ) { startNode2 = getParentOfNode ( startNode2 ) ; } } else if ( nParents1 > nParents2 ) { int adjust = nParents1 - nParents2 ; for ( int i = 0 ; i < adjust ; i ++ ) { startNode1 = getParentOfNode ( startNode1 ) ; } } Node prevChild1 = null , prevChild2 = null ; while ( null != startNode1 ) { if ( startNode1 == startNode2 || isNodeTheSame ( startNode1 , startNode2 ) ) { if ( null == prevChild1 ) { isNodeAfter = ( nParents1 < nParents2 ) ? true : false ; break ; } else { isNodeAfter = isNodeAfterSibling ( startNode1 , prevChild1 , prevChild2 ) ; break ; } } prevChild1 = startNode1 ; startNode1 = getParentOfNode ( startNode1 ) ; prevChild2 = startNode2 ; startNode2 = getParentOfNode ( startNode2 ) ; } } return isNodeAfter ; } public static boolean isNodeTheSame ( Node node1 , Node node2 ) { if ( node1 instanceof DTMNodeProxy && node2 instanceof DTMNodeProxy ) return ( ( DTMNodeProxy ) node1 ) . equals ( ( DTMNodeProxy ) node2 ) ; else return ( node1 == node2 ) ; } private static boolean isNodeAfterSibling ( Node parent , Node child1 , Node child2 ) { boolean isNodeAfterSibling = false ; short child1type = child1 . getNodeType ( ) ; short child2type = child2 . getNodeType ( ) ; if ( ( Node . ATTRIBUTE_NODE != child1type ) && ( Node . ATTRIBUTE_NODE == child2type ) ) { isNodeAfterSibling = false ; } else if ( ( Node . ATTRIBUTE_NODE == child1type ) && ( Node . ATTRIBUTE_NODE != child2type ) ) { isNodeAfterSibling = true ; } else if ( Node . ATTRIBUTE_NODE == child1type ) { NamedNodeMap children = parent . getAttributes ( ) ; int nNodes = children . getLength ( ) ; boolean found1 = false , found2 = false ; for ( int i = 0 ; i < nNodes ; i ++ ) { Node child = children . item ( i ) ; if ( child1 == child || isNodeTheSame ( child1 , child ) ) { if ( found2 ) { isNodeAfterSibling = false ; break ; } found1 = true ; } else if ( child2 == child || isNodeTheSame ( child2 , child ) ) { if ( found1 ) { isNodeAfterSibling = true ; break ; } found2 = true ; } } } else { Node child = parent . getFirstChild ( ) ; boolean found1 = false , found2 = false ; while ( null != child ) { if ( child1 == child || isNodeTheSame ( child1 , child ) ) { if ( found2 ) { isNodeAfterSibling = false ; break ; } found1 = true ; } else if ( child2 == child || isNodeTheSame ( child2 , child ) ) { if ( found1 ) { isNodeAfterSibling = true ; break ; } found2 = true ; } child = child . getNextSibling ( ) ; } } return isNodeAfterSibling ; } public short getLevel ( Node n ) { short level = 1 ; while ( null != ( n = getParentOfNode ( n ) ) ) { level ++ ; } return level ; } public String getNamespaceForPrefix ( String prefix , Element namespaceContext ) { int type ; Node parent = namespaceContext ; String namespace = null ; if ( prefix . equals ( "xml" ) ) { namespace = QName . S_XMLNAMESPACEURI ; } else if ( prefix . equals ( "xmlns" ) ) { namespace = "http://www.w3.org/2000/xmlns/" ; } else { String declname = ( prefix == "" ) ? "xmlns" : "xmlns:" + prefix ; while ( ( null != parent ) && ( null == namespace ) && ( ( ( type = parent . getNodeType ( ) ) == Node . ELEMENT_NODE ) || ( type == Node . ENTITY_REFERENCE_NODE ) ) ) { if ( type == Node . ELEMENT_NODE ) { Attr attr = ( ( Element ) parent ) . getAttributeNode ( declname ) ; if ( attr != null ) { namespace = attr . getNodeValue ( ) ; break ; } } parent = getParentOfNode ( parent ) ; } } return namespace ; } Hashtable m_NSInfos = new Hashtable ( ) ; protected static final NSInfo m_NSInfoUnProcWithXMLNS = new NSInfo ( false , true ) ; protected static final NSInfo m_NSInfoUnProcWithoutXMLNS = new NSInfo ( false , false ) ; protected static final NSInfo m_NSInfoUnProcNoAncestorXMLNS = new NSInfo ( false , false , NSInfo . ANCESTORNOXMLNS ) ; protected static final NSInfo m_NSInfoNullWithXMLNS = new NSInfo ( true , true ) ; protected static final NSInfo m_NSInfoNullWithoutXMLNS = new NSInfo ( true , false ) ; protected static final NSInfo m_NSInfoNullNoAncestorXMLNS = new NSInfo ( true , false , NSInfo . ANCESTORNOXMLNS ) ; protected Vector m_candidateNoAncestorXMLNS = new Vector ( ) ; public String getNamespaceOfNode ( Node n ) { String namespaceOfPrefix ; boolean hasProcessedNS ; NSInfo nsInfo ; short ntype = n . getNodeType ( ) ; if ( Node . ATTRIBUTE_NODE != ntype ) { Object nsObj = m_NSInfos . get ( n ) ; nsInfo = ( nsObj == null ) ? null : ( NSInfo ) nsObj ; hasProcessedNS = ( nsInfo == null ) ? false : nsInfo . m_hasProcessedNS ; } else { hasProcessedNS = false ; nsInfo = null ; } if ( hasProcessedNS ) { namespaceOfPrefix = nsInfo . m_namespace ; } else { namespaceOfPrefix = null ; String nodeName = n . getNodeName ( ) ; int indexOfNSSep = nodeName . indexOf ( ':' ) ; String prefix ; if ( Node . ATTRIBUTE_NODE == ntype ) { if ( indexOfNSSep > 0 ) { prefix = nodeName . substring ( 0 , indexOfNSSep ) ; } else { return namespaceOfPrefix ; } } else { prefix = ( indexOfNSSep >= 0 ) ? nodeName . substring ( 0 , indexOfNSSep ) : "" ; } boolean ancestorsHaveXMLNS = false ; boolean nHasXMLNS = false ; if ( prefix . equals ( "xml" ) ) { namespaceOfPrefix = QName . S_XMLNAMESPACEURI ; } else { int parentType ; Node parent = n ; while ( ( null != parent ) && ( null == namespaceOfPrefix ) ) { if ( ( null != nsInfo ) && ( nsInfo . m_ancestorHasXMLNSAttrs == NSInfo . ANCESTORNOXMLNS ) ) { break ; } parentType = parent . getNodeType ( ) ; if ( ( null == nsInfo ) || nsInfo . m_hasXMLNSAttrs ) { boolean elementHasXMLNS = false ; if ( parentType == Node . ELEMENT_NODE ) { NamedNodeMap nnm = parent . getAttributes ( ) ; for ( int i = 0 ; i < nnm . getLength ( ) ; i ++ ) { Node attr = nnm . item ( i ) ; String aname = attr . getNodeName ( ) ; if ( aname . charAt ( 0 ) == 'x' ) { boolean isPrefix = aname . startsWith ( "xmlns:" ) ; if ( aname . equals ( "xmlns" ) || isPrefix ) { if ( n == parent ) nHasXMLNS = true ; elementHasXMLNS = true ; ancestorsHaveXMLNS = true ; String p = isPrefix ? aname . substring ( 6 ) : "" ; if ( p . equals ( prefix ) ) { namespaceOfPrefix = attr . getNodeValue ( ) ; break ; } } } } } if ( ( Node . ATTRIBUTE_NODE != parentType ) && ( null == nsInfo ) && ( n != parent ) ) { nsInfo = elementHasXMLNS ? m_NSInfoUnProcWithXMLNS : m_NSInfoUnProcWithoutXMLNS ; m_NSInfos . put ( parent , nsInfo ) ; } } if ( Node . ATTRIBUTE_NODE == parentType ) { parent = getParentOfNode ( parent ) ; } else { m_candidateNoAncestorXMLNS . addElement ( parent ) ; m_candidateNoAncestorXMLNS . addElement ( nsInfo ) ; parent = parent . getParentNode ( ) ; } if ( null != parent ) { Object nsObj = m_NSInfos . get ( parent ) ; nsInfo = ( nsObj == null ) ? null : ( NSInfo ) nsObj ; } } int nCandidates = m_candidateNoAncestorXMLNS . size ( ) ; if ( nCandidates > 0 ) { if ( ( false == ancestorsHaveXMLNS ) && ( null == parent ) ) { for ( int i = 0 ; i < nCandidates ; i += 2 ) { Object candidateInfo = m_candidateNoAncestorXMLNS . elementAt ( i + 1 ) ; if ( candidateInfo == m_NSInfoUnProcWithoutXMLNS ) { m_NSInfos . put ( m_candidateNoAncestorXMLNS . elementAt ( i ) , m_NSInfoUnProcNoAncestorXMLNS ) ; } else if ( candidateInfo == m_NSInfoNullWithoutXMLNS ) { m_NSInfos . put ( m_candidateNoAncestorXMLNS . elementAt ( i ) , m_NSInfoNullNoAncestorXMLNS ) ; } } } m_candidateNoAncestorXMLNS . removeAllElements ( ) ; } } if ( Node . ATTRIBUTE_NODE != ntype ) { if ( null == namespaceOfPrefix ) { if ( ancestorsHaveXMLNS ) { if ( nHasXMLNS ) m_NSInfos . put ( n , m_NSInfoNullWithXMLNS ) ; else m_NSInfos . put ( n , m_NSInfoNullWithoutXMLNS ) ; } else { m_NSInfos . put ( n , m_NSInfoNullNoAncestorXMLNS ) ; } } else { m_NSInfos . put ( n , new NSInfo ( namespaceOfPrefix , nHasXMLNS ) ) ; } } } return namespaceOfPrefix ; } public String getLocalNameOfNode ( Node n ) { String qname = n . getNodeName ( ) ; int index = qname . indexOf ( ':' ) ; return ( index < 0 ) ? qname : qname . substring ( index + 1 ) ; } public String getExpandedElementName ( Element elem ) { String namespace = getNamespaceOfNode ( elem ) ; return ( null != namespace ) ? namespace + ":" + getLocalNameOfNode ( elem ) : getLocalNameOfNode ( elem ) ; } public String getExpandedAttributeName ( Attr attr ) { String namespace = getNamespaceOfNode ( attr ) ; return ( null != namespace ) ? namespace + ":" + getLocalNameOfNode ( attr ) : getLocalNameOfNode ( attr ) ; } public boolean isIgnorableWhitespace ( Text node ) { boolean isIgnorable = false ; return isIgnorable ; } public Node getRoot ( Node node ) { Node root = null ; while ( node != null ) { root = node ; node = getParentOfNode ( node ) ; } return root ; } public Node getRootNode ( Node n ) { int nt = n . getNodeType ( ) ; return ( ( Node . DOCUMENT_NODE == nt ) || ( Node . DOCUMENT_FRAGMENT_NODE == nt ) ) ? n : n . getOwnerDocument ( ) ; } public boolean isNamespaceNode ( Node n ) { if ( Node . ATTRIBUTE_NODE == n . getNodeType ( ) ) { String attrName = n . getNodeName ( ) ; return ( attrName . startsWith ( "xmlns:" ) || attrName . equals ( "xmlns" ) ) ; } return false ; } public static Node getParentOfNode ( Node node ) throws RuntimeException { Node parent ; short nodeType = node . getNodeType ( ) ; if ( Node . ATTRIBUTE_NODE == nodeType ) { Document doc = node . getOwnerDocument ( ) ; DOMImplementation impl = doc . getImplementation ( ) ; if ( impl != null && impl . hasFeature ( "Core" , "2.0" ) ) { parent = ( ( Attr ) node ) . getOwnerElement ( ) ; return parent ; } Element rootElem = doc . getDocumentElement ( ) ; if ( null == rootElem ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , null ) ) ; } parent = locateAttrParent ( rootElem , node ) ; } else { parent = node . getParentNode ( ) ; } return parent ; } public Element getElementByID ( String id , Document doc ) { return null ; } public String getUnparsedEntityURI ( String name , Document doc ) { String url = "" ; DocumentType doctype = doc . getDoctype ( ) ; if ( null != doctype ) { NamedNodeMap entities = doctype . getEntities ( ) ; if ( null == entities ) return url ; Entity entity = ( Entity ) entities . getNamedItem ( name ) ; if ( null == entity ) return url ; String notationName = entity . getNotationName ( ) ; if ( null != notationName ) { url = entity . getSystemId ( ) ; if ( null == url ) { url = entity . getPublicId ( ) ; } else { } } } return url ; } private static Node locateAttrParent ( Element elem , Node attr ) { Node parent = null ; Attr check = elem . getAttributeNode ( attr . getNodeName ( ) ) ; if ( check == attr ) parent = elem ; if ( null == parent ) { for ( Node node = elem . getFirstChild ( ) ; null != node ; node = node . getNextSibling ( ) ) { if ( Node . ELEMENT_NODE == node . getNodeType ( ) ) { parent = locateAttrParent ( ( Element ) node , attr ) ; if ( null != parent ) break ; } } } return parent ; } protected Document m_DOMFactory = null ; public void setDOMFactory ( Document domFactory ) { this . m_DOMFactory = domFactory ; } public Document getDOMFactory ( ) { if ( null == this . m_DOMFactory ) { this . m_DOMFactory = createDocument ( ) ; } return this . m_DOMFactory ; } public static String getNodeData ( Node node ) { FastStringBuffer buf = StringBufferPool . get ( ) ; String s ; try { getNodeData ( node , buf ) ; s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; } finally { StringBufferPool . free ( buf ) ; } return s ; } public static void getNodeData ( Node node , FastStringBuffer buf ) { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { getNodeData ( child , buf ) ; } } break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : buf . append ( node . getNodeValue ( ) ) ; break ; case Node . ATTRIBUTE_NODE : buf . append ( node . getNodeValue ( ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : break ; default : break ; } } } 	1	['26', '1', '1', '14', '86', '315', '9', '5', '23', '0.884444444', '1122', '0.888888889', '6', '0', '0.22', '0', '0', '41.80769231', '40', '5', '1']
package org . apache . xpath . compiler ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	1	['12', '1', '0', '3', '44', '64', '1', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '1']
package org . apache . xpath . domapi ; import org . w3c . dom . Attr ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . xpath . XPathNamespace ; public class XPathNamespaceImpl implements XPathNamespace { Node m_attributeNode = null ; public XPathNamespaceImpl ( Node node ) { m_attributeNode = node ; } public Element getOwnerElement ( ) { return ( ( Attr ) m_attributeNode ) . getOwnerElement ( ) ; } public String getNodeName ( ) { return "#namespace" ; } public String getNodeValue ( ) throws DOMException { return m_attributeNode . getNodeValue ( ) ; } public void setNodeValue ( String arg0 ) throws DOMException { } public short getNodeType ( ) { return XPathNamespace . XPATH_NAMESPACE_NODE ; } public Node getParentNode ( ) { return m_attributeNode . getParentNode ( ) ; } public NodeList getChildNodes ( ) { return m_attributeNode . getChildNodes ( ) ; } public Node getFirstChild ( ) { return m_attributeNode . getFirstChild ( ) ; } public Node getLastChild ( ) { return m_attributeNode . getLastChild ( ) ; } public Node getPreviousSibling ( ) { return m_attributeNode . getPreviousSibling ( ) ; } public Node getNextSibling ( ) { return m_attributeNode . getNextSibling ( ) ; } public NamedNodeMap getAttributes ( ) { return m_attributeNode . getAttributes ( ) ; } public Document getOwnerDocument ( ) { return m_attributeNode . getOwnerDocument ( ) ; } public Node insertBefore ( Node arg0 , Node arg1 ) throws DOMException { return null ; } public Node replaceChild ( Node arg0 , Node arg1 ) throws DOMException { return null ; } public Node removeChild ( Node arg0 ) throws DOMException { return null ; } public Node appendChild ( Node arg0 ) throws DOMException { return null ; } public boolean hasChildNodes ( ) { return false ; } public Node cloneNode ( boolean arg0 ) { throw new DOMException ( DOMException . NOT_SUPPORTED_ERR , null ) ; } public void normalize ( ) { m_attributeNode . normalize ( ) ; } public boolean isSupported ( String arg0 , String arg1 ) { return m_attributeNode . isSupported ( arg0 , arg1 ) ; } public String getNamespaceURI ( ) { return m_attributeNode . getNodeValue ( ) ; } public String getPrefix ( ) { return m_attributeNode . getPrefix ( ) ; } public void setPrefix ( String arg0 ) throws DOMException { } public String getLocalName ( ) { return m_attributeNode . getPrefix ( ) ; } public boolean hasAttributes ( ) { return m_attributeNode . hasAttributes ( ) ; } } 	1	['39', '1', '0', '1', '56', '469', '1', '0', '39', '0.578947368', '198', '0', '0', '0', '0.256410256', '0', '0', '4.051282051', '1', '0.9744', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . StringTokenizer ; import org . apache . bcel . generic . Type ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xml . utils . XMLChar ; public final class Util { private static char filesep ; static { String temp = System . getProperty ( "file.separator" , "/" ) ; filesep = temp . charAt ( 0 ) ; } public static String noExtName ( String name ) { final int index = name . lastIndexOf ( '.' ) ; return name . substring ( 0 , index >= 0 ? index : name . length ( ) ) ; } public static String baseName ( String name ) { int index = name . lastIndexOf ( '\\' ) ; if ( index < 0 ) { index = name . lastIndexOf ( '/' ) ; } if ( index >= 0 ) return name . substring ( index + 1 ) ; else { int lastColonIndex = name . lastIndexOf ( ':' ) ; if ( lastColonIndex > 0 ) return name . substring ( lastColonIndex + 1 ) ; else return name ; } } public static String pathName ( String name ) { int index = name . lastIndexOf ( '/' ) ; if ( index < 0 ) { index = name . lastIndexOf ( '\\' ) ; } return name . substring ( 0 , index + 1 ) ; } public static String toJavaName ( String name ) { if ( name . length ( ) > 0 ) { final StringBuffer result = new StringBuffer ( ) ; char ch = name . charAt ( 0 ) ; result . append ( Character . isJavaIdentifierStart ( ch ) ? ch : '_' ) ; final int n = name . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { ch = name . charAt ( i ) ; result . append ( Character . isJavaIdentifierPart ( ch ) ? ch : '_' ) ; } return result . toString ( ) ; } return name ; } public static Type getJCRefType ( String signature ) { return Type . getType ( signature ) ; } public static String internalName ( String cname ) { return cname . replace ( '.' , filesep ) ; } public static void println ( String s ) { System . out . println ( s ) ; } public static void println ( char ch ) { System . out . println ( ch ) ; } public static void TRACE1 ( ) { System . out . println ( "TRACE1" ) ; } public static void TRACE2 ( ) { System . out . println ( "TRACE2" ) ; } public static void TRACE3 ( ) { System . out . println ( "TRACE3" ) ; } public static String replace ( String base , char ch , String str ) { return ( base . indexOf ( ch ) < 0 ) ? base : replace ( base , String . valueOf ( ch ) , new String [ ] { str } ) ; } public static String replace ( String base , String delim , String [ ] str ) { final int len = base . length ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; i ++ ) { final char ch = base . charAt ( i ) ; final int k = delim . indexOf ( ch ) ; if ( k >= 0 ) { result . append ( str [ k ] ) ; } else { result . append ( ch ) ; } } return result . toString ( ) ; } public static String escape ( String input ) { return replace ( input , ".-/:" , new String [ ] { "$dot$" , "$dash$" , "$slash$" , "$colon$" } ) ; } public static String getLocalName ( String qname ) { final int index = qname . lastIndexOf ( ":" ) ; return ( index > 0 ) ? qname . substring ( index + 1 ) : qname ; } public static String getPrefix ( String qname ) { final int index = qname . lastIndexOf ( ":" ) ; return ( index > 0 ) ? qname . substring ( 0 , index ) : Constants . EMPTYSTRING ; } public static boolean isLiteral ( String str ) { final int length = str . length ( ) ; for ( int i = 0 ; i < length - 1 ; i ++ ) { if ( str . charAt ( i ) == '{' && str . charAt ( i + 1 ) != '{' ) { return false ; } } return true ; } public static boolean isValidQNames ( String str ) { if ( ( str != null ) && ( ! str . equals ( Constants . EMPTYSTRING ) ) ) { final StringTokenizer tokens = new StringTokenizer ( str ) ; while ( tokens . hasMoreTokens ( ) ) { if ( ! XMLChar . isValidQName ( tokens . nextToken ( ) ) ) { return false ; } } } return true ; } } 	1	['20', '1', '0', '47', '45', '188', '45', '2', '19', '0.947368421', '326', '1', '0', '0', '0.236842105', '0', '0', '15.25', '5', '1.95', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_zh_CN extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "“{0}”中存在运行时内部错误" } , { BasisLibrary . RUN_TIME_COPY_ERR , "在执行 <xsl:copy> 时发生运行时错误。" } , { BasisLibrary . DATA_CONVERSION_ERR , "从“{0}”到“{1}”的转换无效。" } , { BasisLibrary . EXTERNAL_FUNC_ERR , "XSLTC 不支持外部函数“{0}”。" } , { BasisLibrary . EQUALITY_EXPR_ERR , "等式表达式中的自变量类型未知。" } , { BasisLibrary . INVALID_ARGUMENT_ERR , "在对“{1}”的调用中的自变量类型“{0}”无效" } , { BasisLibrary . FORMAT_NUMBER_ERR , "试图使用模式“{1}”格式化数值“{0}”。" } , { BasisLibrary . ITERATOR_CLONE_ERR , "无法克隆迭代器“{0}”。" } , { BasisLibrary . AXIS_SUPPORT_ERR , "不支持轴“{0}”的迭代器。" } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "不支持输入的轴“{0}”的迭代器。" } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "属性“{0}”在元素外。" } , { BasisLibrary . STRAY_NAMESPACE_ERR , "名称空间说明“{0}”=“{1}”在元素外。" } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "没有说明名称空间前缀“{0}”。" } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "使用错误类型的源 DOM 创建了 DOMAdapter。" } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "正在使用的 SAX 解析器不处理 DTD 说明事件。" } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "正在使用的 SAX 解析器不支持 XML 名称空间。" } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "无法解析 URI 引用“{0}”。" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class FilteredAbsoluteLocationPath extends Expression { private Expression _path ; public FilteredAbsoluteLocationPath ( ) { _path = null ; } public FilteredAbsoluteLocationPath ( Expression path ) { _path = path ; if ( path != null ) { _path . setParent ( this ) ; } } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _path != null ) { _path . setParser ( parser ) ; } } public Expression getPath ( ) { return ( _path ) ; } public String toString ( ) { return "FilteredAbsoluteLocationPath(" + ( _path != null ? _path . toString ( ) : "null" ) + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _path != null ) { final Type ptype = _path . typeCheck ( stable ) ; if ( ptype instanceof NodeType ) { _path = new CastExpr ( _path , Type . NodeSet ) ; } } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _path != null ) { final int initDFI = cpg . addMethodref ( DUP_FILTERED_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( DUP_FILTERED_ITERATOR ) ) ) ; il . append ( DUP ) ; _path . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( initDFI ) ) ; } else { final int git = cpg . addInterfaceMethodref ( DOM_INTF , "getIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEINTERFACE ( git , 1 ) ) ; } } } 	1	['7', '3', '0', '18', '28', '0', '0', '18', '7', '0', '143', '1', '1', '0.934210526', '0.285714286', '2', '7', '19.28571429', '2', '1.1429', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xalan . transformer . TreeWalker2Result ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMTreeWalker ; import org . apache . xalan . serialize . SerializerUtils ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemCopyOf extends ElemTemplateElement { public XPath m_selectExpression = null ; public void setSelect ( XPath expr ) { m_selectExpression = expr ; } public XPath getSelect ( ) { return m_selectExpression ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; m_selectExpression . fixupVariables ( cstate . getVariableNames ( ) , cstate . getGlobalsSize ( ) ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_COPY_OF ; } public String getNodeName ( ) { return Constants . ELEMNAME_COPY_OF_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { XPathContext xctxt = transformer . getXPathContext ( ) ; int sourceNode = xctxt . getCurrentNode ( ) ; XObject value = m_selectExpression . execute ( xctxt , sourceNode , this ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , m_selectExpression , value ) ; SerializationHandler handler = transformer . getSerializationHandler ( ) ; if ( null != value ) { int type = value . getType ( ) ; String s ; switch ( type ) { case XObject . CLASS_BOOLEAN : case XObject . CLASS_NUMBER : case XObject . CLASS_STRING : s = value . str ( ) ; handler . characters ( s . toCharArray ( ) , 0 , s . length ( ) ) ; break ; case XObject . CLASS_NODESET : DTMIterator nl = value . iter ( ) ; DTMTreeWalker tw = new TreeWalker2Result ( transformer , handler ) ; int pos ; while ( DTM . NULL != ( pos = nl . nextNode ( ) ) ) { DTM dtm = xctxt . getDTMManager ( ) . getDTM ( pos ) ; short t = dtm . getNodeType ( pos ) ; if ( t == DTM . DOCUMENT_NODE ) { for ( int child = dtm . getFirstChild ( pos ) ; child != DTM . NULL ; child = dtm . getNextSibling ( child ) ) { tw . traverse ( child ) ; } } else if ( t == DTM . ATTRIBUTE_NODE ) { SerializerUtils . addAttribute ( handler , pos ) ; } else { tw . traverse ( pos ) ; } } break ; case XObject . CLASS_RTREEFRAG : SerializerUtils . outputResultTreeFragment ( handler , value , transformer . getXPathContext ( ) ) ; break ; default : s = value . str ( ) ; handler . characters ( s . toCharArray ( ) , 0 , s . length ( ) ) ; break ; } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; return null ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) m_selectExpression . getExpression ( ) . callVisitors ( m_selectExpression , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } } 	1	['9', '3', '0', '21', '45', '6', '1', '20', '8', '0.375', '217', '0', '1', '0.960784314', '0.238095238', '2', '6', '23', '2', '1', '2']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; public class Function2Args extends FunctionOneArg { Expression m_arg1 ; public Expression getArg1 ( ) { return m_arg1 ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_arg1 ) m_arg1 . fixupVariables ( vars , globalsSize ) ; } public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { if ( argNum == 0 ) super . setArg ( arg , argNum ) ; else if ( 1 == argNum ) { m_arg1 = arg ; arg . exprSetParent ( this ) ; } else reportWrongNumberArgs ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum != 2 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "two" , null ) ) ; } public boolean canTraverseOutsideSubtree ( ) { return super . canTraverseOutsideSubtree ( ) ? true : m_arg1 . canTraverseOutsideSubtree ( ) ; } class Arg1Owner implements ExpressionOwner { public Expression getExpression ( ) { return m_arg1 ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( Function2Args . this ) ; m_arg1 = exp ; } } public void callArgVisitors ( XPathVisitor visitor ) { super . callArgVisitors ( visitor ) ; if ( null != m_arg1 ) m_arg1 . callVisitors ( new Arg1Owner ( ) , visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( null != m_arg1 ) { if ( null == ( ( Function2Args ) expr ) . m_arg1 ) return false ; if ( ! m_arg1 . deepEquals ( ( ( Function2Args ) expr ) . m_arg1 ) ) return false ; } else if ( null != ( ( Function2Args ) expr ) . m_arg1 ) return false ; return true ; } } 	1	['9', '4', '7', '15', '23', '6', '8', '8', '8', '0.375', '123', '0', '1', '0.857142857', '0.355555556', '3', '9', '12.55555556', '6', '1.7778', '1']
package org . apache . xpath . objects ; public class XBoolean extends XObject { public static XBoolean S_TRUE = new XBooleanStatic ( true ) ; public static XBoolean S_FALSE = new XBooleanStatic ( false ) ; boolean m_val ; public XBoolean ( boolean b ) { super ( ) ; m_val = b ; } public XBoolean ( Boolean b ) { super ( ) ; m_val = b . booleanValue ( ) ; m_obj = b ; } public int getType ( ) { return CLASS_BOOLEAN ; } public String getTypeString ( ) { return "#BOOLEAN" ; } public double num ( ) { return m_val ? 1.0 : 0.0 ; } public boolean bool ( ) { return m_val ; } public String str ( ) { return m_val ? "true" : "false" ; } public Object object ( ) { if ( null == m_obj ) m_obj = new Boolean ( m_val ) ; return m_obj ; } public boolean equals ( XObject obj2 ) { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . equals ( this ) ; try { return m_val == obj2 . bool ( ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } } 	1	['10', '3', '1', '26', '18', '3', '24', '3', '9', '0.777777778', '98', '0', '2', '0.91025641', '0.333333333', '2', '22', '8.5', '3', '1.2', '1']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . OpCodes ; public class UnionPathIterator extends LocPathIterator implements Cloneable , DTMIterator , java . io . Serializable , PathComponent { public UnionPathIterator ( ) { super ( ) ; m_iterators = null ; m_exprs = null ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; try { if ( null != m_exprs ) { int n = m_exprs . length ; DTMIterator newIters [ ] = new DTMIterator [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { DTMIterator iter = m_exprs [ i ] . asIterator ( m_execContext , context ) ; newIters [ i ] = iter ; iter . nextNode ( ) ; } m_iterators = newIters ; } } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } } public void addIterator ( DTMIterator expr ) { if ( null == m_iterators ) { m_iterators = new DTMIterator [ 1 ] ; m_iterators [ 0 ] = expr ; } else { DTMIterator [ ] exprs = m_iterators ; int len = m_iterators . length ; m_iterators = new DTMIterator [ len + 1 ] ; System . arraycopy ( exprs , 0 , m_iterators , 0 , len ) ; m_iterators [ len ] = expr ; } expr . nextNode ( ) ; if ( expr instanceof Expression ) ( ( Expression ) expr ) . exprSetParent ( this ) ; } public void detach ( ) { if ( m_allowDetach && null != m_iterators ) { int n = m_iterators . length ; for ( int i = 0 ; i < n ; i ++ ) { m_iterators [ i ] . detach ( ) ; } m_iterators = null ; } } public UnionPathIterator ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { super ( ) ; opPos = compiler . getFirstChildPos ( opPos ) ; loadLocationPaths ( compiler , opPos , 0 ) ; } public static LocPathIterator createUnionIterator ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { UnionPathIterator upi = new UnionPathIterator ( compiler , opPos ) ; int nPaths = upi . m_exprs . length ; boolean isAllChildIterators = true ; for ( int i = 0 ; i < nPaths ; i ++ ) { LocPathIterator lpi = upi . m_exprs [ i ] ; if ( lpi . getAxis ( ) != Axis . CHILD ) { isAllChildIterators = false ; break ; } else { if ( HasPositionalPredChecker . check ( lpi ) ) { isAllChildIterators = false ; break ; } } } if ( isAllChildIterators ) { UnionChildIterator uci = new UnionChildIterator ( ) ; for ( int i = 0 ; i < nPaths ; i ++ ) { PredicatedNodeTest lpi = upi . m_exprs [ i ] ; uci . addNodeTest ( lpi ) ; } return uci ; } else return upi ; } public int getAnalysisBits ( ) { int bits = 0 ; if ( m_exprs != null ) { int n = m_exprs . length ; for ( int i = 0 ; i < n ; i ++ ) { int bit = m_exprs [ i ] . getAnalysisBits ( ) ; bits |= bit ; } } return bits ; } private void readObject ( java . io . ObjectInputStream stream ) throws java . io . IOException , javax . xml . transform . TransformerException { try { stream . defaultReadObject ( ) ; m_clones = new IteratorPool ( this ) ; } catch ( ClassNotFoundException cnfe ) { throw new javax . xml . transform . TransformerException ( cnfe ) ; } } public Object clone ( ) throws CloneNotSupportedException { UnionPathIterator clone = ( UnionPathIterator ) super . clone ( ) ; return clone ; } protected LocPathIterator createDTMIterator ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { LocPathIterator lpi = ( LocPathIterator ) WalkerFactory . newDTMIterator ( compiler , opPos , ( compiler . getLocationPathDepth ( ) <= 0 ) ) ; return lpi ; } protected void loadLocationPaths ( Compiler compiler , int opPos , int count ) throws javax . xml . transform . TransformerException { int steptype = compiler . getOp ( opPos ) ; if ( steptype == OpCodes . OP_LOCATIONPATH ) { loadLocationPaths ( compiler , compiler . getNextOpPos ( opPos ) , count + 1 ) ; m_exprs [ count ] = createDTMIterator ( compiler , opPos ) ; m_exprs [ count ] . exprSetParent ( this ) ; } else { switch ( steptype ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : loadLocationPaths ( compiler , compiler . getNextOpPos ( opPos ) , count + 1 ) ; WalkingIterator iter = new WalkingIterator ( compiler . getNamespaceContext ( ) ) ; iter . exprSetParent ( this ) ; if ( compiler . getLocationPathDepth ( ) <= 0 ) iter . setIsTopLevel ( true ) ; iter . m_firstWalker = new org . apache . xpath . axes . FilterExprWalker ( iter ) ; iter . m_firstWalker . init ( compiler , opPos , steptype ) ; m_exprs [ count ] = iter ; break ; default : m_exprs = new LocPathIterator [ count ] ; } } } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int earliestNode = DTM . NULL ; if ( null != m_iterators ) { int n = m_iterators . length ; int iteratorUsed = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int node = m_iterators [ i ] . getCurrentNode ( ) ; if ( DTM . NULL == node ) continue ; else if ( DTM . NULL == earliestNode ) { iteratorUsed = i ; earliestNode = node ; } else { if ( node == earliestNode ) { m_iterators [ i ] . nextNode ( ) ; } else { DTM dtm = getDTM ( node ) ; if ( dtm . isNodeAfter ( node , earliestNode ) ) { iteratorUsed = i ; earliestNode = node ; } } } } if ( DTM . NULL != earliestNode ) { m_iterators [ iteratorUsed ] . nextNode ( ) ; incrementCurrentPos ( ) ; } else m_foundLast = true ; } m_lastFetched = earliestNode ; return earliestNode ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { for ( int i = 0 ; i < m_exprs . length ; i ++ ) { m_exprs [ i ] . fixupVariables ( vars , globalsSize ) ; } } protected LocPathIterator [ ] m_exprs ; protected DTMIterator [ ] m_iterators ; public int getAxis ( ) { return - 1 ; } class iterOwner implements ExpressionOwner { int m_index ; iterOwner ( int index ) { m_index = index ; } public Expression getExpression ( ) { return m_exprs [ m_index ] ; } public void setExpression ( Expression exp ) { if ( ! ( exp instanceof LocPathIterator ) ) { WalkingIterator wi = new WalkingIterator ( getPrefixResolver ( ) ) ; FilterExprWalker few = new FilterExprWalker ( wi ) ; wi . setFirstWalker ( few ) ; few . setInnerExpression ( exp ) ; wi . exprSetParent ( UnionPathIterator . this ) ; few . exprSetParent ( wi ) ; exp . exprSetParent ( few ) ; exp = wi ; } else exp . exprSetParent ( UnionPathIterator . this ) ; m_exprs [ m_index ] = ( LocPathIterator ) exp ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitUnionPath ( owner , this ) ) { if ( null != m_exprs ) { int n = m_exprs . length ; for ( int i = 0 ; i < n ; i ++ ) { m_exprs [ i ] . callVisitors ( new iterOwner ( i ) , visitor ) ; } } } } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; UnionPathIterator upi = ( UnionPathIterator ) expr ; if ( null != m_exprs ) { int n = m_exprs . length ; if ( ( null == upi . m_exprs ) || ( upi . m_exprs . length != n ) ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m_exprs [ i ] . deepEquals ( upi . m_exprs [ i ] ) ) return false ; } } else if ( null != upi . m_exprs ) { return false ; } return true ; } } 	1	['16', '5', '0', '22', '54', '46', '4', '21', '13', '0.6', '563', '1', '2', '0.899280576', '0.2', '2', '13', '34.0625', '9', '2.5', '2']
package org . apache . xalan . xsltc . compiler ; import java . util . Dictionary ; import java . util . Vector ; import org . apache . bcel . generic . GOTO_W ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class TestSeq { private int _kernelType ; private Vector _patterns = null ; private Mode _mode = null ; private Template _default = null ; private InstructionList _instructionList ; private InstructionHandle _start = null ; public TestSeq ( Vector patterns , Mode mode ) { this ( patterns , - 2 , mode ) ; } public TestSeq ( Vector patterns , int kernelType , Mode mode ) { _patterns = patterns ; _kernelType = kernelType ; _mode = mode ; } public String toString ( ) { final int count = _patterns . size ( ) ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final LocationPathPattern pattern = ( LocationPathPattern ) _patterns . elementAt ( i ) ; if ( i == 0 ) { result . append ( "Testseq for kernel " + _kernelType ) . append ( '\n' ) ; } result . append ( "   pattern " + i + ": " ) . append ( pattern . toString ( ) ) . append ( '\n' ) ; } return result . toString ( ) ; } public InstructionList getInstructionList ( ) { return _instructionList ; } public double getPriority ( ) { final Template template = ( _patterns . size ( ) == 0 ) ? _default : ( ( Pattern ) _patterns . elementAt ( 0 ) ) . getTemplate ( ) ; return template . getPriority ( ) ; } public int getPosition ( ) { final Template template = ( _patterns . size ( ) == 0 ) ? _default : ( ( Pattern ) _patterns . elementAt ( 0 ) ) . getTemplate ( ) ; return template . getPosition ( ) ; } public void reduce ( ) { final Vector newPatterns = new Vector ( ) ; final int count = _patterns . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final LocationPathPattern pattern = ( LocationPathPattern ) _patterns . elementAt ( i ) ; pattern . reduceKernelPattern ( ) ; if ( pattern . isWildcard ( ) ) { _default = pattern . getTemplate ( ) ; break ; } else { newPatterns . addElement ( pattern ) ; } } _patterns = newPatterns ; } public void findTemplates ( Dictionary templates ) { if ( _default != null ) { templates . put ( _default , this ) ; } for ( int i = 0 ; i < _patterns . size ( ) ; i ++ ) { final LocationPathPattern pattern = ( LocationPathPattern ) _patterns . elementAt ( i ) ; templates . put ( pattern . getTemplate ( ) , this ) ; } } private InstructionHandle getTemplateHandle ( Template template ) { return ( InstructionHandle ) _mode . getTemplateInstructionHandle ( template ) ; } private LocationPathPattern getPattern ( int n ) { return ( LocationPathPattern ) _patterns . elementAt ( n ) ; } public InstructionHandle compile ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle continuation ) { if ( _start != null ) { return _start ; } final int count = _patterns . size ( ) ; if ( count == 0 ) { return ( _start = getTemplateHandle ( _default ) ) ; } InstructionHandle fail = ( _default == null ) ? continuation : getTemplateHandle ( _default ) ; for ( int n = count - 1 ; n >= 0 ; n -- ) { final LocationPathPattern pattern = getPattern ( n ) ; final Template template = pattern . getTemplate ( ) ; final InstructionList il = new InstructionList ( ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; InstructionList ilist = _mode . getInstructionList ( pattern ) ; if ( ilist == null ) { ilist = pattern . compile ( classGen , methodGen ) ; _mode . addInstructionList ( pattern , ilist ) ; } InstructionList copyOfilist = ilist . copy ( ) ; FlowList trueList = pattern . getTrueList ( ) ; if ( trueList != null ) { trueList = trueList . copyAndRedirect ( ilist , copyOfilist ) ; } FlowList falseList = pattern . getFalseList ( ) ; if ( falseList != null ) { falseList = falseList . copyAndRedirect ( ilist , copyOfilist ) ; } il . append ( copyOfilist ) ; final InstructionHandle gtmpl = getTemplateHandle ( template ) ; final InstructionHandle success = il . append ( new GOTO_W ( gtmpl ) ) ; if ( trueList != null ) { trueList . backPatch ( success ) ; } if ( falseList != null ) { falseList . backPatch ( fail ) ; } fail = il . getStart ( ) ; if ( _instructionList != null ) { il . append ( _instructionList ) ; } _instructionList = il ; } return ( _start = fail ) ; } } 	1	['11', '1', '0', '13', '48', '0', '1', '13', '9', '0.633333333', '360', '1', '2', '0', '0.222222222', '0', '0', '31.18181818', '11', '2.4545', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_hu extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "Egynél több stíluslap van definiálva ugyanabban a fájlban." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "A(z) ''{0}'' sablon már definiált ebben a stíluslapban." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "A(z) ''{0}'' sablon nem definiált ebben a stíluslapban." } , { ErrorMsg . VARIABLE_REDEF_ERR , "A(z) ''{0}'' változó többször definiált ugyanabban a hatókörben." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "A(z) ''{0}'' változó vagy paraméter nem definiált." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "Nem található a(z) ''{0}'' osztály." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "Nem található a(z) ''{0}'' külső metódus (public-nak kellene lenni)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Nem lehet konvertálni az argumentum/visszatérési kód típusát a(z) ''{0}'' metódus hívásában." } , { ErrorMsg . FILE_NOT_FOUND_ERR , "A(z) ''{0}'' fájl vagy URI nem található." } , { ErrorMsg . INVALID_URI_ERR , "Érvénytelen URI: ''{0}''." } , { ErrorMsg . FILE_ACCESS_ERR , "Nem lehet megnyitni a(z) ''{0}'' fájlt vagy URI-t." } , { ErrorMsg . MISSING_ROOT_ERR , "Hiányzik az <xsl:stylesheet> vagy <xsl:transform> elem." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "A(z) ''{0}'' névtér-prefix nincs deklarálva." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Nem lehet feloldani a(z) ''{0}'' függvény hívását." } , { ErrorMsg . NEED_LITERAL_ERR , "A(z) ''{0}'' argumentuma egy literál kell legyen." } , { ErrorMsg . XPATH_PARSER_ERR , "Hiba történt a(z) ''{0}'' XPath kifejezés elemzésekor." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Hiányzik a(z) ''{0}'' kötelező attribútum." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Nem megengedett karakter (''{0}'') szerepel az XPath kifejezésben." } , { ErrorMsg . ILLEGAL_PI_ERR , "Nem megengedett név (''{0}'') szerepelt a feldolgozási utasításokban." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "A(z) ''{0}'' attribútum kívül esik az elemen." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Nem megengedett attribútum: ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Körkörös import/include. A(z) ''{0}'' stíluslap már be van töltve." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Az eredményfa-részleteket nem lehet rendezni (az <xsl:sort> elemek figyelmen kívül maradnak). Rendeznie kell a node-okat, amikor eredményfát hoz létre." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Már definiálva van a(z) ''{0}'' decimális formázás." } , { ErrorMsg . XSL_VERSION_ERR , "Az XSLTC nem támogatja a(z) ''{0}'' XSL verziót." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Körkörös változó/paraméter-hivatkozás; helye: ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Ismeretlen operátort használt a bináris kifejezésben." } , { ErrorMsg . ILLEGAL_ARG_ERR , "Nem megengedett argumentumo(ka)t használt a függvényhívásban." } , { ErrorMsg . DOCUMENT_ARG_ERR , "A document() függvény második argumentuma egy node-készlet kell legyen." } , { ErrorMsg . MISSING_WHEN_ERR , "Legalább egy <xsl:when> elem szükséges az <xsl:choose>-ban." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "Csak egy <xsl:otherwise> elem megengedett <xsl:choose>-ban." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "Az <xsl:otherwise> csak <xsl:choose>-on belül használható." } , { ErrorMsg . STRAY_WHEN_ERR , "Az <xsl:when> csak <xsl:choose>-on belül használható." } , { ErrorMsg . WHEN_ELEMENT_ERR , "Csak <xsl:when> és <xsl:otherwise> elemek megengedettek az <xsl:choose>-ban." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "Hiányzik az <xsl:attribute-set>-ből a 'name' attribútum." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Nem megengedett gyermek elem." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "Nem hívhat ''{0}''-nek elemet." } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "Nem hívhat ''{0}''-nek attribútumot." } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Szövegadat szerepel a felső szintű <xsl:stylesheet> elemen kívül." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "Nincs megfelelően konfigurálva a JAXP elemző." } , { ErrorMsg . INTERNAL_ERR , "Helyrehozhatatlan XSLTC-belső hiba történt: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Nem támogatott XSL elem: ''{0}''." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "Ismeretlen XSLTC kiterjesztés: ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "A bemenő dokumentum nem stíluslap (az XSL névtér nincs deklarálva a root elemben)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Nem található a(z) ''{0}'' stíluslap-célban." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Nincs megvalósítva: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "A bemenő dokumentum nem tartalmaz XSL stíluslapot." } , { ErrorMsg . ELEMENT_PARSE_ERR , "Nem lehet elemezni a(z) ''{0}'' elemet." } , { ErrorMsg . KEY_USE_ATTR_ERR , "A(z) <key> attribútuma node, node-készlet, szöveg vagy szám lehet." } , { ErrorMsg . OUTPUT_VERSION_ERR , "A kimenő XML dokumentum-verzió 1.0 kell legyen." } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Ismeretlen operátort használt a relációs kifejezésben." } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Nemlétező attribútumkészletet (''{0}'') próbált használni." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Nem lehet elemezni a(z) ''{0}'' attribútumérték-sablont." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Ismeretlen adattípus szerepel a(z) ''{0}'' osztály aláírásában." } , { ErrorMsg . DATA_CONVERSION_ERR , "Nem lehet a(z) ''{0}'' adattípust ''{1}'' típusra konvertálni." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Ez a sablon nem tartalmaz érvényes translet osztálydefiníciót." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Ez a sablon nem tartalmaz ''{0}'' nevű osztályt." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Nem lehet betölteni a(z) ''{0}'' translet osztályt." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "A translet osztály betöltődött, de nem sikerült létrehozni a translet példányt." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "Megpróbálta null-ra állítani ''{0}'' ErrorListener objektumát." } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "Az XSLTC csak a StreamSource, SAXSource és DOMSource interfészeket támogatja." } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "A(z) ''{0}'' metódusnak átadott source objektum nem tartalmaz semmit." } , { ErrorMsg . JAXP_COMPILE_ERR , "Nem sikerült lefordítani a stíluslapot." } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "A TransformerFactory objektum nem ismer ''{0}'' attribútumot." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "A setResult() metódust a startDocument() hívása előtt kell meghívni." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "A transformer interfész nem tartalmaz beágyazott translet objektumot." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "Nincs definiálva kimenetkezelő az átalakítás eredményéhez." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "A(z) ''{0}'' metódusnak átadott result objektum érvénytelen." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Érvénytelen Transformer tulajdonságot (''{0}'') próbált meg elérni." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Nem lehet létrehozni a SAX2DOM adaptert: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() hívása systemId beállítása nélkül történt." } , { ErrorMsg . COMPILE_STDIN_ERR , "A -i kapcsolót a -o kapcsolóval együtt kell használni." } , { ErrorMsg . COMPILE_USAGE_STR , "Használat:\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <kimenet>]\n      [-d <alkönyvtár>] [-j <jarfájl>] [-p <csomag>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <stíluslap> | -i }\n\nOPCIÓK\n   -o <kimenet>    összerendeli a <kimenetet> a létrehozott\n                  translet-tel. Alapértelmezés szerint a translet neve\n                  a <stíluslap> nevéből jön. Ez az opció\n                  figyelmen kívól marad, ha több stíluslapot fordít.\n   -d <alkönyvtár> meghatározza a translet cél-alkönyvtárát\n   -j <jarfájl>   a translet osztályokat egy jar fájlba csomagolja,\n                  aminek a nevét a <jarfájl> attribútum adja meg\n   -p <csomag>    meghatározza az összes generált translet osztály\n                  prefixnevét.\n   -n             engedélyezi a template inlining optimalizálást\n                  (az alapértelmezett viselkedés általában jobb).\n   -x             bekapcsolja a további hibakeresési üzenet-kimenetet\n   -s             letiltja a System.exit hívását\n   -u             a <stíluslap> argumentumokat URL-ként értelmezi\n   -i             kényszeríti a fordítót, hogy a stíluslapokat az stdin-ről olvassa\n   -v             kiírja a fordító  verzióját\n   -h             kiírja ezt a használati üzenetet\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "Használat \n   java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfájl>]\n      [-x] [-s] [-n <iterációk>] {-u <dokumentum_url> | <dokumentum>}\n      <osztály> [<param1>=<érték1> ...]\n\n   a translet <osztályt> használja a <dokumentum> \n   attribútumban megadott XML dokumentum fordítására. A translet <oszály> vagy a\n   felhasználó CLASSPATH változója alapján vagy a megadott <jarfájl>-ban található meg.\nOpciók:\n   -j <jarfájl>      megadja azt a jarfájlt, amiből a translet-et be kell tölteni\n   -x                bekapcsolja a további hibakeresési üzeneteket\n   -s                letiltja a System.exit hívását\n   -n <iterációk>    az átalakítást <iterációk> alkalommal végzi el\n                     és megjeleníti a  teljesítmény-információkat\n   -u <dokumentum_url> a bemeneti XML dokumentumot URL-ként adja meg\n" } , { ErrorMsg . STRAY_SORT_ERR , "Az <xsl:sort> csak <xsl:for-each>-en vagy <xsl:apply-templates>-en belül használható." } , { ErrorMsg . UNSUPPORTED_ENCODING , "A(z) ''{0}'' kimeneti kódolást nem támogatja ez a JVM." } , { ErrorMsg . SYNTAX_ERR , "Szintaktikai hiba történt ''{0}''-ben." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "Nem található a(z) ''{0}'' külső konstruktor." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "A(z ''{0}'' nem statikus Jáva függvény első argumentuma nem egy érvényes objektum-hivatkozás." } , { ErrorMsg . TYPE_CHECK_ERR , "Hiba történt a(z) ''{0}'' kifejezés típusának ellenőrzésekor." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Hiba történt egy ismeretlen helyen lévő kifejezés típusának ellenőrzésekor." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "A(z) ''{0}'' parancssori opció érvénytelen." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "A(z) ''{0}'' parancssori opcióhoz hiányzik egy kötelező argumentum." } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "FIGYELEM:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "FIGYELEM:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "VÉGZETES HIBA:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "VÉGZETES HIBA:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "HIBA:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "HIBA:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Átalakítás a(z) ''{0}'' translet segítségével. " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Átalakítás a(z) ''{1}'' jar fájlból a(z) ''{0}'' translet segítségével." } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "Nem lehet létrehozni a(z) ''{0}'' TransformerFactory osztály példányát." } , { ErrorMsg . COMPILER_ERROR_KEY , "Fordítás hibák:" } , { ErrorMsg . COMPILER_WARNING_KEY , "Fordítási figyelmeztetések:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Translet hibák:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . w3c . dom . xpath ; public class XPathException extends RuntimeException { public XPathException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short INVALID_EXPRESSION_ERR = 1 ; public static final short TYPE_ERR = 2 ; } 	1	['1', '4', '0', '0', '2', '0', '0', '0', '1', '2', '11', '0', '0', '1', '1', '0', '0', '7', '0', '0', '2']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Quo extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( ( int ) ( left . num ( ) / right . num ( ) ) ) ; } } 	1	['2', '3', '0', '4', '5', '1', '1', '3', '2', '2', '16', '0', '0', '0.976190476', '0.75', '1', '1', '7', '1', '0.5', '1']
package org . apache . xalan . processor ; import java . util . Stack ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Templates ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . sax . TemplatesHandler ; import org . apache . xalan . extensions . ExpressionVisitor ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemForEach ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . NamespaceSupport2 ; import org . apache . xml . utils . NodeConsumer ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . apache . xpath . XPath ; import org . apache . xpath . compiler . FunctionTable ; import org . apache . xpath . functions . Function ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . helpers . DefaultHandler ; import org . xml . sax . helpers . NamespaceSupport ; public class StylesheetHandler extends DefaultHandler implements TemplatesHandler , PrefixResolver , NodeConsumer { static { Function func = new org . apache . xalan . templates . FuncDocument ( ) ; FunctionTable . installFunction ( "document" , func ) ; func = new org . apache . xalan . templates . FuncFormatNumb ( ) ; FunctionTable . installFunction ( "format-number" , func ) ; } public StylesheetHandler ( TransformerFactoryImpl processor ) throws TransformerConfigurationException { init ( processor ) ; } void init ( TransformerFactoryImpl processor ) { m_stylesheetProcessor = processor ; m_processors . push ( m_schema . getElementProcessor ( ) ) ; this . pushNewNamespaceSupport ( ) ; } public XPath createXPath ( String str , ElemTemplateElement owningTemplate ) throws javax . xml . transform . TransformerException { ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; XPath xpath = new XPath ( str , owningTemplate , this , XPath . SELECT , handler ) ; xpath . callVisitors ( xpath , new ExpressionVisitor ( getStylesheetRoot ( ) ) ) ; return xpath ; } XPath createMatchPatternXPath ( String str , ElemTemplateElement owningTemplate ) throws javax . xml . transform . TransformerException { ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; XPath xpath = new XPath ( str , owningTemplate , this , XPath . MATCH , handler ) ; xpath . callVisitors ( xpath , new ExpressionVisitor ( getStylesheetRoot ( ) ) ) ; return xpath ; } public String getNamespaceForPrefix ( String prefix ) { return this . getNamespaceSupport ( ) . getURI ( prefix ) ; } public String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node context ) { assertion ( true , "can't process a context node in StylesheetHandler!" ) ; return null ; } private boolean stackContains ( Stack stack , String url ) { int n = stack . size ( ) ; boolean contains = false ; for ( int i = 0 ; i < n ; i ++ ) { String url2 = ( String ) stack . elementAt ( i ) ; if ( url2 . equals ( url ) ) { contains = true ; break ; } } return contains ; } public Templates getTemplates ( ) { return getStylesheetRoot ( ) ; } public void setSystemId ( String baseID ) { pushBaseIndentifier ( baseID ) ; } public String getSystemId ( ) { return this . getBaseIdentifier ( ) ; } public InputSource resolveEntity ( String publicId , String systemId ) throws org . xml . sax . SAXException { return getCurrentProcessor ( ) . resolveEntity ( this , publicId , systemId ) ; } public void notationDecl ( String name , String publicId , String systemId ) { getCurrentProcessor ( ) . notationDecl ( this , name , publicId , systemId ) ; } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) { getCurrentProcessor ( ) . unparsedEntityDecl ( this , name , publicId , systemId , notationName ) ; } XSLTElementProcessor getProcessorFor ( String uri , String localName , String rawName ) throws org . xml . sax . SAXException { XSLTElementProcessor currentProcessor = getCurrentProcessor ( ) ; XSLTElementDef def = currentProcessor . getElemDef ( ) ; XSLTElementProcessor elemProcessor = def . getProcessorFor ( uri , localName ) ; if ( null == elemProcessor && ! ( currentProcessor instanceof ProcessorStylesheetDoc ) && ( ( null == getStylesheet ( ) || Double . valueOf ( getStylesheet ( ) . getVersion ( ) ) . doubleValue ( ) > Constants . XSLTVERSUPPORTED ) || ( ! uri . equals ( Constants . S_XSLNAMESPACEURL ) && currentProcessor instanceof ProcessorStylesheetElement ) || getElemVersion ( ) > Constants . XSLTVERSUPPORTED ) ) { elemProcessor = def . getProcessorForUnknown ( uri , localName ) ; } if ( null == elemProcessor ) error ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_ALLOWED_IN_POSITION , new Object [ ] { rawName } ) , null ) ; return elemProcessor ; } public void setDocumentLocator ( Locator locator ) { m_stylesheetLocatorStack . push ( new SAXSourceLocator ( locator ) ) ; } private int m_stylesheetLevel = - 1 ; public void startDocument ( ) throws org . xml . sax . SAXException { m_stylesheetLevel ++ ; pushSpaceHandling ( false ) ; } private boolean m_parsingComplete = false ; public boolean isStylesheetParsingComplete ( ) { return m_parsingComplete ; } public void endDocument ( ) throws org . xml . sax . SAXException { try { if ( null != getStylesheetRoot ( ) ) { if ( 0 == m_stylesheetLevel ) getStylesheetRoot ( ) . recompose ( ) ; } else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_STYLESHEETROOT , null ) ) ; XSLTElementProcessor elemProcessor = getCurrentProcessor ( ) ; if ( null != elemProcessor ) elemProcessor . startNonText ( this ) ; m_stylesheetLevel -- ; popSpaceHandling ( ) ; m_parsingComplete = ( m_stylesheetLevel < 0 ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } private java . util . Vector m_prefixMappings = new java . util . Vector ( ) ; public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { m_prefixMappings . addElement ( prefix ) ; m_prefixMappings . addElement ( uri ) ; } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { } private void flushCharacters ( ) throws org . xml . sax . SAXException { XSLTElementProcessor elemProcessor = getCurrentProcessor ( ) ; if ( null != elemProcessor ) elemProcessor . startNonText ( this ) ; } public void startElement ( String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { NamespaceSupport nssupport = this . getNamespaceSupport ( ) ; nssupport . pushContext ( ) ; int n = m_prefixMappings . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String prefix = ( String ) m_prefixMappings . elementAt ( i ++ ) ; String nsURI = ( String ) m_prefixMappings . elementAt ( i ) ; nssupport . declarePrefix ( prefix , nsURI ) ; } m_prefixMappings . removeAllElements ( ) ; m_elementID ++ ; checkForFragmentID ( attributes ) ; if ( ! m_shouldProcess ) return ; flushCharacters ( ) ; pushSpaceHandling ( attributes ) ; XSLTElementProcessor elemProcessor = getProcessorFor ( uri , localName , rawName ) ; if ( null != elemProcessor ) { this . pushProcessor ( elemProcessor ) ; elemProcessor . startElement ( this , uri , localName , rawName , attributes ) ; } else { m_shouldProcess = false ; popSpaceHandling ( ) ; } } public void endElement ( String uri , String localName , String rawName ) throws org . xml . sax . SAXException { m_elementID -- ; if ( ! m_shouldProcess ) return ; if ( ( m_elementID + 1 ) == m_fragmentID ) m_shouldProcess = false ; flushCharacters ( ) ; popSpaceHandling ( ) ; XSLTElementProcessor p = getCurrentProcessor ( ) ; p . endElement ( this , uri , localName , rawName ) ; this . popProcessor ( ) ; this . getNamespaceSupport ( ) . popContext ( ) ; } public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; XSLTElementProcessor elemProcessor = getCurrentProcessor ( ) ; XSLTElementDef def = elemProcessor . getElemDef ( ) ; if ( def . getType ( ) != XSLTElementDef . T_PCDATA ) elemProcessor = def . getProcessorFor ( null , "text()" ) ; if ( null == elemProcessor ) { if ( ! XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) error ( XSLMessages . createMessage ( XSLTErrorResources . ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , null ) , null ) ; } else elemProcessor . characters ( this , ch , start , length ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; getCurrentProcessor ( ) . ignorableWhitespace ( this , ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; String prefix = "" , ns = "" , localName = target ; int colon = target . indexOf ( ':' ) ; if ( colon >= 0 ) { ns = getNamespaceForPrefix ( prefix = target . substring ( 0 , colon ) ) ; localName = target . substring ( colon + 1 ) ; } try { if ( "xalan-doc-cache-off" . equals ( target ) || "xalan:doc-cache-off" . equals ( target ) || ( "doc-cache-off" . equals ( localName ) && ns . equals ( "org.apache.xalan.xslt.extensions.Redirect" ) ) ) { if ( ! ( m_elems . peek ( ) instanceof ElemForEach ) ) throw new TransformerException ( "xalan:doc-cache-off not allowed here!" , getLocator ( ) ) ; ElemForEach elem = ( ElemForEach ) m_elems . peek ( ) ; elem . m_doc_cache_off = true ; } } catch ( Exception e ) { } flushCharacters ( ) ; getCurrentProcessor ( ) . processingInstruction ( this , target , data ) ; } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { if ( ! m_shouldProcess ) return ; getCurrentProcessor ( ) . skippedEntity ( this , name ) ; } public void warn ( String msg , Object args [ ] ) throws org . xml . sax . SAXException { String formattedMsg = XSLMessages . createWarning ( msg , args ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { if ( null != handler ) handler . warning ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } private void assertion ( boolean condition , String msg ) throws RuntimeException { if ( ! condition ) throw new RuntimeException ( msg ) ; } protected void error ( String msg , Exception e ) throws org . xml . sax . SAXException { SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; TransformerException pe ; if ( ! ( e instanceof TransformerException ) ) { pe = ( null == e ) ? new TransformerException ( msg , locator ) : new TransformerException ( msg , locator , e ) ; } else pe = ( TransformerException ) e ; if ( null != handler ) { try { handler . error ( pe ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } else throw new org . xml . sax . SAXException ( pe ) ; } protected void error ( String msg , Object args [ ] , Exception e ) throws org . xml . sax . SAXException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; error ( formattedMsg , e ) ; } public void warning ( org . xml . sax . SAXParseException e ) throws org . xml . sax . SAXException { String formattedMsg = e . getMessage ( ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . warning ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void error ( org . xml . sax . SAXParseException e ) throws org . xml . sax . SAXException { String formattedMsg = e . getMessage ( ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . error ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } public void fatalError ( org . xml . sax . SAXParseException e ) throws org . xml . sax . SAXException { String formattedMsg = e . getMessage ( ) ; SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . fatalError ( new TransformerException ( formattedMsg , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } private boolean m_shouldProcess = true ; private String m_fragmentIDString ; private int m_elementID = 0 ; private int m_fragmentID = 0 ; private void checkForFragmentID ( Attributes attributes ) { if ( ! m_shouldProcess ) { if ( ( null != attributes ) && ( null != m_fragmentIDString ) ) { int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String name = attributes . getQName ( i ) ; if ( name . equals ( Constants . ATTRNAME_ID ) ) { String val = attributes . getValue ( i ) ; if ( val . equalsIgnoreCase ( m_fragmentIDString ) ) { m_shouldProcess = true ; m_fragmentID = m_elementID ; } } } } } } private TransformerFactoryImpl m_stylesheetProcessor ; TransformerFactoryImpl getStylesheetProcessor ( ) { return m_stylesheetProcessor ; } static final int STYPE_ROOT = 1 ; static final int STYPE_INCLUDE = 2 ; static final int STYPE_IMPORT = 3 ; private int m_stylesheetType = STYPE_ROOT ; int getStylesheetType ( ) { return m_stylesheetType ; } void setStylesheetType ( int type ) { m_stylesheetType = type ; } private Stack m_stylesheets = new Stack ( ) ; Stylesheet getStylesheet ( ) { return ( m_stylesheets . size ( ) == 0 ) ? null : ( Stylesheet ) m_stylesheets . peek ( ) ; } Stylesheet getLastPoppedStylesheet ( ) { return m_lastPoppedStylesheet ; } public StylesheetRoot getStylesheetRoot ( ) { return m_stylesheetRoot ; } StylesheetRoot m_stylesheetRoot ; Stylesheet m_lastPoppedStylesheet ; public void pushStylesheet ( Stylesheet s ) { if ( m_stylesheets . size ( ) == 0 ) m_stylesheetRoot = ( StylesheetRoot ) s ; m_stylesheets . push ( s ) ; } Stylesheet popStylesheet ( ) { if ( ! m_stylesheetLocatorStack . isEmpty ( ) ) m_stylesheetLocatorStack . pop ( ) ; if ( ! m_stylesheets . isEmpty ( ) ) m_lastPoppedStylesheet = ( Stylesheet ) m_stylesheets . pop ( ) ; return m_lastPoppedStylesheet ; } private Stack m_processors = new Stack ( ) ; XSLTElementProcessor getCurrentProcessor ( ) { return ( XSLTElementProcessor ) m_processors . peek ( ) ; } void pushProcessor ( XSLTElementProcessor processor ) { m_processors . push ( processor ) ; } XSLTElementProcessor popProcessor ( ) { return ( XSLTElementProcessor ) m_processors . pop ( ) ; } private XSLTSchema m_schema = new XSLTSchema ( ) ; XSLTSchema getSchema ( ) { return m_schema ; } private Stack m_elems = new Stack ( ) ; ElemTemplateElement getElemTemplateElement ( ) { try { return ( ElemTemplateElement ) m_elems . peek ( ) ; } catch ( java . util . EmptyStackException ese ) { return null ; } } private int m_docOrderCount = 0 ; int nextUid ( ) { return m_docOrderCount ++ ; } void pushElemTemplateElement ( ElemTemplateElement elem ) { if ( elem . getUid ( ) == - 1 ) elem . setUid ( nextUid ( ) ) ; m_elems . push ( elem ) ; } ElemTemplateElement popElemTemplateElement ( ) { return ( ElemTemplateElement ) m_elems . pop ( ) ; } Stack m_baseIdentifiers = new Stack ( ) ; void pushBaseIndentifier ( String baseID ) { if ( null != baseID ) { int posOfHash = baseID . indexOf ( '#' ) ; if ( posOfHash > - 1 ) { m_fragmentIDString = baseID . substring ( posOfHash + 1 ) ; m_shouldProcess = false ; } else m_shouldProcess = true ; } else m_shouldProcess = true ; m_baseIdentifiers . push ( baseID ) ; } String popBaseIndentifier ( ) { return ( String ) m_baseIdentifiers . pop ( ) ; } public String getBaseIdentifier ( ) { String base = ( String ) ( m_baseIdentifiers . isEmpty ( ) ? null : m_baseIdentifiers . peek ( ) ) ; if ( null == base ) { SourceLocator locator = getLocator ( ) ; base = ( null == locator ) ? "" : locator . getSystemId ( ) ; } return base ; } private Stack m_stylesheetLocatorStack = new Stack ( ) ; public SAXSourceLocator getLocator ( ) { if ( m_stylesheetLocatorStack . isEmpty ( ) ) { SAXSourceLocator locator = new SAXSourceLocator ( ) ; locator . setSystemId ( this . getStylesheetProcessor ( ) . getDOMsystemID ( ) ) ; return locator ; } return ( ( SAXSourceLocator ) m_stylesheetLocatorStack . peek ( ) ) ; } private Stack m_importStack = new Stack ( ) ; void pushImportURL ( String hrefUrl ) { m_importStack . push ( hrefUrl ) ; } boolean importStackContains ( String hrefUrl ) { return stackContains ( m_importStack , hrefUrl ) ; } String popImportURL ( ) { return ( String ) m_importStack . pop ( ) ; } private boolean warnedAboutOldXSLTNamespace = false ; Stack m_nsSupportStack = new Stack ( ) ; void pushNewNamespaceSupport ( ) { m_nsSupportStack . push ( new NamespaceSupport2 ( ) ) ; } void popNamespaceSupport ( ) { m_nsSupportStack . pop ( ) ; } NamespaceSupport getNamespaceSupport ( ) { return ( NamespaceSupport ) m_nsSupportStack . peek ( ) ; } private Node m_originatingNode ; public void setOriginatingNode ( Node n ) { m_originatingNode = n ; } public Node getOriginatingNode ( ) { return m_originatingNode ; } private BoolStack m_spacePreserveStack = new BoolStack ( ) ; boolean isSpacePreserve ( ) { return m_spacePreserveStack . peek ( ) ; } void popSpaceHandling ( ) { m_spacePreserveStack . pop ( ) ; } void pushSpaceHandling ( boolean b ) throws org . xml . sax . SAXParseException { m_spacePreserveStack . push ( b ) ; } void pushSpaceHandling ( Attributes attrs ) throws org . xml . sax . SAXParseException { String value = attrs . getValue ( "xml:space" ) ; if ( null == value ) { m_spacePreserveStack . push ( m_spacePreserveStack . peekOrFalse ( ) ) ; } else if ( value . equals ( "preserve" ) ) { m_spacePreserveStack . push ( true ) ; } else if ( value . equals ( "default" ) ) { m_spacePreserveStack . push ( false ) ; } else { SAXSourceLocator locator = getLocator ( ) ; ErrorListener handler = m_stylesheetProcessor . getErrorListener ( ) ; try { handler . error ( new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_XMLSPACE_VALUE , null ) , locator ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXParseException ( te . getMessage ( ) , locator , te ) ; } m_spacePreserveStack . push ( m_spacePreserveStack . peek ( ) ) ; } } private double getElemVersion ( ) { ElemTemplateElement elem = getElemTemplateElement ( ) ; double version = - 1 ; while ( ( version == - 1 || version == Constants . XSLTVERSUPPORTED ) && elem != null ) { try { version = Double . valueOf ( elem . getVersion ( ) ) . doubleValue ( ) ; } catch ( Exception ex ) { version = - 1 ; } elem = elem . getParentElem ( ) ; } return ( version == - 1 ) ? Constants . XSLTVERSUPPORTED : version ; } public boolean handlesNullPrefixes ( ) { return false ; } } 	1	['70', '2', '0', '44', '152', '2107', '22', '25', '33', '0.93812709', '1322', '0.730769231', '5', '0.2', '0.108695652', '1', '1', '17.51428571', '7', '1.3', '4']
package org . apache . xalan . trace ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; public class EndSelectionEvent extends SelectionEvent { public EndSelectionEvent ( TransformerImpl processor , Node sourceNode , ElemTemplateElement styleNode , String attributeName , XPath xpath , XObject selection ) { super ( processor , sourceNode , styleNode , attributeName , xpath , selection ) ; } } 	1	['1', '2', '0', '8', '2', '0', '3', '5', '1', '2', '10', '0', '0', '0', '1', '0', '0', '9', '0', '0', '1']
package org . apache . xalan . templates ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class XUnresolvedVariable extends XObject { transient private int m_context ; transient private TransformerImpl m_transformer ; transient private int m_varStackPos = - 1 ; transient private int m_varStackContext ; private boolean m_isGlobal ; transient private boolean m_doneEval = true ; public XUnresolvedVariable ( ElemVariable obj , int sourceNode , TransformerImpl transformer , int varStackPos , int varStackContext , boolean isGlobal ) { super ( obj ) ; m_context = sourceNode ; m_transformer = transformer ; m_varStackPos = varStackPos ; m_varStackContext = varStackContext ; m_isGlobal = isGlobal ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( ! m_doneEval ) { this . m_transformer . getMsgMgr ( ) . error ( xctxt . getSAXLocator ( ) , XSLTErrorResources . ER_REFERENCING_ITSELF , new Object [ ] { ( ( ElemVariable ) this . object ( ) ) . getName ( ) . getLocalName ( ) } ) ; } VariableStack vars = xctxt . getVarStack ( ) ; int currentFrame = vars . getStackFrame ( ) ; ElemVariable velem = ( ElemVariable ) m_obj ; try { m_doneEval = false ; if ( - 1 != velem . m_frameSize ) vars . link ( velem . m_frameSize ) ; XObject var = velem . getValue ( m_transformer , m_context ) ; m_doneEval = true ; return var ; } finally { if ( - 1 != velem . m_frameSize ) vars . unlink ( currentFrame ) ; } } public void setVarStackPos ( int top ) { m_varStackPos = top ; } public void setVarStackContext ( int bottom ) { m_varStackContext = bottom ; } public int getType ( ) { return CLASS_UNRESOLVEDVARIABLE ; } public String getTypeString ( ) { return "XUnresolvedVariable (" + object ( ) . getClass ( ) . getName ( ) + ")" ; } } 	1	['6', '3', '0', '7', '23', '9', '1', '7', '6', '0.833333333', '134', '1', '1', '0.934210526', '0.361111111', '2', '12', '20.33333333', '1', '0.8333', '1']
package org . apache . xml . dtm . ref ; import org . w3c . dom . Node ; public class DTMNodeListBase implements org . w3c . dom . NodeList { public DTMNodeListBase ( ) { } public Node item ( int index ) { return null ; } public int getLength ( ) { return 0 ; } } 	1	['3', '1', '3', '3', '4', '3', '3', '0', '3', '2', '10', '0', '0', '0', '0.666666667', '0', '0', '2.333333333', '1', '0.6667', '1']
package org . apache . xalan . extensions ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . functions . FuncExtFunctionAvailable ; import org . apache . xpath . functions . Function ; public class ExpressionVisitor extends XPathVisitor { private StylesheetRoot m_sroot ; public ExpressionVisitor ( StylesheetRoot sroot ) { m_sroot = sroot ; } public boolean visitFunction ( ExpressionOwner owner , Function func ) { if ( func instanceof FuncExtFunction ) { String namespace = ( ( FuncExtFunction ) func ) . getNamespace ( ) ; m_sroot . getExtensionNamespacesManager ( ) . registerExtension ( namespace ) ; } else if ( func instanceof FuncExtFunctionAvailable ) { String arg = ( ( FuncExtFunctionAvailable ) func ) . getArg0 ( ) . toString ( ) ; if ( arg . indexOf ( ":" ) > 0 ) { String prefix = arg . substring ( 0 , arg . indexOf ( ":" ) ) ; String namespace = this . m_sroot . getNamespaceForPrefix ( prefix ) ; m_sroot . getExtensionNamespacesManager ( ) . registerExtension ( namespace ) ; } } return true ; } } 	1	['2', '2', '0', '9', '11', '0', '1', '8', '2', '0', '53', '1', '1', '0.923076923', '0.625', '0', '0', '25', '4', '2', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources_ja extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "エラー: 式内では '{' を使用できません。" } , { ER_ILLEGAL_ATTRIBUTE , "{0} に正しくない属性があります: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "xsl:apply-imports 内の sourceNode がヌルです!" } , { ER_CANNOT_ADD , "{0} を {1} に追加できません。" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "handleApplyTemplatesInstruction 内の sourceNode がヌルです!" } , { ER_NO_NAME_ATTRIB , "{0} には name 属性が必要です。" } , { ER_TEMPLATE_NOT_FOUND , "{0} という名前のテンプレートが見つかりませんでした。" } , { ER_CANT_RESOLVE_NAME_AVT , "xsl:call-template 内の名前 AVT を解決できませんでした。" } , { ER_REQUIRES_ATTRIB , "{0} には属性が必要です: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} には ''test'' 属性が必要です。" } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "level 属性で値が間違っています: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "処理命令の名前は 'xml' にはできません。" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "処理命令の名前は有効な NCName でなければなりません: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} にモードがある場合は、match 属性が必要です。" } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} には name または match のいずれかの属性が必要です。" } , { ER_CANT_RESOLVE_NSPREFIX , "ネーム・スペース接頭部を解決できません: {0}" } , { ER_ILLEGAL_VALUE , "xml:space には正しくない値があります: {0}" } , { ER_NO_OWNERDOC , "下位ノードに所有者文書がありません!" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement エラー: {0}" } , { ER_NULL_CHILD , "ヌルの子を追加しようとしています!" } , { ER_NEED_SELECT_ATTRIB , "{0} には select 属性が必要です。" } , { ER_NEED_TEST_ATTRIB , "xsl:when には 'test' 属性が必要です。" } , { ER_NEED_NAME_ATTRIB , "xsl:with-param には 'name' 属性が必要です。" } , { ER_NO_CONTEXT_OWNERDOC , "コンテキストに所有者文書がありません!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "XML TransformerFactory Liaison を作成できませんでした: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: 処理は成功しませんでした。" } , { ER_NOT_SUCCESSFUL , "Xalan: は成功しませんでした。" } , { ER_ENCODING_NOT_SUPPORTED , "エンコードはサポートされていません: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "TraceListener を作成できませんでした: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key には 'name' 属性が必要です!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key には 'match' 属性が必要です!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key には 'use' 属性が必要です!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} には ''elements'' 属性が必要です!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} 属性の ''prefix'' がありません" } , { ER_BAD_STYLESHEET_URL , "スタイルシート URL が間違っています: {0}" } , { ER_FILE_NOT_FOUND , "スタイルシート・ファイルが見つかりませんでした: {0}" } , { ER_IOEXCEPTION , "スタイルシート・ファイルによる入出力例外が起こりました: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) {0} の href 属性が見つかりませんでした。" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} が自分自身を直接的または間接的に組み込もうとしています!" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude エラー、{0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} 属性の ''lang'' がありません" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) {0} エレメントの場所を間違えた可能性があります。 コンテナー・エレメント ''component'' がありません。" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Element、DocumentFragment、Document、または PrintWriter への出力しかできません。" } , { ER_PROCESS_ERROR , "StylesheetRoot.処理エラー" } , { ER_UNIMPLNODE_ERROR , "UnImplNode エラー: {0}" } , { ER_NO_SELECT_EXPRESSION , "エラー! xpath select 式 (-select) が見つかりませんでした。" } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "XSLProcessor をシリアライズできません!" } , { ER_NO_INPUT_STYLESHEET , "スタイルシート入力が指定されていませんでした!" } , { ER_FAILED_PROCESS_STYLESHEET , "スタイルシートを処理することに失敗しました!" } , { ER_COULDNT_PARSE_DOC , "{0} 文書を構文解析できませんでした!" } , { ER_COULDNT_FIND_FRAGMENT , "フラグメントが見つかりませんでした: {0}" } , { ER_NODE_NOT_ELEMENT , "フラグメント ID により指されているノードがエレメントでありませんでした: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each には match または name のいずれかの属性が必要です。" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "テンプレートには match または name のいずれかの属性が必要です。" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "文書フラグメントの複製がありません!" } , { ER_CANT_CREATE_ITEM , "項目を結果ツリーに作成できません: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "ソース XML 内の xml:space には正しくない値があります: {0}" } , { ER_NO_XSLKEY_DECLARATION , "{0} の xsl:key 宣言がありません!" } , { ER_CANT_CREATE_URL , "エラー! {0} の URL を作成できません。" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions はサポートされていません。" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory エラー" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} はスタイルシートの内部では許可されていません!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns はもうサポートされていません!  代りに xsl:output を使用してください。" } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space はもうサポートされていません!  代りに xsl:strip-space または xsl:preserve-space を使用してください。" } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result はもうサポートされていません!  代りに xsl:output を使用してください。" } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} には正しくない属性があります: {1}" } , { ER_UNKNOWN_XSL_ELEM , "不明の XSL エレメント: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort は xsl:apply-templates または xsl:for-each としか使用できません。" } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) xsl:when の場所を誤っていました!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when が xsl:choose により親になっていませんでした!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) xsl:otherwise の場所を誤っていました!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise が xsl:choose により親になっていませんでした!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} はテンプレートの内部では許可されていません!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} 拡張ネーム・スペース接頭部 {1} が不明です。" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) インポートは、スタイルシート内の先頭エレメントとしてのみ入れることができます!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} が自分自身を直接的または間接的にインポートしようとしています!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) xml:space に正しくない値があります: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet は成功していません!" } , { ER_SAX_EXCEPTION , "SAX 例外" } , { ER_XSLT_ERROR , "XSLT エラー" } , { ER_CURRENCY_SIGN_ILLEGAL , "通貨記号は書式パターン・ストリング内で許可されていません。" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "文書機能はスタイル・シート DOM ではサポートされていません!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "非接頭部リゾルバーの接頭部を解決できません!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "リダイレクト拡張: ファイル名を取得できませんでした。file または select 属性は有効なストリングを戻さなければなりません。" } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "FormatterListener はリダイレクト拡張内にビルドできません!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "exclude-result-prefixes 内の接頭部が無効です: {0}" } , { ER_MISSING_NS_URI , "指定された接頭部のネーム・スペース URI がありません。" } , { ER_MISSING_ARG_FOR_OPTION , "オプションの引き数がありません: {0}" } , { ER_INVALID_OPTION , "無効なオプション: {0}" } , { ER_MALFORMED_FORMAT_STRING , "誤った形式の書式ストリング: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet には 'version' 属性が必要です!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "属性: {0} には正しくない値: {1} があります。" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose には xsl:when が必要です。" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports は xsl:for-each 内では許可されていません。" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "DTMLiaison は出力 DOM ノードに使用できません... 代りに org.apache.xpath.DOM2Helper を渡してください!" } , { ER_CANT_USE_DTM_FOR_INPUT , "DTMLiaison は入力 DOM ノードに使用できません... 代りに org.apache.xpath.DOM2Helper を渡してください!" } , { ER_CALL_TO_EXT_FAILED , "拡張エレメントへの呼び出しが失敗しました: {0}" } , { ER_PREFIX_MUST_RESOLVE , "接頭部はネーム・スペースに解決されなければなりません: {0}" } , { ER_INVALID_UTF16_SURROGATE , "無効な UTF-16 サロゲートが検出されました: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} が自身を使用しているため、無限ループの原因となります。" } , { ER_CANNOT_MIX_XERCESDOM , "非 Xerces-DOM 入力と Xerces-DOM 出力は混用できません!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "ElemTemplateElement.readObject 内: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "次の名前のテンプレートが複数見つかりました: {0}" } , { ER_INVALID_KEY_CALL , "無効な関数呼び出し: 再帰的 key() 呼び出しは許可されていません。" } , { ER_REFERENCING_ITSELF , "変数 {0} が直接的または間接的に自分自身に参照づけています!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "newTemplates の DOMSource の入力をヌルにはできません!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "オプション {0} のクラス・ファイルが見つかりません。" } , { ER_REQUIRED_ELEM_NOT_FOUND , "必要なエレメントが見つかりません: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream をヌルにはできません。" } , { ER_URI_CANNOT_BE_NULL , "URI をヌルにはできません。" } , { ER_FILE_CANNOT_BE_NULL , "ファイルをヌルにはできません。" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource をヌルにはできません。" } , { ER_CANNOT_INIT_BSFMGR , "BSF マネージャーを初期化できませんでした。" } , { ER_CANNOT_CMPL_EXTENSN , "拡張機能をコンパイルできませんでした。" } , { ER_CANNOT_CREATE_EXTENSN , "原因: {1} のために拡張機能: {0} を作成できませんでした。" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "メソッド {0} へのインスタンス・メソッド呼び出しにはオブジェクト・インスタンスが最初の引き数として必要です。" } , { ER_INVALID_ELEMENT_NAME , "無効なエレメント名が指定されました: {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "エレメント名メソッドは静的でなければなりません: {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "拡張機能 {0} : {1} が不明です。" } , { ER_MORE_MATCH_CONSTRUCTOR , "{0} のコンストラクターの最適一致が複数あります。" } , { ER_MORE_MATCH_METHOD , "メソッド {0} の最適一致が複数あります。" } , { ER_MORE_MATCH_ELEMENT , "エレメント・メソッド {0} の最適一致が複数あります。" } , { ER_INVALID_CONTEXT_PASSED , "{0} を評価するために渡されたコンテキストが無効です。" } , { ER_POOL_EXISTS , "プールはすでに存在しています。" } , { ER_NO_DRIVER_NAME , "ドライバー名が指定されていません。" } , { ER_NO_URL , "URL が指定されていません。" } , { ER_POOL_SIZE_LESSTHAN_ONE , "プール・サイズが 1 より小です!" } , { ER_INVALID_DRIVER , "無効なドライバー名が指定されました!" } , { ER_NO_STYLESHEETROOT , "スタイルシートのルートが見つかりませんでした!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "xml:space の値が正しくありません。" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode が失敗しました。" } , { ER_RESOURCE_COULD_NOT_LOAD , "リソース [ {0} ] をロードできませんでした: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "バッファー・サイズ <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "エクステンションを呼び出し時に不明エラー" } , { ER_NO_NAMESPACE_DECL , "接頭部 {0} には対応しているネーム・スペース宣言がありません。" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "エレメントのコンテンツは lang=javaclass {0} の場合は許可されていません。" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "スタイルシートで終了が指図されました。" } , { ER_ONE_OR_TWO , "1 または 2" } , { ER_TWO_OR_THREE , "2 または 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "{0} をロードできませんでした (CLASSPATH を調べてください)。現在はまさにデフォルトを使用中です。" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "デフォルト・テンプレートを初期化できません。" } , { ER_RESULT_NULL , "結果はヌルにはならないはずです。" } , { ER_RESULT_COULD_NOT_BE_SET , "結果を設定できませんでした。" } , { ER_NO_OUTPUT_SPECIFIED , "出力が指定されていません。" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "タイプ {0} の結果に変換できません" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "タイプ {0} のソースを変換できません" } , { ER_NULL_CONTENT_HANDLER , "ヌルのコンテンツ・ハンドラー" } , { ER_NULL_ERROR_HANDLER , "ヌルのエラー・ハンドラー" } , { ER_CANNOT_CALL_PARSE , "ContentHandler が未設定の場合は parse の呼び出しはできません。" } , { ER_NO_PARENT_FOR_FILTER , "フィルターの親がありません。" } , { ER_NO_STYLESHEET_IN_MEDIA , "スタイルシートが {0}、メディア= {1} に見つかりません。" } , { ER_NO_STYLESHEET_PI , "XML スタイルシート PI が {0} に見つかりません。" } , { ER_NOT_SUPPORTED , "サポートされていません: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "プロパティー {0} の値はブール・インスタンスにする必要があります。" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "{0} の外部スクリプトへ到達できませんでした。" } , { ER_RESOURCE_COULD_NOT_FIND , "リソース [ {0} ] は見つかりませんでした。\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "出力プロパティーは認識されていません: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "ElemLiteralResult インスタンスの作成が失敗しました。" } , { ER_VALUE_SHOULD_BE_NUMBER , "{0} の値には構文解析可能番号が含まれているはずです。" } , { ER_VALUE_SHOULD_EQUAL , "{0} の値は yes または no と等しくなければなりません。" } , { ER_FAILED_CALLING_METHOD , "{0} メソッドの呼び出しが失敗しました。" } , { ER_FAILED_CREATING_ELEMTMPL , "ElemTemplateElement インスタンスの作成が失敗しました。" } , { ER_CHARS_NOT_ALLOWED , "文字は文書内のこのポイントでは許可されていません。" } , { ER_ATTR_NOT_ALLOWED , "\"{0}\" 属性は {1} エレメントでは許可されていません!" } , { ER_BAD_VALUE , "{0} の間違った値 {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "{0} 属性値が見つかりません。 " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "{0} 属性値は認識されません。 " } , { ER_NULL_URI_NAMESPACE , "ネーム・スペース接頭部をヌルの URI で生成しようとしています。" } , { ER_NUMBER_TOO_BIG , "最大 Long 整数より大きい数をフォーマットしようとしています。" } , { ER_CANNOT_FIND_SAX1_DRIVER , "SAX1 ドライバー・クラス {0} が見つかりません。" } , { ER_SAX1_DRIVER_NOT_LOADED , "SAX1 ドライバー・クラス {0} が見つかりましたがロードできません。" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "SAX1 ドライバー・クラス {0} がロードされましたがインスタンス生成できません。" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1 ドライバー・クラス {0} が org.xml.sax.Parser をインプリメントしていません。" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "システム・プロパティー org.xml.sax.parser は指定されていません。" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "パーサーの引き数をヌルにしてはなりません。" } , { ER_FEATURE , "フィーチャー: {0}" } , { ER_PROPERTY , "プロパティー: {0}" } , { ER_NULL_ENTITY_RESOLVER , "ヌル・エンティティー・リゾルバー" } , { ER_NULL_DTD_HANDLER , "ヌル DTD ハンドラー" } , { ER_NO_DRIVER_NAME_SPECIFIED , "ドライバー名が指定されていません!" } , { ER_NO_URL_SPECIFIED , "URL が指定されていません!" } , { ER_POOLSIZE_LESS_THAN_ONE , "プール・サイズが 1 より小です!" } , { ER_INVALID_DRIVER_NAME , "無効なドライバー名が指定されました!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "プログラマーのエラー! expr には ElemTemplateElement 親がありません!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "RedundentExprEliminator 内のプログラマーのアサーション: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} はスタイルシートのこの位置では許可されません!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "空白文字以外のテキストはスタイルシートのこの位置では許可されません!" } , { INVALID_TCHAR , "正しくない値: {1} が CHAR 属性: {0} に使用されました。CHAR タイプの属性は 1 文字でなければなりません!" } , { INVALID_QNAME , "正しくない値: {1} が QNAME 属性: {0} に使用されました。" } , { INVALID_ENUM , "正しくない値: {1} が ENUM 属性: {0} に使用されました。  有効値: {2}。" } , { INVALID_NMTOKEN , "正しくない値: {1} が NMTOKEN 属性: {0} に使用されました。 " } , { INVALID_NCNAME , "正しくない値: {1} が NCNAME 属性: {0} に使用されました。 " } , { INVALID_BOOLEAN , "正しくない値: {1} が boolean 属性: {0} に使用されました。 " } , { INVALID_NUMBER , "正しくない値: {1} が number 属性: {0} に使用されました。 " } , { ER_ARG_LITERAL , "マッチング・パターンの {0} への引き数はリテラルでなければなりません。" } , { ER_DUPLICATE_GLOBAL_VAR , "グローバル変数宣言が重複しています。" } , { ER_DUPLICATE_VAR , "変数宣言が重複しています。" } , { ER_TEMPLATE_NAME_MATCH , "xsl:template には name または match 属性 (あるいはその両方) が必要です。" } , { ER_INVALID_PREFIX , "exclude-result-prefixes 内の接頭部が無効です: {0}" } , { ER_NO_ATTRIB_SET , "{0} という名前の attribute-set が存在していません。" } , { WG_FOUND_CURLYBRACE , "'}' が見つかりましたが、オープンされた属性テンプレートがありません!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "警告: count 属性が xsl:number 内の上位と一致しません! ターゲット = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "旧構文: 'expr' 属性の名前が 'select' に変更されています。" } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan はフォーマット番号関数内でまだロケール名を処理しません。" } , { WG_LOCALE_NOT_FOUND , "警告: xml:lang={0} のロケールが見つかりませんでした。" } , { WG_CANNOT_MAKE_URL_FROM , "URL を {0} から作成できません。" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "要求された doc: {0} をロードできません。" } , { WG_CANNOT_FIND_COLLATOR , "<sort xml:lang={0} のコレーターが見つかりませんでした。" } , { WG_FUNCTIONS_SHOULD_USE_URL , "旧構文: 関数命令では {0} の URL を使用する必要があります。" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "エンコードはサポートされません: {0}、UTF-8 を使用中。" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "エンコードはサポートされません: {0}、Java {1} を使用中。" } , { WG_SPECIFICITY_CONFLICTS , "限定性の矛盾が検出されました: {0} スタイルシート内で最後に検出されたものが使用されます。" } , { WG_PARSING_AND_PREPARING , "========= {0} を構文解析中および準備中 ==========" } , { WG_ATTR_TEMPLATE , "属性テンプレート {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "xsl:strip-space と xsl:preserve-space の間のマッチングの矛盾" } , { WG_ATTRIB_NOT_HANDLED , "Xalan はまだ {0} 属性を処理しません!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "10 進数形式の宣言が見つかりません: {0}" } , { WG_OLD_XSLT_NS , "XSLT ネーム・スペースがないか誤っています。" } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "デフォルトの xsl:decimal-format 宣言は 1 つしか許可されていません。" } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format 名は固有でなければなりません。 名前 \"{0}\" が重複していました。" } , { WG_ILLEGAL_ATTRIBUTE , "{0} に正しくない属性があります: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "ネーム・スペース接頭部を解決できませんでした: {0}。 ノードは無視されます。" } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet には 'version' 属性が必要です!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "正しくない属性名: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "属性 {0}: {1} に使用された値は正しくありません。" } , { WG_EMPTY_SECOND_ARG , "文書機能の 2 番目の引き数から得られた nodeset が空です。空の node-set を戻します。" } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "xsl:processing-instruction 名の 'name' 属性の値は 'xml' であってはなりません。" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "xsl:processing-instruction の 'name' 属性の値は有効な NCName でなければなりません: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "下位ノードの後またはエレメントが生成される前に属性 {0} を追加できません。属性は無視されます。" } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "createMessage へのパラメーターが境界外でした。" } , { "FORMAT_FAILED" , "messageFormat 呼び出し中に例外がスローされました。" } , { "version" , ">>>>>>> Xalan バージョン " } , { "version2" , "<<<<<<<" } , { "yes" , "はい" } , { "line" , "行 #" } , { "column" , "桁 #" } , { "xsldone" , "XSLProcessor: 完了" } , { "xslProc_option" , "Xalan-J コマンド行 Process クラス・オプション" } , { "xslProc_option" , "Xalan-J コマンド行 Process クラス・オプション:" } , { "xslProc_invalid_xsltc_option" , "オプション {0} は XSLTC モードではサポートされていません。" } , { "xslProc_invalid_xalan_option" , "オプション {0} は -XSLTC と一緒にしか使用できません。" } , { "xslProc_no_input" , "エラー: スタイルシートがないか入力 xml が指定されていません。 使用法の説明については、オプションなしでこのコマンドを実行してください。" } , { "xslProc_common_options" , "-共通オプション-" } , { "xslProc_xalan_options" , "-Xalan 用オプション-" } , { "xslProc_xsltc_options" , "-XSLTC 用オプション-" } , { "xslProc_return_to_continue" , "(続けるには <return> を押してください)" } , { "optionXSLTC" , "   [-XSLTC (変換に XSLTC を使用)]" } , { "optionIN" , "   [-IN inputXMLURL]" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER parser liaison の完全修飾クラス名]" } , { "optionE" , "   [-E (エンティティー ref を拡張しない)]" } , { "optionV" , "   [-E (エンティティー ref を拡張しない)]" } , { "optionQC" , "   [-QC (静止パターン矛盾警告)]" } , { "optionQ" , "   [-Q  (静止モード)]" } , { "optionLF" , "[-LF (LF (改行) を出力時のみに使用  {デフォルトは CR/LF})]" } , { "optionCR" , "[-CR (CR (復帰) を出力時のみに使用 {デフォルトは CR/LF})]" } , { "optionESCAPE" , "[-ESCAPE (エスケープする文字 {デフォルトは <>&\"\'\\r\\n}]" } , { "optionINDENT" , "[-INDENT (字下げするスペースを制御 {デフォルトは 0})]" } , { "optionTT" , "   [-TT (テンプレートを呼び出し中にトレース。)]" } , { "optionTG" , "   [-TG (各生成イベントをトレース。)]" } , { "optionTS" , "   [-TS (各選択イベントをトレース。)]" } , { "optionTTC" , "   [-TTC (テンプレートの子を呼び出し中にトレース。)]" } , { "optionTCLASS" , "   [-TCLASS (トレース拡張機能の TraceListener クラス。)]" } , { "optionVALIDATE" , "   [-VALIDATE (妥当性検査を実行するかどうかを設定。  デフォルトでは、妥当性検査はオフです。)]" } , { "optionEDUMP" , "[-EDUMP {optional filename} (エラー時に stackdump を実行。)]" } , { "optionXML" , "   [-XML (XML フォーマッターを使用および XML ヘッダーを追加。)]" } , { "optionTEXT" , "   [-TEXT (シンプル・テキスト・フォーマッターを使用。)]" } , { "optionHTML" , "   [-HTML (HTML フォーマッターを使用。)]" } , { "optionPARAM" , "   [-PARAM 名前式 (stylesheet パラメーターを設定。)]" } , { "noParsermsg1" , "XSL 処理は成功しませんでした。" } , { "noParsermsg2" , "** パーサーが見つかりませんでした **" } , { "noParsermsg3" , "クラスパスを調べてください。" } , { "noParsermsg4" , "IBM の XML Parser for Java がない場合は、次のサイトからダウンロードできます:" } , { "noParsermsg5" , "IBM AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER 絶対クラス名 (URI を解決するために使用する URIResolver)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER 絶対クラス名 (エンティティーを解決するために使用する EntityResolver)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER 絶対クラス名 (出力をシリアライズするために使用する ContentHandler)]" } , { "optionLINENUMBERS" , "   [-L ソース・ドキュメントの行番号を使用]" } , { "optionMEDIA" , "   [-MEDIA mediaType (文書と関連したスタイルシートを検索するメディア属性を使用。)]" } , { "optionFLAVOR" , "   [-FLAVOR flavorName (変換を実行するために s2s=SAX または d2d=DOM を明示的に使用。)]" } , { "optionDIAG" , "   [-DIAG (変換にかかった全ミリ秒を印刷。)]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL (http://xml.apache.org/xalan/features/incremental を true に設定することにより増分 DTM 構造を要求。)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE (http://xml.apache.org/xalan/features/optimize を false に設定することによりスタイルシート最適化処理なしを要求。)]" } , { "optionRL" , "   [-RL recursionlimit (スタイルシートの再帰の深さについての数値限界を主張。)]" } , { "optionXO" , "   [-XO [transletName] (名前を生成後の translet に割り当て)]" } , { "optionXD" , "   [-XD destinationDirectory (宛先ディレクトリーを translet に指定)]" } , { "optionXJ" , "   [-XJ jarfile (translet クラスを名前 <jarfile> の jar ファイルにパッケージします)]" } , { "optionXP" , "   [-XP package (パッケージ名接頭部をすべての生成後の translet クラスに指定します)]" } , { "optionXN" , "   [-XN (テンプレートをインラインで使用可能にします)]" } , { "optionXX" , "   [-XX (追加のデバッグ・メッセージ出力をオンにします)]" } , { "optionXT" , "   [-XT (可能な場合は translet を使用して変換)]" } , { "diagTiming" , "--------- {0} の {1} による変換には {2} ミリ秒かかりました" } , { "recursionTooDeep" , "テンプレートのネストが深すぎます。 ネスト = {0}、テンプレート {1} {2}" } , { "nameIs" , "名前は" } , { "matchPatternIs" , "マッチング・パターンは" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "エラー: " ; public static final String WARNING_HEADER = "警告: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '0', '1', '16', '8', '0', '1', '3', '1.24795082', '4275', '0', '0', '0.926829268', '0.333333333', '0', '0', '805.2', '2', '0.8', '1']
package org . apache . xml . serializer ; import org . apache . xml . utils . StringToIntTable ; public final class ElemDesc { int m_flags ; StringToIntTable m_attrs = null ; public static final int EMPTY = ( 1 << 1 ) ; public static final int FLOW = ( 1 << 2 ) ; public static final int BLOCK = ( 1 << 3 ) ; public static final int BLOCKFORM = ( 1 << 4 ) ; public static final int BLOCKFORMFIELDSET = ( 1 << 5 ) ; public static final int CDATA = ( 1 << 6 ) ; public static final int PCDATA = ( 1 << 7 ) ; public static final int RAW = ( 1 << 8 ) ; public static final int INLINE = ( 1 << 9 ) ; public static final int INLINEA = ( 1 << 10 ) ; public static final int INLINELABEL = ( 1 << 11 ) ; public static final int FONTSTYLE = ( 1 << 12 ) ; public static final int PHRASE = ( 1 << 13 ) ; public static final int FORMCTRL = ( 1 << 14 ) ; public static final int SPECIAL = ( 1 << 15 ) ; public static final int ASPECIAL = ( 1 << 16 ) ; public static final int HEADMISC = ( 1 << 17 ) ; public static final int HEAD = ( 1 << 18 ) ; public static final int LIST = ( 1 << 19 ) ; public static final int PREFORMATTED = ( 1 << 20 ) ; public static final int WHITESPACESENSITIVE = ( 1 << 21 ) ; public static final int HEADELEM = ( 1 << 22 ) ; public static final int ATTRURL = ( 1 << 1 ) ; public static final int ATTREMPTY = ( 1 << 2 ) ; public ElemDesc ( int flags ) { m_flags = flags ; } public boolean is ( int flags ) { return ( m_flags & flags ) != 0 ; } public int getFlags ( ) { return m_flags ; } public void setAttr ( String name , int flags ) { if ( null == m_attrs ) m_attrs = new StringToIntTable ( ) ; m_attrs . put ( name , flags ) ; } public boolean isAttrFlagSet ( String name , int flags ) { return ( null != m_attrs ) ? ( ( m_attrs . getIgnoreCase ( name ) & flags ) != 0 ) : false ; } } 	1	['5', '1', '0', '6', '9', '0', '5', '1', '5', '1.192307692', '84', '0', '1', '0', '0.733333333', '0', '0', '10.6', '3', '1.6', '1']
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XSLTErrorResources extends ListResourceBundle { public static final int MAX_CODE = 201 ; public static final int MAX_WARNING = 29 ; public static final int MAX_OTHERS = 55 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ER_NO_CURLYBRACE = "ER_NO_CURLYBRACE" ; public static final String ER_FUNCTION_NOT_SUPPORTED = "ER_FUNCTION_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIBUTE = "ER_ILLEGAL_ATTRIBUTE" ; public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = "ER_NULL_SOURCENODE_APPLYIMPORTS" ; public static final String ER_CANNOT_ADD = "ER_CANNOT_ADD" ; public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = "ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES" ; public static final String ER_NO_NAME_ATTRIB = "ER_NO_NAME_ATTRIB" ; public static final String ER_TEMPLATE_NOT_FOUND = "ER_TEMPLATE_NOT_FOUND" ; public static final String ER_CANT_RESOLVE_NAME_AVT = "ER_CANT_RESOLVE_NAME_AVT" ; public static final String ER_REQUIRES_ATTRIB = "ER_REQUIRES_ATTRIB" ; public static final String ER_MUST_HAVE_TEST_ATTRIB = "ER_MUST_HAVE_TEST_ATTRIB" ; public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB = "ER_BAD_VAL_ON_LEVEL_ATTRIB" ; public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String ER_NEED_MATCH_ATTRIB = "ER_NEED_MATCH_ATTRIB" ; public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = "ER_NEED_NAME_OR_MATCH_ATTRIB" ; public static final String ER_CANT_RESOLVE_NSPREFIX = "ER_CANT_RESOLVE_NSPREFIX" ; public static final String ER_ILLEGAL_VALUE = "ER_ILLEGAL_VALUE" ; public static final String ER_NO_OWNERDOC = "ER_NO_OWNERDOC" ; public static final String ER_ELEMTEMPLATEELEM_ERR = "ER_ELEMTEMPLATEELEM_ERR" ; public static final String ER_NULL_CHILD = "ER_NULL_CHILD" ; public static final String ER_NEED_SELECT_ATTRIB = "ER_NEED_SELECT_ATTRIB" ; public static final String ER_NEED_TEST_ATTRIB = "ER_NEED_TEST_ATTRIB" ; public static final String ER_NEED_NAME_ATTRIB = "ER_NEED_NAME_ATTRIB" ; public static final String ER_NO_CONTEXT_OWNERDOC = "ER_NO_CONTEXT_OWNERDOC" ; public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = "ER_COULD_NOT_CREATE_XML_PROC_LIAISON" ; public static final String ER_PROCESS_NOT_SUCCESSFUL = "ER_PROCESS_NOT_SUCCESSFUL" ; public static final String ER_NOT_SUCCESSFUL = "ER_NOT_SUCCESSFUL" ; public static final String ER_ENCODING_NOT_SUPPORTED = "ER_ENCODING_NOT_SUPPORTED" ; public static final String ER_COULD_NOT_CREATE_TRACELISTENER = "ER_COULD_NOT_CREATE_TRACELISTENER" ; public static final String ER_KEY_REQUIRES_NAME_ATTRIB = "ER_KEY_REQUIRES_NAME_ATTRIB" ; public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = "ER_KEY_REQUIRES_MATCH_ATTRIB" ; public static final String ER_KEY_REQUIRES_USE_ATTRIB = "ER_KEY_REQUIRES_USE_ATTRIB" ; public static final String ER_REQUIRES_ELEMENTS_ATTRIB = "ER_REQUIRES_ELEMENTS_ATTRIB" ; public static final String ER_MISSING_PREFIX_ATTRIB = "ER_MISSING_PREFIX_ATTRIB" ; public static final String ER_BAD_STYLESHEET_URL = "ER_BAD_STYLESHEET_URL" ; public static final String ER_FILE_NOT_FOUND = "ER_FILE_NOT_FOUND" ; public static final String ER_IOEXCEPTION = "ER_IOEXCEPTION" ; public static final String ER_NO_HREF_ATTRIB = "ER_NO_HREF_ATTRIB" ; public static final String ER_STYLESHEET_INCLUDES_ITSELF = "ER_STYLESHEET_INCLUDES_ITSELF" ; public static final String ER_PROCESSINCLUDE_ERROR = "ER_PROCESSINCLUDE_ERROR" ; public static final String ER_MISSING_LANG_ATTRIB = "ER_MISSING_LANG_ATTRIB" ; public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = "ER_MISSING_CONTAINER_ELEMENT_COMPONENT" ; public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = "ER_CAN_ONLY_OUTPUT_TO_ELEMENT" ; public static final String ER_PROCESS_ERROR = "ER_PROCESS_ERROR" ; public static final String ER_UNIMPLNODE_ERROR = "ER_UNIMPLNODE_ERROR" ; public static final String ER_NO_SELECT_EXPRESSION = "ER_NO_SELECT_EXPRESSION" ; public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = "ER_CANNOT_SERIALIZE_XSLPROCESSOR" ; public static final String ER_NO_INPUT_STYLESHEET = "ER_NO_INPUT_STYLESHEET" ; public static final String ER_FAILED_PROCESS_STYLESHEET = "ER_FAILED_PROCESS_STYLESHEET" ; public static final String ER_COULDNT_PARSE_DOC = "ER_COULDNT_PARSE_DOC" ; public static final String ER_COULDNT_FIND_FRAGMENT = "ER_COULDNT_FIND_FRAGMENT" ; public static final String ER_NODE_NOT_ELEMENT = "ER_NODE_NOT_ELEMENT" ; public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = "ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = "ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB" ; public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = "ER_NO_CLONE_OF_DOCUMENT_FRAG" ; public static final String ER_CANT_CREATE_ITEM = "ER_CANT_CREATE_ITEM" ; public static final String ER_XMLSPACE_ILLEGAL_VALUE = "ER_XMLSPACE_ILLEGAL_VALUE" ; public static final String ER_NO_XSLKEY_DECLARATION = "ER_NO_XSLKEY_DECLARATION" ; public static final String ER_CANT_CREATE_URL = "ER_CANT_CREATE_URL" ; public static final String ER_XSLFUNCTIONS_UNSUPPORTED = "ER_XSLFUNCTIONS_UNSUPPORTED" ; public static final String ER_PROCESSOR_ERROR = "ER_PROCESSOR_ERROR" ; public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = "ER_NOT_ALLOWED_INSIDE_STYLESHEET" ; public static final String ER_RESULTNS_NOT_SUPPORTED = "ER_RESULTNS_NOT_SUPPORTED" ; public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = "ER_DEFAULTSPACE_NOT_SUPPORTED" ; public static final String ER_INDENTRESULT_NOT_SUPPORTED = "ER_INDENTRESULT_NOT_SUPPORTED" ; public static final String ER_ILLEGAL_ATTRIB = "ER_ILLEGAL_ATTRIB" ; public static final String ER_UNKNOWN_XSL_ELEM = "ER_UNKNOWN_XSL_ELEM" ; public static final String ER_BAD_XSLSORT_USE = "ER_BAD_XSLSORT_USE" ; public static final String ER_MISPLACED_XSLWHEN = "ER_MISPLACED_XSLWHEN" ; public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_MISPLACED_XSLOTHERWISE = "ER_MISPLACED_XSLOTHERWISE" ; public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = "ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE" ; public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = "ER_NOT_ALLOWED_INSIDE_TEMPLATE" ; public static final String ER_UNKNOWN_EXT_NS_PREFIX = "ER_UNKNOWN_EXT_NS_PREFIX" ; public static final String ER_IMPORTS_AS_FIRST_ELEM = "ER_IMPORTS_AS_FIRST_ELEM" ; public static final String ER_IMPORTING_ITSELF = "ER_IMPORTING_ITSELF" ; public static final String ER_XMLSPACE_ILLEGAL_VAL = "ER_XMLSPACE_ILLEGAL_VAL" ; public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = "ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL" ; public static final String ER_SAX_EXCEPTION = "ER_SAX_EXCEPTION" ; public static final String ER_XSLT_ERROR = "ER_XSLT_ERROR" ; public static final String ER_CURRENCY_SIGN_ILLEGAL = "ER_CURRENCY_SIGN_ILLEGAL" ; public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = "ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM" ; public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = "ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER" ; public static final String ER_REDIRECT_COULDNT_GET_FILENAME = "ER_REDIRECT_COULDNT_GET_FILENAME" ; public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = "ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT" ; public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = "ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX" ; public static final String ER_MISSING_NS_URI = "ER_MISSING_NS_URI" ; public static final String ER_MISSING_ARG_FOR_OPTION = "ER_MISSING_ARG_FOR_OPTION" ; public static final String ER_INVALID_OPTION = "ER_INVALID_OPTION" ; public static final String ER_MALFORMED_FORMAT_STRING = "ER_MALFORMED_FORMAT_STRING" ; public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = "ER_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = "ER_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String ER_CHOOSE_REQUIRES_WHEN = "ER_CHOOSE_REQUIRES_WHEN" ; public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = "ER_NO_APPLY_IMPORT_IN_FOR_EACH" ; public static final String ER_CANT_USE_DTM_FOR_OUTPUT = "ER_CANT_USE_DTM_FOR_OUTPUT" ; public static final String ER_CANT_USE_DTM_FOR_INPUT = "ER_CANT_USE_DTM_FOR_INPUT" ; public static final String ER_CALL_TO_EXT_FAILED = "ER_CALL_TO_EXT_FAILED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_XSLATTRSET_USED_ITSELF = "ER_XSLATTRSET_USED_ITSELF" ; public static final String ER_CANNOT_MIX_XERCESDOM = "ER_CANNOT_MIX_XERCESDOM" ; public static final String ER_TOO_MANY_LISTENERS = "ER_TOO_MANY_LISTENERS" ; public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = "ER_IN_ELEMTEMPLATEELEM_READOBJECT" ; public static final String ER_DUPLICATE_NAMED_TEMPLATE = "ER_DUPLICATE_NAMED_TEMPLATE" ; public static final String ER_INVALID_KEY_CALL = "ER_INVALID_KEY_CALL" ; public static final String ER_REFERENCING_ITSELF = "ER_REFERENCING_ITSELF" ; public static final String ER_ILLEGAL_DOMSOURCE_INPUT = "ER_ILLEGAL_DOMSOURCE_INPUT" ; public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = "ER_CLASS_NOT_FOUND_FOR_OPTION" ; public static final String ER_REQUIRED_ELEM_NOT_FOUND = "ER_REQUIRED_ELEM_NOT_FOUND" ; public static final String ER_INPUT_CANNOT_BE_NULL = "ER_INPUT_CANNOT_BE_NULL" ; public static final String ER_URI_CANNOT_BE_NULL = "ER_URI_CANNOT_BE_NULL" ; public static final String ER_FILE_CANNOT_BE_NULL = "ER_FILE_CANNOT_BE_NULL" ; public static final String ER_SOURCE_CANNOT_BE_NULL = "ER_SOURCE_CANNOT_BE_NULL" ; public static final String ER_CANNOT_INIT_BSFMGR = "ER_CANNOT_INIT_BSFMGR" ; public static final String ER_CANNOT_CMPL_EXTENSN = "ER_CANNOT_CMPL_EXTENSN" ; public static final String ER_CANNOT_CREATE_EXTENSN = "ER_CANNOT_CREATE_EXTENSN" ; public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = "ER_INSTANCE_MTHD_CALL_REQUIRES" ; public static final String ER_INVALID_ELEMENT_NAME = "ER_INVALID_ELEMENT_NAME" ; public static final String ER_ELEMENT_NAME_METHOD_STATIC = "ER_ELEMENT_NAME_METHOD_STATIC" ; public static final String ER_EXTENSION_FUNC_UNKNOWN = "ER_EXTENSION_FUNC_UNKNOWN" ; public static final String ER_MORE_MATCH_CONSTRUCTOR = "ER_MORE_MATCH_CONSTRUCTOR" ; public static final String ER_MORE_MATCH_METHOD = "ER_MORE_MATCH_METHOD" ; public static final String ER_MORE_MATCH_ELEMENT = "ER_MORE_MATCH_ELEMENT" ; public static final String ER_INVALID_CONTEXT_PASSED = "ER_INVALID_CONTEXT_PASSED" ; public static final String ER_POOL_EXISTS = "ER_POOL_EXISTS" ; public static final String ER_NO_DRIVER_NAME = "ER_NO_DRIVER_NAME" ; public static final String ER_NO_URL = "ER_NO_URL" ; public static final String ER_POOL_SIZE_LESSTHAN_ONE = "ER_POOL_SIZE_LESSTHAN_ONE" ; public static final String ER_INVALID_DRIVER = "ER_INVALID_DRIVER" ; public static final String ER_NO_STYLESHEETROOT = "ER_NO_STYLESHEETROOT" ; public static final String ER_ILLEGAL_XMLSPACE_VALUE = "ER_ILLEGAL_XMLSPACE_VALUE" ; public static final String ER_PROCESSFROMNODE_FAILED = "ER_PROCESSFROMNODE_FAILED" ; public static final String ER_RESOURCE_COULD_NOT_LOAD = "ER_RESOURCE_COULD_NOT_LOAD" ; public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = "ER_BUFFER_SIZE_LESSTHAN_ZERO" ; public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = "ER_UNKNOWN_ERROR_CALLING_EXTENSION" ; public static final String ER_NO_NAMESPACE_DECL = "ER_NO_NAMESPACE_DECL" ; public static final String ER_ELEM_CONTENT_NOT_ALLOWED = "ER_ELEM_CONTENT_NOT_ALLOWED" ; public static final String ER_STYLESHEET_DIRECTED_TERMINATION = "ER_STYLESHEET_DIRECTED_TERMINATION" ; public static final String ER_ONE_OR_TWO = "ER_ONE_OR_TWO" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_COULD_NOT_LOAD_RESOURCE = "ER_COULD_NOT_LOAD_RESOURCE" ; public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = "ER_CANNOT_INIT_DEFAULT_TEMPLATES" ; public static final String ER_RESULT_NULL = "ER_RESULT_NULL" ; public static final String ER_RESULT_COULD_NOT_BE_SET = "ER_RESULT_COULD_NOT_BE_SET" ; public static final String ER_NO_OUTPUT_SPECIFIED = "ER_NO_OUTPUT_SPECIFIED" ; public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = "ER_CANNOT_TRANSFORM_TO_RESULT_TYPE" ; public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = "ER_CANNOT_TRANSFORM_SOURCE_TYPE" ; public static final String ER_NULL_CONTENT_HANDLER = "ER_NULL_CONTENT_HANDLER" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_CANNOT_CALL_PARSE = "ER_CANNOT_CALL_PARSE" ; public static final String ER_NO_PARENT_FOR_FILTER = "ER_NO_PARENT_FOR_FILTER" ; public static final String ER_NO_STYLESHEET_IN_MEDIA = "ER_NO_STYLESHEET_IN_MEDIA" ; public static final String ER_NO_STYLESHEET_PI = "ER_NO_STYLESHEET_PI" ; public static final String ER_NOT_SUPPORTED = "ER_NOT_SUPPORTED" ; public static final String ER_PROPERTY_VALUE_BOOLEAN = "ER_PROPERTY_VALUE_BOOLEAN" ; public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = "ER_COULD_NOT_FIND_EXTERN_SCRIPT" ; public static final String ER_RESOURCE_COULD_NOT_FIND = "ER_RESOURCE_COULD_NOT_FIND" ; public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = "ER_OUTPUT_PROPERTY_NOT_RECOGNIZED" ; public static final String ER_FAILED_CREATING_ELEMLITRSLT = "ER_FAILED_CREATING_ELEMLITRSLT" ; public static final String ER_VALUE_SHOULD_BE_NUMBER = "ER_VALUE_SHOULD_BE_NUMBER" ; public static final String ER_VALUE_SHOULD_EQUAL = "ER_VALUE_SHOULD_EQUAL" ; public static final String ER_FAILED_CALLING_METHOD = "ER_FAILED_CALLING_METHOD" ; public static final String ER_FAILED_CREATING_ELEMTMPL = "ER_FAILED_CREATING_ELEMTMPL" ; public static final String ER_CHARS_NOT_ALLOWED = "ER_CHARS_NOT_ALLOWED" ; public static final String ER_ATTR_NOT_ALLOWED = "ER_ATTR_NOT_ALLOWED" ; public static final String ER_BAD_VALUE = "ER_BAD_VALUE" ; public static final String ER_ATTRIB_VALUE_NOT_FOUND = "ER_ATTRIB_VALUE_NOT_FOUND" ; public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = "ER_ATTRIB_VALUE_NOT_RECOGNIZED" ; public static final String ER_NULL_URI_NAMESPACE = "ER_NULL_URI_NAMESPACE" ; public static final String ER_NUMBER_TOO_BIG = "ER_NUMBER_TOO_BIG" ; public static final String ER_CANNOT_FIND_SAX1_DRIVER = "ER_CANNOT_FIND_SAX1_DRIVER" ; public static final String ER_SAX1_DRIVER_NOT_LOADED = "ER_SAX1_DRIVER_NOT_LOADED" ; public static final String ER_SAX1_DRIVER_NOT_INSTANTIATED = "ER_SAX1_DRIVER_NOT_INSTANTIATED" ; public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = "ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER" ; public static final String ER_PARSER_PROPERTY_NOT_SPECIFIED = "ER_PARSER_PROPERTY_NOT_SPECIFIED" ; public static final String ER_PARSER_ARG_CANNOT_BE_NULL = "ER_PARSER_ARG_CANNOT_BE_NULL" ; public static final String ER_FEATURE = "ER_FEATURE" ; public static final String ER_PROPERTY = "ER_PROPERTY" ; public static final String ER_NULL_ENTITY_RESOLVER = "ER_NULL_ENTITY_RESOLVER" ; public static final String ER_NULL_DTD_HANDLER = "ER_NULL_DTD_HANDLER" ; public static final String ER_NO_DRIVER_NAME_SPECIFIED = "ER_NO_DRIVER_NAME_SPECIFIED" ; public static final String ER_NO_URL_SPECIFIED = "ER_NO_URL_SPECIFIED" ; public static final String ER_POOLSIZE_LESS_THAN_ONE = "ER_POOLSIZE_LESS_THAN_ONE" ; public static final String ER_INVALID_DRIVER_NAME = "ER_INVALID_DRIVER_NAME" ; public static final String ER_ERRORLISTENER = "ER_ERRORLISTENER" ; public static final String ER_ASSERT_NO_TEMPLATE_PARENT = "ER_ASSERT_NO_TEMPLATE_PARENT" ; public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = "ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR" ; public static final String ER_NOT_ALLOWED_IN_POSITION = "ER_NOT_ALLOWED_IN_POSITION" ; public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = "ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION" ; public static final String INVALID_TCHAR = "INVALID_TCHAR" ; public static final String INVALID_QNAME = "INVALID_QNAME" ; public static final String INVALID_ENUM = "INVALID_ENUM" ; public static final String INVALID_NMTOKEN = "INVALID_NMTOKEN" ; public static final String INVALID_NCNAME = "INVALID_NCNAME" ; public static final String INVALID_BOOLEAN = "INVALID_BOOLEAN" ; public static final String INVALID_NUMBER = "INVALID_NUMBER" ; public static final String ER_ARG_LITERAL = "ER_ARG_LITERAL" ; public static final String ER_DUPLICATE_GLOBAL_VAR = "ER_DUPLICATE_GLOBAL_VAR" ; public static final String ER_DUPLICATE_VAR = "ER_DUPLICATE_VAR" ; public static final String ER_TEMPLATE_NAME_MATCH = "ER_TEMPLATE_NAME_MATCH" ; public static final String ER_INVALID_PREFIX = "ER_INVALID_PREFIX" ; public static final String ER_NO_ATTRIB_SET = "ER_NO_ATTRIB_SET" ; public static final String ER_FUNCTION_NOT_FOUND = "ER_FUNCTION_NOT_FOUND" ; public static final String ER_CANT_HAVE_CONTENT_AND_SELECT = "ER_CANT_HAVE_CONTENT_AND_SELECT" ; public static final String ER_INVALID_SET_PARAM_VALUE = "ER_INVALID_SET_PARAM_VALUE" ; public static final String WG_FOUND_CURLYBRACE = "WG_FOUND_CURLYBRACE" ; public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = "WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR" ; public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = "WG_EXPR_ATTRIB_CHANGED_TO_SELECT" ; public static final String WG_NO_LOCALE_IN_FORMATNUMBER = "WG_NO_LOCALE_IN_FORMATNUMBER" ; public static final String WG_LOCALE_NOT_FOUND = "WG_LOCALE_NOT_FOUND" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_CANNOT_LOAD_REQUESTED_DOC = "WG_CANNOT_LOAD_REQUESTED_DOC" ; public static final String WG_CANNOT_FIND_COLLATOR = "WG_CANNOT_FIND_COLLATOR" ; public static final String WG_FUNCTIONS_SHOULD_USE_URL = "WG_FUNCTIONS_SHOULD_USE_URL" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = "WG_ENCODING_NOT_SUPPORTED_USING_UTF8" ; public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = "WG_ENCODING_NOT_SUPPORTED_USING_JAVA" ; public static final String WG_SPECIFICITY_CONFLICTS = "WG_SPECIFICITY_CONFLICTS" ; public static final String WG_PARSING_AND_PREPARING = "WG_PARSING_AND_PREPARING" ; public static final String WG_ATTR_TEMPLATE = "WG_ATTR_TEMPLATE" ; public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = "WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP" ; public static final String WG_ATTRIB_NOT_HANDLED = "WG_ATTRIB_NOT_HANDLED" ; public static final String WG_NO_DECIMALFORMAT_DECLARATION = "WG_NO_DECIMALFORMAT_DECLARATION" ; public static final String WG_OLD_XSLT_NS = "WG_OLD_XSLT_NS" ; public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = "WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED" ; public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = "WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE" ; public static final String WG_ILLEGAL_ATTRIBUTE = "WG_ILLEGAL_ATTRIBUTE" ; public static final String WG_COULD_NOT_RESOLVE_PREFIX = "WG_COULD_NOT_RESOLVE_PREFIX" ; public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = "WG_STYLESHEET_REQUIRES_VERSION_ATTRIB" ; public static final String WG_ILLEGAL_ATTRIBUTE_NAME = "WG_ILLEGAL_ATTRIBUTE_NAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = "WG_ILLEGAL_ATTRIBUTE_VALUE" ; public static final String WG_EMPTY_SECOND_ARG = "WG_EMPTY_SECOND_ARG" ; public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = "WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML" ; public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = "WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME" ; public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = "WG_ILLEGAL_ATTRIBUTE_POSITION" ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_NO_CURLYBRACE , "Error: Can not have '{' within expression" } , { ER_ILLEGAL_ATTRIBUTE , "{0} has an illegal attribute: {1}" } , { ER_NULL_SOURCENODE_APPLYIMPORTS , "sourceNode is null in xsl:apply-imports!" } , { ER_CANNOT_ADD , "Can not add {0} to {1}" } , { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES , "sourceNode is null in handleApplyTemplatesInstruction!" } , { ER_NO_NAME_ATTRIB , "{0} must have a name attribute." } , { ER_TEMPLATE_NOT_FOUND , "Could not find template named: {0}" } , { ER_CANT_RESOLVE_NAME_AVT , "Could not resolve name AVT in xsl:call-template." } , { ER_REQUIRES_ATTRIB , "{0} requires attribute: {1}" } , { ER_MUST_HAVE_TEST_ATTRIB , "{0} must have a ''test'' attribute." } , { ER_BAD_VAL_ON_LEVEL_ATTRIB , "Bad value on level attribute: {0}" } , { ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "processing-instruction name can not be 'xml'" } , { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "processing-instruction name must be a valid NCName: {0}" } , { ER_NEED_MATCH_ATTRIB , "{0} must have a match attribute if it has a mode." } , { ER_NEED_NAME_OR_MATCH_ATTRIB , "{0} requires either a name or a match attribute." } , { ER_CANT_RESOLVE_NSPREFIX , "Can not resolve namespace prefix: {0}" } , { ER_ILLEGAL_VALUE , "xml:space has an illegal value: {0}" } , { ER_NO_OWNERDOC , "Child node does not have an owner document!" } , { ER_ELEMTEMPLATEELEM_ERR , "ElemTemplateElement error: {0}" } , { ER_NULL_CHILD , "Trying to add a null child!" } , { ER_NEED_SELECT_ATTRIB , "{0} requires a select attribute." } , { ER_NEED_TEST_ATTRIB , "xsl:when must have a 'test' attribute." } , { ER_NEED_NAME_ATTRIB , "xsl:with-param must have a 'name' attribute." } , { ER_NO_CONTEXT_OWNERDOC , "context does not have an owner document!" } , { ER_COULD_NOT_CREATE_XML_PROC_LIAISON , "Could not create XML TransformerFactory Liaison: {0}" } , { ER_PROCESS_NOT_SUCCESSFUL , "Xalan: Process was not successful." } , { ER_NOT_SUCCESSFUL , "Xalan: was not successful." } , { ER_ENCODING_NOT_SUPPORTED , "Encoding not supported: {0}" } , { ER_COULD_NOT_CREATE_TRACELISTENER , "Could not create TraceListener: {0}" } , { ER_KEY_REQUIRES_NAME_ATTRIB , "xsl:key requires a 'name' attribute!" } , { ER_KEY_REQUIRES_MATCH_ATTRIB , "xsl:key requires a 'match' attribute!" } , { ER_KEY_REQUIRES_USE_ATTRIB , "xsl:key requires a 'use' attribute!" } , { ER_REQUIRES_ELEMENTS_ATTRIB , "(StylesheetHandler) {0} requires an ''elements'' attribute!" } , { ER_MISSING_PREFIX_ATTRIB , "(StylesheetHandler) {0} attribute ''prefix'' is missing" } , { ER_BAD_STYLESHEET_URL , "Stylesheet URL is bad: {0}" } , { ER_FILE_NOT_FOUND , "Stylesheet file was not found: {0}" } , { ER_IOEXCEPTION , "Had IO Exception with stylesheet file: {0}" } , { ER_NO_HREF_ATTRIB , "(StylesheetHandler) Could not find href attribute for {0}" } , { ER_STYLESHEET_INCLUDES_ITSELF , "(StylesheetHandler) {0} is directly or indirectly including itself!" } , { ER_PROCESSINCLUDE_ERROR , "StylesheetHandler.processInclude error, {0}" } , { ER_MISSING_LANG_ATTRIB , "(StylesheetHandler) {0} attribute ''lang'' is missing" } , { ER_MISSING_CONTAINER_ELEMENT_COMPONENT , "(StylesheetHandler) misplaced {0} element?? Missing container element ''component''" } , { ER_CAN_ONLY_OUTPUT_TO_ELEMENT , "Can only output to an Element, DocumentFragment, Document, or PrintWriter." } , { ER_PROCESS_ERROR , "StylesheetRoot.process error" } , { ER_UNIMPLNODE_ERROR , "UnImplNode error: {0}" } , { ER_NO_SELECT_EXPRESSION , "Error! Did not find xpath select expression (-select)." } , { ER_CANNOT_SERIALIZE_XSLPROCESSOR , "Can not serialize an XSLProcessor!" } , { ER_NO_INPUT_STYLESHEET , "Stylesheet input was not specified!" } , { ER_FAILED_PROCESS_STYLESHEET , "Failed to process stylesheet!" } , { ER_COULDNT_PARSE_DOC , "Could not parse {0} document!" } , { ER_COULDNT_FIND_FRAGMENT , "Could not find fragment: {0}" } , { ER_NODE_NOT_ELEMENT , "Node pointed to by fragment identifier was not an element: {0}" } , { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB , "for-each must have either a match or name attribute" } , { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB , "templates must have either a match or name attribute" } , { ER_NO_CLONE_OF_DOCUMENT_FRAG , "No clone of a document fragment!" } , { ER_CANT_CREATE_ITEM , "Can not create item in result tree: {0}" } , { ER_XMLSPACE_ILLEGAL_VALUE , "xml:space in the source XML has an illegal value: {0}" } , { ER_NO_XSLKEY_DECLARATION , "There is no xsl:key declaration for {0}!" } , { ER_CANT_CREATE_URL , "Error! Cannot create url for: {0}" } , { ER_XSLFUNCTIONS_UNSUPPORTED , "xsl:functions is unsupported" } , { ER_PROCESSOR_ERROR , "XSLT TransformerFactory Error" } , { ER_NOT_ALLOWED_INSIDE_STYLESHEET , "(StylesheetHandler) {0} not allowed inside a stylesheet!" } , { ER_RESULTNS_NOT_SUPPORTED , "result-ns no longer supported!  Use xsl:output instead." } , { ER_DEFAULTSPACE_NOT_SUPPORTED , "default-space no longer supported!  Use xsl:strip-space or xsl:preserve-space instead." } , { ER_INDENTRESULT_NOT_SUPPORTED , "indent-result no longer supported!  Use xsl:output instead." } , { ER_ILLEGAL_ATTRIB , "(StylesheetHandler) {0} has an illegal attribute: {1}" } , { ER_UNKNOWN_XSL_ELEM , "Unknown XSL element: {0}" } , { ER_BAD_XSLSORT_USE , "(StylesheetHandler) xsl:sort can only be used with xsl:apply-templates or xsl:for-each." } , { ER_MISPLACED_XSLWHEN , "(StylesheetHandler) misplaced xsl:when!" } , { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:when not parented by xsl:choose!" } , { ER_MISPLACED_XSLOTHERWISE , "(StylesheetHandler) misplaced xsl:otherwise!" } , { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE , "(StylesheetHandler) xsl:otherwise not parented by xsl:choose!" } , { ER_NOT_ALLOWED_INSIDE_TEMPLATE , "(StylesheetHandler) {0} is not allowed inside a template!" } , { ER_UNKNOWN_EXT_NS_PREFIX , "(StylesheetHandler) {0} extension namespace prefix {1} unknown" } , { ER_IMPORTS_AS_FIRST_ELEM , "(StylesheetHandler) Imports can only occur as the first elements in the stylesheet!" } , { ER_IMPORTING_ITSELF , "(StylesheetHandler) {0} is directly or indirectly importing itself!" } , { ER_XMLSPACE_ILLEGAL_VAL , "(StylesheetHandler) " + "xml:space has an illegal value: {0}" } , { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL , "processStylesheet not succesfull!" } , { ER_SAX_EXCEPTION , "SAX Exception" } , { ER_FUNCTION_NOT_SUPPORTED , "Function not supported!" } , { ER_XSLT_ERROR , "XSLT Error" } , { ER_CURRENCY_SIGN_ILLEGAL , "currency sign is not allowed in format pattern string" } , { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM , "Document function not supported in Stylesheet DOM!" } , { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER , "Can't resolve prefix of non-Prefix resolver!" } , { ER_REDIRECT_COULDNT_GET_FILENAME , "Redirect extension: Could not get filename - file or select attribute must return vald string." } , { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT , "Can not build FormatterListener in Redirect extension!" } , { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX , "Prefix in exclude-result-prefixes is not valid: {0}" } , { ER_MISSING_NS_URI , "Missing namespace URI for specified prefix" } , { ER_MISSING_ARG_FOR_OPTION , "Missing argument for option: {0}" } , { ER_INVALID_OPTION , "Invalid option: {0}" } , { ER_MALFORMED_FORMAT_STRING , "Malformed format string: {0}" } , { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet requires a 'version' attribute!" } , { ER_ILLEGAL_ATTRIBUTE_VALUE , "Attribute: {0} has an illegal value: {1}" } , { ER_CHOOSE_REQUIRES_WHEN , "xsl:choose requires an xsl:when" } , { ER_NO_APPLY_IMPORT_IN_FOR_EACH , "xsl:apply-imports not allowed in a xsl:for-each" } , { ER_CANT_USE_DTM_FOR_OUTPUT , "Cannot use a DTMLiaison for an output DOM node... pass a org.apache.xpath.DOM2Helper instead!" } , { ER_CANT_USE_DTM_FOR_INPUT , "Cannot use a DTMLiaison for a input DOM node... pass a org.apache.xpath.DOM2Helper instead!" } , { ER_CALL_TO_EXT_FAILED , "Call to extension element failed: {0}" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_INVALID_UTF16_SURROGATE , "Invalid UTF-16 surrogate detected: {0} ?" } , { ER_XSLATTRSET_USED_ITSELF , "xsl:attribute-set {0} used itself, which will cause an infinite loop." } , { ER_CANNOT_MIX_XERCESDOM , "Can not mix non Xerces-DOM input with Xerces-DOM output!" } , { ER_TOO_MANY_LISTENERS , "addTraceListenersToStylesheet - TooManyListenersException" } , { ER_IN_ELEMTEMPLATEELEM_READOBJECT , "In ElemTemplateElement.readObject: {0}" } , { ER_DUPLICATE_NAMED_TEMPLATE , "Found more than one template named: {0}" } , { ER_INVALID_KEY_CALL , "Invalid function call: recursive key() calls are not allowed" } , { ER_REFERENCING_ITSELF , "Variable {0} is directly or indirectly referencing itself!" } , { ER_ILLEGAL_DOMSOURCE_INPUT , "The input node can not be null for a DOMSource for newTemplates!" } , { ER_CLASS_NOT_FOUND_FOR_OPTION , "Class file not found for option {0}" } , { ER_REQUIRED_ELEM_NOT_FOUND , "Required Element not found: {0}" } , { ER_INPUT_CANNOT_BE_NULL , "InputStream cannot be null" } , { ER_URI_CANNOT_BE_NULL , "URI cannot be null" } , { ER_FILE_CANNOT_BE_NULL , "File cannot be null" } , { ER_SOURCE_CANNOT_BE_NULL , "InputSource cannot be null" } , { ER_CANNOT_INIT_BSFMGR , "Could not initialize BSF Manager" } , { ER_CANNOT_CMPL_EXTENSN , "Could not compile extension" } , { ER_CANNOT_CREATE_EXTENSN , "Could not create extension: {0} because of: {1}" } , { ER_INSTANCE_MTHD_CALL_REQUIRES , "Instance method call to method {0} requires an Object instance as first argument" } , { ER_INVALID_ELEMENT_NAME , "Invalid element name specified {0}" } , { ER_ELEMENT_NAME_METHOD_STATIC , "Element name method must be static {0}" } , { ER_EXTENSION_FUNC_UNKNOWN , "Extension function {0} : {1} is unknown" } , { ER_MORE_MATCH_CONSTRUCTOR , "More than one best match for constructor for {0}" } , { ER_MORE_MATCH_METHOD , "More than one best match for method {0}" } , { ER_MORE_MATCH_ELEMENT , "More than one best match for element method {0}" } , { ER_INVALID_CONTEXT_PASSED , "Invalid context passed to evaluate {0}" } , { ER_POOL_EXISTS , "Pool already exists" } , { ER_NO_DRIVER_NAME , "No driver Name specified" } , { ER_NO_URL , "No URL specified" } , { ER_POOL_SIZE_LESSTHAN_ONE , "Pool size is less than one!" } , { ER_INVALID_DRIVER , "Invalid driver name specified!" } , { ER_NO_STYLESHEETROOT , "Did not find the stylesheet root!" } , { ER_ILLEGAL_XMLSPACE_VALUE , "Illegal value for xml:space" } , { ER_PROCESSFROMNODE_FAILED , "processFromNode failed" } , { ER_RESOURCE_COULD_NOT_LOAD , "The resource [ {0} ] could not load: {1} \n {2} \t {3}" } , { ER_BUFFER_SIZE_LESSTHAN_ZERO , "Buffer size <=0" } , { ER_UNKNOWN_ERROR_CALLING_EXTENSION , "Unknown error when calling extension" } , { ER_NO_NAMESPACE_DECL , "Prefix {0} does not have a corresponding namespace declaration" } , { ER_ELEM_CONTENT_NOT_ALLOWED , "Element content not allowed for lang=javaclass {0}" } , { ER_STYLESHEET_DIRECTED_TERMINATION , "Stylesheet directed termination" } , { ER_ONE_OR_TWO , "1 or 2" } , { ER_TWO_OR_THREE , "2 or 3" } , { ER_COULD_NOT_LOAD_RESOURCE , "Could not load {0} (check CLASSPATH), now using just the defaults" } , { ER_CANNOT_INIT_DEFAULT_TEMPLATES , "Cannot initialize default templates" } , { ER_RESULT_NULL , "Result should not be null" } , { ER_RESULT_COULD_NOT_BE_SET , "Result could not be set" } , { ER_NO_OUTPUT_SPECIFIED , "No output specified" } , { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE , "Can''t transform to a Result of type {0}" } , { ER_CANNOT_TRANSFORM_SOURCE_TYPE , "Can''t transform a Source of type {0}" } , { ER_NULL_CONTENT_HANDLER , "Null content handler" } , { ER_NULL_ERROR_HANDLER , "Null error handler" } , { ER_CANNOT_CALL_PARSE , "parse can not be called if the ContentHandler has not been set" } , { ER_NO_PARENT_FOR_FILTER , "No parent for filter" } , { ER_NO_STYLESHEET_IN_MEDIA , "No stylesheet found in: {0}, media= {1}" } , { ER_NO_STYLESHEET_PI , "No xml-stylesheet PI found in: {0}" } , { ER_NOT_SUPPORTED , "Not supported: {0}" } , { ER_PROPERTY_VALUE_BOOLEAN , "Value for property {0} should be a Boolean instance" } , { ER_COULD_NOT_FIND_EXTERN_SCRIPT , "Could not get to external script at {0}" } , { ER_RESOURCE_COULD_NOT_FIND , "The resource [ {0} ] could not be found.\n {1}" } , { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , "Output property not recognized: {0}" } , { ER_FAILED_CREATING_ELEMLITRSLT , "Failed creating ElemLiteralResult instance" } , { ER_VALUE_SHOULD_BE_NUMBER , "Value for {0} should contain a parsable number" } , { ER_VALUE_SHOULD_EQUAL , "Value for {0} should equal yes or no" } , { ER_FAILED_CALLING_METHOD , "Failed calling {0} method" } , { ER_FAILED_CREATING_ELEMTMPL , "Failed creating ElemTemplateElement instance" } , { ER_CHARS_NOT_ALLOWED , "Characters are not allowed at this point in the document" } , { ER_ATTR_NOT_ALLOWED , "\"{0}\" attribute is not allowed on the {1} element!" } , { ER_BAD_VALUE , "{0} bad value {1} " } , { ER_ATTRIB_VALUE_NOT_FOUND , "{0} attribute value not found " } , { ER_ATTRIB_VALUE_NOT_RECOGNIZED , "{0} attribute value not recognized " } , { ER_NULL_URI_NAMESPACE , "Attempting to generate a namespace prefix with a null URI" } , { ER_NUMBER_TOO_BIG , "Attempting to format a number bigger than the largest Long integer" } , { ER_CANNOT_FIND_SAX1_DRIVER , "Cannot find SAX1 driver class {0}" } , { ER_SAX1_DRIVER_NOT_LOADED , "SAX1 driver class {0} found but cannot be loaded" } , { ER_SAX1_DRIVER_NOT_INSTANTIATED , "SAX1 driver class {0} loaded but cannot be instantiated" } , { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER , "SAX1 driver class {0} does not implement org.xml.sax.Parser" } , { ER_PARSER_PROPERTY_NOT_SPECIFIED , "System property org.xml.sax.parser not specified" } , { ER_PARSER_ARG_CANNOT_BE_NULL , "Parser argument must not be null" } , { ER_FEATURE , "Feature: {0}" } , { ER_PROPERTY , "Property: {0}" } , { ER_NULL_ENTITY_RESOLVER , "Null entity resolver" } , { ER_NULL_DTD_HANDLER , "Null DTD handler" } , { ER_NO_DRIVER_NAME_SPECIFIED , "No Driver Name Specified!" } , { ER_NO_URL_SPECIFIED , "No URL Specified!" } , { ER_POOLSIZE_LESS_THAN_ONE , "Pool size is less than 1!" } , { ER_INVALID_DRIVER_NAME , "Invalid Driver Name Specified!" } , { ER_ERRORLISTENER , "ErrorListener" } , { ER_ASSERT_NO_TEMPLATE_PARENT , "Programmer's error! The expression has no ElemTemplateElement parent!" } , { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , "Programmer''s assertion in RedundentExprEliminator: {0}" } , { ER_NOT_ALLOWED_IN_POSITION , "{0} is not allowed in this position in the stylesheet!" } , { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION , "Non-whitespace text is not allowed in this position in the stylesheet!" } , { INVALID_TCHAR , "Illegal value: {1} used for CHAR attribute: {0}.  An attribute of type CHAR must be only 1 character!" } , { INVALID_QNAME , "Illegal value: {1} used for QNAME attribute: {0}" } , { INVALID_ENUM , "Illegal value: {1} used for ENUM attribute: {0}.  Valid values are: {2}." } , { INVALID_NMTOKEN , "Illegal value: {1} used for NMTOKEN attribute: {0} " } , { INVALID_NCNAME , "Illegal value: {1} used for NCNAME attribute: {0} " } , { INVALID_BOOLEAN , "Illegal value: {1} used for boolean attribute: {0} " } , { INVALID_NUMBER , "Illegal value: {1} used for number attribute: {0} " } , { ER_ARG_LITERAL , "Argument to {0} in match pattern must be a literal." } , { ER_DUPLICATE_GLOBAL_VAR , "Duplicate global variable declaration." } , { ER_DUPLICATE_VAR , "Duplicate variable declaration." } , { ER_TEMPLATE_NAME_MATCH , "xsl:template must have a name or match attribute (or both)" } , { ER_INVALID_PREFIX , "Prefix in exclude-result-prefixes is not valid: {0}" } , { ER_NO_ATTRIB_SET , "attribute-set named {0} does not exist" } , { ER_FUNCTION_NOT_FOUND , "The function named {0} does not exist" } , { ER_CANT_HAVE_CONTENT_AND_SELECT , "The {0} element must not have both content and a select attribute." } , { ER_INVALID_SET_PARAM_VALUE , "The value of param {0} must be a valid Java Object" } , { WG_FOUND_CURLYBRACE , "Found '}' but no attribute template open!" } , { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR , "Warning: count attribute does not match an ancestor in xsl:number! Target = {0}" } , { WG_EXPR_ATTRIB_CHANGED_TO_SELECT , "Old syntax: The name of the 'expr' attribute has been changed to 'select'." } , { WG_NO_LOCALE_IN_FORMATNUMBER , "Xalan doesn't yet handle the locale name in the format-number function." } , { WG_LOCALE_NOT_FOUND , "Warning: Could not find locale for xml:lang={0}" } , { WG_CANNOT_MAKE_URL_FROM , "Can not make URL from: {0}" } , { WG_CANNOT_LOAD_REQUESTED_DOC , "Can not load requested doc: {0}" } , { WG_CANNOT_FIND_COLLATOR , "Could not find Collator for <sort xml:lang={0}" } , { WG_FUNCTIONS_SHOULD_USE_URL , "Old syntax: the functions instruction should use a url of {0}" } , { WG_ENCODING_NOT_SUPPORTED_USING_UTF8 , "encoding not supported: {0}, using UTF-8" } , { WG_ENCODING_NOT_SUPPORTED_USING_JAVA , "encoding not supported: {0}, using Java {1}" } , { WG_SPECIFICITY_CONFLICTS , "Specificity conflicts found: {0} Last found in stylesheet will be used." } , { WG_PARSING_AND_PREPARING , "========= Parsing and preparing {0} ==========" } , { WG_ATTR_TEMPLATE , "Attr Template, {0}" } , { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE , "Match conflict between xsl:strip-space and xsl:preserve-space" } , { WG_ATTRIB_NOT_HANDLED , "Xalan does not yet handle the {0} attribute!" } , { WG_NO_DECIMALFORMAT_DECLARATION , "No declaration found for decimal format: {0}" } , { WG_OLD_XSLT_NS , "Missing or incorrect XSLT Namespace. " } , { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED , "Only one default xsl:decimal-format declaration is allowed." } , { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE , "xsl:decimal-format names must be unique. Name \"{0}\" has been duplicated." } , { WG_ILLEGAL_ATTRIBUTE , "{0} has an illegal attribute: {1}" } , { WG_COULD_NOT_RESOLVE_PREFIX , "Could not resolve namespace prefix: {0}. The node will be ignored." } , { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB , "xsl:stylesheet requires a 'version' attribute!" } , { WG_ILLEGAL_ATTRIBUTE_NAME , "Illegal attribute name: {0}" } , { WG_ILLEGAL_ATTRIBUTE_VALUE , "Illegal value used for attribute {0}: {1}" } , { WG_EMPTY_SECOND_ARG , "Resulting nodeset from second argument of document function is empty. Return an empty node-set." } , { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML , "The value of the 'name' attribute of xsl:processing-instruction name must not be 'xml'" } , { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME , "The value of the 'name' attribute of xsl:processing-instruction must be a valid NCName: {0}" } , { WG_ILLEGAL_ATTRIBUTE_POSITION , "Cannot add attribute {0} after child nodes or before an element is produced.  Attribute will be ignored." } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "Parameter to createMessage was out of bounds" } , { "FORMAT_FAILED" , "Exception thrown during messageFormat call" } , { "version" , ">>>>>>> Xalan Version " } , { "version2" , "<<<<<<<" } , { "yes" , "yes" } , { "line" , "Line #" } , { "column" , "Column #" } , { "xsldone" , "XSLProcessor: done" } , { "xslProc_option" , "Xalan-J command line Process class options:" } , { "xslProc_option" , "Xalan-J command line Process class options:" } , { "xslProc_invalid_xsltc_option" , "The option {0} is not supported in XSLTC mode." } , { "xslProc_invalid_xalan_option" , "The option {0} can only be used with -XSLTC." } , { "xslProc_no_input" , "Error: No stylesheet or input xml is specified. Run this command without any option for usage instructions." } , { "xslProc_common_options" , "-Common Options-" } , { "xslProc_xalan_options" , "-Options for Xalan-" } , { "xslProc_xsltc_options" , "-Options for XSLTC-" } , { "xslProc_return_to_continue" , "(press <return> to continue)" } , { "optionXSLTC" , "   [-XSLTC (use XSLTC for transformation)]" } , { "optionIN" , "   [-IN inputXMLURL]" } , { "optionXSL" , "   [-XSL XSLTransformationURL]" } , { "optionOUT" , "   [-OUT outputFileName]" } , { "optionLXCIN" , "   [-LXCIN compiledStylesheetFileNameIn]" } , { "optionLXCOUT" , "   [-LXCOUT compiledStylesheetFileNameOutOut]" } , { "optionPARSER" , "   [-PARSER fully qualified class name of parser liaison]" } , { "optionE" , "   [-E (Do not expand entity refs)]" } , { "optionV" , "   [-E (Do not expand entity refs)]" } , { "optionQC" , "   [-QC (Quiet Pattern Conflicts Warnings)]" } , { "optionQ" , "   [-Q  (Quiet Mode)]" } , { "optionLF" , "   [-LF (Use linefeeds only on output {default is CR/LF})]" } , { "optionCR" , "   [-CR (Use carriage returns only on output {default is CR/LF})]" } , { "optionESCAPE" , "   [-ESCAPE (Which characters to escape {default is <>&\"\'\\r\\n}]" } , { "optionINDENT" , "   [-INDENT (Control how many spaces to indent {default is 0})]" } , { "optionTT" , "   [-TT (Trace the templates as they are being called.)]" } , { "optionTG" , "   [-TG (Trace each generation event.)]" } , { "optionTS" , "   [-TS (Trace each selection event.)]" } , { "optionTTC" , "   [-TTC (Trace the template children as they are being processed.)]" } , { "optionTCLASS" , "   [-TCLASS (TraceListener class for trace extensions.)]" } , { "optionVALIDATE" , "   [-VALIDATE (Set whether validation occurs.  Validation is off by default.)]" } , { "optionEDUMP" , "   [-EDUMP {optional filename} (Do stackdump on error.)]" } , { "optionXML" , "   [-XML (Use XML formatter and add XML header.)]" } , { "optionTEXT" , "   [-TEXT (Use simple Text formatter.)]" } , { "optionHTML" , "   [-HTML (Use HTML formatter.)]" } , { "optionPARAM" , "   [-PARAM name expression (Set a stylesheet parameter)]" } , { "noParsermsg1" , "XSL Process was not successful." } , { "noParsermsg2" , "** Could not find parser **" } , { "noParsermsg3" , "Please check your classpath." } , { "noParsermsg4" , "If you don't have IBM's XML Parser for Java, you can download it from" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "optionURIRESOLVER" , "   [-URIRESOLVER full class name (URIResolver to be used to resolve URIs)]" } , { "optionENTITYRESOLVER" , "   [-ENTITYRESOLVER full class name (EntityResolver to be used to resolve entities)]" } , { "optionCONTENTHANDLER" , "   [-CONTENTHANDLER full class name (ContentHandler to be used to serialize output)]" } , { "optionLINENUMBERS" , "   [-L use line numbers for source document]" } , { "optionMEDIA" , "   [-MEDIA mediaType (use media attribute to find stylesheet associated with a document.)]" } , { "optionFLAVOR" , "   [-FLAVOR flavorName (Explicitly use s2s=SAX or d2d=DOM to do transform.)] " } , { "optionDIAG" , "   [-DIAG (Print overall milliseconds transform took.)]" } , { "optionINCREMENTAL" , "   [-INCREMENTAL (request incremental DTM construction by setting http://xml.apache.org/xalan/features/incremental true.)]" } , { "optionNOOPTIMIMIZE" , "   [-NOOPTIMIMIZE (request no stylesheet optimization processing by setting http://xml.apache.org/xalan/features/optimize false.)]" } , { "optionRL" , "   [-RL recursionlimit (assert numeric limit on stylesheet recursion depth.)]" } , { "optionXO" , "   [-XO [transletName] (assign the name to the generated translet)]" } , { "optionXD" , "   [-XD destinationDirectory (specify a destination directory for translet)]" } , { "optionXJ" , "   [-XJ jarfile (packages translet classes into a jar file of name <jarfile>)]" } , { "optionXP" , "   [-XP package (specifies a package name prefix for all generated translet classes)]" } , { "optionXN" , "   [-XN (enables template inlining)]" } , { "optionXX" , "   [-XX (turns on additional debugging message output)]" } , { "optionXT" , "   [-XT (use translet to transform if possible)]" } , { "diagTiming" , " --------- Transform of {0} via {1} took {2} ms" } , { "recursionTooDeep" , "Template nesting too deep. nesting = {0}, template {1} {2}" } , { "nameIs" , "name is" } , { "matchPatternIs" , "match pattern is" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Warning: " ; public static final String XSL_HEADER = "XSLT " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XSLTErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XSLTErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1	['5', '3', '2', '18', '16', '8', '18', '0', '3', '1.247983871', '4331', '0', '0', '0.926829268', '0.333333333', '0', '0', '815.6', '2', '0.8', '6']
package org . apache . xml . serializer ; import java . util . Vector ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . ext . LexicalHandler ; abstract public class ToSAXHandler extends SerializerBase { public ToSAXHandler ( ) { } public ToSAXHandler ( ContentHandler hdlr , LexicalHandler lex , String encoding ) { setContentHandler ( hdlr ) ; setLexHandler ( lex ) ; setEncoding ( encoding ) ; } public ToSAXHandler ( ContentHandler handler , String encoding ) { setContentHandler ( handler ) ; setEncoding ( encoding ) ; } protected ContentHandler m_saxHandler ; protected LexicalHandler m_lexHandler ; private boolean m_shouldGenerateNSAttribute = true ; protected TransformStateSetter m_state = null ; protected void startDocumentInternal ( ) throws SAXException { if ( m_needToCallStartDocument ) { super . startDocumentInternal ( ) ; m_saxHandler . startDocument ( ) ; m_needToCallStartDocument = false ; } } public void startDTD ( String arg0 , String arg1 , String arg2 ) throws SAXException { } public void characters ( String characters ) throws SAXException { final int len = characters . length ( ) ; if ( len > m_charsBuff . length ) { m_charsBuff = new char [ len * 2 + 1 ] ; } characters . getChars ( 0 , len , m_charsBuff , 0 ) ; characters ( m_charsBuff , 0 , len ) ; } public void comment ( String comment ) throws SAXException { if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; } else if ( m_cdataTagOpen ) { closeCDATA ( ) ; } if ( m_lexHandler != null ) { final int len = comment . length ( ) ; if ( len > m_charsBuff . length ) { m_charsBuff = new char [ len * 2 + 1 ] ; } comment . getChars ( 0 , len , m_charsBuff , 0 ) ; m_lexHandler . comment ( m_charsBuff , 0 , len ) ; if ( m_tracer != null ) super . fireCommentEvent ( m_charsBuff , 0 , len ) ; } } public void processingInstruction ( String target , String data ) throws SAXException { } protected void closeStartTag ( ) throws SAXException { } protected void closeCDATA ( ) throws SAXException { } public void startElement ( String arg0 , String arg1 , String arg2 , Attributes arg3 ) throws SAXException { if ( m_state != null ) { m_state . resetState ( getTransformer ( ) ) ; } if ( m_tracer != null ) super . fireStartElem ( arg2 ) ; } public void setLexHandler ( LexicalHandler _lexHandler ) { this . m_lexHandler = _lexHandler ; } public void setContentHandler ( ContentHandler _saxHandler ) { this . m_saxHandler = _saxHandler ; if ( m_lexHandler == null && _saxHandler instanceof LexicalHandler ) { m_lexHandler = ( LexicalHandler ) _saxHandler ; } } public void setCdataSectionElements ( Vector URI_and_localNames ) { } public void setShouldOutputNSAttr ( boolean doOutputNSAttr ) { m_shouldGenerateNSAttribute = doOutputNSAttr ; } boolean getShouldOutputNSAttr ( ) { return m_shouldGenerateNSAttribute ; } public void flushPending ( ) throws SAXException { if ( m_needToCallStartDocument ) { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; } if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } if ( m_cdataTagOpen ) { closeCDATA ( ) ; m_cdataTagOpen = false ; } } public void setTransformState ( TransformStateSetter ts ) { this . m_state = ts ; } public void startElement ( String uri , String localName , String qName ) throws SAXException { if ( m_state != null ) { m_state . resetState ( getTransformer ( ) ) ; } if ( m_tracer != null ) super . fireStartElem ( qName ) ; } public void startElement ( String qName ) throws SAXException { if ( m_state != null ) { m_state . resetState ( getTransformer ( ) ) ; } if ( m_tracer != null ) super . fireStartElem ( qName ) ; } public void characters ( org . w3c . dom . Node node ) throws org . xml . sax . SAXException { if ( m_state != null ) { m_state . setCurrentNode ( node ) ; } String data = node . getNodeValue ( ) ; if ( data != null ) { this . characters ( data ) ; } } public void fatalError ( SAXParseException exc ) throws SAXException { super . fatalError ( exc ) ; m_needToCallStartDocument = false ; if ( m_saxHandler instanceof ErrorHandler ) { ( ( ErrorHandler ) m_saxHandler ) . fatalError ( exc ) ; } } public void error ( SAXParseException exc ) throws SAXException { super . error ( exc ) ; if ( m_saxHandler instanceof ErrorHandler ) ( ( ErrorHandler ) m_saxHandler ) . error ( exc ) ; } public void warning ( SAXParseException exc ) throws SAXException { super . warning ( exc ) ; if ( m_saxHandler instanceof ErrorHandler ) ( ( ErrorHandler ) m_saxHandler ) . warning ( exc ) ; } public boolean reset ( ) { boolean wasReset = false ; if ( super . reset ( ) ) { resetToSAXHandler ( ) ; wasReset = true ; } return wasReset ; } private void resetToSAXHandler ( ) { this . m_lexHandler = null ; this . m_saxHandler = null ; this . m_state = null ; this . m_shouldGenerateNSAttribute = false ; } public void addUniqueAttribute ( String qName , String value , int flags ) throws SAXException { addAttribute ( qName , value ) ; } } 	1	['27', '2', '3', '8', '49', '207', '4', '4', '22', '0.711538462', '363', '1', '1', '0.783783784', '0.171717172', '1', '7', '12.2962963', '3', '1', '3']
package org . apache . xpath . functions ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . ExtensionsProvider ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XNull ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class FuncExtFunction extends Function { String m_namespace ; String m_extensionName ; Object m_methodKey ; Vector m_argVec = new Vector ( ) ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { if ( null != m_argVec ) { int nArgs = m_argVec . size ( ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { Expression arg = ( Expression ) m_argVec . elementAt ( i ) ; arg . fixupVariables ( vars , globalsSize ) ; } } } public String getNamespace ( ) { return m_namespace ; } public String getFunctionName ( ) { return m_extensionName ; } public Object getMethodKey ( ) { return m_methodKey ; } public Expression getArg ( int n ) { if ( n >= 0 && n < m_argVec . size ( ) ) return ( Expression ) m_argVec . elementAt ( n ) ; else return null ; } public int getArgCount ( ) { return m_argVec . size ( ) ; } public FuncExtFunction ( java . lang . String namespace , java . lang . String extensionName , Object methodKey ) { m_namespace = namespace ; m_extensionName = extensionName ; m_methodKey = methodKey ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject result ; Vector argVec = new Vector ( ) ; int nArgs = m_argVec . size ( ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { Expression arg = ( Expression ) m_argVec . elementAt ( i ) ; XObject xobj = arg . execute ( xctxt ) ; xobj . allowDetachToRelease ( false ) ; argVec . addElement ( xobj ) ; } ExtensionsProvider extProvider = ( ExtensionsProvider ) xctxt . getOwnerObject ( ) ; Object val = extProvider . extFunction ( this , argVec ) ; if ( null != val ) { result = XObject . create ( val , xctxt ) ; } else { result = new XNull ( ) ; } return result ; } public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { m_argVec . addElement ( arg ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { } class ArgExtOwner implements ExpressionOwner { Expression m_exp ; ArgExtOwner ( Expression exp ) { m_exp = exp ; } public Expression getExpression ( ) { return m_exp ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FuncExtFunction . this ) ; m_exp = exp ; } } public void callArgVisitors ( XPathVisitor visitor ) { for ( int i = 0 ; i < m_argVec . size ( ) ; i ++ ) { Expression exp = ( Expression ) m_argVec . elementAt ( i ) ; exp . callVisitors ( new ArgExtOwner ( exp ) , visitor ) ; } } public void exprSetParent ( ExpressionNode n ) { super . exprSetParent ( n ) ; int nArgs = m_argVec . size ( ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { Expression arg = ( Expression ) m_argVec . elementAt ( i ) ; arg . exprSetParent ( n ) ; } } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { "Programmer's assertion:  the method FunctionMultiArgs.reportWrongNumberArgs() should never be called." } ) ; throw new RuntimeException ( fMsg ) ; } } 	1	['13', '3', '0', '22', '31', '16', '12', '12', '12', '0.791666667', '210', '0', '0', '0.76', '0.205128205', '2', '9', '14.84615385', '3', '1.3846', '2']
package org . apache . xpath . domapi ; import org . apache . xml . utils . PrefixResolverDefault ; import org . w3c . dom . Node ; import org . w3c . dom . xpath . XPathNSResolver ; public class XPathNSResolverImpl extends PrefixResolverDefault implements XPathNSResolver { public XPathNSResolverImpl ( Node xpathExpressionContext ) { super ( xpathExpressionContext ) ; } public String lookupNamespaceURI ( String prefix ) { return super . getNamespaceForPrefix ( prefix ) ; } } 	1	['2', '2', '0', '2', '4', '1', '1', '1', '2', '2', '10', '0', '0', '0.8', '0.666666667', '0', '0', '4', '1', '0.5', '1']
package org . apache . xalan . processor ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemText ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . w3c . dom . Node ; public class ProcessorCharacters extends XSLTElementProcessor { public void startNonText ( StylesheetHandler handler ) throws org . xml . sax . SAXException { if ( this == handler . getCurrentProcessor ( ) ) { handler . popProcessor ( ) ; } int nChars = m_accumulator . length ( ) ; if ( ( nChars > 0 ) && ( ( null != m_xslTextElement ) || ! XMLCharacterRecognizer . isWhiteSpace ( m_accumulator ) ) || handler . isSpacePreserve ( ) ) { ElemTextLiteral elem = new ElemTextLiteral ( ) ; elem . setDOMBackPointer ( m_firstBackPointer ) ; elem . setLocaterInfo ( handler . getLocator ( ) ) ; try { elem . setPrefixes ( handler . getNamespaceSupport ( ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } boolean doe = ( null != m_xslTextElement ) ? m_xslTextElement . getDisableOutputEscaping ( ) : false ; elem . setDisableOutputEscaping ( doe ) ; elem . setPreserveSpace ( true ) ; char [ ] chars = new char [ nChars ] ; m_accumulator . getChars ( 0 , nChars , chars , 0 ) ; elem . setChars ( chars ) ; ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; parent . appendChild ( elem ) ; } m_accumulator . setLength ( 0 ) ; m_firstBackPointer = null ; } protected Node m_firstBackPointer = null ; public void characters ( StylesheetHandler handler , char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { m_accumulator . append ( ch , start , length ) ; if ( null == m_firstBackPointer ) m_firstBackPointer = handler . getOriginatingNode ( ) ; if ( this != handler . getCurrentProcessor ( ) ) handler . pushProcessor ( this ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { startNonText ( handler ) ; handler . getCurrentProcessor ( ) . endElement ( handler , uri , localName , rawName ) ; handler . popProcessor ( ) ; } private StringBuffer m_accumulator = new StringBuffer ( ) ; private ElemText m_xslTextElement ; void setXslTextElement ( ElemText xslTextElement ) { m_xslTextElement = xslTextElement ; } } 	1	['5', '4', '0', '9', '31', '2', '2', '7', '4', '0.333333333', '151', '1', '1', '0.981308411', '0.4', '1', '2', '28.6', '1', '0.8', '1']
package org . apache . xalan . lib . sql ; import java . util . Hashtable ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; public class ConnectionPoolManager { static Hashtable m_poolTable = null ; static boolean m_isInit = false ; public ConnectionPoolManager ( ) { init ( ) ; } public synchronized void init ( ) { if ( m_isInit == true ) return ; m_poolTable = new Hashtable ( ) ; m_isInit = true ; } public synchronized void registerPool ( String name , ConnectionPool pool ) { if ( m_poolTable . containsKey ( name ) ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_POOL_EXISTS , null ) ) ; } m_poolTable . put ( name , pool ) ; } public synchronized void removePool ( String name ) { ConnectionPool pool = getPool ( name ) ; if ( null != pool ) { pool . setPoolEnabled ( false ) ; if ( ! pool . hasActiveConnections ( ) ) m_poolTable . remove ( name ) ; } } public synchronized ConnectionPool getPool ( String name ) { return ( ConnectionPool ) m_poolTable . get ( name ) ; } } 	1	['6', '1', '0', '3', '16', '0', '1', '2', '5', '0.3', '69', '0', '0', '0', '0.6', '0', '0', '10.16666667', '3', '1.3333', '1']
package org . apache . xalan . xsltc . compiler . util ; public final class ErrorMessages_no extends ErrorMessages { private static final String m_errorMessages [ ] [ ] = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "En fil kan bare innehold ett stilark." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "<xsl:template> ''{0}'' er allerede definert i dette stilarket." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "<xsl:template> ''{0}'' er ikke definert i dette stilarket." } , { ErrorMsg . VARIABLE_REDEF_ERR , "Variabel ''{0}'' er allerede definert." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "Variabel eller parameter ''{0}'' er ikke definert." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "Finner ikke klassen ''{0}''." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "Finner ikke ekstern funksjon ''{0}'' (må v\00e6re deklarert både 'static' og 'public')." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Kan ikke konvertere argument/retur type i kall til funksjon ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "Finner ikke fil eller URI ''{0}''." } , { ErrorMsg . INVALID_URI_ERR , "Ugyldig URI ''{0}''." } , { ErrorMsg . FILE_ACCESS_ERR , "Kan ikke åpne fil eller URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "Forvented <xsl:stylesheet> eller <xsl:transform> element." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Prefiks ''{0}'' er ikke deklarert." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Kunne ikke resolvere kall til funksjon ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "Argument til ''{0}'' må v\00e6re ordrett tekst." } , { ErrorMsg . XPATH_PARSER_ERR , "Kunne ikke tolke XPath uttrykk ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Nødvendig attributt ''{0}'' er ikke deklarert." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Ugyldig bokstav/tegn ''{0}'' i XPath uttrykk." } , { ErrorMsg . ILLEGAL_PI_ERR , "Ugyldig navn ''{0}'' for prosesserings-instruksjon." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "Attributt ''{0}'' utenfor element." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Ugyldig attributt ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Sirkul \00e6 import/include; stilark ''{0}'' er alt lest." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Result-tre fragmenter kan ikke sorteres (<xsl:sort> elementer vil " + "bli ignorert). Du må sortere nodene mens du bygger treet." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Formatterings-symboler ''{0}'' er alt definert." } , { ErrorMsg . XSL_VERSION_ERR , "XSL versjon ''{0}'' er ikke støttet av XSLTC." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Sirkul\00e6r variabel/parameter referanse i ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Ugyldig operator for bin\00e6rt uttrykk." } , { ErrorMsg . ILLEGAL_ARG_ERR , "Ugyldig parameter i funksjons-kall." } , { ErrorMsg . DOCUMENT_ARG_ERR , "Andre argument til document() må v\00e6re et node-sett." } , { ErrorMsg . MISSING_WHEN_ERR , "Du må deklarere minst ett <xsl:when> element innenfor <xsl:choose>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "Kun ett <xsl:otherwise> element kan deklareres innenfor <xsl:choose>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> kan kun benyttes innenfor <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> kan kun benyttes innenfor <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "Kun <xsl:when> og <xsl:otherwise> kan benyttes innenfor <xsl:choose>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set> element manger 'name' attributt." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Ugyldig element." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "''{0}'' er ikke et gyldig navn for et element." } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "''{0}'' er ikke et gyldig navn for et attributt." } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Du kan ikke plassere tekst utenfor et <xsl:stylesheet> element." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "JAXP parser er ikke korrekt konfigurert." } , { ErrorMsg . INTERNAL_ERR , "XSLTC-intern feil: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Støtter ikke XSL element ''{0}''." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "XSLTC støtter ikke utvidet funksjon ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "Dette dokumentet er ikke et XSL stilark " + "(xmlns:xsl='http://www.w3.org/1999/XSL/Transform' er ikke deklarert)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Kan ikke finne stilark ved navn ''{0}'' i dette dokumentet." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Ikke implementert/gjenkjent: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "Dokumentet inneholder ikke et XSL stilark" } , { ErrorMsg . ELEMENT_PARSE_ERR , "Kan ikke tolke element ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "'use'-attributtet i <xsl:key> må v\00e6re node, node-sett, tekst eller nummer." } , { ErrorMsg . OUTPUT_VERSION_ERR , "Det genererte XML dokumentet må gis versjon 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Ugyldig operator for relasjons-uttrykk." } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Finner ikke <xsl:attribute-set> element med navn ''{0}''." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Kan ikke tolke attributt ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Ukjent data-type i signatur for klassen ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "Kan ikke oversette mellom data-type ''{0}'' og ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Dette Templates objected inneholder ingen translet klasse definisjon." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Dette Templates objected inneholder ingen klasse ved navn ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Kan ikke laste translet-klasse ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Translet klassen er lastet man kan instansieres." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "ErrorListener for ''{0}'' forsøkt satt til 'null'." } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "Kun StreamSource, SAXSource og DOMSOurce er støttet av XSLTC" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "Source objekt sendt til ''{0}'' har intet innhold." } , { ErrorMsg . JAXP_COMPILE_ERR , "Kan ikke kompilere stilark." } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory gjenkjenner ikke attributtet ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "setResult() må kalles før startDocument()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformer objektet inneholder ikken noen translet instans." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "Ingen 'handler' er satt for å ta imot generert dokument." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "Result objektet sendt til ''{0}'' er ikke gyldig." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Forsøker å lese ugyldig attributt ''{0}'' fra Transformer." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Kan ikke instansiere SAX2DOM adapter: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() kalt uten at 'systemId' er definert." } , { ErrorMsg . COMPILE_STDIN_ERR , "Du kan ikke bruke -i uten å også angi klasse-navn med -o." } , { ErrorMsg . COMPILE_USAGE_STR , "Bruk:\n" + "   xsltc [-o <klasse>] [-d <katalog>] [-j <arkiv>]\n" + "         [-p <pakke>] [-x] [-s] [-u] <stilark>|-i\n\n" + "   Der:  <klasse> er navnet du vil gi den kompilerte java klassen.\n" + "         <stilark> er ett eller flere XSL stilark, eller dersom -u\n" + "         er benyttet, en eller flere URL'er til stilark.\n" + "         <katalog> katalog der klasse filer vil plasseres.\n" + "         <arkiv> er en JAR-fil der klassene vil plasseres\n" + "         <pakke> er an Java 'package' klassene vil legges i.\n\n" + "   Annet:\n" + "         -i tvinger kompilatoren til å lese fra stdin.\n" + "         -o ignoreres dersom flere enn ett silark kompileres.\n" + "         -x slår på debug meldinger.\n" + "         -s blokkerer alle kall til System.exit()." } , { ErrorMsg . TRANSFORM_USAGE_STR , "Bruk: \n" + "   xslt  [-j <arkiv>] {-u <url> | <dokument>} <klasse>\n" + "         [<param>=<verdi> ...]\n\n" + "   Der:  <dokument> er XML dokumentet som skal behandles.\n" + "         <url> er en URL til XML dokumentet som skal behandles.\n" + "         <klasse> er Java klassen som skal benyttes.\n" + "         <arkiv> er en JAR-fil som klassen leses fra.\n" + "   Annet:\n" + "         -x slår på debug meldinger.\n" + "         -s blokkerer alle kall til System.exit()." } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> kan bare brukes under <xsl:for-each> eller <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "Karaktersett ''{0}'' er ikke støttet av denne JVM." } , { ErrorMsg . SYNTAX_ERR , "Syntax error in ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '4', '0', '1', '4', '1', '0', '1', '2', '0.5', '1014', '1', '0', '0.975', '1', '0', '0', '336.6666667', '1', '0.3333', '1']
package org . apache . xpath . compiler ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	1	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '1']
package org . apache . xpath . patterns ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . WalkerFactory ; import org . apache . xpath . objects . XObject ; public class ContextMatchStepPattern extends StepPattern { public ContextMatchStepPattern ( int axis , int paxis ) { super ( DTMFilter . SHOW_ALL , axis , paxis ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( xctxt . getIteratorRoot ( ) == xctxt . getCurrentNode ( ) ) return getStaticScore ( ) ; else return this . SCORE_NONE ; } public XObject executeRelativePathPattern ( XPathContext xctxt , StepPattern prevStep ) throws javax . xml . transform . TransformerException { XObject score = NodeTest . SCORE_NONE ; int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; if ( null != dtm ) { int predContext = xctxt . getCurrentNode ( ) ; DTMAxisTraverser traverser ; int axis = m_axis ; boolean needToTraverseAttrs = WalkerFactory . isDownwardAxisOfMany ( axis ) ; boolean iterRootIsAttr = ( dtm . getNodeType ( xctxt . getIteratorRoot ( ) ) == DTM . ATTRIBUTE_NODE ) ; if ( ( Axis . PRECEDING == axis ) && iterRootIsAttr ) { axis = Axis . PRECEDINGANDANCESTOR ; } traverser = dtm . getAxisTraverser ( axis ) ; for ( int relative = traverser . first ( context ) ; DTM . NULL != relative ; relative = traverser . next ( context , relative ) ) { try { xctxt . pushCurrentNode ( relative ) ; score = execute ( xctxt ) ; if ( score != NodeTest . SCORE_NONE ) { if ( executePredicates ( xctxt , dtm , context ) ) return score ; score = NodeTest . SCORE_NONE ; } if ( needToTraverseAttrs && iterRootIsAttr && ( DTM . ELEMENT_NODE == dtm . getNodeType ( relative ) ) ) { int xaxis = Axis . ATTRIBUTE ; for ( int i = 0 ; i < 2 ; i ++ ) { DTMAxisTraverser atraverser = dtm . getAxisTraverser ( xaxis ) ; for ( int arelative = atraverser . first ( relative ) ; DTM . NULL != arelative ; arelative = atraverser . next ( relative , arelative ) ) { try { xctxt . pushCurrentNode ( arelative ) ; score = execute ( xctxt ) ; if ( score != NodeTest . SCORE_NONE ) { if ( score != NodeTest . SCORE_NONE ) return score ; } } finally { xctxt . popCurrentNode ( ) ; } } xaxis = Axis . NAMESPACE ; } } } finally { xctxt . popCurrentNode ( ) ; } } } return score ; } } 	1	['3', '4', '0', '8', '16', '3', '1', '8', '3', '2', '176', '0', '0', '0.975903614', '0.583333333', '2', '12', '57.66666667', '1', '0.6667', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class ElemExsltFuncResult extends ElemVariable { public void execute ( TransformerImpl transformer ) throws TransformerException { XPathContext context = transformer . getXPathContext ( ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; if ( transformer . currentFuncResultSeen ( ) ) { throw new TransformerException ( "An EXSLT function cannot set more than one result!" ) ; } int sourceNode = context . getCurrentNode ( ) ; XObject var = getValue ( transformer , sourceNode ) ; transformer . popCurrentFuncResult ( ) ; transformer . pushCurrentFuncResult ( var ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public int getXSLToken ( ) { return Constants . EXSLT_ELEMNAME_FUNCRESULT ; } public String getNodeName ( ) { return Constants . EXSLT_ELEMNAME_FUNCRESULT_STRING ; } } 	1	['4', '4', '0', '9', '15', '6', '3', '6', '4', '2', '49', '0', '0', '0.986363636', '0.625', '3', '7', '11.25', '1', '0.75', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . VariableStack ; import org . apache . xpath . objects . XObject ; public class ElemParam extends ElemVariable { int m_qnameID ; public ElemParam ( ) { } public int getXSLToken ( ) { return Constants . ELEMNAME_PARAMVARIABLE ; } public String getNodeName ( ) { return Constants . ELEMNAME_PARAMVARIABLE_STRING ; } public ElemParam ( ElemParam param ) throws TransformerException { super ( param ) ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; m_qnameID = sroot . getComposeState ( ) . getQNameID ( m_qname ) ; int parentToken = m_parentNode . getXSLToken ( ) ; if ( parentToken == Constants . ELEMNAME_TEMPLATE || parentToken == Constants . EXSLT_ELEMNAME_FUNCTION ) ( ( ElemTemplate ) m_parentNode ) . m_inArgsSize ++ ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; VariableStack vars = transformer . getXPathContext ( ) . getVarStack ( ) ; if ( ! vars . isLocalSet ( m_index ) ) { int sourceNode = transformer . getXPathContext ( ) . getCurrentNode ( ) ; XObject var = getValue ( transformer , sourceNode ) ; transformer . getXPathContext ( ) . getVarStack ( ) . setLocalVariable ( m_index , var ) ; } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } 	1	['6', '4', '0', '18', '21', '15', '7', '11', '6', '1', '85', '0', '0', '0.981900452', '0.375', '3', '8', '13', '1', '0.6667', '2']
package org . apache . xpath . patterns ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FunctionPattern extends StepPattern { public FunctionPattern ( Expression expr , int axis , int predaxis ) { super ( 0 , null , null , axis , predaxis ) ; m_functionExpr = expr ; } public final void calcScore ( ) { m_score = SCORE_OTHER ; if ( null == m_targetString ) calcTargetString ( ) ; } Expression m_functionExpr ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; m_functionExpr . fixupVariables ( vars , globalsSize ) ; } public XObject execute ( XPathContext xctxt , int context ) throws javax . xml . transform . TransformerException { DTMIterator nl = m_functionExpr . asIterator ( xctxt , context ) ; XNumber score = SCORE_NONE ; if ( null != nl ) { int n ; while ( DTM . NULL != ( n = nl . nextNode ( ) ) ) { score = ( n == context ) ? SCORE_OTHER : SCORE_NONE ; if ( score == SCORE_OTHER ) { context = n ; break ; } } } nl . detach ( ) ; return score ; } public XObject execute ( XPathContext xctxt , int context , DTM dtm , int expType ) throws javax . xml . transform . TransformerException { DTMIterator nl = m_functionExpr . asIterator ( xctxt , context ) ; XNumber score = SCORE_NONE ; if ( null != nl ) { int n ; while ( DTM . NULL != ( n = nl . nextNode ( ) ) ) { score = ( n == context ) ? SCORE_OTHER : SCORE_NONE ; if ( score == SCORE_OTHER ) { context = n ; break ; } } nl . detach ( ) ; } return score ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = xctxt . getCurrentNode ( ) ; DTMIterator nl = m_functionExpr . asIterator ( xctxt , context ) ; XNumber score = SCORE_NONE ; if ( null != nl ) { int n ; while ( DTM . NULL != ( n = nl . nextNode ( ) ) ) { score = ( n == context ) ? SCORE_OTHER : SCORE_NONE ; if ( score == SCORE_OTHER ) { context = n ; break ; } } nl . detach ( ) ; } return score ; } class FunctionOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_functionExpr ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FunctionPattern . this ) ; m_functionExpr = exp ; } } protected void callSubtreeVisitors ( XPathVisitor visitor ) { m_functionExpr . callVisitors ( new FunctionOwner ( ) , visitor ) ; super . callSubtreeVisitors ( visitor ) ; } } 	1	['7', '4', '0', '12', '18', '0', '3', '10', '6', '0.166666667', '156', '0', '1', '0.931034483', '0.367346939', '3', '16', '21.14285714', '2', '1', '1']
package org . apache . xpath . objects ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . RTFIterator ; import org . w3c . dom . NodeList ; public class XRTreeFrag extends XObject implements Cloneable { DTM m_dtm ; int m_dtmRoot ; XPathContext m_xctxt ; boolean m_allowRelease = false ; public XRTreeFrag ( int root , XPathContext xctxt , ExpressionNode parent ) { super ( null ) ; exprSetParent ( parent ) ; m_dtmRoot = root ; m_xctxt = xctxt ; m_dtm = xctxt . getDTM ( root ) ; } public XRTreeFrag ( int root , XPathContext xctxt ) { super ( null ) ; m_dtmRoot = root ; m_xctxt = xctxt ; m_dtm = xctxt . getDTM ( root ) ; } public Object object ( ) { if ( m_xctxt != null ) return new org . apache . xml . dtm . ref . DTMNodeIterator ( ( DTMIterator ) ( new org . apache . xpath . NodeSetDTM ( m_dtmRoot , m_xctxt . getDTMManager ( ) ) ) ) ; else return super . object ( ) ; } public XRTreeFrag ( Expression expr ) { super ( expr ) ; } protected void finalize ( ) throws Throwable { try { destruct ( ) ; } finally { super . finalize ( ) ; } } public void allowDetachToRelease ( boolean allowRelease ) { m_allowRelease = allowRelease ; } public void detach ( ) { if ( m_allowRelease ) { int ident = m_xctxt . getDTMIdentity ( m_dtm ) ; DTM foundDTM = m_xctxt . getDTM ( ident ) ; if ( foundDTM == m_dtm ) { m_xctxt . release ( m_dtm , true ) ; m_dtm = null ; m_xctxt = null ; } m_obj = null ; } } public void destruct ( ) { if ( null != m_dtm ) { int ident = m_xctxt . getDTMIdentity ( m_dtm ) ; DTM foundDTM = m_xctxt . getDTM ( ident ) ; if ( foundDTM == m_dtm ) { m_xctxt . release ( m_dtm , true ) ; m_dtm = null ; m_xctxt = null ; } } m_obj = null ; } public int getType ( ) { return CLASS_RTREEFRAG ; } public String getTypeString ( ) { return "#RTREEFRAG" ; } public double num ( ) throws javax . xml . transform . TransformerException { XMLString s = xstr ( ) ; return s . toDouble ( ) ; } public boolean bool ( ) { return true ; } private XMLString m_xmlStr = null ; public XMLString xstr ( ) { if ( null == m_xmlStr ) m_xmlStr = m_dtm . getStringValue ( m_dtmRoot ) ; return m_xmlStr ; } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { XString xstring = ( XString ) xstr ( ) ; xstring . appendToFsb ( fsb ) ; } public String str ( ) { String str = m_dtm . getStringValue ( m_dtmRoot ) . toString ( ) ; return ( null == str ) ? "" : str ; } public int rtf ( ) { return m_dtmRoot ; } public DTMIterator asNodeIterator ( ) { return new RTFIterator ( m_dtmRoot , m_xctxt . getDTMManager ( ) ) ; } public NodeList convertToNodeset ( ) { if ( m_obj instanceof NodeList ) return ( NodeList ) m_obj ; else return new org . apache . xml . dtm . ref . DTMNodeList ( asNodeIterator ( ) ) ; } public boolean equals ( XObject obj2 ) { try { if ( XObject . CLASS_NODESET == obj2 . getType ( ) ) { return obj2 . equals ( this ) ; } else if ( XObject . CLASS_BOOLEAN == obj2 . getType ( ) ) { return bool ( ) == obj2 . bool ( ) ; } else if ( XObject . CLASS_NUMBER == obj2 . getType ( ) ) { return num ( ) == obj2 . num ( ) ; } else if ( XObject . CLASS_NODESET == obj2 . getType ( ) ) { return xstr ( ) . equals ( obj2 . xstr ( ) ) ; } else if ( XObject . CLASS_STRING == obj2 . getType ( ) ) { return xstr ( ) . equals ( obj2 . xstr ( ) ) ; } else if ( XObject . CLASS_RTREEFRAG == obj2 . getType ( ) ) { return xstr ( ) . equals ( obj2 . xstr ( ) ) ; } else { return super . equals ( obj2 ) ; } } catch ( javax . xml . transform . TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } } 	1	['19', '3', '1', '20', '42', '83', '5', '15', '18', '0.6', '332', '0.2', '3', '0.816091954', '0.184210526', '2', '24', '16.21052632', '9', '1.6842', '1']
package org . apache . xalan . templates ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . StackGuard ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . QName ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . xml . sax . SAXException ; public class ElemApplyTemplates extends ElemCallTemplate { private QName m_mode = null ; public void setMode ( QName mode ) { m_mode = mode ; } public QName getMode ( ) { return m_mode ; } private boolean m_isDefaultTemplate = false ; public void setIsDefaultTemplate ( boolean b ) { m_isDefaultTemplate = b ; } public int getXSLToken ( ) { return Constants . ELEMNAME_APPLY_TEMPLATES ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; } public String getNodeName ( ) { return Constants . ELEMNAME_APPLY_TEMPLATES_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { transformer . pushCurrentTemplateRuleIsNull ( false ) ; boolean pushMode = false ; try { QName mode = transformer . getMode ( ) ; if ( ! m_isDefaultTemplate ) { if ( ( ( null == mode ) && ( null != m_mode ) ) || ( ( null != mode ) && ! mode . equals ( m_mode ) ) ) { pushMode = true ; transformer . pushMode ( m_mode ) ; } } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; transformSelectedNodes ( transformer ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; if ( pushMode ) transformer . popMode ( ) ; transformer . popCurrentTemplateRuleIsNull ( ) ; } } public void transformSelectedNodes ( TransformerImpl transformer ) throws TransformerException { final XPathContext xctxt = transformer . getXPathContext ( ) ; final int sourceNode = xctxt . getCurrentNode ( ) ; DTMIterator sourceNodes = m_selectExpression . asIterator ( xctxt , sourceNode ) ; VariableStack vars = xctxt . getVarStack ( ) ; int nParams = getParamElemCount ( ) ; int thisframe = vars . getStackFrame ( ) ; StackGuard guard = transformer . getStackGuard ( ) ; boolean check = ( guard . getRecursionLimit ( ) > - 1 ) ? true : false ; boolean pushContextNodeListFlag = false ; try { xctxt . pushCurrentNode ( DTM . NULL ) ; xctxt . pushCurrentExpressionNode ( DTM . NULL ) ; xctxt . pushSAXLocatorNull ( ) ; transformer . pushElemTemplateElement ( null ) ; final Vector keys = ( m_sortElems == null ) ? null : transformer . processSortKeys ( this , sourceNode ) ; if ( null != keys ) sourceNodes = sortNodes ( xctxt , keys , sourceNodes ) ; if ( TransformerImpl . S_DEBUG ) { transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , new XPath ( m_selectExpression ) , new org . apache . xpath . objects . XNodeSet ( sourceNodes ) ) ; } final SerializationHandler rth = transformer . getSerializationHandler ( ) ; final StylesheetRoot sroot = transformer . getStylesheet ( ) ; final TemplateList tl = sroot . getTemplateListComposed ( ) ; final boolean quiet = transformer . getQuietConflictWarnings ( ) ; DTM dtm = xctxt . getDTM ( sourceNode ) ; int argsFrame = - 1 ; if ( nParams > 0 ) { argsFrame = vars . link ( nParams ) ; vars . setStackFrame ( thisframe ) ; for ( int i = 0 ; i < nParams ; i ++ ) { ElemWithParam ewp = m_paramElems [ i ] ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( ewp ) ; XObject obj = ewp . getValue ( transformer , sourceNode ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( ewp ) ; vars . setLocalVariable ( i , obj , argsFrame ) ; } vars . setStackFrame ( argsFrame ) ; } xctxt . pushContextNodeList ( sourceNodes ) ; pushContextNodeListFlag = true ; IntStack currentNodes = xctxt . getCurrentNodeStack ( ) ; IntStack currentExpressionNodes = xctxt . getCurrentExpressionNodeStack ( ) ; int child ; while ( DTM . NULL != ( child = sourceNodes . nextNode ( ) ) ) { currentNodes . setTop ( child ) ; currentExpressionNodes . setTop ( child ) ; if ( xctxt . getDTM ( child ) != dtm ) { dtm = xctxt . getDTM ( child ) ; } final int exNodeType = dtm . getExpandedTypeID ( child ) ; final int nodeType = dtm . getNodeType ( child ) ; final QName mode = transformer . getMode ( ) ; ElemTemplate template = tl . getTemplateFast ( xctxt , child , exNodeType , mode , - 1 , quiet , dtm ) ; if ( null == template ) { switch ( nodeType ) { case DTM . DOCUMENT_FRAGMENT_NODE : case DTM . ELEMENT_NODE : template = sroot . getDefaultRule ( ) ; break ; case DTM . ATTRIBUTE_NODE : case DTM . CDATA_SECTION_NODE : case DTM . TEXT_NODE : transformer . pushPairCurrentMatched ( sroot . getDefaultTextRule ( ) , child ) ; transformer . setCurrentElement ( sroot . getDefaultTextRule ( ) ) ; dtm . dispatchCharactersEvents ( child , rth , false ) ; transformer . popCurrentMatched ( ) ; continue ; case DTM . DOCUMENT_NODE : template = sroot . getDefaultRootRule ( ) ; break ; default : continue ; } } else { transformer . setCurrentElement ( template ) ; } transformer . pushPairCurrentMatched ( template , child ) ; if ( check ) guard . checkForInfinateLoop ( ) ; int currentFrameBottom ; if ( template . m_frameSize > 0 ) { xctxt . pushRTFContext ( ) ; currentFrameBottom = vars . getStackFrame ( ) ; vars . link ( template . m_frameSize ) ; if ( template . m_inArgsSize > 0 ) { int paramIndex = 0 ; for ( ElemTemplateElement elem = template . getFirstChildElem ( ) ; null != elem ; elem = elem . getNextSiblingElem ( ) ) { if ( Constants . ELEMNAME_PARAMVARIABLE == elem . getXSLToken ( ) ) { ElemParam ep = ( ElemParam ) elem ; int i ; for ( i = 0 ; i < nParams ; i ++ ) { ElemWithParam ewp = m_paramElems [ i ] ; if ( ewp . m_qnameID == ep . m_qnameID ) { XObject obj = vars . getLocalVariable ( i , argsFrame ) ; vars . setLocalVariable ( paramIndex , obj ) ; break ; } } if ( i == nParams ) vars . setLocalVariable ( paramIndex , null ) ; } else break ; paramIndex ++ ; } } } else currentFrameBottom = 0 ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( template ) ; for ( ElemTemplateElement t = template . m_firstChild ; t != null ; t = t . m_nextSibling ) { xctxt . setSAXLocator ( t ) ; try { transformer . pushElemTemplateElement ( t ) ; t . execute ( transformer ) ; } finally { transformer . popElemTemplateElement ( ) ; } } if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( template ) ; if ( template . m_frameSize > 0 ) { vars . unlink ( currentFrameBottom ) ; xctxt . popRTFContext ( ) ; } transformer . popCurrentMatched ( ) ; } } catch ( SAXException se ) { transformer . getErrorListener ( ) . fatalError ( new TransformerException ( se ) ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEndEvent ( sourceNode , this , "select" , new XPath ( m_selectExpression ) , new org . apache . xpath . objects . XNodeSet ( sourceNodes ) ) ; if ( nParams > 0 ) vars . unlink ( thisframe ) ; xctxt . popSAXLocator ( ) ; if ( pushContextNodeListFlag ) xctxt . popContextNodeList ( ) ; transformer . popElemTemplateElement ( ) ; xctxt . popCurrentExpressionNode ( ) ; xctxt . popCurrentNode ( ) ; sourceNodes . detach ( ) ; } } } 	1	['9', '5', '0', '23', '82', '20', '2', '22', '9', '0.6875', '593', '1', '1', '0.965811966', '0.311111111', '5', '10', '64.66666667', '1', '0.8889', '2']
package org . apache . xml . dtm . ref . dom2dtm ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . dom . DOMSource ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . ref . DTMDefaultBaseIterators ; import org . apache . xml . dtm . ref . DTMManagerDefault ; import org . apache . xml . dtm . ref . ExpandedNameTable ; import org . apache . xml . dtm . ref . IncrementalSAXSource ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . StringBufferPool ; import org . apache . xml . utils . TreeWalker ; import org . apache . xml . utils . XMLCharacterRecognizer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . Entity ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; public class DOM2DTM extends DTMDefaultBaseIterators { static final boolean JJK_DEBUG = false ; static final boolean JJK_NEWCODE = true ; static final String NAMESPACE_DECL_NS = "http://www.w3.org/XML/1998/namespace" ; transient private Node m_pos ; private int m_last_parent = 0 ; private int m_last_kid = NULL ; transient private Node m_root ; boolean m_processedFirstElement = false ; transient private boolean m_nodesAreProcessed ; protected Vector m_nodes = new Vector ( ) ; public DOM2DTM ( DTMManager mgr , DOMSource domSource , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { super ( mgr , domSource , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing ) ; m_pos = m_root = domSource . getNode ( ) ; m_last_parent = m_last_kid = NULL ; m_last_kid = addNode ( m_root , m_last_parent , m_last_kid , NULL ) ; if ( ELEMENT_NODE == m_root . getNodeType ( ) ) { NamedNodeMap attrs = m_root . getAttributes ( ) ; int attrsize = ( attrs == null ) ? 0 : attrs . getLength ( ) ; if ( attrsize > 0 ) { int attrIndex = NULL ; for ( int i = 0 ; i < attrsize ; ++ i ) { attrIndex = addNode ( attrs . item ( i ) , 0 , attrIndex , NULL ) ; m_firstch . setElementAt ( DTM . NULL , attrIndex ) ; } m_nextsib . setElementAt ( DTM . NULL , attrIndex ) ; } } m_nodesAreProcessed = false ; } protected int addNode ( Node node , int parentIndex , int previousSibling , int forceNodeType ) { int nodeIndex = m_nodes . size ( ) ; if ( m_dtmIdent . size ( ) == ( nodeIndex > > > DTMManager . IDENT_DTM_NODE_BITS ) ) { try { if ( m_mgr == null ) throw new ClassCastException ( ) ; DTMManagerDefault mgrD = ( DTMManagerDefault ) m_mgr ; int id = mgrD . getFirstFreeDTMID ( ) ; mgrD . addDTM ( this , id , nodeIndex ) ; m_dtmIdent . addElement ( id << DTMManager . IDENT_DTM_NODE_BITS ) ; } catch ( ClassCastException e ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DTMIDS_AVAIL , null ) ) ; } } m_size ++ ; int type ; if ( NULL == forceNodeType ) type = node . getNodeType ( ) ; else type = forceNodeType ; if ( Node . ATTRIBUTE_NODE == type ) { String name = node . getNodeName ( ) ; if ( name . startsWith ( "xmlns:" ) || name . equals ( "xmlns" ) ) { type = DTM . NAMESPACE_NODE ; } } m_nodes . addElement ( node ) ; m_firstch . setElementAt ( NOTPROCESSED , nodeIndex ) ; m_nextsib . setElementAt ( NOTPROCESSED , nodeIndex ) ; m_prevsib . setElementAt ( previousSibling , nodeIndex ) ; m_parent . setElementAt ( parentIndex , nodeIndex ) ; if ( DTM . NULL != parentIndex && type != DTM . ATTRIBUTE_NODE && type != DTM . NAMESPACE_NODE ) { if ( NOTPROCESSED == m_firstch . elementAt ( parentIndex ) ) m_firstch . setElementAt ( nodeIndex , parentIndex ) ; } String nsURI = node . getNamespaceURI ( ) ; String localName = ( type == Node . PROCESSING_INSTRUCTION_NODE ) ? node . getNodeName ( ) : node . getLocalName ( ) ; if ( ( ( type == Node . ELEMENT_NODE ) || ( type == Node . ATTRIBUTE_NODE ) ) && null == localName ) localName = node . getNodeName ( ) ; ExpandedNameTable exnt = m_expandedNameTable ; if ( node . getLocalName ( ) == null && ( type == Node . ELEMENT_NODE || type == Node . ATTRIBUTE_NODE ) ) { } int expandedNameID = ( null != localName ) ? exnt . getExpandedTypeID ( nsURI , localName , type ) : exnt . getExpandedTypeID ( type ) ; m_exptype . setElementAt ( expandedNameID , nodeIndex ) ; indexNode ( expandedNameID , nodeIndex ) ; if ( DTM . NULL != previousSibling ) m_nextsib . setElementAt ( nodeIndex , previousSibling ) ; if ( type == DTM . NAMESPACE_NODE ) declareNamespaceInContext ( parentIndex , nodeIndex ) ; return nodeIndex ; } public int getNumberOfNodes ( ) { return m_nodes . size ( ) ; } protected boolean nextNode ( ) { if ( m_nodesAreProcessed ) return false ; Node pos = m_pos ; Node next = null ; int nexttype = NULL ; do { if ( pos . hasChildNodes ( ) ) { next = pos . getFirstChild ( ) ; if ( next != null && DOCUMENT_TYPE_NODE == next . getNodeType ( ) ) next = next . getNextSibling ( ) ; if ( ENTITY_REFERENCE_NODE != pos . getNodeType ( ) ) { m_last_parent = m_last_kid ; m_last_kid = NULL ; if ( null != m_wsfilter ) { short wsv = m_wsfilter . getShouldStripSpace ( makeNodeHandle ( m_last_parent ) , this ) ; boolean shouldStrip = ( DTMWSFilter . INHERIT == wsv ) ? getShouldStripWhitespace ( ) : ( DTMWSFilter . STRIP == wsv ) ; pushShouldStripWhitespace ( shouldStrip ) ; } } } else { if ( m_last_kid != NULL ) { if ( m_firstch . elementAt ( m_last_kid ) == NOTPROCESSED ) m_firstch . setElementAt ( NULL , m_last_kid ) ; } while ( m_last_parent != NULL ) { next = pos . getNextSibling ( ) ; if ( next != null && DOCUMENT_TYPE_NODE == next . getNodeType ( ) ) next = next . getNextSibling ( ) ; if ( next != null ) break ; pos = pos . getParentNode ( ) ; if ( pos == null ) { if ( JJK_DEBUG ) { System . out . println ( "***** DOM2DTM Pop Control Flow problem" ) ; for ( ; ; ) ; } } if ( pos != null && ENTITY_REFERENCE_NODE == pos . getNodeType ( ) ) { if ( JJK_DEBUG ) System . out . println ( "***** DOM2DTM popping EntRef" ) ; } else { popShouldStripWhitespace ( ) ; if ( m_last_kid == NULL ) m_firstch . setElementAt ( NULL , m_last_parent ) ; else m_nextsib . setElementAt ( NULL , m_last_kid ) ; m_last_parent = m_parent . elementAt ( m_last_kid = m_last_parent ) ; } } if ( m_last_parent == NULL ) next = null ; } if ( next != null ) nexttype = next . getNodeType ( ) ; if ( ENTITY_REFERENCE_NODE == nexttype ) pos = next ; } while ( ENTITY_REFERENCE_NODE == nexttype ) ; if ( next == null ) { m_nextsib . setElementAt ( NULL , 0 ) ; m_nodesAreProcessed = true ; m_pos = null ; if ( JJK_DEBUG ) { System . out . println ( "***** DOM2DTM Crosscheck:" ) ; for ( int i = 0 ; i < m_nodes . size ( ) ; ++ i ) System . out . println ( i + ":\t" + m_firstch . elementAt ( i ) + "\t" + m_nextsib . elementAt ( i ) ) ; } return false ; } boolean suppressNode = false ; Node lastTextNode = null ; nexttype = next . getNodeType ( ) ; if ( TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype ) { suppressNode = ( ( null != m_wsfilter ) && getShouldStripWhitespace ( ) ) ; Node n = next ; while ( n != null ) { lastTextNode = n ; if ( TEXT_NODE == n . getNodeType ( ) ) nexttype = TEXT_NODE ; suppressNode &= XMLCharacterRecognizer . isWhiteSpace ( n . getNodeValue ( ) ) ; n = logicalNextDOMTextNode ( n ) ; } } else if ( PROCESSING_INSTRUCTION_NODE == nexttype ) { suppressNode = ( pos . getNodeName ( ) . toLowerCase ( ) . equals ( "xml" ) ) ; } if ( ! suppressNode ) { int nextindex = addNode ( next , m_last_parent , m_last_kid , nexttype ) ; m_last_kid = nextindex ; if ( ELEMENT_NODE == nexttype ) { int attrIndex = NULL ; NamedNodeMap attrs = next . getAttributes ( ) ; int attrsize = ( attrs == null ) ? 0 : attrs . getLength ( ) ; if ( attrsize > 0 ) { for ( int i = 0 ; i < attrsize ; ++ i ) { attrIndex = addNode ( attrs . item ( i ) , nextindex , attrIndex , NULL ) ; m_firstch . setElementAt ( DTM . NULL , attrIndex ) ; if ( ! m_processedFirstElement && "xmlns:xml" . equals ( attrs . item ( i ) . getNodeName ( ) ) ) m_processedFirstElement = true ; } } if ( ! m_processedFirstElement ) { attrIndex = addNode ( new DOM2DTMdefaultNamespaceDeclarationNode ( ( Element ) next , "xml" , NAMESPACE_DECL_NS , makeNodeHandle ( ( ( attrIndex == NULL ) ? nextindex : attrIndex ) + 1 ) ) , nextindex , attrIndex , NULL ) ; m_firstch . setElementAt ( DTM . NULL , attrIndex ) ; m_processedFirstElement = true ; } if ( attrIndex != NULL ) m_nextsib . setElementAt ( DTM . NULL , attrIndex ) ; } } if ( TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype ) { next = lastTextNode ; } m_pos = next ; return true ; } public Node getNode ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; return ( Node ) m_nodes . elementAt ( identity ) ; } protected Node lookupNode ( int nodeIdentity ) { return ( Node ) m_nodes . elementAt ( nodeIdentity ) ; } protected int getNextNodeIdentity ( int identity ) { identity += 1 ; if ( identity >= m_nodes . size ( ) ) { if ( ! nextNode ( ) ) identity = DTM . NULL ; } return identity ; } private int getHandleFromNode ( Node node ) { if ( null != node ) { int len = m_nodes . size ( ) ; boolean isMore ; int i = 0 ; do { for ( ; i < len ; i ++ ) { if ( m_nodes . elementAt ( i ) == node ) return makeNodeHandle ( i ) ; } isMore = nextNode ( ) ; len = m_nodes . size ( ) ; } while ( isMore || i < len ) ; } return DTM . NULL ; } public int getHandleOfNode ( Node node ) { if ( null != node ) { if ( ( m_root == node ) || ( m_root . getNodeType ( ) == DOCUMENT_NODE && m_root == node . getOwnerDocument ( ) ) || ( m_root . getNodeType ( ) != DOCUMENT_NODE && m_root . getOwnerDocument ( ) == node . getOwnerDocument ( ) ) ) { for ( Node cursor = node ; cursor != null ; cursor = ( cursor . getNodeType ( ) != ATTRIBUTE_NODE ) ? cursor . getParentNode ( ) : ( ( org . w3c . dom . Attr ) cursor ) . getOwnerElement ( ) ) { if ( cursor == m_root ) return getHandleFromNode ( node ) ; } } } return DTM . NULL ; } public int getAttributeNode ( int nodeHandle , String namespaceURI , String name ) { if ( null == namespaceURI ) namespaceURI = "" ; int type = getNodeType ( nodeHandle ) ; if ( DTM . ELEMENT_NODE == type ) { int identity = makeNodeIdentity ( nodeHandle ) ; while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { type = _type ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE || type == DTM . NAMESPACE_NODE ) { Node node = lookupNode ( identity ) ; String nodeuri = node . getNamespaceURI ( ) ; if ( null == nodeuri ) nodeuri = "" ; String nodelocalname = node . getLocalName ( ) ; if ( nodeuri . equals ( namespaceURI ) && name . equals ( nodelocalname ) ) return makeNodeHandle ( identity ) ; } else { break ; } } } return DTM . NULL ; } public XMLString getStringValue ( int nodeHandle ) { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; if ( DTM . ELEMENT_NODE == type || DTM . DOCUMENT_NODE == type || DTM . DOCUMENT_FRAGMENT_NODE == type ) { FastStringBuffer buf = StringBufferPool . get ( ) ; String s ; try { getNodeData ( node , buf ) ; s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; } finally { StringBufferPool . free ( buf ) ; } return m_xstrf . newstr ( s ) ; } else if ( TEXT_NODE == type || CDATA_SECTION_NODE == type ) { FastStringBuffer buf = StringBufferPool . get ( ) ; while ( node != null ) { buf . append ( node . getNodeValue ( ) ) ; node = logicalNextDOMTextNode ( node ) ; } String s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; StringBufferPool . free ( buf ) ; return m_xstrf . newstr ( s ) ; } else return m_xstrf . newstr ( node . getNodeValue ( ) ) ; } public boolean isWhitespace ( int nodeHandle ) { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; if ( TEXT_NODE == type || CDATA_SECTION_NODE == type ) { FastStringBuffer buf = StringBufferPool . get ( ) ; while ( node != null ) { buf . append ( node . getNodeValue ( ) ) ; node = logicalNextDOMTextNode ( node ) ; } boolean b = buf . isWhitespace ( 0 , buf . length ( ) ) ; StringBufferPool . free ( buf ) ; return b ; } return false ; } protected static void getNodeData ( Node node , FastStringBuffer buf ) { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { getNodeData ( child , buf ) ; } } break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : case Node . ATTRIBUTE_NODE : buf . append ( node . getNodeValue ( ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : break ; default : break ; } } public String getNodeName ( int nodeHandle ) { Node node = getNode ( nodeHandle ) ; return node . getNodeName ( ) ; } public String getNodeNameX ( int nodeHandle ) { String name ; short type = getNodeType ( nodeHandle ) ; switch ( type ) { case DTM . NAMESPACE_NODE : { Node node = getNode ( nodeHandle ) ; name = node . getNodeName ( ) ; if ( name . startsWith ( "xmlns:" ) ) { name = QName . getLocalPart ( name ) ; } else if ( name . equals ( "xmlns" ) ) { name = "" ; } } break ; case DTM . ATTRIBUTE_NODE : case DTM . ELEMENT_NODE : case DTM . ENTITY_REFERENCE_NODE : case DTM . PROCESSING_INSTRUCTION_NODE : { Node node = getNode ( nodeHandle ) ; name = node . getNodeName ( ) ; } break ; default : name = "" ; } return name ; } public String getLocalName ( int nodeHandle ) { if ( JJK_NEWCODE ) { int id = makeNodeIdentity ( nodeHandle ) ; if ( NULL == id ) return null ; Node newnode = ( Node ) m_nodes . elementAt ( id ) ; String newname = newnode . getLocalName ( ) ; if ( null == newname ) { String qname = newnode . getNodeName ( ) ; if ( '#' == qname . charAt ( 0 ) ) { newname = "" ; } else { int index = qname . indexOf ( ':' ) ; newname = ( index < 0 ) ? qname : qname . substring ( index + 1 ) ; } } return newname ; } else { String name ; short type = getNodeType ( nodeHandle ) ; switch ( type ) { case DTM . ATTRIBUTE_NODE : case DTM . ELEMENT_NODE : case DTM . ENTITY_REFERENCE_NODE : case DTM . NAMESPACE_NODE : case DTM . PROCESSING_INSTRUCTION_NODE : { Node node = getNode ( nodeHandle ) ; name = node . getLocalName ( ) ; if ( null == name ) { String qname = node . getNodeName ( ) ; int index = qname . indexOf ( ':' ) ; name = ( index < 0 ) ? qname : qname . substring ( index + 1 ) ; } } break ; default : name = "" ; } return name ; } } public String getPrefix ( int nodeHandle ) { String prefix ; short type = getNodeType ( nodeHandle ) ; switch ( type ) { case DTM . NAMESPACE_NODE : { Node node = getNode ( nodeHandle ) ; String qname = node . getNodeName ( ) ; int index = qname . indexOf ( ':' ) ; prefix = ( index < 0 ) ? "" : qname . substring ( index + 1 ) ; } break ; case DTM . ATTRIBUTE_NODE : case DTM . ELEMENT_NODE : { Node node = getNode ( nodeHandle ) ; String qname = node . getNodeName ( ) ; int index = qname . indexOf ( ':' ) ; prefix = ( index < 0 ) ? "" : qname . substring ( 0 , index ) ; } break ; default : prefix = "" ; } return prefix ; } public String getNamespaceURI ( int nodeHandle ) { if ( JJK_NEWCODE ) { int id = makeNodeIdentity ( nodeHandle ) ; if ( id == NULL ) return null ; Node node = ( Node ) m_nodes . elementAt ( id ) ; return node . getNamespaceURI ( ) ; } else { String nsuri ; short type = getNodeType ( nodeHandle ) ; switch ( type ) { case DTM . ATTRIBUTE_NODE : case DTM . ELEMENT_NODE : case DTM . ENTITY_REFERENCE_NODE : case DTM . NAMESPACE_NODE : case DTM . PROCESSING_INSTRUCTION_NODE : { Node node = getNode ( nodeHandle ) ; nsuri = node . getNamespaceURI ( ) ; } break ; default : nsuri = null ; } return nsuri ; } } private Node logicalNextDOMTextNode ( Node n ) { Node p = n . getNextSibling ( ) ; if ( p == null ) { for ( n = n . getParentNode ( ) ; n != null && ENTITY_REFERENCE_NODE == n . getNodeType ( ) ; n = n . getParentNode ( ) ) { p = n . getNextSibling ( ) ; if ( p != null ) break ; } } n = p ; while ( n != null && ENTITY_REFERENCE_NODE == n . getNodeType ( ) ) { if ( n . hasChildNodes ( ) ) n = n . getFirstChild ( ) ; else n = n . getNextSibling ( ) ; } if ( n != null ) { int ntype = n . getNodeType ( ) ; if ( TEXT_NODE != ntype && CDATA_SECTION_NODE != ntype ) n = null ; } return n ; } public String getNodeValue ( int nodeHandle ) { int type = _exptype ( makeNodeIdentity ( nodeHandle ) ) ; type = ( NULL != type ) ? getNodeType ( nodeHandle ) : NULL ; if ( TEXT_NODE != type && CDATA_SECTION_NODE != type ) return getNode ( nodeHandle ) . getNodeValue ( ) ; Node node = getNode ( nodeHandle ) ; Node n = logicalNextDOMTextNode ( node ) ; if ( n == null ) return node . getNodeValue ( ) ; FastStringBuffer buf = StringBufferPool . get ( ) ; buf . append ( node . getNodeValue ( ) ) ; while ( n != null ) { buf . append ( n . getNodeValue ( ) ) ; n = logicalNextDOMTextNode ( n ) ; } String s = ( buf . length ( ) > 0 ) ? buf . toString ( ) : "" ; StringBufferPool . free ( buf ) ; return s ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { Document doc ; if ( m_root . getNodeType ( ) == Node . DOCUMENT_NODE ) doc = ( Document ) m_root ; else doc = m_root . getOwnerDocument ( ) ; if ( null != doc ) { DocumentType dtd = doc . getDoctype ( ) ; if ( null != dtd ) { return dtd . getSystemId ( ) ; } } return null ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { Document doc ; if ( m_root . getNodeType ( ) == Node . DOCUMENT_NODE ) doc = ( Document ) m_root ; else doc = m_root . getOwnerDocument ( ) ; if ( null != doc ) { DocumentType dtd = doc . getDoctype ( ) ; if ( null != dtd ) { return dtd . getPublicId ( ) ; } } return null ; } public int getElementById ( String elementId ) { Document doc = ( m_root . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( Document ) m_root : m_root . getOwnerDocument ( ) ; if ( null != doc ) { Node elem = doc . getElementById ( elementId ) ; if ( null != elem ) { int elemHandle = getHandleFromNode ( elem ) ; if ( DTM . NULL == elemHandle ) { int identity = m_nodes . size ( ) - 1 ; while ( DTM . NULL != ( identity = getNextNodeIdentity ( identity ) ) ) { Node node = getNode ( identity ) ; if ( node == elem ) { elemHandle = getHandleFromNode ( elem ) ; break ; } } } return elemHandle ; } } return DTM . NULL ; } public String getUnparsedEntityURI ( String name ) { String url = "" ; Document doc = ( m_root . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( Document ) m_root : m_root . getOwnerDocument ( ) ; if ( null != doc ) { DocumentType doctype = doc . getDoctype ( ) ; if ( null != doctype ) { NamedNodeMap entities = doctype . getEntities ( ) ; if ( null == entities ) return url ; Entity entity = ( Entity ) entities . getNamedItem ( name ) ; if ( null == entity ) return url ; String notationName = entity . getNotationName ( ) ; if ( null != notationName ) { url = entity . getSystemId ( ) ; if ( null == url ) { url = entity . getPublicId ( ) ; } else { } } } } return url ; } public boolean isAttributeSpecified ( int attributeHandle ) { int type = getNodeType ( attributeHandle ) ; if ( DTM . ATTRIBUTE_NODE == type ) { Attr attr = ( Attr ) getNode ( attributeHandle ) ; return attr . getSpecified ( ) ; } return false ; } public void setIncrementalSAXSource ( IncrementalSAXSource source ) { } public org . xml . sax . ContentHandler getContentHandler ( ) { return null ; } public org . xml . sax . ext . LexicalHandler getLexicalHandler ( ) { return null ; } public org . xml . sax . EntityResolver getEntityResolver ( ) { return null ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return null ; } public org . xml . sax . ErrorHandler getErrorHandler ( ) { return null ; } public org . xml . sax . ext . DeclHandler getDeclHandler ( ) { return null ; } public boolean needsTwoThreads ( ) { return false ; } private static boolean isSpace ( char ch ) { return XMLCharacterRecognizer . isWhiteSpace ( ch ) ; } public void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { if ( normalize ) { XMLString str = getStringValue ( nodeHandle ) ; str = str . fixWhiteSpace ( true , true , false ) ; str . dispatchCharactersEvents ( ch ) ; } else { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; dispatchNodeData ( node , ch , 0 ) ; if ( TEXT_NODE == type || CDATA_SECTION_NODE == type ) { while ( null != ( node = logicalNextDOMTextNode ( node ) ) ) { dispatchNodeData ( node , ch , 0 ) ; } } } } protected static void dispatchNodeData ( Node node , org . xml . sax . ContentHandler ch , int depth ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { dispatchNodeData ( child , ch , depth + 1 ) ; } } break ; case Node . PROCESSING_INSTRUCTION_NODE : case Node . COMMENT_NODE : if ( 0 != depth ) break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : case Node . ATTRIBUTE_NODE : String str = node . getNodeValue ( ) ; if ( ch instanceof CharacterNodeHandler ) { ( ( CharacterNodeHandler ) ch ) . characters ( node ) ; } else { ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } break ; default : break ; } } TreeWalker m_walker = new TreeWalker ( null ) ; public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { TreeWalker treeWalker = m_walker ; ContentHandler prevCH = treeWalker . getContentHandler ( ) ; if ( null != prevCH ) { treeWalker = new TreeWalker ( null ) ; } treeWalker . setContentHandler ( ch ) ; try { Node node = getNode ( nodeHandle ) ; treeWalker . traverse ( node ) ; } finally { treeWalker . setContentHandler ( null ) ; } } public interface CharacterNodeHandler { public void characters ( Node node ) throws org . xml . sax . SAXException ; } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { return null ; } } 	1	['39', '4', '0', '18', '119', '617', '1', '18', '30', '0.870813397', '1667', '0.545454545', '1', '0.712121212', '0.142857143', '2', '17', '41.46153846', '42', '4.6154', '1']
package org . apache . xml . dtm . ref ; import javax . xml . transform . SourceLocator ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . ext . LexicalHandler ; public class DTMDocumentImpl implements DTM , org . xml . sax . ContentHandler , org . xml . sax . ext . LexicalHandler { protected static final byte DOCHANDLE_SHIFT = 22 ; protected static final int NODEHANDLE_MASK = ( 1 << ( DOCHANDLE_SHIFT + 1 ) ) - 1 ; protected static final int DOCHANDLE_MASK = - 1 - NODEHANDLE_MASK ; int m_docHandle = NULL ; int m_docElement = NULL ; int currentParent = 0 ; int previousSibling = 0 ; protected int m_currentNode = - 1 ; private boolean previousSiblingWasParent = false ; int gotslot [ ] = new int [ 4 ] ; private boolean done = false ; boolean m_isError = false ; private final boolean DEBUG = false ; protected String m_documentBaseURI ; private IncrementalSAXSource m_incrSAXSource = null ; ChunkedIntArray nodes = new ChunkedIntArray ( 4 ) ; private FastStringBuffer m_char = new FastStringBuffer ( ) ; private int m_char_current_start = 0 ; private DTMStringPool m_localNames = new DTMStringPool ( ) ; private DTMStringPool m_nsNames = new DTMStringPool ( ) ; private DTMStringPool m_prefixNames = new DTMStringPool ( ) ; private ExpandedNameTable m_expandedNames = new ExpandedNameTable ( ) ; private XMLStringFactory m_xsf ; public DTMDocumentImpl ( DTMManager mgr , int documentNumber , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory ) { initDocument ( documentNumber ) ; m_xsf = xstringfactory ; } public void setIncrementalSAXSource ( IncrementalSAXSource source ) { m_incrSAXSource = source ; source . setContentHandler ( this ) ; source . setLexicalHandler ( this ) ; } private final int appendNode ( int w0 , int w1 , int w2 , int w3 ) { int slotnumber = nodes . appendSlot ( w0 , w1 , w2 , w3 ) ; if ( DEBUG ) System . out . println ( slotnumber + ": " + w0 + " " + w1 + " " + w2 + " " + w3 ) ; if ( previousSiblingWasParent ) nodes . writeEntry ( previousSibling , 2 , slotnumber ) ; previousSiblingWasParent = false ; return slotnumber ; } public void setFeature ( String featureId , boolean state ) { } ; public void setLocalNameTable ( DTMStringPool poolRef ) { m_localNames = poolRef ; } public DTMStringPool getLocalNameTable ( ) { return m_localNames ; } public void setNsNameTable ( DTMStringPool poolRef ) { m_nsNames = poolRef ; } public DTMStringPool getNsNameTable ( ) { return m_nsNames ; } public void setPrefixNameTable ( DTMStringPool poolRef ) { m_prefixNames = poolRef ; } public DTMStringPool getPrefixNameTable ( ) { return m_prefixNames ; } void setContentBuffer ( FastStringBuffer buffer ) { m_char = buffer ; } FastStringBuffer getContentBuffer ( ) { return m_char ; } public org . xml . sax . ContentHandler getContentHandler ( ) { if ( m_incrSAXSource instanceof IncrementalSAXSource_Filter ) return ( ContentHandler ) m_incrSAXSource ; else return this ; } public LexicalHandler getLexicalHandler ( ) { if ( m_incrSAXSource instanceof IncrementalSAXSource_Filter ) return ( LexicalHandler ) m_incrSAXSource ; else return this ; } public org . xml . sax . EntityResolver getEntityResolver ( ) { return null ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return null ; } public org . xml . sax . ErrorHandler getErrorHandler ( ) { return null ; } public org . xml . sax . ext . DeclHandler getDeclHandler ( ) { return null ; } public boolean needsTwoThreads ( ) { return null != m_incrSAXSource ; } public void characters ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { m_char . append ( ch , start , length ) ; } private void processAccumulatedText ( ) { int len = m_char . length ( ) ; if ( len != m_char_current_start ) { appendTextChild ( m_char_current_start , len - m_char_current_start ) ; m_char_current_start = len ; } } public void endDocument ( ) throws org . xml . sax . SAXException { appendEndDocument ( ) ; } public void endElement ( java . lang . String namespaceURI , java . lang . String localName , java . lang . String qName ) throws org . xml . sax . SAXException { processAccumulatedText ( ) ; appendEndElement ( ) ; } public void endPrefixMapping ( java . lang . String prefix ) throws org . xml . sax . SAXException { } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { } public void processingInstruction ( java . lang . String target , java . lang . String data ) throws org . xml . sax . SAXException { processAccumulatedText ( ) ; } public void setDocumentLocator ( Locator locator ) { } public void skippedEntity ( java . lang . String name ) throws org . xml . sax . SAXException { processAccumulatedText ( ) ; } public void startDocument ( ) throws org . xml . sax . SAXException { appendStartDocument ( ) ; } public void startElement ( java . lang . String namespaceURI , java . lang . String localName , java . lang . String qName , Attributes atts ) throws org . xml . sax . SAXException { processAccumulatedText ( ) ; String prefix = null ; int colon = qName . indexOf ( ':' ) ; if ( colon > 0 ) prefix = qName . substring ( 0 , colon ) ; System . out . println ( "Prefix=" + prefix + " index=" + m_prefixNames . stringToIndex ( prefix ) ) ; appendStartElement ( m_nsNames . stringToIndex ( namespaceURI ) , m_localNames . stringToIndex ( localName ) , m_prefixNames . stringToIndex ( prefix ) ) ; int nAtts = ( atts == null ) ? 0 : atts . getLength ( ) ; for ( int i = nAtts - 1 ; i >= 0 ; -- i ) { qName = atts . getQName ( i ) ; if ( qName . startsWith ( "xmlns:" ) || "xmlns" . equals ( qName ) ) { prefix = null ; colon = qName . indexOf ( ':' ) ; if ( colon > 0 ) { prefix = qName . substring ( 0 , colon ) ; } else { prefix = null ; } appendNSDeclaration ( m_prefixNames . stringToIndex ( prefix ) , m_nsNames . stringToIndex ( atts . getValue ( i ) ) , atts . getType ( i ) . equalsIgnoreCase ( "ID" ) ) ; } } for ( int i = nAtts - 1 ; i >= 0 ; -- i ) { qName = atts . getQName ( i ) ; if ( ! ( qName . startsWith ( "xmlns:" ) || "xmlns" . equals ( qName ) ) ) { prefix = null ; colon = qName . indexOf ( ':' ) ; if ( colon > 0 ) { prefix = qName . substring ( 0 , colon ) ; localName = qName . substring ( colon + 1 ) ; } else { prefix = "" ; localName = qName ; } m_char . append ( atts . getValue ( i ) ) ; int contentEnd = m_char . length ( ) ; if ( ! ( "xmlns" . equals ( prefix ) || "xmlns" . equals ( qName ) ) ) appendAttribute ( m_nsNames . stringToIndex ( atts . getURI ( i ) ) , m_localNames . stringToIndex ( localName ) , m_prefixNames . stringToIndex ( prefix ) , atts . getType ( i ) . equalsIgnoreCase ( "ID" ) , m_char_current_start , contentEnd - m_char_current_start ) ; m_char_current_start = contentEnd ; } } } public void startPrefixMapping ( java . lang . String prefix , java . lang . String uri ) throws org . xml . sax . SAXException { } public void comment ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { processAccumulatedText ( ) ; m_char . append ( ch , start , length ) ; appendComment ( m_char_current_start , length ) ; m_char_current_start += length ; } public void endCDATA ( ) throws org . xml . sax . SAXException { } public void endDTD ( ) throws org . xml . sax . SAXException { } public void endEntity ( java . lang . String name ) throws org . xml . sax . SAXException { } public void startCDATA ( ) throws org . xml . sax . SAXException { } public void startDTD ( java . lang . String name , java . lang . String publicId , java . lang . String systemId ) throws org . xml . sax . SAXException { } public void startEntity ( java . lang . String name ) throws org . xml . sax . SAXException { } final void initDocument ( int documentNumber ) { m_docHandle = documentNumber << DOCHANDLE_SHIFT ; nodes . writeSlot ( 0 , DOCUMENT_NODE , - 1 , - 1 , 0 ) ; done = false ; } public boolean hasChildNodes ( int nodeHandle ) { return ( getFirstChild ( nodeHandle ) != NULL ) ; } public int getFirstChild ( int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; nodes . readSlot ( nodeHandle , gotslot ) ; short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; if ( ( type == ELEMENT_NODE ) || ( type == DOCUMENT_NODE ) || ( type == ENTITY_REFERENCE_NODE ) ) { int kid = nodeHandle + 1 ; nodes . readSlot ( kid , gotslot ) ; while ( ATTRIBUTE_NODE == ( gotslot [ 0 ] & 0xFFFF ) ) { kid = gotslot [ 2 ] ; if ( kid == NULL ) return NULL ; nodes . readSlot ( kid , gotslot ) ; } if ( gotslot [ 1 ] == nodeHandle ) { int firstChild = kid | m_docHandle ; return firstChild ; } } return NULL ; } public int getLastChild ( int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; int lastChild = NULL ; for ( int nextkid = getFirstChild ( nodeHandle ) ; nextkid != NULL ; nextkid = getNextSibling ( nextkid ) ) { lastChild = nextkid ; } return lastChild | m_docHandle ; } public int getAttributeNode ( int nodeHandle , String namespaceURI , String name ) { int nsIndex = m_nsNames . stringToIndex ( namespaceURI ) , nameIndex = m_localNames . stringToIndex ( name ) ; nodeHandle &= NODEHANDLE_MASK ; nodes . readSlot ( nodeHandle , gotslot ) ; short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; if ( type == ELEMENT_NODE ) nodeHandle ++ ; while ( type == ATTRIBUTE_NODE ) { if ( ( nsIndex == ( gotslot [ 0 ] << 16 ) ) && ( gotslot [ 3 ] == nameIndex ) ) return nodeHandle | m_docHandle ; nodeHandle = gotslot [ 2 ] ; nodes . readSlot ( nodeHandle , gotslot ) ; } return NULL ; } public int getFirstAttribute ( int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; if ( ELEMENT_NODE != ( nodes . readEntry ( nodeHandle , 0 ) & 0xFFFF ) ) return NULL ; nodeHandle ++ ; return ( ATTRIBUTE_NODE == ( nodes . readEntry ( nodeHandle , 0 ) & 0xFFFF ) ) ? nodeHandle | m_docHandle : NULL ; } public int getFirstNamespaceNode ( int nodeHandle , boolean inScope ) { return NULL ; } public int getNextSibling ( int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; if ( nodeHandle == 0 ) return NULL ; short type = ( short ) ( nodes . readEntry ( nodeHandle , 0 ) & 0xFFFF ) ; if ( ( type == ELEMENT_NODE ) || ( type == ATTRIBUTE_NODE ) || ( type == ENTITY_REFERENCE_NODE ) ) { int nextSib = nodes . readEntry ( nodeHandle , 2 ) ; if ( nextSib == NULL ) return NULL ; if ( nextSib != 0 ) return ( m_docHandle | nextSib ) ; } int thisParent = nodes . readEntry ( nodeHandle , 1 ) ; if ( nodes . readEntry ( ++ nodeHandle , 1 ) == thisParent ) return ( m_docHandle | nodeHandle ) ; return NULL ; } public int getPreviousSibling ( int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; if ( nodeHandle == 0 ) return NULL ; int parent = nodes . readEntry ( nodeHandle , 1 ) ; int kid = NULL ; for ( int nextkid = getFirstChild ( parent ) ; nextkid != nodeHandle ; nextkid = getNextSibling ( nextkid ) ) { kid = nextkid ; } return kid | m_docHandle ; } public int getNextAttribute ( int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; nodes . readSlot ( nodeHandle , gotslot ) ; short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; if ( type == ELEMENT_NODE ) { return getFirstAttribute ( nodeHandle ) ; } else if ( type == ATTRIBUTE_NODE ) { if ( gotslot [ 2 ] != NULL ) return ( m_docHandle | gotslot [ 2 ] ) ; } return NULL ; } public int getNextNamespaceNode ( int baseHandle , int namespaceHandle , boolean inScope ) { return NULL ; } public int getNextDescendant ( int subtreeRootHandle , int nodeHandle ) { subtreeRootHandle &= NODEHANDLE_MASK ; nodeHandle &= NODEHANDLE_MASK ; if ( nodeHandle == 0 ) return NULL ; while ( ! m_isError ) { if ( done && ( nodeHandle > nodes . slotsUsed ( ) ) ) break ; if ( nodeHandle > subtreeRootHandle ) { nodes . readSlot ( nodeHandle + 1 , gotslot ) ; if ( gotslot [ 2 ] != 0 ) { short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; if ( type == ATTRIBUTE_NODE ) { nodeHandle += 2 ; } else { int nextParentPos = gotslot [ 1 ] ; if ( nextParentPos >= subtreeRootHandle ) return ( m_docHandle | ( nodeHandle + 1 ) ) ; else break ; } } else if ( ! done ) { } else break ; } else { nodeHandle ++ ; } } return NULL ; } public int getNextFollowing ( int axisContextHandle , int nodeHandle ) { return NULL ; } public int getNextPreceding ( int axisContextHandle , int nodeHandle ) { nodeHandle &= NODEHANDLE_MASK ; while ( nodeHandle > 1 ) { nodeHandle -- ; if ( ATTRIBUTE_NODE == ( nodes . readEntry ( nodeHandle , 0 ) & 0xFFFF ) ) continue ; return ( m_docHandle | nodes . specialFind ( axisContextHandle , nodeHandle ) ) ; } return NULL ; } public int getParent ( int nodeHandle ) { return ( m_docHandle | nodes . readEntry ( nodeHandle , 1 ) ) ; } public int getDocumentRoot ( ) { return ( m_docHandle | m_docElement ) ; } public int getDocument ( ) { return m_docHandle ; } public int getOwnerDocument ( int nodeHandle ) { if ( ( nodeHandle & NODEHANDLE_MASK ) == 0 ) return NULL ; return ( nodeHandle & DOCHANDLE_MASK ) ; } public int getDocumentRoot ( int nodeHandle ) { if ( ( nodeHandle & NODEHANDLE_MASK ) == 0 ) return NULL ; return ( nodeHandle & DOCHANDLE_MASK ) ; } public XMLString getStringValue ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; int nodetype = gotslot [ 0 ] & 0xFF ; String value = null ; switch ( nodetype ) { case TEXT_NODE : case COMMENT_NODE : case CDATA_SECTION_NODE : value = m_char . getString ( gotslot [ 2 ] , gotslot [ 3 ] ) ; break ; case PROCESSING_INSTRUCTION_NODE : case ATTRIBUTE_NODE : case ELEMENT_NODE : case ENTITY_REFERENCE_NODE : default : break ; } return m_xsf . newstr ( value ) ; } public int getStringValueChunkCount ( int nodeHandle ) { return 0 ; } public char [ ] getStringValueChunk ( int nodeHandle , int chunkIndex , int [ ] startAndLen ) { return new char [ 0 ] ; } public int getExpandedTypeID ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; String qName = m_localNames . indexToString ( gotslot [ 3 ] ) ; int colonpos = qName . indexOf ( ":" ) ; String localName = qName . substring ( colonpos + 1 ) ; String namespace = m_nsNames . indexToString ( gotslot [ 0 ] << 16 ) ; String expandedName = namespace + ":" + localName ; int expandedNameID = m_nsNames . stringToIndex ( expandedName ) ; return expandedNameID ; } public int getExpandedTypeID ( String namespace , String localName , int type ) { String expandedName = namespace + ":" + localName ; int expandedNameID = m_nsNames . stringToIndex ( expandedName ) ; return expandedNameID ; } public String getLocalNameFromExpandedNameID ( int ExpandedNameID ) { String expandedName = m_localNames . indexToString ( ExpandedNameID ) ; int colonpos = expandedName . indexOf ( ":" ) ; String localName = expandedName . substring ( colonpos + 1 ) ; return localName ; } public String getNamespaceFromExpandedNameID ( int ExpandedNameID ) { String expandedName = m_localNames . indexToString ( ExpandedNameID ) ; int colonpos = expandedName . indexOf ( ":" ) ; String nsName = expandedName . substring ( 0 , colonpos ) ; return nsName ; } static final String [ ] fixednames = { null , null , null , "#text" , "#cdata_section" , null , null , null , "#comment" , "#document" , null , "#document-fragment" , null } ; public String getNodeName ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; String name = fixednames [ type ] ; if ( null == name ) { int i = gotslot [ 3 ] ; System . out . println ( "got i=" + i + " " + ( i > > 16 ) + "/" + ( i & 0xffff ) ) ; name = m_localNames . indexToString ( i & 0xFFFF ) ; String prefix = m_prefixNames . indexToString ( i > > 16 ) ; if ( prefix != null && prefix . length ( ) > 0 ) name = prefix + ":" + name ; } return name ; } public String getNodeNameX ( int nodeHandle ) { return null ; } public String getLocalName ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; String name = "" ; if ( ( type == ELEMENT_NODE ) || ( type == ATTRIBUTE_NODE ) ) { int i = gotslot [ 3 ] ; name = m_localNames . indexToString ( i & 0xFFFF ) ; if ( name == null ) name = "" ; } return name ; } public String getPrefix ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; String name = "" ; if ( ( type == ELEMENT_NODE ) || ( type == ATTRIBUTE_NODE ) ) { int i = gotslot [ 3 ] ; name = m_prefixNames . indexToString ( i > > 16 ) ; if ( name == null ) name = "" ; } return name ; } public String getNamespaceURI ( int nodeHandle ) { return null ; } public String getNodeValue ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; int nodetype = gotslot [ 0 ] & 0xFF ; String value = null ; switch ( nodetype ) { case ATTRIBUTE_NODE : nodes . readSlot ( nodeHandle + 1 , gotslot ) ; case TEXT_NODE : case COMMENT_NODE : case CDATA_SECTION_NODE : value = m_char . getString ( gotslot [ 2 ] , gotslot [ 3 ] ) ; break ; case PROCESSING_INSTRUCTION_NODE : case ELEMENT_NODE : case ENTITY_REFERENCE_NODE : default : break ; } return value ; } public short getNodeType ( int nodeHandle ) { return ( short ) ( nodes . readEntry ( nodeHandle , 0 ) & 0xFFFF ) ; } public short getLevel ( int nodeHandle ) { short count = 0 ; while ( nodeHandle != 0 ) { count ++ ; nodeHandle = nodes . readEntry ( nodeHandle , 1 ) ; } return count ; } public boolean isSupported ( String feature , String version ) { return false ; } public String getDocumentBaseURI ( ) { return m_documentBaseURI ; } public void setDocumentBaseURI ( String baseURI ) { m_documentBaseURI = baseURI ; } public String getDocumentSystemIdentifier ( int nodeHandle ) { return null ; } public String getDocumentEncoding ( int nodeHandle ) { return null ; } public String getDocumentStandalone ( int nodeHandle ) { return null ; } public String getDocumentVersion ( int documentHandle ) { return null ; } public boolean getDocumentAllDeclarationsProcessed ( ) { return false ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { return null ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { return null ; } public int getElementById ( String elementId ) { return 0 ; } public String getUnparsedEntityURI ( String name ) { return null ; } public boolean supportsPreStripping ( ) { return false ; } public boolean isNodeAfter ( int nodeHandle1 , int nodeHandle2 ) { return false ; } public boolean isCharacterElementContentWhitespace ( int nodeHandle ) { return false ; } public boolean isDocumentAllDeclarationsProcessed ( int documentHandle ) { return false ; } public boolean isAttributeSpecified ( int attributeHandle ) { return false ; } public void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { } public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { } public org . w3c . dom . Node getNode ( int nodeHandle ) { return null ; } public void appendChild ( int newChild , boolean clone , boolean cloneDepth ) { boolean sameDoc = ( ( newChild & DOCHANDLE_MASK ) == m_docHandle ) ; if ( clone || ! sameDoc ) { } else { } } public void appendTextChild ( String str ) { } void appendTextChild ( int m_char_current_start , int contentLength ) { int w0 = TEXT_NODE ; int w1 = currentParent ; int w2 = m_char_current_start ; int w3 = contentLength ; int ourslot = appendNode ( w0 , w1 , w2 , w3 ) ; previousSibling = ourslot ; } void appendComment ( int m_char_current_start , int contentLength ) { int w0 = COMMENT_NODE ; int w1 = currentParent ; int w2 = m_char_current_start ; int w3 = contentLength ; int ourslot = appendNode ( w0 , w1 , w2 , w3 ) ; previousSibling = ourslot ; } void appendStartElement ( int namespaceIndex , int localNameIndex , int prefixIndex ) { int w0 = ( namespaceIndex << 16 ) | ELEMENT_NODE ; int w1 = currentParent ; int w2 = 0 ; int w3 = localNameIndex | prefixIndex << 16 ; System . out . println ( "set w3=" + w3 + " " + ( w3 > > 16 ) + "/" + ( w3 & 0xffff ) ) ; int ourslot = appendNode ( w0 , w1 , w2 , w3 ) ; currentParent = ourslot ; previousSibling = 0 ; if ( m_docElement == NULL ) m_docElement = ourslot ; } void appendNSDeclaration ( int prefixIndex , int namespaceIndex , boolean isID ) { final int namespaceForNamespaces = m_nsNames . stringToIndex ( "http://www.w3.org/2000/xmlns/" ) ; int w0 = NAMESPACE_NODE | ( m_nsNames . stringToIndex ( "http://www.w3.org/2000/xmlns/" ) << 16 ) ; int w1 = currentParent ; int w2 = 0 ; int w3 = namespaceIndex ; int ourslot = appendNode ( w0 , w1 , w2 , w3 ) ; previousSibling = ourslot ; previousSiblingWasParent = false ; return ; } void appendAttribute ( int namespaceIndex , int localNameIndex , int prefixIndex , boolean isID , int m_char_current_start , int contentLength ) { int w0 = ATTRIBUTE_NODE | namespaceIndex << 16 ; int w1 = currentParent ; int w2 = 0 ; int w3 = localNameIndex | prefixIndex << 16 ; System . out . println ( "set w3=" + w3 + " " + ( w3 > > 16 ) + "/" + ( w3 & 0xffff ) ) ; int ourslot = appendNode ( w0 , w1 , w2 , w3 ) ; previousSibling = ourslot ; w0 = TEXT_NODE ; w1 = ourslot ; w2 = m_char_current_start ; w3 = contentLength ; appendNode ( w0 , w1 , w2 , w3 ) ; previousSiblingWasParent = true ; return ; } public DTMAxisTraverser getAxisTraverser ( final int axis ) { return null ; } public DTMAxisIterator getAxisIterator ( final int axis ) { return null ; } public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) { return null ; } void appendEndElement ( ) { if ( previousSiblingWasParent ) nodes . writeEntry ( previousSibling , 2 , NULL ) ; previousSibling = currentParent ; nodes . readSlot ( currentParent , gotslot ) ; currentParent = gotslot [ 1 ] & 0xFFFF ; previousSiblingWasParent = true ; } void appendStartDocument ( ) { m_docElement = NULL ; initDocument ( 0 ) ; } void appendEndDocument ( ) { done = true ; } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { return null ; } public void documentRegistration ( ) { } public void documentRelease ( ) { } public void migrateTo ( DTMManager manager ) { } } 	1	['111', '1', '0', '13', '150', '5301', '0', '13', '97', '0.944318182', '1851', '0.666666667', '8', '0', '0.119886364', '0', '0', '15.45945946', '10', '1.5315', '3']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . BranchInstruction ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFNE ; import org . apache . bcel . generic . IF_ICMPEQ ; import org . apache . bcel . generic . IF_ICMPNE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . NumberType ; import org . apache . xalan . xsltc . compiler . util . RealType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . runtime . Operators ; final class EqualityExpr extends Expression implements Operators { private final int _op ; private Expression _left ; private Expression _right ; public EqualityExpr ( int op , Expression left , Expression right ) { _op = op ; ( _left = left ) . setParent ( this ) ; ( _right = right ) . setParent ( this ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public String toString ( ) { return Operators . names [ _op ] + '(' + _left + ", " + _right + ')' ; } public Expression getLeft ( ) { return _left ; } public Expression getRight ( ) { return _right ; } public boolean getOp ( ) { return ( _op != Operators . NE ) ; } public boolean hasPositionCall ( ) { if ( _left . hasPositionCall ( ) ) return true ; if ( _right . hasPositionCall ( ) ) return true ; return false ; } public boolean hasLastCall ( ) { if ( _left . hasLastCall ( ) ) return true ; if ( _right . hasLastCall ( ) ) return true ; return false ; } private void swapArguments ( ) { final Expression temp = _left ; _left = _right ; _right = temp ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tleft = _left . typeCheck ( stable ) ; final Type tright = _right . typeCheck ( stable ) ; if ( tleft . isSimple ( ) && tright . isSimple ( ) ) { if ( tleft != tright ) { if ( tleft instanceof BooleanType ) { _right = new CastExpr ( _right , Type . Boolean ) ; } else if ( tright instanceof BooleanType ) { _left = new CastExpr ( _left , Type . Boolean ) ; } else if ( tleft instanceof NumberType || tright instanceof NumberType ) { _left = new CastExpr ( _left , Type . Real ) ; _right = new CastExpr ( _right , Type . Real ) ; } else { _left = new CastExpr ( _left , Type . String ) ; _right = new CastExpr ( _right , Type . String ) ; } } } else if ( tleft instanceof ReferenceType ) { _right = new CastExpr ( _right , Type . Reference ) ; } else if ( tright instanceof ReferenceType ) { _left = new CastExpr ( _left , Type . Reference ) ; } else if ( tleft instanceof NodeType && tright == Type . String ) { _left = new CastExpr ( _left , Type . String ) ; } else if ( tleft == Type . String && tright instanceof NodeType ) { _right = new CastExpr ( _right , Type . String ) ; } else if ( tleft instanceof NodeType && tright instanceof NodeType ) { _left = new CastExpr ( _left , Type . String ) ; _right = new CastExpr ( _right , Type . String ) ; } else if ( tleft instanceof NodeType && tright instanceof NodeSetType ) { } else if ( tleft instanceof NodeSetType && tright instanceof NodeType ) { swapArguments ( ) ; } else { if ( tleft instanceof NodeType ) { _left = new CastExpr ( _left , Type . NodeSet ) ; } if ( tright instanceof NodeType ) { _right = new CastExpr ( _right , Type . NodeSet ) ; } if ( tleft . isSimple ( ) || tleft instanceof ResultTreeType && tright instanceof NodeSetType ) { swapArguments ( ) ; } if ( _right . getType ( ) instanceof IntType ) { _right = new CastExpr ( _right , Type . Real ) ; } } return _type = Type . Boolean ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final Type tleft = _left . getType ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( tleft instanceof BooleanType ) { _left . translate ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; _falseList . add ( il . append ( _op == Operators . EQ ? ( BranchInstruction ) new IF_ICMPNE ( null ) : ( BranchInstruction ) new IF_ICMPEQ ( null ) ) ) ; } else if ( tleft instanceof NumberType ) { _left . translate ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; if ( tleft instanceof RealType ) { il . append ( DCMPG ) ; _falseList . add ( il . append ( _op == Operators . EQ ? ( BranchInstruction ) new IFNE ( null ) : ( BranchInstruction ) new IFEQ ( null ) ) ) ; } else { _falseList . add ( il . append ( _op == Operators . EQ ? ( BranchInstruction ) new IF_ICMPNE ( null ) : ( BranchInstruction ) new IF_ICMPEQ ( null ) ) ) ; } } else { translate ( classGen , methodGen ) ; desynthesize ( classGen , methodGen ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final Type tleft = _left . getType ( ) ; Type tright = _right . getType ( ) ; if ( tleft instanceof BooleanType || tleft instanceof NumberType ) { translateDesynthesized ( classGen , methodGen ) ; synthesize ( classGen , methodGen ) ; return ; } if ( tleft instanceof StringType ) { final int equals = cpg . addMethodref ( STRING_CLASS , "equals" , "(" + OBJECT_SIG + ")Z" ) ; _left . translate ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( equals ) ) ; if ( _op == Operators . NE ) { il . append ( ICONST_1 ) ; il . append ( IXOR ) ; } return ; } BranchHandle truec , falsec ; if ( tleft instanceof ResultTreeType ) { if ( tright instanceof BooleanType ) { _right . translate ( classGen , methodGen ) ; if ( _op == Operators . NE ) { il . append ( ICONST_1 ) ; il . append ( IXOR ) ; } return ; } if ( tright instanceof RealType ) { _left . translate ( classGen , methodGen ) ; tleft . translateTo ( classGen , methodGen , Type . Real ) ; _right . translate ( classGen , methodGen ) ; il . append ( DCMPG ) ; falsec = il . append ( _op == Operators . EQ ? ( BranchInstruction ) new IFNE ( null ) : ( BranchInstruction ) new IFEQ ( null ) ) ; il . append ( ICONST_1 ) ; truec = il . append ( new GOTO ( null ) ) ; falsec . setTarget ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; return ; } _left . translate ( classGen , methodGen ) ; tleft . translateTo ( classGen , methodGen , Type . String ) ; _right . translate ( classGen , methodGen ) ; if ( tright instanceof ResultTreeType ) { tright . translateTo ( classGen , methodGen , Type . String ) ; } final int equals = cpg . addMethodref ( STRING_CLASS , "equals" , "(" + OBJECT_SIG + ")Z" ) ; il . append ( new INVOKEVIRTUAL ( equals ) ) ; if ( _op == Operators . NE ) { il . append ( ICONST_1 ) ; il . append ( IXOR ) ; } return ; } if ( tleft instanceof NodeSetType && tright instanceof BooleanType ) { _left . translate ( classGen , methodGen ) ; _left . startIterator ( classGen , methodGen ) ; Type . NodeSet . translateTo ( classGen , methodGen , Type . Boolean ) ; _right . translate ( classGen , methodGen ) ; il . append ( IXOR ) ; if ( _op == EQ ) { il . append ( ICONST_1 ) ; il . append ( IXOR ) ; } return ; } if ( tleft instanceof NodeSetType && tright instanceof StringType ) { _left . translate ( classGen , methodGen ) ; _left . startIterator ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , _op ) ) ; il . append ( methodGen . loadDOM ( ) ) ; final int cmp = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "compare" , "(" + tleft . toSignature ( ) + tright . toSignature ( ) + "I" + DOM_INTF_SIG + ")Z" ) ; il . append ( new INVOKESTATIC ( cmp ) ) ; return ; } _left . translate ( classGen , methodGen ) ; _left . startIterator ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; _right . startIterator ( classGen , methodGen ) ; if ( tright instanceof ResultTreeType ) { tright . translateTo ( classGen , methodGen , Type . String ) ; tright = Type . String ; } il . append ( new PUSH ( cpg , _op ) ) ; il . append ( methodGen . loadDOM ( ) ) ; final int compare = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "compare" , "(" + tleft . toSignature ( ) + tright . toSignature ( ) + "I" + DOM_INTF_SIG + ")Z" ) ; il . append ( new INVOKESTATIC ( compare ) ) ; } } 	1	['12', '3', '0', '37', '49', '0', '1', '36', '11', '0.333333333', '836', '1', '2', '0.865853659', '0.238095238', '2', '8', '68.41666667', '18', '3.25', '1']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemMessage extends ElemTemplateElement { private boolean m_terminate = Constants . ATTRVAL_NO ; public void setTerminate ( boolean v ) { m_terminate = v ; } public boolean getTerminate ( ) { return m_terminate ; } public int getXSLToken ( ) { return Constants . ELEMNAME_MESSAGE ; } public String getNodeName ( ) { return Constants . ELEMNAME_MESSAGE_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; String data = transformer . transformToString ( this ) ; transformer . getMsgMgr ( ) . message ( this , data , m_terminate ) ; if ( m_terminate ) transformer . getErrorListener ( ) . fatalError ( new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_STYLESHEET_DIRECTED_TERMINATION , null ) ) ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } 	1	['6', '3', '0', '6', '17', '3', '1', '5', '6', '0.4', '60', '1', '0', '0.975124378', '0.444444444', '2', '4', '8.833333333', '1', '0.8333', '2']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . MethodGen ; import org . apache . bcel . generic . Type ; public class MethodGenerator extends MethodGen implements org . apache . xalan . xsltc . compiler . Constants { protected static final int INVALID_INDEX = - 1 ; private static final String START_ELEMENT_SIG = "(" + STRING_SIG + ")V" ; private static final String END_ELEMENT_SIG = START_ELEMENT_SIG ; private InstructionList _mapTypeSub ; private static final int DOM_INDEX = 1 ; private static final int ITERATOR_INDEX = 2 ; private static final int HANDLER_INDEX = 3 ; private Instruction _iloadCurrent ; private Instruction _istoreCurrent ; private final Instruction _astoreHandler ; private final Instruction _aloadHandler ; private final Instruction _astoreIterator ; private final Instruction _aloadIterator ; private final Instruction _aloadDom ; private final Instruction _astoreDom ; private final Instruction _startElement ; private final Instruction _endElement ; private final Instruction _startDocument ; private final Instruction _endDocument ; private final Instruction _attribute ; private final Instruction _uniqueAttribute ; private final Instruction _namespace ; private final Instruction _setStartNode ; private final Instruction _reset ; private final Instruction _nextNode ; private SlotAllocator _slotAllocator ; private boolean _allocatorInit = false ; public MethodGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cpg ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cpg ) ; _astoreHandler = new ASTORE ( HANDLER_INDEX ) ; _aloadHandler = new ALOAD ( HANDLER_INDEX ) ; _astoreIterator = new ASTORE ( ITERATOR_INDEX ) ; _aloadIterator = new ALOAD ( ITERATOR_INDEX ) ; _aloadDom = new ALOAD ( DOM_INDEX ) ; _astoreDom = new ASTORE ( DOM_INDEX ) ; final int startElement = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "startElement" , START_ELEMENT_SIG ) ; _startElement = new INVOKEINTERFACE ( startElement , 2 ) ; final int endElement = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "endElement" , END_ELEMENT_SIG ) ; _endElement = new INVOKEINTERFACE ( endElement , 2 ) ; final int attribute = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "addAttribute" , "(" + STRING_SIG + STRING_SIG + ")V" ) ; _attribute = new INVOKEINTERFACE ( attribute , 3 ) ; final int uniqueAttribute = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "addUniqueAttribute" , "(" + STRING_SIG + STRING_SIG + "I)V" ) ; _uniqueAttribute = new INVOKEINTERFACE ( uniqueAttribute , 4 ) ; final int namespace = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "namespaceAfterStartElement" , "(" + STRING_SIG + STRING_SIG + ")V" ) ; _namespace = new INVOKEINTERFACE ( namespace , 3 ) ; int index = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "startDocument" , "()V" ) ; _startDocument = new INVOKEINTERFACE ( index , 1 ) ; index = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "endDocument" , "()V" ) ; _endDocument = new INVOKEINTERFACE ( index , 1 ) ; index = cpg . addInterfaceMethodref ( NODE_ITERATOR , SET_START_NODE , SET_START_NODE_SIG ) ; _setStartNode = new INVOKEINTERFACE ( index , 2 ) ; index = cpg . addInterfaceMethodref ( NODE_ITERATOR , "reset" , "()" + NODE_ITERATOR_SIG ) ; _reset = new INVOKEINTERFACE ( index , 1 ) ; index = cpg . addInterfaceMethodref ( NODE_ITERATOR , NEXT , NEXT_SIG ) ; _nextNode = new INVOKEINTERFACE ( index , 1 ) ; _slotAllocator = new SlotAllocator ( ) ; _slotAllocator . initialize ( getLocalVariables ( ) ) ; _allocatorInit = true ; } public LocalVariableGen addLocalVariable ( String name , Type type , InstructionHandle start , InstructionHandle end ) { return ( _allocatorInit ) ? addLocalVariable2 ( name , type , start ) : super . addLocalVariable ( name , type , start , end ) ; } public LocalVariableGen addLocalVariable2 ( String name , Type type , InstructionHandle start ) { return super . addLocalVariable ( name , type , _slotAllocator . allocateSlot ( type ) , start , null ) ; } public void removeLocalVariable ( LocalVariableGen lvg ) { _slotAllocator . releaseSlot ( lvg ) ; super . removeLocalVariable ( lvg ) ; } public Instruction loadDOM ( ) { return _aloadDom ; } public Instruction storeDOM ( ) { return _astoreDom ; } public Instruction storeHandler ( ) { return _astoreHandler ; } public Instruction loadHandler ( ) { return _aloadHandler ; } public Instruction storeIterator ( ) { return _astoreIterator ; } public Instruction loadIterator ( ) { return _aloadIterator ; } public final Instruction setStartNode ( ) { return _setStartNode ; } public final Instruction reset ( ) { return _reset ; } public final Instruction nextNode ( ) { return _nextNode ; } public final Instruction startElement ( ) { return _startElement ; } public final Instruction endElement ( ) { return _endElement ; } public final Instruction startDocument ( ) { return _startDocument ; } public final Instruction endDocument ( ) { return _endDocument ; } public final Instruction attribute ( ) { return _attribute ; } public final Instruction uniqueAttribute ( ) { return _uniqueAttribute ; } public final Instruction namespace ( ) { return _namespace ; } public Instruction loadCurrentNode ( ) { if ( _iloadCurrent == null ) { int idx = getLocalIndex ( "current" ) ; if ( idx > 0 ) _iloadCurrent = new ILOAD ( idx ) ; else _iloadCurrent = new ICONST ( 0 ) ; } return _iloadCurrent ; } public Instruction storeCurrentNode ( ) { return _istoreCurrent != null ? _istoreCurrent : ( _istoreCurrent = new ISTORE ( getLocalIndex ( "current" ) ) ) ; } public Instruction loadContextNode ( ) { return loadCurrentNode ( ) ; } public Instruction storeContextNode ( ) { return storeCurrentNode ( ) ; } public int getLocalIndex ( String name ) { return getLocalVariable ( name ) . getIndex ( ) ; } public LocalVariableGen getLocalVariable ( String name ) { final LocalVariableGen [ ] vars = getLocalVariables ( ) ; for ( int i = 0 ; i < vars . length ; i ++ ) if ( vars [ i ] . getName ( ) . equals ( name ) ) return vars [ i ] ; return null ; } public void setMaxLocals ( ) { int maxLocals = super . getMaxLocals ( ) ; int prevLocals = maxLocals ; final LocalVariableGen [ ] localVars = super . getLocalVariables ( ) ; if ( localVars != null ) { if ( localVars . length > maxLocals ) maxLocals = localVars . length ; } if ( maxLocals < 5 ) maxLocals = 5 ; super . setMaxLocals ( maxLocals ) ; } } 	1	['27', '4', '6', '137', '49', '311', '122', '15', '27', '0.978632479', '432', '1', '1', '0.788617886', '0.159259259', '1', '2', '14', '4', '1.2963', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . Transformer ; import org . apache . xml . serializer . Serializer ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . ext . DeclHandler ; public interface SerializationHandler extends ExtendedContentHandler , ExtendedLexicalHandler , XSLOutputAttributes , DeclHandler , ErrorHandler , DOMSerializer , Serializer { public void setContentHandler ( ContentHandler ch ) ; public void close ( ) ; public void serialize ( Node node ) throws IOException ; public boolean setEscaping ( boolean escape ) throws SAXException ; public void setIndentAmount ( int spaces ) ; public void setTransformer ( Transformer transformer ) ; public Transformer getTransformer ( ) ; public void setNamespaceMappings ( NamespaceMappings mappings ) ; public void flushPending ( ) throws SAXException ; } 	1	['9', '1', '0', '47', '9', '36', '41', '6', '9', '2', '9', '0', '0', '0', '0.238095238', '0', '0', '0', '1', '1', '3']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_ru extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "В файле определено несколько таблиц стилей. " } , { ErrorMsg . TEMPLATE_REDEF_ERR , "Шаблон ''{0}'' уже определен в этой таблице стилей. " } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "Шаблон ''{0}'' не определен в этой таблице стилей. " } , { ErrorMsg . VARIABLE_REDEF_ERR , "Переменная ''{0}'' определена в одной области действия несколько раз. " } , { ErrorMsg . VARIABLE_UNDEF_ERR , "Переменная или параметр ''{0}'' не определены. " } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "Не найден класс ''{0}''." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "Не найден внешний метод ''{0}'' (должен быть public)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "Невозможно преобразовать тип аргумента/возврата в вызове метода ''{0}''" } , { ErrorMsg . FILE_NOT_FOUND_ERR , "Не найден файл или URI ''{0}''." } , { ErrorMsg . INVALID_URI_ERR , "Недопустимый URI ''{0}''." } , { ErrorMsg . FILE_ACCESS_ERR , "Невозможно открыть файл или URI ''{0}''." } , { ErrorMsg . MISSING_ROOT_ERR , "Ожидался элемент <xsl:stylesheet> или <xsl:transform>." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Префикс ''{0}'' пространства имен не объявлен." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "Невозможно преобразовать вызов функции ''{0}''." } , { ErrorMsg . NEED_LITERAL_ERR , "Аргумент ''{0}'' должен быть литеральной строкой." } , { ErrorMsg . XPATH_PARSER_ERR , "Ошибка при анализе выражения XPath ''{0}''." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Отсутствует обязательный атрибут ''{0}''." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "Недопустимый символ ''{0}'' в выражении XPath." } , { ErrorMsg . ILLEGAL_PI_ERR , "Недопустимое имя ''{0}'' для инструкции обработки." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "Атрибут ''{0}'' вне элемента." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "Недопустимый атрибут ''{0}''." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Циклический импорт/включение. Таблица стилей ''{0}'' уже загружена." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Невозможно отсортировать фрагменты дерева результатов (элементы <xsl:sort> игнорируются). При создании дерева результатов необходимо отсортировать узлы. " } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Десятичное форматирование ''{0}'' уже определено." } , { ErrorMsg . XSL_VERSION_ERR , "Версия XSL ''{0}'' не поддерживается XSLTC." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "Циклическая ссылка на параметр/переменную в ''{0}''." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "Неизвестный оператор в двоичном выражении." } , { ErrorMsg . ILLEGAL_ARG_ERR , "Недопустимые аргументы в вызове функции." } , { ErrorMsg . DOCUMENT_ARG_ERR , "Второй аргумент в функции document() должен быть набором узлов." } , { ErrorMsg . MISSING_WHEN_ERR , "В <xsl:choose> необходим по крайней мере один элемент <xsl:when>." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "<xsl:choose> разрешен только один элемент <xsl:otherwise>." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> может применяться только в <xsl:choose>." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> может применяться только в <xsl:choose>." } , { ErrorMsg . WHEN_ELEMENT_ERR , "В <xsl:choose> разрешены только элементы <xsl:when> и <xsl:otherwise>." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "В <xsl:attribute-set> отсутствует атрибут 'name'." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Недопустимый дочерний элемент." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "Нельзя вызывать элемент ''{0}''" } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "Нельзя вызывать атрибут ''{0}''" } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Текстовые данные вне элемента верхнего уровня <xsl:stylesheet>. " } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "Неправильно настроен анализатор JAXP" } , { ErrorMsg . INTERNAL_ERR , "Неустранимая внутренняя ошибка XSLTC: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "Неподдерживаемый элемент XSL ''{0}''." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "Нераспознанное расширение XSLTC ''{0}''." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "Исходный документ не является таблицей стилей (пространство имен XSL не объявлено в корневом элементе)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Не найден целевой документ таблицы стилей ''{0}''." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Не реализовано: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "Исходный документ не содержит таблицу стилей XSL." } , { ErrorMsg . ELEMENT_PARSE_ERR , "Невозможно проанализировать элемент ''{0}''" } , { ErrorMsg . KEY_USE_ATTR_ERR , "Атрибут use <key> должен быть node, node-set, string или number." } , { ErrorMsg . OUTPUT_VERSION_ERR , "Документ XML должен использовать версию 1.0" } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "Неизвестный оператор в выражении сравнения." } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Попытка воспользоваться несуществующим набором атрибутов ''{0}''." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Невозможно проанализировать шаблон значения атрибута ''{0}''." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "Неизвестный тип данных в сигнатуре класса ''{0}''." } , { ErrorMsg . DATA_CONVERSION_ERR , "Невозможно преобразовать тип данных ''{0}'' в ''{1}''." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "В классе Templates нет допустимого определения класса процедур преобразования." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "В классе Templates нет класса с именем ''{0}''." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Невозможно загрузить класс процедур преобразования ''{0}''." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Класс процедур преобразования загружен, однако создать экземпляр процедуры невозможно." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "Попытка присвоить значение null интерфейсу ErrorListener для ''{0}''" } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "XSLTC поддерживает только StreamSource, SAXSource и DOMSource" } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "Исходный объект, переданный ''{0}'', пуст." } , { ErrorMsg . JAXP_COMPILE_ERR , "Невозможно откомпилировать таблицу стилей" } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory не распознает атрибут ''{0}''." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "Перед startDocument() необходимо вызвать setResult()." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "В интерфейсе Transformer нет инкапсулированного объекта процедуры преобразования." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "Для результатов преобразования не определен обработчик вывода." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "Объект Result, переданный ''{0}'', недопустим." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Попытка обратиться к недопустимому свойству Transformer ''{0}''." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "Невозможно создать адаптер SAX2DOM: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() вызван без предварительной установки systemId. " } , { ErrorMsg . COMPILE_STDIN_ERR , "Опция -i должна применяться вместе с опцией -o." } , { ErrorMsg . COMPILE_USAGE_STR , "Формат\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <вывод>]\n [-d <каталог>] [-j <файл-jar>] [-p <пакет>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <таблица-стилей> | -i }\n\nOPTIONS\n   -o <вывод> присваивает созданной процедуре преобразования имя <вывод>\n  По умолчанию имя процедуры преобразования\n берется из имени <таблицы-стилей>. При компиляции нескольких таблиц стилей\n                  эта опция игнорируется.\n-d <каталог> задает целевой каталог для процедуры преобразования\n   -j <файл-jar> упаковывает классы процедуры преобразования \n                  в <файл-jar> с указанным именем\n   -p <пакет>   задает префикс имени пакета для всех созданных\n                  классов процедуры преобразования\n -n             разрешает копирование строк шаблона (обычно способ, применяемый по умолчанию,\n работает лучше).\n   -x             включает вывод отладочных сообщений\n   -s  выключает вызов System.exit\n   -u             интерпретирует аргументы <таблицы-стилей>  как URL\n   -i             указывает, что компилятор должен считывать таблицу стилей из стандартного ввода\n   -v             выводит информацию о версии компилятора\n   -h выводит данное сообщение\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "Формат\n   java org.apache.xalan.xsltc.cmdline.Transform [-j <файл-jar>]\n      [-x] [-s] [-n <счетчик>]  {-u <url-документа> | <документ>}\n  <класс> [<параметр1>=<значение1> ...]\n\n применяет <класс> процедуры преобразования для преобразования \n <документа> XML с указанным именем. <Класс> процедуры преобразования должен быть доступен либо \n   с помощью CLASSPATH пользователя, либо с помощью указанного <файла-jar>.\nОпции\n   -j <файл-jar>    задает файл jar, из которого загружается процедура преобразования\n  -x              включает отладочные сообщения\n   -s  выключает вызов System.exit\n   -n <итерации> выполняет преобразование <счетчик> раз и\n                   показывает информацию профилирования\n  -u <url-документа> задает исходный документ XML в виде URL\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> может применяться только в <xsl:for-each> или <xsl:apply-templates>." } , { ErrorMsg . UNSUPPORTED_ENCODING , "Целевая кодировка ''{0}'' не поддерживается этой JVM." } , { ErrorMsg . SYNTAX_ERR , "Синтаксическая ошибка в ''{0}''." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "Не найден внешний конструктор ''{0}''." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "Первый аргумент в не статической функции Java ''{0}'' не является допустимой ссылкой на объект." } , { ErrorMsg . TYPE_CHECK_ERR , "Ошибка при проверке типа выражения ''{0}''." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Ошибка при проверке типа выражения в неизвестном расположении." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "Недопустимая опция командной строки ''{0}''." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "Не указан обязательный аргумент опции командной строки ''{0}''. " } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "Предупреждение:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "Предупреждение:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "Критическая ошибка:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "Критическая ошибка:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "Ошибка:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "Ошибка:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "Преобразование с помощью процедуры ''{0}'' " } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "Преобразование с помощью процедуры ''{0}'' из файла jar ''{1}''" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "Невозможно создать экземпляр класса TransformerFactory ''{0}''." } , { ErrorMsg . COMPILER_ERROR_KEY , "Ошибки компилятора:" } , { ErrorMsg . COMPILER_WARNING_KEY , "Предупреждения компилятора:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Ошибки процедуры преобразования:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xpath ; import java . io . IOException ; import java . util . Vector ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . SystemIDResolver ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class SourceTreeManager { private Vector m_sourceTree = new Vector ( ) ; public void reset ( ) { m_sourceTree = new Vector ( ) ; } URIResolver m_uriResolver ; public void setURIResolver ( URIResolver resolver ) { m_uriResolver = resolver ; } public URIResolver getURIResolver ( ) { return m_uriResolver ; } public String findURIFromDoc ( int owner ) { int n = m_sourceTree . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SourceTree sTree = ( SourceTree ) m_sourceTree . elementAt ( i ) ; if ( owner == sTree . m_root ) return sTree . m_url ; } return null ; } public Source resolveURI ( String base , String urlString , SourceLocator locator ) throws TransformerException , IOException { Source source = null ; if ( null != m_uriResolver ) { source = m_uriResolver . resolve ( urlString , base ) ; } if ( null == source ) { String uri = SystemIDResolver . getAbsoluteURI ( urlString , base ) ; source = new StreamSource ( uri ) ; } return source ; } public void removeDocumentFromCache ( int n ) { if ( DTM . NULL == n ) return ; for ( int i = m_sourceTree . size ( ) - 1 ; i >= 0 ; -- i ) { SourceTree st = ( SourceTree ) m_sourceTree . elementAt ( i ) ; if ( st != null && st . m_root == n ) { m_sourceTree . removeElementAt ( i ) ; return ; } } } public void putDocumentInCache ( int n , Source source ) { int cachedNode = getNode ( source ) ; if ( DTM . NULL != cachedNode ) { if ( ! ( cachedNode == n ) ) throw new RuntimeException ( "Programmer's Error!  " + "putDocumentInCache found reparse of doc: " + source . getSystemId ( ) ) ; return ; } if ( null != source . getSystemId ( ) ) { m_sourceTree . addElement ( new SourceTree ( n , source . getSystemId ( ) ) ) ; } } public int getNode ( Source source ) { String url = source . getSystemId ( ) ; if ( null == url ) return DTM . NULL ; int n = m_sourceTree . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { SourceTree sTree = ( SourceTree ) m_sourceTree . elementAt ( i ) ; if ( url . equals ( sTree . m_url ) ) return sTree . m_root ; } return DTM . NULL ; } public int getSourceTree ( String base , String urlString , SourceLocator locator , XPathContext xctxt ) throws TransformerException { try { Source source = this . resolveURI ( base , urlString , locator ) ; return getSourceTree ( source , locator , xctxt ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe . getMessage ( ) , locator , ioe ) ; } } public int getSourceTree ( Source source , SourceLocator locator , XPathContext xctxt ) throws TransformerException { int n = getNode ( source ) ; if ( DTM . NULL != n ) return n ; n = parseToNode ( source , locator , xctxt ) ; if ( DTM . NULL != n ) putDocumentInCache ( n , source ) ; return n ; } public int parseToNode ( Source source , SourceLocator locator , XPathContext xctxt ) throws TransformerException { try { Object xowner = xctxt . getOwnerObject ( ) ; DTM dtm ; if ( null != xowner && xowner instanceof org . apache . xml . dtm . DTMWSFilter ) { dtm = xctxt . getDTM ( source , false , ( org . apache . xml . dtm . DTMWSFilter ) xowner , false , true ) ; } else { dtm = xctxt . getDTM ( source , false , null , false , true ) ; } return dtm . getDocument ( ) ; } catch ( Exception e ) { throw new TransformerException ( e . getMessage ( ) , locator , e ) ; } } public static XMLReader getXMLReader ( Source inputSource , SourceLocator locator ) throws TransformerException { try { XMLReader reader = ( inputSource instanceof SAXSource ) ? ( ( SAXSource ) inputSource ) . getXMLReader ( ) : null ; if ( null == reader ) { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) reader = XMLReaderFactory . createXMLReader ( ) ; } try { reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } return reader ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se . getMessage ( ) , locator , se ) ; } } } 	1	['13', '1', '0', '8', '46', '42', '4', '5', '13', '0.625', '339', '0.5', '0', '0', '0.340659341', '0', '0', '24.92307692', '5', '1.8462', '1']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMDOMException ; import org . w3c . dom . Attr ; import org . w3c . dom . CDATASection ; import org . w3c . dom . Comment ; import org . w3c . dom . DOMException ; import org . w3c . dom . DOMImplementation ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . EntityReference ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; public class DTMNodeProxy implements Node , Document , Text , Element , Attr , ProcessingInstruction , Comment , DocumentFragment { public DTM dtm ; int node ; static final DOMImplementation implementation = new DTMNodeProxyImplementation ( ) ; public DTMNodeProxy ( DTM dtm , int node ) { this . dtm = dtm ; this . node = node ; } public final DTM getDTM ( ) { return dtm ; } public final int getDTMNodeNumber ( ) { return node ; } public final boolean equals ( Node node ) { try { DTMNodeProxy dtmp = ( DTMNodeProxy ) node ; return ( dtmp . node == this . node ) && ( dtmp . dtm == this . dtm ) ; } catch ( ClassCastException cce ) { return false ; } } public final boolean equals ( Object node ) { try { return equals ( ( Node ) node ) ; } catch ( ClassCastException cce ) { return false ; } } public final boolean sameNodeAs ( Node other ) { if ( ! ( other instanceof DTMNodeProxy ) ) return false ; DTMNodeProxy that = ( DTMNodeProxy ) other ; return this . dtm == that . dtm && this . node == that . node ; } public final String getNodeName ( ) { return dtm . getNodeName ( node ) ; } public final String getTarget ( ) { return dtm . getNodeName ( node ) ; } public final String getLocalName ( ) { return dtm . getLocalName ( node ) ; } public final String getPrefix ( ) { return dtm . getPrefix ( node ) ; } public final void setPrefix ( String prefix ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final String getNamespaceURI ( ) { return dtm . getNamespaceURI ( node ) ; } public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; } public final boolean isSupported ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; } public final String getNodeValue ( ) throws DOMException { return dtm . getNodeValue ( node ) ; } public final String getStringValue ( ) throws DOMException { return dtm . getStringValue ( node ) . toString ( ) ; } public final void setNodeValue ( String nodeValue ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final short getNodeType ( ) { return ( short ) dtm . getNodeType ( node ) ; } public final Node getParentNode ( ) { if ( getNodeType ( ) == Node . ATTRIBUTE_NODE ) return null ; int newnode = dtm . getParent ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final Node getOwnerNode ( ) { int newnode = dtm . getParent ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final NodeList getChildNodes ( ) { return new DTMChildIterNodeList ( dtm , node ) ; } public final Node getFirstChild ( ) { int newnode = dtm . getFirstChild ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final Node getLastChild ( ) { int newnode = dtm . getLastChild ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final Node getPreviousSibling ( ) { int newnode = dtm . getPreviousSibling ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final Node getNextSibling ( ) { if ( dtm . getNodeType ( node ) == Node . ATTRIBUTE_NODE ) return null ; int newnode = dtm . getNextSibling ( node ) ; return ( newnode == DTM . NULL ) ? null : dtm . getNode ( newnode ) ; } public final NamedNodeMap getAttributes ( ) { return new DTMNamedNodeMap ( dtm , node ) ; } public boolean hasAttribute ( String name ) { return DTM . NULL != dtm . getAttributeNode ( node , null , name ) ; } public boolean hasAttributeNS ( String name , String x ) { return DTM . NULL != dtm . getAttributeNode ( node , x , name ) ; } public final Document getOwnerDocument ( ) { return ( Document ) ( dtm . getNode ( dtm . getOwnerDocument ( node ) ) ) ; } public final Node insertBefore ( Node newChild , Node refChild ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final Node removeChild ( Node oldChild ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final Node appendChild ( Node newChild ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final boolean hasChildNodes ( ) { return ( DTM . NULL != dtm . getFirstChild ( node ) ) ; } public final Node cloneNode ( boolean deep ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final DocumentType getDoctype ( ) { return null ; } public final DOMImplementation getImplementation ( ) { return implementation ; } public final Element getDocumentElement ( ) { int dochandle = dtm . getDocument ( ) ; int elementhandle = DTM . NULL ; for ( int kidhandle = dtm . getFirstChild ( dochandle ) ; kidhandle != DTM . NULL ; kidhandle = dtm . getNextSibling ( kidhandle ) ) { switch ( dtm . getNodeType ( kidhandle ) ) { case Node . ELEMENT_NODE : if ( elementhandle != DTM . NULL ) { elementhandle = DTM . NULL ; kidhandle = dtm . getLastChild ( dochandle ) ; } else elementhandle = kidhandle ; break ; case Node . COMMENT_NODE : case Node . PROCESSING_INSTRUCTION_NODE : case Node . DOCUMENT_TYPE_NODE : break ; default : elementhandle = DTM . NULL ; kidhandle = dtm . getLastChild ( dochandle ) ; break ; } } if ( elementhandle == DTM . NULL ) throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; else return ( Element ) ( dtm . getNode ( elementhandle ) ) ; } public final Element createElement ( String tagName ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final DocumentFragment createDocumentFragment ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Text createTextNode ( String data ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Comment createComment ( String data ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final CDATASection createCDATASection ( String data ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr createAttribute ( String name ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final EntityReference createEntityReference ( String name ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final NodeList getElementsByTagName ( String tagname ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Node importNode ( Node importedNode , boolean deep ) throws DOMException { throw new DTMDOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR ) ; } public final Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Element getElementById ( String elementId ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Text splitText ( int offset ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final String getData ( ) throws DOMException { return dtm . getNodeValue ( node ) ; } public final void setData ( String data ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final int getLength ( ) { return dtm . getNodeValue ( node ) . length ( ) ; } public final String substringData ( int offset , int count ) throws DOMException { return getData ( ) . substring ( offset , offset + count ) ; } public final void appendData ( String arg ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void insertData ( int offset , String arg ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void deleteData ( int offset , int count ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void replaceData ( int offset , int count , String arg ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final String getTagName ( ) { return dtm . getNodeName ( node ) ; } public final String getAttribute ( String name ) { DTMNamedNodeMap map = new DTMNamedNodeMap ( dtm , node ) ; Node node = map . getNamedItem ( name ) ; return ( null == node ) ? null : node . getNodeValue ( ) ; } public final void setAttribute ( String name , String value ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void removeAttribute ( String name ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr getAttributeNode ( String name ) { DTMNamedNodeMap map = new DTMNamedNodeMap ( dtm , node ) ; return ( Attr ) map . getNamedItem ( name ) ; } public final Attr setAttributeNode ( Attr newAttr ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr removeAttributeNode ( Attr oldAttr ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public boolean hasAttributes ( ) { return DTM . NULL != dtm . getFirstAttribute ( node ) ; } public final void normalize ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final String getAttributeNS ( String namespaceURI , String localName ) { DTMNamedNodeMap map = new DTMNamedNodeMap ( dtm , node ) ; Node node = map . getNamedItemNS ( namespaceURI , localName ) ; return ( null == node ) ? null : node . getNodeValue ( ) ; } public final void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr getAttributeNodeNS ( String namespaceURI , String localName ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final String getName ( ) { return dtm . getNodeName ( node ) ; } public final boolean getSpecified ( ) { return true ; } public final String getValue ( ) { return dtm . getNodeValue ( node ) ; } public final void setValue ( String value ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public final Element getOwnerElement ( ) { if ( getNodeType ( ) != Node . ATTRIBUTE_NODE ) return null ; int newnode = dtm . getParent ( node ) ; return ( newnode == DTM . NULL ) ? null : ( Element ) ( dtm . getNode ( newnode ) ) ; } public Node adoptNode ( Node source ) throws DOMException { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public String getEncoding ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public void setEncoding ( String encoding ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public boolean getStandalone ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public void setStandalone ( boolean standalone ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public boolean getStrictErrorChecking ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public void setStrictErrorChecking ( boolean strictErrorChecking ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public String getVersion ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public void setVersion ( String version ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } static class DTMNodeProxyImplementation implements DOMImplementation { public DocumentType createDocumentType ( String qualifiedName , String publicId , String systemId ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public Document createDocument ( String namespaceURI , String qualfiedName , DocumentType doctype ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public boolean hasFeature ( String feature , String version ) { if ( ( "CORE" . equals ( feature . toUpperCase ( ) ) || "XML" . equals ( feature . toUpperCase ( ) ) ) && ( "1.0" . equals ( version ) || "2.0" . equals ( version ) ) ) return true ; return false ; } } } 	1	['121', '1', '0', '13', '151', '5992', '7', '6', '120', '0.794444444', '1009', '0', '1', '0', '0.185185185', '0', '0', '7.314049587', '4', '1.1818', '2']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IF_ICMPEQ ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; final class ProcessingInstructionPattern extends StepPattern { private String _name = null ; private boolean _typeChecked = false ; public ProcessingInstructionPattern ( String name ) { super ( Axis . CHILD , DTM . PROCESSING_INSTRUCTION_NODE , null ) ; _name = name ; } public double getDefaultPriority ( ) { return ( _name != null ) ? 0.0 : - 0.5 ; } public String toString ( ) { if ( _predicates == null ) return "processing-instruction(" + _name + ")" ; else return "processing-instruction(" + _name + ")" + _predicates ; } public void reduceKernelPattern ( ) { _typeChecked = true ; } public boolean isWildcard ( ) { return false ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( hasPredicates ( ) ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; pred . typeCheck ( stable ) ; } } return Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int gname = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeName" , "(I)Ljava/lang/String;" ) ; int cmp = cpg . addMethodref ( STRING_CLASS , "equals" , "(Ljava/lang/Object;)Z" ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; if ( ! _typeChecked ) { il . append ( methodGen . loadCurrentNode ( ) ) ; final int getType = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( getType , 2 ) ) ; il . append ( new PUSH ( cpg , DTM . PROCESSING_INSTRUCTION_NODE ) ) ; _falseList . add ( il . append ( new IF_ICMPEQ ( null ) ) ) ; } il . append ( new PUSH ( cpg , _name ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( new INVOKEINTERFACE ( gname , 2 ) ) ; il . append ( new INVOKEVIRTUAL ( cmp ) ) ; _falseList . add ( il . append ( new IFEQ ( null ) ) ) ; if ( hasPredicates ( ) ) { final int n = _predicates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Predicate pred = ( Predicate ) _predicates . elementAt ( i ) ; Expression exp = pred . getExpr ( ) ; exp . translateDesynthesized ( classGen , methodGen ) ; _trueList . append ( exp . _trueList ) ; _falseList . append ( exp . _falseList ) ; } } InstructionHandle restore ; restore = il . append ( methodGen . storeCurrentNode ( ) ) ; backPatchTrueList ( restore ) ; BranchHandle skipFalse = il . append ( new GOTO ( null ) ) ; restore = il . append ( methodGen . storeCurrentNode ( ) ) ; backPatchFalseList ( restore ) ; _falseList . add ( il . append ( new GOTO ( null ) ) ) ; skipFalse . setTarget ( il . append ( NOP ) ) ; } } 	1	['7', '7', '0', '23', '40', '1', '0', '23', '7', '0.583333333', '297', '1', '0', '0.951612903', '0.314285714', '5', '11', '41.14285714', '4', '1.5714', '1']
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages_tr extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "''{0}'' sınıfında çalışma zamanı iç hatası " } , { BasisLibrary . RUN_TIME_COPY_ERR , "<xsl:copy> yürütülürken çalışma zamanı hatası." } , { BasisLibrary . DATA_CONVERSION_ERR , "''{0}'' tipinden ''{1}'' tipine dönüştürme geçersiz." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "''{0}'' dış işlevi XSLTC tarafından desteklenmiyor." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Eşitlik ifadesinde bilinmeyen bağımsız değişken tipi." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "''{1}'' işlevi çağrısında ''{0}'' bağımsız değişken tipi geçersiz " } , { BasisLibrary . FORMAT_NUMBER_ERR , "''{0}'' sayısını ''{1}'' örüntüsünü kullanarak biçimleme girişimi." } , { BasisLibrary . ITERATOR_CLONE_ERR , "''{0}'' yineleyicisinin eşkopyası yaratılamıyor." } , { BasisLibrary . AXIS_SUPPORT_ERR , "''{0}'' ekseni için yineleyici desteklenmiyor." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Tip atanmış ''{0}'' ekseni için yineleyici desteklenmiyor." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "''{0}'' özniteliği öğenin dışında." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "''{0}''=''{1}'' ad alanı bildirimi öğenin dışında." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "''{0}'' önekine ilişkin ad alanı bildirilmedi." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter, yanlış tipte kaynak DOM kullanılarak yaratıldı." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "Kullandığınız SAX ayrıştırıcısı DTD bildirim olaylarını işlemiyor." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "Kullandığınız SAX ayrıştırıcısının XML ad alanları desteği yok." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "''{0}'' URI başvurusu çözülemedi." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '234', '1', '0', '0.974358974', '1', '0', '0', '76.66666667', '1', '0.3333', '1']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; import org . apache . xml . dtm . ref . DTMManagerDefault ; import org . apache . xml . serializer . EmptySerializer ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringDefault ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import javax . xml . transform . SourceLocator ; public class SimpleResultTreeImpl extends EmptySerializer implements DOM , DTM { public final class SimpleIterator extends DTMAxisIteratorBase { static final int DIRECTION_UP = 0 ; static final int DIRECTION_DOWN = 1 ; static final int NO_TYPE = - 1 ; int _direction = DIRECTION_DOWN ; int _type = NO_TYPE ; int _currentNode ; public SimpleIterator ( ) { } public SimpleIterator ( int direction ) { _direction = direction ; } public SimpleIterator ( int direction , int type ) { _direction = direction ; _type = type ; } public int next ( ) { if ( _direction == DIRECTION_DOWN ) { while ( _currentNode < NUMBER_OF_NODES ) { if ( _type != NO_TYPE ) { if ( ( _currentNode == RTF_ROOT && _type == DTM . ROOT_NODE ) || ( _currentNode == RTF_TEXT && _type == DTM . TEXT_NODE ) ) return returnNode ( getNodeHandle ( _currentNode ++ ) ) ; else _currentNode ++ ; } else return returnNode ( getNodeHandle ( _currentNode ++ ) ) ; } return END ; } else { while ( _currentNode >= 0 ) { if ( _type != NO_TYPE ) { if ( ( _currentNode == RTF_ROOT && _type == DTM . ROOT_NODE ) || ( _currentNode == RTF_TEXT && _type == DTM . TEXT_NODE ) ) return returnNode ( getNodeHandle ( _currentNode -- ) ) ; else _currentNode -- ; } else return returnNode ( getNodeHandle ( _currentNode -- ) ) ; } return END ; } } public DTMAxisIterator setStartNode ( int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; _startNode = nodeID ; if ( ! _includeSelf && nodeID != DTM . NULL ) { if ( _direction == DIRECTION_DOWN ) nodeID ++ ; else if ( _direction == DIRECTION_UP ) nodeID -- ; } _currentNode = nodeID ; return this ; } public void setMark ( ) { _markedNode = _currentNode ; } public void gotoMark ( ) { _currentNode = _markedNode ; } } public final class SingletonIterator extends DTMAxisIteratorBase { static final int NO_TYPE = - 1 ; int _type = NO_TYPE ; int _currentNode ; public SingletonIterator ( ) { } public SingletonIterator ( int type ) { _type = type ; } public void setMark ( ) { _markedNode = _currentNode ; } public void gotoMark ( ) { _currentNode = _markedNode ; } public DTMAxisIterator setStartNode ( int nodeHandle ) { _currentNode = _startNode = getNodeIdent ( nodeHandle ) ; return this ; } public int next ( ) { if ( _currentNode == END ) return END ; _currentNode = END ; if ( _type != NO_TYPE ) { if ( ( _currentNode == RTF_ROOT && _type == DTM . ROOT_NODE ) || ( _currentNode == RTF_TEXT && _type == DTM . TEXT_NODE ) ) return getNodeHandle ( _currentNode ) ; } else return getNodeHandle ( _currentNode ) ; return END ; } } private final static DTMAxisIterator EMPTY_ITERATOR = new DTMAxisIteratorBase ( ) { public DTMAxisIterator reset ( ) { return this ; } public DTMAxisIterator setStartNode ( int node ) { return this ; } public int next ( ) { return DTM . NULL ; } public void setMark ( ) { } public void gotoMark ( ) { } public int getLast ( ) { return 0 ; } public int getPosition ( ) { return 0 ; } public DTMAxisIterator cloneIterator ( ) { return this ; } public void setRestartable ( boolean isRestartable ) { } } ; public static final int RTF_ROOT = 0 ; public static final int RTF_TEXT = 1 ; public static final int NUMBER_OF_NODES = 2 ; private static int _documentURIIndex = 0 ; private static final String EMPTY_STR = "" ; private String _text ; protected String [ ] _textArray ; protected XSLTCDTMManager _dtmManager ; protected int _size = 0 ; private int _documentID ; private BitArray _dontEscape = null ; private boolean _escaping = true ; public SimpleResultTreeImpl ( XSLTCDTMManager dtmManager , int documentID ) { _dtmManager = dtmManager ; _documentID = documentID ; _textArray = new String [ 4 ] ; } public DTMManagerDefault getDTMManager ( ) { return _dtmManager ; } public int getDocument ( ) { return _documentID ; } public String getStringValue ( ) { return _text ; } public DTMAxisIterator getIterator ( ) { return new SingletonIterator ( getDocument ( ) ) ; } public DTMAxisIterator getChildren ( final int node ) { return new SimpleIterator ( ) . setStartNode ( node ) ; } public DTMAxisIterator getTypedChildren ( final int type ) { return new SimpleIterator ( SimpleIterator . DIRECTION_DOWN , type ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { switch ( axis ) { case Axis . CHILD : case Axis . DESCENDANT : return new SimpleIterator ( SimpleIterator . DIRECTION_DOWN ) ; case Axis . PARENT : case Axis . ANCESTOR : return new SimpleIterator ( SimpleIterator . DIRECTION_UP ) ; case Axis . ANCESTORORSELF : return ( new SimpleIterator ( SimpleIterator . DIRECTION_UP ) ) . includeSelf ( ) ; case Axis . DESCENDANTORSELF : return ( new SimpleIterator ( SimpleIterator . DIRECTION_DOWN ) ) . includeSelf ( ) ; case Axis . SELF : return new SingletonIterator ( ) ; default : return EMPTY_ITERATOR ; } } public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) { switch ( axis ) { case Axis . CHILD : case Axis . DESCENDANT : return new SimpleIterator ( SimpleIterator . DIRECTION_DOWN , type ) ; case Axis . PARENT : case Axis . ANCESTOR : return new SimpleIterator ( SimpleIterator . DIRECTION_UP , type ) ; case Axis . ANCESTORORSELF : return ( new SimpleIterator ( SimpleIterator . DIRECTION_UP , type ) ) . includeSelf ( ) ; case Axis . DESCENDANTORSELF : return ( new SimpleIterator ( SimpleIterator . DIRECTION_DOWN , type ) ) . includeSelf ( ) ; case Axis . SELF : return new SingletonIterator ( type ) ; default : return EMPTY_ITERATOR ; } } public DTMAxisIterator getNthDescendant ( int node , int n , boolean includeself ) { return null ; } public DTMAxisIterator getNamespaceAxisIterator ( final int axis , final int ns ) { return null ; } public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iter , int returnType , String value , boolean op ) { return null ; } public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) { return source ; } public String getNodeName ( final int node ) { if ( getNodeIdent ( node ) == RTF_TEXT ) return "#text" ; else return EMPTY_STR ; } public String getNodeNameX ( final int node ) { return EMPTY_STR ; } public String getNamespaceName ( final int node ) { return EMPTY_STR ; } public int getExpandedTypeID ( final int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_TEXT ) return DTM . TEXT_NODE ; else if ( nodeID == RTF_ROOT ) return DTM . ROOT_NODE ; else return DTM . NULL ; } public int getNamespaceType ( final int node ) { return 0 ; } public int getParent ( final int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; return ( nodeID == RTF_TEXT ) ? getNodeHandle ( RTF_ROOT ) : DTM . NULL ; } public int getAttributeNode ( final int gType , final int element ) { return DTM . NULL ; } public String getStringValueX ( final int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_ROOT || nodeID == RTF_TEXT ) return _text ; else return EMPTY_STR ; } public void copy ( final int node , SerializationHandler handler ) throws TransletException { characters ( node , handler ) ; } public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException { int node ; while ( ( node = nodes . next ( ) ) != DTM . NULL ) { copy ( node , handler ) ; } } public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException { characters ( node , handler ) ; return null ; } public boolean lessThan ( final int node1 , final int node2 ) { if ( node1 == DTM . NULL ) { return false ; } else if ( node2 == DTM . NULL ) { return true ; } else return ( node1 < node2 ) ; } public void characters ( final int node , SerializationHandler handler ) throws TransletException { int nodeID = getNodeIdent ( node ) ; if ( nodeID == RTF_ROOT || nodeID == RTF_TEXT ) { boolean escapeBit = false ; boolean oldEscapeSetting = false ; try { for ( int i = 0 ; i < _size ; i ++ ) { if ( _dontEscape != null ) { escapeBit = _dontEscape . getBit ( i ) ; if ( escapeBit ) { oldEscapeSetting = handler . setEscaping ( false ) ; } } handler . characters ( _textArray [ i ] ) ; if ( escapeBit ) { handler . setEscaping ( oldEscapeSetting ) ; } } } catch ( SAXException e ) { throw new TransletException ( e ) ; } } } public Node makeNode ( int index ) { return null ; } public Node makeNode ( DTMAxisIterator iter ) { return null ; } public NodeList makeNodeList ( int index ) { return null ; } public NodeList makeNodeList ( DTMAxisIterator iter ) { return null ; } public String getLanguage ( int node ) { return null ; } public int getSize ( ) { return 2 ; } public String getDocumentURI ( int node ) { return "simple_rtf" + _documentURIIndex ++ ; } public void setFilter ( StripFilter filter ) { } public void setupMapping ( String [ ] names , String [ ] uris , int [ ] types , String [ ] namespaces ) { } public boolean isElement ( final int node ) { return false ; } public boolean isAttribute ( final int node ) { return false ; } public String lookupNamespace ( int node , String prefix ) throws TransletException { return null ; } public int getNodeIdent ( final int nodehandle ) { return ( nodehandle != DTM . NULL ) ? ( nodehandle - _documentID ) : DTM . NULL ; } public int getNodeHandle ( final int nodeId ) { return ( nodeId != DTM . NULL ) ? ( nodeId + _documentID ) : DTM . NULL ; } public DOM getResultTreeFrag ( int initialSize , int rtfType ) { return null ; } public DOM getResultTreeFrag ( int initialSize , int rtfType , boolean addToManager ) { return null ; } public SerializationHandler getOutputDomBuilder ( ) { return this ; } public int getNSType ( int node ) { return 0 ; } public String getUnparsedEntityURI ( String name ) { return null ; } public Hashtable getElementsWithIDs ( ) { return null ; } public void startDocument ( ) throws SAXException { } public void endDocument ( ) throws SAXException { if ( _size == 1 ) _text = _textArray [ 0 ] ; else { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 ; i < _size ; i ++ ) { buffer . append ( _textArray [ i ] ) ; } _text = buffer . toString ( ) ; } } public void characters ( String str ) throws SAXException { if ( _size >= _textArray . length ) { String [ ] newTextArray = new String [ _textArray . length * 2 ] ; System . arraycopy ( _textArray , 0 , newTextArray , 0 , _textArray . length ) ; _textArray = newTextArray ; } if ( ! _escaping ) { if ( _dontEscape == null ) { _dontEscape = new BitArray ( 8 ) ; } if ( _size >= _dontEscape . size ( ) ) _dontEscape . resize ( _dontEscape . size ( ) * 2 ) ; _dontEscape . setBit ( _size ) ; } _textArray [ _size ++ ] = str ; } public void characters ( char [ ] ch , int offset , int length ) throws SAXException { if ( _size >= _textArray . length ) { String [ ] newTextArray = new String [ _textArray . length * 2 ] ; System . arraycopy ( _textArray , 0 , newTextArray , 0 , _textArray . length ) ; _textArray = newTextArray ; } if ( ! _escaping ) { if ( _dontEscape == null ) { _dontEscape = new BitArray ( 8 ) ; } if ( _size >= _dontEscape . size ( ) ) _dontEscape . resize ( _dontEscape . size ( ) * 2 ) ; _dontEscape . setBit ( _size ) ; } _textArray [ _size ++ ] = new String ( ch , offset , length ) ; } public boolean setEscaping ( boolean escape ) throws SAXException { final boolean temp = _escaping ; _escaping = escape ; return temp ; } public void setFeature ( String featureId , boolean state ) { } public void setProperty ( String property , Object value ) { } public DTMAxisTraverser getAxisTraverser ( final int axis ) { return null ; } public boolean hasChildNodes ( int nodeHandle ) { return ( getNodeIdent ( nodeHandle ) == RTF_ROOT ) ; } public int getFirstChild ( int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_ROOT ) return getNodeHandle ( RTF_TEXT ) ; else return DTM . NULL ; } public int getLastChild ( int nodeHandle ) { return getFirstChild ( nodeHandle ) ; } public int getAttributeNode ( int elementHandle , String namespaceURI , String name ) { return DTM . NULL ; } public int getFirstAttribute ( int nodeHandle ) { return DTM . NULL ; } public int getFirstNamespaceNode ( int nodeHandle , boolean inScope ) { return DTM . NULL ; } public int getNextSibling ( int nodeHandle ) { return DTM . NULL ; } public int getPreviousSibling ( int nodeHandle ) { return DTM . NULL ; } public int getNextAttribute ( int nodeHandle ) { return DTM . NULL ; } public int getNextNamespaceNode ( int baseHandle , int namespaceHandle , boolean inScope ) { return DTM . NULL ; } public int getOwnerDocument ( int nodeHandle ) { return getDocument ( ) ; } public int getDocumentRoot ( int nodeHandle ) { return getDocument ( ) ; } public XMLString getStringValue ( int nodeHandle ) { return new XMLStringDefault ( getStringValueX ( nodeHandle ) ) ; } public int getStringValueChunkCount ( int nodeHandle ) { return 0 ; } public char [ ] getStringValueChunk ( int nodeHandle , int chunkIndex , int [ ] startAndLen ) { return null ; } public int getExpandedTypeID ( String namespace , String localName , int type ) { return DTM . NULL ; } public String getLocalNameFromExpandedNameID ( int ExpandedNameID ) { return EMPTY_STR ; } public String getNamespaceFromExpandedNameID ( int ExpandedNameID ) { return EMPTY_STR ; } public String getLocalName ( int nodeHandle ) { return EMPTY_STR ; } public String getPrefix ( int nodeHandle ) { return null ; } public String getNamespaceURI ( int nodeHandle ) { return EMPTY_STR ; } public String getNodeValue ( int nodeHandle ) { return ( getNodeIdent ( nodeHandle ) == RTF_TEXT ) ? _text : null ; } public short getNodeType ( int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_TEXT ) return DTM . TEXT_NODE ; else if ( nodeID == RTF_ROOT ) return DTM . ROOT_NODE ; else return DTM . NULL ; } public short getLevel ( int nodeHandle ) { int nodeID = getNodeIdent ( nodeHandle ) ; if ( nodeID == RTF_TEXT ) return 2 ; else if ( nodeID == RTF_ROOT ) return 1 ; else return DTM . NULL ; } public boolean isSupported ( String feature , String version ) { return false ; } public String getDocumentBaseURI ( ) { return EMPTY_STR ; } public void setDocumentBaseURI ( String baseURI ) { } public String getDocumentSystemIdentifier ( int nodeHandle ) { return null ; } public String getDocumentEncoding ( int nodeHandle ) { return null ; } public String getDocumentStandalone ( int nodeHandle ) { return null ; } public String getDocumentVersion ( int documentHandle ) { return null ; } public boolean getDocumentAllDeclarationsProcessed ( ) { return false ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { return null ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { return null ; } public int getElementById ( String elementId ) { return DTM . NULL ; } public boolean supportsPreStripping ( ) { return false ; } public boolean isNodeAfter ( int firstNodeHandle , int secondNodeHandle ) { return lessThan ( firstNodeHandle , secondNodeHandle ) ; } public boolean isCharacterElementContentWhitespace ( int nodeHandle ) { return false ; } public boolean isDocumentAllDeclarationsProcessed ( int documentHandle ) { return false ; } public boolean isAttributeSpecified ( int attributeHandle ) { return false ; } public void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { } public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { } public org . w3c . dom . Node getNode ( int nodeHandle ) { return makeNode ( nodeHandle ) ; } public boolean needsTwoThreads ( ) { return false ; } public org . xml . sax . ContentHandler getContentHandler ( ) { return null ; } public org . xml . sax . ext . LexicalHandler getLexicalHandler ( ) { return null ; } public org . xml . sax . EntityResolver getEntityResolver ( ) { return null ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return null ; } public org . xml . sax . ErrorHandler getErrorHandler ( ) { return null ; } public org . xml . sax . ext . DeclHandler getDeclHandler ( ) { return null ; } public void appendChild ( int newChild , boolean clone , boolean cloneDepth ) { } public void appendTextChild ( String str ) { } public SourceLocator getSourceLocatorFor ( int node ) { return null ; } public void documentRegistration ( ) { } public void documentRelease ( ) { } public void migrateTo ( DTMManager manager ) { } } 	1	['111', '2', '1', '21', '139', '6045', '5', '18', '110', '0.968531469', '842', '0.769230769', '3', '0.470873786', '0.144155844', '0', '0', '6.468468468', '4', '1.1622', '1']
package org . apache . xalan . extensions ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . transformer . ClonerToResultTree ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xalan . serialize . SerializerUtils ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . DescendantIterator ; import org . apache . xpath . axes . OneStepIterator ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . objects . XString ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . traversal . NodeIterator ; public class XSLProcessorContext { public XSLProcessorContext ( TransformerImpl transformer , Stylesheet stylesheetTree ) { this . transformer = transformer ; this . stylesheetTree = stylesheetTree ; org . apache . xpath . XPathContext xctxt = transformer . getXPathContext ( ) ; this . mode = transformer . getMode ( ) ; this . sourceNode = xctxt . getCurrentNode ( ) ; this . sourceTree = xctxt . getDTM ( this . sourceNode ) ; } private TransformerImpl transformer ; public TransformerImpl getTransformer ( ) { return transformer ; } private Stylesheet stylesheetTree ; public Stylesheet getStylesheet ( ) { return stylesheetTree ; } private org . apache . xml . dtm . DTM sourceTree ; public org . w3c . dom . Node getSourceTree ( ) { return sourceTree . getNode ( sourceTree . getDocumentRoot ( sourceNode ) ) ; } private int sourceNode ; public org . w3c . dom . Node getContextNode ( ) { return sourceTree . getNode ( sourceNode ) ; } private QName mode ; public QName getMode ( ) { return mode ; } public void outputToResultTree ( Stylesheet stylesheetTree , Object obj ) throws TransformerException , java . net . MalformedURLException , java . io . FileNotFoundException , java . io . IOException { try { SerializationHandler rtreeHandler = transformer . getResultTreeHandler ( ) ; XPathContext xctxt = transformer . getXPathContext ( ) ; XObject value ; if ( obj instanceof XObject ) { value = ( XObject ) obj ; } else if ( obj instanceof String ) { value = new XString ( ( String ) obj ) ; } else if ( obj instanceof Boolean ) { value = new XBoolean ( ( ( Boolean ) obj ) . booleanValue ( ) ) ; } else if ( obj instanceof Double ) { value = new XNumber ( ( ( Double ) obj ) . doubleValue ( ) ) ; } else if ( obj instanceof DocumentFragment ) { int handle = xctxt . getDTMHandleFromNode ( ( DocumentFragment ) obj ) ; value = new XRTreeFrag ( handle , xctxt ) ; } else if ( obj instanceof DTM ) { DTM dtm = ( DTM ) obj ; DTMIterator iterator = new DescendantIterator ( ) ; iterator . setRoot ( dtm . getDocument ( ) , xctxt ) ; value = new XNodeSet ( iterator ) ; } else if ( obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) obj ; DTMIterator iterator = new OneStepIterator ( iter , - 1 ) ; value = new XNodeSet ( iterator ) ; } else if ( obj instanceof DTMIterator ) { value = new XNodeSet ( ( DTMIterator ) obj ) ; } else if ( obj instanceof NodeIterator ) { value = new XNodeSet ( new org . apache . xpath . NodeSetDTM ( ( ( NodeIterator ) obj ) , xctxt ) ) ; } else if ( obj instanceof org . w3c . dom . Node ) { value = new XNodeSet ( xctxt . getDTMHandleFromNode ( ( org . w3c . dom . Node ) obj ) , xctxt . getDTMManager ( ) ) ; } else { value = new XString ( obj . toString ( ) ) ; } int type = value . getType ( ) ; String s ; switch ( type ) { case XObject . CLASS_BOOLEAN : case XObject . CLASS_NUMBER : case XObject . CLASS_STRING : s = value . str ( ) ; rtreeHandler . characters ( s . toCharArray ( ) , 0 , s . length ( ) ) ; break ; case XObject . CLASS_NODESET : DTMIterator nl = value . iter ( ) ; int pos ; while ( DTM . NULL != ( pos = nl . nextNode ( ) ) ) { DTM dtm = nl . getDTM ( pos ) ; int top = pos ; while ( DTM . NULL != pos ) { rtreeHandler . flushPending ( ) ; ClonerToResultTree . cloneToResultTree ( pos , dtm . getNodeType ( pos ) , dtm , rtreeHandler , true ) ; int nextNode = dtm . getFirstChild ( pos ) ; while ( DTM . NULL == nextNode ) { if ( DTM . ELEMENT_NODE == dtm . getNodeType ( pos ) ) { rtreeHandler . endElement ( "" , "" , dtm . getNodeName ( pos ) ) ; } if ( top == pos ) break ; nextNode = dtm . getNextSibling ( pos ) ; if ( DTM . NULL == nextNode ) { pos = dtm . getParent ( pos ) ; if ( top == pos ) { if ( DTM . ELEMENT_NODE == dtm . getNodeType ( pos ) ) { rtreeHandler . endElement ( "" , "" , dtm . getNodeName ( pos ) ) ; } nextNode = DTM . NULL ; break ; } } } pos = nextNode ; } } break ; case XObject . CLASS_RTREEFRAG : SerializerUtils . outputResultTreeFragment ( rtreeHandler , value , transformer . getXPathContext ( ) ) ; break ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } } 	1	['7', '1', '0', '25', '49', '5', '5', '20', '7', '0.733333333', '321', '1', '4', '0', '0.392857143', '0', '0', '44.14285714', '1', '0.8571', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; public class WriterToASCI extends Writer { private final OutputStream m_os ; public WriterToASCI ( OutputStream os ) { m_os = os ; } public void write ( char chars [ ] , int start , int length ) throws java . io . IOException { int n = length + start ; for ( int i = start ; i < n ; i ++ ) { m_os . write ( chars [ i ] ) ; } } public void write ( int c ) throws IOException { m_os . write ( c ) ; } public void write ( String s ) throws IOException { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { m_os . write ( s . charAt ( i ) ) ; } } public void flush ( ) throws java . io . IOException { m_os . flush ( ) ; } public void close ( ) throws java . io . IOException { m_os . close ( ) ; } public OutputStream getOutputStream ( ) { return m_os ; } } 	1	['7', '2', '0', '1', '13', '0', '1', '0', '7', '0', '65', '1', '0', '0.684210526', '0.342857143', '1', '2', '8.142857143', '1', '0.8571', '1']
package org . apache . xalan . xsltc . compiler . util ; import java . util . ListResourceBundle ; public class ErrorMessages_tr extends ListResourceBundle { private static final String [ ] [ ] m_errorMessages = { { ErrorMsg . MULTIPLE_STYLESHEET_ERR , "Aynı dosyada birden çok biçem yaprağı tanımlandı." } , { ErrorMsg . TEMPLATE_REDEF_ERR , "Biçem yaprağında ''{0}'' şablonu zaten tanımlı." } , { ErrorMsg . TEMPLATE_UNDEF_ERR , "Bu biçem yaprağında ''{0}'' şablonu tanımlı değil." } , { ErrorMsg . VARIABLE_REDEF_ERR , "''{0}'' değişkeni aynı kapsamda bir kereden çok tanımlandı." } , { ErrorMsg . VARIABLE_UNDEF_ERR , "''{0}'' değişkeni ya da değiştirgesi tanımlı değil." } , { ErrorMsg . CLASS_NOT_FOUND_ERR , "''{0}'' sınıfı bulunamıyor." } , { ErrorMsg . METHOD_NOT_FOUND_ERR , "''{0}'' dış yöntemi bulunamıyor (public olmalı)." } , { ErrorMsg . ARGUMENT_CONVERSION_ERR , "''{0}'' yöntemi çağrısında bağımsız değişken/dönüş tipi dönüştürülemiyor." } , { ErrorMsg . FILE_NOT_FOUND_ERR , "Dosya ya da URI ''{0}'' bulunamadı." } , { ErrorMsg . INVALID_URI_ERR , "Geçersiz URI ''{0}''." } , { ErrorMsg . FILE_ACCESS_ERR , "Dosya ya da URI ''{0}'' açılamıyor." } , { ErrorMsg . MISSING_ROOT_ERR , "<xsl:stylesheet> ya da <xsl:transform> öğesi bekleniyor." } , { ErrorMsg . NAMESPACE_UNDEF_ERR , "Ad alanı öneki ''{0}'' bildirilmemiş." } , { ErrorMsg . FUNCTION_RESOLVE_ERR , "''{0}'' işlevi çağrısı çözülemiyor." } , { ErrorMsg . NEED_LITERAL_ERR , "''{0}'' işlevine ilişkin bağımsız değişken bir hazır bilgi dizgisi olmalıdır." } , { ErrorMsg . XPATH_PARSER_ERR , "XPath ifadesi ''{0}'' ayrıştırılırken hata oluştu." } , { ErrorMsg . REQUIRED_ATTR_ERR , "Gerekli ''{0}'' özniteliği eksik." } , { ErrorMsg . ILLEGAL_CHAR_ERR , "XPath ifadesinde geçersiz ''{0}'' karakteri var." } , { ErrorMsg . ILLEGAL_PI_ERR , "İşleme yönergesi için ''{0}'' adı geçersiz." } , { ErrorMsg . STRAY_ATTRIBUTE_ERR , "''{0}'' özniteliği öğenin dışında." } , { ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , "''{0}'' özniteliği geçersiz." } , { ErrorMsg . CIRCULAR_INCLUDE_ERR , "Çevrimsel import/include. ''{0}'' biçem yaprağı zaten yüklendi." } , { ErrorMsg . RESULT_TREE_SORT_ERR , "Sonuç ağacı parçaları sıralanamıyor (<xsl:sort> öğeleri yok sayıldı). Düğümleri sonuç ağacını yaratırken sıralamalısınız." } , { ErrorMsg . SYMBOLS_REDEF_ERR , "Onlu biçimleme biçemi ''{0}'' zaten tanımlı." } , { ErrorMsg . XSL_VERSION_ERR , "XSL sürümü ''{0}'' XSLTC tarafından desteklenmiyor." } , { ErrorMsg . CIRCULAR_VARIABLE_ERR , "''{0}'' içinde çevrimsel değişken/değiştirge başvurusu." } , { ErrorMsg . ILLEGAL_BINARY_OP_ERR , "İkili ifadede bilinmeyen işleç." } , { ErrorMsg . ILLEGAL_ARG_ERR , "İşlev çağrısı için geçersiz sayıda bağımsız değişken." } , { ErrorMsg . DOCUMENT_ARG_ERR , "document() işlevinin ikinci bağımsız değişkeni düğüm kümesi olmalıdır." } , { ErrorMsg . MISSING_WHEN_ERR , "<xsl:choose> içinde en az bir <xsl:when> öğesi gereklidir." } , { ErrorMsg . MULTIPLE_OTHERWISE_ERR , "<xsl:choose> içinde tek bir <xsl:otherwise> öğesine izin verilir." } , { ErrorMsg . STRAY_OTHERWISE_ERR , "<xsl:otherwise> yalnızca <xsl:choose> içinde kullanılabilir." } , { ErrorMsg . STRAY_WHEN_ERR , "<xsl:when> yalnızca <xsl:choose> içinde kullanılabilir." } , { ErrorMsg . WHEN_ELEMENT_ERR , "<xsl:choose> içinde yalnızca <xsl:when> ve <xsl:otherwise> öğeleri kullanılabilir." } , { ErrorMsg . UNNAMED_ATTRIBSET_ERR , "<xsl:attribute-set> öğesinde 'name' özniteliği eksik." } , { ErrorMsg . ILLEGAL_CHILD_ERR , "Geçersiz alt öğe." } , { ErrorMsg . ILLEGAL_ELEM_NAME_ERR , "Bir öğeye ''{0}'' adı verilemez." } , { ErrorMsg . ILLEGAL_ATTR_NAME_ERR , "Bir özniteliğe ''{0}'' adı verilemez." } , { ErrorMsg . ILLEGAL_TEXT_NODE_ERR , "Üst düzey <xsl:stylesheet> öğesi dışında metin verisi." } , { ErrorMsg . SAX_PARSER_CONFIG_ERR , "JAXP ayrıştırıcısı doğru yapılandırılmamış" } , { ErrorMsg . INTERNAL_ERR , "Kurtarılamaz XSLTC iç hatası: ''{0}''" } , { ErrorMsg . UNSUPPORTED_XSL_ERR , "XSL öğesi ''{0}'' desteklenmiyor." } , { ErrorMsg . UNSUPPORTED_EXT_ERR , "XSLTC uzantısı ''{0}'' tanınmıyor." } , { ErrorMsg . MISSING_XSLT_URI_ERR , "Giriş belgesi bir biçem yaprağı değil (XSL ad alanı kök öğede bildirilmedi)." } , { ErrorMsg . MISSING_XSLT_TARGET_ERR , "Biçem yaprağı hedefi ''{0}'' bulunamadı." } , { ErrorMsg . NOT_IMPLEMENTED_ERR , "Uygulanmadı: ''{0}''." } , { ErrorMsg . NOT_STYLESHEET_ERR , "Giriş belgesi bir XSL biçem yaprağı içermiyor." } , { ErrorMsg . ELEMENT_PARSE_ERR , "''{0}'' öğesi ayrıştırılamadı." } , { ErrorMsg . KEY_USE_ATTR_ERR , "<key> ile ilgili use özniteliği node, node-set, string ya da number olmalıdır." } , { ErrorMsg . OUTPUT_VERSION_ERR , "Çıkış XML belgesi sürümü 1.0 olmalıdır." } , { ErrorMsg . ILLEGAL_RELAT_OP_ERR , "İlişkisel ifade için bilinmeyen işleç" } , { ErrorMsg . ATTRIBSET_UNDEF_ERR , "Varolmayan ''{0}'' öznitelik kümesini kullanma girişimi." } , { ErrorMsg . ATTR_VAL_TEMPLATE_ERR , "Öznitelik değeri şablonu ''{0}'' ayrıştırılamıyor." } , { ErrorMsg . UNKNOWN_SIG_TYPE_ERR , "''{0}'' sınıfına ilişkin imzada bilinmeyen veri tipi." } , { ErrorMsg . DATA_CONVERSION_ERR , "''{0}'' veri tipi ''{1}'' tipine dönüştürülemez." } , { ErrorMsg . NO_TRANSLET_CLASS_ERR , "Bu Templates geçerli bir derleme sonucu sınıf tanımı içermiyor." } , { ErrorMsg . NO_MAIN_TRANSLET_ERR , "Bu Templates ''{0}'' adında bir sınıf içermiyor." } , { ErrorMsg . TRANSLET_CLASS_ERR , "Derleme sonucu sınıfı ''{0}'' yüklenemedi." } , { ErrorMsg . TRANSLET_OBJECT_ERR , "Derleme sonucu sınıfı yüklendi, ancak derleme sonucu sınıfının somut kopyası yaratılamıyor." } , { ErrorMsg . ERROR_LISTENER_NULL_ERR , "''{0}'' ile ilgili ErrorListener nesnesini boş değer (null) olarak ayarlama girişimi." } , { ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR , "XSLTC yalnızca StreamSource, SAXSource ve DOMSource arabirimlerini destekler." } , { ErrorMsg . JAXP_NO_SOURCE_ERR , "''{0}'' yöntemine aktarılan Source nesnesinin içeriği yok." } , { ErrorMsg . JAXP_COMPILE_ERR , "Biçem yaprağı derlenemedi." } , { ErrorMsg . JAXP_INVALID_ATTR_ERR , "TransformerFactory ''{0}'' özniteliğini tanımıyor." } , { ErrorMsg . JAXP_SET_RESULT_ERR , "startDocument() yönteminden önce setResult() çağrılmalıdır." } , { ErrorMsg . JAXP_NO_TRANSLET_ERR , "Transformer, derleme sonucu sınıf dosyası nesnesine başvuru içermiyor." } , { ErrorMsg . JAXP_NO_HANDLER_ERR , "Dönüştürme sonucu için tanımlı çıkış işleyicisi yok." } , { ErrorMsg . JAXP_NO_RESULT_ERR , "''{0}'' yöntemine aktarılan Result nesnesi geçersiz." } , { ErrorMsg . JAXP_UNKNOWN_PROP_ERR , "Geçersiz ''{0}'' Transformer özelliğine erişme girişimi." } , { ErrorMsg . SAX2DOM_ADAPTER_ERR , "SAX2DOM bağdaştırıcısı yaratılamadı: ''{0}''." } , { ErrorMsg . XSLTC_SOURCE_ERR , "XSLTCSource.build() yöntemi systemId tanımlanmadan çağrıldı." } , { ErrorMsg . COMPILE_STDIN_ERR , "-i seçeneği -o seçeneğiyle birlikte kullanılmalıdır." } , { ErrorMsg . COMPILE_USAGE_STR , "ÖZET\n   java org.apache.xalan.xsltc.cmdline.Compile [-o <çıkış>]\n      [-d <dizin>] [-j <jardosyası>] [-p <paket>]\n      [-n] [-x] [-s] [-u] [-v] [-h] { <biçemyaprağı> | -i }\n\nSEÇENEKLER\n   -o <çıkış>    derleme sonucu sınıf dosyasına <çıkış>\n                  adını atar. Varsayılan olarak, derleme sonucu sınıf dosyası\n                  adı <biçemyaprağı> adından alınır. Birden çok biçem yaprağı derleniyorsa\n                  bu seçenek dikkate alınmaz.\n   -d <dizin> derleme sonucu sınıf dosyası için hedef dizini belirtir.\n   -j <jardosyası>   derleme sonucu sınıf dosyalarını\n                  <jardosyası> dosyasında paketler.\n   -p <paket>   derleme sonucu üretilen tüm sınıf dosyaları için\n                  bir paket adı öneki belirtir.\n   -n             şablona doğrudan yerleştirmeyi etkinleştirir (ortalama olarak\n                  daha yüksek başarım sağlar).\n   -x             ek hata ayıklama iletisi çıkışını etkinleştirir.\n   -s             System.exit çağrısını geçersiz kılar.\n   -u             <biçemyaprağı> bağımsız değişkenlerini URL olarak yorumlar.\n   -i             derleyiciyi stdin'den biçem yaprağını okumaya zorlar.\n   -v             derleyici sürümünü yazdırır.\n   -h             bu kullanım bilgilerini yazdırır.\n" } , { ErrorMsg . TRANSFORM_USAGE_STR , "SÖZDİZİMİ \n   java org.apache.xalan.xsltc.cmdline.Transform [-j <jardosyası>]\n      [-x] [-s] [-n <yineleme sayısı>] {-u <belge_url> | <belge>}\n      <sınıf> [<değiştirge1>=<değer1> ...]\n\n   <belge> ile belirtilen XML belgesini dönüştürmek için <sınıf> \n   sınıf dosyasını kullanır. <sınıf> sınıf dosyası\n   kullanıcının CLASSPATH değişkeninde ya da isteğe bağlı olarak belirtilen <jardosyası> dosyasındadır.\nSEÇENEKLER\n   -j <jardosyası>    derleme sonucu sınıf dosyasının hangi jar dosyasından yükleneceğini belirtir.\n   -x              ek hata ayıklama iletisi çıkışını etkinleştirir.\n   -s              System.exit çağrısını geçersiz kılar.\n   -n <yineleme sayısı> dönüştürmeyi <yineleme sayısı> ile belirtilen sayı kadar çalıştırır ve\n                   yakalama bilgilerini görüntüler.\n   -u <belge_url> XML giriş belgesini URL olarak belirtir.\n" } , { ErrorMsg . STRAY_SORT_ERR , "<xsl:sort> yalnızca <xsl:for-each> ya da <xsl:apply-templates> içinde kullanılabilir." } , { ErrorMsg . UNSUPPORTED_ENCODING , "''{0}'' çıkış kodlaması bu JVM üzerinde desteklenmiyor." } , { ErrorMsg . SYNTAX_ERR , "''{0}'' ifadesinde sözdizimi hatası." } , { ErrorMsg . CONSTRUCTOR_NOT_FOUND , "Dış oluşturucu ''{0}'' bulunamıyor." } , { ErrorMsg . NO_JAVA_FUNCT_THIS_REF , "Durağan (static) olmayan ''{0}'' Java işlevine ilişkin ilk bağımsız değişken geçerli bir nesne başvurusu değil. " } , { ErrorMsg . TYPE_CHECK_ERR , "''{0}'' ifadesinin tipi denetlenirken hata saptandı." } , { ErrorMsg . TYPE_CHECK_UNK_LOC_ERR , "Bilinmeyen bir yerdeki bir ifadenin tipi denetlenirken hata saptandı." } , { ErrorMsg . ILLEGAL_CMDLINE_OPTION_ERR , "Komut satırı seçeneği ''{0}'' geçerli değil." } , { ErrorMsg . CMDLINE_OPT_MISSING_ARG_ERR , "''{0}'' komut satırı seçeneğinde gerekli bir bağımsız değişken eksik." } , { ErrorMsg . WARNING_PLUS_WRAPPED_MSG , "UYARI:  ''{0}''\n       :{1}" } , { ErrorMsg . WARNING_MSG , "UYARI:  ''{0}''" } , { ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , "ONULMAZ HATA:  ''{0}''\n           :{1}" } , { ErrorMsg . FATAL_ERR_MSG , "ONULMAZ HATA:  ''{0}''" } , { ErrorMsg . ERROR_PLUS_WRAPPED_MSG , "HATA:  ''{0}''\n     :{1}" } , { ErrorMsg . ERROR_MSG , "HATA:  ''{0}''" } , { ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , "''{0}'' sınıfını kullanarak dönüştür" } , { ErrorMsg . TRANSFORM_WITH_JAR_STR , "''{1}'' jar dosyasından ''{0}'' sınıfını kullanarak dönüştür" } , { ErrorMsg . COULD_NOT_CREATE_TRANS_FACT , "''{0}'' TransformerFactory sınıfının somut kopyası yaratılamadı." } , { ErrorMsg . COMPILER_ERROR_KEY , "Derleyici hataları:" } , { ErrorMsg . COMPILER_WARNING_KEY , "Derleyici uyarıları:" } , { ErrorMsg . RUNTIME_ERROR_KEY , "Derleme sonusu sınıf dosyası hataları:" } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1	['3', '3', '0', '0', '4', '1', '0', '0', '2', '0.5', '1248', '1', '0', '0.974358974', '1', '0', '0', '414.6666667', '1', '0.3333', '1']
package org . apache . xalan . xsltc . trax ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . Properties ; import java . security . AccessController ; import java . security . PrivilegedAction ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . URIResolver ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . runtime . Hashtable ; public final class TemplatesImpl implements Templates , Serializable { private static String ABSTRACT_TRANSLET = "org.apache.xalan.xsltc.runtime.AbstractTranslet" ; private String _name = null ; private byte [ ] [ ] _bytecodes = null ; private Class [ ] _class = null ; private int _transletIndex = - 1 ; private Hashtable _auxClasses = null ; private Properties _outputProperties ; private int _indentNumber ; private transient URIResolver _uriResolver = null ; private transient ThreadLocal _sdom = new ThreadLocal ( ) ; private transient TransformerFactoryImpl _tfactory = null ; static final class TransletClassLoader extends ClassLoader { TransletClassLoader ( ClassLoader parent ) { super ( parent ) ; } Class defineClass ( final byte [ ] b ) { return defineClass ( null , b , 0 , b . length ) ; } } protected TemplatesImpl ( byte [ ] [ ] bytecodes , String transletName , Properties outputProperties , int indentNumber , TransformerFactoryImpl tfactory ) { _bytecodes = bytecodes ; _name = transletName ; _outputProperties = outputProperties ; _indentNumber = indentNumber ; _tfactory = tfactory ; } protected TemplatesImpl ( Class [ ] transletClasses , String transletName , Properties outputProperties , int indentNumber , TransformerFactoryImpl tfactory ) { _class = transletClasses ; _name = transletName ; _transletIndex = 0 ; _outputProperties = outputProperties ; _indentNumber = indentNumber ; _tfactory = tfactory ; } public TemplatesImpl ( ) { } private void readObject ( ObjectInputStream is ) throws IOException , ClassNotFoundException { is . defaultReadObject ( ) ; if ( is . readBoolean ( ) ) { _uriResolver = ( URIResolver ) is . readObject ( ) ; } _tfactory = new TransformerFactoryImpl ( ) ; } private void writeObject ( ObjectOutputStream os ) throws IOException , ClassNotFoundException { os . defaultWriteObject ( ) ; if ( _uriResolver instanceof Serializable ) { os . writeBoolean ( true ) ; os . writeObject ( ( Serializable ) _uriResolver ) ; } else { os . writeBoolean ( false ) ; } } public synchronized void setURIResolver ( URIResolver resolver ) { _uriResolver = resolver ; } protected synchronized void setTransletBytecodes ( byte [ ] [ ] bytecodes ) { _bytecodes = bytecodes ; } public synchronized byte [ ] [ ] getTransletBytecodes ( ) { return _bytecodes ; } public synchronized Class [ ] getTransletClasses ( ) { try { if ( _class == null ) defineTransletClasses ( ) ; } catch ( TransformerConfigurationException e ) { } return _class ; } public synchronized int getTransletIndex ( ) { try { if ( _class == null ) defineTransletClasses ( ) ; } catch ( TransformerConfigurationException e ) { } return _transletIndex ; } protected synchronized void setTransletName ( String name ) { _name = name ; } protected synchronized String getTransletName ( ) { return _name ; } private void defineTransletClasses ( ) throws TransformerConfigurationException { if ( _bytecodes == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NO_TRANSLET_CLASS_ERR ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } TransletClassLoader loader = ( TransletClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new TransletClassLoader ( ObjectFactory . findClassLoader ( ) ) ; } } ) ; try { final int classCount = _bytecodes . length ; _class = new Class [ classCount ] ; if ( classCount > 1 ) { _auxClasses = new Hashtable ( ) ; } for ( int i = 0 ; i < classCount ; i ++ ) { _class [ i ] = loader . defineClass ( _bytecodes [ i ] ) ; final Class superClass = _class [ i ] . getSuperclass ( ) ; if ( superClass . getName ( ) . equals ( ABSTRACT_TRANSLET ) ) { _transletIndex = i ; } else { _auxClasses . put ( _class [ i ] . getName ( ) , _class [ i ] ) ; } } if ( _transletIndex < 0 ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NO_MAIN_TRANSLET_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } catch ( ClassFormatError e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_CLASS_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( LinkageError e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_OBJECT_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } private Translet getTransletInstance ( ) throws TransformerConfigurationException { try { if ( _name == null ) return null ; if ( _class == null ) defineTransletClasses ( ) ; AbstractTranslet translet = ( AbstractTranslet ) _class [ _transletIndex ] . newInstance ( ) ; translet . postInitialization ( ) ; translet . setTemplates ( this ) ; if ( _auxClasses != null ) { translet . setAuxiliaryClasses ( _auxClasses ) ; } return translet ; } catch ( InstantiationException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_OBJECT_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( IllegalAccessException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . TRANSLET_OBJECT_ERR , _name ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } public synchronized Transformer newTransformer ( ) throws TransformerConfigurationException { TransformerImpl transformer ; transformer = new TransformerImpl ( getTransletInstance ( ) , _outputProperties , _indentNumber , _tfactory ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return transformer ; } public synchronized Properties getOutputProperties ( ) { try { return newTransformer ( ) . getOutputProperties ( ) ; } catch ( TransformerConfigurationException e ) { return null ; } } public DOM getStylesheetDOM ( ) { return ( DOM ) _sdom . get ( ) ; } public void setStylesheetDOM ( DOM sdom ) { _sdom . set ( sdom ) ; } } 	1	['19', '1', '0', '11', '49', '37', '4', '9', '9', '0.636363636', '455', '1', '2', '0', '0.171717172', '0', '0', '22.36842105', '1', '0.7895', '1']
package org . apache . xalan . xsltc . dom ; import java . util . Vector ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; public abstract class NodeCounter implements Axis { public static final int END = DTM . NULL ; protected int _node = END ; protected int _nodeType = DOM . FIRST_TYPE - 1 ; protected int _value = Integer . MIN_VALUE ; public final DOM _document ; public final DTMAxisIterator _iterator ; public final Translet _translet ; protected String _format ; protected String _lang ; protected String _letterValue ; protected String _groupSep ; protected int _groupSize ; private boolean separFirst = true ; private boolean separLast = false ; private Vector separToks = null ; private Vector formatToks = null ; private int nSepars = 0 ; private int nFormats = 0 ; private static String [ ] Thousands = { "" , "m" , "mm" , "mmm" } ; private static String [ ] Hundreds = { "" , "c" , "cc" , "ccc" , "cd" , "d" , "dc" , "dcc" , "dccc" , "cm" } ; private static String [ ] Tens = { "" , "x" , "xx" , "xxx" , "xl" , "l" , "lx" , "lxx" , "lxxx" , "xc" } ; private static String [ ] Ones = { "" , "i" , "ii" , "iii" , "iv" , "v" , "vi" , "vii" , "viii" , "ix" } ; protected NodeCounter ( Translet translet , DOM document , DTMAxisIterator iterator ) { _translet = translet ; _document = document ; _iterator = iterator ; } abstract public NodeCounter setStartNode ( int node ) ; public NodeCounter setValue ( int value ) { _value = value ; return this ; } protected void setFormatting ( String format , String lang , String letterValue , String groupSep , String groupSize ) { _lang = lang ; _format = format ; _groupSep = groupSep ; _letterValue = letterValue ; try { _groupSize = Integer . parseInt ( groupSize ) ; } catch ( NumberFormatException e ) { _groupSize = 0 ; } final int length = _format . length ( ) ; boolean isFirst = true ; separFirst = true ; separLast = false ; separToks = new Vector ( ) ; formatToks = new Vector ( ) ; for ( int j = 0 , i = 0 ; i < length ; ) { char c = _format . charAt ( i ) ; for ( j = i ; Character . isLetterOrDigit ( c ) ; ) { if ( ++ i == length ) break ; c = _format . charAt ( i ) ; } if ( i > j ) { if ( isFirst ) { separToks . addElement ( "." ) ; isFirst = separFirst = false ; } formatToks . addElement ( _format . substring ( j , i ) ) ; } if ( i == length ) break ; c = _format . charAt ( i ) ; for ( j = i ; ! Character . isLetterOrDigit ( c ) ; ) { if ( ++ i == length ) break ; c = _format . charAt ( i ) ; isFirst = false ; } if ( i > j ) { separToks . addElement ( _format . substring ( j , i ) ) ; } } nSepars = separToks . size ( ) ; nFormats = formatToks . size ( ) ; if ( nSepars > nFormats ) separLast = true ; if ( separFirst ) nSepars -- ; if ( separLast ) nSepars -- ; if ( nSepars == 0 ) { separToks . insertElementAt ( "." , 1 ) ; nSepars ++ ; } if ( separFirst ) nSepars ++ ; } public NodeCounter setDefaultFormatting ( ) { setFormatting ( "1" , "en" , "alphabetic" , null , null ) ; return this ; } abstract public String getCounter ( ) ; public String getCounter ( String format , String lang , String letterValue , String groupSep , String groupSize ) { setFormatting ( format , lang , letterValue , groupSep , groupSize ) ; return getCounter ( ) ; } public boolean matchesCount ( int node ) { return _nodeType == _document . getExpandedTypeID ( node ) ; } public boolean matchesFrom ( int node ) { return false ; } protected String formatNumbers ( int value ) { return formatNumbers ( new int [ ] { value } ) ; } protected String formatNumbers ( int [ ] values ) { final int nValues = values . length ; final int length = _format . length ( ) ; boolean isEmpty = true ; for ( int i = 0 ; i < nValues ; i ++ ) if ( values [ i ] != Integer . MIN_VALUE ) isEmpty = false ; if ( isEmpty ) return ( "" ) ; boolean isFirst = true ; int t = 0 , n = 0 , s = 1 ; final StringBuffer buffer = new StringBuffer ( ) ; if ( separFirst ) buffer . append ( ( String ) separToks . elementAt ( 0 ) ) ; while ( n < nValues ) { final int value = values [ n ] ; if ( value != Integer . MIN_VALUE ) { if ( ! isFirst ) buffer . append ( ( String ) separToks . elementAt ( s ++ ) ) ; formatValue ( value , ( String ) formatToks . elementAt ( t ++ ) , buffer ) ; if ( t == nFormats ) t -- ; if ( s >= nSepars ) s -- ; isFirst = false ; } n ++ ; } if ( separLast ) buffer . append ( ( String ) separToks . lastElement ( ) ) ; return buffer . toString ( ) ; } private void formatValue ( int value , String format , StringBuffer buffer ) { char c = format . charAt ( 0 ) ; if ( Character . isDigit ( c ) ) { char zero = ( char ) ( c - Character . getNumericValue ( c ) ) ; StringBuffer temp = buffer ; if ( _groupSize > 0 ) { temp = new StringBuffer ( ) ; } String s = "" ; int n = value ; while ( n > 0 ) { s = ( char ) ( ( int ) zero + ( n % 10 ) ) + s ; n = n / 10 ; } for ( int i = 0 ; i < format . length ( ) - s . length ( ) ; i ++ ) { temp . append ( zero ) ; } temp . append ( s ) ; if ( _groupSize > 0 ) { for ( int i = 0 ; i < temp . length ( ) ; i ++ ) { if ( i != 0 && ( ( temp . length ( ) - i ) % _groupSize ) == 0 ) { buffer . append ( _groupSep ) ; } buffer . append ( temp . charAt ( i ) ) ; } } } else if ( c == 'i' && ! _letterValue . equals ( "alphabetic" ) ) { buffer . append ( romanValue ( value ) ) ; } else if ( c == 'I' && ! _letterValue . equals ( "alphabetic" ) ) { buffer . append ( romanValue ( value ) . toUpperCase ( ) ) ; } else { int min = ( int ) c ; int max = ( int ) c ; if ( c >= 0x3b1 && c <= 0x3c9 ) { max = 0x3c9 ; } else { while ( Character . isLetterOrDigit ( ( char ) ( max + 1 ) ) ) { max ++ ; } } buffer . append ( alphaValue ( value , min , max ) ) ; } } private String alphaValue ( int value , int min , int max ) { if ( value <= 0 ) { return "" + value ; } int range = max - min + 1 ; char last = ( char ) ( ( ( value - 1 ) % range ) + min ) ; if ( value > range ) { return alphaValue ( ( value - 1 ) / range , min , max ) + last ; } else { return "" + last ; } } private String romanValue ( int n ) { if ( n <= 0 || n > 4000 ) { return "" + n ; } return Thousands [ n / 1000 ] + Hundreds [ ( n / 100 ) % 10 ] + Tens [ ( n / 10 ) % 10 ] + Ones [ n % 10 ] ; } } 	1	['15', '1', '3', '8', '43', '91', '4', '4', '7', '0.811688312', '833', '0.818181818', '3', '0', '0.267857143', '0', '0', '53.06666667', '14', '3.6', '2']
package org . apache . xml . dtm ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . XMLStringFactory ; public abstract class DTMManager { private static final String defaultPropName = "org.apache.xml.dtm.DTMManager" ; private static String defaultClassName = "org.apache.xml.dtm.ref.DTMManagerDefault" ; protected XMLStringFactory m_xsf = null ; protected DTMManager ( ) { } public XMLStringFactory getXMLStringFactory ( ) { return m_xsf ; } public void setXMLStringFactory ( XMLStringFactory xsf ) { m_xsf = xsf ; } public static DTMManager newInstance ( XMLStringFactory xsf ) throws DTMConfigurationException { DTMManager factoryImpl = null ; try { factoryImpl = ( DTMManager ) ObjectFactory . createObject ( defaultPropName , defaultClassName ) ; } catch ( ObjectFactory . ConfigurationError e ) { throw new DTMConfigurationException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DEFAULT_IMPL , null ) , e . getException ( ) ) ; } if ( factoryImpl == null ) { throw new DTMConfigurationException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DEFAULT_IMPL , null ) ) ; } factoryImpl . setXMLStringFactory ( xsf ) ; return factoryImpl ; } public abstract DTM getDTM ( javax . xml . transform . Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing ) ; public abstract DTM getDTM ( int nodeHandle ) ; public abstract int getDTMHandleFromNode ( org . w3c . dom . Node node ) ; public abstract DTM createDocumentFragment ( ) ; public abstract boolean release ( DTM dtm , boolean shouldHardDelete ) ; public abstract DTMIterator createDTMIterator ( Object xpathCompiler , int pos ) ; public abstract DTMIterator createDTMIterator ( String xpathString , PrefixResolver presolver ) ; public abstract DTMIterator createDTMIterator ( int whatToShow , DTMFilter filter , boolean entityReferenceExpansion ) ; public abstract DTMIterator createDTMIterator ( int node ) ; public static boolean m_incremental = false ; public synchronized static boolean getIncremental ( ) { return m_incremental ; } public synchronized static void setIncremental ( boolean incremental ) { m_incremental = incremental ; } private static boolean debug ; static { try { debug = System . getProperty ( "dtm.debug" ) != null ; } catch ( SecurityException ex ) { } } public static final int IDENT_DTM_NODE_BITS = 16 ; public static final int IDENT_NODE_DEFAULT = ( 1 << IDENT_DTM_NODE_BITS ) - 1 ; public static final int IDENT_DTM_DEFAULT = ~ IDENT_NODE_DEFAULT ; public static final int IDENT_MAX_DTMS = ( IDENT_DTM_DEFAULT > > > IDENT_DTM_NODE_BITS ) + 1 ; public abstract int getDTMIdentity ( DTM dtm ) ; public int getDTMIdentityMask ( ) { return IDENT_DTM_DEFAULT ; } public int getNodeIdentityMask ( ) { return IDENT_NODE_DEFAULT ; } } 	1	['19', '1', '2', '54', '26', '157', '46', '10', '17', '0.99382716', '96', '0.444444444', '1', '0', '0.157407407', '0', '0', '3.578947368', '1', '0.8947', '2']
package org . apache . xalan . xsltc . compiler ; import java . io . OutputStreamWriter ; import java . util . Properties ; import java . util . StringTokenizer ; import javax . xml . transform . OutputKeys ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . serializer . Encodings ; import org . apache . xml . utils . XMLChar ; final class Output extends TopLevelElement { private String _version ; private String _method ; private String _encoding ; private boolean _omitHeader = false ; private String _standalone ; private String _doctypePublic ; private String _doctypeSystem ; private String _cdata ; private boolean _indent = false ; private String _mediaType ; private String _cdataToMerge ; private boolean _disabled = false ; private final static String STRING_SIG = "Ljava/lang/String;" ; private final static String XML_VERSION = "1.0" ; private final static String HTML_VERSION = "4.0" ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "Output " + _method ) ; } public void disable ( ) { _disabled = true ; } public boolean enabled ( ) { return ! _disabled ; } public String getCdata ( ) { return _cdata ; } public String getOutputMethod ( ) { return _method ; } public void mergeCdata ( String cdata ) { _cdataToMerge = cdata ; } public void parseContents ( Parser parser ) { final Properties outputProperties = new Properties ( ) ; parser . setOutput ( this ) ; if ( _disabled ) return ; String attrib = null ; _version = getAttribute ( "version" ) ; if ( _version == null || _version . equals ( Constants . EMPTYSTRING ) ) { _version = null ; } else { outputProperties . setProperty ( OutputKeys . VERSION , _version ) ; } _method = getAttribute ( "method" ) ; if ( _method . equals ( Constants . EMPTYSTRING ) ) { _method = null ; } if ( _method != null ) { _method = _method . toLowerCase ( ) ; if ( ( _method . equals ( "xml" ) ) || ( _method . equals ( "html" ) ) || ( _method . equals ( "text" ) ) || ( ( XMLChar . isValidQName ( _method ) && ( _method . indexOf ( ":" ) > 0 ) ) ) ) { outputProperties . setProperty ( OutputKeys . METHOD , _method ) ; } else { reportError ( this , parser , ErrorMsg . INVALID_METHOD_IN_OUTPUT , _method ) ; } } _encoding = getAttribute ( "encoding" ) ; if ( _encoding . equals ( Constants . EMPTYSTRING ) ) { _encoding = null ; } else { try { String canonicalEncoding ; canonicalEncoding = Encodings . convertMime2JavaEncoding ( _encoding ) ; OutputStreamWriter writer = new OutputStreamWriter ( System . out , canonicalEncoding ) ; } catch ( java . io . UnsupportedEncodingException e ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_ENCODING , _encoding , this ) ; parser . reportError ( Constants . WARNING , msg ) ; } outputProperties . setProperty ( OutputKeys . ENCODING , _encoding ) ; } attrib = getAttribute ( "omit-xml-declaration" ) ; if ( attrib != null && ! attrib . equals ( Constants . EMPTYSTRING ) ) { if ( attrib . equals ( "yes" ) ) { _omitHeader = true ; } outputProperties . setProperty ( OutputKeys . OMIT_XML_DECLARATION , attrib ) ; } _standalone = getAttribute ( "standalone" ) ; if ( _standalone . equals ( Constants . EMPTYSTRING ) ) { _standalone = null ; } else { outputProperties . setProperty ( OutputKeys . STANDALONE , _standalone ) ; } _doctypeSystem = getAttribute ( "doctype-system" ) ; if ( _doctypeSystem . equals ( Constants . EMPTYSTRING ) ) { _doctypeSystem = null ; } else { outputProperties . setProperty ( OutputKeys . DOCTYPE_SYSTEM , _doctypeSystem ) ; } _doctypePublic = getAttribute ( "doctype-public" ) ; if ( _doctypePublic . equals ( Constants . EMPTYSTRING ) ) { _doctypePublic = null ; } else { outputProperties . setProperty ( OutputKeys . DOCTYPE_PUBLIC , _doctypePublic ) ; } _cdata = getAttribute ( "cdata-section-elements" ) ; if ( _cdata != null && _cdata . equals ( Constants . EMPTYSTRING ) ) { _cdata = null ; } else { StringBuffer expandedNames = new StringBuffer ( ) ; StringTokenizer tokens = new StringTokenizer ( _cdata ) ; while ( tokens . hasMoreTokens ( ) ) { String qname = tokens . nextToken ( ) ; if ( ! XMLChar . isValidQName ( qname ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , qname , this ) ; parser . reportError ( Constants . ERROR , err ) ; } expandedNames . append ( parser . getQName ( qname ) . toString ( ) ) . append ( ' ' ) ; } _cdata = expandedNames . toString ( ) ; if ( _cdataToMerge != null ) { _cdata = _cdata + _cdataToMerge ; } outputProperties . setProperty ( OutputKeys . CDATA_SECTION_ELEMENTS , _cdata ) ; } attrib = getAttribute ( "indent" ) ; if ( attrib != null && ! attrib . equals ( EMPTYSTRING ) ) { if ( attrib . equals ( "yes" ) ) { _indent = true ; } outputProperties . setProperty ( OutputKeys . INDENT , attrib ) ; } else if ( _method != null && _method . equals ( "html" ) ) { _indent = true ; } _mediaType = getAttribute ( "media-type" ) ; if ( _mediaType . equals ( Constants . EMPTYSTRING ) ) { _mediaType = null ; } else { outputProperties . setProperty ( OutputKeys . MEDIA_TYPE , _mediaType ) ; } if ( _method != null ) { if ( _method . equals ( "html" ) ) { if ( _version == null ) { _version = HTML_VERSION ; } if ( _mediaType == null ) { _mediaType = "text/html" ; } } else if ( _method . equals ( "text" ) ) { if ( _mediaType == null ) { _mediaType = "text/plain" ; } } } parser . getCurrentStylesheet ( ) . setOutputProperties ( outputProperties ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _disabled ) return ; ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; int field = 0 ; il . append ( classGen . loadTranslet ( ) ) ; if ( ( _version != null ) && ( ! _version . equals ( XML_VERSION ) ) ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_version" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _version ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _method != null ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_method" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _method ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _encoding != null ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_encoding" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _encoding ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _omitHeader ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_omitHeader" , "Z" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _omitHeader ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _standalone != null ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_standalone" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _standalone ) ) ; il . append ( new PUTFIELD ( field ) ) ; } field = cpg . addFieldref ( TRANSLET_CLASS , "_doctypeSystem" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _doctypeSystem ) ) ; il . append ( new PUTFIELD ( field ) ) ; field = cpg . addFieldref ( TRANSLET_CLASS , "_doctypePublic" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _doctypePublic ) ) ; il . append ( new PUTFIELD ( field ) ) ; if ( _mediaType != null ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_mediaType" , STRING_SIG ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _mediaType ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _indent ) { field = cpg . addFieldref ( TRANSLET_CLASS , "_indent" , "Z" ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , _indent ) ) ; il . append ( new PUTFIELD ( field ) ) ; } if ( _cdata != null ) { int index = cpg . addMethodref ( TRANSLET_CLASS , "addCdataElement" , "(Ljava/lang/String;)V" ) ; StringTokenizer tokens = new StringTokenizer ( _cdata ) ; while ( tokens . hasMoreTokens ( ) ) { il . append ( DUP ) ; il . append ( new PUSH ( cpg , tokens . nextToken ( ) ) ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } } il . append ( POP ) ; } } 	1	['9', '3', '0', '20', '50', '0', '2', '20', '8', '0.858333333', '786', '1', '0', '0.882352941', '0.259259259', '3', '8', '84.66666667', '35', '6', '1']
package org . apache . xml . utils ; public class Trie { public static final int ALPHA_SIZE = 128 ; Node m_Root ; private char [ ] m_charBuffer = new char [ 0 ] ; public Trie ( ) { m_Root = new Node ( ) ; } public Object put ( String key , Object value ) { final int len = key . length ( ) ; if ( len > m_charBuffer . length ) { m_charBuffer = new char [ len ] ; } Node node = m_Root ; for ( int i = 0 ; i < len ; i ++ ) { Node nextNode = node . m_nextChar [ Character . toUpperCase ( key . charAt ( i ) ) ] ; if ( nextNode != null ) { node = nextNode ; } else { for ( ; i < len ; i ++ ) { Node newNode = new Node ( ) ; node . m_nextChar [ Character . toUpperCase ( key . charAt ( i ) ) ] = newNode ; node . m_nextChar [ Character . toLowerCase ( key . charAt ( i ) ) ] = newNode ; node = newNode ; } break ; } } Object ret = node . m_Value ; node . m_Value = value ; return ret ; } public Object get ( final String key ) { final int len = key . length ( ) ; if ( m_charBuffer . length < len ) return null ; Node node = m_Root ; switch ( len ) { case 0 : { return null ; } case 1 : { final char ch = key . charAt ( 0 ) ; if ( ch < ALPHA_SIZE ) { node = node . m_nextChar [ ch ] ; if ( node != null ) return node . m_Value ; } return null ; } default : { key . getChars ( 0 , len , m_charBuffer , 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { final char ch = m_charBuffer [ i ] ; if ( ALPHA_SIZE <= ch ) { return null ; } node = node . m_nextChar [ ch ] ; if ( node == null ) return null ; } return node . m_Value ; } } } class Node { Node ( ) { m_nextChar = new Node [ ALPHA_SIZE ] ; m_Value = null ; } Node m_nextChar [ ] ; Object m_Value ; } } 	1	['3', '1', '0', '2', '10', '0', '2', '1', '3', '0.5', '162', '0.333333333', '1', '0', '0.666666667', '0', '0', '52', '10', '5', '1']
package org . apache . xalan . xsltc . trax ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FilenameFilter ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TemplatesHandler ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xml . utils . StylesheetPIHandler ; import org . apache . xml . utils . StopParseException ; import org . apache . xalan . xsltc . compiler . SourceLoader ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . dom . XSLTCDTMManager ; import org . xml . sax . InputSource ; import org . xml . sax . XMLFilter ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class TransformerFactoryImpl extends SAXTransformerFactory implements SourceLoader , ErrorListener { public final static String TRANSLET_NAME = "translet-name" ; public final static String DESTINATION_DIRECTORY = "destination-directory" ; public final static String PACKAGE_NAME = "package-name" ; public final static String JAR_NAME = "jar-name" ; public final static String GENERATE_TRANSLET = "generate-translet" ; public final static String AUTO_TRANSLET = "auto-translet" ; public final static String USE_CLASSPATH = "use-classpath" ; public final static String DEBUG = "debug" ; public final static String ENABLE_INLINING = "enable-inlining" ; public final static String INDENT_NUMBER = "indent-number" ; private ErrorListener _errorListener = this ; private URIResolver _uriResolver = null ; protected static String DEFAULT_TRANSLET_NAME = "GregorSamsa" ; private String _transletName = DEFAULT_TRANSLET_NAME ; private String _destinationDirectory = null ; private String _packageName = null ; private String _jarFileName = null ; private Hashtable _piParams = null ; static ThreadLocal _xmlReader = new ThreadLocal ( ) ; private static class PIParamWrapper { public String _media = null ; public String _title = null ; public String _charset = null ; public PIParamWrapper ( String media , String title , String charset ) { _media = media ; _title = title ; _charset = charset ; } } private boolean _debug = false ; private boolean _enableInlining = false ; private boolean _generateTranslet = false ; private boolean _autoTranslet = false ; private boolean _useClasspath = false ; private int _indentNumber = - 1 ; private Class m_DTMManagerClass ; public TransformerFactoryImpl ( ) { m_DTMManagerClass = XSLTCDTMManager . getDTMManagerClass ( ) ; } public void setErrorListener ( ErrorListener listener ) throws IllegalArgumentException { if ( listener == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ERROR_LISTENER_NULL_ERR , "TransformerFactory" ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } _errorListener = listener ; } public ErrorListener getErrorListener ( ) { return _errorListener ; } public Object getAttribute ( String name ) throws IllegalArgumentException { if ( name . equals ( TRANSLET_NAME ) ) { return _transletName ; } else if ( name . equals ( GENERATE_TRANSLET ) ) { return new Boolean ( _generateTranslet ) ; } else if ( name . equals ( AUTO_TRANSLET ) ) { return new Boolean ( _autoTranslet ) ; } ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_INVALID_ATTR_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } public void setAttribute ( String name , Object value ) throws IllegalArgumentException { if ( name . equals ( TRANSLET_NAME ) && value instanceof String ) { _transletName = ( String ) value ; return ; } else if ( name . equals ( DESTINATION_DIRECTORY ) && value instanceof String ) { _destinationDirectory = ( String ) value ; return ; } else if ( name . equals ( PACKAGE_NAME ) && value instanceof String ) { _packageName = ( String ) value ; return ; } else if ( name . equals ( JAR_NAME ) && value instanceof String ) { _jarFileName = ( String ) value ; return ; } else if ( name . equals ( GENERATE_TRANSLET ) ) { if ( value instanceof Boolean ) { _generateTranslet = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _generateTranslet = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( AUTO_TRANSLET ) ) { if ( value instanceof Boolean ) { _autoTranslet = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _autoTranslet = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( USE_CLASSPATH ) ) { if ( value instanceof Boolean ) { _useClasspath = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _useClasspath = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( DEBUG ) ) { if ( value instanceof Boolean ) { _debug = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _debug = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( ENABLE_INLINING ) ) { if ( value instanceof Boolean ) { _enableInlining = ( ( Boolean ) value ) . booleanValue ( ) ; return ; } else if ( value instanceof String ) { _enableInlining = ( ( String ) value ) . equalsIgnoreCase ( "true" ) ; return ; } } else if ( name . equals ( INDENT_NUMBER ) ) { if ( value instanceof String ) { try { _indentNumber = Integer . parseInt ( ( String ) value ) ; return ; } catch ( NumberFormatException e ) { } } else if ( value instanceof Integer ) { _indentNumber = ( ( Integer ) value ) . intValue ( ) ; return ; } } final ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_INVALID_ATTR_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } public boolean getFeature ( String name ) { String [ ] features = { DOMSource . FEATURE , DOMResult . FEATURE , SAXSource . FEATURE , SAXResult . FEATURE , StreamSource . FEATURE , StreamResult . FEATURE , SAXTransformerFactory . FEATURE , SAXTransformerFactory . FEATURE_XMLFILTER } ; for ( int i = 0 ; i < features . length ; i ++ ) { if ( name . equals ( features [ i ] ) ) { return true ; } } return false ; } public URIResolver getURIResolver ( ) { return _uriResolver ; } public void setURIResolver ( URIResolver resolver ) { _uriResolver = resolver ; } public Source getAssociatedStylesheet ( Source source , String media , String title , String charset ) throws TransformerConfigurationException { String baseId ; XMLReader reader = null ; InputSource isource = null ; StylesheetPIHandler _stylesheetPIHandler = new StylesheetPIHandler ( null , media , title , charset ) ; try { if ( source instanceof DOMSource ) { final DOMSource domsrc = ( DOMSource ) source ; baseId = domsrc . getSystemId ( ) ; final org . w3c . dom . Node node = domsrc . getNode ( ) ; final DOM2SAX dom2sax = new DOM2SAX ( node ) ; _stylesheetPIHandler . setBaseId ( baseId ) ; dom2sax . setContentHandler ( _stylesheetPIHandler ) ; dom2sax . parse ( ) ; } else { isource = SAXSource . sourceToInputSource ( source ) ; baseId = isource . getSystemId ( ) ; SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; if ( reader == null ) { reader = XMLReaderFactory . createXMLReader ( ) ; } _stylesheetPIHandler . setBaseId ( baseId ) ; reader . setContentHandler ( _stylesheetPIHandler ) ; reader . parse ( isource ) ; } if ( _uriResolver != null ) { _stylesheetPIHandler . setURIResolver ( _uriResolver ) ; } } catch ( StopParseException e ) { } catch ( javax . xml . parsers . ParserConfigurationException e ) { throw new TransformerConfigurationException ( "getAssociatedStylesheets failed" , e ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerConfigurationException ( "getAssociatedStylesheets failed" , se ) ; } catch ( IOException ioe ) { throw new TransformerConfigurationException ( "getAssociatedStylesheets failed" , ioe ) ; } return _stylesheetPIHandler . getAssociatedStylesheet ( ) ; } public Transformer newTransformer ( ) throws TransformerConfigurationException { TransformerImpl result = new TransformerImpl ( new Properties ( ) , _indentNumber , this ) ; if ( _uriResolver != null ) { result . setURIResolver ( _uriResolver ) ; } return result ; } public Transformer newTransformer ( Source source ) throws TransformerConfigurationException { final Templates templates = newTemplates ( source ) ; final Transformer transformer = templates . newTransformer ( ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return ( transformer ) ; } private void passWarningsToListener ( Vector messages ) throws TransformerException { if ( _errorListener == null || messages == null ) { return ; } final int count = messages . size ( ) ; for ( int pos = 0 ; pos < count ; pos ++ ) { String message = messages . elementAt ( pos ) . toString ( ) ; _errorListener . error ( new TransformerConfigurationException ( message ) ) ; } } private void passErrorsToListener ( Vector messages ) { try { if ( _errorListener == null || messages == null ) { return ; } final int count = messages . size ( ) ; for ( int pos = 0 ; pos < count ; pos ++ ) { String message = messages . elementAt ( pos ) . toString ( ) ; _errorListener . error ( new TransformerException ( message ) ) ; } } catch ( TransformerException e ) { } } public Templates newTemplates ( Source source ) throws TransformerConfigurationException { if ( _useClasspath ) { String transletName = getTransletBaseName ( source ) ; if ( _packageName != null ) transletName = _packageName + "." + transletName ; try { final Class clazz = ObjectFactory . findProviderClass ( transletName , ObjectFactory . findClassLoader ( ) , true ) ; resetTransientAttributes ( ) ; return new TemplatesImpl ( new Class [ ] { clazz } , transletName , null , _indentNumber , this ) ; } catch ( ClassNotFoundException cnfe ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , transletName ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( Exception e ) { ErrorMsg err = new ErrorMsg ( new ErrorMsg ( ErrorMsg . RUNTIME_ERROR_KEY ) + e . getMessage ( ) ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } } if ( _autoTranslet ) { byte [ ] [ ] bytecodes = null ; String transletClassName = getTransletBaseName ( source ) ; if ( _packageName != null ) transletClassName = _packageName + "." + transletClassName ; if ( _jarFileName != null ) bytecodes = getBytecodesFromJar ( source , transletClassName ) ; else bytecodes = getBytecodesFromClasses ( source , transletClassName ) ; if ( bytecodes != null ) { if ( _debug ) { if ( _jarFileName != null ) System . err . println ( new ErrorMsg ( ErrorMsg . TRANSFORM_WITH_JAR_STR , transletClassName , _jarFileName ) ) ; else System . err . println ( new ErrorMsg ( ErrorMsg . TRANSFORM_WITH_TRANSLET_STR , transletClassName ) ) ; } resetTransientAttributes ( ) ; return new TemplatesImpl ( bytecodes , transletClassName , null , _indentNumber , this ) ; } } final XSLTC xsltc = new XSLTC ( ) ; if ( _debug ) xsltc . setDebug ( true ) ; if ( _enableInlining ) xsltc . setTemplateInlining ( true ) ; xsltc . init ( ) ; if ( _uriResolver != null ) { xsltc . setSourceLoader ( this ) ; } if ( ( _piParams != null ) && ( _piParams . get ( source ) != null ) ) { PIParamWrapper p = ( PIParamWrapper ) _piParams . get ( source ) ; if ( p != null ) { xsltc . setPIParameters ( p . _media , p . _title , p . _charset ) ; } } int outputType = XSLTC . BYTEARRAY_OUTPUT ; if ( _generateTranslet || _autoTranslet ) { xsltc . setClassName ( getTransletBaseName ( source ) ) ; if ( _destinationDirectory != null ) xsltc . setDestDirectory ( _destinationDirectory ) ; else { String xslName = getStylesheetFileName ( source ) ; if ( xslName != null ) { File xslFile = new File ( xslName ) ; String xslDir = xslFile . getParent ( ) ; if ( xslDir != null ) xsltc . setDestDirectory ( xslDir ) ; } } if ( _packageName != null ) xsltc . setPackageName ( _packageName ) ; if ( _jarFileName != null ) { xsltc . setJarFileName ( _jarFileName ) ; outputType = XSLTC . BYTEARRAY_AND_JAR_OUTPUT ; } else outputType = XSLTC . BYTEARRAY_AND_FILE_OUTPUT ; } final InputSource input = Util . getInputSource ( xsltc , source ) ; byte [ ] [ ] bytecodes = xsltc . compile ( null , input , outputType ) ; final String transletName = xsltc . getClassName ( ) ; if ( ( _generateTranslet || _autoTranslet ) && bytecodes != null && _jarFileName != null ) { try { xsltc . outputToJar ( ) ; } catch ( java . io . IOException e ) { } } resetTransientAttributes ( ) ; if ( _errorListener != this ) { try { passWarningsToListener ( xsltc . getWarnings ( ) ) ; } catch ( TransformerException e ) { throw new TransformerConfigurationException ( e ) ; } } else { xsltc . printWarnings ( ) ; } if ( bytecodes == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_COMPILE_ERR ) ; TransformerConfigurationException exc = new TransformerConfigurationException ( err . toString ( ) ) ; if ( _errorListener != null ) { passErrorsToListener ( xsltc . getErrors ( ) ) ; try { _errorListener . fatalError ( exc ) ; } catch ( TransformerException te ) { } } else { xsltc . printErrors ( ) ; } throw exc ; } return new TemplatesImpl ( bytecodes , transletName , xsltc . getOutputProperties ( ) , _indentNumber , this ) ; } public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { final TemplatesHandlerImpl handler = new TemplatesHandlerImpl ( _indentNumber , this ) ; if ( _uriResolver != null ) { handler . setURIResolver ( _uriResolver ) ; } return handler ; } public TransformerHandler newTransformerHandler ( ) throws TransformerConfigurationException { final Transformer transformer = newTransformer ( ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return new TransformerHandlerImpl ( ( TransformerImpl ) transformer ) ; } public TransformerHandler newTransformerHandler ( Source src ) throws TransformerConfigurationException { final Transformer transformer = newTransformer ( src ) ; if ( _uriResolver != null ) { transformer . setURIResolver ( _uriResolver ) ; } return new TransformerHandlerImpl ( ( TransformerImpl ) transformer ) ; } public TransformerHandler newTransformerHandler ( Templates templates ) throws TransformerConfigurationException { final Transformer transformer = templates . newTransformer ( ) ; final TransformerImpl internal = ( TransformerImpl ) transformer ; return new TransformerHandlerImpl ( internal ) ; } public XMLFilter newXMLFilter ( Source src ) throws TransformerConfigurationException { Templates templates = newTemplates ( src ) ; if ( templates == null ) return null ; return newXMLFilter ( templates ) ; } public XMLFilter newXMLFilter ( Templates templates ) throws TransformerConfigurationException { try { return new org . apache . xalan . xsltc . trax . TrAXFilter ( templates ) ; } catch ( TransformerConfigurationException e1 ) { if ( _errorListener != null ) { try { _errorListener . fatalError ( e1 ) ; return null ; } catch ( TransformerException e2 ) { new TransformerConfigurationException ( e2 ) ; } } throw e1 ; } } public void error ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . ERROR_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . ERROR_MSG , e . getMessageAndLocation ( ) ) ) ; } throw e ; } public void fatalError ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . FATAL_ERR_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . FATAL_ERR_MSG , e . getMessageAndLocation ( ) ) ) ; } throw e ; } public void warning ( TransformerException e ) throws TransformerException { Throwable wrapped = e . getException ( ) ; if ( wrapped != null ) { System . err . println ( new ErrorMsg ( ErrorMsg . WARNING_PLUS_WRAPPED_MSG , e . getMessageAndLocation ( ) , wrapped . getMessage ( ) ) ) ; } else { System . err . println ( new ErrorMsg ( ErrorMsg . WARNING_MSG , e . getMessageAndLocation ( ) ) ) ; } } public InputSource loadSource ( String href , String context , XSLTC xsltc ) { try { if ( _uriResolver != null ) { final Source source = _uriResolver . resolve ( href , context ) ; if ( source != null ) { return Util . getInputSource ( xsltc , source ) ; } } } catch ( TransformerException e ) { } return null ; } private void resetTransientAttributes ( ) { _transletName = DEFAULT_TRANSLET_NAME ; _destinationDirectory = null ; _packageName = null ; _jarFileName = null ; } private byte [ ] [ ] getBytecodesFromClasses ( Source source , String fullClassName ) { if ( fullClassName == null ) return null ; String xslFileName = getStylesheetFileName ( source ) ; File xslFile = null ; if ( xslFileName != null ) xslFile = new File ( xslFileName ) ; final String transletName ; int lastDotIndex = fullClassName . lastIndexOf ( '.' ) ; if ( lastDotIndex > 0 ) transletName = fullClassName . substring ( lastDotIndex + 1 ) ; else transletName = fullClassName ; String transletPath = fullClassName . replace ( '.' , '/' ) ; if ( _destinationDirectory != null ) { transletPath = _destinationDirectory + "/" + transletPath + ".class" ; } else { if ( xslFile != null && xslFile . getParent ( ) != null ) transletPath = xslFile . getParent ( ) + "/" + transletPath + ".class" ; else transletPath = transletPath + ".class" ; } File transletFile = new File ( transletPath ) ; if ( ! transletFile . exists ( ) ) return null ; if ( xslFile != null && xslFile . exists ( ) ) { long xslTimestamp = xslFile . lastModified ( ) ; long transletTimestamp = transletFile . lastModified ( ) ; if ( transletTimestamp < xslTimestamp ) return null ; } Vector bytecodes = new Vector ( ) ; int fileLength = ( int ) transletFile . length ( ) ; if ( fileLength > 0 ) { FileInputStream input = null ; try { input = new FileInputStream ( transletFile ) ; } catch ( FileNotFoundException e ) { return null ; } byte [ ] bytes = new byte [ fileLength ] ; try { readFromInputStream ( bytes , input , fileLength ) ; input . close ( ) ; } catch ( IOException e ) { return null ; } bytecodes . addElement ( bytes ) ; } else return null ; String transletParentDir = transletFile . getParent ( ) ; if ( transletParentDir == null ) transletParentDir = System . getProperty ( "user.dir" ) ; File transletParentFile = new File ( transletParentDir ) ; final String transletAuxPrefix = transletName + "$" ; File [ ] auxfiles = transletParentFile . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return ( name . endsWith ( ".class" ) && name . startsWith ( transletAuxPrefix ) ) ; } } ) ; for ( int i = 0 ; i < auxfiles . length ; i ++ ) { File auxfile = auxfiles [ i ] ; int auxlength = ( int ) auxfile . length ( ) ; if ( auxlength > 0 ) { FileInputStream auxinput = null ; try { auxinput = new FileInputStream ( auxfile ) ; } catch ( FileNotFoundException e ) { continue ; } byte [ ] bytes = new byte [ auxlength ] ; try { readFromInputStream ( bytes , auxinput , auxlength ) ; auxinput . close ( ) ; } catch ( IOException e ) { continue ; } bytecodes . addElement ( bytes ) ; } } final int count = bytecodes . size ( ) ; if ( count > 0 ) { final byte [ ] [ ] result = new byte [ count ] [ 1 ] ; for ( int i = 0 ; i < count ; i ++ ) { result [ i ] = ( byte [ ] ) bytecodes . elementAt ( i ) ; } return result ; } else return null ; } private byte [ ] [ ] getBytecodesFromJar ( Source source , String fullClassName ) { String xslFileName = getStylesheetFileName ( source ) ; File xslFile = null ; if ( xslFileName != null ) xslFile = new File ( xslFileName ) ; String jarPath = null ; if ( _destinationDirectory != null ) jarPath = _destinationDirectory + "/" + _jarFileName ; else { if ( xslFile != null && xslFile . getParent ( ) != null ) jarPath = xslFile . getParent ( ) + "/" + _jarFileName ; else jarPath = _jarFileName ; } File file = new File ( jarPath ) ; if ( ! file . exists ( ) ) return null ; if ( xslFile != null && xslFile . exists ( ) ) { long xslTimestamp = xslFile . lastModified ( ) ; long transletTimestamp = file . lastModified ( ) ; if ( transletTimestamp < xslTimestamp ) return null ; } ZipFile jarFile = null ; try { jarFile = new ZipFile ( file ) ; } catch ( IOException e ) { return null ; } String transletPath = fullClassName . replace ( '.' , '/' ) ; String transletAuxPrefix = transletPath + "$" ; String transletFullName = transletPath + ".class" ; Vector bytecodes = new Vector ( ) ; Enumeration entries = jarFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) entries . nextElement ( ) ; String entryName = entry . getName ( ) ; if ( entry . getSize ( ) > 0 && ( entryName . equals ( transletFullName ) || ( entryName . endsWith ( ".class" ) && entryName . startsWith ( transletAuxPrefix ) ) ) ) { try { InputStream input = jarFile . getInputStream ( entry ) ; int size = ( int ) entry . getSize ( ) ; byte [ ] bytes = new byte [ size ] ; readFromInputStream ( bytes , input , size ) ; input . close ( ) ; bytecodes . addElement ( bytes ) ; } catch ( IOException e ) { return null ; } } } final int count = bytecodes . size ( ) ; if ( count > 0 ) { final byte [ ] [ ] result = new byte [ count ] [ 1 ] ; for ( int i = 0 ; i < count ; i ++ ) { result [ i ] = ( byte [ ] ) bytecodes . elementAt ( i ) ; } return result ; } else return null ; } private void readFromInputStream ( byte [ ] bytes , InputStream input , int size ) throws IOException { int n = 0 ; int offset = 0 ; int length = size ; while ( length > 0 && ( n = input . read ( bytes , offset , length ) ) > 0 ) { offset = offset + n ; length = length - n ; } } private String getTransletBaseName ( Source source ) { String transletBaseName = null ; if ( ! _transletName . equals ( DEFAULT_TRANSLET_NAME ) ) return _transletName ; else { String systemId = source . getSystemId ( ) ; if ( systemId != null ) { String baseName = Util . baseName ( systemId ) ; if ( baseName != null ) { baseName = Util . noExtName ( baseName ) ; transletBaseName = Util . toJavaName ( baseName ) ; } } } return ( transletBaseName != null ) ? transletBaseName : DEFAULT_TRANSLET_NAME ; } private String getStylesheetFileName ( Source source ) { String systemId = source . getSystemId ( ) ; if ( systemId != null ) { File file = new File ( systemId ) ; if ( file . exists ( ) ) return systemId ; else { URL url = null ; try { url = new URL ( systemId ) ; } catch ( MalformedURLException e ) { return null ; } if ( "file" . equals ( url . getProtocol ( ) ) ) return url . getFile ( ) ; else return null ; } } else return null ; } protected Class getDTMManagerClass ( ) { return m_DTMManagerClass ; } } 	1	['33', '3', '0', '17', '151', '322', '6', '16', '23', '0.901442308', '1758', '0.576923077', '0', '0.392156863', '0.142857143', '1', '2', '51.48484848', '17', '2.1212', '5']
package org . apache . xml . utils ; public class SuballocatedIntVector { protected int m_blocksize ; protected int m_SHIFT , m_MASK ; protected static final int NUMBLOCKS_DEFAULT = 32 ; protected int m_numblocks = NUMBLOCKS_DEFAULT ; protected int m_map [ ] [ ] ; protected int m_firstFree = 0 ; protected int m_map0 [ ] ; protected int m_buildCache [ ] ; protected int m_buildCacheStartIndex ; public SuballocatedIntVector ( ) { this ( 2048 ) ; } public SuballocatedIntVector ( int blocksize , int numblocks ) { for ( m_SHIFT = 0 ; 0 != ( blocksize >>>= 1 ) ; ++ m_SHIFT ) ; m_blocksize = 1 << m_SHIFT ; m_MASK = m_blocksize - 1 ; m_numblocks = numblocks ; m_map0 = new int [ m_blocksize ] ; m_map = new int [ numblocks ] [ ] ; m_map [ 0 ] = m_map0 ; m_buildCache = m_map0 ; m_buildCacheStartIndex = 0 ; } public SuballocatedIntVector ( int blocksize ) { this ( blocksize , NUMBLOCKS_DEFAULT ) ; } public int size ( ) { return m_firstFree ; } public void setSize ( int sz ) { if ( m_firstFree > sz ) m_firstFree = sz ; } public void addElement ( int value ) { int indexRelativeToCache = m_firstFree - m_buildCacheStartIndex ; if ( indexRelativeToCache >= 0 && indexRelativeToCache < m_blocksize ) { m_buildCache [ indexRelativeToCache ] = value ; ++ m_firstFree ; } else { int index = m_firstFree > > > m_SHIFT ; int offset = m_firstFree & m_MASK ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; block [ offset ] = value ; m_buildCache = block ; m_buildCacheStartIndex = m_firstFree - offset ; ++ m_firstFree ; } } private void addElements ( int value , int numberOfElements ) { if ( m_firstFree + numberOfElements < m_blocksize ) for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map0 [ m_firstFree ++ ] = value ; } else { int index = m_firstFree > > > m_SHIFT ; int offset = m_firstFree & m_MASK ; m_firstFree += numberOfElements ; while ( numberOfElements > 0 ) { if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; int copied = ( m_blocksize - offset < numberOfElements ) ? m_blocksize - offset : numberOfElements ; numberOfElements -= copied ; while ( copied -- > 0 ) block [ offset ++ ] = value ; ++ index ; offset = 0 ; } } } private void addElements ( int numberOfElements ) { int newlen = m_firstFree + numberOfElements ; if ( newlen > m_blocksize ) { int index = m_firstFree > > > m_SHIFT ; int newindex = ( m_firstFree + numberOfElements ) > > > m_SHIFT ; for ( int i = index + 1 ; i <= newindex ; ++ i ) m_map [ i ] = new int [ m_blocksize ] ; } m_firstFree = newlen ; } private void insertElementAt ( int value , int at ) { if ( at == m_firstFree ) addElement ( value ) ; else if ( at > m_firstFree ) { int index = at > > > m_SHIFT ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; int offset = at & m_MASK ; block [ offset ] = value ; m_firstFree = offset + 1 ; } else { int index = at > > > m_SHIFT ; int maxindex = m_firstFree > > > m_SHIFT ; ++ m_firstFree ; int offset = at & m_MASK ; int push ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; int [ ] block = m_map [ index ] ; if ( null == block ) { push = 0 ; block = m_map [ index ] = new int [ m_blocksize ] ; } else { push = block [ m_blocksize - 1 ] ; System . arraycopy ( block , offset , block , offset + 1 , copylen ) ; } block [ offset ] = value ; value = push ; offset = 0 ; ++ index ; } } } public void removeAllElements ( ) { m_firstFree = 0 ; m_buildCache = m_map0 ; m_buildCacheStartIndex = 0 ; } private boolean removeElement ( int s ) { int at = indexOf ( s , 0 ) ; if ( at < 0 ) return false ; removeElementAt ( at ) ; return true ; } private void removeElementAt ( int at ) { if ( at < m_firstFree ) { int index = at > > > m_SHIFT ; int maxindex = m_firstFree > > > m_SHIFT ; int offset = at & m_MASK ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; else System . arraycopy ( block , offset + 1 , block , offset , copylen ) ; if ( index < maxindex ) { int [ ] next = m_map [ index + 1 ] ; if ( next != null ) block [ m_blocksize - 1 ] = ( next != null ) ? next [ 0 ] : 0 ; } else block [ m_blocksize - 1 ] = 0 ; offset = 0 ; ++ index ; } } -- m_firstFree ; } public void setElementAt ( int value , int at ) { if ( at < m_blocksize ) m_map0 [ at ] = value ; else { int index = at > > > m_SHIFT ; int offset = at & m_MASK ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; block [ offset ] = value ; } if ( at >= m_firstFree ) m_firstFree = at + 1 ; } public int elementAt ( int i ) { if ( i < m_blocksize ) return m_map0 [ i ] ; return m_map [ i > > > m_SHIFT ] [ i & m_MASK ] ; } private boolean contains ( int s ) { return ( indexOf ( s , 0 ) >= 0 ) ; } public int indexOf ( int elem , int index ) { if ( index >= m_firstFree ) return - 1 ; int bindex = index > > > m_SHIFT ; int boffset = index & m_MASK ; int maxindex = m_firstFree > > > m_SHIFT ; int [ ] block ; for ( ; bindex < maxindex ; ++ bindex ) { block = m_map [ bindex ] ; if ( block != null ) for ( int offset = boffset ; offset < m_blocksize ; ++ offset ) if ( block [ offset ] == elem ) return offset + bindex * m_blocksize ; boffset = 0 ; } int maxoffset = m_firstFree & m_MASK ; block = m_map [ maxindex ] ; for ( int offset = boffset ; offset < maxoffset ; ++ offset ) if ( block [ offset ] == elem ) return offset + maxindex * m_blocksize ; return - 1 ; } public int indexOf ( int elem ) { return indexOf ( elem , 0 ) ; } private int lastIndexOf ( int elem ) { int boffset = m_firstFree & m_MASK ; for ( int index = m_firstFree > > > m_SHIFT ; index >= 0 ; -- index ) { int [ ] block = m_map [ index ] ; if ( block != null ) for ( int offset = boffset ; offset >= 0 ; -- offset ) if ( block [ offset ] == elem ) return offset + index * m_blocksize ; boffset = 0 ; } return - 1 ; } public final int [ ] getMap0 ( ) { return m_map0 ; } public final int [ ] [ ] getMap ( ) { return m_map ; } } 	1	['20', '1', '0', '15', '22', '8', '15', '0', '13', '0.552631579', '901', '1', '0', '0', '0.875', '0', '0', '43.55', '8', '2.95', '1']
package org . w3c . dom . xpath ; import org . w3c . dom . Node ; import org . w3c . dom . DOMException ; public interface XPathExpression { public Object evaluate ( Node contextNode , short type , Object result ) throws XPathException , DOMException ; } 	1	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . xml . serializer ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Transformer ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . BoolStack ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; abstract public class SerializerBase implements SerializationHandler , SerializerConstants , org . apache . xml . dtm . ref . dom2dtm . DOM2DTM . CharacterNodeHandler { protected void fireEndElem ( String name ) throws org . xml . sax . SAXException { if ( m_tracer != null ) { flushMyWriter ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENDELEMENT , name , ( Attributes ) null ) ; } } protected void fireCharEvent ( char [ ] chars , int start , int length ) throws org . xml . sax . SAXException { if ( m_tracer != null ) { flushMyWriter ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_CHARACTERS , chars , start , length ) ; } } protected boolean m_needToCallStartDocument = true ; protected boolean m_cdataTagOpen = false ; protected AttributesImplSerializer m_attributes = new AttributesImplSerializer ( ) ; protected boolean m_inEntityRef = false ; protected boolean m_inExternalDTD = false ; private String m_doctypeSystem ; private String m_doctypePublic ; boolean m_needToOutputDocTypeDecl = true ; private String m_encoding = null ; private boolean m_shouldNotWriteXMLHeader = false ; private String m_standalone ; protected boolean m_standaloneWasSpecified = false ; protected boolean m_doIndent = false ; protected int m_indentAmount = 0 ; private String m_version = null ; private String m_mediatype ; private Transformer m_transformer ; protected Vector m_cdataSectionElements = null ; protected NamespaceMappings m_prefixMap ; protected SerializerTrace m_tracer ; protected SourceLocator m_sourceLocator ; protected java . io . Writer m_writer = null ; protected ElemContext m_elemContext = new ElemContext ( ) ; protected char [ ] m_charsBuff = new char [ 60 ] ; protected char [ ] m_attrBuff = new char [ 30 ] ; public void comment ( String data ) throws SAXException { final int length = data . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * 2 + 1 ] ; } data . getChars ( 0 , length , m_charsBuff , 0 ) ; comment ( m_charsBuff , 0 , length ) ; } protected String patchName ( String qname ) { final int lastColon = qname . lastIndexOf ( ':' ) ; if ( lastColon > 0 ) { final int firstColon = qname . indexOf ( ':' ) ; final String prefix = qname . substring ( 0 , firstColon ) ; final String localName = qname . substring ( lastColon + 1 ) ; final String uri = m_prefixMap . lookupNamespace ( prefix ) ; if ( uri != null && uri . length ( ) == 0 ) { return localName ; } else if ( firstColon != lastColon ) { return prefix + ':' + localName ; } } return qname ; } protected static String getLocalName ( String qname ) { final int col = qname . lastIndexOf ( ':' ) ; return ( col > 0 ) ? qname . substring ( col + 1 ) : qname ; } public void setDocumentLocator ( Locator locator ) { return ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { if ( m_elemContext . m_startTagOpen ) { addAttributeAlways ( uri , localName , rawName , type , value ) ; } } public void addAttributeAlways ( String uri , String localName , String rawName , String type , String value ) { int index ; index = m_attributes . getIndex ( rawName ) ; if ( index >= 0 ) { m_attributes . setValue ( index , value ) ; } else { m_attributes . addAttribute ( uri , localName , rawName , type , value ) ; } } public void addAttribute ( String name , final String value ) { if ( m_elemContext . m_startTagOpen ) { final String patchedName = patchName ( name ) ; final String localName = getLocalName ( patchedName ) ; final String uri = getNamespaceURI ( patchedName , false ) ; addAttributeAlways ( uri , localName , patchedName , "CDATA" , value ) ; } } public void addAttributes ( Attributes atts ) throws SAXException { int nAtts = atts . getLength ( ) ; for ( int i = 0 ; i < nAtts ; i ++ ) { String uri = atts . getURI ( i ) ; if ( null == uri ) uri = "" ; addAttributeAlways ( uri , atts . getLocalName ( i ) , atts . getQName ( i ) , atts . getType ( i ) , atts . getValue ( i ) ) ; } } public ContentHandler asContentHandler ( ) throws IOException { return this ; } public void endEntity ( String name ) throws org . xml . sax . SAXException { if ( name . equals ( "[dtd]" ) ) m_inExternalDTD = false ; m_inEntityRef = false ; if ( m_tracer != null ) this . fireEndEntity ( name ) ; } public void close ( ) { } protected void initCDATA ( ) { } public String getEncoding ( ) { return m_encoding ; } public void setEncoding ( String m_encoding ) { this . m_encoding = m_encoding ; } public void setOmitXMLDeclaration ( boolean b ) { this . m_shouldNotWriteXMLHeader = b ; } public boolean getOmitXMLDeclaration ( ) { return m_shouldNotWriteXMLHeader ; } public String getDoctypePublic ( ) { return m_doctypePublic ; } public void setDoctypePublic ( String doctypePublic ) { this . m_doctypePublic = doctypePublic ; } public String getDoctypeSystem ( ) { return m_doctypeSystem ; } public void setDoctypeSystem ( String doctypeSystem ) { this . m_doctypeSystem = doctypeSystem ; } public void setDoctype ( String doctypeSystem , String doctypePublic ) { this . m_doctypeSystem = doctypeSystem ; this . m_doctypePublic = doctypePublic ; } public void setStandalone ( String standalone ) { if ( standalone != null ) { m_standaloneWasSpecified = true ; setStandaloneInternal ( standalone ) ; } } protected void setStandaloneInternal ( String standalone ) { if ( "yes" . equals ( standalone ) ) m_standalone = "yes" ; else m_standalone = "no" ; } public String getStandalone ( ) { return m_standalone ; } public boolean getIndent ( ) { return m_doIndent ; } public String getMediaType ( ) { return m_mediatype ; } public String getVersion ( ) { return m_version ; } public void setVersion ( String version ) { m_version = version ; } public void setMediaType ( String mediaType ) { m_mediatype = mediaType ; } public int getIndentAmount ( ) { return m_indentAmount ; } public void setIndentAmount ( int m_indentAmount ) { this . m_indentAmount = m_indentAmount ; } public void setIndent ( boolean doIndent ) { m_doIndent = doIndent ; } public void namespaceAfterStartElement ( String uri , String prefix ) throws SAXException { } public DOMSerializer asDOMSerializer ( ) throws IOException { return this ; } protected boolean isCdataSection ( ) { boolean b = false ; if ( null != m_cdataSectionElements ) { if ( m_elemContext . m_elementLocalName == null ) m_elemContext . m_elementLocalName = getLocalName ( m_elemContext . m_elementName ) ; if ( m_elemContext . m_elementURI == null ) { String prefix = getPrefixPart ( m_elemContext . m_elementName ) ; if ( prefix != null ) m_elemContext . m_elementURI = m_prefixMap . lookupNamespace ( prefix ) ; } if ( ( null != m_elemContext . m_elementURI ) && m_elemContext . m_elementURI . length ( ) == 0 ) m_elemContext . m_elementURI = null ; int nElems = m_cdataSectionElements . size ( ) ; for ( int i = 0 ; i < nElems ; i += 2 ) { String uri = ( String ) m_cdataSectionElements . elementAt ( i ) ; String loc = ( String ) m_cdataSectionElements . elementAt ( i + 1 ) ; if ( loc . equals ( m_elemContext . m_elementLocalName ) && subPartMatch ( m_elemContext . m_elementURI , uri ) ) { b = true ; break ; } } } return b ; } private static final boolean subPartMatch ( String p , String t ) { return ( p == t ) || ( ( null != p ) && ( p . equals ( t ) ) ) ; } protected static final String getPrefixPart ( String qname ) { final int col = qname . indexOf ( ':' ) ; return ( col > 0 ) ? qname . substring ( 0 , col ) : null ; } public NamespaceMappings getNamespaceMappings ( ) { return m_prefixMap ; } public String getPrefix ( String namespaceURI ) { String prefix = m_prefixMap . lookupPrefix ( namespaceURI ) ; return prefix ; } public String getNamespaceURI ( String qname , boolean isElement ) { String uri = EMPTYSTRING ; int col = qname . lastIndexOf ( ':' ) ; final String prefix = ( col > 0 ) ? qname . substring ( 0 , col ) : EMPTYSTRING ; if ( ! EMPTYSTRING . equals ( prefix ) || isElement ) { if ( m_prefixMap != null ) { uri = m_prefixMap . lookupNamespace ( prefix ) ; if ( uri == null && ! prefix . equals ( XMLNS_PREFIX ) ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NAMESPACE_PREFIX , new Object [ ] { qname . substring ( 0 , col ) } ) ) ; } } } return uri ; } public String getNamespaceURIFromPrefix ( String prefix ) { String uri = null ; if ( m_prefixMap != null ) uri = m_prefixMap . lookupNamespace ( prefix ) ; return uri ; } public void entityReference ( String name ) throws org . xml . sax . SAXException { flushPending ( ) ; startEntity ( name ) ; endEntity ( name ) ; if ( m_tracer != null ) fireEntityReference ( name ) ; } public void setTransformer ( Transformer t ) { m_transformer = t ; if ( ( m_transformer instanceof SerializerTrace ) && ( ( ( SerializerTrace ) m_transformer ) . hasTraceListeners ( ) ) ) { m_tracer = ( SerializerTrace ) m_transformer ; } else { m_tracer = null ; } } public Transformer getTransformer ( ) { return m_transformer ; } public void characters ( org . w3c . dom . Node node ) throws org . xml . sax . SAXException { flushPending ( ) ; String data = node . getNodeValue ( ) ; if ( data != null ) { final int length = data . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * 2 + 1 ] ; } data . getChars ( 0 , length , m_charsBuff , 0 ) ; characters ( m_charsBuff , 0 , length ) ; } } public void error ( SAXParseException exc ) throws SAXException { } public void fatalError ( SAXParseException exc ) throws SAXException { m_elemContext . m_startTagOpen = false ; } public void warning ( SAXParseException exc ) throws SAXException { } protected void fireStartEntity ( String name ) throws org . xml . sax . SAXException { if ( m_tracer != null ) { flushMyWriter ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENTITYREF , name ) ; } } private void flushMyWriter ( ) { if ( m_writer != null ) { try { m_writer . flush ( ) ; } catch ( IOException ioe ) { } } } protected void fireCDATAEvent ( char [ ] chars , int start , int length ) throws org . xml . sax . SAXException { if ( m_tracer != null ) { flushMyWriter ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_CDATA , chars , start , length ) ; } } protected void fireCommentEvent ( char [ ] chars , int start , int length ) throws org . xml . sax . SAXException { if ( m_tracer != null ) { flushMyWriter ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_COMMENT , new String ( chars , start , length ) ) ; } } public void fireEndEntity ( String name ) throws org . xml . sax . SAXException { if ( m_tracer != null ) flushMyWriter ( ) ; } protected void fireStartDoc ( ) throws org . xml . sax . SAXException { if ( m_tracer != null ) { flushMyWriter ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_STARTDOCUMENT ) ; } } protected void fireEndDoc ( ) throws org . xml . sax . SAXException { if ( m_tracer != null ) { flushMyWriter ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENDDOCUMENT ) ; } } protected void fireStartElem ( String elemName ) throws org . xml . sax . SAXException { if ( m_tracer != null ) { flushMyWriter ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_STARTELEMENT , elemName , m_attributes ) ; } } protected void fireEscapingEvent ( String name , String data ) throws org . xml . sax . SAXException { if ( m_tracer != null ) { flushMyWriter ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_PI , name , data ) ; } } protected void fireEntityReference ( String name ) throws org . xml . sax . SAXException { if ( m_tracer != null ) { flushMyWriter ( ) ; m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENTITYREF , name , ( Attributes ) null ) ; } } public void startDocument ( ) throws org . xml . sax . SAXException { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; return ; } protected void startDocumentInternal ( ) throws org . xml . sax . SAXException { if ( m_tracer != null ) this . fireStartDoc ( ) ; } public void setSourceLocator ( SourceLocator locator ) { m_sourceLocator = locator ; } public void setNamespaceMappings ( NamespaceMappings mappings ) { m_prefixMap = mappings ; } public boolean reset ( ) { resetSerializerBase ( ) ; return true ; } private void resetSerializerBase ( ) { this . m_attributes . clear ( ) ; this . m_cdataSectionElements = null ; this . m_elemContext = new ElemContext ( ) ; this . m_doctypePublic = null ; this . m_doctypeSystem = null ; this . m_doIndent = false ; this . m_encoding = null ; this . m_indentAmount = 0 ; this . m_inEntityRef = false ; this . m_inExternalDTD = false ; this . m_mediatype = null ; this . m_needToCallStartDocument = true ; this . m_needToOutputDocTypeDecl = false ; if ( this . m_prefixMap != null ) this . m_prefixMap . reset ( ) ; this . m_shouldNotWriteXMLHeader = false ; this . m_sourceLocator = null ; this . m_standalone = null ; this . m_standaloneWasSpecified = false ; this . m_tracer = null ; this . m_transformer = null ; this . m_version = null ; } } 	1	['67', '1', '3', '12', '111', '1771', '3', '9', '47', '0.931515152', '958', '0.96', '4', '0', '0.138059701', '0', '0', '12.92537313', '10', '1.4776', '5']
package org . apache . xml . serializer ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . util . Enumeration ; import java . util . Properties ; import javax . xml . transform . OutputKeys ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . Constants ; import org . apache . xml . utils . WrappedRuntimeException ; public class OutputPropertiesFactory { public static final String S_BUILTIN_EXTENSIONS_UNIVERSAL = "{" + Constants . S_BUILTIN_EXTENSIONS_URL + "}" ; public static final String S_KEY_INDENT_AMOUNT = S_BUILTIN_EXTENSIONS_UNIVERSAL + "indent-amount" ; public static final String S_KEY_CONTENT_HANDLER = S_BUILTIN_EXTENSIONS_UNIVERSAL + "content-handler" ; public static final String S_KEY_ENTITIES = S_BUILTIN_EXTENSIONS_UNIVERSAL + "entities" ; public static final String S_USE_URL_ESCAPING = S_BUILTIN_EXTENSIONS_UNIVERSAL + "use-url-escaping" ; public static final String S_OMIT_META_TAG = S_BUILTIN_EXTENSIONS_UNIVERSAL + "omit-meta-tag" ; public static final String S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL = "{" + Constants . S_BUILTIN_OLD_EXTENSIONS_URL + "}" ; public static final int S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL_LEN = S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL . length ( ) ; private static final String S_XSLT_PREFIX = "xslt.output." ; private static final int S_XSLT_PREFIX_LEN = S_XSLT_PREFIX . length ( ) ; private static final String S_XALAN_PREFIX = "org.apache.xslt." ; private static final int S_XALAN_PREFIX_LEN = S_XALAN_PREFIX . length ( ) ; private static Integer m_synch_object = new Integer ( 1 ) ; private static final String PROP_DIR = "org/apache/xml/serializer/" ; private static final String PROP_FILE_XML = "output_xml.properties" ; private static final String PROP_FILE_TEXT = "output_text.properties" ; private static final String PROP_FILE_HTML = "output_html.properties" ; private static final String PROP_FILE_UNKNOWN = "output_unknown.properties" ; private static Properties m_xml_properties = null ; private static Properties m_html_properties = null ; private static Properties m_text_properties = null ; private static Properties m_unknown_properties = null ; private static final Class ACCESS_CONTROLLER_CLASS = findAccessControllerClass ( ) ; private static Class findAccessControllerClass ( ) { try { return Class . forName ( "java.security.AccessController" ) ; } catch ( Exception e ) { } return null ; } static public Properties getDefaultMethodProperties ( String method ) { String fileName = null ; Properties defaultProperties = null ; try { synchronized ( m_synch_object ) { if ( null == m_xml_properties ) { fileName = PROP_FILE_XML ; m_xml_properties = loadPropertiesFile ( fileName , null ) ; } } if ( method . equals ( Method . XML ) ) { defaultProperties = m_xml_properties ; } else if ( method . equals ( Method . HTML ) ) { if ( null == m_html_properties ) { fileName = PROP_FILE_HTML ; m_html_properties = loadPropertiesFile ( fileName , m_xml_properties ) ; } defaultProperties = m_html_properties ; } else if ( method . equals ( Method . TEXT ) ) { if ( null == m_text_properties ) { fileName = PROP_FILE_TEXT ; m_text_properties = loadPropertiesFile ( fileName , m_xml_properties ) ; if ( null == m_text_properties . getProperty ( OutputKeys . ENCODING ) ) { String mimeEncoding = Encodings . getMimeEncoding ( null ) ; m_text_properties . put ( OutputKeys . ENCODING , mimeEncoding ) ; } } defaultProperties = m_text_properties ; } else if ( method . equals ( org . apache . xml . serializer . Method . UNKNOWN ) ) { if ( null == m_unknown_properties ) { fileName = PROP_FILE_UNKNOWN ; m_unknown_properties = loadPropertiesFile ( fileName , m_xml_properties ) ; } defaultProperties = m_unknown_properties ; } else { defaultProperties = m_xml_properties ; } } catch ( IOException ioe ) { throw new WrappedRuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COULD_NOT_LOAD_METHOD_PROPERTY , new Object [ ] { fileName , method } ) , ioe ) ; } return new Properties ( defaultProperties ) ; } static private Properties loadPropertiesFile ( final String resourceName , Properties defaults ) throws IOException { Properties props = new Properties ( defaults ) ; InputStream is = null ; BufferedInputStream bis = null ; try { if ( ACCESS_CONTROLLER_CLASS != null ) { is = ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return OutputPropertiesFactory . class . getResourceAsStream ( resourceName ) ; } } ) ; } else { is = OutputPropertiesFactory . class . getResourceAsStream ( resourceName ) ; } bis = new BufferedInputStream ( is ) ; props . load ( bis ) ; } catch ( IOException ioe ) { if ( defaults == null ) { throw ioe ; } else { throw new WrappedRuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COULD_NOT_LOAD_RESOURCE , new Object [ ] { resourceName } ) , ioe ) ; } } catch ( SecurityException se ) { if ( defaults == null ) { throw se ; } else { throw new WrappedRuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COULD_NOT_LOAD_RESOURCE , new Object [ ] { resourceName } ) , se ) ; } } finally { if ( bis != null ) { bis . close ( ) ; } if ( is != null ) { is . close ( ) ; } } Enumeration keys = ( ( Properties ) props . clone ( ) ) . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = ( String ) keys . nextElement ( ) ; String value = null ; try { value = System . getProperty ( key ) ; } catch ( SecurityException se ) { } if ( value == null ) value = ( String ) props . get ( key ) ; String newKey = fixupPropertyString ( key , true ) ; String newValue = null ; try { newValue = System . getProperty ( newKey ) ; } catch ( SecurityException se ) { } if ( newValue == null ) newValue = fixupPropertyString ( value , false ) ; else newValue = fixupPropertyString ( newValue , false ) ; if ( key != newKey || value != newValue ) { props . remove ( key ) ; props . put ( newKey , newValue ) ; } } return props ; } static private String fixupPropertyString ( String s , boolean doClipping ) { int index ; if ( doClipping && s . startsWith ( S_XSLT_PREFIX ) ) { s = s . substring ( S_XSLT_PREFIX_LEN ) ; } if ( s . startsWith ( S_XALAN_PREFIX ) ) { s = S_BUILTIN_EXTENSIONS_UNIVERSAL + s . substring ( S_XALAN_PREFIX_LEN ) ; } if ( ( index = s . indexOf ( "\\u003a" ) ) > 0 ) { String temp = s . substring ( index + 6 ) ; s = s . substring ( 0 , index ) + ":" + temp ; } return s ; } } 	1	['6', '1', '0', '10', '38', '9', '6', '4', '2', '1.026086957', '388', '0.652173913', '0', '0', '0.3', '0', '0', '59.83333333', '10', '2.8333', '2']
package org . apache . xpath . axes ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public abstract class LocPathIterator extends PredicatedNodeTest implements Cloneable , DTMIterator , java . io . Serializable , PathComponent { protected LocPathIterator ( ) { } protected LocPathIterator ( PrefixResolver nscontext ) { setLocPathIterator ( this ) ; m_prefixResolver = nscontext ; } protected LocPathIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { this ( compiler , opPos , analysis , true ) ; } protected LocPathIterator ( Compiler compiler , int opPos , int analysis , boolean shouldLoadWalkers ) throws javax . xml . transform . TransformerException { setLocPathIterator ( this ) ; } public int getAnalysisBits ( ) { int axis = getAxis ( ) ; int bit = WalkerFactory . getAnalysisBitFromAxes ( axis ) ; return bit ; } private void readObject ( java . io . ObjectInputStream stream ) throws java . io . IOException , javax . xml . transform . TransformerException { try { stream . defaultReadObject ( ) ; m_clones = new IteratorPool ( this ) ; } catch ( ClassNotFoundException cnfe ) { throw new javax . xml . transform . TransformerException ( cnfe ) ; } } public void setEnvironment ( Object environment ) { } public DTM getDTM ( int nodeHandle ) { return m_execContext . getDTM ( nodeHandle ) ; } public DTMManager getDTMManager ( ) { return m_execContext . getDTMManager ( ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XNodeSet iter = new XNodeSet ( ( LocPathIterator ) m_clones . getInstance ( ) ) ; iter . setRoot ( xctxt . getCurrentNode ( ) , xctxt ) ; return iter ; } public void executeCharsToContentHandler ( XPathContext xctxt , org . xml . sax . ContentHandler handler ) throws javax . xml . transform . TransformerException , org . xml . sax . SAXException { LocPathIterator clone = ( LocPathIterator ) m_clones . getInstance ( ) ; int current = xctxt . getCurrentNode ( ) ; clone . setRoot ( current , xctxt ) ; int node = clone . nextNode ( ) ; DTM dtm = clone . getDTM ( node ) ; clone . detach ( ) ; if ( node != DTM . NULL ) { dtm . dispatchCharactersEvents ( node , handler , false ) ; } } public DTMIterator asIterator ( XPathContext xctxt , int contextNode ) throws javax . xml . transform . TransformerException { XNodeSet iter = new XNodeSet ( ( LocPathIterator ) m_clones . getInstance ( ) ) ; iter . setRoot ( contextNode , xctxt ) ; return iter ; } public boolean isNodesetExpr ( ) { return true ; } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { DTMIterator iter = ( DTMIterator ) m_clones . getInstance ( ) ; int current = xctxt . getCurrentNode ( ) ; iter . setRoot ( current , xctxt ) ; int next = iter . nextNode ( ) ; iter . detach ( ) ; return next ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( asNode ( xctxt ) != DTM . NULL ) ; } public void setIsTopLevel ( boolean b ) { m_isTopLevel = b ; } public boolean getIsTopLevel ( ) { return m_isTopLevel ; } public void setRoot ( int context , Object environment ) { m_context = context ; XPathContext xctxt = ( XPathContext ) environment ; m_execContext = xctxt ; m_cdtm = xctxt . getDTM ( context ) ; m_currentContextNode = context ; if ( null == m_prefixResolver ) m_prefixResolver = xctxt . getNamespaceContext ( ) ; m_lastFetched = DTM . NULL ; m_foundLast = false ; m_pos = 0 ; m_length = - 1 ; if ( m_isTopLevel ) this . m_stackFrame = xctxt . getVarStack ( ) . getStackFrame ( ) ; } protected void setNextPosition ( int next ) { assertion ( false , "setNextPosition not supported in this iterator!" ) ; } public final int getCurrentPos ( ) { return m_pos ; } public void setShouldCacheNodes ( boolean b ) { assertion ( false , "setShouldCacheNodes not supported by this iterater!" ) ; } public boolean isMutable ( ) { return false ; } public void setCurrentPos ( int i ) { assertion ( false , "setCurrentPos not supported by this iterator!" ) ; } public void incrementCurrentPos ( ) { m_pos ++ ; } public int size ( ) { assertion ( false , "size() not supported by this iterator!" ) ; return 0 ; } public int item ( int index ) { assertion ( false , "item(int index) not supported by this iterator!" ) ; return 0 ; } public void setItem ( int node , int index ) { assertion ( false , "setItem not supported by this iterator!" ) ; } public int getLength ( ) { boolean isPredicateTest = ( this == m_execContext . getSubContextList ( ) ) ; int predCount = getPredicateCount ( ) ; if ( - 1 != m_length && isPredicateTest && m_predicateIndex < 1 ) return m_length ; if ( m_foundLast ) return m_pos ; int pos = ( m_predicateIndex >= 0 ) ? getProximityPosition ( ) : m_pos ; LocPathIterator clone ; try { clone = ( LocPathIterator ) clone ( ) ; } catch ( CloneNotSupportedException cnse ) { return - 1 ; } if ( predCount > 0 && isPredicateTest ) { clone . m_predCount = m_predicateIndex ; } int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { pos ++ ; } if ( isPredicateTest && m_predicateIndex < 1 ) m_length = pos ; return pos ; } public boolean isFresh ( ) { return ( m_pos == 0 ) ; } public int previousNode ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_ITERATE , null ) ) ; } public int getWhatToShow ( ) { return DTMFilter . SHOW_ALL & ~ DTMFilter . SHOW_ENTITY_REFERENCE ; } public DTMFilter getFilter ( ) { return null ; } public int getRoot ( ) { return m_context ; } public boolean getExpandEntityReferences ( ) { return true ; } protected boolean m_allowDetach = true ; public void allowDetachToRelease ( boolean allowRelease ) { m_allowDetach = allowRelease ; } public void detach ( ) { if ( m_allowDetach ) { m_execContext = null ; m_cdtm = null ; m_length = - 1 ; m_pos = 0 ; m_lastFetched = DTM . NULL ; m_context = DTM . NULL ; m_currentContextNode = DTM . NULL ; m_clones . freeInstance ( this ) ; } } public void reset ( ) { assertion ( false , "This iterator can not reset!" ) ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { LocPathIterator clone ; clone = ( LocPathIterator ) m_clones . getInstanceOrThrow ( ) ; clone . m_execContext = m_execContext ; clone . m_cdtm = m_cdtm ; clone . m_context = m_context ; clone . m_currentContextNode = m_currentContextNode ; clone . m_stackFrame = m_stackFrame ; return clone ; } public abstract int nextNode ( ) ; protected int returnNextNode ( int nextNode ) { if ( DTM . NULL != nextNode ) { m_pos ++ ; } m_lastFetched = nextNode ; if ( DTM . NULL == nextNode ) m_foundLast = true ; return nextNode ; } public int getCurrentNode ( ) { return m_lastFetched ; } public void runTo ( int index ) { if ( m_foundLast || ( ( index >= 0 ) && ( index <= getCurrentPos ( ) ) ) ) return ; int n ; if ( - 1 == index ) { while ( DTM . NULL != ( n = nextNode ( ) ) ) ; } else { while ( DTM . NULL != ( n = nextNode ( ) ) ) { if ( getCurrentPos ( ) >= index ) break ; } } } public final boolean getFoundLast ( ) { return m_foundLast ; } public final XPathContext getXPathContext ( ) { return m_execContext ; } public final int getContext ( ) { return m_context ; } public final int getCurrentContextNode ( ) { return m_currentContextNode ; } public final void setCurrentContextNode ( int n ) { m_currentContextNode = n ; } public final PrefixResolver getPrefixResolver ( ) { if ( null == m_prefixResolver ) { m_prefixResolver = ( PrefixResolver ) getExpressionOwner ( ) ; } return m_prefixResolver ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitLocationPath ( owner , this ) ) { visitor . visitStep ( owner , this ) ; callPredicateVisitors ( visitor ) ; } } transient protected IteratorPool m_clones = new IteratorPool ( this ) ; transient protected DTM m_cdtm ; transient int m_stackFrame = - 1 ; private boolean m_isTopLevel = false ; transient public int m_lastFetched = DTM . NULL ; transient protected int m_context = DTM . NULL ; transient protected int m_currentContextNode = DTM . NULL ; transient protected int m_pos = 0 ; transient protected int m_length = - 1 ; private PrefixResolver m_prefixResolver ; transient protected XPathContext m_execContext ; public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return - 1 ; } public int getLastPos ( XPathContext xctxt ) { return getLength ( ) ; } } 	1	['52', '4', '8', '37', '84', '1016', '20', '20', '45', '0.85130719', '665', '0.833333333', '4', '0.616', '0.145104895', '2', '9', '11.55769231', '12', '1.4231', '1']
package org . apache . xml . serializer ; import java . util . Hashtable ; import org . xml . sax . Attributes ; import org . xml . sax . helpers . AttributesImpl ; public class AttributesImplSerializer extends AttributesImpl { private Hashtable m_indexFromQName = new Hashtable ( ) ; public static final int MAX = 12 ; private static final int MAXMinus1 = MAX - 1 ; public int getIndex ( String qname ) { int index ; if ( super . getLength ( ) < MAX ) { index = super . getIndex ( qname ) ; return index ; } Integer i = ( Integer ) m_indexFromQName . get ( qname ) ; if ( i == null ) index = - 1 ; else index = i . intValue ( ) ; return index ; } public void addAttribute ( String uri , String local , String qname , String type , String val ) { int index = super . getLength ( ) ; super . addAttribute ( uri , local , qname , type , val ) ; if ( index < MAXMinus1 ) { return ; } else if ( index == MAXMinus1 ) { switchOverToHash ( MAX ) ; } else { Integer i = new Integer ( index ) ; m_indexFromQName . put ( qname , i ) ; } return ; } private void switchOverToHash ( int numAtts ) { for ( int index = 0 ; index < numAtts ; index ++ ) { String qName = super . getQName ( index ) ; Integer i = new Integer ( index ) ; m_indexFromQName . put ( qName , i ) ; } } public void clear ( ) { int len = super . getLength ( ) ; super . clear ( ) ; if ( MAX <= len ) { m_indexFromQName . clear ( ) ; } } public void setAttributes ( Attributes atts ) { super . setAttributes ( atts ) ; int numAtts = atts . getLength ( ) ; if ( MAX <= numAtts ) switchOverToHash ( numAtts ) ; } } 	1	['6', '2', '0', '6', '20', '0', '6', '0', '5', '0.8', '124', '0.666666667', '0', '0.827586207', '0.416666667', '1', '2', '19.16666667', '3', '2', '1']
package org . apache . xalan . transformer ; import java . io . IOException ; import javax . xml . transform . Result ; import javax . xml . transform . Transformer ; import javax . xml . transform . sax . TransformerHandler ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . IncrementalSAXSource_Filter ; import org . apache . xml . dtm . ref . sax2dtm . SAX2DTM ; import org . apache . xpath . XPathContext ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . apache . xml . serializer . SerializationHandler ; public class TransformerHandlerImpl implements EntityResolver , DTDHandler , ContentHandler , ErrorHandler , LexicalHandler , TransformerHandler , DeclHandler { private boolean m_insideParse = false ; public TransformerHandlerImpl ( TransformerImpl transformer , boolean doFragment , String baseSystemID ) { super ( ) ; m_transformer = transformer ; m_baseSystemID = baseSystemID ; XPathContext xctxt = transformer . getXPathContext ( ) ; DTM dtm = xctxt . getDTM ( null , true , transformer , true , true ) ; m_dtm = dtm ; dtm . setDocumentBaseURI ( baseSystemID ) ; m_contentHandler = dtm . getContentHandler ( ) ; m_dtdHandler = dtm . getDTDHandler ( ) ; m_entityResolver = dtm . getEntityResolver ( ) ; m_errorHandler = dtm . getErrorHandler ( ) ; m_lexicalHandler = dtm . getLexicalHandler ( ) ; } protected void clearCoRoutine ( ) { clearCoRoutine ( null ) ; } protected void clearCoRoutine ( SAXException ex ) { if ( null != ex ) m_transformer . setExceptionThrown ( ex ) ; if ( m_dtm instanceof SAX2DTM ) { if ( DEBUG ) System . err . println ( "In clearCoRoutine..." ) ; try { SAX2DTM sax2dtm = ( ( SAX2DTM ) m_dtm ) ; if ( null != m_contentHandler && m_contentHandler instanceof IncrementalSAXSource_Filter ) { IncrementalSAXSource_Filter sp = ( IncrementalSAXSource_Filter ) m_contentHandler ; sp . deliverMoreNodes ( false ) ; } sax2dtm . clearCoRoutine ( true ) ; m_contentHandler = null ; m_dtdHandler = null ; m_entityResolver = null ; m_errorHandler = null ; m_lexicalHandler = null ; } catch ( Throwable throwable ) { throwable . printStackTrace ( ) ; } if ( DEBUG ) System . err . println ( "...exiting clearCoRoutine" ) ; } } public void setResult ( Result result ) throws IllegalArgumentException { if ( null == result ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_RESULT_NULL , null ) ) ; try { SerializationHandler xoh = m_transformer . createSerializationHandler ( result ) ; m_transformer . setSerializationHandler ( xoh ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_RESULT_COULD_NOT_BE_SET , null ) ) ; } m_result = result ; } public void setSystemId ( String systemID ) { m_baseSystemID = systemID ; m_dtm . setDocumentBaseURI ( systemID ) ; } public String getSystemId ( ) { return m_baseSystemID ; } public Transformer getTransformer ( ) { return m_transformer ; } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( m_entityResolver != null ) { return m_entityResolver . resolveEntity ( publicId , systemId ) ; } else { return null ; } } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { if ( m_dtdHandler != null ) { m_dtdHandler . notationDecl ( name , publicId , systemId ) ; } } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( m_dtdHandler != null ) { m_dtdHandler . unparsedEntityDecl ( name , publicId , systemId , notationName ) ; } } public void setDocumentLocator ( Locator locator ) { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#setDocumentLocator: " + locator . getSystemId ( ) ) ; this . m_locator = locator ; if ( null == m_baseSystemID ) { setSystemId ( locator . getSystemId ( ) ) ; } if ( m_contentHandler != null ) { m_contentHandler . setDocumentLocator ( locator ) ; } } public void startDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startDocument" ) ; m_insideParse = true ; if ( m_contentHandler != null ) { if ( DTMManager . getIncremental ( ) ) { m_transformer . setSourceTreeDocForThread ( m_dtm . getDocument ( ) ) ; int cpriority = Thread . currentThread ( ) . getPriority ( ) ; m_transformer . runTransformThread ( cpriority ) ; } m_contentHandler . startDocument ( ) ; } } public void endDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endDocument" ) ; m_insideParse = false ; if ( m_contentHandler != null ) { m_contentHandler . endDocument ( ) ; } if ( DTMManager . getIncremental ( ) ) { m_transformer . waitTransformThread ( ) ; } else { m_transformer . setSourceTreeDocForThread ( m_dtm . getDocument ( ) ) ; m_transformer . run ( ) ; } } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startPrefixMapping: " + prefix + ", " + uri ) ; if ( m_contentHandler != null ) { m_contentHandler . startPrefixMapping ( prefix , uri ) ; } } public void endPrefixMapping ( String prefix ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endPrefixMapping: " + prefix ) ; if ( m_contentHandler != null ) { m_contentHandler . endPrefixMapping ( prefix ) ; } } public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startElement: " + qName ) ; if ( m_contentHandler != null ) { m_contentHandler . startElement ( uri , localName , qName , atts ) ; } } public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endElement: " + qName ) ; if ( m_contentHandler != null ) { m_contentHandler . endElement ( uri , localName , qName ) ; } } public void characters ( char ch [ ] , int start , int length ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#characters: " + start + ", " + length ) ; if ( m_contentHandler != null ) { m_contentHandler . characters ( ch , start , length ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#ignorableWhitespace: " + start + ", " + length ) ; if ( m_contentHandler != null ) { m_contentHandler . ignorableWhitespace ( ch , start , length ) ; } } public void processingInstruction ( String target , String data ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#processingInstruction: " + target + ", " + data ) ; if ( m_contentHandler != null ) { m_contentHandler . processingInstruction ( target , data ) ; } } public void skippedEntity ( String name ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#skippedEntity: " + name ) ; if ( m_contentHandler != null ) { m_contentHandler . skippedEntity ( name ) ; } } public void warning ( SAXParseException e ) throws SAXException { javax . xml . transform . ErrorListener errorListener = m_transformer . getErrorListener ( ) ; if ( errorListener instanceof ErrorHandler ) { ( ( ErrorHandler ) errorListener ) . warning ( e ) ; } else { try { errorListener . warning ( new javax . xml . transform . TransformerException ( e ) ) ; } catch ( javax . xml . transform . TransformerException te ) { throw e ; } } } public void error ( SAXParseException e ) throws SAXException { javax . xml . transform . ErrorListener errorListener = m_transformer . getErrorListener ( ) ; if ( errorListener instanceof ErrorHandler ) { ( ( ErrorHandler ) errorListener ) . error ( e ) ; if ( null != m_errorHandler ) m_errorHandler . error ( e ) ; } else { try { errorListener . error ( new javax . xml . transform . TransformerException ( e ) ) ; if ( null != m_errorHandler ) m_errorHandler . error ( e ) ; } catch ( javax . xml . transform . TransformerException te ) { throw e ; } } } public void fatalError ( SAXParseException e ) throws SAXException { if ( null != m_errorHandler ) { try { m_errorHandler . fatalError ( e ) ; } catch ( SAXParseException se ) { } } javax . xml . transform . ErrorListener errorListener = m_transformer . getErrorListener ( ) ; if ( errorListener instanceof ErrorHandler ) { ( ( ErrorHandler ) errorListener ) . fatalError ( e ) ; if ( null != m_errorHandler ) m_errorHandler . fatalError ( e ) ; } else { try { errorListener . fatalError ( new javax . xml . transform . TransformerException ( e ) ) ; if ( null != m_errorHandler ) m_errorHandler . fatalError ( e ) ; } catch ( javax . xml . transform . TransformerException te ) { throw e ; } } } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startDTD: " + name + ", " + publicId + ", " + systemId ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startDTD ( name , publicId , systemId ) ; } } public void endDTD ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endDTD" ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . endDTD ( ) ; } } public void startEntity ( String name ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startEntity: " + name ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startEntity ( name ) ; } } public void endEntity ( String name ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endEntity: " + name ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . endEntity ( name ) ; } } public void startCDATA ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startCDATA" ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endCDATA" ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . endCDATA ( ) ; } } public void comment ( char ch [ ] , int start , int length ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#comment: " + start + ", " + length ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . comment ( ch , start , length ) ; } } public void elementDecl ( String name , String model ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#elementDecl: " + name + ", " + model ) ; if ( null != m_declHandler ) { m_declHandler . elementDecl ( name , model ) ; } } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#attributeDecl: " + eName + ", " + aName + ", etc..." ) ; if ( null != m_declHandler ) { m_declHandler . attributeDecl ( eName , aName , type , valueDefault , value ) ; } } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#internalEntityDecl: " + name + ", " + value ) ; if ( null != m_declHandler ) { m_declHandler . internalEntityDecl ( name , value ) ; } } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#externalEntityDecl: " + name + ", " + publicId + ", " + systemId ) ; if ( null != m_declHandler ) { m_declHandler . externalEntityDecl ( name , publicId , systemId ) ; } } private static boolean DEBUG = false ; private TransformerImpl m_transformer ; private String m_baseSystemID ; private Result m_result = null ; private Locator m_locator = null ; private EntityResolver m_entityResolver = null ; private DTDHandler m_dtdHandler = null ; private ContentHandler m_contentHandler = null ; private ErrorHandler m_errorHandler = null ; private LexicalHandler m_lexicalHandler = null ; private DeclHandler m_declHandler = null ; DTM m_dtm ; } 	1	['36', '1', '0', '9', '100', '0', '1', '9', '33', '0.817582418', '914', '0.923076923', '2', '0', '0.176623377', '0', '0', '24.02777778', '7', '1.1944', '1']
