package org . apache . log4j . xml . examples ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . xml . examples . XPriority ; public class XCategory extends Category implements OptionHandler { final private static String FQCN = XCategory . class . getName ( ) ; private static XFactory factory = new XFactory ( ) ; public static final String SUFFIX_OPTION = "Suffix" ; String suffix = "" ; protected XCategory ( String name ) { super ( name ) ; } public void activateOptions ( ) { } public void debug ( String message ) { super . debug ( message + " " + suffix ) ; } public static Category getInstance ( String name ) { return Category . getInstance ( name , factory ) ; } public static Category getInstance ( Class clazz ) { return getInstance ( clazz . getName ( ) , factory ) ; } public String [ ] getOptionStrings ( ) { return ( new String [ ] { SUFFIX_OPTION } ) ; } public void lethal ( String message , Throwable t ) { if ( hierarchy . isDisabled ( XPriority . LETHAL_INT ) ) return ; if ( XPriority . LETHAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , XPriority . LETHAL , message , t ) ; } public void lethal ( String message ) { if ( hierarchy . isDisabled ( XPriority . LETHAL_INT ) ) return ; if ( XPriority . LETHAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , XPriority . LETHAL , message , null ) ; } public void setOption ( String option , String value ) { if ( option == null ) { return ; } if ( option . equalsIgnoreCase ( SUFFIX_OPTION ) ) { this . suffix = value ; LogLog . debug ( "Setting suffix to" + suffix ) ; } } public String getOption ( String option ) { if ( option . equalsIgnoreCase ( SUFFIX_OPTION ) ) { return this . suffix ; } return null ; } public void trace ( String message , Throwable t ) { if ( hierarchy . isDisabled ( XPriority . TRACE_INT ) ) return ; if ( XPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , XPriority . TRACE , message , t ) ; } public void trace ( String message ) { if ( hierarchy . isDisabled ( XPriority . TRACE_INT ) ) return ; if ( XPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( FQCN , this , XPriority . TRACE , message , null ) ) ; } public static class XFactory implements CategoryFactory { public XFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new XCategory ( name ) ; } } } 	1	['14', '2', '0', '9', '33', '53', '1', '9', '11', '0.876923077', '188', '0.4', '1', '0.796610169', '0.442307692', '1', '3', '12.07142857', '3', '1.6429', '1']
package org . apache . log4j . helpers ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . RelativeTimeDateFormat ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . helpers . DateTimeDateFormat ; import org . apache . log4j . helpers . ISO8601DateFormat ; import org . apache . log4j . spi . LoggingEvent ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . TimeZone ; import java . text . FieldPosition ; abstract public class DateLayout extends Layout { public final static String NULL_DATE_FORMAT = "NULL" ; public final static String RELATIVE_TIME_DATE_FORMAT = "RELATIVE" ; protected FieldPosition pos = new FieldPosition ( 0 ) ; final static public String DATE_FORMAT_OPTION = "DateFormat" ; final static public String TIMEZONE_OPTION = "TimeZone" ; private String timeZoneID ; private String dateFormatOption ; protected DateFormat dateFormat ; protected Date date = new Date ( ) ; public String [ ] getOptionStrings ( ) { return new String [ ] { DATE_FORMAT_OPTION , TIMEZONE_OPTION } ; } public void setOption ( String option , String value ) { if ( option . equalsIgnoreCase ( DATE_FORMAT_OPTION ) ) { dateFormatOption = value . toUpperCase ( ) ; } else if ( option . equalsIgnoreCase ( TIMEZONE_OPTION ) ) { timeZoneID = value ; } } public void setDateFormat ( String dateFormat ) { if ( dateFormat != null ) { dateFormatOption = dateFormat . toUpperCase ( ) ; } setDateFormat ( dateFormatOption , TimeZone . getDefault ( ) ) ; } public String getDateFormat ( ) { return dateFormatOption ; } public void setTimeZone ( String timeZone ) { this . timeZoneID = timeZone ; } public String getTimeZone ( ) { return timeZoneID ; } public void activateOptions ( ) { setDateFormat ( dateFormatOption ) ; if ( timeZoneID != null && dateFormat != null ) { dateFormat . setTimeZone ( TimeZone . getTimeZone ( timeZoneID ) ) ; } } public void dateFormat ( StringBuffer buf , LoggingEvent event ) { if ( dateFormat != null ) { date . setTime ( event . timeStamp ) ; dateFormat . format ( date , buf , this . pos ) ; buf . append ( ' ' ) ; } } public void setDateFormat ( DateFormat dateFormat , TimeZone timeZone ) { this . dateFormat = dateFormat ; this . dateFormat . setTimeZone ( timeZone ) ; } public void setDateFormat ( String dateFormatType , TimeZone timeZone ) { if ( dateFormatType == null ) { this . dateFormat = null ; return ; } if ( dateFormatType . equalsIgnoreCase ( NULL_DATE_FORMAT ) ) { this . dateFormat = null ; } else if ( dateFormatType . equalsIgnoreCase ( RELATIVE_TIME_DATE_FORMAT ) ) { this . dateFormat = new RelativeTimeDateFormat ( ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . ABS_TIME_DATE_FORMAT ) ) { this . dateFormat = new AbsoluteTimeDateFormat ( timeZone ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ) { this . dateFormat = new DateTimeDateFormat ( timeZone ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ) ) { this . dateFormat = new ISO8601DateFormat ( timeZone ) ; } else { this . dateFormat = new SimpleDateFormat ( dateFormatType ) ; this . dateFormat . setTimeZone ( timeZone ) ; } } } 	1	['11', '2', '0', '6', '27', '19', '0', '6', '11', '0.911111111', '199', '0.555555556', '0', '0.444444444', '0.303030303', '0', '0', '16.27272727', '7', '2', '1']
package org . apache . log4j ; import org . apache . log4j . Priority ; import org . apache . log4j . Category ; import java . util . Random ; class StressCategory { static Priority [ ] priority = new Priority [ ] { Priority . DEBUG , Priority . INFO , Priority . WARN , Priority . ERROR , Priority . FATAL } ; static Priority defaultPriority = Category . getRoot ( ) . getPriority ( ) ; static int LENGTH ; static String [ ] names ; static Category [ ] cat ; static CT [ ] ct ; static Random random = new Random ( 10 ) ; public static void main ( String [ ] args ) { LENGTH = args . length ; if ( LENGTH == 0 ) { System . err . println ( "Usage: java " + StressCategory . class . getName ( ) + " name1 ... nameN\n." ) ; System . exit ( 1 ) ; } if ( LENGTH >= 7 ) { System . err . println ( "This stress test suffers from combinatorial explosion.\n" + "Invoking with seven arguments takes about 90 minutes even on fast machines" ) ; } names = new String [ LENGTH ] ; for ( int i = 0 ; i < LENGTH ; i ++ ) { names [ i ] = args [ i ] ; } cat = new Category [ LENGTH ] ; ct = new CT [ LENGTH ] ; permute ( 0 ) ; } static void permute ( int n ) { if ( n == LENGTH ) createLoop ( 0 ) ; else for ( int i = n ; i < LENGTH ; i ++ ) { swap ( names , n , i ) ; permute ( n + 1 ) ; swap ( names , n , i ) ; } } static void swap ( String [ ] names , int i , int j ) { String t = names [ i ] ; names [ i ] = names [ j ] ; names [ j ] = t ; } public static void permutationDump ( ) { System . out . print ( "Current permutation is - " ) ; for ( int i = 0 ; i < LENGTH ; i ++ ) { System . out . print ( names [ i ] + " " ) ; } System . out . println ( ) ; } static void createLoop ( int n ) { if ( n == LENGTH ) { for ( int i = 0 ; i < LENGTH ; i ++ ) { if ( ct [ i ] == null ) cat [ i ] = null ; else { cat [ i ] = Category . getInstance ( ct [ i ] . catstr ) ; cat [ i ] . setPriority ( ct [ i ] . priority ) ; } } test ( ) ; Category . defaultHierarchy . clear ( ) ; } else { ct [ n ] = null ; createLoop ( n + 1 ) ; ct [ n ] = new CT ( names [ n ] , null ) ; createLoop ( n + 1 ) ; int r = random . nextInt ( ) ; if ( r < 0 ) r = - r ; ct [ n ] = new CT ( names [ n ] , priority [ r % 5 ] ) ; createLoop ( n + 1 ) ; } } static void test ( ) { for ( int i = 0 ; i < LENGTH ; i ++ ) { if ( ! checkCorrectness ( i ) ) { System . out . println ( "Failed stress test." ) ; permutationDump ( ) ; ctDump ( ) ; catDump ( ) ; System . exit ( 1 ) ; } } } static void ctDump ( ) { for ( int j = 0 ; j < LENGTH ; j ++ ) { if ( ct [ j ] != null ) System . out . println ( "ct [" + j + "] = (" + ct [ j ] . catstr + "," + ct [ j ] . priority + ")" ) ; else System . out . println ( "ct [" + j + "] = undefined" ) ; } } static void catDump ( ) { for ( int j = 0 ; j < LENGTH ; j ++ ) { if ( cat [ j ] != null ) System . out . println ( "cat[" + j + "] = (" + cat [ j ] . name + "," + cat [ j ] . getPriority ( ) + ")" ) ; else System . out . println ( "cat[" + j + "] = undefined" ) ; } } static boolean checkCorrectness ( int i ) { CT localCT = ct [ i ] ; if ( localCT == null ) return true ; Priority expected = getExpectedPrioriy ( localCT ) ; Priority purported = cat [ i ] . getChainedPriority ( ) ; if ( expected != purported ) { System . out . println ( "Expected priority for " + localCT . catstr + " is " + expected ) ; System . out . println ( "Purported priority for " + cat [ i ] . name + " is " + purported ) ; return false ; } return true ; } static Priority getExpectedPrioriy ( CT ctParam ) { Priority priority = ctParam . priority ; if ( priority != null ) return priority ; String catstr = ctParam . catstr ; for ( int i = catstr . lastIndexOf ( '.' , catstr . length ( ) - 1 ) ; i >= 0 ; i = catstr . lastIndexOf ( '.' , i - 1 ) ) { String substr = catstr . substring ( 0 , i ) ; for ( int j = 0 ; j < LENGTH ; j ++ ) { if ( ct [ j ] != null && substr . equals ( ct [ j ] . catstr ) ) { Priority p = ct [ j ] . priority ; if ( p != null ) return p ; } } } return defaultPriority ; } static class CT { public String catstr ; public Priority priority ; CT ( String catstr , Priority priority ) { this . catstr = catstr ; this . priority = priority ; } } } 	1	['13', '1', '0', '4', '40', '8', '0', '4', '2', '0.697916667', '516', '0', '4', '0', '0.15', '0', '0', '38.07692308', '7', '2.7692', '2']
package org . apache . log4j . spi ; import org . apache . log4j . Hierarchy ; import java . net . URL ; public interface Configurator { void doConfigure ( URL url , Hierarchy hierarchy ) ; } 	1	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . log4j . nt ; import org . apache . log4j . * ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . LogLog ; import java . io . * ; public class NTEventLogAppender extends AppenderSkeleton { private int _handle = 0 ; public static final String SOURCE_OPTION = "Source" ; private String source = null ; private String server = null ; private static final int FATAL = Priority . FATAL . toInt ( ) ; private static final int ERROR = Priority . ERROR . toInt ( ) ; private static final int WARN = Priority . WARN . toInt ( ) ; private static final int INFO = Priority . INFO . toInt ( ) ; private static final int DEBUG = Priority . DEBUG . toInt ( ) ; public NTEventLogAppender ( ) { this ( null , null , null ) ; } public NTEventLogAppender ( String source ) { this ( null , source , null ) ; } public NTEventLogAppender ( String server , String source ) { this ( server , source , null ) ; } public NTEventLogAppender ( Layout layout ) { this ( null , null , layout ) ; } public NTEventLogAppender ( String source , Layout layout ) { this ( null , source , layout ) ; } public NTEventLogAppender ( String server , String source , Layout layout ) { if ( source == null ) { source = "Log4j" ; } if ( layout == null ) { this . layout = new TTCCLayout ( ) ; } else { this . layout = layout ; } try { _handle = registerEventSource ( server , source ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; _handle = 0 ; } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { SOURCE_OPTION } ) ; } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( SOURCE_OPTION ) ) { source = value . trim ( ) ; } } public void close ( ) { } public void activateOptions ( ) { if ( source != null ) { try { _handle = registerEventSource ( server , source ) ; } catch ( Exception e ) { LogLog . error ( "Could not register event source." , e ) ; _handle = 0 ; } } } public void append ( LoggingEvent event ) { StringBuffer sbuf = new StringBuffer ( ) ; sbuf . append ( layout . format ( event ) ) ; if ( layout . ignoresThrowable ( ) ) { String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { int len = s . length ; for ( int i = 0 ; i < len ; i ++ ) { sbuf . append ( s [ 0 ] ) ; } } } int nt_category = event . priority . toInt ( ) ; reportEvent ( _handle , sbuf . toString ( ) , nt_category ) ; } public void finalize ( ) { deregisterEventSource ( _handle ) ; _handle = 0 ; } public void setSource ( String source ) { this . source = source . trim ( ) ; } public String getSource ( ) { return source ; } public boolean requiresLayout ( ) { return true ; } native private int registerEventSource ( String server , String source ) ; native private void reportEvent ( int handle , String message , int priority ) ; native private void deregisterEventSource ( int handle ) ; static { System . loadLibrary ( "NTEventLogAppender" ) ; } } 	1	['19', '2', '0', '8', '36', '141', '1', '7', '15', '0.864197531', '229', '0.888888889', '0', '0.6', '0.355555556', '1', '1', '10.57894737', '4', '0.9474', '1']
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . ConsoleAppender ; import org . apache . log4j . Layout ; import org . apache . log4j . Priority ; public class NotLogging { static int runLength ; final static int INITIAL_HASH_SIZE = 101 ; static String SHORT_MSG = "Hello World" ; static Category SHORT_CAT = Category . getInstance ( "A0123456789" ) ; static Category MEDIUM_CAT = Category . getInstance ( "A0123456789.B0123456789" ) ; static Category LONG_CAT = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static Category INEXISTENT_SHORT_CAT = Category . getInstance ( "I0123456789" ) ; static Category INEXISTENT_MEDIUM_CAT = Category . getInstance ( "I0123456789.B0123456789" ) ; static Category INEXISTENT_LONG_CAT = Category . getInstance ( "I0123456789.B0123456789.C0123456789" ) ; static Category [ ] CAT_ARRAY = new Category [ ] { SHORT_CAT , MEDIUM_CAT , LONG_CAT , INEXISTENT_SHORT_CAT , INEXISTENT_MEDIUM_CAT , INEXISTENT_LONG_CAT } ; static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.NotLogging true|false runLength\n" + "true indicates shipped code, false indicates code in development" + "  where runLength is an int representing the run length of loops\n" + "We suggest that runLength be at least 100'000." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length != 2 ) { Usage ( ) ; } ProgramInit ( argv ) ; double delta ; System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = SimpleMessage ( CAT_ARRAY [ i ] , SHORT_MSG , runLength ) ; System . out . println ( "Simple argument,          " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = FullyOptimizedComplexMessage ( CAT_ARRAY [ i ] , runLength ) ; System . out . println ( "Fully optimized complex,  " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = ComplexMessage ( CAT_ARRAY [ i ] , runLength ) ; System . out . println ( "Complex message argument, " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } } static void ProgramInit ( String [ ] args ) { try { runLength = Integer . parseInt ( args [ 1 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } ConsoleAppender appender = new ConsoleAppender ( new SimpleLayout ( ) ) ; if ( "false" . equals ( args [ 0 ] ) ) ; else if ( "true" . equals ( args [ 0 ] ) ) { System . out . println ( "Flagging as shipped code." ) ; Category . getDefaultHierarchy ( ) . disableInfo ( ) ; } else Usage ( ) ; SHORT_CAT . setPriority ( Priority . INFO ) ; Category . getRoot ( ) . setPriority ( Priority . INFO ) ; } static double SimpleMessage ( Category category , String msg , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . debug ( msg ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double FullyOptimizedComplexMessage ( Category category , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { if ( category . isDebugEnabled ( ) ) category . debug ( "Message" + i + " bottles of beer standing on the wall." ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double ComplexMessage ( Category category , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . debug ( "Message" + i + " bottles of beer standing on the wall." ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } } 	1	['8', '1', '0', '6', '31', '22', '0', '6', '2', '0.942857143', '324', '0', '7', '0', '0.285714286', '0', '0', '38.25', '5', '2', '1']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . NDC ; import org . apache . log4j . Priority ; import java . io . IOException ; import java . util . Enumeration ; public class Shallow { static Category cat = Category . getInstance ( Shallow . class ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Shallow . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { if ( configFile . endsWith ( ".xml" ) ) DOMConfigurator . configure ( configFile ) ; else PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; NDC . push ( "NDC" ) ; Category root = Category . getRoot ( ) ; cat . debug ( "Message " + ++ i ) ; root . debug ( "Message " + i ) ; cat . info ( "Message " + ++ i ) ; root . info ( "Message " + i ) ; cat . warn ( "Message " + ++ i ) ; root . warn ( "Message " + i ) ; cat . error ( "Message " + ++ i ) ; root . error ( "Message " + i ) ; cat . log ( Priority . FATAL , "Message " + ++ i ) ; root . log ( Priority . FATAL , "Message " + i ) ; Exception e = new Exception ( "Just testing" ) ; cat . debug ( "Message " + ++ i , e ) ; root . debug ( "Message " + i , e ) ; cat . info ( "Message " + ++ i , e ) ; root . info ( "Message " + i , e ) ; cat . warn ( "Message " + ++ i , e ) ; root . warn ( "Message " + i , e ) ; cat . error ( "Message " + ++ i , e ) ; root . error ( "Message " + i , e ) ; cat . log ( Priority . FATAL , "Message " + ++ i , e ) ; root . log ( Priority . FATAL , "Message " + i , e ) ; Category . shutdown ( ) ; } static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } } 	1	['8', '1', '0', '5', '39', '24', '0', '5', '2', '0.714285714', '328', '0', '1', '0', '0.214285714', '0', '0', '39.75', '2', '1.125', '1']
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . DefaultCategoryFactory ; import org . apache . log4j . config . PropertySetter ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . FileWatchdog ; import java . util . NoSuchElementException ; import java . util . Enumeration ; import java . util . Properties ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . StringTokenizer ; import java . util . Hashtable ; public class PropertyConfigurator extends BasicConfigurator implements Configurator { protected Hashtable registry = new Hashtable ( 11 ) ; protected CategoryFactory categoryFactory = new DefaultCategoryFactory ( ) ; static final String CATEGORY_PREFIX = "log4j.category." ; static final String ADDITIVITY_PREFIX = "log4j.additivity." ; static final String ROOT_CATEGORY_PREFIX = "log4j.rootCategory" ; static final String APPENDER_PREFIX = "log4j.appender." ; static final String RENDERER_PREFIX = "log4j.renderer." ; static final String CATEGORY_FACTORY_KEY = "log4j.categoryFactory" ; static final private String INTERNAL_ROOT_NAME = "root" ; public void doConfigure ( String configFileName , Hierarchy hierarchy ) { Properties props = new Properties ( ) ; try { FileInputStream istream = new FileInputStream ( configFileName ) ; props . load ( istream ) ; istream . close ( ) ; } catch ( IOException e ) { LogLog . error ( "Could not read configuration file [" + configFileName + "]." , e ) ; LogLog . error ( "Ignoring configuration file [" + configFileName + "]." ) ; return ; } doConfigure ( props , hierarchy ) ; } static public void configure ( String configFilename ) { new PropertyConfigurator ( ) . doConfigure ( configFilename , Category . defaultHierarchy ) ; } public static void configure ( java . net . URL configURL ) { new PropertyConfigurator ( ) . doConfigure ( configURL , Category . defaultHierarchy ) ; } static public void configure ( Properties properties ) { new PropertyConfigurator ( ) . doConfigure ( properties , Category . defaultHierarchy ) ; } static public void configureAndWatch ( String configFilename ) { configureAndWatch ( configFilename , FileWatchdog . DEFAULT_DELAY ) ; } static public void configureAndWatch ( String configFilename , long delay ) { PropertyWatchdog pdog = new PropertyWatchdog ( configFilename ) ; pdog . setDelay ( delay ) ; pdog . start ( ) ; } public void doConfigure ( Properties properties , Hierarchy hierarchy ) { String value = properties . getProperty ( LogLog . DEBUG_KEY ) ; if ( value == null ) { value = properties . getProperty ( LogLog . CONFIG_DEBUG_KEY ) ; if ( value != null ) LogLog . warn ( "[log4j.configDebug] is deprecated. Use [log4j.debug] instead." ) ; } if ( value != null ) { LogLog . setInternalDebugging ( OptionConverter . toBoolean ( value , true ) ) ; } String override = properties . getProperty ( BasicConfigurator . DISABLE_OVERRIDE_KEY ) ; hierarchy . overrideAsNeeded ( override ) ; if ( override == null ) { String disableStr = properties . getProperty ( BasicConfigurator . DISABLE_KEY ) ; if ( disableStr != null ) hierarchy . disable ( disableStr ) ; } configureRootCategory ( properties , hierarchy ) ; configureCategoryFactory ( properties ) ; parseCatsAndRenderers ( properties , hierarchy ) ; LogLog . debug ( "Finished configuring." ) ; registry . clear ( ) ; } public void doConfigure ( java . net . URL configURL , Hierarchy hierarchy ) { Properties props = new Properties ( ) ; LogLog . debug ( "Reading configuration from URL " + configURL ) ; try { props . load ( configURL . openStream ( ) ) ; } catch ( java . io . IOException e ) { LogLog . error ( "Could not read configuration file from URL [" + configURL + "]." , e ) ; LogLog . error ( "Ignoring configuration file [" + configURL + "]." ) ; return ; } doConfigure ( props , hierarchy ) ; } void configureCategoryFactory ( Properties props ) { String factoryClassName = OptionConverter . findAndSubst ( CATEGORY_FACTORY_KEY , props ) ; if ( factoryClassName != null ) { LogLog . debug ( "Setting category factory to [" + factoryClassName + "]." ) ; categoryFactory = ( CategoryFactory ) OptionConverter . instantiateByClassName ( factoryClassName , CategoryFactory . class , categoryFactory ) ; } } void configureRootCategory ( Properties props , Hierarchy hierarchy ) { String value = OptionConverter . findAndSubst ( ROOT_CATEGORY_PREFIX , props ) ; if ( value == null ) LogLog . debug ( "Could not find root category information. Is this OK?" ) ; else { Category root = hierarchy . getRoot ( ) ; synchronized ( root ) { parseCategory ( props , root , ROOT_CATEGORY_PREFIX , INTERNAL_ROOT_NAME , value ) ; } } } protected void parseCatsAndRenderers ( Properties props , Hierarchy hierarchy ) { Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; if ( key . startsWith ( CATEGORY_PREFIX ) ) { String categoryName = key . substring ( CATEGORY_PREFIX . length ( ) ) ; String value = OptionConverter . findAndSubst ( key , props ) ; Category cat = hierarchy . getInstance ( categoryName , categoryFactory ) ; synchronized ( cat ) { parseCategory ( props , cat , key , categoryName , value ) ; parseAdditivityForCategory ( props , cat , categoryName ) ; } } else if ( key . startsWith ( RENDERER_PREFIX ) ) { String renderedClass = key . substring ( RENDERER_PREFIX . length ( ) ) ; String renderingClass = OptionConverter . findAndSubst ( key , props ) ; addRenderer ( hierarchy , renderedClass , renderingClass ) ; } } } void parseAdditivityForCategory ( Properties props , Category cat , String categoryName ) { String value = OptionConverter . findAndSubst ( ADDITIVITY_PREFIX + categoryName , props ) ; LogLog . debug ( "Handling " + ADDITIVITY_PREFIX + categoryName + "=[" + value + "]" ) ; if ( ( value != null ) && ( ! value . equals ( "" ) ) ) { boolean additivity = OptionConverter . toBoolean ( value , true ) ; LogLog . debug ( "Setting additivity for \"" + categoryName + "\" to " + additivity ) ; cat . setAdditivity ( additivity ) ; } } void parseCategory ( Properties props , Category cat , String optionKey , String catName , String value ) { LogLog . debug ( "Parsing for [" + catName + "] with value=[" + value + "]." ) ; StringTokenizer st = new StringTokenizer ( value , "," ) ; if ( ! ( value . startsWith ( "," ) || value . equals ( "" ) ) ) { if ( ! st . hasMoreTokens ( ) ) return ; String priorityStr = st . nextToken ( ) ; LogLog . debug ( "Priority token is [" + priorityStr + "]." ) ; if ( priorityStr . equalsIgnoreCase ( BasicConfigurator . INHERITED ) && ! catName . equals ( INTERNAL_ROOT_NAME ) ) cat . setPriority ( null ) ; else cat . setPriority ( Priority . toPriority ( priorityStr ) ) ; LogLog . debug ( "Category " + catName + " set to " + cat . getPriority ( ) ) ; } cat . removeAllAppenders ( ) ; Appender appender ; String appenderName ; while ( st . hasMoreTokens ( ) ) { appenderName = st . nextToken ( ) . trim ( ) ; if ( appenderName == null || appenderName . equals ( "," ) ) continue ; LogLog . debug ( "Parsing appender named \"" + appenderName + "\"." ) ; appender = parseAppender ( props , appenderName ) ; if ( appender != null ) { cat . addAppender ( appender ) ; } } } Appender parseAppender ( Properties props , String appenderName ) { Appender appender = registryGet ( appenderName ) ; if ( ( appender != null ) ) { LogLog . debug ( "Appender \"" + appenderName + "\" was already parsed." ) ; return appender ; } String prefix = APPENDER_PREFIX + appenderName ; String layoutPrefix = prefix + ".layout" ; appender = ( Appender ) OptionConverter . instantiateByKey ( props , prefix , org . apache . log4j . Appender . class , null ) ; if ( appender == null ) { LogLog . error ( "Could not instantiate appender named \"" + appenderName + "\"." ) ; return null ; } appender . setName ( appenderName ) ; if ( appender instanceof OptionHandler ) { if ( appender . requiresLayout ( ) ) { Layout layout = ( Layout ) OptionConverter . instantiateByKey ( props , layoutPrefix , Layout . class , null ) ; if ( layout != null ) { appender . setLayout ( layout ) ; LogLog . debug ( "Parsing layout options for \"" + appenderName + "\"." ) ; PropertySetter . setProperties ( layout , props , layoutPrefix + "." ) ; LogLog . debug ( "End of parsing for \"" + appenderName + "\"." ) ; } } PropertySetter . setProperties ( appender , props , prefix + "." ) ; LogLog . debug ( "Parsed \"" + appenderName + "\" options." ) ; } registryPut ( appender ) ; return appender ; } void registryPut ( Appender appender ) { registry . put ( appender . getName ( ) , appender ) ; } Appender registryGet ( String name ) { return ( Appender ) registry . get ( name ) ; } } class PropertyWatchdog extends FileWatchdog { PropertyWatchdog ( String filename ) { super ( filename ) ; } public void doOnChange ( ) { new PropertyConfigurator ( ) . doConfigure ( filename , Category . defaultHierarchy ) ; } } 	1	['18', '2', '0', '28', '78', '135', '14', '15', '9', '0.93627451', '714', '0.25', '1', '0.413793103', '0.277777778', '1', '1', '38', '10', '2.5', '6']
package org . apache . log4j ; public class Priority { int level ; String levelStr ; int syslogEquivalent ; public final static int FATAL_INT = 50000 ; public final static int ERROR_INT = 40000 ; public final static int WARN_INT = 30000 ; public final static int INFO_INT = 20000 ; public final static int DEBUG_INT = 10000 ; final static public Priority FATAL = new Priority ( FATAL_INT , "FATAL" , 0 ) ; final static public Priority ERROR = new Priority ( ERROR_INT , "ERROR" , 3 ) ; final static public Priority WARN = new Priority ( WARN_INT , "WARN" , 4 ) ; final static public Priority INFO = new Priority ( INFO_INT , "INFO" , 6 ) ; final static public Priority DEBUG = new Priority ( DEBUG_INT , "DEBUG" , 7 ) ; protected Priority ( int level , String levelStr , int syslogEquivalent ) { this . level = level ; this . levelStr = levelStr ; this . syslogEquivalent = syslogEquivalent ; } public final int getSyslogEquivalent ( ) { return syslogEquivalent ; } final public String toString ( ) { return levelStr ; } public final int toInt ( ) { return level ; } public boolean isGreaterOrEqual ( Priority r ) { return level >= r . level ; } public static Priority [ ] getAllPossiblePriorities ( ) { return new Priority [ ] { Priority . FATAL , Priority . ERROR , Priority . WARN , Priority . INFO , Priority . DEBUG } ; } public static Priority toPriority ( String sArg ) { return toPriority ( sArg , Priority . DEBUG ) ; } public static Priority toPriority ( int val ) { return toPriority ( val , Priority . DEBUG ) ; } public static Priority toPriority ( int val , Priority defaultPriority ) { switch ( val ) { case DEBUG_INT : return DEBUG ; case INFO_INT : return INFO ; case WARN_INT : return WARN ; case ERROR_INT : return ERROR ; case FATAL_INT : return FATAL ; default : return defaultPriority ; } } public static Priority toPriority ( String sArg , Priority defaultPriority ) { if ( sArg == null ) return defaultPriority ; String s = sArg . toUpperCase ( ) ; if ( s . equals ( "DEBUG" ) ) return Priority . DEBUG ; if ( s . equals ( "INFO" ) ) return Priority . INFO ; if ( s . equals ( "WARN" ) ) return Priority . WARN ; if ( s . equals ( "ERROR" ) ) return Priority . ERROR ; if ( s . equals ( "FATAL" ) ) return Priority . FATAL ; return defaultPriority ; } } 	1	['11', '1', '0', '31', '14', '15', '31', '0', '9', '0.792307692', '174', '0', '5', '0', '0.35', '0', '0', '13.63636364', '7', '2', '5']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import org . apache . log4j . helpers . LogLog ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . lang . reflect . Method ; import java . io . ObjectOutputStream ; import java . io . ObjectInputStream ; import java . util . Hashtable ; public class LoggingEvent implements java . io . Serializable { private static long startTime = System . currentTimeMillis ( ) ; transient public final String fqnOfCategoryClass ; transient public Category category ; public final String categoryName ; transient public Priority priority ; private String ndc ; private boolean ndcLookupRequired = true ; transient private Object message ; private String renderedMessage ; private String threadName ; private ThrowableInformation throwableInfo ; public final long timeStamp ; private LocationInfo locationInfo ; static final long serialVersionUID = - 868428216207166145L ; static final Integer [ ] PARAM_ARRAY = new Integer [ 1 ] ; static final String TO_PRIORITY = "toPriority" ; static final Class [ ] TO_PRIORITY_PARAMS = new Class [ ] { int . class } ; static final Hashtable methodCache = new Hashtable ( 3 ) ; public LoggingEvent ( String fqnOfCategoryClass , Category category , Priority priority , Object message , Throwable throwable ) { this . fqnOfCategoryClass = fqnOfCategoryClass ; this . category = category ; this . categoryName = category . getName ( ) ; this . priority = priority ; this . message = message ; if ( throwable != null ) { this . throwableInfo = new ThrowableInformation ( throwable ) ; } timeStamp = System . currentTimeMillis ( ) ; } public LocationInfo getLocationInformation ( ) { if ( locationInfo == null ) { locationInfo = new LocationInfo ( new Throwable ( ) , fqnOfCategoryClass ) ; } return locationInfo ; } public Object getMessage ( ) { if ( message != null ) { return message ; } else { return getRenderedMessage ( ) ; } } public String getNDC ( ) { if ( ndcLookupRequired ) { ndcLookupRequired = false ; ndc = NDC . get ( ) ; } return ndc ; } public String getRenderedMessage ( ) { if ( renderedMessage == null && message != null ) { if ( message instanceof String ) renderedMessage = ( String ) message ; else { renderedMessage = category . getHierarchy ( ) . getRendererMap ( ) . findAndRender ( message ) ; } } return renderedMessage ; } public static long getStartTime ( ) { return startTime ; } public String getThreadName ( ) { if ( threadName == null ) threadName = ( Thread . currentThread ( ) ) . getName ( ) ; return threadName ; } public ThrowableInformation getThrowableInformation ( ) { return throwableInfo ; } public String [ ] getThrowableStrRep ( ) { if ( throwableInfo == null ) return null ; else return throwableInfo . getThrowableStrRep ( ) ; } private void readPriority ( ObjectInputStream ois ) throws java . io . IOException , ClassNotFoundException { int p = ois . readInt ( ) ; try { String className = ( String ) ois . readObject ( ) ; if ( className == null ) { priority = Priority . toPriority ( p ) ; } else { Method m = ( Method ) methodCache . get ( className ) ; if ( m == null ) { Class clazz = Class . forName ( className ) ; m = clazz . getDeclaredMethod ( TO_PRIORITY , TO_PRIORITY_PARAMS ) ; methodCache . put ( className , m ) ; } PARAM_ARRAY [ 0 ] = new Integer ( p ) ; priority = ( Priority ) m . invoke ( null , PARAM_ARRAY ) ; } } catch ( Exception e ) { LogLog . warn ( "Priority deserialization failed, reverting to default." , e ) ; priority = Priority . toPriority ( p ) ; } } private void readObject ( ObjectInputStream ois ) throws java . io . IOException , ClassNotFoundException { ois . defaultReadObject ( ) ; readPriority ( ois ) ; if ( locationInfo == null ) locationInfo = new LocationInfo ( null , null ) ; } private void writeObject ( ObjectOutputStream oos ) throws java . io . IOException { this . getThreadName ( ) ; this . getRenderedMessage ( ) ; this . getNDC ( ) ; this . getThrowableStrRep ( ) ; oos . defaultWriteObject ( ) ; writePriority ( oos ) ; } private void writePriority ( ObjectOutputStream oos ) throws java . io . IOException { oos . writeInt ( priority . toInt ( ) ) ; Class clazz = priority . getClass ( ) ; if ( clazz == Priority . class ) { oos . writeObject ( null ) ; } else { oos . writeObject ( clazz . getName ( ) ) ; } } } 	1	['15', '1', '0', '42', '48', '77', '35', '8', '9', '0.898496241', '304', '0.421052632', '4', '0', '0.196428571', '0', '0', '18', '4', '1.4', '4']
package org . apache . log4j . helpers ; import java . net . URL ; public class Loader { static String TSTR = "Caught Exception while in Loader.getResource. This may be innocuous." ; static public URL getResource ( String resource , Class clazz ) { URL url = null ; LogLog . debug ( "Trying to find [" + resource + "] using Class.getResource()." ) ; try { url = clazz . getResource ( resource ) ; if ( url != null ) return url ; } catch ( Throwable t ) { LogLog . warn ( TSTR , t ) ; } String fullyQualified = resolveName ( resource , clazz ) ; LogLog . debug ( "Trying to find [" + fullyQualified + "] using ClassLoader.getSystemResource()." ) ; url = ClassLoader . getSystemResource ( fullyQualified ) ; if ( url != null ) return url ; ClassLoader loader = clazz . getClassLoader ( ) ; if ( loader != null ) { try { LogLog . debug ( "Trying to find [" + resource + "] using " + loader + " class loader." ) ; url = loader . getResource ( resource ) ; if ( url != null ) return url ; } catch ( Throwable t ) { LogLog . warn ( TSTR , t ) ; } } LogLog . debug ( "Trying to find [" + resource + "] using ClassLoader.getSystemResource()." ) ; url = ClassLoader . getSystemResource ( resource ) ; return url ; } static String resolveName ( String resource , Class clazz ) { String fqcn = clazz . getName ( ) ; int index = fqcn . lastIndexOf ( '.' ) ; if ( index != - 1 ) { fqcn = fqcn . substring ( 0 , index ) . replace ( '.' , '/' ) ; resource = fqcn + "/" + resource ; } return resource ; } } 	1	['4', '1', '0', '2', '19', '4', '1', '1', '2', '0.666666667', '139', '0', '0', '0', '0.555555556', '0', '0', '33.5', '3', '1.25', '1']
package org . apache . log4j . test ; import java . util . Properties ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . ConsoleAppender ; public class SysoutConfigurator implements Configurator { public void doConfigure ( java . net . URL url , Hierarchy hierarchy ) { Category . getRoot ( ) . addAppender ( new ConsoleAppender ( new SimpleLayout ( ) , ConsoleAppender . SYSTEM_OUT ) ) ; } } 	1	['2', '1', '0', '7', '7', '1', '0', '7', '2', '2', '15', '0', '0', '0', '0.666666667', '0', '0', '6.5', '1', '0.5', '1']
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . BoundedFIFO ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . helpers . AppenderAttachableImpl ; import org . apache . log4j . helpers . LogLog ; import java . util . Enumeration ; public class AsyncAppender extends AppenderSkeleton implements AppenderAttachable { public static final String LOCATION_INFO_OPTION = "LocationInfo" ; public static final String BUFFER_SIZE_OPTION = "BufferSize" ; public static final int DEFAULT_BUFFER_SIZE = 128 ; BoundedFIFO bf = new BoundedFIFO ( DEFAULT_BUFFER_SIZE ) ; AppenderAttachableImpl aai ; Dispatcher dispatcher ; boolean locationInfo = false ; boolean interruptedWarningMessage = false ; public AsyncAppender ( ) { aai = new AppenderAttachableImpl ( ) ; dispatcher = new Dispatcher ( bf , this ) ; dispatcher . start ( ) ; } public void addAppender ( Appender newAppender ) { synchronized ( aai ) { aai . addAppender ( newAppender ) ; } } public void append ( LoggingEvent event ) { event . getNDC ( ) ; event . getThreadName ( ) ; if ( locationInfo ) { event . getLocationInformation ( ) ; } synchronized ( bf ) { while ( bf . isFull ( ) ) { try { bf . wait ( ) ; } catch ( InterruptedException e ) { if ( ! interruptedWarningMessage ) { interruptedWarningMessage = true ; LogLog . warn ( "AsyncAppender interrupted." , e ) ; } else { LogLog . warn ( "AsyncAppender interrupted again." ) ; } } } bf . put ( event ) ; if ( bf . wasEmpty ( ) ) { bf . notify ( ) ; } } } public void close ( ) { synchronized ( this ) { if ( closed ) return ; closed = true ; } dispatcher . close ( ) ; try { dispatcher . join ( ) ; } catch ( InterruptedException e ) { LogLog . error ( "Got an InterruptedException while waiting for the " + "dispatcher to finish." , e ) ; } dispatcher = null ; bf = null ; } public Enumeration getAllAppenders ( ) { synchronized ( aai ) { return aai . getAllAppenders ( ) ; } } public Appender getAppender ( String name ) { synchronized ( aai ) { return aai . getAppender ( name ) ; } } public boolean getLocationInfo ( ) { return locationInfo ; } public boolean requiresLayout ( ) { return false ; } public void removeAllAppenders ( ) { synchronized ( aai ) { aai . removeAllAppenders ( ) ; } } public void removeAppender ( Appender appender ) { synchronized ( aai ) { aai . removeAppender ( appender ) ; } } public void removeAppender ( String name ) { synchronized ( aai ) { aai . removeAppender ( name ) ; } } public void setLocationInfo ( boolean flag ) { locationInfo = flag ; } public void setBufferSize ( int size ) { bf . resize ( size ) ; } public int getBufferSize ( ) { return bf . getMaxSize ( ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { LOCATION_INFO_OPTION , BUFFER_SIZE_OPTION } ) ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; else if ( option . equals ( BUFFER_SIZE_OPTION ) ) { int newSize = OptionConverter . toInt ( value , DEFAULT_BUFFER_SIZE ) ; bf . resize ( newSize ) ; } } } class Dispatcher extends Thread { BoundedFIFO bf ; AppenderAttachableImpl aai ; boolean interrupted = false ; AsyncAppender container ; Dispatcher ( BoundedFIFO bf , AsyncAppender container ) { this . bf = bf ; this . container = container ; this . aai = container . aai ; this . setPriority ( Thread . MIN_PRIORITY ) ; this . setName ( "Dispatcher-" + getName ( ) ) ; } void close ( ) { synchronized ( bf ) { interrupted = true ; if ( bf . length ( ) == 0 ) { bf . notify ( ) ; } } } public void run ( ) { LoggingEvent event ; while ( true ) { synchronized ( bf ) { if ( bf . length ( ) == 0 ) { if ( interrupted ) { return ; } try { bf . wait ( ) ; } catch ( InterruptedException e ) { LogLog . error ( "The dispathcer should not be interrupted." ) ; break ; } } event = bf . get ( ) ; if ( bf . wasFull ( ) ) { bf . notify ( ) ; } } synchronized ( container . aai ) { if ( aai != null && event != null ) { aai . appendLoopOnAppenders ( event ) ; } } } } } 	1	['16', '2', '0', '10', '48', '34', '1', '10', '16', '0.883333333', '320', '0', '3', '0.545454545', '0.25', '2', '3', '18.5', '5', '1.4375', '5']
package org . apache . log4j . net ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . IOException ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; public class SimpleSocketServer { static Category cat = Category . getInstance ( SimpleSocketServer . class . getName ( ) ) ; static int port ; public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; try { cat . info ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { cat . info ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; cat . info ( "Connected to client at " + socket . getInetAddress ( ) ) ; cat . info ( "Starting new socket node." ) ; new Thread ( new SocketNode ( socket , Category . getDefaultHierarchy ( ) ) ) . start ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SimpleSocketServer . class . getName ( ) + " port configFile" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; } } 	1	['6', '1', '0', '4', '30', '9', '0', '4', '2', '0.666666667', '144', '0', '1', '0', '0.333333333', '0', '0', '22.5', '2', '1', '1']
package org . apache . log4j . net ; import java . net . InetAddress ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . InputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; public class SocketNode implements Runnable { Socket socket ; Hierarchy hierarchy ; ObjectInputStream ois ; static Category cat = Category . getInstance ( SocketNode . class . getName ( ) ) ; public SocketNode ( Socket socket , Hierarchy hierarchy ) { this . socket = socket ; this . hierarchy = hierarchy ; try { ois = new ObjectInputStream ( socket . getInputStream ( ) ) ; } catch ( Exception e ) { cat . error ( "Could not open ObjectInputStream to " + socket , e ) ; } } public void run ( ) { LoggingEvent event ; Category remoteCategory ; try { while ( true ) { event = ( LoggingEvent ) ois . readObject ( ) ; remoteCategory = hierarchy . getInstance ( event . categoryName ) ; event . category = remoteCategory ; if ( event . priority . isGreaterOrEqual ( remoteCategory . getChainedPriority ( ) ) ) { remoteCategory . callAppenders ( event ) ; } } } catch ( java . io . EOFException e ) { cat . info ( "Caught java.io.EOFException closing conneciton." ) ; } catch ( java . net . SocketException e ) { cat . info ( "Caught java.net.SocketException closing conneciton." ) ; } catch ( Exception e ) { cat . error ( "Unexpected exception. Closing conneciton." , e ) ; } try { ois . close ( ) ; } catch ( Exception e ) { cat . info ( "Could not close connection." , e ) ; } } } 	1	['4', '1', '0', '7', '25', '0', '3', '4', '2', '0.733333333', '109', '0', '2', '0', '0.416666667', '0', '0', '25', '2', '0.75', '3']
package org . apache . log4j . net ; import java . net . Socket ; import java . net . ServerSocket ; import java . net . InetAddress ; import java . net . MalformedURLException ; import java . io . IOException ; import java . io . File ; import java . util . Hashtable ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . Priority ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . spi . RootCategory ; public class SocketServer { static String GENERIC = "generic" ; static String CONFIG_FILE_EXT = ".lcf" ; static Category cat = Category . getInstance ( SocketServer . class ) ; static SocketServer server ; static int port ; Hashtable hierarchyMap ; Hierarchy genericHierarchy ; File dir ; public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] ) ; else usage ( "Wrong number of arguments." ) ; try { cat . info ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { cat . info ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; InetAddress inetAddress = socket . getInetAddress ( ) ; cat . info ( "Connected to client at " + inetAddress ) ; Hierarchy h = ( Hierarchy ) server . hierarchyMap . get ( inetAddress ) ; if ( h == null ) { h = server . configureHierarchy ( inetAddress ) ; } cat . info ( "Starting new socket node." ) ; new Thread ( new SocketNode ( socket , h ) ) . start ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SocketServer . class . getName ( ) + " port configFile directory" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile , String dirStr ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; File dir = new File ( dirStr ) ; if ( ! dir . isDirectory ( ) ) { usage ( "[" + dirStr + "] is not a directory." ) ; } server = new SocketServer ( dir ) ; } public SocketServer ( File directory ) { this . dir = directory ; hierarchyMap = new Hashtable ( 11 ) ; } Hierarchy configureHierarchy ( InetAddress inetAddress ) { cat . info ( "Locating configuration file for " + inetAddress ) ; String s = inetAddress . toString ( ) ; int i = s . indexOf ( "/" ) ; if ( i == - 1 ) { cat . warn ( "Could not parse the inetAddress [" + inetAddress + "]. Using default hierarchy." ) ; return genericHierarchy ( ) ; } else { String key = s . substring ( 0 , i ) ; File configFile = new File ( dir , key + CONFIG_FILE_EXT ) ; if ( configFile . exists ( ) ) { Hierarchy h = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; hierarchyMap . put ( inetAddress , h ) ; new PropertyConfigurator ( ) . doConfigure ( configFile . getAbsolutePath ( ) , h ) ; return h ; } else { cat . warn ( "Could not find config file [" + configFile + "]." ) ; return genericHierarchy ( ) ; } } } Hierarchy genericHierarchy ( ) { if ( genericHierarchy == null ) { File f = new File ( dir , GENERIC + CONFIG_FILE_EXT ) ; if ( f . exists ( ) ) { genericHierarchy = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; new PropertyConfigurator ( ) . doConfigure ( f . getAbsolutePath ( ) , genericHierarchy ) ; } else { cat . warn ( "Could not find config file [" + f + "]. Will use the default hierarchy." ) ; genericHierarchy = Category . getDefaultHierarchy ( ) ; } } return genericHierarchy ; } } 	1	['8', '1', '0', '6', '48', '6', '0', '6', '2', '0.666666667', '356', '0', '3', '0', '0.257142857', '0', '0', '42.375', '3', '1.75', '1']
package org . apache . log4j . config ; import java . beans . Introspector ; import java . beans . PropertyDescriptor ; import java . beans . BeanInfo ; import java . beans . IntrospectionException ; import java . io . * ; import java . lang . reflect . * ; import java . util . * ; import org . apache . log4j . * ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . spi . OptionHandler ; public class PropertySetter { protected Object obj ; protected PropertyDescriptor [ ] props ; public PropertySetter ( Object obj ) { this . obj = obj ; } protected void introspect ( ) { try { BeanInfo bi = Introspector . getBeanInfo ( obj . getClass ( ) ) ; props = bi . getPropertyDescriptors ( ) ; } catch ( IntrospectionException ex ) { LogLog . error ( "Failed to introspect " + obj + ": " + ex . getMessage ( ) ) ; props = new PropertyDescriptor [ 0 ] ; } } public static void setProperties ( Object obj , Properties properties , String prefix ) { new PropertySetter ( obj ) . setProperties ( properties , prefix ) ; } public void setProperties ( Properties properties , String prefix ) { int len = prefix . length ( ) ; for ( Enumeration e = properties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . startsWith ( prefix ) ) { if ( key . indexOf ( '.' , len + 1 ) > 0 ) { continue ; } String value = OptionConverter . findAndSubst ( key , properties ) ; key = key . substring ( len ) ; if ( "layout" . equals ( key ) && obj instanceof Appender ) { continue ; } setProperty ( key , value ) ; } } activate ( ) ; } public void setProperty ( String name , String value ) { if ( value == null ) return ; name = Introspector . decapitalize ( name ) ; PropertyDescriptor prop = getPropertyDescriptor ( name ) ; if ( prop == null ) { LogLog . warn ( "No such property [" + name + "] in " + obj . getClass ( ) . getName ( ) + "." ) ; } else { try { setProperty ( prop , name , value ) ; } catch ( PropertySetterException ex ) { LogLog . warn ( "Failed to set property " + name + " to value \"" + value + "\". " + ex . getMessage ( ) ) ; } } } public void setProperty ( PropertyDescriptor prop , String name , String value ) throws PropertySetterException { Method setter = prop . getWriteMethod ( ) ; if ( setter == null ) { throw new PropertySetterException ( "No setter for property" ) ; } Class [ ] paramTypes = setter . getParameterTypes ( ) ; if ( paramTypes . length != 1 ) { throw new PropertySetterException ( "#params for setter != 1" ) ; } Object arg ; try { arg = convertArg ( value , paramTypes [ 0 ] ) ; } catch ( Throwable t ) { throw new PropertySetterException ( "Conversion to type [" + paramTypes [ 0 ] + "] failed. Reason: " + t ) ; } if ( arg == null ) { throw new PropertySetterException ( "Conversion to type [" + paramTypes [ 0 ] + "] failed." ) ; } LogLog . debug ( "Setting property [" + name + "] to [" + arg + "]." ) ; try { setter . invoke ( obj , new Object [ ] { arg } ) ; } catch ( Exception ex ) { throw new PropertySetterException ( ex ) ; } } protected Object convertArg ( String val , Class type ) { if ( val == null ) return null ; String v = val . trim ( ) ; if ( String . class . isAssignableFrom ( type ) ) { return val ; } else if ( Integer . TYPE . isAssignableFrom ( type ) ) { return new Integer ( v ) ; } else if ( Long . TYPE . isAssignableFrom ( type ) ) { return new Long ( v ) ; } else if ( Boolean . TYPE . isAssignableFrom ( type ) ) { if ( "true" . equalsIgnoreCase ( v ) ) { return Boolean . TRUE ; } else if ( "false" . equalsIgnoreCase ( v ) ) { return Boolean . FALSE ; } } else if ( Priority . class . isAssignableFrom ( type ) ) { return OptionConverter . toPriority ( v , null ) ; } return null ; } protected PropertyDescriptor getPropertyDescriptor ( String name ) { if ( props == null ) introspect ( ) ; for ( int i = 0 ; i < props . length ; i ++ ) { if ( name . equals ( props [ i ] . getName ( ) ) ) { return props [ i ] ; } } return null ; } public void activate ( ) { if ( obj instanceof OptionHandler ) { ( ( OptionHandler ) obj ) . activateOptions ( ) ; } } } 	1	['10', '1', '0', '7', '49', '13', '1', '6', '6', '0.694444444', '386', '0.5', '0', '0', '0.35', '0', '0', '37.2', '11', '2.9', '2']
package org . apache . log4j . net ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . DatagramPacket ; import java . net . UnknownHostException ; import java . net . SocketException ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . SyslogWriter ; import org . apache . log4j . helpers . SyslogQuietWriter ; public class SyslogAppender extends AppenderSkeleton { final static public int LOG_KERN = 0 ; final static public int LOG_USER = 1 << 3 ; final static public int LOG_MAIL = 2 << 3 ; final static public int LOG_DAEMON = 3 << 3 ; final static public int LOG_AUTH = 4 << 3 ; final static public int LOG_SYSLOG = 5 << 3 ; final static public int LOG_LPR = 6 << 3 ; final static public int LOG_NEWS = 7 << 3 ; final static public int LOG_UUCP = 8 << 3 ; final static public int LOG_CRON = 9 << 3 ; final static public int LOG_AUTHPRIV = 10 << 3 ; final static public int LOG_FTP = 11 << 3 ; final static public int LOG_LOCAL0 = 16 << 3 ; final static public int LOG_LOCAL1 = 17 << 3 ; final static public int LOG_LOCAL2 = 18 << 3 ; final static public int LOG_LOCAL3 = 19 << 3 ; final static public int LOG_LOCAL4 = 20 << 3 ; final static public int LOG_LOCAL5 = 21 << 3 ; final static public int LOG_LOCAL6 = 22 << 3 ; final static public int LOG_LOCAL7 = 23 << 3 ; public static final String SYSLOG_HOST_OPTION = "SyslogHost" ; public static final String FACILITY_OPTION = "Facility" ; public static final String FACILITY_PRINTING_OPTION = "FacilityPrinting" ; protected static final int SYSLOG_HOST_OI = 0 ; protected static final int FACILITY_OI = 1 ; static final String TAB = "    " ; int syslogFacility = LOG_USER ; String facilityStr ; boolean facilityPrinting = false ; SyslogQuietWriter sqw ; String syslogHost ; public SyslogAppender ( ) { this . initSyslogFacilityStr ( ) ; } public SyslogAppender ( Layout layout , int syslogFacility ) { this . layout = layout ; this . syslogFacility = syslogFacility ; this . initSyslogFacilityStr ( ) ; } public SyslogAppender ( Layout layout , String syslogHost , int syslogFacility ) { this ( layout , syslogFacility ) ; setSyslogHost ( syslogHost ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { SYSLOG_HOST_OPTION , FACILITY_OPTION , FACILITY_PRINTING_OPTION } ) ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( SYSLOG_HOST_OPTION ) ) this . setSyslogHost ( value ) ; else if ( option . equals ( FACILITY_PRINTING_OPTION ) ) facilityPrinting = OptionConverter . toBoolean ( value , facilityPrinting ) ; else if ( option . equals ( FACILITY_OPTION ) ) { this . setFacility ( value ) ; } } synchronized public void close ( ) { closed = true ; sqw = null ; } private void initSyslogFacilityStr ( ) { facilityStr = getFacilityString ( this . syslogFacility ) ; if ( facilityStr == null ) { System . err . println ( "\"" + syslogFacility + "\" is an unknown syslog facility. Defaulting to \"USER\"." ) ; this . syslogFacility = LOG_USER ; facilityStr = "user:" ; } else { facilityStr += ":" ; } } public static String getFacilityString ( int syslogFacility ) { switch ( syslogFacility ) { case LOG_KERN : return "kern" ; case LOG_USER : return "user" ; case LOG_MAIL : return "mail" ; case LOG_DAEMON : return "daemon" ; case LOG_AUTH : return "auth" ; case LOG_SYSLOG : return "syslog" ; case LOG_LPR : return "lpr" ; case LOG_NEWS : return "news" ; case LOG_UUCP : return "uucp" ; case LOG_CRON : return "cron" ; case LOG_AUTHPRIV : return "authpriv" ; case LOG_FTP : return "ftp" ; case LOG_LOCAL0 : return "local0" ; case LOG_LOCAL1 : return "local1" ; case LOG_LOCAL2 : return "local2" ; case LOG_LOCAL3 : return "local3" ; case LOG_LOCAL4 : return "local4" ; case LOG_LOCAL5 : return "local5" ; case LOG_LOCAL6 : return "local6" ; case LOG_LOCAL7 : return "local7" ; default : return null ; } } public static int getFacility ( String facilityName ) { if ( facilityName != null ) { facilityName = facilityName . trim ( ) ; } if ( "KERN" . equalsIgnoreCase ( facilityName ) ) { return LOG_KERN ; } else if ( "USER" . equalsIgnoreCase ( facilityName ) ) { return LOG_USER ; } else if ( "MAIL" . equalsIgnoreCase ( facilityName ) ) { return LOG_MAIL ; } else if ( "DAEMON" . equalsIgnoreCase ( facilityName ) ) { return LOG_DAEMON ; } else if ( "AUTH" . equalsIgnoreCase ( facilityName ) ) { return LOG_AUTH ; } else if ( "SYSLOG" . equalsIgnoreCase ( facilityName ) ) { return LOG_SYSLOG ; } else if ( "LPR" . equalsIgnoreCase ( facilityName ) ) { return LOG_LPR ; } else if ( "NEWS" . equalsIgnoreCase ( facilityName ) ) { return LOG_NEWS ; } else if ( "UUCP" . equalsIgnoreCase ( facilityName ) ) { return LOG_UUCP ; } else if ( "CRON" . equalsIgnoreCase ( facilityName ) ) { return LOG_CRON ; } else if ( "AUTHPRIV" . equalsIgnoreCase ( facilityName ) ) { return LOG_AUTHPRIV ; } else if ( "FTP" . equalsIgnoreCase ( facilityName ) ) { return LOG_FTP ; } else if ( "LOCAL0" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL0 ; } else if ( "LOCAL1" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL1 ; } else if ( "LOCAL2" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL2 ; } else if ( "LOCAL3" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL3 ; } else if ( "LOCAL4" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL4 ; } else if ( "LOCAL5" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL5 ; } else if ( "LOCAL6" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL6 ; } else if ( "LOCAL7" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL7 ; } else { return - 1 ; } } public void append ( LoggingEvent event ) { if ( ! isAsSevereAsThreshold ( event . priority ) ) return ; if ( sqw == null ) { errorHandler . error ( "No syslog host is set for SyslogAppedender named \"" + this . name + "\"." ) ; return ; } String buffer = ( facilityPrinting ? facilityStr : "" ) + layout . format ( event ) ; sqw . setPriority ( event . priority . getSyslogEquivalent ( ) ) ; sqw . write ( buffer ) ; String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { int len = s . length ; if ( len > 0 ) { sqw . write ( s [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { sqw . write ( TAB + s [ i ] . substring ( 1 ) ) ; } } } } public void activateOptions ( ) { } public boolean requiresLayout ( ) { return true ; } public void setSyslogHost ( String syslogHost ) { this . sqw = new SyslogQuietWriter ( new SyslogWriter ( syslogHost ) , syslogFacility , errorHandler ) ; this . syslogHost = syslogHost ; } public String getSyslogHost ( ) { return syslogHost ; } public void setFacility ( String facilityName ) { if ( facilityName == null ) return ; syslogFacility = getFacility ( facilityName ) ; if ( syslogFacility == - 1 ) { System . err . println ( "[" + facilityName + "] is an unknown syslog facility. Defaulting to [USER]." ) ; syslogFacility = LOG_USER ; } this . initSyslogFacilityStr ( ) ; if ( sqw != null ) { sqw . setSyslogFacility ( this . syslogFacility ) ; } } public String getFacility ( ) { return getFacilityString ( syslogFacility ) ; } public void setFacilityPrinting ( boolean on ) { facilityPrinting = on ; } public boolean getFacilityPrinting ( ) { return facilityPrinting ; } } 	1	['18', '2', '0', '8', '42', '81', '0', '8', '17', '1', '517', '0.064516129', '1', '0.545454545', '0.259259259', '2', '4', '26', '22', '3.9444', '1']
package org . apache . log4j ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . log4j . helpers . LogLog ; public class NDC { static Hashtable ht = new Hashtable ( ) ; static int pushCounter = 0 ; static final int REAP_THRESHOLD = 5 ; private NDC ( ) { } public static void clear ( ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack != null ) stack . setSize ( 0 ) ; } public static Stack cloneStack ( ) { Object o = ht . get ( Thread . currentThread ( ) ) ; if ( o == null ) return null ; else { Stack stack = ( Stack ) o ; return ( Stack ) stack . clone ( ) ; } } public static void inherit ( Stack stack ) { if ( stack != null ) ht . put ( Thread . currentThread ( ) , stack ) ; } static public String get ( ) { Stack s = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( s != null && ! s . isEmpty ( ) ) return ( ( DiagnosticContext ) s . peek ( ) ) . fullMessage ; else return null ; } public static int getDepth ( ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack == null ) return 0 ; else return stack . size ( ) ; } private static void lazyRemove ( ) { Vector v ; synchronized ( ht ) { if ( ++ pushCounter >= REAP_THRESHOLD ) { return ; } else { pushCounter = 0 ; } int misses = 0 ; v = new Vector ( ) ; Enumeration enum = ht . keys ( ) ; while ( enum . hasMoreElements ( ) && ( misses <= 4 ) ) { Thread t = ( Thread ) enum . nextElement ( ) ; if ( t . isAlive ( ) ) { misses ++ ; } else { misses = 0 ; v . addElement ( t ) ; } } } int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Thread t = ( Thread ) v . elementAt ( i ) ; LogLog . debug ( "Lazy NDC removal for thread [" + t . getName ( ) + "] (" + ht . size ( ) + ")." ) ; ht . remove ( t ) ; } } public static String pop ( ) { Thread key = Thread . currentThread ( ) ; Stack stack = ( Stack ) ht . get ( key ) ; if ( stack != null && ! stack . isEmpty ( ) ) return ( ( DiagnosticContext ) stack . pop ( ) ) . message ; else return "" ; } public static void push ( String message ) { Thread key = Thread . currentThread ( ) ; Stack stack = ( Stack ) ht . get ( key ) ; if ( stack == null ) { DiagnosticContext dc = new DiagnosticContext ( message , null ) ; stack = new Stack ( ) ; ht . put ( key , stack ) ; stack . push ( dc ) ; } else if ( stack . isEmpty ( ) ) { DiagnosticContext dc = new DiagnosticContext ( message , null ) ; stack . push ( dc ) ; } else { DiagnosticContext parent = ( DiagnosticContext ) stack . peek ( ) ; stack . push ( new DiagnosticContext ( message , parent ) ) ; } } static public void remove ( ) { ht . remove ( Thread . currentThread ( ) ) ; lazyRemove ( ) ; } static public void setMaxDepth ( int maxDepth ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack != null && maxDepth < stack . size ( ) ) stack . setSize ( maxDepth ) ; } private static class DiagnosticContext { String fullMessage ; String message ; DiagnosticContext ( String message , DiagnosticContext parent ) { this . message = message ; if ( parent != null ) { fullMessage = parent . fullMessage + ' ' + message ; } else { fullMessage = message ; } } } } 	1	['12', '1', '0', '12', '41', '0', '10', '2', '9', '0.666666667', '275', '0', '0', '0', '0.090909091', '0', '0', '21.66666667', '6', '2.25', '2']
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . NDC ; import org . apache . log4j . helpers . PatternParser ; import org . apache . log4j . helpers . PatternConverter ; import org . apache . log4j . helpers . OptionConverter ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . TimeZone ; import java . util . Vector ; import java . text . FieldPosition ; public class PatternLayout extends Layout { final static public String CONVERSION_PATTERN_OPTION = "ConversionPattern" ; public final static String DEFAULT_CONVERSION_PATTERN = "%m%n" ; public final static String TTCC_CONVERSION_PATTERN = "%r [%t] %p %c %x - %m%n" ; protected final int BUF_SIZE = 256 ; protected final int MAX_CAPACITY = 1024 ; private StringBuffer sbuf = new StringBuffer ( BUF_SIZE ) ; private String pattern ; private PatternConverter head ; private String timezone ; public PatternLayout ( ) { this ( DEFAULT_CONVERSION_PATTERN ) ; } public PatternLayout ( String pattern ) { this . pattern = pattern ; head = createPatternParser ( ( pattern == null ) ? DEFAULT_CONVERSION_PATTERN : pattern ) . parse ( ) ; } public String [ ] getOptionStrings ( ) { return new String [ ] { CONVERSION_PATTERN_OPTION } ; } public void setOption ( String option , String value ) { if ( value == null ) return ; if ( option . equalsIgnoreCase ( CONVERSION_PATTERN_OPTION ) ) { pattern = value ; head = createPatternParser ( value ) . parse ( ) ; } } public void setConversionPattern ( String conversionPattern ) { pattern = conversionPattern ; head = createPatternParser ( conversionPattern ) . parse ( ) ; } public String getConversionPattern ( ) { return pattern ; } public void activateOptions ( ) { } public boolean ignoresThrowable ( ) { return true ; } protected PatternParser createPatternParser ( String pattern ) { return new PatternParser ( pattern ) ; } public String format ( LoggingEvent event ) { if ( sbuf . capacity ( ) > MAX_CAPACITY ) { sbuf = new StringBuffer ( BUF_SIZE ) ; } else { sbuf . setLength ( 0 ) ; } PatternConverter c = head ; while ( c != null ) { c . format ( sbuf , event ) ; c = c . next ; } return sbuf . toString ( ) ; } } 	1	['10', '2', '0', '7', '19', '27', '3', '4', '9', '0.901234568', '130', '0.666666667', '1', '0.5', '0.5', '0', '0', '11.1', '3', '1.2', '1']
package org . apache . log4j ; import java . util . Hashtable ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . log4j . spi . RootCategory ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; public class Hierarchy { static final int DISABLE_OFF = - 1 ; static final int DISABLE_OVERRIDE = - 2 ; static private CategoryFactory defaultFactory = new DefaultCategoryFactory ( ) ; Hashtable ht ; Category root ; RendererMap rendererMap ; int disable ; boolean emittedNoAppenderWarning = false ; boolean emittedNoResourceBundleWarning = false ; public Hierarchy ( Category root ) { ht = new Hashtable ( ) ; this . root = root ; disable = DISABLE_OFF ; this . root . setHierarchy ( this ) ; rendererMap = new RendererMap ( ) ; } public void addRenderer ( Class classToRender , ObjectRenderer or ) { rendererMap . put ( classToRender , or ) ; } public void clear ( ) { ht . clear ( ) ; } public Category exists ( String name ) { Object o = ht . get ( new CategoryKey ( name ) ) ; if ( o instanceof Category ) { return ( Category ) o ; } else { return null ; } } public void disable ( String priorityStr ) { if ( disable != DISABLE_OVERRIDE ) { Priority p = Priority . toPriority ( priorityStr , null ) ; if ( p != null ) { disable = p . level ; } else { LogLog . warn ( "Could not convert [" + priorityStr + "] to Priority." ) ; } } } public void disable ( Priority p ) { if ( ( disable != DISABLE_OVERRIDE ) && ( p != null ) ) { disable = p . level ; } } public void disableAll ( ) { disable ( Priority . FATAL ) ; } public void disableDebug ( ) { disable ( Priority . DEBUG ) ; } public void disableInfo ( ) { disable ( Priority . INFO ) ; } public void enableAll ( ) { disable = DISABLE_OFF ; } public void overrideAsNeeded ( String override ) { if ( override != null ) { LogLog . debug ( "Handling non-null disable override directive: \"" + override + "\"." ) ; if ( OptionConverter . toBoolean ( override , true ) ) { LogLog . debug ( "Overriding all disable methods." ) ; disable = DISABLE_OVERRIDE ; } } } public Category getInstance ( String name ) { return getInstance ( name , defaultFactory ) ; } public Category getInstance ( String name , CategoryFactory factory ) { CategoryKey key = new CategoryKey ( name ) ; Category category ; synchronized ( ht ) { Object o = ht . get ( key ) ; if ( o == null ) { category = factory . makeNewCategoryInstance ( name ) ; category . setHierarchy ( this ) ; ht . put ( key , category ) ; updateParents ( category ) ; return category ; } else if ( o instanceof Category ) { return ( Category ) o ; } else if ( o instanceof ProvisionNode ) { category = factory . makeNewCategoryInstance ( name ) ; category . setHierarchy ( this ) ; ht . put ( key , category ) ; updateChildren ( ( ProvisionNode ) o , category ) ; updateParents ( category ) ; return category ; } else { return null ; } } } public Enumeration getCurrentCategories ( ) { Vector v = new Vector ( ht . size ( ) ) ; Enumeration elems = ht . elements ( ) ; while ( elems . hasMoreElements ( ) ) { Object o = elems . nextElement ( ) ; if ( o instanceof Category ) { v . addElement ( o ) ; } } return v . elements ( ) ; } public boolean isDisabled ( int level ) { return disable >= level ; } public RendererMap getRendererMap ( ) { return rendererMap ; } public Category getRoot ( ) { return root ; } public void resetConfiguration ( ) { getRoot ( ) . setPriority ( Priority . DEBUG ) ; root . setResourceBundle ( null ) ; disable = Hierarchy . DISABLE_OFF ; synchronized ( ht ) { shutdown ( ) ; Enumeration cats = getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . setPriority ( null ) ; c . setAdditivity ( true ) ; c . setResourceBundle ( null ) ; } } rendererMap . clear ( ) ; } public void setDisableOverride ( String override ) { if ( OptionConverter . toBoolean ( override , true ) ) { LogLog . debug ( "Overriding disable." ) ; disable = DISABLE_OVERRIDE ; } } public void shutdown ( ) { Category root = getRoot ( ) ; root . closeNestedAppenders ( ) ; synchronized ( ht ) { Enumeration cats = this . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . closeNestedAppenders ( ) ; } root . removeAllAppenders ( ) ; cats = this . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . removeAllAppenders ( ) ; } } } final private void updateParents ( Category cat ) { String name = cat . name ; int length = name . length ( ) ; boolean parentFound = false ; for ( int i = name . lastIndexOf ( '.' , length - 1 ) ; i >= 0 ; i = name . lastIndexOf ( '.' , i - 1 ) ) { String substr = name . substring ( 0 , i ) ; CategoryKey key = new CategoryKey ( substr ) ; Object o = ht . get ( key ) ; if ( o == null ) { ProvisionNode pn = new ProvisionNode ( cat ) ; ht . put ( key , pn ) ; } else if ( o instanceof Category ) { parentFound = true ; cat . parent = ( Category ) o ; break ; } else if ( o instanceof ProvisionNode ) { ( ( ProvisionNode ) o ) . addElement ( cat ) ; } else { Exception e = new IllegalStateException ( "unexpected object type " + o . getClass ( ) + " in ht." ) ; e . printStackTrace ( ) ; } } if ( ! parentFound ) cat . parent = root ; } final private void updateChildren ( ProvisionNode pn , Category cat ) { final int last = pn . size ( ) ; for ( int i = 0 ; i < last ; i ++ ) { Category c = ( Category ) pn . elementAt ( i ) ; if ( ! c . parent . name . startsWith ( cat . name ) ) { cat . parent = c . parent ; c . parent = cat ; } } } } 	1	['23', '1', '0', '23', '65', '125', '15', '10', '20', '0.873737374', '530', '0.111111111', '3', '0', '0.186868687', '0', '0', '21.65217391', '6', '1.913', '3']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . Layout ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . CyclicBuffer ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . TriggeringEventEvaluator ; import java . util . Properties ; import java . util . Date ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . internet . MimeMessage ; import javax . mail . Multipart ; import javax . mail . internet . MimeMultipart ; import javax . mail . internet . MimeBodyPart ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . AddressException ; import javax . mail . internet . MimeUtility ; public class SMTPAppender extends AppenderSkeleton { String to ; String from ; String subject ; String smtpHost ; int bufferSize = 512 ; CyclicBuffer cb = new CyclicBuffer ( bufferSize ) ; Session session ; Message msg ; boolean locationInfo = false ; public static final String TO_OPTION = "To" ; public static final String FROM_OPTION = "From" ; public static final String SUBJECT_OPTION = "Subject" ; public static final String SMTP_HOST_OPTION = "SMTPHost" ; public static final String BUFFER_SIZE_OPTION = "BufferSize" ; public static final String EVALUATOR_CLASS_OPTION = "EvaluatorClass" ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; protected TriggeringEventEvaluator evaluator ; public SMTPAppender ( ) { this ( new DefaultEvaluator ( ) ) ; } public SMTPAppender ( TriggeringEventEvaluator evaluator ) { this . evaluator = evaluator ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { TO_OPTION , FROM_OPTION , SUBJECT_OPTION , SMTP_HOST_OPTION , BUFFER_SIZE_OPTION , EVALUATOR_CLASS_OPTION , LOCATION_INFO_OPTION } ) ; } public void activateOptions ( ) { Properties props = System . getProperties ( ) ; if ( smtpHost != null ) props . put ( "mail.smtp.host" , smtpHost ) ; session = Session . getDefaultInstance ( props , null ) ; msg = new MimeMessage ( session ) ; try { if ( from != null ) msg . setFrom ( getAddress ( from ) ) ; else msg . setFrom ( ) ; msg . setRecipients ( Message . RecipientType . TO , parseAddress ( to ) ) ; if ( subject != null ) msg . setSubject ( subject ) ; } catch ( MessagingException e ) { LogLog . error ( "Could not activate SMTPAppender options." , e ) ; } } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } event . getThreadName ( ) ; event . getNDC ( ) ; if ( locationInfo ) { event . getLocationInformation ( ) ; } cb . add ( event ) ; if ( evaluator . isTriggeringEvent ( event ) ) { sendBuffer ( ) ; } } protected boolean checkEntryConditions ( ) { if ( this . msg == null ) { errorHandler . error ( "Message object not configured." ) ; return false ; } if ( this . evaluator == null ) { errorHandler . error ( "No TriggeringEventEvaluator is set for appender [" + name + "]." ) ; return false ; } if ( this . layout == null ) { errorHandler . error ( "No layout set for appender named [" + name + "]." ) ; return false ; } return true ; } synchronized public void close ( ) { this . closed = true ; } InternetAddress getAddress ( String addressStr ) { try { return new InternetAddress ( addressStr ) ; } catch ( AddressException e ) { errorHandler . error ( "Could not parse address [" + addressStr + "]." , e , ErrorCode . ADDRESS_PARSE_FAILURE ) ; return null ; } } InternetAddress [ ] parseAddress ( String addressStr ) { try { return InternetAddress . parse ( addressStr , true ) ; } catch ( AddressException e ) { errorHandler . error ( "Could not parse address [" + addressStr + "]." , e , ErrorCode . ADDRESS_PARSE_FAILURE ) ; return null ; } } public String getTo ( ) { return to ; } public boolean requiresLayout ( ) { return true ; } protected void sendBuffer ( ) { try { MimeBodyPart part = new MimeBodyPart ( ) ; StringBuffer sbuf = new StringBuffer ( ) ; String t = layout . getHeader ( ) ; if ( t != null ) sbuf . append ( t ) ; int len = cb . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { LoggingEvent event = cb . get ( ) ; sbuf . append ( layout . format ( event ) ) ; if ( layout . ignoresThrowable ( ) ) { String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { for ( int j = 0 ; j < s . length ; j ++ ) { sbuf . append ( s [ j ] ) ; } } } } t = layout . getFooter ( ) ; if ( t != null ) sbuf . append ( t ) ; part . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; Multipart mp = new MimeMultipart ( ) ; mp . addBodyPart ( part ) ; msg . setContent ( mp ) ; msg . setSentDate ( new Date ( ) ) ; Transport . send ( msg ) ; } catch ( Exception e ) { LogLog . error ( "Error occured while sending e-mail notification." , e ) ; } } public String getEvaluatorClass ( ) { return evaluator == null ? null : evaluator . getClass ( ) . getName ( ) ; } public String getFrom ( ) { return from ; } public String getSubject ( ) { return subject ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( TO_OPTION ) ) to = value ; else if ( option . equals ( FROM_OPTION ) ) from = value ; else if ( option . equals ( SMTP_HOST_OPTION ) ) smtpHost = value ; else if ( option . equals ( SUBJECT_OPTION ) ) subject = value ; else if ( option . equals ( EVALUATOR_CLASS_OPTION ) ) { evaluator = ( TriggeringEventEvaluator ) OptionConverter . instantiateByClassName ( value , TriggeringEventEvaluator . class , evaluator ) ; } else if ( option . equals ( BUFFER_SIZE_OPTION ) ) { bufferSize = OptionConverter . toInt ( value , bufferSize ) ; cb . resize ( bufferSize ) ; } else if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } public void setFrom ( String from ) { this . from = from ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setBufferSize ( int bufferSize ) { this . bufferSize = bufferSize ; cb . resize ( bufferSize ) ; } public void setSMTPHost ( String smtpHost ) { this . smtpHost = smtpHost ; } public String getSMTPHost ( ) { return smtpHost ; } public void setTo ( String to ) { this . to = to ; } public int getBufferSize ( ) { return bufferSize ; } public void setEvaluatorClass ( String value ) { evaluator = ( TriggeringEventEvaluator ) OptionConverter . instantiateByClassName ( value , TriggeringEventEvaluator . class , evaluator ) ; } public void setLocationInfo ( boolean locationInfo ) { this . locationInfo = locationInfo ; } public boolean getLocationInfo ( ) { return locationInfo ; } } class DefaultEvaluator implements TriggeringEventEvaluator { public boolean isTriggeringEvent ( LoggingEvent event ) { return event . priority . isGreaterOrEqual ( Priority . ERROR ) ; } } 	1	['27', '2', '0', '10', '80', '239', '0', '10', '22', '0.938034188', '565', '0.055555556', '2', '0.418604651', '0.240740741', '2', '3', '19.25925926', '10', '1.8519', '3']
package org . apache . log4j . config ; import java . beans . * ; import java . io . * ; import java . lang . reflect . * ; import java . util . * ; import org . apache . log4j . Appender ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; public class PropertyGetter { protected static final Object [ ] NULL_ARG = new Object [ ] { } ; protected Object obj ; protected PropertyDescriptor [ ] props ; public interface PropertyCallback { void foundProperty ( Object obj , String prefix , String name , Object value ) ; } public PropertyGetter ( Object obj ) throws IntrospectionException { BeanInfo bi = Introspector . getBeanInfo ( obj . getClass ( ) ) ; props = bi . getPropertyDescriptors ( ) ; this . obj = obj ; } public static void getProperties ( Object obj , PropertyCallback callback , String prefix ) { try { new PropertyGetter ( obj ) . getProperties ( callback , prefix ) ; } catch ( IntrospectionException ex ) { LogLog . error ( "Failed to introspect object " + obj , ex ) ; } } public void getProperties ( PropertyCallback callback , String prefix ) { for ( int i = 0 ; i < props . length ; i ++ ) { Method getter = props [ i ] . getReadMethod ( ) ; if ( getter == null ) continue ; if ( ! isHandledType ( getter . getReturnType ( ) ) ) { continue ; } String name = props [ i ] . getName ( ) ; try { Object result = getter . invoke ( obj , NULL_ARG ) ; if ( result != null ) { callback . foundProperty ( obj , prefix , name , result ) ; } } catch ( Exception ex ) { LogLog . warn ( "Failed to get value of property " + name ) ; } } } protected boolean isHandledType ( Class type ) { return String . class . isAssignableFrom ( type ) || Integer . TYPE . isAssignableFrom ( type ) || Long . TYPE . isAssignableFrom ( type ) || Boolean . TYPE . isAssignableFrom ( type ) || Priority . class . isAssignableFrom ( type ) ; } } 	1	['6', '1', '0', '3', '25', '11', '1', '2', '3', '0.68', '154', '0.6', '0', '0', '0.44', '0', '0', '23.83333333', '8', '2.3333', '1']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . or . MessageRenderer ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . helpers . LogLog ; import javax . jms . * ; import javax . naming . InitialContext ; import javax . naming . Context ; import javax . naming . NameNotFoundException ; import javax . naming . NamingException ; public class JMSSink { static public void main ( String [ ] args ) { if ( args . length != 3 ) { usage ( "Wrong number of arguments." ) ; } String tcfBindingName = args [ 0 ] ; String topicBindingName = args [ 1 ] ; PropertyConfigurator . configure ( args [ 2 ] ) ; Category . getDefaultHierarchy ( ) . addRenderer ( Message . class , new MessageRenderer ( ) ) ; try { Context ctx = new InitialContext ( ) ; TopicConnectionFactory topicConnectionFactory ; topicConnectionFactory = ( TopicConnectionFactory ) lookup ( ctx , tcfBindingName ) ; TopicConnection topicConnection = topicConnectionFactory . createTopicConnection ( ) ; topicConnection . start ( ) ; TopicSession topicSession = topicConnection . createTopicSession ( false , Session . AUTO_ACKNOWLEDGE ) ; Topic topic = ( Topic ) ctx . lookup ( topicBindingName ) ; TopicSubscriber topicSubscriber = topicSession . createDurableSubscriber ( topic , "x" ) ; LoggingEvent event ; Category remoteCategory ; while ( true ) { ObjectMessage msg = ( ObjectMessage ) topicSubscriber . receive ( ) ; event = ( LoggingEvent ) msg . getObject ( ) ; remoteCategory = Category . getInstance ( event . categoryName ) ; remoteCategory . callAppenders ( event ) ; } } catch ( Exception e ) { LogLog . error ( "Could not read JMS message." , e ) ; } } protected static Object lookup ( Context ctx , String name ) throws NamingException { try { return ctx . lookup ( name ) ; } catch ( NameNotFoundException e ) { LogLog . error ( "Could not find name [" + name + "]." ) ; throw e ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + JMSSink . class . getName ( ) + " TopicConnectionFactoryBindingName TopicBindingName configFile" ) ; System . exit ( 1 ) ; } } 	1	['5', '1', '0', '7', '31', '10', '0', '7', '2', '0.875', '145', '0', '0', '0', '0.3', '0', '0', '27.6', '3', '1.4', '3']
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SyslogAppender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . FileAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . NDC ; import org . apache . log4j . performance . NOPWriter ; import java . util . Enumeration ; public class Logging { static int runLength ; static int delay = - 1 ; static int burstLen = 100 ; static int DELAY_MULT = 1000 / burstLen ; static Category cat = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Logging . class . getName ( ) + " confFile runLength [delay] [burstLen]\n" + "        confFile is an XML configuration file and\n" + "        runLength (integer) is the length of test loop.\n" + "        delay is the time in millisecs to wait every bustLen log requests." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] , null , null ) ; else if ( argv . length == 4 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] , argv [ 3 ] ) ; else Usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; double delta ; String msg = "ABCDEGHIJKLMNOPQRSTUVWXYZabcdeghijklmnopqrstuvwxyz1234567890" ; if ( delay <= 0 ) delta = NoDelayLoop ( cat , msg ) ; else delta = DelayedLoop ( cat , msg ) ; System . out . print ( ( int ) delta ) ; Category . shutdown ( ) ; } static void init ( String configFile , String runLengthStr , String delayStr , String burstLenStr ) { try { runLength = Integer . parseInt ( runLengthStr ) ; if ( delayStr != null ) { delay = Integer . parseInt ( delayStr ) ; } if ( delayStr != null ) { burstLen = Integer . parseInt ( burstLenStr ) ; DELAY_MULT = 1000 / burstLen ; } } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; } DOMConfigurator . configure ( configFile ) ; } static double NoDelayLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; } return ( ( System . currentTimeMillis ( ) - before ) * 1000.0 ) / runLength ; } static double DelayedLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; int j = 0 ; Thread currentThread = Thread . currentThread ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; if ( j ++ == burstLen ) { j = 0 ; try { currentThread . sleep ( delay ) ; } catch ( Exception e ) { } } } double actualTime = ( ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ) ; System . out . println ( "actual time: " + actualTime ) ; return ( actualTime - delay * DELAY_MULT ) ; } } 	1	['8', '1', '0', '3', '30', '12', '0', '3', '2', '0.666666667', '228', '0', '1', '0', '0.321428571', '0', '0', '26.75', '4', '1.75', '1']
package org . apache . log4j . helpers ; import java . util . Properties ; import java . net . URL ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . PropertyConfigurator ; public class OptionConverter { static String DELIM_START = "${" ; static char DELIM_STOP = '}' ; static int DELIM_START_LEN = 2 ; static int DELIM_STOP_LEN = 1 ; static StringBuffer sbuf = new StringBuffer ( ) ; private OptionConverter ( ) { } public static String [ ] concatanateArrays ( String [ ] l , String [ ] r ) { int len = l . length + r . length ; String [ ] a = new String [ len ] ; System . arraycopy ( l , 0 , a , 0 , l . length ) ; System . arraycopy ( r , 0 , a , l . length , r . length ) ; return a ; } public static String convertSpecialChars ( String s ) { char c ; int len = s . length ( ) ; StringBuffer sbuf = new StringBuffer ( len ) ; int i = 0 ; while ( i < len ) { c = s . charAt ( i ++ ) ; if ( c == '\\' ) { c = s . charAt ( i ++ ) ; if ( c == 'n' ) c = '\n' ; else if ( c == 'r' ) c = '\r' ; else if ( c == 't' ) c = '\t' ; else if ( c == 'f' ) c = '\f' ; else if ( c == '\b' ) c = '\b' ; else if ( c == '\"' ) c = '\"' ; else if ( c == '\'' ) c = '\'' ; else if ( c == '\\' ) c = '\\' ; } sbuf . append ( c ) ; } return sbuf . toString ( ) ; } public static String getSystemProperty ( String key , String def ) { try { return System . getProperty ( key , def ) ; } catch ( Throwable e ) { LogLog . debug ( "Was not allowed to read system property \"" + key + "\"." ) ; return def ; } } public static Object instantiateByKey ( Properties props , String key , Class superClass , Object defaultValue ) { String className = findAndSubst ( key , props ) ; if ( className == null ) { LogLog . error ( "Could not find value for key " + key ) ; return defaultValue ; } return OptionConverter . instantiateByClassName ( className . trim ( ) , superClass , defaultValue ) ; } public static boolean toBoolean ( String value , boolean dEfault ) { if ( value == null ) return dEfault ; String trimmedVal = value . trim ( ) ; if ( "true" . equalsIgnoreCase ( trimmedVal ) ) return true ; if ( "false" . equalsIgnoreCase ( trimmedVal ) ) return false ; return dEfault ; } public static int toInt ( String value , int dEfault ) { if ( value != null ) { String s = value . trim ( ) ; try { return Integer . valueOf ( s ) . intValue ( ) ; } catch ( NumberFormatException e ) { LogLog . error ( "[" + s + "] is not in proper int form." ) ; e . printStackTrace ( ) ; } } return dEfault ; } public static Priority toPriority ( String value , Priority defaultValue ) { if ( value == null ) return defaultValue ; int hashIndex = value . indexOf ( '#' ) ; if ( hashIndex == - 1 ) { return Priority . toPriority ( value , defaultValue ) ; } Priority result = defaultValue ; String clazz = value . substring ( hashIndex + 1 ) ; String priorityName = value . substring ( 0 , hashIndex ) ; LogLog . debug ( "toPriority" + ":class=[" + clazz + "]" + ":pri=[" + priorityName + "]" ) ; try { Class customPriority = Class . forName ( clazz ) ; Class [ ] paramTypes = new Class [ ] { String . class , org . apache . log4j . Priority . class } ; java . lang . reflect . Method toPriorityMethod = customPriority . getMethod ( "toPriority" , paramTypes ) ; Object [ ] params = new Object [ ] { priorityName , defaultValue } ; Object o = toPriorityMethod . invoke ( null , params ) ; result = ( Priority ) o ; } catch ( ClassNotFoundException e ) { LogLog . warn ( "custom priority class [" + clazz + "] not found." ) ; } catch ( NoSuchMethodException e ) { LogLog . warn ( "custom priority class [" + clazz + "]" + " does not have a constructor which takes one string parameter" , e ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { LogLog . warn ( "custom priority class [" + clazz + "]" + " could not be instantiated" , e ) ; } catch ( ClassCastException e ) { LogLog . warn ( "class [" + clazz + "] is not a subclass of org.apache.log4j.Priority" , e ) ; } catch ( IllegalAccessException e ) { LogLog . warn ( "class [" + clazz + "] cannot be instantiated due to access restrictions" , e ) ; } catch ( Exception e ) { LogLog . warn ( "class [" + clazz + "], priority [" + priorityName + "] conversion failed." , e ) ; } return result ; } public static long toFileSize ( String value , long dEfault ) { if ( value == null ) return dEfault ; String s = value . trim ( ) . toUpperCase ( ) ; long multiplier = 1 ; int index ; if ( ( index = s . indexOf ( "KB" ) ) != - 1 ) { multiplier = 1024 ; s = s . substring ( 0 , index ) ; } else if ( ( index = s . indexOf ( "MB" ) ) != - 1 ) { multiplier = 1024 * 1024 ; s = s . substring ( 0 , index ) ; } else if ( ( index = s . indexOf ( "GB" ) ) != - 1 ) { multiplier = 1024 * 1024 * 1024 ; s = s . substring ( 0 , index ) ; } if ( s != null ) { try { return Long . valueOf ( s ) . longValue ( ) * multiplier ; } catch ( NumberFormatException e ) { LogLog . error ( "[" + s + "] is not in proper int form." ) ; LogLog . error ( "[" + value + "] not in expected format." , e ) ; } } return dEfault ; } public static String findAndSubst ( String key , Properties props ) { String value = props . getProperty ( key ) ; if ( value == null ) return null ; try { return substVars ( value , props ) ; } catch ( IllegalArgumentException e ) { LogLog . error ( "Bad option value [" + value + "]." , e ) ; return value ; } } public static Object instantiateByClassName ( String className , Class superClass , Object defaultValue ) { if ( className != null ) { try { Class classObj = Class . forName ( className ) ; if ( ! superClass . isAssignableFrom ( classObj ) ) { LogLog . error ( "A \"" + className + "\" object is not assignable to a \"" + superClass . getName ( ) + "\" variable." ) ; return defaultValue ; } return classObj . newInstance ( ) ; } catch ( Exception e ) { LogLog . error ( "Could not instantiate class [" + className + "]." , e ) ; } } return defaultValue ; } public static String substVars ( String val , Properties props ) throws IllegalArgumentException { sbuf . setLength ( 0 ) ; int i = 0 ; int j , k ; while ( true ) { j = val . indexOf ( DELIM_START , i ) ; if ( j == - 1 ) { if ( i == 0 ) return val ; else { sbuf . append ( val . substring ( i , val . length ( ) ) ) ; return sbuf . toString ( ) ; } } else { sbuf . append ( val . substring ( i , j ) ) ; k = val . indexOf ( DELIM_STOP , j ) ; if ( k == - 1 ) { throw new IllegalArgumentException ( '"' + val + "\" has no closing brace. Opening brace at position " + j + '.' ) ; } else { j += DELIM_START_LEN ; String key = val . substring ( j , k ) ; String replacement = getSystemProperty ( key , null ) ; if ( replacement == null && props != null ) { replacement = props . getProperty ( key ) ; } if ( replacement != null ) sbuf . append ( replacement ) ; i = k + DELIM_STOP_LEN ; } } } } static public void selectAndConfigure ( URL url , Hierarchy hierarchy ) { String clazz = url . getRef ( ) ; Configurator configurator = null ; if ( clazz != null ) { LogLog . debug ( "Preferred configurator class: " + clazz ) ; configurator = ( Configurator ) instantiateByClassName ( clazz , Configurator . class , null ) ; if ( configurator == null ) { LogLog . error ( "Could not instantiate configurator [" + clazz + "]." ) ; return ; } } else { String filename = url . getFile ( ) ; if ( filename != null && filename . endsWith ( ".xml" ) ) { try { configurator = new DOMConfigurator ( ) ; } catch ( NoClassDefFoundError e ) { LogLog . warn ( "Could not find DOMConfigurator!" , e ) ; return ; } } else { configurator = new PropertyConfigurator ( ) ; } } configurator . doConfigure ( url , hierarchy ) ; } } 	1	['15', '1', '0', '20', '63', '103', '17', '6', '12', '0.910714286', '757', '0', '0', '0', '0.154761905', '0', '0', '48.93333333', '11', '3', '3']
package org . apache . log4j . spi ; import java . io . Writer ; import java . io . PrintWriter ; import java . util . Vector ; public class ThrowableInformation implements java . io . Serializable { private transient Throwable throwable ; private String [ ] rep ; static private VectorWriter vw = new VectorWriter ( ) ; public ThrowableInformation ( Throwable throwable ) { this . throwable = throwable ; } public Throwable getThrowable ( ) { return throwable ; } public String [ ] getThrowableStrRep ( ) { if ( rep != null ) { return ( String [ ] ) rep . clone ( ) ; } else { throwable . printStackTrace ( vw ) ; rep = vw . toStringArray ( ) ; vw . clear ( ) ; return rep ; } } } class VectorWriter extends PrintWriter { private Vector v ; VectorWriter ( ) { super ( new NullWriter ( ) ) ; v = new Vector ( ) ; } public void println ( Object o ) { v . addElement ( o . toString ( ) ) ; } public void println ( char [ ] s ) { v . addElement ( new String ( s ) ) ; } public void println ( String s ) { v . addElement ( s ) ; } public String [ ] toStringArray ( ) { int len = v . size ( ) ; String [ ] sa = new String [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { sa [ i ] = ( String ) v . elementAt ( i ) ; } return sa ; } public void clear ( ) { v . setSize ( 0 ) ; } } class NullWriter extends Writer { public void close ( ) { } public void flush ( ) { } public void write ( char [ ] cbuf , int off , int len ) { } } 	1	['4', '1', '0', '2', '10', '0', '1', '1', '3', '0.666666667', '43', '1', '1', '0', '0.666666667', '0', '0', '9', '2', '0.75', '2']
package org . apache . log4j ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . LogLog ; public class FileAppender extends WriterAppender { public static final String FILE_OPTION = "File" ; public static final String APPEND_OPTION = "Append" ; protected boolean fileAppend = true ; protected String fileName = null ; protected boolean qwIsOurs = false ; public FileAppender ( ) { } public FileAppender ( Layout layout , OutputStream os ) { super ( layout , os ) ; } public FileAppender ( Layout layout , Writer writer ) { super ( layout , writer ) ; } public FileAppender ( Layout layout , String filename , boolean append ) throws IOException { this . layout = layout ; this . setFile ( filename , append ) ; } public FileAppender ( Layout layout , String filename ) throws IOException { this ( layout , filename , true ) ; } public void setFile ( String file ) { String val = file . trim ( ) ; if ( val . equalsIgnoreCase ( "System.out" ) ) { setWriter ( new OutputStreamWriter ( System . out ) ) ; } else if ( val . equalsIgnoreCase ( "System.err" ) ) { setWriter ( new OutputStreamWriter ( System . err ) ) ; } else { fileName = val ; } } public boolean getAppend ( ) { return fileAppend ; } public String getFile ( ) { return fileName ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { FILE_OPTION , APPEND_OPTION } ) ; } public void setAppend ( boolean flag ) { fileAppend = flag ; } public void activateOptions ( ) { if ( fileName != null ) { try { setFile ( fileName , fileAppend ) ; } catch ( java . io . IOException e ) { errorHandler . error ( "setFile(" + fileName + "," + fileAppend + ") call failed." , e , ErrorCode . FILE_OPEN_FAILURE ) ; } } else { LogLog . warn ( "File option not set for appender [" + name + "]." ) ; LogLog . warn ( "Are you using FileAppender instead of ConsoleAppender?" ) ; } } protected void closeFile ( ) { if ( this . qw != null && this . qwIsOurs ) { try { this . qw . close ( ) ; } catch ( java . io . IOException e ) { LogLog . error ( "Could not close " + qw , e ) ; } } } public synchronized void setFile ( String fileName , boolean append ) throws IOException { reset ( ) ; this . setQWForFiles ( new FileWriter ( fileName , append ) ) ; this . fileName = fileName ; this . fileAppend = append ; this . qwIsOurs = true ; writeHeader ( ) ; } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( FILE_OPTION ) ) { String val = value . trim ( ) ; if ( val . equalsIgnoreCase ( "System.out" ) ) { setWriter ( new OutputStreamWriter ( System . out ) ) ; } else if ( val . equalsIgnoreCase ( "System.err" ) ) { setWriter ( new OutputStreamWriter ( System . err ) ) ; } else { fileName = val ; } } else if ( key . equalsIgnoreCase ( APPEND_OPTION ) ) { fileAppend = OptionConverter . toBoolean ( value , fileAppend ) ; } } protected void setQWForFiles ( Writer writer ) { this . qw = new QuietWriter ( writer , errorHandler ) ; } protected void reset ( ) { closeFile ( ) ; this . fileName = null ; if ( qwIsOurs ) { super . reset ( ) ; } else { this . qw = null ; } } } 	1	['16', '3', '1', '8', '40', '0', '1', '7', '13', '0.666666667', '306', '0.6', '0', '0.755555556', '0.322916667', '1', '13', '17.8125', '6', '1.375', '3']
package org . apache . log4j ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . LogLog ; public class WriterAppender extends AppenderSkeleton { public static final String IMMEDIATE_FLUSH_OPTION = "ImmediateFlush" ; protected boolean immediateFlush = true ; protected QuietWriter qw ; public WriterAppender ( ) { } public WriterAppender ( Layout layout , OutputStream os ) { this ( layout , new OutputStreamWriter ( os ) ) ; } public WriterAppender ( Layout layout , Writer writer ) { this . layout = layout ; this . setWriter ( writer ) ; } public void setImmediateFlush ( boolean value ) { immediateFlush = value ; } public boolean getImmediateFlush ( ) { return immediateFlush ; } public void activateOptions ( ) { } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } subAppend ( event ) ; } protected boolean checkEntryConditions ( ) { if ( this . closed ) { LogLog . warn ( "Not allowed to write to a closed appender." ) ; return false ; } if ( this . qw == null ) { errorHandler . error ( "No output stream or file set for appender named [" + name + "]." ) ; return false ; } if ( this . layout == null ) { errorHandler . error ( "No layout set for appender named [" + name + "]." ) ; return false ; } return true ; } public synchronized void close ( ) { if ( this . closed ) return ; this . closed = true ; writeFooter ( ) ; reset ( ) ; } protected void closeWriter ( ) { if ( qw != null ) { try { qw . close ( ) ; } catch ( IOException e ) { LogLog . error ( "Could not close " + qw , e ) ; } } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { IMMEDIATE_FLUSH_OPTION } ) ; } public synchronized void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { LogLog . warn ( "You have tried to set a null error-handler." ) ; } else { this . errorHandler = eh ; if ( this . qw != null ) { this . qw . setErrorHandler ( eh ) ; } } } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( IMMEDIATE_FLUSH_OPTION ) ) { immediateFlush = OptionConverter . toBoolean ( value , immediateFlush ) ; } } public synchronized void setWriter ( Writer writer ) { reset ( ) ; this . qw = new QuietWriter ( writer , errorHandler ) ; writeHeader ( ) ; } protected void subAppend ( LoggingEvent event ) { this . qw . write ( this . layout . format ( event ) ) ; if ( layout . ignoresThrowable ( ) ) { String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { int len = s . length ; for ( int i = 0 ; i < len ; i ++ ) { this . qw . write ( s [ i ] ) ; this . qw . write ( Layout . LINE_SEP ) ; } } } if ( this . immediateFlush ) { this . qw . flush ( ) ; } } public boolean requiresLayout ( ) { return true ; } protected void reset ( ) { closeWriter ( ) ; this . qw = null ; } protected void writeFooter ( ) { if ( layout != null ) { String f = layout . getFooter ( ) ; if ( f != null && this . qw != null ) this . qw . write ( f ) ; } } protected void writeHeader ( ) { if ( layout != null ) { String h = layout . getHeader ( ) ; if ( h != null && this . qw != null ) this . qw . write ( h ) ; } } } 	1	['19', '2', '1', '9', '43', '85', '2', '7', '13', '0.703703704', '285', '0.666666667', '1', '0.529411765', '0.190789474', '1', '3', '13.84210526', '5', '1.8947', '4']
package org . apache . log4j ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . LocationInfo ; import org . apache . log4j . helpers . OptionConverter ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . io . Writer ; public class HTMLLayout extends Layout { protected final int BUF_SIZE = 256 ; protected final int MAX_CAPACITY = 1024 ; static String TRACE_PREFIX = "<br>&nbsp;&nbsp;&nbsp;&nbsp;" ; private StringBuffer sbuf = new StringBuffer ( BUF_SIZE ) ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; public static final String TITLE_OPTION = "Title" ; boolean locationInfo = false ; String title = "Log4J Log Messages" ; public String [ ] getOptionStrings ( ) { return new String [ ] { LOCATION_INFO_OPTION , TITLE_OPTION } ; } public void setOption ( String key , String value ) { if ( value == null ) return ; if ( key . equalsIgnoreCase ( LOCATION_INFO_OPTION ) ) { locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } else if ( key . equalsIgnoreCase ( TITLE_OPTION ) ) { title = value ; } } public void setLocationInfo ( boolean flag ) { locationInfo = flag ; } public boolean getLocationInfo ( ) { return locationInfo ; } public void setTitle ( String title ) { this . title = title ; } public String getTitle ( ) { return title ; } public String getContentType ( ) { return "text/html" ; } public void activateOptions ( ) { } public String format ( LoggingEvent event ) { if ( sbuf . capacity ( ) > MAX_CAPACITY ) { sbuf = new StringBuffer ( BUF_SIZE ) ; } else { sbuf . setLength ( 0 ) ; } sbuf . append ( Layout . LINE_SEP + "<tr>" + Layout . LINE_SEP ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . timeStamp - event . getStartTime ( ) ) ; sbuf . append ( "</td>" + Layout . LINE_SEP ) ; sbuf . append ( "<td title=\"" + event . getThreadName ( ) + " thread\">" ) ; sbuf . append ( escapeHTMLTags ( event . getThreadName ( ) ) ) ; sbuf . append ( "</td>" + Layout . LINE_SEP ) ; sbuf . append ( "<td title=\"Priority\">" ) ; if ( event . priority . equals ( Priority . DEBUG ) ) { sbuf . append ( "<font color=\"#339933\">" ) ; sbuf . append ( event . priority ) ; sbuf . append ( "</font>" ) ; } else if ( event . priority . isGreaterOrEqual ( Priority . WARN ) ) { sbuf . append ( "<font color=\"#993300\"><strong>" ) ; sbuf . append ( event . priority ) ; sbuf . append ( "</strong></font>" ) ; } else { sbuf . append ( event . priority ) ; } sbuf . append ( "</td>" + Layout . LINE_SEP ) ; sbuf . append ( "<td title=\"" + event . categoryName + " category\">" ) ; sbuf . append ( escapeHTMLTags ( event . categoryName ) ) ; sbuf . append ( "</td>" + Layout . LINE_SEP ) ; if ( locationInfo ) { LocationInfo locInfo = event . getLocationInformation ( ) ; sbuf . append ( "<td>" ) ; sbuf . append ( escapeHTMLTags ( locInfo . getFileName ( ) ) ) ; sbuf . append ( ':' ) ; sbuf . append ( locInfo . getLineNumber ( ) ) ; sbuf . append ( "</td>" + Layout . LINE_SEP ) ; } sbuf . append ( "<td title=\"Message\">" ) ; sbuf . append ( escapeHTMLTags ( event . getRenderedMessage ( ) ) ) ; sbuf . append ( "</td>" + Layout . LINE_SEP ) ; sbuf . append ( "</tr>" + Layout . LINE_SEP ) ; if ( event . getNDC ( ) != null ) { sbuf . append ( "<tr><td bgcolor=\"#EEEEEE\" style=\"font-size : xx-small;\" colspan=\"6\" title=\"Nested Diagnostic Context\">" ) ; sbuf . append ( "NDC: " + escapeHTMLTags ( event . getNDC ( ) ) ) ; sbuf . append ( "</td></tr>" + Layout . LINE_SEP ) ; } String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { sbuf . append ( "<tr><td bgcolor=\"#993300\" style=\"color:White; font-size : xx-small;\" colspan=\"6\">" ) ; appendThrowableAsHTML ( s , sbuf ) ; sbuf . append ( "</td></tr>" + Layout . LINE_SEP ) ; } return sbuf . toString ( ) ; } void appendThrowableAsHTML ( String [ ] s , StringBuffer sbuf ) { if ( s != null ) { int len = s . length ; if ( len == 0 ) return ; sbuf . append ( escapeHTMLTags ( s [ 0 ] ) ) ; sbuf . append ( Layout . LINE_SEP ) ; for ( int i = 1 ; i < len ; i ++ ) { sbuf . append ( TRACE_PREFIX ) ; sbuf . append ( escapeHTMLTags ( s [ i ] ) ) ; sbuf . append ( Layout . LINE_SEP ) ; } } } public String getHeader ( ) { StringBuffer sbuf = new StringBuffer ( ) ; sbuf . append ( "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">" + Layout . LINE_SEP ) ; sbuf . append ( "<html>" + Layout . LINE_SEP ) ; sbuf . append ( "<head>" + Layout . LINE_SEP ) ; sbuf . append ( "<title>" + title + "</title>" + Layout . LINE_SEP ) ; sbuf . append ( "<style type=\"text/css\">" + Layout . LINE_SEP ) ; sbuf . append ( "<!--" + Layout . LINE_SEP ) ; sbuf . append ( "body, table {font-family: arial,sans-serif; font-size: x-small;}" + Layout . LINE_SEP ) ; sbuf . append ( "th {background: #336699; color: #FFFFFF; text-align: left;}" + Layout . LINE_SEP ) ; sbuf . append ( "-->" + Layout . LINE_SEP ) ; sbuf . append ( "</style>" + Layout . LINE_SEP ) ; sbuf . append ( "</head>" + Layout . LINE_SEP ) ; sbuf . append ( "<body bgcolor=\"#FFFFFF\" topmargin=\"6\" leftmargin=\"6\">" + Layout . LINE_SEP ) ; sbuf . append ( "<hr size=\"1\" noshade>" + Layout . LINE_SEP ) ; sbuf . append ( "Log session start time " + new java . util . Date ( ) + "<br>" + Layout . LINE_SEP ) ; sbuf . append ( "<br>" + Layout . LINE_SEP ) ; sbuf . append ( "<table cellspacing=\"0\" cellpadding=\"4\" border=\"1\" bordercolor=\"#224466\" width=\"100%\">" + Layout . LINE_SEP ) ; sbuf . append ( "<tr>" + Layout . LINE_SEP ) ; sbuf . append ( "<th>Time</th>" + Layout . LINE_SEP ) ; sbuf . append ( "<th>Thread</th>" + Layout . LINE_SEP ) ; sbuf . append ( "<th>Priority</th>" + Layout . LINE_SEP ) ; sbuf . append ( "<th>Category</th>" + Layout . LINE_SEP ) ; if ( locationInfo ) { sbuf . append ( "<th>File:Line</th>" + Layout . LINE_SEP ) ; } sbuf . append ( "<th>Message</th>" + Layout . LINE_SEP ) ; sbuf . append ( "</tr>" + Layout . LINE_SEP ) ; return sbuf . toString ( ) ; } public String getFooter ( ) { StringBuffer sbuf = new StringBuffer ( ) ; sbuf . append ( "</table>" + Layout . LINE_SEP ) ; sbuf . append ( "<br>" + Layout . LINE_SEP ) ; sbuf . append ( "</body></html>" ) ; return sbuf . toString ( ) ; } public boolean ignoresThrowable ( ) { return false ; } private String escapeHTMLTags ( String input ) { if ( input == null || input . length ( ) == 0 ) { return input ; } StringBuffer buf = new StringBuffer ( input . length ( ) + 6 ) ; char ch = ' ' ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { ch = input . charAt ( i ) ; if ( ch == '<' ) { buf . append ( "&lt;" ) ; } else if ( ch == '>' ) { buf . append ( "&gt;" ) ; } else { buf . append ( ch ) ; } } return buf . toString ( ) ; } } 	1	['16', '2', '0', '5', '41', '74', '0', '5', '13', '0.916666667', '853', '0.375', '0', '0.363636364', '0.244444444', '1', '1', '51.8125', '7', '2', '2']
package org . apache . log4j ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . RootCategory ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . NullEnumeration ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . AppenderAttachableImpl ; import org . apache . log4j . helpers . Loader ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . or . ObjectRenderer ; import java . util . Enumeration ; import java . util . Vector ; import java . util . MissingResourceException ; import java . text . MessageFormat ; import java . util . ResourceBundle ; import java . net . URL ; import java . net . MalformedURLException ; public class Category implements AppenderAttachable { static public final Hierarchy defaultHierarchy = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; static public final String DEFAULT_CONFIGURATION_FILE = "log4j.properties" ; static final public String DEFAULT_CONFIGURATION_KEY = "log4j.configuration" ; public static final String DEFAULT_INIT_OVERRIDE_KEY = "log4j.defaultInitOverride" ; static { String override = OptionConverter . getSystemProperty ( DEFAULT_INIT_OVERRIDE_KEY , null ) ; if ( override == null || "false" . equalsIgnoreCase ( override ) ) { String resource = OptionConverter . getSystemProperty ( DEFAULT_CONFIGURATION_KEY , DEFAULT_CONFIGURATION_FILE ) ; URL url = null ; try { url = new URL ( resource ) ; } catch ( MalformedURLException ex ) { url = Loader . getResource ( resource , Object . class ) ; } if ( url != null ) { LogLog . debug ( "Using URL [" + url + "] for automatic log4j configuration." ) ; OptionConverter . selectAndConfigure ( url , defaultHierarchy ) ; } else { LogLog . debug ( "Could not find resource: [" + resource + "]." ) ; } } } protected String name ; volatile protected Priority priority ; volatile protected Category parent ; private static final String FQCN = Category . class . getName ( ) ; protected ResourceBundle resourceBundle ; protected Hierarchy hierarchy ; AppenderAttachableImpl aai ; protected boolean additive = true ; protected Category ( String name ) { this . name = name ; } synchronized public void addAppender ( Appender newAppender ) { if ( aai == null ) { aai = new AppenderAttachableImpl ( ) ; } aai . addAppender ( newAppender ) ; } public void assert ( boolean assertion , String msg ) { if ( ! assertion ) this . error ( msg ) ; } public void callAppenders ( LoggingEvent event ) { int writes = 0 ; for ( Category c = this ; c != null ; c = c . parent ) { synchronized ( c ) { if ( c . aai != null ) { writes += c . aai . appendLoopOnAppenders ( event ) ; } if ( ! c . additive ) { break ; } } } if ( ! hierarchy . emittedNoAppenderWarning && writes == 0 ) { LogLog . error ( "No appenders could be found for category (" + this . getName ( ) + ")." ) ; LogLog . error ( "Please initialize the log4j system properly." ) ; hierarchy . emittedNoAppenderWarning = true ; } } synchronized void closeNestedAppenders ( ) { Enumeration enum = this . getAllAppenders ( ) ; if ( enum != null ) { while ( enum . hasMoreElements ( ) ) { Appender a = ( Appender ) enum . nextElement ( ) ; if ( a instanceof AppenderAttachable ) { a . close ( ) ; } } } } public void debug ( Object message ) { if ( hierarchy . disable >= Priority . DEBUG_INT ) return ; if ( Priority . DEBUG . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { forcedLog ( FQCN , Priority . DEBUG , message , null ) ; } } public void debug ( Object message , Throwable t ) { if ( hierarchy . disable >= Priority . DEBUG_INT ) return ; if ( this . isEnabledFor ( Priority . DEBUG ) ) forcedLog ( FQCN , Priority . DEBUG , message , t ) ; } public void error ( Object message ) { if ( hierarchy . disable >= Priority . ERROR_INT ) return ; if ( this . isEnabledFor ( Priority . ERROR ) ) forcedLog ( FQCN , Priority . ERROR , message , null ) ; } public void error ( Object message , Throwable t ) { if ( hierarchy . disable >= Priority . ERROR_INT ) return ; if ( this . isEnabledFor ( Priority . ERROR ) ) forcedLog ( FQCN , Priority . ERROR , message , t ) ; } public static Category exists ( String name ) { return defaultHierarchy . exists ( name ) ; } public void fatal ( Object message ) { if ( hierarchy . disable >= Priority . FATAL_INT ) return ; if ( Priority . FATAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , Priority . FATAL , message , null ) ; } public void fatal ( Object message , Throwable t ) { if ( hierarchy . disable >= Priority . FATAL_INT ) return ; if ( Priority . FATAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , Priority . FATAL , message , t ) ; } protected void forcedLog ( String fqcn , Priority priority , Object message , Throwable t ) { callAppenders ( new LoggingEvent ( fqcn , this , priority , message , t ) ) ; } public boolean getAdditivity ( ) { return additive ; } synchronized public Enumeration getAllAppenders ( ) { if ( aai == null ) return NullEnumeration . getInstance ( ) ; else return aai . getAllAppenders ( ) ; } synchronized public Appender getAppender ( String name ) { if ( aai == null || name == null ) return null ; return aai . getAppender ( name ) ; } public Priority getChainedPriority ( ) { for ( Category c = this ; c != null ; c = c . parent ) { if ( c . priority != null ) return c . priority ; } return null ; } public static Enumeration getCurrentCategories ( ) { return defaultHierarchy . getCurrentCategories ( ) ; } public static Hierarchy getDefaultHierarchy ( ) { return defaultHierarchy ; } public Hierarchy getHierarchy ( ) { return hierarchy ; } public static Category getInstance ( String name ) { return defaultHierarchy . getInstance ( name ) ; } public static Category getInstance ( Class clazz ) { return getInstance ( clazz . getName ( ) ) ; } public static Category getInstance ( String name , CategoryFactory factory ) { return defaultHierarchy . getInstance ( name , factory ) ; } public final String getName ( ) { return name ; } final public Priority getPriority ( ) { return this . priority ; } final public static Category getRoot ( ) { return defaultHierarchy . getRoot ( ) ; } public ResourceBundle getResourceBundle ( ) { for ( Category c = this ; c != null ; c = c . parent ) { if ( c . resourceBundle != null ) return c . resourceBundle ; } return null ; } protected String getResourceBundleString ( String key ) { ResourceBundle rb = getResourceBundle ( ) ; if ( rb == null ) { if ( ! hierarchy . emittedNoResourceBundleWarning ) { error ( "No resource bundle has been set for category " + name ) ; hierarchy . emittedNoResourceBundleWarning = true ; } return null ; } else { try { return rb . getString ( key ) ; } catch ( MissingResourceException mre ) { error ( "No resource is associated with key \"" + key + "\"." ) ; return null ; } } } public void info ( Object message ) { if ( hierarchy . disable >= Priority . INFO_INT ) return ; if ( Priority . INFO . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , Priority . INFO , message , null ) ; } public void info ( Object message , Throwable t ) { if ( hierarchy . disable >= Priority . INFO_INT ) return ; if ( Priority . INFO . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , Priority . INFO , message , t ) ; } public boolean isDebugEnabled ( ) { if ( hierarchy . disable >= Priority . DEBUG_INT ) return false ; return Priority . DEBUG . isGreaterOrEqual ( this . getChainedPriority ( ) ) ; } public boolean isEnabledFor ( Priority priority ) { if ( hierarchy . disable >= priority . level ) { return false ; } return priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ; } public boolean isInfoEnabled ( ) { if ( hierarchy . disable >= Priority . INFO_INT ) return false ; return Priority . INFO . isGreaterOrEqual ( this . getChainedPriority ( ) ) ; } public void l7dlog ( Priority priority , String key , Throwable t ) { if ( hierarchy . disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { String msg = getResourceBundleString ( key ) ; if ( msg == null ) { msg = key ; } forcedLog ( FQCN , priority , msg , t ) ; } } public void l7dlog ( Priority priority , String key , Object [ ] params , Throwable t ) { if ( hierarchy . disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { String pattern = getResourceBundleString ( key ) ; String msg ; if ( pattern == null ) msg = key ; else msg = java . text . MessageFormat . format ( pattern , params ) ; forcedLog ( FQCN , priority , msg , t ) ; } } public void log ( Priority priority , Object message , Throwable t ) { if ( hierarchy . disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , priority , message , t ) ; } public void log ( Priority priority , Object message ) { if ( hierarchy . disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , priority , message , null ) ; } public void log ( String callerFQCN , Priority priority , Object message , Throwable t ) { if ( hierarchy . disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { forcedLog ( callerFQCN , priority , message , t ) ; } } synchronized public void removeAllAppenders ( ) { if ( aai != null ) { aai . removeAllAppenders ( ) ; aai = null ; } } synchronized public void removeAppender ( Appender appender ) { if ( appender == null || aai == null ) return ; aai . removeAppender ( appender ) ; } synchronized public void removeAppender ( String name ) { if ( name == null || aai == null ) return ; aai . removeAppender ( name ) ; } public void setAdditivity ( boolean additive ) { this . additive = additive ; } final void setHierarchy ( Hierarchy hierarchy ) { this . hierarchy = hierarchy ; } public void setPriority ( Priority priority ) { this . priority = priority ; } public void setResourceBundle ( ResourceBundle bundle ) { resourceBundle = bundle ; } public static void shutdown ( ) { defaultHierarchy . shutdown ( ) ; } public void warn ( Object message ) { if ( this . isEnabledFor ( Priority . WARN ) ) forcedLog ( FQCN , Priority . WARN , message , null ) ; } public void warn ( Object message , Throwable t ) { if ( this . isEnabledFor ( Priority . WARN ) ) forcedLog ( FQCN , Priority . WARN , message , t ) ; } } 	1	['50', '1', '2', '46', '90', '637', '38', '12', '43', '0.814868805', '778', '0.5', '5', '0', '0.149136578', '0', '0', '14.28', '6', '2.08', '9']
package org . apache . log4j . net ; import java . net . InetAddress ; import java . net . Socket ; import java . io . OutputStream ; import java . io . IOException ; import java . io . ObjectOutputStream ; import java . io . ObjectOutputStream ; import java . io . OutputStreamWriter ; import java . io . StringWriter ; import java . io . PrintWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . AppenderSkeleton ; public class SocketAppender extends AppenderSkeleton { public static final String REMOTE_HOST_OPTION = "RemoteHost" ; public static final String PORT_OPTION = "Port" ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; public static final String RECONNECTION_DELAY_OPTION = "ReconnectionDelay" ; static final int DEFAULT_PORT = 4560 ; static final int DEFAULT_RECONNECTION_DELAY = 30000 ; String remoteHost ; InetAddress address ; int port = DEFAULT_PORT ; ObjectOutputStream oos ; int reconnectionDelay = DEFAULT_RECONNECTION_DELAY ; boolean locationInfo = false ; private Connector connector ; int counter = 0 ; private static final int RESET_FREQUENCY = 1 ; public SocketAppender ( ) { } public SocketAppender ( InetAddress address , int port ) { this . address = address ; this . remoteHost = address . getHostName ( ) ; this . port = port ; connect ( address , port ) ; } public SocketAppender ( String host , int port ) { this . port = port ; this . address = getAddressByName ( host ) ; this . remoteHost = host ; connect ( address , port ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { REMOTE_HOST_OPTION , PORT_OPTION , LOCATION_INFO_OPTION , RECONNECTION_DELAY_OPTION } ) ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( REMOTE_HOST_OPTION ) ) { address = getAddressByName ( value ) ; remoteHost = value ; } else if ( option . equals ( PORT_OPTION ) ) { port = OptionConverter . toInt ( value , port ) ; } else if ( option . equals ( LOCATION_INFO_OPTION ) ) { locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } else if ( option . equals ( RECONNECTION_DELAY_OPTION ) ) { reconnectionDelay = OptionConverter . toInt ( value , reconnectionDelay ) ; } } public void activateOptions ( ) { connect ( address , port ) ; } synchronized public void close ( ) { if ( closed ) return ; this . closed = true ; cleanUp ( ) ; } public void cleanUp ( ) { if ( oos != null ) { try { oos . close ( ) ; } catch ( IOException e ) { LogLog . error ( "Could not close oos." , e ) ; } oos = null ; } if ( connector != null ) { connector . interrupted = true ; connector = null ; } } void connect ( InetAddress address , int port ) { if ( this . address == null ) return ; try { cleanUp ( ) ; oos = new ObjectOutputStream ( new Socket ( address , port ) . getOutputStream ( ) ) ; } catch ( IOException e ) { LogLog . error ( "Could not connect to remote log4j server at [" + address . getHostName ( ) + "]. We will try again later." , e ) ; fireConnector ( ) ; } } public void append ( LoggingEvent event ) { if ( event == null ) return ; if ( address == null ) { errorHandler . error ( "No remote host is set for SocketAppender named \"" + this . name + "\"." ) ; return ; } if ( oos != null ) { try { if ( locationInfo ) { event . getLocationInformation ( ) ; } oos . writeObject ( event ) ; oos . flush ( ) ; if ( ++ counter >= RESET_FREQUENCY ) { counter = 0 ; oos . reset ( ) ; } } catch ( IOException e ) { oos = null ; LogLog . warn ( "Detected problem with connection: " + e ) ; if ( reconnectionDelay > 0 ) { fireConnector ( ) ; } } } } void fireConnector ( ) { if ( connector == null ) { LogLog . debug ( "Starting a new connector thread." ) ; connector = new Connector ( ) ; connector . setDaemon ( true ) ; connector . setPriority ( Thread . MIN_PRIORITY ) ; connector . start ( ) ; } } static InetAddress getAddressByName ( String host ) { try { return InetAddress . getByName ( host ) ; } catch ( Exception e ) { LogLog . error ( "Could not find address of [" + host + "]." , e ) ; return null ; } } public boolean requiresLayout ( ) { return false ; } public void setRemoteHost ( String host ) { address = getAddressByName ( host ) ; remoteHost = host ; } public String getRemoteHost ( ) { return remoteHost ; } public void setPort ( int port ) { this . port = port ; } public int getPort ( ) { return port ; } public void setLocationInfo ( boolean locationInfo ) { this . locationInfo = locationInfo ; } public boolean getLocationInfo ( ) { return locationInfo ; } public void setReconnectionDelay ( int delay ) { this . reconnectionDelay = delay ; } public int getReconnectionDelay ( ) { return reconnectionDelay ; } class Connector extends Thread { boolean interrupted = false ; public void run ( ) { Socket socket ; while ( ! interrupted ) { try { sleep ( reconnectionDelay ) ; LogLog . debug ( "Attempting connection to " + address . getHostName ( ) ) ; socket = new Socket ( address , port ) ; synchronized ( this ) { oos = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; connector = null ; break ; } } catch ( InterruptedException e ) { LogLog . debug ( "Connector interrupted. Leaving loop." ) ; return ; } catch ( java . net . ConnectException e ) { LogLog . debug ( "Remote host " + address . getHostName ( ) + " refused connection." ) ; } catch ( IOException e ) { LogLog . debug ( "Could not connect to " + address . getHostName ( ) + ". Exception is " + e ) ; } } } } } 	1	['22', '2', '0', '9', '51', '95', '3', '7', '18', '0.888888889', '414', '0.133333333', '1', '0.486486486', '0.198863636', '2', '3', '17.13636364', '6', '1.5455', '1']
package org . apache . log4j . spi ; import org . apache . log4j . FileAppender ; public interface OptionHandler { void activateOptions ( ) ; String [ ] getOptionStrings ( ) ; void setOption ( String option , String value ) ; } 	1	['3', '1', '0', '7', '3', '3', '7', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '1']
package org . apache . log4j ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import java . util . Enumeration ; public class BasicConfigurator { public static final String DISABLE_OVERRIDE_KEY = "log4j.disableOverride" ; public static final String DISABLE_KEY = "log4j.disable" ; public static final String INHERITED = "inherited" ; static { String override = OptionConverter . getSystemProperty ( DISABLE_OVERRIDE_KEY , null ) ; if ( override != null ) { Category . defaultHierarchy . setDisableOverride ( override ) ; } else { String disableStr = OptionConverter . getSystemProperty ( DISABLE_KEY , null ) ; if ( disableStr != null ) { Category . defaultHierarchy . disable ( disableStr ) ; } } } protected BasicConfigurator ( ) { } protected void addRenderer ( Hierarchy hierarchy , String renderedClassName , String renderingClassName ) { LogLog . debug ( "Rendering class: [" + renderingClassName + "], Rendered class: [" + renderedClassName + "]." ) ; ObjectRenderer renderer = ( ObjectRenderer ) OptionConverter . instantiateByClassName ( renderingClassName , ObjectRenderer . class , null ) ; if ( renderer == null ) { LogLog . error ( "Could not instantiate renderer [" + renderingClassName + "]." ) ; return ; } else { try { Class renderedClass = Class . forName ( renderedClassName ) ; hierarchy . rendererMap . put ( renderedClass , renderer ) ; } catch ( ClassNotFoundException e ) { LogLog . error ( "Could not find class [" + renderedClassName + "]." , e ) ; } } } public static void disable ( String priorityStr ) { Category . getDefaultHierarchy ( ) . disable ( priorityStr ) ; } public static void disable ( Priority p ) { } public static void disableAll ( ) { Category . getDefaultHierarchy ( ) . disable ( Priority . FATAL ) ; } public static void disableDebug ( ) { Category . getDefaultHierarchy ( ) . disable ( Priority . DEBUG ) ; } public static void disableInfo ( ) { Category . getDefaultHierarchy ( ) . disable ( Priority . INFO ) ; } public static void enableAll ( ) { Category . getDefaultHierarchy ( ) . disable ( Priority . INFO ) ; } static public void configure ( ) { Category root = Category . getRoot ( ) ; root . addAppender ( new ConsoleAppender ( new PatternLayout ( PatternLayout . TTCC_CONVERSION_PATTERN ) ) ) ; } static public void configure ( Appender appender ) { Category root = Category . getRoot ( ) ; root . addAppender ( appender ) ; } public static void resetConfiguration ( ) { Category . defaultHierarchy . resetConfiguration ( ) ; } public static void resetConfiguration ( Hierarchy hierarchy ) { hierarchy . resetConfiguration ( ) ; } } 	1	['14', '1', '1', '17', '36', '91', '6', '11', '10', '1.057692308', '161', '0', '0', '0', '0.138461538', '0', '0', '10.21428571', '3', '1', '2']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import java . util . Properties ; import javax . jms . * ; import javax . naming . InitialContext ; import javax . naming . Context ; import javax . naming . NameNotFoundException ; import javax . naming . NamingException ; public class JMSAppender extends AppenderSkeleton { public static final String TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION = "TopicConnectionFactoryBindingName" ; public static final String TOPIC_BINDING_NAME_OPTION = "TopicBindingName" ; TopicConnection topicConnection ; TopicSession topicSession ; TopicPublisher topicPublisher ; String topicBindingName ; String tcfBindingName ; public JMSAppender ( ) { } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { TOPIC_BINDING_NAME_OPTION , TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION } ) ; } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equals ( TOPIC_BINDING_NAME_OPTION ) ) topicBindingName = value ; else if ( key . equals ( TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION ) ) { tcfBindingName = value ; } } public void setTopicConnectionFactoryBindingName ( String tcfBindingName ) { this . tcfBindingName = tcfBindingName ; } public String getTopicConnectionFactoryBindingName ( ) { return tcfBindingName ; } public void setTopicBindingName ( String topicBindingName ) { this . topicBindingName = topicBindingName ; } public String getTopicBindingName ( ) { return topicBindingName ; } public void activateOptions ( ) { TopicConnectionFactory topicConnectionFactory ; try { Context ctx = new InitialContext ( ) ; topicConnectionFactory = ( TopicConnectionFactory ) lookup ( ctx , tcfBindingName ) ; topicConnection = topicConnectionFactory . createTopicConnection ( ) ; topicConnection . start ( ) ; topicSession = topicConnection . createTopicSession ( false , Session . AUTO_ACKNOWLEDGE ) ; Topic topic = ( Topic ) lookup ( ctx , topicBindingName ) ; topicPublisher = topicSession . createPublisher ( topic ) ; ctx . close ( ) ; } catch ( Exception e ) { errorHandler . error ( "Error while activating options for appender named [" + name + "]." , e , ErrorCode . GENERIC_FAILURE ) ; } } protected Object lookup ( Context ctx , String name ) throws NamingException { try { return ctx . lookup ( name ) ; } catch ( NameNotFoundException e ) { LogLog . error ( "Could not find name [" + name + "]." ) ; throw e ; } } protected boolean checkEntryConditions ( ) { String fail = null ; if ( this . topicConnection == null ) { fail = "No TopicConnection" ; } else if ( this . topicSession == null ) { fail = "No TopicSession" ; } else if ( this . topicPublisher == null ) { fail = "No TopicPublisher" ; } if ( fail != null ) { errorHandler . error ( fail + " for JMSAppender named [" + name + "]." ) ; return false ; } else { return true ; } } public synchronized void close ( ) { if ( this . closed ) return ; LogLog . debug ( "Closing appender [" + name + "]." ) ; this . closed = true ; try { if ( topicSession != null ) topicSession . close ( ) ; if ( topicConnection != null ) topicConnection . close ( ) ; } catch ( Exception e ) { LogLog . error ( "Error while closing JMSAppender [" + name + "]." , e ) ; } topicPublisher = null ; topicSession = null ; topicConnection = null ; } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } try { ObjectMessage msg = topicSession . createObjectMessage ( ) ; msg . setObject ( event ) ; topicPublisher . publish ( msg ) ; } catch ( Exception e ) { errorHandler . error ( "Could not publish message in JMSAppender [" + name + "]." , e , ErrorCode . GENERIC_FAILURE ) ; } } public boolean requiresLayout ( ) { return false ; } } 	1	['13', '2', '0', '5', '38', '44', '0', '5', '11', '0.845238095', '284', '0', '0', '0.6', '0.365384615', '2', '3', '20.30769231', '5', '1.6923', '2']
package org . apache . log4j ; import java . beans . * ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . File ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . CountingQuietWriter ; import org . apache . log4j . spi . LoggingEvent ; public class RollingFileAppender extends FileAppender { static final public String MAX_FILE_SIZE_OPTION = "MaxFileSize" ; static final public String MAX_BACKUP_INDEX_OPTION = "MaxBackupIndex" ; protected long maxFileSize = 10 * 1024 * 1024 ; protected int maxBackupIndex = 1 ; public RollingFileAppender ( ) { super ( ) ; } public RollingFileAppender ( Layout layout , String filename , boolean append ) throws IOException { super ( layout , filename , append ) ; } public RollingFileAppender ( Layout layout , String filename ) throws IOException { super ( layout , filename ) ; } public int getMaxBackupIndex ( ) { return maxBackupIndex ; } public long getMaximumFileSize ( ) { return maxFileSize ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { MAX_FILE_SIZE_OPTION , MAX_BACKUP_INDEX_OPTION } ) ; } public void rollOver ( ) { File target ; File file ; LogLog . debug ( "rolling over count=" + ( ( CountingQuietWriter ) qw ) . getCount ( ) ) ; LogLog . debug ( "maxBackupIndex=" + maxBackupIndex ) ; if ( maxBackupIndex > 0 ) { file = new File ( fileName + '.' + maxBackupIndex ) ; if ( file . exists ( ) ) file . delete ( ) ; for ( int i = maxBackupIndex - 1 ; i >= 1 ; i -- ) { file = new File ( fileName + "." + i ) ; if ( file . exists ( ) ) { target = new File ( fileName + '.' + ( i + 1 ) ) ; LogLog . debug ( "Renaming file " + file + " to " + target ) ; file . renameTo ( target ) ; } } target = new File ( fileName + "." + 1 ) ; this . closeFile ( ) ; file = new File ( fileName ) ; LogLog . debug ( "Renaming file " + file + " to " + target ) ; file . renameTo ( target ) ; } try { this . setFile ( fileName , false ) ; } catch ( IOException e ) { LogLog . error ( "setFile(" + fileName + ", false) call failed." , e ) ; } } public synchronized void setFile ( String fileName , boolean append ) throws IOException { super . setFile ( fileName , append ) ; if ( append ) { File f = new File ( fileName ) ; ( ( CountingQuietWriter ) qw ) . setCount ( f . length ( ) ) ; } } public void setOption ( String key , String value ) { super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( MAX_FILE_SIZE_OPTION ) ) { maxFileSize = OptionConverter . toFileSize ( value , maxFileSize + 1 ) ; } else if ( key . equalsIgnoreCase ( MAX_BACKUP_INDEX_OPTION ) ) { maxBackupIndex = OptionConverter . toInt ( value , maxBackupIndex ) ; } } public void setMaxBackupIndex ( int maxBackups ) { this . maxBackupIndex = maxBackups ; } public void setMaxFileSize ( long maxFileSize ) { this . maxFileSize = maxFileSize ; } public void setMaximumFileSize ( long maxFileSize ) { this . maxFileSize = maxFileSize ; } public void setMaxFileSize ( String value ) { maxFileSize = OptionConverter . toFileSize ( value , maxFileSize + 1 ) ; } protected void setQWForFiles ( Writer writer ) { this . qw = new CountingQuietWriter ( writer , errorHandler ) ; } protected void subAppend ( LoggingEvent event ) { super . subAppend ( event ) ; if ( ( fileName != null ) && ( ( CountingQuietWriter ) qw ) . getCount ( ) >= maxFileSize ) this . rollOver ( ) ; } } 	1	['15', '3', '0', '10', '44', '3', '0', '10', '13', '0.767857143', '334', '0.5', '0', '0.733333333', '0.241666667', '1', '10', '21', '5', '1.3333', '1']
package org . apache . log4j ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OnlyOnceErrorHandler ; import org . apache . log4j . helpers . LogLog ; public abstract class AppenderSkeleton implements Appender , OptionHandler { public static final String THRESHOLD_OPTION = "Threshold" ; protected Layout layout ; protected String name ; protected Priority threshold ; protected ErrorHandler errorHandler = new OnlyOnceErrorHandler ( ) ; protected Filter headFilter ; protected Filter tailFilter ; protected boolean closed = false ; public void activateOptions ( ) { } public void addFilter ( Filter newFilter ) { if ( headFilter == null ) { headFilter = tailFilter = newFilter ; } else { tailFilter . next = newFilter ; tailFilter = newFilter ; } } abstract protected void append ( LoggingEvent event ) ; public void clearFilters ( ) { headFilter = tailFilter = null ; } public void finalize ( ) { if ( this . closed ) return ; LogLog . debug ( "Finalizing appender named [" + name + "]." ) ; close ( ) ; } public ErrorHandler getErrorHandler ( ) { return this . errorHandler ; } public Filter getFilter ( ) { return headFilter ; } public final Filter getFirstFilter ( ) { return headFilter ; } public Layout getLayout ( ) { return layout ; } public final String getName ( ) { return this . name ; } public String [ ] getOptionStrings ( ) { return new String [ ] { THRESHOLD_OPTION } ; } public Priority getThreshold ( ) { return threshold ; } public boolean isAsSevereAsThreshold ( Priority priority ) { return ( ( threshold == null ) || priority . isGreaterOrEqual ( threshold ) ) ; } public synchronized void doAppend ( LoggingEvent event ) { if ( closed ) { LogLog . error ( "Attempted to append to closed appender named [" + name + "]." ) ; } if ( ! isAsSevereAsThreshold ( event . priority ) ) { return ; } Filter f = this . headFilter ; FILTER_LOOP : while ( f != null ) { switch ( f . decide ( event ) ) { case Filter . DENY : return ; case Filter . ACCEPT : break FILTER_LOOP ; case Filter . NEUTRAL : f = f . next ; } } this . append ( event ) ; } public synchronized void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { LogLog . warn ( "You have tried to set a null error-handler." ) ; } else { this . errorHandler = eh ; } } public void setLayout ( Layout layout ) { this . layout = layout ; } public void setName ( String name ) { this . name = name ; } public void setOption ( String key , String value ) { if ( key . equalsIgnoreCase ( THRESHOLD_OPTION ) ) { threshold = Priority . toPriority ( value ) ; } } public void setThreshold ( Priority threshold ) { this . threshold = threshold ; } } 	1	['22', '1', '8', '20', '35', '175', '11', '9', '21', '0.904761905', '193', '0.875', '5', '0', '0.201298701', '0', '0', '7.409090909', '4', '1.3636', '4']
