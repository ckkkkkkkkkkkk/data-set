package org . apache . camel . component . quartz ; import org . apache . camel . CamelContext ; import org . apache . camel . impl . DefaultExchange ; import org . quartz . JobExecutionContext ; public class QuartzExchange extends DefaultExchange { public QuartzExchange ( CamelContext context , JobExecutionContext jobExecutionContext ) { super ( context ) ; setIn ( new QuartzMessage ( this , jobExecutionContext ) ) ; } @ Override public QuartzMessage getIn ( ) { return ( QuartzMessage ) super . getIn ( ) ; } public JobExecutionContext getJobExecutionContext ( ) { return getIn ( ) . getJobExecutionContext ( ) ; } } 	0	['4', '2', '0', '6', '8', '6', '2', '5', '4', '2', '26', '0', '0', '0.896551724', '0.5', '0', '0', '5.5', '1', '0.75', '0']
package org . apache . camel ; import java . util . Map ; public interface Message { String getMessageId ( ) ; void setMessageId ( String messageId ) ; Exchange getExchange ( ) ; Object getHeader ( String name ) ; < T > T getHeader ( String name , Class < T > type ) ; void setHeader ( String name , Object value ) ; Map < String , Object > getHeaders ( ) ; void setHeaders ( Map < String , Object > headers ) ; public Object getBody ( ) ; public < T > T getBody ( Class < T > type ) ; public void setBody ( Object body ) ; public < T > void setBody ( Object body , Class < T > type ) ; Message copy ( ) ; } 	1	['13', '1', '0', '66', '13', '78', '66', '1', '13', '2', '13', '0', '0', '0', '0.369230769', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . mina ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoConnector ; import org . apache . mina . filter . codec . ProtocolCodecFilter ; import org . apache . mina . filter . codec . serialization . ObjectSerializationCodecFactory ; import org . apache . mina . transport . socket . nio . DatagramAcceptor ; import org . apache . mina . transport . socket . nio . DatagramConnector ; import org . apache . mina . transport . socket . nio . DatagramConnectorConfig ; import org . apache . mina . transport . socket . nio . SocketAcceptor ; import org . apache . mina . transport . socket . nio . SocketConnector ; import org . apache . mina . transport . socket . nio . SocketConnectorConfig ; import org . apache . mina . transport . vmpipe . VmPipeAcceptor ; import org . apache . mina . transport . vmpipe . VmPipeAddress ; import org . apache . mina . transport . vmpipe . VmPipeConnector ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Map ; public class MinaComponent extends DefaultComponent < MinaExchange > { public MinaComponent ( ) { } public MinaComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < MinaExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { URI u = new URI ( remaining ) ; String protocol = u . getScheme ( ) ; if ( protocol . equals ( "tcp" ) ) { return createSocketEndpoint ( uri , u ) ; } else if ( protocol . equals ( "udp" ) || protocol . equals ( "mcast" ) || protocol . equals ( "multicast" ) ) { return createDatagramEndpoint ( uri , u ) ; } else if ( protocol . equals ( "vm" ) ) { return createVmEndpoint ( uri , u ) ; } else { throw new IOException ( "Unrecognised MINA protocol: " + protocol + " for uri: " + uri ) ; } } protected MinaEndpoint createVmEndpoint ( String uri , URI connectUri ) { IoAcceptor acceptor = new VmPipeAcceptor ( ) ; SocketAddress address = new VmPipeAddress ( connectUri . getPort ( ) ) ; IoConnector connector = new VmPipeConnector ( ) ; return new MinaEndpoint ( uri , this , address , acceptor , connector , null ) ; } protected MinaEndpoint createSocketEndpoint ( String uri , URI connectUri ) { IoAcceptor acceptor = new SocketAcceptor ( ) ; SocketAddress address = new InetSocketAddress ( connectUri . getHost ( ) , connectUri . getPort ( ) ) ; IoConnector connector = new SocketConnector ( ) ; SocketConnectorConfig config = new SocketConnectorConfig ( ) ; config . getFilterChain ( ) . addLast ( "codec" , new ProtocolCodecFilter ( new ObjectSerializationCodecFactory ( ) ) ) ; return new MinaEndpoint ( uri , this , address , acceptor , connector , config ) ; } protected MinaEndpoint createDatagramEndpoint ( String uri , URI connectUri ) { IoAcceptor acceptor = new DatagramAcceptor ( ) ; SocketAddress address = new InetSocketAddress ( connectUri . getHost ( ) , connectUri . getPort ( ) ) ; IoConnector connector = new DatagramConnector ( ) ; DatagramConnectorConfig config = new DatagramConnectorConfig ( ) ; config . getFilterChain ( ) . addLast ( "codec" , new ProtocolCodecFilter ( new ObjectSerializationCodecFactory ( ) ) ) ; return new MinaEndpoint ( uri , this , address , acceptor , connector , config ) ; } } 	0	['6', '3', '0', '21', '33', '15', '1', '21', '2', '2', '176', '0', '0', '0.8', '0.5', '2', '2', '28.33333333', '1', '0.6667', '0']
package org . apache . camel . component . file ; import org . apache . camel . Exchange ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; public class FileProducer extends DefaultProducer { private static final transient Log log = LogFactory . getLog ( FileProducer . class ) ; private final FileEndpoint endpoint ; public FileProducer ( FileEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) { process ( endpoint . toExchangeType ( exchange ) ) ; } public void process ( FileExchange exchange ) { String fileName = exchange . getIn ( ) . getMessageId ( ) ; ByteBuffer payload = exchange . getIn ( ) . getBody ( ByteBuffer . class ) ; payload . flip ( ) ; File file = null ; if ( endpoint . getFile ( ) != null && endpoint . getFile ( ) . isDirectory ( ) ) { file = new File ( endpoint . getFile ( ) , fileName ) ; } else { file = new File ( fileName ) ; } buildDirectory ( file ) ; try { FileChannel fc = new RandomAccessFile ( file , "rw" ) . getChannel ( ) ; fc . position ( fc . size ( ) ) ; fc . write ( payload ) ; fc . close ( ) ; } catch ( Throwable e ) { log . error ( "Failed to write to File: " + file , e ) ; } } private void buildDirectory ( File file ) { String dirName = file . getAbsolutePath ( ) ; int index = dirName . lastIndexOf ( File . separatorChar ) ; if ( index > 0 ) { dirName = dirName . substring ( 0 , index ) ; File dir = new File ( dirName ) ; dir . mkdirs ( ) ; } } } 	1	['5', '3', '0', '8', '31', '2', '1', '8', '3', '0.5', '122', '1', '1', '0.8', '0.4', '0', '0', '23', '3', '1.2', '2']
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import java . util . List ; public class RandomLoadBalancer extends QueueLoadBalancer { protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { int size = processors . size ( ) ; while ( true ) { int index = ( int ) Math . round ( Math . random ( ) * size ) ; if ( index < size ) { return processors . get ( index ) ; } } } } 	0	['2', '3', '0', '3', '7', '1', '0', '3', '1', '2', '24', '0', '0', '0.833333333', '0.666666667', '1', '1', '11', '1', '0.5', '0']
package org . apache . camel ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . Callable ; public interface CamelContext extends Service { void addComponent ( String componentName , Component component ) ; Component getComponent ( String componentName ) ; < T extends Component > T getComponent ( String name , Class < T > componentType ) ; Component removeComponent ( String componentName ) ; Component getOrCreateComponent ( String componentName , Callable < Component > factory ) ; Endpoint getEndpoint ( String uri ) ; < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) ; Collection < Endpoint > getSingletonEndpoints ( ) ; Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception ; Endpoint removeSingletonEndpoint ( String uri ) throws Exception ; List < Route > getRoutes ( ) ; void setRoutes ( List < Route > routes ) ; void addRoutes ( Collection < Route > routes ) throws Exception ; void addRoutes ( RouteBuilder builder ) throws Exception ; ExchangeConverter getExchangeConverter ( ) ; TypeConverter getTypeConverter ( ) ; Injector getInjector ( ) ; } 	1	['17', '1', '0', '84', '17', '136', '80', '7', '17', '2', '17', '0', '0', '0', '0.222222222', '0', '0', '0', '1', '1', '1']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; public class ValueBuilder < E extends Exchange > implements Expression < E > { private Expression < E > expression ; public ValueBuilder ( Expression < E > expression ) { this . expression = expression ; } public Object evaluate ( E exchange ) { return expression . evaluate ( exchange ) ; } public Expression < E > getExpression ( ) { return expression ; } @ Override public String toString ( ) { return expression . toString ( ) ; } @ Fluent public Predicate < E > isNotEqualTo ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isNotEqualTo ( expression , right ) ) ; } @ Fluent public Predicate < E > isEqualTo ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isEqualTo ( expression , right ) ) ; } @ Fluent public Predicate < E > isLessThan ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isLessThan ( expression , right ) ) ; } @ Fluent public Predicate < E > isLessThanOrEqualTo ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isLessThanOrEqualTo ( expression , right ) ) ; } @ Fluent public Predicate < E > isGreaterThan ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isGreaterThan ( expression , right ) ) ; } @ Fluent public Predicate < E > isGreaterThanOrEqualTo ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isGreaterThanOrEqualTo ( expression , right ) ) ; } @ Fluent public Predicate < E > isInstanceOf ( @ FluentArg ( "class" ) Class type ) { return onNewPredicate ( PredicateBuilder . isInstanceOf ( expression , type ) ) ; } @ Fluent public Predicate < E > matchesRegex ( @ FluentArg ( "regex" ) String regex ) { return onNewPredicate ( PredicateBuilder . regex ( expression , regex ) ) ; } @ Fluent public Predicate < E > isNull ( ) { return onNewPredicate ( PredicateBuilder . isNull ( expression ) ) ; } @ Fluent public Predicate < E > isNotNull ( ) { return onNewPredicate ( PredicateBuilder . isNotNull ( expression ) ) ; } @ Fluent public Predicate < E > contains ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . contains ( expression , right ) ) ; } @ Fluent public Predicate < E > regex ( String regex ) { return onNewPredicate ( PredicateBuilder . regex ( expression , regex ) ) ; } @ Fluent public ValueBuilder < E > tokenize ( ) { return tokenize ( "\n" ) ; } @ Fluent public ValueBuilder < E > tokenize ( @ FluentArg ( "token" ) String token ) { Expression < E > newExp = ExpressionBuilder . tokenizeExpression ( expression , token ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > regexTokenize ( @ FluentArg ( "regex" ) String regex ) { Expression < E > newExp = ExpressionBuilder . regexTokenize ( expression , regex ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > regexReplaceAll ( @ FluentArg ( "regex" ) String regex , @ FluentArg ( "replacement" ) String replacement ) { Expression < E > newExp = ExpressionBuilder . regexReplaceAll ( expression , regex , replacement ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > regexReplaceAll ( @ FluentArg ( "regex" ) String regex , @ FluentArg ( "replacement" ) Expression < E > replacement ) { Expression < E > newExp = ExpressionBuilder . regexReplaceAll ( expression , regex , replacement ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > convertTo ( @ FluentArg ( "type" ) Class type ) { Expression < E > newExp = ExpressionBuilder . convertTo ( expression , type ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > convertToString ( ) { return convertTo ( String . class ) ; } @ Fluent public ValueBuilder < E > append ( @ FluentArg ( "value" ) Object value ) { return new ValueBuilder < E > ( ExpressionBuilder . append ( expression , asExpression ( value ) ) ) ; } protected Predicate < E > onNewPredicate ( Predicate < E > predicate ) { return predicate ; } protected Expression < E > asExpression ( Object value ) { if ( value instanceof Expression ) { return ( Expression < E > ) value ; } else { return ExpressionBuilder . constantExpression ( value ) ; } } } 	0	['26', '1', '1', '10', '47', '0', '5', '5', '24', '0.08', '236', '1', '1', '0', '0.258241758', '0', '0', '8.038461538', '2', '1', '0']
package org . apache . camel . component . file ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . ScheduledPollEndpoint ; import java . io . File ; public class FileEndpoint extends ScheduledPollEndpoint < FileExchange > { private File file ; private boolean autoCreate = true ; protected FileEndpoint ( File file , String endpointUri , FileComponent component ) { super ( endpointUri , component ) ; this . file = file ; } public Producer < FileExchange > createProducer ( ) throws Exception { Producer < FileExchange > result = new FileProducer ( this ) ; return result ; } public Consumer < FileExchange > createConsumer ( Processor file ) throws Exception { Consumer < FileExchange > result = new FileConsumer ( this , file ) ; configureConsumer ( result ) ; return result ; } public FileExchange createExchange ( File file ) { return new FileExchange ( getContext ( ) , file ) ; } public FileExchange createExchange ( ) { return createExchange ( getFile ( ) ) ; } public File getFile ( ) { if ( autoCreate && ! file . exists ( ) ) { file . mkdirs ( ) ; } return file ; } public boolean isSingleton ( ) { return true ; } public boolean isAutoCreate ( ) { return this . autoCreate ; } public void setAutoCreate ( boolean autoCreate ) { this . autoCreate = autoCreate ; } } 	1	['10', '3', '0', '11', '17', '33', '3', '11', '9', '0.555555556', '79', '1', '0', '0.666666667', '0.266666667', '1', '1', '6.7', '3', '1.1', '1']
package org . apache . camel . component . xmpp ; import com . sun . jndi . toolkit . url . Uri ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . URISupport ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Map ; public class XmppComponent extends DefaultComponent < XmppExchange > { public static XmppComponent xmppComponent ( ) { return new XmppComponent ( ) ; } public XmppComponent ( ) { } public XmppComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < XmppExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { XmppEndpoint endpoint = new XmppEndpoint ( uri , this ) ; URI u = new URI ( uri ) ; endpoint . setHost ( u . getHost ( ) ) ; endpoint . setPort ( u . getPort ( ) ) ; if ( u . getUserInfo ( ) != null ) { endpoint . setUser ( u . getUserInfo ( ) ) ; } String remainingPath = u . getPath ( ) ; if ( remainingPath != null ) { if ( remainingPath . startsWith ( "/" ) ) { remainingPath = remainingPath . substring ( 1 ) ; } if ( remainingPath . length ( ) > 0 ) { endpoint . setParticipant ( remainingPath ) ; } } return endpoint ; } } 	0	['4', '3', '0', '4', '19', '6', '1', '4', '3', '2', '62', '0', '0', '0.888888889', '0.375', '1', '1', '14.5', '1', '0.5', '0']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . UuidGenerator ; public abstract class MessageSupport implements Message { private static final UuidGenerator defaultIdGenerator = new UuidGenerator ( ) ; private Exchange exchange ; private Object body ; private String messageId = defaultIdGenerator . generateId ( ) ; public Object getBody ( ) { if ( body == null ) { body = createBody ( ) ; } return body ; } @ SuppressWarnings ( { "unchecked" } ) public < T > T getBody ( Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { return e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , getBody ( ) ) ; } return ( T ) getBody ( ) ; } public void setBody ( Object body ) { this . body = body ; } public < T > void setBody ( Object body , Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { T value = e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , body ) ; if ( value != null ) { body = value ; } } setBody ( body ) ; } public Message copy ( ) { Message answer = newInstance ( ) ; answer . setMessageId ( getMessageId ( ) ) ; answer . setBody ( getBody ( ) ) ; answer . getHeaders ( ) . putAll ( getHeaders ( ) ) ; return answer ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public abstract Message newInstance ( ) ; protected Object createBody ( ) { return null ; } public String getMessageId ( ) { return this . messageId ; } public void setMessageId ( String messageId ) { this . messageId = messageId ; } } 	1	['13', '1', '1', '7', '24', '66', '2', '5', '11', '0.770833333', '113', '1', '2', '0', '0.3', '0', '0', '7.384615385', '3', '1.1538', '1']
package org . apache . camel . builder ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . Exchange ; import org . apache . camel . Service ; import org . apache . camel . processor . Resequencer ; import java . util . List ; public class ResequencerBuilder extends FromBuilder { private final List < Expression < Exchange > > expressions ; private long batchTimeout = 1000L ; private int batchSize = 100 ; public ResequencerBuilder ( FromBuilder builder , List < Expression < Exchange > > expressions ) { super ( builder ) ; this . expressions = expressions ; } @ Override public Route createRoute ( ) throws Exception { final Processor processor = super . createProcessor ( ) ; final Resequencer resequencer = new Resequencer ( getFrom ( ) , processor , expressions ) ; return new Route < Exchange > ( getFrom ( ) ) { protected void addServices ( List < Service > list ) throws Exception { list . add ( resequencer ) ; } @ Override public String toString ( ) { return "ResequencerRoute[" + getEndpoint ( ) + " -> " + processor + "]" ; } } ; } public ResequencerBuilder batchSize ( int batchSize ) { setBatchSize ( batchSize ) ; return this ; } public ResequencerBuilder batchTimeout ( int batchTimeout ) { setBatchTimeout ( batchTimeout ) ; return this ; } public int getBatchSize ( ) { return batchSize ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( long batchTimeout ) { this . batchTimeout = batchTimeout ; } } 	0	['8', '3', '0', '6', '13', '14', '2', '6', '8', '0.666666667', '70', '1', '0', '0.909090909', '0.35', '1', '1', '7.375', '1', '0.875', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . UuidGenerator ; import java . util . HashMap ; import java . util . Map ; public class DefaultExchange implements Exchange { private static final UuidGenerator defaultIdGenerator = new UuidGenerator ( ) ; protected final CamelContext context ; private Map < String , Object > headers ; private Message in ; private Message out ; private Message fault ; private Throwable exception ; private String exchangeId = DefaultExchange . defaultIdGenerator . generateId ( ) ; public DefaultExchange ( CamelContext context ) { this . context = context ; } @ Override public String toString ( ) { return "Exchange[" + in + "]" ; } public Exchange copy ( ) { Exchange exchange = newInstance ( ) ; exchange . copyFrom ( this ) ; return exchange ; } public void copyFrom ( Exchange exchange ) { if ( exchange == this ) { return ; } setHeaders ( safeCopy ( exchange . getProperties ( ) ) ) ; setIn ( safeCopy ( exchange . getIn ( ) ) ) ; setOut ( safeCopy ( exchange . getOut ( ) ) ) ; setFault ( safeCopy ( exchange . getFault ( ) ) ) ; setException ( exchange . getException ( ) ) ; } static private Map < String , Object > safeCopy ( Map < String , Object > properties ) { if ( properties == null ) return null ; return new HashMap < String , Object > ( properties ) ; } static private Message safeCopy ( Message message ) { if ( message == null ) return null ; return message . copy ( ) ; } public Exchange newInstance ( ) { return new DefaultExchange ( context ) ; } public CamelContext getContext ( ) { return context ; } public Object getProperty ( String name ) { if ( headers != null ) { return headers . get ( name ) ; } return null ; } public < T > T getProperty ( String name , Class < T > type ) { Object value = getProperty ( name ) ; return getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setProperty ( String name , Object value ) { getProperties ( ) . put ( name , value ) ; } public Map < String , Object > getProperties ( ) { if ( headers == null ) { headers = new HashMap < String , Object > ( ) ; } return headers ; } public void setHeaders ( Map < String , Object > headers ) { this . headers = headers ; } public Message getIn ( ) { if ( in == null ) { in = createInMessage ( ) ; configureMessage ( in ) ; } return in ; } public void setIn ( Message in ) { this . in = in ; configureMessage ( in ) ; } public Message getOut ( ) { return getOut ( true ) ; } public Message getOut ( boolean lazyCreate ) { if ( out == null && lazyCreate ) { out = createOutMessage ( ) ; configureMessage ( out ) ; } return out ; } public void setOut ( Message out ) { this . out = out ; configureMessage ( out ) ; } public Throwable getException ( ) { return exception ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Message getFault ( ) { return fault ; } public void setFault ( Message fault ) { this . fault = fault ; configureMessage ( fault ) ; } public String getExchangeId ( ) { return exchangeId ; } public void setExchangeId ( String id ) { this . exchangeId = id ; } protected Message createInMessage ( ) { return new DefaultMessage ( ) ; } protected Message createOutMessage ( ) { return new DefaultMessage ( ) ; } protected void configureMessage ( Message message ) { if ( message instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) message ; messageSupport . setExchange ( this ) ; } } } 	1	['28', '1', '11', '23', '50', '346', '16', '7', '22', '0.888888889', '258', '1', '5', '0', '0.155555556', '0', '0', '7.928571429', '3', '1.25', '1']
package org . apache . camel . spring . xml ; import java . lang . annotation . Annotation ; import java . lang . reflect . Array ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Set ; import java . util . Map ; import org . apache . camel . Expression ; import org . apache . camel . builder . Fluent ; import org . apache . camel . builder . FluentArg ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . builder . ValueBuilder ; import org . springframework . beans . SimpleTypeConverter ; import org . springframework . beans . factory . config . RuntimeBeanReference ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . ChildBeanDefinition ; import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . StringUtils ; import org . springframework . util . xml . DomUtils ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class CamelBeanDefinitionParser extends AbstractBeanDefinitionParser { private final CamelNamespaceHandler namespaceHandler ; private int counter ; public CamelBeanDefinitionParser ( CamelNamespaceHandler namespaceHandler ) { this . namespaceHandler = namespaceHandler ; } protected AbstractBeanDefinition parseInternal ( Element element , ParserContext parserContext ) { BeanDefinitionBuilder factory = BeanDefinitionBuilder . rootBeanDefinition ( RouteBuilderFactoryBean . class ) ; List childElements = DomUtils . getChildElementsByTagName ( element , "route" ) ; ArrayList < BuilderStatement > routes = new ArrayList < BuilderStatement > ( childElements . size ( ) ) ; if ( childElements != null && childElements . size ( ) > 0 ) { for ( int i = 0 ; i < childElements . size ( ) ; ++ i ) { Element routeElement = ( Element ) childElements . get ( i ) ; ArrayList < BuilderAction > actions = new ArrayList < BuilderAction > ( ) ; Class type = parseBuilderElement ( parserContext , routeElement , RouteBuilder . class , actions ) ; BuilderStatement statement = new BuilderStatement ( ) ; statement . setReturnType ( type ) ; statement . setActions ( actions ) ; routes . add ( statement ) ; } } factory . addPropertyValue ( "routes" , routes ) ; return factory . getBeanDefinition ( ) ; } private Class parseBuilderElement ( ParserContext parserContext , Element element , Class < RouteBuilder > builder , ArrayList < BuilderAction > actions ) { Class currentBuilder = builder ; NodeList childElements = element . getChildNodes ( ) ; Element previousElement = null ; for ( int i = 0 ; i < childElements . getLength ( ) ; ++ i ) { Node node = childElements . item ( i ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { currentBuilder = parseAction ( parserContext , currentBuilder , actions , ( Element ) node , previousElement ) ; previousElement = ( Element ) node ; BuilderAction action = actions . get ( actions . size ( ) - 1 ) ; if ( action . getMethodInfo ( ) . methodAnnotation . nestedActions ( ) ) { currentBuilder = parseBuilderElement ( parserContext , ( Element ) node , currentBuilder , actions ) ; } else { if ( hasChildElements ( node ) ) { throw new IllegalArgumentException ( "The element " + node . getLocalName ( ) + " should not have any child elements." ) ; } } } } if ( currentBuilder != null ) { Method [ ] methods = currentBuilder . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; Fluent annotation = method . getAnnotation ( Fluent . class ) ; if ( annotation != null && annotation . callOnElementEnd ( ) ) { if ( method . getParameterTypes ( ) . length > 0 ) { throw new RuntimeException ( "Only methods with no parameters can annotated with @Fluent(callOnElementEnd=true): " + method ) ; } MethodInfo methodInfo = new MethodInfo ( method , annotation , new LinkedHashMap < String , Class > ( ) , new LinkedHashMap < String , FluentArg > ( ) ) ; actions . add ( new BuilderAction ( methodInfo , new HashMap < String , Object > ( ) ) ) ; currentBuilder = method . getReturnType ( ) ; } } } return currentBuilder ; } private boolean hasChildElements ( Node node ) { NodeList nl = node . getChildNodes ( ) ; for ( int j = 0 ; j < nl . getLength ( ) ; ++ j ) { if ( nl . item ( j ) . getNodeType ( ) == Node . ELEMENT_NODE ) { return true ; } } return false ; } private Class parseAction ( ParserContext parserContext , Class currentBuilder , ArrayList < BuilderAction > actions , Element element , Element previousElement ) { String actionName = element . getLocalName ( ) ; ArrayList < MethodInfo > methods = findFluentMethodsWithName ( currentBuilder , element . getLocalName ( ) ) ; if ( methods . isEmpty ( ) ) { throw new IllegalActionException ( actionName , previousElement == null ? null : previousElement . getLocalName ( ) ) ; } Collections . sort ( methods , new Comparator < MethodInfo > ( ) { public int compare ( MethodInfo m1 , MethodInfo m2 ) { return m1 . method . getParameterTypes ( ) . length - m2 . method . getParameterTypes ( ) . length ; } } ) ; HashMap < String , Object > attributeArguments = getArugmentsFromAttributes ( element ) ; HashMap < String , ArrayList < Element > > elementArguments = getArgumentsFromElements ( element ) ; MethodInfo match = null ; match = findMethodMatch ( methods , attributeArguments . keySet ( ) , elementArguments . keySet ( ) ) ; if ( match == null ) throw new IllegalActionException ( actionName , previousElement == null ? null : previousElement . getLocalName ( ) ) ; Set < Map . Entry < String , Object > > attributeEntries = attributeArguments . entrySet ( ) ; for ( Map . Entry < String , Object > entry : attributeEntries ) { String name = entry . getKey ( ) ; FluentArg arg = match . parameterAnnotations . get ( name ) ; if ( arg != null && ( arg . reference ( ) || name . equals ( "ref" ) ) ) { Object value = entry . getValue ( ) ; if ( value instanceof String ) { entry . setValue ( new RuntimeBeanReference ( value . toString ( ) ) ) ; } } } Set < String > parameterNames = new HashSet < String > ( match . parameters . keySet ( ) ) ; parameterNames . removeAll ( attributeArguments . keySet ( ) ) ; for ( String key : parameterNames ) { ArrayList < Element > elements = elementArguments . get ( key ) ; if ( elements == null ) { elements = getFirstChildElements ( element ) ; } Class clazz = match . parameters . get ( key ) ; Object value = convertTo ( parserContext , elements , clazz ) ; attributeArguments . put ( key , value ) ; for ( Element el : elements ) { el . getParentNode ( ) . removeChild ( el ) ; } } actions . add ( new BuilderAction ( match , attributeArguments ) ) ; return match . method . getReturnType ( ) ; } private ArrayList < Element > getFirstChildElements ( Element element ) { ArrayList < Element > answer = new ArrayList < Element > ( ) ; NodeList list = element . getChildNodes ( ) ; for ( int i = 0 , size = list . getLength ( ) ; i < size ; i ++ ) { Node node = list . item ( i ) ; if ( node instanceof Element ) { answer . add ( ( Element ) node ) ; break ; } } return answer ; } private Object convertTo ( ParserContext parserContext , ArrayList < Element > elements , Class clazz ) { if ( clazz . isArray ( ) || elements . size ( ) > 1 ) { List list = new ArrayList ( ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { ArrayList < Element > e = new ArrayList < Element > ( 1 ) ; e . add ( elements . get ( i ) ) ; Object value = convertTo ( parserContext , e , clazz . getComponentType ( ) ) ; list . add ( value ) ; } return list ; } else { Element element = elements . get ( 0 ) ; String ref = element . getAttribute ( "ref" ) ; if ( StringUtils . hasText ( ref ) ) { return new RuntimeBeanReference ( ref ) ; } if ( hasChildElements ( element ) ) { ArrayList < BuilderAction > actions = new ArrayList < BuilderAction > ( ) ; Class type = parseBuilderElement ( parserContext , element , RouteBuilder . class , actions ) ; if ( type == ValueBuilder . class && clazz == Expression . class ) { Method method ; try { method = ValueBuilder . class . getMethod ( "getExpression" , new Class [ ] { } ) ; } catch ( Throwable e ) { throw new RuntimeException ( ValueBuilder . class . getName ( ) + " does not have the getExpression() method." ) ; } MethodInfo methodInfo = new MethodInfo ( method , null , new LinkedHashMap < String , Class > ( ) , new LinkedHashMap < String , FluentArg > ( ) ) ; actions . add ( new BuilderAction ( methodInfo , new HashMap < String , Object > ( ) ) ) ; type = Expression . class ; } BuilderStatement statement = new BuilderStatement ( ) ; statement . setReturnType ( type ) ; statement . setActions ( actions ) ; if ( ! clazz . isAssignableFrom ( statement . getReturnType ( ) ) ) { throw new IllegalStateException ( "Builder does not produce object of expected type: " + clazz . getName ( ) + ", it produced: " + statement . getReturnType ( ) ) ; } return statement ; } else { String name = element . getLocalName ( ) ; if ( namespaceHandler . getParserElementNames ( ) . contains ( name ) ) { String id = createBeanId ( name ) ; element . setAttribute ( "id" , id ) ; namespaceHandler . parse ( element , parserContext ) ; return new RuntimeBeanReference ( id ) ; } SimpleTypeConverter converter = new SimpleTypeConverter ( ) ; return converter . convertIfNecessary ( element . getTextContent ( ) , clazz ) ; } } } protected synchronized String createBeanId ( String name ) { return "_internal:camel:bean:" + name + ( ++ counter ) ; } private MethodInfo findMethodMatch ( ArrayList < MethodInfo > methods , Set < String > attributeNames , Set < String > elementNames ) { for ( MethodInfo method : methods ) { boolean miss = false ; for ( String key : attributeNames ) { FluentArg arg = method . parameterAnnotations . get ( key ) ; if ( arg == null || ! arg . attribute ( ) ) { miss = true ; break ; } } if ( miss ) continue ; Set < String > parameterNames = new HashSet < String > ( method . parameters . keySet ( ) ) ; parameterNames . removeAll ( attributeNames ) ; if ( parameterNames . isEmpty ( ) ) { return method ; } return method ; } return null ; } private LinkedHashMap < String , ArrayList < Element > > getArgumentsFromElements ( Element element ) { LinkedHashMap < String , ArrayList < Element > > elements = new LinkedHashMap < String , ArrayList < Element > > ( ) ; NodeList childNodes = element . getChildNodes ( ) ; String lastTag = null ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node node = childNodes . item ( i ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { Element el = ( Element ) node ; String tag = el . getLocalName ( ) ; ArrayList < Element > els = elements . get ( tag ) ; if ( els == null ) { els = new ArrayList < Element > ( ) ; elements . put ( el . getLocalName ( ) , els ) ; els . add ( el ) ; lastTag = tag ; } else { if ( tag . equals ( lastTag ) ) { els . add ( el ) ; lastTag = tag ; } } } } return elements ; } private HashMap < String , Object > getArugmentsFromAttributes ( Element element ) { HashMap < String , Object > attributes = new HashMap < String , Object > ( ) ; NamedNodeMap childNodes = element . getAttributes ( ) ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node node = childNodes . item ( i ) ; if ( node . getNodeType ( ) == Node . ATTRIBUTE_NODE ) { Attr attr = ( Attr ) node ; String str = attr . getValue ( ) ; Object value = str ; if ( str . startsWith ( "#" ) ) { str = str . substring ( 1 ) ; if ( ! str . startsWith ( "#" ) ) { value = new RuntimeBeanReference ( str ) ; } } attributes . put ( attr . getName ( ) , value ) ; } } return attributes ; } private ArrayList < MethodInfo > findFluentMethodsWithName ( Class clazz , String name ) { ArrayList < MethodInfo > rc = new ArrayList < MethodInfo > ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; if ( ! method . isAnnotationPresent ( Fluent . class ) ) { continue ; } Fluent fluentAnnotation = method . getAnnotation ( Fluent . class ) ; if ( StringUtils . hasText ( fluentAnnotation . value ( ) ) ? name . equals ( fluentAnnotation . value ( ) ) : name . equals ( method . getName ( ) ) ) { LinkedHashMap < String , Class > map = new LinkedHashMap < String , Class > ( ) ; LinkedHashMap < String , FluentArg > amap = new LinkedHashMap < String , FluentArg > ( ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( int j = 0 ; j < parameters . length ; j ++ ) { Class < ? > parameter = parameters [ j ] ; FluentArg annotation = getParameterAnnotation ( FluentArg . class , method , j ) ; if ( annotation != null ) { map . put ( annotation . value ( ) , parameter ) ; amap . put ( annotation . value ( ) , annotation ) ; } else { break ; } } if ( parameters . length == map . size ( ) ) { rc . add ( new MethodInfo ( method , fluentAnnotation , map , amap ) ) ; } } } return rc ; } private < T > T getParameterAnnotation ( Class < T > annotationClass , Method method , int index ) { Annotation [ ] annotations = method . getParameterAnnotations ( ) [ index ] ; for ( int i = 0 ; i < annotations . length ; i ++ ) { if ( annotationClass . isAssignableFrom ( annotations [ i ] . getClass ( ) ) ) { return ( T ) annotations [ i ] ; } } return null ; } } 	0	['13', '2', '0', '18', '112', '76', '3', '17', '1', '0.875', '1000', '1', '1', '0.4', '0.272727273', '1', '1', '75.76923077', '10', '5.2308', '0']
package org . apache . camel . builder . xml ; import org . apache . camel . Exchange ; import org . apache . camel . ExpectedBodyTypeException ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeTransformException ; import org . apache . camel . converter . jaxp . XmlConverter ; import static org . apache . camel . util . ObjectHelper . notNull ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . stream . StreamSource ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class XsltBuilder implements Processor { private Map < String , Object > parameters = new HashMap < String , Object > ( ) ; private XmlConverter converter = new XmlConverter ( ) ; private Transformer transformer ; private ResultHandler resultHandler = new StringResultHandler ( ) ; private boolean failOnNullBody = true ; public XsltBuilder ( ) { } public XsltBuilder ( Transformer transformer ) { this . transformer = transformer ; } @ Override public String toString ( ) { return "XSLT[" + transformer + "]" ; } public synchronized void process ( Exchange exchange ) throws Exception { Transformer transformer = getTransformer ( ) ; if ( transformer == null ) { throw new IllegalArgumentException ( "No transformer configured!" ) ; } configureTransformer ( transformer , exchange ) ; Source source = getSource ( exchange ) ; Result result = resultHandler . getResult ( ) ; transformer . transform ( source , result ) ; resultHandler . setBody ( exchange . getIn ( ) ) ; } public static XsltBuilder xslt ( Transformer transformer ) { return new XsltBuilder ( transformer ) ; } public static XsltBuilder xslt ( Source xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; XsltBuilder answer = new XsltBuilder ( ) ; answer . setTransformerSource ( xslt ) ; return answer ; } public static XsltBuilder xslt ( File xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public static XsltBuilder xslt ( URL xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( xslt . openStream ( ) ) ; } public static XsltBuilder xslt ( InputStream xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public XsltBuilder outputBytes ( ) { setResultHandler ( new StreamResultHandler ( ) ) ; return this ; } public XsltBuilder outputString ( ) { setResultHandler ( new StringResultHandler ( ) ) ; return this ; } public XsltBuilder outputDOM ( ) { setResultHandler ( new DomResultHandler ( ) ) ; return this ; } public XsltBuilder parameter ( String name , Object value ) { parameters . put ( name , value ) ; return this ; } public Map < String , Object > getParameters ( ) { return parameters ; } public void setParameters ( Map < String , Object > parameters ) { this . parameters = parameters ; } public Transformer getTransformer ( ) { return transformer ; } public void setTransformer ( Transformer transformer ) { this . transformer = transformer ; } public boolean isFailOnNullBody ( ) { return failOnNullBody ; } public void setFailOnNullBody ( boolean failOnNullBody ) { this . failOnNullBody = failOnNullBody ; } public ResultHandler getResultHandler ( ) { return resultHandler ; } public void setResultHandler ( ResultHandler resultHandler ) { this . resultHandler = resultHandler ; } public void setTransformerSource ( Source source ) throws TransformerConfigurationException { setTransformer ( converter . getTransformerFactory ( ) . newTransformer ( source ) ) ; } protected Source getSource ( Exchange exchange ) { Message in = exchange . getIn ( ) ; Source source = in . getBody ( Source . class ) ; if ( source == null ) { if ( isFailOnNullBody ( ) ) { throw new ExpectedBodyTypeException ( exchange , Source . class ) ; } else { try { source = converter . toSource ( converter . createDocument ( ) ) ; } catch ( ParserConfigurationException e ) { throw new RuntimeTransformException ( e ) ; } } } return source ; } protected void configureTransformer ( Transformer transformer , Exchange exchange ) { transformer . clearParameters ( ) ; addParameters ( transformer , exchange . getProperties ( ) ) ; addParameters ( transformer , exchange . getIn ( ) . getHeaders ( ) ) ; addParameters ( transformer , getParameters ( ) ) ; transformer . setParameter ( "exchange" , exchange ) ; transformer . setParameter ( "in" , exchange . getIn ( ) ) ; transformer . setParameter ( "out" , exchange . getOut ( ) ) ; } protected void addParameters ( Transformer transformer , Map < String , Object > map ) { Set < Map . Entry < String , Object > > propertyEntries = map . entrySet ( ) ; for ( Map . Entry < String , Object > entry : propertyEntries ) { transformer . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } 	1	['25', '1', '0', '11', '63', '230', '0', '11', '22', '0.65', '316', '1', '2', '0', '0.13', '0', '0', '11.44', '3', '1.04', '1']
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class ConstantProcessorBuilder implements ProcessorFactory { private Processor processor ; public ConstantProcessorBuilder ( Processor processor ) { this . processor = processor ; } public Processor createProcessor ( ) { return processor ; } } 	0	['2', '1', '0', '4', '3', '0', '2', '2', '2', '0', '12', '1', '1', '0', '0.75', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . camel ; public interface Processor { void process ( Exchange exchange ) throws Exception ; } 	1	['1', '1', '0', '126', '1', '0', '125', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . cxf ; import java . net . URI ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . cxf . Bus ; import org . apache . cxf . BusException ; import org . apache . cxf . bus . CXFBusFactory ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . DestinationFactoryManager ; import org . apache . cxf . transport . local . LocalTransportFactory ; import org . xmlsoap . schemas . wsdl . http . AddressType ; public class CxfComponent extends DefaultComponent < CxfExchange > { private LocalTransportFactory localTransportFactory ; public CxfComponent ( ) { } public CxfComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < CxfExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { URI u = new URI ( remaining ) ; EndpointInfo endpointInfo = new EndpointInfo ( null , "http://schemas.xmlsoap.org/soap/http" ) ; AddressType a = new AddressType ( ) ; a . setLocation ( remaining ) ; endpointInfo . addExtensor ( a ) ; return new CxfEndpoint ( uri , this , endpointInfo ) ; } public LocalTransportFactory getLocalTransportFactory ( ) throws BusException { if ( localTransportFactory == null ) { localTransportFactory = findLocalTransportFactory ( ) ; if ( localTransportFactory == null ) { localTransportFactory = new LocalTransportFactory ( ) ; } } return localTransportFactory ; } public void setLocalTransportFactory ( LocalTransportFactory localTransportFactory ) { this . localTransportFactory = localTransportFactory ; } protected LocalTransportFactory findLocalTransportFactory ( ) throws BusException { Bus bus = CXFBusFactory . getDefaultBus ( ) ; DestinationFactoryManager dfm = bus . getExtension ( DestinationFactoryManager . class ) ; return ( LocalTransportFactory ) dfm . getDestinationFactory ( LocalTransportFactory . TRANSPORT_ID ) ; } } 	0	['6', '3', '0', '13', '18', '13', '1', '13', '4', '0.8', '76', '1', '0', '0.8', '0.333333333', '1', '1', '11.5', '1', '0.6667', '0']
package org . apache . camel . converter ; import org . apache . camel . Converter ; import java . io . * ; import java . nio . ByteBuffer ; @ Converter public class NIOConverter { @ Converter public static byte [ ] toByteArray ( ByteBuffer buffer ) { return buffer . array ( ) ; } @ Converter public static ByteBuffer toByteBuffer ( byte [ ] data ) { return ByteBuffer . wrap ( data ) ; } @ Converter public static ByteBuffer toByteBuffer ( String value ) { ByteBuffer buf = ByteBuffer . allocate ( value . length ( ) ) ; byte [ ] bytes = value . getBytes ( ) ; buf . put ( bytes ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Short value ) { ByteBuffer buf = ByteBuffer . allocate ( 2 ) ; buf . putShort ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Integer value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Long value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putLong ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Float value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putFloat ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Double value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putDouble ( value ) ; return buf ; } } 	1	['9', '1', '0', '1', '26', '36', '1', '0', '9', '2', '81', '0', '0', '0', '0.111111111', '0', '0', '8', '1', '0.8889', '1']
package org . apache . camel ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ProducerCache ; import java . util . HashMap ; import java . util . Map ; public class CamelTemplate < E extends Exchange > extends ServiceSupport { private CamelContext context ; private ProducerCache < E > producerCache = new ProducerCache < E > ( ) ; private boolean useEndpointCache = true ; private Map < String , Endpoint < E > > endpointCache = new HashMap < String , Endpoint < E > > ( ) ; private Endpoint < E > defaultEndpoint ; public CamelTemplate ( CamelContext context ) { this . context = context ; } public CamelTemplate ( CamelContext context , Endpoint defaultEndpoint ) { this ( context ) ; this . defaultEndpoint = defaultEndpoint ; } public E send ( String endpointUri , E exchange ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; send ( endpoint , exchange ) ; return exchange ; } public E send ( String endpointUri , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor ) ; } public E send ( Endpoint < E > endpoint , E exchange ) { E convertedExchange = endpoint . toExchangeType ( exchange ) ; producerCache . send ( endpoint , convertedExchange ) ; return exchange ; } public E send ( Endpoint < E > endpoint , Processor processor ) { return producerCache . send ( endpoint , processor ) ; } public Object sendBody ( Endpoint < E > endpoint , final Object body ) { E result = send ( endpoint , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , final Object body ) { E result = send ( endpointUri , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , final Object body , final String header , final Object headerValue ) { E result = send ( endpointUri , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setHeader ( header , headerValue ) ; in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , final Object body , final Map < String , Object > headers ) { E result = send ( endpointUri , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; for ( Map . Entry < String , Object > header : headers . entrySet ( ) ) { in . setHeader ( header . getKey ( ) , header . getValue ( ) ) ; } in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBody ( Object body ) { return sendBody ( getMandatoryDefaultEndpoint ( ) , body ) ; } public E send ( E exchange ) { return send ( getMandatoryDefaultEndpoint ( ) , exchange ) ; } public E send ( Processor processor ) { return send ( getMandatoryDefaultEndpoint ( ) , processor ) ; } public Producer < E > getProducer ( Endpoint < E > endpoint ) { return producerCache . getProducer ( endpoint ) ; } public CamelContext getContext ( ) { return context ; } public Endpoint < E > getDefaultEndpoint ( ) { return defaultEndpoint ; } public void setDefaultEndpoint ( Endpoint < E > defaultEndpoint ) { this . defaultEndpoint = defaultEndpoint ; } public void setDefaultEndpointUri ( String endpointUri ) { setDefaultEndpoint ( getContext ( ) . getEndpoint ( endpointUri ) ) ; } public boolean isUseEndpointCache ( ) { return useEndpointCache ; } public void setUseEndpointCache ( boolean useEndpointCache ) { this . useEndpointCache = useEndpointCache ; } protected Endpoint resolveMandatoryEndpoint ( String endpointUri ) { Endpoint endpoint = null ; if ( isUseEndpointCache ( ) ) { synchronized ( endpointCache ) { endpoint = endpointCache . get ( endpointUri ) ; if ( endpoint == null ) { endpoint = context . getEndpoint ( endpointUri ) ; if ( endpoint != null ) { endpointCache . put ( endpointUri , endpoint ) ; } } } } else { endpoint = context . getEndpoint ( endpointUri ) ; } if ( endpoint == null ) { throw new NoSuchEndpointException ( endpointUri ) ; } return endpoint ; } protected Endpoint < E > getMandatoryDefaultEndpoint ( ) { Endpoint < E > answer = getDefaultEndpoint ( ) ; ObjectHelper . notNull ( answer , "defaultEndpoint" ) ; return answer ; } protected void doStart ( ) throws Exception { producerCache . start ( ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; } protected Object extractResultBody ( E result ) { return result != null ? result . getOut ( ) . getBody ( ) : null ; } } 	0	['25', '2', '0', '18', '45', '252', '8', '14', '20', '0.675', '273', '1', '3', '0.233333333', '0.24', '1', '1', '9.72', '5', '1.12', '0']
package org . apache . camel . component . file ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . channels . FileChannel ; public class FileConsumer extends ScheduledPollConsumer < FileExchange > { private static final transient Log log = LogFactory . getLog ( FileConsumer . class ) ; private final FileEndpoint endpoint ; private boolean recursive = true ; private boolean attemptFileLock = false ; private String regexPattern = "" ; private long lastPollTime = 0l ; public FileConsumer ( final FileEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } protected void poll ( ) throws Exception { pollFileOrDirectory ( endpoint . getFile ( ) , isRecursive ( ) ) ; lastPollTime = System . currentTimeMillis ( ) ; } protected void pollFileOrDirectory ( File fileOrDirectory , boolean processDir ) { if ( ! fileOrDirectory . isDirectory ( ) ) { pollFile ( fileOrDirectory ) ; } else if ( processDir ) { log . debug ( "Polling directory " + fileOrDirectory ) ; File [ ] files = fileOrDirectory . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { pollFileOrDirectory ( files [ i ] , isRecursive ( ) ) ; } } else { log . debug ( "Skipping directory " + fileOrDirectory ) ; } } protected void pollFile ( final File file ) { if ( file . exists ( ) && file . lastModified ( ) > lastPollTime ) { if ( isValidFile ( file ) ) { processFile ( file ) ; } } } protected void processFile ( File file ) { try { getProcessor ( ) . process ( endpoint . createExchange ( file ) ) ; } catch ( Throwable e ) { handleException ( e ) ; } } protected boolean isValidFile ( File file ) { boolean result = false ; if ( file != null && file . exists ( ) ) { if ( isMatched ( file ) ) { if ( isAttemptFileLock ( ) ) { FileChannel fc = null ; try { fc = new RandomAccessFile ( file , "rw" ) . getChannel ( ) ; fc . lock ( ) ; result = true ; } catch ( Throwable e ) { log . debug ( "Failed to get the lock on file: " + file , e ) ; } finally { if ( fc != null ) { try { fc . close ( ) ; } catch ( IOException e ) { } } } } else { result = true ; } } } return result ; } protected boolean isMatched ( File file ) { boolean result = true ; if ( regexPattern != null && regexPattern . length ( ) > 0 ) { result = file . getName ( ) . matches ( getRegexPattern ( ) ) ; } return result ; } public boolean isRecursive ( ) { return this . recursive ; } public void setRecursive ( boolean recursive ) { this . recursive = recursive ; } public boolean isAttemptFileLock ( ) { return this . attemptFileLock ; } public void setAttemptFileLock ( boolean attemptFileLock ) { this . attemptFileLock = attemptFileLock ; } public String getRegexPattern ( ) { return this . regexPattern ; } public void setRegexPattern ( String regexPattern ) { this . regexPattern = regexPattern ; } } 	1	['14', '4', '0', '8', '39', '51', '1', '8', '7', '0.730769231', '240', '1', '1', '0.692307692', '0.307692308', '1', '1', '15.71428571', '6', '1.7143', '1']
package org . apache . camel . component . mail ; import javax . mail . MessagingException ; public class MessageHeaderAccessException extends RuntimeMailException { private static final long serialVersionUID = - 3996286386119163309L ; private String propertyName ; public MessageHeaderAccessException ( String propertyName , MessagingException e ) { super ( "Error accessing header: " + propertyName , e ) ; this . propertyName = propertyName ; } public String getPropertyName ( ) { return propertyName ; } } 	0	['2', '5', '0', '2', '6', '0', '1', '1', '2', '1', '22', '1', '0', '0.944444444', '0.666666667', '0', '0', '9', '1', '0.5', '0']
package org . apache . camel . impl ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . Service ; public abstract class ServiceSupport implements Service { private AtomicBoolean started = new AtomicBoolean ( false ) ; private AtomicBoolean stopping = new AtomicBoolean ( false ) ; private AtomicBoolean stopped = new AtomicBoolean ( false ) ; public void start ( ) throws Exception { if ( started . compareAndSet ( false , true ) ) { doStart ( ) ; } } public void stop ( ) throws Exception { if ( stopped . compareAndSet ( false , true ) ) { stopping . set ( true ) ; try { doStop ( ) ; } finally { stopped . set ( true ) ; started . set ( false ) ; stopping . set ( false ) ; } } } public boolean isStarted ( ) { return started . get ( ) ; } public boolean isStopping ( ) { return stopping . get ( ) ; } public boolean isStopped ( ) { return stopped . get ( ) ; } protected abstract void doStart ( ) throws Exception ; protected abstract void doStop ( ) throws Exception ; } 	1	['8', '1', '25', '26', '13', '8', '25', '1', '6', '0.666666667', '94', '1', '0', '0', '1', '0', '0', '10.375', '1', '0.875', '1']
package org . apache . camel . processor ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . util . ServiceHelper ; import org . apache . camel . impl . ServiceSupport ; import java . util . ArrayList ; import java . util . List ; public class ChoiceProcessor extends ServiceSupport implements Processor { private List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; private Processor otherwise ; public ChoiceProcessor ( List < FilterProcessor > filters , Processor otherwise ) { this . filters = filters ; this . otherwise = otherwise ; } public void process ( Exchange exchange ) throws Exception { for ( FilterProcessor filterProcessor : filters ) { Predicate < Exchange > predicate = filterProcessor . getPredicate ( ) ; if ( predicate != null && predicate . matches ( exchange ) ) { filterProcessor . getProcessor ( ) . process ( exchange ) ; return ; } } if ( otherwise != null ) { otherwise . process ( exchange ) ; } } @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( "choice{" ) ; boolean first = true ; for ( FilterProcessor processor : filters ) { if ( first ) { first = false ; } else { builder . append ( ", " ) ; } builder . append ( "when " ) ; builder . append ( processor . getPredicate ( ) . toString ( ) ) ; builder . append ( ": " ) ; builder . append ( processor . getProcessor ( ) ) ; } if ( otherwise != null ) { builder . append ( ", otherwise: " ) ; builder . append ( otherwise ) ; } builder . append ( "}" ) ; return builder . toString ( ) ; } public List < FilterProcessor > getFilters ( ) { return filters ; } public Processor getOtherwise ( ) { return otherwise ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( filters ) ; ServiceHelper . startServices ( otherwise ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( otherwise ) ; ServiceHelper . stopServices ( filters ) ; } } 	0	['7', '2', '0', '7', '25', '0', '1', '6', '5', '0.166666667', '153', '1', '1', '0.538461538', '0.357142857', '1', '1', '20.57142857', '4', '1.2857', '0']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . Route ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Service ; import org . apache . camel . TypeConverter ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . impl . converter . DefaultTypeConverter ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; public class DefaultCamelContext extends ServiceSupport implements CamelContext , Service { private Map < String , Endpoint > endpoints = new HashMap < String , Endpoint > ( ) ; private Map < String , Component > components = new HashMap < String , Component > ( ) ; private List < Route > routes ; private List < Service > servicesToClose = new ArrayList < Service > ( ) ; private TypeConverter typeConverter ; private ExchangeConverter exchangeConverter ; private Injector injector ; private ComponentResolver componentResolver ; private boolean autoCreateComponents = true ; public void addComponent ( String componentName , final Component component ) { if ( component == null ) { throw new IllegalArgumentException ( "Component cannot be null" ) ; } synchronized ( components ) { if ( components . containsKey ( componentName ) ) { throw new IllegalArgumentException ( "Component previously added: " + componentName ) ; } component . setCamelContext ( this ) ; components . put ( componentName , component ) ; } } public Component getComponent ( String name ) { synchronized ( components ) { Component component = components . get ( name ) ; if ( component == null && autoCreateComponents ) { try { component = getComponentResolver ( ) . resolveComponent ( name , this ) ; if ( component != null ) { addComponent ( name , component ) ; if ( isStarted ( ) ) { startServices ( component ) ; } } } catch ( Exception e ) { throw new RuntimeCamelException ( "Could not auto create component: " + name , e ) ; } } return component ; } } public < T extends Component > T getComponent ( String name , Class < T > componentType ) { Component component = getComponent ( name ) ; if ( componentType . isInstance ( component ) ) { return componentType . cast ( component ) ; } else { throw new IllegalArgumentException ( "The component is not of type: " + componentType + " but is: " + component ) ; } } public Component removeComponent ( String componentName ) { synchronized ( components ) { return components . remove ( componentName ) ; } } public Component getOrCreateComponent ( String componentName , Callable < Component > factory ) { synchronized ( components ) { Component component = components . get ( componentName ) ; if ( component == null ) { try { component = factory . call ( ) ; if ( component == null ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component, it returned null." ) ; } components . put ( componentName , component ) ; component . setCamelContext ( this ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component" , e ) ; } } return component ; } } public Collection < Endpoint > getSingletonEndpoints ( ) { synchronized ( endpoints ) { return new ArrayList < Endpoint > ( endpoints . values ( ) ) ; } } public Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { startServices ( endpoint ) ; oldEndpoint = endpoints . remove ( uri ) ; endpoints . put ( uri , endpoint ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint removeSingletonEndpoint ( String uri ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { oldEndpoint = endpoints . remove ( uri ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint getEndpoint ( String uri ) { Endpoint answer ; synchronized ( endpoints ) { answer = endpoints . get ( uri ) ; if ( answer == null ) { try { String splitURI [ ] = ObjectHelper . splitOnCharacter ( uri , ":" , 2 ) ; if ( splitURI [ 1 ] == null ) { throw new IllegalArgumentException ( "Invalid URI, it did not contain a scheme: " + uri ) ; } String scheme = splitURI [ 0 ] ; Component component = getComponent ( scheme ) ; if ( component != null ) { answer = component . createEndpoint ( uri ) ; if ( answer != null && answer . isSingleton ( ) ) { if ( answer != null ) { startServices ( answer ) ; endpoints . put ( uri , answer ) ; } } } } catch ( Exception e ) { throw new ResolveEndpointFailedException ( uri , e ) ; } } } return answer ; } public < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) { Endpoint endpoint = getEndpoint ( name ) ; if ( endpointType . isInstance ( endpoint ) ) { return endpointType . cast ( endpoint ) ; } else { throw new IllegalArgumentException ( "The endpoint is not of type: " + endpointType + " but is: " + endpoint ) ; } } public List < Route > getRoutes ( ) { return routes ; } public void setRoutes ( List < Route > routes ) { this . routes = routes ; } public void addRoutes ( Collection < Route > routes ) throws Exception { if ( this . routes == null ) { this . routes = new ArrayList < Route > ( routes ) ; } else { this . routes . addAll ( routes ) ; } if ( isStarted ( ) ) { startRoutes ( routes ) ; } } public void addRoutes ( RouteBuilder builder ) throws Exception { builder . setContext ( this ) ; addRoutes ( builder . getRouteList ( ) ) ; } public ExchangeConverter getExchangeConverter ( ) { if ( exchangeConverter == null ) { exchangeConverter = createExchangeConverter ( ) ; } return exchangeConverter ; } public void setExchangeConverter ( ExchangeConverter exchangeConverter ) { this . exchangeConverter = exchangeConverter ; } public TypeConverter getTypeConverter ( ) { if ( typeConverter == null ) { typeConverter = createTypeConverter ( ) ; } return typeConverter ; } public void setTypeConverter ( TypeConverter typeConverter ) { this . typeConverter = typeConverter ; } public Injector getInjector ( ) { if ( injector == null ) { injector = createInjector ( ) ; } return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } public ComponentResolver getComponentResolver ( ) { if ( componentResolver == null ) { componentResolver = createComponentResolver ( ) ; } return componentResolver ; } public void setComponentResolver ( ComponentResolver componentResolver ) { this . componentResolver = componentResolver ; } protected void doStart ( ) throws Exception { if ( components != null ) { for ( Component component : components . values ( ) ) { startServices ( component ) ; } } startRoutes ( routes ) ; } protected void doStop ( ) throws Exception { stopServices ( servicesToClose ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { stopServices ( component ) ; } } } protected void startRoutes ( Collection < Route > routeList ) throws Exception { if ( routeList != null ) { for ( Route < Exchange > route : routeList ) { List < Service > services = route . getServicesForRoute ( ) ; servicesToClose . addAll ( services ) ; startServices ( services ) ; } } } protected ExchangeConverter createExchangeConverter ( ) { return new DefaultExchangeConverter ( ) ; } protected TypeConverter createTypeConverter ( ) { return new DefaultTypeConverter ( ) ; } protected Injector createInjector ( ) { FactoryFinder finder = new FactoryFinder ( ) ; try { return ( Injector ) finder . newInstance ( "Injector" ) ; } catch ( NoFactoryAvailableException e ) { return new ReflectionInjector ( ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e ) ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeCamelException ( e ) ; } } protected ComponentResolver createComponentResolver ( ) { return new DefaultComponentResolver ( ) ; } public boolean isAutoCreateComponents ( ) { return autoCreateComponents ; } public void setAutoCreateComponents ( boolean autoCreateComponents ) { this . autoCreateComponents = autoCreateComponents ; } } 	1	['32', '2', '1', '22', '76', '400', '2', '21', '25', '0.867383513', '718', '1', '4', '0.184210526', '0.122767857', '1', '1', '21.15625', '3', '1.4063', '1']
package org . apache . camel . component . jbi ; import org . apache . camel . RuntimeCamelException ; public class JbiException extends RuntimeCamelException { public JbiException ( Throwable cause ) { super ( cause ) ; } public JbiException ( String message ) { super ( message ) ; } public JbiException ( String message , Throwable cause ) { super ( message , cause ) ; } } 	0	['3', '5', '0', '2', '6', '3', '1', '1', '3', '2', '16', '0', '0', '1', '0.777777778', '0', '0', '4.333333333', '0', '0', '0']
package org . apache . camel . builder ; import static org . apache . camel . util . ObjectHelper . compare ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . impl . PredicateSupport ; import org . apache . camel . impl . BinaryPredicateSupport ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class PredicateBuilder { public static < E extends Exchange > Predicate < E > and ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) && right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") and (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > or ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) || right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") or (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > isEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . equals ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isNotEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ! ObjectHelper . equals ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return "<" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) <= 0 ; } protected String getOperationText ( ) { return "<=" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) > 0 ; } protected String getOperationText ( ) { return ">" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return ">=" ; } } ; } public static < E extends Exchange > Predicate < E > contains ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . contains ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "contains" ; } } ; } public static < E extends Exchange > Predicate < E > isNull ( final Expression < E > expression ) { return isEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isNotNull ( final Expression < E > expression ) { return isNotEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isInstanceOf ( final Expression < E > expression , final Class type ) { notNull ( expression , "expression" ) ; notNull ( type , "type" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return type . isInstance ( value ) ; } @ Override public String toString ( ) { return expression + " instanceof " + type . getName ( ) ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final String regex ) { return regex ( expression , Pattern . compile ( regex ) ) ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final Pattern pattern ) { notNull ( expression , "expression" ) ; notNull ( pattern , "pattern" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; if ( value != null ) { Matcher matcher = pattern . matcher ( value . toString ( ) ) ; return matcher . matches ( ) ; } return false ; } @ Override public String toString ( ) { return expression + ".matches(" + pattern + ")" ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } } 	1	['15', '1', '0', '17', '30', '105', '2', '15', '15', '2', '123', '0', '0', '0', '0.2', '0', '0', '7.2', '1', '0.9333', '1']
