package org . apache . velocity . runtime . exception ; import org . apache . velocity . runtime . parser . node . Node ; public class NodeException extends Exception { public NodeException ( String exceptionMessage , Node node ) { super ( exceptionMessage + ": " + node . literal ( ) + " [line " + node . getLine ( ) + ",column " + node . getColumn ( ) + "]" ) ; } } 	0	['1', '3', '0', '1', '9', '0', '0', '1', '1', '2', '27', '0', '0', '1', '1', '0', '0', '26', '0', '0', '0']
package org . apache . velocity . test ; import java . io . BufferedWriter ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . StringWriter ; import java . util . Vector ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . Template ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . test . provider . TestProvider ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . app . Velocity ; import junit . framework . TestCase ; public class VelocityAppTestCase extends BaseTestCase implements TemplateTestBase { private StringWriter compare1 = new StringWriter ( ) ; private String input1 = "My name is $name -> $Floog" ; private String result1 = "My name is jason -> floogie woogie" ; public VelocityAppTestCase ( ) { super ( "VelocityAppTestCase" ) ; try { Velocity . setProperty ( Velocity . FILE_RESOURCE_LOADER_PATH , FILE_RESOURCE_LOADER_PATH ) ; Velocity . init ( ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup VelocityAppTestCase!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } public static junit . framework . Test suite ( ) { return new VelocityAppTestCase ( ) ; } public void runTest ( ) { VelocityContext context = new VelocityContext ( ) ; context . put ( "name" , "jason" ) ; context . put ( "Floog" , "floogie woogie" ) ; try { Velocity . evaluate ( context , compare1 , "evaltest" , input1 ) ; if ( ! result1 . equals ( compare1 . toString ( ) ) ) { fail ( "Output incorrect." ) ; } } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } } } 	0	['3', '4', '0', '8', '17', '1', '0', '8', '3', '0', '75', '1', '0', '0.964285714', '0.666666667', '3', '3', '23', '1', '0.6667', '0']
package org . apache . velocity . runtime . parser ; import java . io . * ; import java . util . * ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . * ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . directive . Macro ; import org . apache . velocity . runtime . directive . MacroParseException ; import org . apache . velocity . util . StringUtils ; public class Parser implements ParserTreeConstants , ParserConstants { protected JJTParserState jjtree = new JJTParserState ( ) ; private Hashtable directives = new Hashtable ( 0 ) ; String currentTemplateName = "" ; VelocityCharStream velcharstream = null ; private RuntimeServices rsvc = null ; public Parser ( RuntimeServices rs ) { this ( new VelocityCharStream ( new ByteArrayInputStream ( "\n" . getBytes ( ) ) , 1 , 1 ) ) ; velcharstream = new VelocityCharStream ( new ByteArrayInputStream ( "\n" . getBytes ( ) ) , 1 , 1 ) ; rsvc = rs ; } public SimpleNode parse ( Reader reader , String templateName ) throws ParseException { SimpleNode sn = null ; currentTemplateName = templateName ; try { token_source . clearStateVars ( ) ; velcharstream . ReInit ( reader , 1 , 1 ) ; ReInit ( velcharstream ) ; sn = process ( ) ; } catch ( MacroParseException mee ) { rsvc . error ( "Parser Error:  #macro() : " + templateName + " : " + StringUtils . stackTrace ( mee ) ) ; throw new ParseException ( mee . getMessage ( ) ) ; } catch ( ParseException pe ) { rsvc . error ( "Parser Exception: " + templateName + " : " + StringUtils . stackTrace ( pe ) ) ; throw new ParseException ( pe . currentToken , pe . expectedTokenSequences , pe . tokenImage ) ; } catch ( TokenMgrError tme ) { throw new ParseException ( "Lexical error: " + tme . toString ( ) ) ; } catch ( Exception e ) { rsvc . error ( "Parser Error: " + templateName + " : " + StringUtils . stackTrace ( e ) ) ; } currentTemplateName = "" ; return sn ; } public void setDirectives ( Hashtable directives ) { this . directives = directives ; } public Directive getDirective ( String directive ) { return ( Directive ) directives . get ( directive ) ; } public boolean isDirective ( String directive ) { if ( directives . containsKey ( directive ) ) return true ; else return false ; } private String escapedDirective ( String strImage ) { int iLast = strImage . lastIndexOf ( "\\" ) ; String strDirective = strImage . substring ( iLast + 1 ) ; boolean bRecognizedDirective = false ; if ( isDirective ( strDirective . substring ( 1 ) ) ) { bRecognizedDirective = true ; } else if ( rsvc . isVelocimacro ( strDirective . substring ( 1 ) , currentTemplateName ) ) { bRecognizedDirective = true ; } else { if ( strDirective . substring ( 1 ) . equals ( "if" ) || strDirective . substring ( 1 ) . equals ( "end" ) || strDirective . substring ( 1 ) . equals ( "set" ) || strDirective . substring ( 1 ) . equals ( "else" ) || strDirective . substring ( 1 ) . equals ( "elseif" ) || strDirective . substring ( 1 ) . equals ( "stop" ) ) { bRecognizedDirective = true ; } } if ( bRecognizedDirective ) return ( strImage . substring ( 0 , iLast / 2 ) + strDirective ) ; else return ( strImage ) ; } final public SimpleNode process ( ) throws ParseException { ASTprocess jjtn000 = new ASTprocess ( this , JJTPROCESS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { label_1 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case SINGLE_LINE_COMMENT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case NUMBER_LITERAL : case WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } Statement ( ) ; } jj_consume_token ( 0 ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; { if ( true ) return jjtn000 ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } throw new Error ( "Missing return statement in function" ) ; } final public void Statement ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IF_DIRECTIVE : IfStatement ( ) ; break ; case STOP_DIRECTIVE : StopStatement ( ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; if ( jj_2_1 ( 2 ) ) { Reference ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case SINGLE_LINE_COMMENT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : Comment ( ) ; break ; case SET_DIRECTIVE : SetDirective ( ) ; break ; case ESCAPE_DIRECTIVE : EscapedDirective ( ) ; break ; case DOUBLE_ESCAPE : Escape ( ) ; break ; case WORD : Directive ( ) ; break ; case LPAREN : case RPAREN : case ESCAPE : case TEXT : case STRING_LITERAL : case NUMBER_LITERAL : case DOT : case LCURLY : case RCURLY : Text ( ) ; break ; default : jj_la1 [ 2 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } } final public void EscapedDirective ( ) throws ParseException { ASTEscapedDirective jjtn000 = new ASTEscapedDirective ( this , JJTESCAPEDDIRECTIVE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { Token t = null ; t = jj_consume_token ( ESCAPE_DIRECTIVE ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; t . image = escapedDirective ( t . image ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Escape ( ) throws ParseException { ASTEscape jjtn000 = new ASTEscape ( this , JJTESCAPE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { Token t = null ; int count = 0 ; boolean control = false ; label_2 : while ( true ) { t = jj_consume_token ( DOUBLE_ESCAPE ) ; count ++ ; if ( jj_2_2 ( 2 ) ) { ; } else { break label_2 ; } } jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; switch ( t . next . kind ) { case IF_DIRECTIVE : case ELSE_DIRECTIVE : case ELSEIF_DIRECTIVE : case END : case STOP_DIRECTIVE : control = true ; break ; } if ( isDirective ( t . next . image . substring ( 1 ) ) ) control = true ; else if ( rsvc . isVelocimacro ( t . next . image . substring ( 1 ) , currentTemplateName ) ) control = true ; jjtn000 . val = "" ; for ( int i = 0 ; i < count ; i ++ ) jjtn000 . val += ( control ? "\\" : "\\\\" ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Comment ( ) throws ParseException { ASTComment jjtn000 = new ASTComment ( this , JJTCOMMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case SINGLE_LINE_COMMENT : jj_consume_token ( SINGLE_LINE_COMMENT ) ; break ; case MULTI_LINE_COMMENT : jj_consume_token ( MULTI_LINE_COMMENT ) ; break ; case FORMAL_COMMENT : jj_consume_token ( FORMAL_COMMENT ) ; break ; default : jj_la1 [ 3 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void NumberLiteral ( ) throws ParseException { ASTNumberLiteral jjtn000 = new ASTNumberLiteral ( this , JJTNUMBERLITERAL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( NUMBER_LITERAL ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void StringLiteral ( ) throws ParseException { ASTStringLiteral jjtn000 = new ASTStringLiteral ( this , JJTSTRINGLITERAL ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( STRING_LITERAL ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Identifier ( ) throws ParseException { ASTIdentifier jjtn000 = new ASTIdentifier ( this , JJTIDENTIFIER ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( IDENTIFIER ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Word ( ) throws ParseException { ASTWord jjtn000 = new ASTWord ( this , JJTWORD ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( WORD ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public int DirectiveArg ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : case LCURLY : Reference ( ) ; { if ( true ) return ParserTreeConstants . JJTREFERENCE ; } break ; case WORD : Word ( ) ; { if ( true ) return ParserTreeConstants . JJTWORD ; } break ; case STRING_LITERAL : StringLiteral ( ) ; { if ( true ) return ParserTreeConstants . JJTSTRINGLITERAL ; } break ; case NUMBER_LITERAL : NumberLiteral ( ) ; { if ( true ) return ParserTreeConstants . JJTNUMBERLITERAL ; } break ; default : jj_la1 [ 4 ] = jj_gen ; if ( jj_2_3 ( 2147483647 ) ) { IntegerRange ( ) ; { if ( true ) return ParserTreeConstants . JJTINTEGERRANGE ; } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : ObjectArray ( ) ; { if ( true ) return ParserTreeConstants . JJTOBJECTARRAY ; } break ; case TRUE : True ( ) ; { if ( true ) return ParserTreeConstants . JJTTRUE ; } break ; case FALSE : False ( ) ; { if ( true ) return ParserTreeConstants . JJTFALSE ; } break ; default : jj_la1 [ 5 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } throw new Error ( "Missing return statement in function" ) ; } final public SimpleNode Directive ( ) throws ParseException { ASTDirective jjtn000 = new ASTDirective ( this , JJTDIRECTIVE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; Token t = null ; int argType ; int argPos = 0 ; Directive d ; int directiveType ; boolean isVM = false ; boolean doItNow = false ; try { t = jj_consume_token ( WORD ) ; String directiveName = t . image . substring ( 1 ) ; d = ( Directive ) directives . get ( directiveName ) ; if ( directiveName . equals ( "macro" ) ) { doItNow = true ; } jjtn000 . setDirectiveName ( directiveName ) ; if ( d == null ) { isVM = rsvc . isVelocimacro ( directiveName , currentTemplateName ) ; if ( ! isVM ) { token_source . stateStackPop ( ) ; token_source . inDirective = false ; { if ( true ) return jjtn000 ; } } directiveType = Directive . LINE ; } else { directiveType = d . getType ( ) ; } token_source . SwitchTo ( DIRECTIVE ) ; argPos = 0 ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 6 ] = jj_gen ; ; } jj_consume_token ( LPAREN ) ; label_3 : while ( true ) { if ( jj_2_4 ( 2 ) ) { ; } else { break label_3 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 7 ] = jj_gen ; ; } argType = DirectiveArg ( ) ; if ( argType == ParserTreeConstants . JJTWORD ) { if ( doItNow && argPos == 0 ) { ; } else if ( t . image . equals ( "#foreach" ) && argPos == 1 ) { ; } else { { if ( true ) throw new MacroParseException ( "Invalid arg #" + argPos + " in " + ( isVM ? "VM " : "directive " ) + t . image + " at line " + t . beginLine + ", column " + t . beginColumn + " in template " + currentTemplateName ) ; } } } else { if ( doItNow && argPos == 0 ) { { if ( true ) throw new MacroParseException ( "Invalid first arg " + " in #macro() directive - must be a" + " word token (no \' or \" surrounding)" + " at line " + t . beginLine + ", column " + t . beginColumn + " in template " + currentTemplateName ) ; } } } argPos ++ ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 8 ] = jj_gen ; ; } jj_consume_token ( RPAREN ) ; if ( directiveType == Directive . LINE ) { { if ( true ) return jjtn000 ; } } ASTBlock jjtn001 = new ASTBlock ( this , JJTBLOCK ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { label_4 : while ( true ) { Statement ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case SINGLE_LINE_COMMENT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case NUMBER_LITERAL : case WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 9 ] = jj_gen ; break label_4 ; } } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , true ) ; } } jj_consume_token ( END ) ; jjtree . closeNodeScope ( jjtn000 , true ) ; jjtc000 = false ; if ( doItNow ) { Macro . processAndRegister ( rsvc , jjtn000 , currentTemplateName ) ; } { if ( true ) return jjtn000 ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } throw new Error ( "Missing return statement in function" ) ; } final public void ObjectArray ( ) throws ParseException { ASTObjectArray jjtn000 = new ASTObjectArray ( this , JJTOBJECTARRAY ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( LBRACKET ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : case WHITESPACE : case STRING_LITERAL : case TRUE : case FALSE : case NUMBER_LITERAL : case IDENTIFIER : case LCURLY : Parameter ( ) ; label_5 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 10 ] = jj_gen ; break label_5 ; } jj_consume_token ( COMMA ) ; Parameter ( ) ; } break ; default : jj_la1 [ 11 ] = jj_gen ; ; } jj_consume_token ( RBRACKET ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void IntegerRange ( ) throws ParseException { ASTIntegerRange jjtn000 = new ASTIntegerRange ( this , JJTINTEGERRANGE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( LBRACKET ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 12 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : case LCURLY : Reference ( ) ; break ; case NUMBER_LITERAL : NumberLiteral ( ) ; break ; default : jj_la1 [ 13 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 14 ] = jj_gen ; ; } jj_consume_token ( DOUBLEDOT ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 15 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : case LCURLY : Reference ( ) ; break ; case NUMBER_LITERAL : NumberLiteral ( ) ; break ; default : jj_la1 [ 16 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 17 ] = jj_gen ; ; } jj_consume_token ( RBRACKET ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Parameter ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 18 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case STRING_LITERAL : StringLiteral ( ) ; break ; default : jj_la1 [ 19 ] = jj_gen ; if ( jj_2_5 ( 2147483647 ) ) { IntegerRange ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : ObjectArray ( ) ; break ; case TRUE : True ( ) ; break ; case FALSE : False ( ) ; break ; case IDENTIFIER : case LCURLY : Reference ( ) ; break ; case NUMBER_LITERAL : NumberLiteral ( ) ; break ; default : jj_la1 [ 20 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 21 ] = jj_gen ; ; } } final public void Method ( ) throws ParseException { ASTMethod jjtn000 = new ASTMethod ( this , JJTMETHOD ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { Identifier ( ) ; jj_consume_token ( LPAREN ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : case WHITESPACE : case STRING_LITERAL : case TRUE : case FALSE : case NUMBER_LITERAL : case IDENTIFIER : case LCURLY : Parameter ( ) ; label_6 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 22 ] = jj_gen ; break label_6 ; } jj_consume_token ( COMMA ) ; Parameter ( ) ; } break ; default : jj_la1 [ 23 ] = jj_gen ; ; } jj_consume_token ( REFMOD2_RPAREN ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Reference ( ) throws ParseException { ASTReference jjtn000 = new ASTReference ( this , JJTREFERENCE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : jj_consume_token ( IDENTIFIER ) ; label_7 : while ( true ) { if ( jj_2_6 ( 2 ) ) { ; } else { break label_7 ; } jj_consume_token ( DOT ) ; if ( jj_2_7 ( 3 ) ) { Method ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : Identifier ( ) ; break ; default : jj_la1 [ 24 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } break ; case LCURLY : jj_consume_token ( LCURLY ) ; jj_consume_token ( IDENTIFIER ) ; label_8 : while ( true ) { if ( jj_2_8 ( 2 ) ) { ; } else { break label_8 ; } jj_consume_token ( DOT ) ; if ( jj_2_9 ( 3 ) ) { Method ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : Identifier ( ) ; break ; default : jj_la1 [ 25 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } jj_consume_token ( RCURLY ) ; break ; default : jj_la1 [ 26 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void True ( ) throws ParseException { ASTTrue jjtn000 = new ASTTrue ( this , JJTTRUE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( TRUE ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void False ( ) throws ParseException { ASTFalse jjtn000 = new ASTFalse ( this , JJTFALSE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( FALSE ) ; } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Text ( ) throws ParseException { ASTText jjtn000 = new ASTText ( this , JJTTEXT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case TEXT : jj_consume_token ( TEXT ) ; break ; case DOT : jj_consume_token ( DOT ) ; break ; case RPAREN : jj_consume_token ( RPAREN ) ; break ; case LPAREN : jj_consume_token ( LPAREN ) ; break ; case NUMBER_LITERAL : jj_consume_token ( NUMBER_LITERAL ) ; break ; case STRING_LITERAL : jj_consume_token ( STRING_LITERAL ) ; break ; case ESCAPE : jj_consume_token ( ESCAPE ) ; break ; case LCURLY : jj_consume_token ( LCURLY ) ; break ; case RCURLY : jj_consume_token ( RCURLY ) ; break ; default : jj_la1 [ 27 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void IfStatement ( ) throws ParseException { ASTIfStatement jjtn000 = new ASTIfStatement ( this , JJTIFSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( IF_DIRECTIVE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 28 ] = jj_gen ; ; } jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; ASTBlock jjtn001 = new ASTBlock ( this , JJTBLOCK ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { label_9 : while ( true ) { Statement ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case SINGLE_LINE_COMMENT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case NUMBER_LITERAL : case WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 29 ] = jj_gen ; break label_9 ; } } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , true ) ; } } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ELSEIF_DIRECTIVE : label_10 : while ( true ) { ElseIfStatement ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ELSEIF_DIRECTIVE : ; break ; default : jj_la1 [ 30 ] = jj_gen ; break label_10 ; } } break ; default : jj_la1 [ 31 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ELSE_DIRECTIVE : ElseStatement ( ) ; break ; default : jj_la1 [ 32 ] = jj_gen ; ; } jj_consume_token ( END ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void ElseStatement ( ) throws ParseException { ASTElseStatement jjtn000 = new ASTElseStatement ( this , JJTELSESTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( ELSE_DIRECTIVE ) ; ASTBlock jjtn001 = new ASTBlock ( this , JJTBLOCK ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { label_11 : while ( true ) { Statement ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case SINGLE_LINE_COMMENT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case NUMBER_LITERAL : case WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 33 ] = jj_gen ; break label_11 ; } } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , true ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void ElseIfStatement ( ) throws ParseException { ASTElseIfStatement jjtn000 = new ASTElseIfStatement ( this , JJTELSEIFSTATEMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( ELSEIF_DIRECTIVE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 34 ] = jj_gen ; ; } jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; ASTBlock jjtn001 = new ASTBlock ( this , JJTBLOCK ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { label_12 : while ( true ) { Statement ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : case RPAREN : case ESCAPE_DIRECTIVE : case SET_DIRECTIVE : case DOUBLE_ESCAPE : case ESCAPE : case TEXT : case SINGLE_LINE_COMMENT : case FORMAL_COMMENT : case MULTI_LINE_COMMENT : case STRING_LITERAL : case IF_DIRECTIVE : case STOP_DIRECTIVE : case NUMBER_LITERAL : case WORD : case IDENTIFIER : case DOT : case LCURLY : case RCURLY : ; break ; default : jj_la1 [ 35 ] = jj_gen ; break label_12 ; } } } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , true ) ; } } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void SetDirective ( ) throws ParseException { ASTSetDirective jjtn000 = new ASTSetDirective ( this , JJTSETDIRECTIVE ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { jj_consume_token ( SET_DIRECTIVE ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 36 ] = jj_gen ; ; } Reference ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 37 ] = jj_gen ; ; } jj_consume_token ( EQUALS ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; token_source . inSet = false ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case NEWLINE : jj_consume_token ( NEWLINE ) ; break ; default : jj_la1 [ 38 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void StopStatement ( ) throws ParseException { jj_consume_token ( STOP_DIRECTIVE ) ; } final public void Expression ( ) throws ParseException { ASTExpression jjtn000 = new ASTExpression ( this , JJTEXPRESSION ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { ConditionalOrExpression ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } } final public void Assignment ( ) throws ParseException { ASTAssignment jjtn000 = new ASTAssignment ( this , JJTASSIGNMENT ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { PrimaryExpression ( ) ; jj_consume_token ( EQUALS ) ; Expression ( ) ; } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , 2 ) ; } } } final public void ConditionalOrExpression ( ) throws ParseException { ConditionalAndExpression ( ) ; label_13 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_OR : ; break ; default : jj_la1 [ 39 ] = jj_gen ; break label_13 ; } jj_consume_token ( LOGICAL_OR ) ; ASTOrNode jjtn001 = new ASTOrNode ( this , JJTORNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { ConditionalAndExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } } } final public void ConditionalAndExpression ( ) throws ParseException { EqualityExpression ( ) ; label_14 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_AND : ; break ; default : jj_la1 [ 40 ] = jj_gen ; break label_14 ; } jj_consume_token ( LOGICAL_AND ) ; ASTAndNode jjtn001 = new ASTAndNode ( this , JJTANDNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { EqualityExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } } } final public void EqualityExpression ( ) throws ParseException { RelationalExpression ( ) ; label_15 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_EQUALS : case LOGICAL_NOT_EQUALS : ; break ; default : jj_la1 [ 41 ] = jj_gen ; break label_15 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_EQUALS : jj_consume_token ( LOGICAL_EQUALS ) ; ASTEQNode jjtn001 = new ASTEQNode ( this , JJTEQNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { RelationalExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } break ; case LOGICAL_NOT_EQUALS : jj_consume_token ( LOGICAL_NOT_EQUALS ) ; ASTNENode jjtn002 = new ASTNENode ( this , JJTNENODE ) ; boolean jjtc002 = true ; jjtree . openNodeScope ( jjtn002 ) ; try { RelationalExpression ( ) ; } catch ( Throwable jjte002 ) { if ( jjtc002 ) { jjtree . clearNodeScope ( jjtn002 ) ; jjtc002 = false ; } else { jjtree . popNode ( ) ; } if ( jjte002 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte002 ; } } if ( jjte002 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte002 ; } } { if ( true ) throw ( Error ) jjte002 ; } } finally { if ( jjtc002 ) { jjtree . closeNodeScope ( jjtn002 , 2 ) ; } } break ; default : jj_la1 [ 42 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void RelationalExpression ( ) throws ParseException { AdditiveExpression ( ) ; label_16 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_LT : case LOGICAL_LE : case LOGICAL_GT : case LOGICAL_GE : ; break ; default : jj_la1 [ 43 ] = jj_gen ; break label_16 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LOGICAL_LT : jj_consume_token ( LOGICAL_LT ) ; ASTLTNode jjtn001 = new ASTLTNode ( this , JJTLTNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { AdditiveExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } break ; case LOGICAL_GT : jj_consume_token ( LOGICAL_GT ) ; ASTGTNode jjtn002 = new ASTGTNode ( this , JJTGTNODE ) ; boolean jjtc002 = true ; jjtree . openNodeScope ( jjtn002 ) ; try { AdditiveExpression ( ) ; } catch ( Throwable jjte002 ) { if ( jjtc002 ) { jjtree . clearNodeScope ( jjtn002 ) ; jjtc002 = false ; } else { jjtree . popNode ( ) ; } if ( jjte002 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte002 ; } } if ( jjte002 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte002 ; } } { if ( true ) throw ( Error ) jjte002 ; } } finally { if ( jjtc002 ) { jjtree . closeNodeScope ( jjtn002 , 2 ) ; } } break ; case LOGICAL_LE : jj_consume_token ( LOGICAL_LE ) ; ASTLENode jjtn003 = new ASTLENode ( this , JJTLENODE ) ; boolean jjtc003 = true ; jjtree . openNodeScope ( jjtn003 ) ; try { AdditiveExpression ( ) ; } catch ( Throwable jjte003 ) { if ( jjtc003 ) { jjtree . clearNodeScope ( jjtn003 ) ; jjtc003 = false ; } else { jjtree . popNode ( ) ; } if ( jjte003 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte003 ; } } if ( jjte003 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte003 ; } } { if ( true ) throw ( Error ) jjte003 ; } } finally { if ( jjtc003 ) { jjtree . closeNodeScope ( jjtn003 , 2 ) ; } } break ; case LOGICAL_GE : jj_consume_token ( LOGICAL_GE ) ; ASTGENode jjtn004 = new ASTGENode ( this , JJTGENODE ) ; boolean jjtc004 = true ; jjtree . openNodeScope ( jjtn004 ) ; try { AdditiveExpression ( ) ; } catch ( Throwable jjte004 ) { if ( jjtc004 ) { jjtree . clearNodeScope ( jjtn004 ) ; jjtc004 = false ; } else { jjtree . popNode ( ) ; } if ( jjte004 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte004 ; } } if ( jjte004 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte004 ; } } { if ( true ) throw ( Error ) jjte004 ; } } finally { if ( jjtc004 ) { jjtree . closeNodeScope ( jjtn004 , 2 ) ; } } break ; default : jj_la1 [ 44 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void AdditiveExpression ( ) throws ParseException { MultiplicativeExpression ( ) ; label_17 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case MINUS : case PLUS : ; break ; default : jj_la1 [ 45 ] = jj_gen ; break label_17 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : jj_consume_token ( PLUS ) ; ASTAddNode jjtn001 = new ASTAddNode ( this , JJTADDNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { MultiplicativeExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } break ; case MINUS : jj_consume_token ( MINUS ) ; ASTSubtractNode jjtn002 = new ASTSubtractNode ( this , JJTSUBTRACTNODE ) ; boolean jjtc002 = true ; jjtree . openNodeScope ( jjtn002 ) ; try { MultiplicativeExpression ( ) ; } catch ( Throwable jjte002 ) { if ( jjtc002 ) { jjtree . clearNodeScope ( jjtn002 ) ; jjtc002 = false ; } else { jjtree . popNode ( ) ; } if ( jjte002 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte002 ; } } if ( jjte002 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte002 ; } } { if ( true ) throw ( Error ) jjte002 ; } } finally { if ( jjtc002 ) { jjtree . closeNodeScope ( jjtn002 , 2 ) ; } } break ; default : jj_la1 [ 46 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void MultiplicativeExpression ( ) throws ParseException { UnaryExpression ( ) ; label_18 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case MULTIPLY : case DIVIDE : case MODULUS : ; break ; default : jj_la1 [ 47 ] = jj_gen ; break label_18 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case MULTIPLY : jj_consume_token ( MULTIPLY ) ; ASTMulNode jjtn001 = new ASTMulNode ( this , JJTMULNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { UnaryExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 2 ) ; } } break ; case DIVIDE : jj_consume_token ( DIVIDE ) ; ASTDivNode jjtn002 = new ASTDivNode ( this , JJTDIVNODE ) ; boolean jjtc002 = true ; jjtree . openNodeScope ( jjtn002 ) ; try { UnaryExpression ( ) ; } catch ( Throwable jjte002 ) { if ( jjtc002 ) { jjtree . clearNodeScope ( jjtn002 ) ; jjtc002 = false ; } else { jjtree . popNode ( ) ; } if ( jjte002 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte002 ; } } if ( jjte002 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte002 ; } } { if ( true ) throw ( Error ) jjte002 ; } } finally { if ( jjtc002 ) { jjtree . closeNodeScope ( jjtn002 , 2 ) ; } } break ; case MODULUS : jj_consume_token ( MODULUS ) ; ASTModNode jjtn003 = new ASTModNode ( this , JJTMODNODE ) ; boolean jjtc003 = true ; jjtree . openNodeScope ( jjtn003 ) ; try { UnaryExpression ( ) ; } catch ( Throwable jjte003 ) { if ( jjtc003 ) { jjtree . clearNodeScope ( jjtn003 ) ; jjtc003 = false ; } else { jjtree . popNode ( ) ; } if ( jjte003 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte003 ; } } if ( jjte003 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte003 ; } } { if ( true ) throw ( Error ) jjte003 ; } } finally { if ( jjtc003 ) { jjtree . closeNodeScope ( jjtn003 , 2 ) ; } } break ; default : jj_la1 [ 48 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void UnaryExpression ( ) throws ParseException { if ( jj_2_10 ( 2 ) ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 49 ] = jj_gen ; ; } jj_consume_token ( LOGICAL_NOT ) ; ASTNotNode jjtn001 = new ASTNotNode ( this , JJTNOTNODE ) ; boolean jjtc001 = true ; jjtree . openNodeScope ( jjtn001 ) ; try { UnaryExpression ( ) ; } catch ( Throwable jjte001 ) { if ( jjtc001 ) { jjtree . clearNodeScope ( jjtn001 ) ; jjtc001 = false ; } else { jjtree . popNode ( ) ; } if ( jjte001 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte001 ; } } if ( jjte001 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte001 ; } } { if ( true ) throw ( Error ) jjte001 ; } } finally { if ( jjtc001 ) { jjtree . closeNodeScope ( jjtn001 , 1 ) ; } } } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : case LPAREN : case WHITESPACE : case STRING_LITERAL : case TRUE : case FALSE : case NUMBER_LITERAL : case IDENTIFIER : case LCURLY : PrimaryExpression ( ) ; break ; default : jj_la1 [ 50 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } final public void PrimaryExpression ( ) throws ParseException { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 51 ] = jj_gen ; ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case STRING_LITERAL : StringLiteral ( ) ; break ; case NUMBER_LITERAL : NumberLiteral ( ) ; break ; case IDENTIFIER : case LCURLY : Reference ( ) ; break ; default : jj_la1 [ 52 ] = jj_gen ; if ( jj_2_11 ( 2147483647 ) ) { IntegerRange ( ) ; } else { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case LBRACKET : ObjectArray ( ) ; break ; case TRUE : True ( ) ; break ; case FALSE : False ( ) ; break ; case LPAREN : jj_consume_token ( LPAREN ) ; Expression ( ) ; jj_consume_token ( RPAREN ) ; break ; default : jj_la1 [ 53 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case WHITESPACE : jj_consume_token ( WHITESPACE ) ; break ; default : jj_la1 [ 54 ] = jj_gen ; ; } } final private boolean jj_2_1 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_1 ( ) ; jj_save ( 0 , xla ) ; return retval ; } final private boolean jj_2_2 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_2 ( ) ; jj_save ( 1 , xla ) ; return retval ; } final private boolean jj_2_3 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_3 ( ) ; jj_save ( 2 , xla ) ; return retval ; } final private boolean jj_2_4 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_4 ( ) ; jj_save ( 3 , xla ) ; return retval ; } final private boolean jj_2_5 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_5 ( ) ; jj_save ( 4 , xla ) ; return retval ; } final private boolean jj_2_6 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_6 ( ) ; jj_save ( 5 , xla ) ; return retval ; } final private boolean jj_2_7 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_7 ( ) ; jj_save ( 6 , xla ) ; return retval ; } final private boolean jj_2_8 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_8 ( ) ; jj_save ( 7 , xla ) ; return retval ; } final private boolean jj_2_9 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_9 ( ) ; jj_save ( 8 , xla ) ; return retval ; } final private boolean jj_2_10 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_10 ( ) ; jj_save ( 9 , xla ) ; return retval ; } final private boolean jj_2_11 ( int xla ) { jj_la = xla ; jj_lastpos = jj_scanpos = token ; boolean retval = ! jj_3_11 ( ) ; jj_save ( 10 , xla ) ; return retval ; } final private boolean jj_3R_54 ( ) { if ( jj_scan_token ( STRING_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_24 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_41 ( ) { if ( jj_scan_token ( NUMBER_LITERAL ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_4 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_24 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_25 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_38 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_29 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_32 ( ) { if ( jj_3R_50 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_30 ( ) { if ( jj_3R_50 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_37 ( ) { if ( jj_3R_41 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_2 ( ) { if ( jj_scan_token ( DOUBLE_ESCAPE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_28 ( ) { if ( jj_3R_41 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_36 ( ) { if ( jj_3R_19 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_9 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_82 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_59 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_23 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_7 ( ) { if ( jj_3R_31 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_27 ( ) { if ( jj_3R_19 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_58 ( ) { if ( jj_scan_token ( FALSE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_35 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_57 ( ) { if ( jj_scan_token ( TRUE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_8 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3_9 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_32 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_51 ( ) { if ( jj_3R_59 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_82 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3_6 ( ) { if ( jj_scan_token ( DOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3_7 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_30 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_40 ( ) { if ( jj_scan_token ( LCURLY ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_8 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } if ( jj_scan_token ( RCURLY ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_22 ( ) { if ( jj_3R_41 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_11 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_35 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_36 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_37 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_38 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( DOUBLEDOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_26 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_39 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3_6 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3_1 ( ) { if ( jj_3R_19 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_81 ( ) { if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_19 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_39 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_40 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_80 ( ) { if ( jj_3R_58 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_33 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_79 ( ) { if ( jj_3R_57 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_78 ( ) { if ( jj_3R_56 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_77 ( ) { if ( jj_3R_55 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_76 ( ) { if ( jj_3R_19 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_21 ( ) { if ( jj_3R_19 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_5 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_26 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_27 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_28 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_29 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( DOUBLEDOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_75 ( ) { if ( jj_3R_41 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_31 ( ) { if ( jj_3R_50 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_51 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( REFMOD2_RPAREN ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_74 ( ) { if ( jj_3R_54 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_73 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_60 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_73 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_74 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_75 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_76 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_77 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_78 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_79 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_80 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_81 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_85 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_72 ( ) { if ( jj_3R_41 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_71 ( ) { if ( jj_3R_19 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_83 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_70 ( ) { if ( jj_3R_58 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_69 ( ) { if ( jj_3R_57 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_34 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3_10 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_52 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_10 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_33 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( LOGICAL_NOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_34 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_52 ( ) { if ( jj_3R_60 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_68 ( ) { if ( jj_3R_56 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_67 ( ) { if ( jj_3R_55 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_66 ( ) { if ( jj_3R_54 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_20 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_87 ( ) { if ( jj_3R_41 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_89 ( ) { if ( jj_scan_token ( COMMA ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_3R_59 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_63 ( ) { if ( jj_3R_41 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_65 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_59 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_65 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_66 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_67 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_68 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_69 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_70 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_71 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_72 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_83 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_61 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3_3 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_20 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_21 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_22 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_23 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( DOUBLEDOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_49 ( ) { if ( jj_3R_58 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_88 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_86 ( ) { if ( jj_3R_19 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_48 ( ) { if ( jj_3R_57 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_84 ( ) { if ( jj_scan_token ( WHITESPACE ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_62 ( ) { if ( jj_3R_19 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_64 ( ) { if ( jj_3R_59 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; while ( true ) { xsp = jj_scanpos ; if ( jj_3R_89 ( ) ) { jj_scanpos = xsp ; break ; } if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } return false ; } final private boolean jj_3R_47 ( ) { if ( jj_3R_56 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_55 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_61 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_62 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_63 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_84 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( DOUBLEDOT ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_85 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_86 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_87 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; xsp = jj_scanpos ; if ( jj_3R_88 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_46 ( ) { if ( jj_3R_55 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_45 ( ) { if ( jj_3R_41 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_56 ( ) { if ( jj_scan_token ( LBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; Token xsp ; xsp = jj_scanpos ; if ( jj_3R_64 ( ) ) jj_scanpos = xsp ; else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; if ( jj_scan_token ( RBRACKET ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_44 ( ) { if ( jj_3R_54 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_43 ( ) { if ( jj_3R_53 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_42 ( ) { if ( jj_3R_19 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_25 ( ) { Token xsp ; xsp = jj_scanpos ; if ( jj_3R_42 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_43 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_44 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_45 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_46 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_47 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_48 ( ) ) { jj_scanpos = xsp ; if ( jj_3R_49 ( ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; } else if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_53 ( ) { if ( jj_scan_token ( WORD ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } final private boolean jj_3R_50 ( ) { if ( jj_scan_token ( IDENTIFIER ) ) return true ; if ( jj_la == 0 && jj_scanpos == jj_lastpos ) return false ; return false ; } public ParserTokenManager token_source ; public Token token , jj_nt ; private int jj_ntk ; private Token jj_scanpos , jj_lastpos ; private int jj_la ; public boolean lookingAhead = false ; private boolean jj_semLA ; private int jj_gen ; final private int [ ] jj_la1 = new int [ 55 ] ; final private int [ ] jj_la1_0 = { 0x13f0360 , 0x0 , 0x13f0360 , 0x380000 , 0x1000000 , 0x6000002 , 0x800000 , 0x800000 , 0x800000 , 0x13f0360 , 0x8 , 0x7800002 , 0x800000 , 0x0 , 0x800000 , 0x800000 , 0x0 , 0x800000 , 0x800000 , 0x1000000 , 0x6000002 , 0x800000 , 0x8 , 0x7800002 , 0x0 , 0x0 , 0x0 , 0x1060060 , 0x800000 , 0x13f0360 , 0x0 , 0x0 , 0x0 , 0x13f0360 , 0x800000 , 0x13f0360 , 0x800000 , 0x800000 , 0x8000000 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x30000000 , 0x30000000 , 0xc0000000 , 0xc0000000 , 0x800000 , 0x7800022 , 0x800000 , 0x1000000 , 0x6000022 , 0x800000 , } ; final private int [ ] jj_la1_1 = { 0xf129000 , 0x9000 , 0xe120000 , 0x0 , 0x5120000 , 0x0 , 0x0 , 0x0 , 0x0 , 0xf129000 , 0x0 , 0x5020000 , 0x0 , 0x5020000 , 0x0 , 0x0 , 0x5020000 , 0x0 , 0x0 , 0x0 , 0x5020000 , 0x0 , 0x0 , 0x5020000 , 0x1000000 , 0x1000000 , 0x5000000 , 0xe020000 , 0x0 , 0xf129000 , 0x2000 , 0x2000 , 0x4000 , 0xf129000 , 0x0 , 0xf129000 , 0x0 , 0x0 , 0x0 , 0x4 , 0x2 , 0x180 , 0x180 , 0x78 , 0x78 , 0x0 , 0x0 , 0x1 , 0x1 , 0x0 , 0x5020000 , 0x0 , 0x5020000 , 0x0 , 0x0 , } ; final private JJCalls [ ] jj_2_rtns = new JJCalls [ 11 ] ; private boolean jj_rescan = false ; private int jj_gc = 0 ; public Parser ( CharStream stream ) { token_source = new ParserTokenManager ( stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 55 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( CharStream stream ) { token_source . ReInit ( stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 55 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public Parser ( ParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 55 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } public void ReInit ( ParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jjtree . reset ( ) ; jj_gen = 0 ; for ( int i = 0 ; i < 55 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; } final private Token jj_consume_token ( int kind ) throws ParseException { Token oldToken ; if ( ( oldToken = token ) . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; if ( token . kind == kind ) { jj_gen ++ ; if ( ++ jj_gc > 100 ) { jj_gc = 0 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) { JJCalls c = jj_2_rtns [ i ] ; while ( c != null ) { if ( c . gen < jj_gen ) c . first = null ; c = c . next ; } } } return token ; } token = oldToken ; jj_kind = kind ; throw generateParseException ( ) ; } final private boolean jj_scan_token ( int kind ) { if ( jj_scanpos == jj_lastpos ) { jj_la -- ; if ( jj_scanpos . next == null ) { jj_lastpos = jj_scanpos = jj_scanpos . next = token_source . getNextToken ( ) ; } else { jj_lastpos = jj_scanpos = jj_scanpos . next ; } } else { jj_scanpos = jj_scanpos . next ; } if ( jj_rescan ) { int i = 0 ; Token tok = token ; while ( tok != null && tok != jj_scanpos ) { i ++ ; tok = tok . next ; } if ( tok != null ) jj_add_error_token ( kind , i ) ; } return ( jj_scanpos . kind != kind ) ; } final public Token getNextToken ( ) { if ( token . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; jj_gen ++ ; return token ; } final public Token getToken ( int index ) { Token t = lookingAhead ? jj_scanpos : token ; for ( int i = 0 ; i < index ; i ++ ) { if ( t . next != null ) t = t . next ; else t = t . next = token_source . getNextToken ( ) ; } return t ; } final private int jj_ntk ( ) { if ( ( jj_nt = token . next ) == null ) return ( jj_ntk = ( token . next = token_source . getNextToken ( ) ) . kind ) ; else return ( jj_ntk = jj_nt . kind ) ; } private java . util . Vector jj_expentries = new java . util . Vector ( ) ; private int [ ] jj_expentry ; private int jj_kind = - 1 ; private int [ ] jj_lasttokens = new int [ 100 ] ; private int jj_endpos ; private void jj_add_error_token ( int kind , int pos ) { if ( pos >= 100 ) return ; if ( pos == jj_endpos + 1 ) { jj_lasttokens [ jj_endpos ++ ] = kind ; } else if ( jj_endpos != 0 ) { jj_expentry = new int [ jj_endpos ] ; for ( int i = 0 ; i < jj_endpos ; i ++ ) { jj_expentry [ i ] = jj_lasttokens [ i ] ; } boolean exists = false ; for ( java . util . Enumeration enum = jj_expentries . elements ( ) ; enum . hasMoreElements ( ) ; ) { int [ ] oldentry = ( int [ ] ) ( enum . nextElement ( ) ) ; if ( oldentry . length == jj_expentry . length ) { exists = true ; for ( int i = 0 ; i < jj_expentry . length ; i ++ ) { if ( oldentry [ i ] != jj_expentry [ i ] ) { exists = false ; break ; } } if ( exists ) break ; } } if ( ! exists ) jj_expentries . addElement ( jj_expentry ) ; if ( pos != 0 ) jj_lasttokens [ ( jj_endpos = pos ) - 1 ] = kind ; } } final public ParseException generateParseException ( ) { jj_expentries . removeAllElements ( ) ; boolean [ ] la1tokens = new boolean [ 62 ] ; for ( int i = 0 ; i < 62 ; i ++ ) { la1tokens [ i ] = false ; } if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 55 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } } } } for ( int i = 0 ; i < 62 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . addElement ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = ( int [ ] ) jj_expentries . elementAt ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; } final public void enable_tracing ( ) { } final public void disable_tracing ( ) { } final private void jj_rescan_token ( ) { jj_rescan = true ; for ( int i = 0 ; i < 11 ; i ++ ) { JJCalls p = jj_2_rtns [ i ] ; do { if ( p . gen > jj_gen ) { jj_la = p . arg ; jj_lastpos = jj_scanpos = p . first ; switch ( i ) { case 0 : jj_3_1 ( ) ; break ; case 1 : jj_3_2 ( ) ; break ; case 2 : jj_3_3 ( ) ; break ; case 3 : jj_3_4 ( ) ; break ; case 4 : jj_3_5 ( ) ; break ; case 5 : jj_3_6 ( ) ; break ; case 6 : jj_3_7 ( ) ; break ; case 7 : jj_3_8 ( ) ; break ; case 8 : jj_3_9 ( ) ; break ; case 9 : jj_3_10 ( ) ; break ; case 10 : jj_3_11 ( ) ; break ; } } p = p . next ; } while ( p != null ) ; } jj_rescan = false ; } final private void jj_save ( int index , int xla ) { JJCalls p = jj_2_rtns [ index ] ; while ( p . gen > jj_gen ) { if ( p . next == null ) { p = p . next = new JJCalls ( ) ; break ; } p = p . next ; } p . gen = jj_gen + xla - jj_la ; p . first = token ; p . arg = xla ; } static final class JJCalls { int gen ; Token first ; int arg ; JJCalls next ; } } 	0	['148', '1', '0', '60', '236', '0', '43', '55', '48', '0.733908948', '9104', '0.769230769', '9', '0', '0.147804054', '0', '0', '60.33783784', '34', '4.5878', '0']
package org . apache . velocity . test ; import java . io . StringWriter ; import junit . framework . TestCase ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . runtime . log . LogSystem ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . app . event . ReferenceInsertionEventHandler ; import org . apache . velocity . app . event . MethodExceptionEventHandler ; import org . apache . velocity . app . event . NullSetEventHandler ; import org . apache . velocity . runtime . RuntimeServices ; public class EventHandlingTestCase extends TestCase implements ReferenceInsertionEventHandler , NullSetEventHandler , MethodExceptionEventHandler , LogSystem { private String logString = null ; private boolean exceptionSwitch = true ; private static String NO_REFERENCE_VALUE = "<no reference value>" ; private static String REFERENCE_VALUE = "<reference value>" ; public EventHandlingTestCase ( ) { super ( "EventHandlingTestCase" ) ; try { Velocity . setProperty ( Velocity . RUNTIME_LOG_LOGSYSTEM , this ) ; Velocity . init ( ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup event handling test : " + e ) ; System . exit ( 1 ) ; } } public void init ( RuntimeServices rs ) { } public static junit . framework . Test suite ( ) { return new EventHandlingTestCase ( ) ; } public void runTest ( ) { VelocityContext inner = new VelocityContext ( ) ; EventCartridge ec = new EventCartridge ( ) ; ec . addEventHandler ( this ) ; ec . attachToContext ( inner ) ; VelocityContext context = new VelocityContext ( inner ) ; context . put ( "name" , "Velocity" ) ; try { String s = "$name" ; StringWriter w = new StringWriter ( ) ; Velocity . evaluate ( context , w , "mystring" , s ) ; if ( ! w . toString ( ) . equals ( REFERENCE_VALUE ) ) { fail ( "Reference insertion test 1" ) ; } s = "$floobie" ; w = new StringWriter ( ) ; Velocity . evaluate ( context , w , "mystring" , s ) ; if ( ! w . toString ( ) . equals ( NO_REFERENCE_VALUE ) ) { fail ( "Reference insertion test 2" ) ; } s = "#set($settest = $NotAReference)" ; w = new StringWriter ( ) ; logString = null ; Velocity . evaluate ( context , w , "mystring" , s ) ; if ( logString != null ) { fail ( "NullSetEventHandler test 1" ) ; } s = "#set($logthis = $NotAReference)" ; w = new StringWriter ( ) ; logString = null ; Velocity . evaluate ( context , w , "mystring" , s ) ; if ( logString == null ) { fail ( "NullSetEventHandler test 1" ) ; } exceptionSwitch = true ; context . put ( "this" , this ) ; s = " $this.throwException()" ; w = new StringWriter ( ) ; try { Velocity . evaluate ( context , w , "mystring" , s ) ; } catch ( MethodInvocationException mee ) { fail ( "MethodExceptionEvent test 1" ) ; } catch ( Exception e ) { fail ( "MethodExceptionEvent test 1" ) ; } exceptionSwitch = false ; s = " $this.throwException()" ; w = new StringWriter ( ) ; try { Velocity . evaluate ( context , w , "mystring" , s ) ; fail ( "MethodExceptionEvent test 2" ) ; } catch ( MethodInvocationException mee ) { } catch ( Exception e ) { fail ( "MethodExceptionEvent test 2" ) ; } } catch ( ParseErrorException pee ) { fail ( "ParseErrorException" + pee ) ; } catch ( MethodInvocationException mee ) { fail ( "MethodInvocationException" + mee ) ; } catch ( Exception e ) { fail ( "Exception" + e ) ; } } public void throwException ( ) throws Exception { throw new Exception ( "Hello from throwException()" ) ; } public Object referenceInsert ( String reference , Object value ) { String s = null ; if ( value != null ) { s = REFERENCE_VALUE ; } else { if ( reference . equals ( "$floobie" ) ) { s = NO_REFERENCE_VALUE ; } } return s ; } public boolean shouldLogOnNullSet ( String lhs , String rhs ) { if ( lhs . equals ( "$settest" ) ) return false ; return true ; } public Object methodException ( Class claz , String method , Exception e ) throws Exception { if ( exceptionSwitch && method . equals ( "throwException" ) ) { return "handler" ; } throw e ; } public void logVelocityMessage ( int level , String message ) { logString = message ; } } 	0	['10', '3', '0', '16', '31', '29', '0', '16', '9', '0.722222222', '284', '1', '0', '0.859649123', '0.26984127', '3', '3', '27', '5', '1.5', '0']
package org . apache . velocity . runtime . parser . node ; public interface ParserVisitor { public Object visit ( SimpleNode node , Object data ) ; public Object visit ( ASTprocess node , Object data ) ; public Object visit ( ASTComment node , Object data ) ; public Object visit ( ASTNumberLiteral node , Object data ) ; public Object visit ( ASTStringLiteral node , Object data ) ; public Object visit ( ASTIdentifier node , Object data ) ; public Object visit ( ASTWord node , Object data ) ; public Object visit ( ASTDirective node , Object data ) ; public Object visit ( ASTBlock node , Object data ) ; public Object visit ( ASTObjectArray node , Object data ) ; public Object visit ( ASTMethod node , Object data ) ; public Object visit ( ASTReference node , Object data ) ; public Object visit ( ASTTrue node , Object data ) ; public Object visit ( ASTFalse node , Object data ) ; public Object visit ( ASTText node , Object data ) ; public Object visit ( ASTIfStatement node , Object data ) ; public Object visit ( ASTElseStatement node , Object data ) ; public Object visit ( ASTElseIfStatement node , Object data ) ; public Object visit ( ASTSetDirective node , Object data ) ; public Object visit ( ASTExpression node , Object data ) ; public Object visit ( ASTAssignment node , Object data ) ; public Object visit ( ASTOrNode node , Object data ) ; public Object visit ( ASTAndNode node , Object data ) ; public Object visit ( ASTEQNode node , Object data ) ; public Object visit ( ASTNENode node , Object data ) ; public Object visit ( ASTLTNode node , Object data ) ; public Object visit ( ASTGTNode node , Object data ) ; public Object visit ( ASTLENode node , Object data ) ; public Object visit ( ASTGENode node , Object data ) ; public Object visit ( ASTAddNode node , Object data ) ; public Object visit ( ASTSubtractNode node , Object data ) ; public Object visit ( ASTMulNode node , Object data ) ; public Object visit ( ASTDivNode node , Object data ) ; public Object visit ( ASTModNode node , Object data ) ; public Object visit ( ASTNotNode node , Object data ) ; } 	0	['35', '1', '0', '47', '35', '595', '47', '35', '35', '2', '35', '0', '0', '0', '0.081081081', '0', '0', '0', '1', '1', '0']
package org . apache . velocity . test ; import java . io . BufferedWriter ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . Properties ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . Template ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . test . provider . TestProvider ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . runtime . VelocimacroFactory ; import junit . framework . TestCase ; public class InlineScopeVMTestCase extends BaseTestCase implements TemplateTestBase { private static final String TEST_CASE_NAME = "InlineScopeVMTestCase" ; InlineScopeVMTestCase ( ) { super ( TEST_CASE_NAME ) ; try { Velocity . setProperty ( Velocity . VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL , "true" ) ; Velocity . setProperty ( Velocity . VM_PERM_INLINE_LOCAL , "true" ) ; Velocity . setProperty ( Velocity . FILE_RESOURCE_LOADER_PATH , FILE_RESOURCE_LOADER_PATH ) ; Velocity . init ( ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup " + TEST_CASE_NAME ) ; System . exit ( 1 ) ; } } public static junit . framework . Test suite ( ) { return new InlineScopeVMTestCase ( ) ; } public void runTest ( ) { try { assureResultsDirectoryExists ( RESULT_DIR ) ; Template template2 = RuntimeSingleton . getTemplate ( getFileName ( null , "vm_test2" , TMPL_FILE_EXT ) ) ; Template template1 = RuntimeSingleton . getTemplate ( getFileName ( null , "vm_test1" , TMPL_FILE_EXT ) ) ; FileOutputStream fos1 = new FileOutputStream ( getFileName ( RESULT_DIR , "vm_test1" , RESULT_FILE_EXT ) ) ; FileOutputStream fos2 = new FileOutputStream ( getFileName ( RESULT_DIR , "vm_test2" , RESULT_FILE_EXT ) ) ; Writer writer1 = new BufferedWriter ( new OutputStreamWriter ( fos1 ) ) ; Writer writer2 = new BufferedWriter ( new OutputStreamWriter ( fos2 ) ) ; VelocityContext context = new VelocityContext ( ) ; template1 . merge ( context , writer1 ) ; writer1 . flush ( ) ; writer1 . close ( ) ; template2 . merge ( context , writer2 ) ; writer2 . flush ( ) ; writer2 . close ( ) ; if ( ! isMatch ( RESULT_DIR , COMPARE_DIR , "vm_test1" , RESULT_FILE_EXT , CMP_FILE_EXT ) || ! isMatch ( RESULT_DIR , COMPARE_DIR , "vm_test2" , RESULT_FILE_EXT , CMP_FILE_EXT ) ) { fail ( "Output incorrect." ) ; } } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } } } 	0	['3', '4', '0', '9', '21', '3', '0', '9', '2', '1.5', '119', '1', '0', '0.964285714', '0.666666667', '2', '4', '38.33333333', '2', '1', '0']
package org . apache . velocity . runtime . parser ; import java . io . * ; import java . util . * ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . * ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . directive . Macro ; import org . apache . velocity . runtime . directive . MacroParseException ; import org . apache . velocity . util . StringUtils ; public class ParserTokenManager implements ParserConstants { private int fileDepth = 0 ; private int lparen = 0 ; private int rparen = 0 ; Stack stateStack = new Stack ( ) ; public boolean debugPrint = false ; private boolean inReference ; public boolean inDirective ; private boolean inComment ; public boolean inSet ; public boolean stateStackPop ( ) { Hashtable h ; try { h = ( Hashtable ) stateStack . pop ( ) ; } catch ( EmptyStackException e ) { lparen = 0 ; SwitchTo ( DEFAULT ) ; return false ; } if ( debugPrint ) System . out . println ( " stack pop (" + stateStack . size ( ) + ") : lparen=" + ( ( Integer ) h . get ( "lparen" ) ) . intValue ( ) + " newstate=" + ( ( Integer ) h . get ( "lexstate" ) ) . intValue ( ) ) ; lparen = ( ( Integer ) h . get ( "lparen" ) ) . intValue ( ) ; rparen = ( ( Integer ) h . get ( "rparen" ) ) . intValue ( ) ; SwitchTo ( ( ( Integer ) h . get ( "lexstate" ) ) . intValue ( ) ) ; return true ; } public boolean stateStackPush ( ) { if ( debugPrint ) System . out . println ( " (" + stateStack . size ( ) + ") pushing cur state : " + curLexState ) ; Hashtable h = new Hashtable ( ) ; h . put ( "lexstate" , new Integer ( curLexState ) ) ; h . put ( "lparen" , new Integer ( lparen ) ) ; h . put ( "rparen" , new Integer ( rparen ) ) ; lparen = 0 ; stateStack . push ( h ) ; return true ; } public void clearStateVars ( ) { stateStack . clear ( ) ; lparen = 0 ; rparen = 0 ; inReference = false ; inDirective = false ; inComment = false ; inSet = false ; return ; } private void RPARENHandler ( ) { boolean closed = false ; if ( inComment ) closed = true ; while ( ! closed ) { if ( lparen > 0 ) { if ( lparen == rparen + 1 ) { stateStackPop ( ) ; } else { rparen ++ ; } closed = true ; } else { if ( ! stateStackPop ( ) ) break ; } } } public java . io . PrintStream debugStream = System . out ; public void setDebugStream ( java . io . PrintStream ds ) { debugStream = ds ; } private final int jjStopStringLiteralDfa_0 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x6000000L ) != 0L ) { jjmatchedKind = 52 ; return 33 ; } if ( ( active0 & 0x10000000L ) != 0L ) return 31 ; if ( ( active0 & 0xd000L ) != 0L ) return 7 ; return - 1 ; case 1 : if ( ( active0 & 0x6000000L ) != 0L ) { jjmatchedKind = 52 ; jjmatchedPos = 1 ; return 33 ; } if ( ( active0 & 0x4000L ) != 0L ) return 5 ; return - 1 ; case 2 : if ( ( active0 & 0x6000000L ) != 0L ) { jjmatchedKind = 52 ; jjmatchedPos = 2 ; return 33 ; } return - 1 ; case 3 : if ( ( active0 & 0x4000000L ) != 0L ) { jjmatchedKind = 52 ; jjmatchedPos = 3 ; return 33 ; } if ( ( active0 & 0x2000000L ) != 0L ) return 33 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_0 ( int pos , long active0 ) { return jjMoveNfa_0 ( jjStopStringLiteralDfa_0 ( pos , active0 ) , pos + 1 ) ; } private final int jjStopAtPos ( int pos , int kind ) { jjmatchedKind = kind ; jjmatchedPos = pos ; return pos + 1 ; } private final int jjStartNfaWithStates_0 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_0 ( state , pos + 1 ) ; } private final int jjMoveStringLiteralDfa0_0 ( ) { switch ( curChar ) { case 33 : jjmatchedKind = 41 ; return jjMoveStringLiteralDfa1_0 ( 0x10000000000L ) ; case 35 : jjmatchedKind = 15 ; return jjMoveStringLiteralDfa1_0 ( 0x5000L ) ; case 37 : return jjStopAtPos ( 0 , 32 ) ; case 38 : return jjMoveStringLiteralDfa1_0 ( 0x200000000L ) ; case 40 : return jjStopAtPos ( 0 , 5 ) ; case 42 : return jjStopAtPos ( 0 , 30 ) ; case 43 : return jjStopAtPos ( 0 , 29 ) ; case 44 : return jjStopAtPos ( 0 , 3 ) ; case 45 : return jjStartNfaWithStates_0 ( 0 , 28 , 31 ) ; case 46 : return jjMoveStringLiteralDfa1_0 ( 0x10L ) ; case 47 : return jjStopAtPos ( 0 , 31 ) ; case 60 : jjmatchedKind = 35 ; return jjMoveStringLiteralDfa1_0 ( 0x1000000000L ) ; case 61 : jjmatchedKind = 42 ; return jjMoveStringLiteralDfa1_0 ( 0x8000000000L ) ; case 62 : jjmatchedKind = 37 ; return jjMoveStringLiteralDfa1_0 ( 0x4000000000L ) ; case 91 : return jjStopAtPos ( 0 , 1 ) ; case 93 : return jjStopAtPos ( 0 , 2 ) ; case 102 : return jjMoveStringLiteralDfa1_0 ( 0x4000000L ) ; case 116 : return jjMoveStringLiteralDfa1_0 ( 0x2000000L ) ; case 124 : return jjMoveStringLiteralDfa1_0 ( 0x400000000L ) ; default : return jjMoveNfa_0 ( 0 , 0 ) ; } } private final int jjMoveStringLiteralDfa1_0 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x1000L ) != 0L ) return jjStopAtPos ( 1 , 12 ) ; break ; case 38 : if ( ( active0 & 0x200000000L ) != 0L ) return jjStopAtPos ( 1 , 33 ) ; break ; case 42 : if ( ( active0 & 0x4000L ) != 0L ) return jjStartNfaWithStates_0 ( 1 , 14 , 5 ) ; break ; case 46 : if ( ( active0 & 0x10L ) != 0L ) return jjStopAtPos ( 1 , 4 ) ; break ; case 61 : if ( ( active0 & 0x1000000000L ) != 0L ) return jjStopAtPos ( 1 , 36 ) ; else if ( ( active0 & 0x4000000000L ) != 0L ) return jjStopAtPos ( 1 , 38 ) ; else if ( ( active0 & 0x8000000000L ) != 0L ) return jjStopAtPos ( 1 , 39 ) ; else if ( ( active0 & 0x10000000000L ) != 0L ) return jjStopAtPos ( 1 , 40 ) ; break ; case 97 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x4000000L ) ; case 114 : return jjMoveStringLiteralDfa2_0 ( active0 , 0x2000000L ) ; case 124 : if ( ( active0 & 0x400000000L ) != 0L ) return jjStopAtPos ( 1 , 34 ) ; break ; default : break ; } return jjStartNfa_0 ( 0 , active0 ) ; } private final int jjMoveStringLiteralDfa2_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_0 ( 0 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 1 , active0 ) ; return 2 ; } switch ( curChar ) { case 108 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x4000000L ) ; case 117 : return jjMoveStringLiteralDfa3_0 ( active0 , 0x2000000L ) ; default : break ; } return jjStartNfa_0 ( 1 , active0 ) ; } private final int jjMoveStringLiteralDfa3_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_0 ( 1 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 2 , active0 ) ; return 3 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x2000000L ) != 0L ) return jjStartNfaWithStates_0 ( 3 , 25 , 33 ) ; break ; case 115 : return jjMoveStringLiteralDfa4_0 ( active0 , 0x4000000L ) ; default : break ; } return jjStartNfa_0 ( 2 , active0 ) ; } private final int jjMoveStringLiteralDfa4_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_0 ( 2 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 3 , active0 ) ; return 4 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x4000000L ) != 0L ) return jjStartNfaWithStates_0 ( 4 , 26 , 33 ) ; break ; default : break ; } return jjStartNfa_0 ( 3 , active0 ) ; } private final void jjCheckNAdd ( int state ) { if ( jjrounds [ state ] != jjround ) { jjstateSet [ jjnewStateCnt ++ ] = state ; jjrounds [ state ] = jjround ; } } private final void jjAddStates ( int start , int end ) { do { jjstateSet [ jjnewStateCnt ++ ] = jjnextStates [ start ] ; } while ( start ++ != end ) ; } private final void jjCheckNAddTwoStates ( int state1 , int state2 ) { jjCheckNAdd ( state1 ) ; jjCheckNAdd ( state2 ) ; } private final void jjCheckNAddStates ( int start , int end ) { do { jjCheckNAdd ( jjnextStates [ start ] ) ; } while ( start ++ != end ) ; } private final void jjCheckNAddStates ( int start ) { jjCheckNAdd ( jjnextStates [ start ] ) ; jjCheckNAdd ( jjnextStates [ start + 1 ] ) ; } static final long [ ] jjbitVec0 = { 0xfffffffffffffffeL , 0xffffffffffffffffL , 0xffffffffffffffffL , 0xffffffffffffffffL } ; static final long [ ] jjbitVec2 = { 0x0L , 0x0L , 0xffffffffffffffffL , 0xffffffffffffffffL } ; private final int jjMoveNfa_0 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 42 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 0 : if ( ( 0x3ff000000000000L & l ) != 0L ) { if ( kind > 49 ) kind = 49 ; jjCheckNAdd ( 31 ) ; } else if ( ( 0x2400L & l ) != 0L ) { if ( kind > 27 ) kind = 27 ; } else if ( ( 0x100000200L & l ) != 0L ) { if ( kind > 23 ) kind = 23 ; jjCheckNAdd ( 9 ) ; } else if ( curChar == 36 ) { if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 39 , 40 ) ; } else if ( curChar == 45 ) jjCheckNAdd ( 31 ) ; else if ( curChar == 39 ) jjCheckNAddStates ( 0 , 2 ) ; else if ( curChar == 34 ) jjCheckNAddStates ( 3 , 5 ) ; else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; else if ( curChar == 41 ) { if ( kind > 6 ) kind = 6 ; jjCheckNAddStates ( 6 , 8 ) ; } if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 28 ; break ; case 1 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddStates ( 6 , 8 ) ; break ; case 2 : if ( ( 0x2400L & l ) != 0L && kind > 6 ) kind = 6 ; break ; case 3 : if ( curChar == 10 && kind > 6 ) kind = 6 ; break ; case 4 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 3 ; break ; case 5 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 6 ; break ; case 6 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 13 ) kind = 13 ; break ; case 7 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 8 : if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; break ; case 9 : if ( ( 0x100000200L & l ) == 0L ) break ; if ( kind > 23 ) kind = 23 ; jjCheckNAdd ( 9 ) ; break ; case 10 : if ( curChar == 34 ) jjCheckNAddStates ( 3 , 5 ) ; break ; case 11 : if ( ( 0xfffffffbffffdbffL & l ) != 0L ) jjCheckNAddStates ( 3 , 5 ) ; break ; case 12 : if ( curChar == 34 && kind > 24 ) kind = 24 ; break ; case 14 : if ( ( 0x8400000000L & l ) != 0L ) jjCheckNAddStates ( 3 , 5 ) ; break ; case 15 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 9 , 12 ) ; break ; case 16 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 3 , 5 ) ; break ; case 17 : if ( ( 0xf000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 18 ; break ; case 18 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 16 ) ; break ; case 19 : if ( curChar == 32 ) jjAddStates ( 13 , 14 ) ; break ; case 20 : if ( curChar == 10 ) jjCheckNAddStates ( 3 , 5 ) ; break ; case 21 : if ( curChar == 39 ) jjCheckNAddStates ( 0 , 2 ) ; break ; case 22 : if ( ( 0xffffff7fffffdbffL & l ) != 0L ) jjCheckNAddStates ( 0 , 2 ) ; break ; case 24 : if ( curChar == 32 ) jjAddStates ( 15 , 16 ) ; break ; case 25 : if ( curChar == 10 ) jjCheckNAddStates ( 0 , 2 ) ; break ; case 26 : if ( curChar == 39 && kind > 24 ) kind = 24 ; break ; case 27 : if ( ( 0x2400L & l ) != 0L && kind > 27 ) kind = 27 ; break ; case 28 : if ( curChar == 10 && kind > 27 ) kind = 27 ; break ; case 29 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 28 ; break ; case 30 : if ( curChar == 45 ) jjCheckNAdd ( 31 ) ; break ; case 31 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 49 ) kind = 49 ; jjCheckNAdd ( 31 ) ; break ; case 33 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjstateSet [ jjnewStateCnt ++ ] = 33 ; break ; case 36 : if ( curChar == 36 && kind > 10 ) kind = 10 ; break ; case 38 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 39 , 40 ) ; break ; case 40 : if ( curChar == 33 && kind > 11 ) kind = 11 ; break ; case 41 : if ( curChar != 36 ) break ; if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 39 , 40 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 0 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 52 ) kind = 52 ; jjCheckNAdd ( 33 ) ; } else if ( curChar == 92 ) jjCheckNAddStates ( 17 , 20 ) ; break ; case 6 : if ( kind > 13 ) kind = 13 ; break ; case 11 : if ( ( 0xffffffffefffffffL & l ) != 0L ) jjCheckNAddStates ( 3 , 5 ) ; break ; case 13 : if ( curChar == 92 ) jjAddStates ( 21 , 25 ) ; break ; case 14 : if ( ( 0x14404410000000L & l ) != 0L ) jjCheckNAddStates ( 3 , 5 ) ; break ; case 22 : jjAddStates ( 0 , 2 ) ; break ; case 23 : if ( curChar == 92 ) jjAddStates ( 15 , 16 ) ; break ; case 32 : case 33 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjCheckNAdd ( 33 ) ; break ; case 34 : if ( curChar == 92 ) jjCheckNAddStates ( 17 , 20 ) ; break ; case 35 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 35 , 36 ) ; break ; case 37 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 37 , 38 ) ; break ; case 39 : if ( curChar == 92 ) jjAddStates ( 26 , 27 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 6 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 13 ) kind = 13 ; break ; case 11 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 3 , 5 ) ; break ; case 22 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 0 , 2 ) ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 42 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_6 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0xd000L ) != 0L ) return 2 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_6 ( int pos , long active0 ) { return jjMoveNfa_6 ( jjStopStringLiteralDfa_6 ( pos , active0 ) , pos + 1 ) ; } private final int jjStartNfaWithStates_6 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_6 ( state , pos + 1 ) ; } private final int jjMoveStringLiteralDfa0_6 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 15 ; return jjMoveStringLiteralDfa1_6 ( 0x5000L ) ; case 42 : return jjMoveStringLiteralDfa1_6 ( 0x200000L ) ; default : return jjMoveNfa_6 ( 3 , 0 ) ; } } private final int jjMoveStringLiteralDfa1_6 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_6 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x1000L ) != 0L ) return jjStopAtPos ( 1 , 12 ) ; else if ( ( active0 & 0x200000L ) != 0L ) return jjStopAtPos ( 1 , 21 ) ; break ; case 42 : if ( ( active0 & 0x4000L ) != 0L ) return jjStartNfaWithStates_6 ( 1 , 14 , 0 ) ; break ; default : break ; } return jjStartNfa_6 ( 0 , active0 ) ; } private final int jjMoveNfa_6 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 12 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( curChar == 36 ) { if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 9 , 10 ) ; } else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 0 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; break ; case 1 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 13 ) kind = 13 ; break ; case 2 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 0 ; break ; case 6 : if ( curChar == 36 && kind > 10 ) kind = 10 ; break ; case 8 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 9 , 10 ) ; break ; case 10 : if ( curChar == 33 && kind > 11 ) kind = 11 ; break ; case 11 : if ( curChar != 36 ) break ; if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 9 , 10 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( curChar == 92 ) jjCheckNAddStates ( 28 , 31 ) ; break ; case 1 : if ( kind > 13 ) kind = 13 ; break ; case 5 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 5 , 6 ) ; break ; case 7 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 7 , 8 ) ; break ; case 9 : if ( curChar == 92 ) jjAddStates ( 32 , 33 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 1 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 13 ) kind = 13 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 12 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_4 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0xd000L ) != 0L ) return 2 ; if ( ( active0 & 0x200000000000L ) != 0L ) { jjmatchedKind = 52 ; return 22 ; } if ( ( active0 & 0x900000000000L ) != 0L ) { jjmatchedKind = 52 ; return 7 ; } return - 1 ; case 1 : if ( ( active0 & 0x4000L ) != 0L ) return 0 ; if ( ( active0 & 0x200000000000L ) != 0L ) { jjmatchedKind = 52 ; jjmatchedPos = 1 ; return 28 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { jjmatchedKind = 52 ; jjmatchedPos = 1 ; return 7 ; } if ( ( active0 & 0x100000000000L ) != 0L ) return 7 ; return - 1 ; case 2 : if ( ( active0 & 0x200000000000L ) != 0L ) { jjmatchedKind = 52 ; jjmatchedPos = 2 ; return 23 ; } if ( ( active0 & 0x800000000000L ) != 0L ) { jjmatchedKind = 52 ; jjmatchedPos = 2 ; return 7 ; } return - 1 ; case 3 : if ( ( active0 & 0x800000000000L ) != 0L ) return 7 ; if ( ( active0 & 0x200000000000L ) != 0L ) { jjmatchedKind = 46 ; jjmatchedPos = 3 ; return 30 ; } return - 1 ; case 4 : if ( ( active0 & 0x200000000000L ) != 0L ) { jjmatchedKind = 52 ; jjmatchedPos = 4 ; return 7 ; } return - 1 ; default : return - 1 ; } } private final int jjStartNfa_4 ( int pos , long active0 ) { return jjMoveNfa_4 ( jjStopStringLiteralDfa_4 ( pos , active0 ) , pos + 1 ) ; } private final int jjStartNfaWithStates_4 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_4 ( state , pos + 1 ) ; } private final int jjMoveStringLiteralDfa0_4 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 15 ; return jjMoveStringLiteralDfa1_4 ( 0x5000L ) ; case 101 : return jjMoveStringLiteralDfa1_4 ( 0x200000000000L ) ; case 105 : return jjMoveStringLiteralDfa1_4 ( 0x100000000000L ) ; case 115 : return jjMoveStringLiteralDfa1_4 ( 0x800000000000L ) ; default : return jjMoveNfa_4 ( 3 , 0 ) ; } } private final int jjMoveStringLiteralDfa1_4 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_4 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x1000L ) != 0L ) return jjStopAtPos ( 1 , 12 ) ; break ; case 42 : if ( ( active0 & 0x4000L ) != 0L ) return jjStartNfaWithStates_4 ( 1 , 14 , 0 ) ; break ; case 102 : if ( ( active0 & 0x100000000000L ) != 0L ) return jjStartNfaWithStates_4 ( 1 , 44 , 7 ) ; break ; case 108 : return jjMoveStringLiteralDfa2_4 ( active0 , 0x200000000000L ) ; case 116 : return jjMoveStringLiteralDfa2_4 ( active0 , 0x800000000000L ) ; default : break ; } return jjStartNfa_4 ( 0 , active0 ) ; } private final int jjMoveStringLiteralDfa2_4 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_4 ( 0 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_4 ( 1 , active0 ) ; return 2 ; } switch ( curChar ) { case 111 : return jjMoveStringLiteralDfa3_4 ( active0 , 0x800000000000L ) ; case 115 : return jjMoveStringLiteralDfa3_4 ( active0 , 0x200000000000L ) ; default : break ; } return jjStartNfa_4 ( 1 , active0 ) ; } private final int jjMoveStringLiteralDfa3_4 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_4 ( 1 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_4 ( 2 , active0 ) ; return 3 ; } switch ( curChar ) { case 101 : return jjMoveStringLiteralDfa4_4 ( active0 , 0x200000000000L ) ; case 112 : if ( ( active0 & 0x800000000000L ) != 0L ) return jjStartNfaWithStates_4 ( 3 , 47 , 7 ) ; break ; default : break ; } return jjStartNfa_4 ( 2 , active0 ) ; } private final int jjMoveStringLiteralDfa4_4 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_4 ( 2 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_4 ( 3 , active0 ) ; return 4 ; } switch ( curChar ) { case 105 : return jjMoveStringLiteralDfa5_4 ( active0 , 0x200000000000L ) ; default : break ; } return jjStartNfa_4 ( 3 , active0 ) ; } private final int jjMoveStringLiteralDfa5_4 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_4 ( 3 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_4 ( 4 , active0 ) ; return 5 ; } switch ( curChar ) { case 102 : if ( ( active0 & 0x200000000000L ) != 0L ) return jjStartNfaWithStates_4 ( 5 , 45 , 7 ) ; break ; default : break ; } return jjStartNfa_4 ( 4 , active0 ) ; } private final int jjMoveNfa_4 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 30 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( ( 0x3ff000000000000L & l ) != 0L ) { if ( kind > 49 ) kind = 49 ; jjCheckNAdd ( 5 ) ; } else if ( curChar == 36 ) { if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 13 , 14 ) ; } else if ( curChar == 45 ) jjCheckNAdd ( 5 ) ; else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 30 : if ( ( 0x3ff000000000000L & l ) != 0L ) { if ( kind > 52 ) kind = 52 ; jjCheckNAdd ( 7 ) ; } else if ( ( 0x2400L & l ) != 0L ) { if ( kind > 46 ) kind = 46 ; } else if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddStates ( 34 , 36 ) ; if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 26 ; break ; case 22 : case 7 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjCheckNAdd ( 7 ) ; break ; case 28 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjCheckNAdd ( 7 ) ; break ; case 23 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjCheckNAdd ( 7 ) ; break ; case 0 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; break ; case 1 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 13 ) kind = 13 ; break ; case 2 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 0 ; break ; case 4 : if ( curChar == 45 ) jjCheckNAdd ( 5 ) ; break ; case 5 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 49 ) kind = 49 ; jjCheckNAdd ( 5 ) ; break ; case 10 : if ( curChar == 36 && kind > 10 ) kind = 10 ; break ; case 12 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 13 , 14 ) ; break ; case 14 : if ( curChar == 33 && kind > 11 ) kind = 11 ; break ; case 15 : if ( curChar != 36 ) break ; if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 13 , 14 ) ; break ; case 18 : if ( ( 0x100000200L & l ) != 0L ) jjAddStates ( 37 , 39 ) ; break ; case 19 : if ( ( 0x2400L & l ) != 0L && kind > 43 ) kind = 43 ; break ; case 20 : if ( curChar == 10 && kind > 43 ) kind = 43 ; break ; case 21 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 20 ; break ; case 24 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddStates ( 34 , 36 ) ; break ; case 25 : if ( ( 0x2400L & l ) != 0L && kind > 46 ) kind = 46 ; break ; case 26 : if ( curChar == 10 && kind > 46 ) kind = 46 ; break ; case 27 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 26 ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 52 ) kind = 52 ; jjCheckNAdd ( 7 ) ; } else if ( curChar == 92 ) jjCheckNAddStates ( 40 , 43 ) ; if ( curChar == 101 ) jjAddStates ( 44 , 45 ) ; break ; case 30 : case 7 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjCheckNAdd ( 7 ) ; break ; case 22 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 52 ) kind = 52 ; jjCheckNAdd ( 7 ) ; } if ( curChar == 108 ) jjstateSet [ jjnewStateCnt ++ ] = 28 ; else if ( curChar == 110 ) jjstateSet [ jjnewStateCnt ++ ] = 17 ; break ; case 28 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 52 ) kind = 52 ; jjCheckNAdd ( 7 ) ; } if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 23 ; break ; case 23 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 52 ) kind = 52 ; jjCheckNAdd ( 7 ) ; } if ( curChar == 101 ) { if ( kind > 46 ) kind = 46 ; jjAddStates ( 34 , 36 ) ; } break ; case 1 : if ( kind > 13 ) kind = 13 ; break ; case 6 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 52 ) kind = 52 ; jjCheckNAdd ( 7 ) ; break ; case 8 : if ( curChar == 92 ) jjCheckNAddStates ( 40 , 43 ) ; break ; case 9 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 9 , 10 ) ; break ; case 11 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 11 , 12 ) ; break ; case 13 : if ( curChar == 92 ) jjAddStates ( 46 , 47 ) ; break ; case 16 : if ( curChar == 101 ) jjAddStates ( 44 , 45 ) ; break ; case 17 : if ( curChar != 100 ) break ; if ( kind > 43 ) kind = 43 ; jjAddStates ( 37 , 39 ) ; break ; case 29 : if ( curChar == 108 ) jjstateSet [ jjnewStateCnt ++ ] = 28 ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 1 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 13 ) kind = 13 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 30 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_3 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0x30000L ) != 0L ) return 9 ; if ( ( active0 & 0xd000L ) != 0L ) return 16 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_3 ( int pos , long active0 ) { return jjMoveNfa_3 ( jjStopStringLiteralDfa_3 ( pos , active0 ) , pos + 1 ) ; } private final int jjStartNfaWithStates_3 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_3 ( state , pos + 1 ) ; } private final int jjMoveStringLiteralDfa0_3 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 15 ; return jjMoveStringLiteralDfa1_3 ( 0x5000L ) ; case 92 : jjmatchedKind = 17 ; return jjMoveStringLiteralDfa1_3 ( 0x10000L ) ; default : return jjMoveNfa_3 ( 13 , 0 ) ; } } private final int jjMoveStringLiteralDfa1_3 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_3 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x1000L ) != 0L ) return jjStopAtPos ( 1 , 12 ) ; break ; case 42 : if ( ( active0 & 0x4000L ) != 0L ) return jjStartNfaWithStates_3 ( 1 , 14 , 14 ) ; break ; case 92 : if ( ( active0 & 0x10000L ) != 0L ) return jjStartNfaWithStates_3 ( 1 , 16 , 25 ) ; break ; default : break ; } return jjStartNfa_3 ( 0 , active0 ) ; } private final int jjMoveNfa_3 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 25 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 16 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 14 ; break ; case 13 : if ( ( 0xffffffe7ffffffffL & l ) != 0L ) { if ( kind > 18 ) kind = 18 ; jjCheckNAdd ( 7 ) ; } else if ( curChar == 36 ) { if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 22 , 23 ) ; } else if ( curChar == 35 ) jjCheckNAddTwoStates ( 5 , 16 ) ; if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddTwoStates ( 0 , 6 ) ; break ; case 25 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 22 , 23 ) ; if ( curChar == 36 ) { if ( kind > 10 ) kind = 10 ; } break ; case 9 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 22 , 23 ) ; else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 11 ; if ( curChar == 36 ) { if ( kind > 10 ) kind = 10 ; } break ; case 0 : if ( ( 0x100000200L & l ) != 0L ) jjCheckNAddTwoStates ( 0 , 6 ) ; break ; case 2 : if ( curChar == 32 ) jjAddStates ( 48 , 49 ) ; break ; case 3 : if ( curChar == 40 && kind > 9 ) kind = 9 ; break ; case 6 : if ( curChar == 35 ) jjCheckNAdd ( 5 ) ; break ; case 7 : if ( ( 0xffffffe7ffffffffL & l ) == 0L ) break ; if ( kind > 18 ) kind = 18 ; jjCheckNAdd ( 7 ) ; break ; case 10 : if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 11 ; break ; case 12 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 8 ) kind = 8 ; jjstateSet [ jjnewStateCnt ++ ] = 12 ; break ; case 14 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 15 ; break ; case 15 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 13 ) kind = 13 ; break ; case 19 : if ( curChar == 36 && kind > 10 ) kind = 10 ; break ; case 21 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 22 , 23 ) ; break ; case 23 : if ( curChar == 33 && kind > 11 ) kind = 11 ; break ; case 24 : if ( curChar != 36 ) break ; if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 22 , 23 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 16 : case 5 : if ( curChar == 115 ) jjstateSet [ jjnewStateCnt ++ ] = 4 ; break ; case 13 : if ( ( 0xffffffffefffffffL & l ) != 0L ) { if ( kind > 18 ) kind = 18 ; jjCheckNAdd ( 7 ) ; } else if ( curChar == 92 ) jjCheckNAddStates ( 50 , 53 ) ; if ( curChar == 92 ) jjAddStates ( 32 , 33 ) ; break ; case 25 : if ( curChar == 92 ) jjAddStates ( 32 , 33 ) ; if ( curChar == 92 ) jjCheckNAddTwoStates ( 20 , 21 ) ; if ( curChar == 92 ) jjCheckNAddTwoStates ( 18 , 19 ) ; break ; case 9 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 20 , 21 ) ; if ( curChar == 92 ) jjCheckNAddTwoStates ( 18 , 19 ) ; if ( curChar == 92 ) jjstateSet [ jjnewStateCnt ++ ] = 8 ; break ; case 1 : if ( curChar == 116 ) jjAddStates ( 48 , 49 ) ; break ; case 4 : if ( curChar == 101 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; break ; case 7 : if ( ( 0xffffffffefffffffL & l ) == 0L ) break ; if ( kind > 18 ) kind = 18 ; jjCheckNAdd ( 7 ) ; break ; case 8 : if ( curChar == 92 ) jjAddStates ( 32 , 33 ) ; break ; case 11 : case 12 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 8 ) kind = 8 ; jjCheckNAdd ( 12 ) ; break ; case 15 : if ( kind > 13 ) kind = 13 ; break ; case 17 : if ( curChar == 92 ) jjCheckNAddStates ( 50 , 53 ) ; break ; case 18 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 18 , 19 ) ; break ; case 20 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 20 , 21 ) ; break ; case 22 : if ( curChar == 92 ) jjAddStates ( 54 , 55 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 13 : case 7 : if ( ! jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) break ; if ( kind > 18 ) kind = 18 ; jjCheckNAdd ( 7 ) ; break ; case 15 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 13 ) kind = 13 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 25 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_7 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0xd000L ) != 0L ) return 2 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_7 ( int pos , long active0 ) { return jjMoveNfa_7 ( jjStopStringLiteralDfa_7 ( pos , active0 ) , pos + 1 ) ; } private final int jjStartNfaWithStates_7 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_7 ( state , pos + 1 ) ; } private final int jjMoveStringLiteralDfa0_7 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 15 ; return jjMoveStringLiteralDfa1_7 ( 0x5000L ) ; case 42 : return jjMoveStringLiteralDfa1_7 ( 0x100000L ) ; default : return jjMoveNfa_7 ( 3 , 0 ) ; } } private final int jjMoveStringLiteralDfa1_7 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_7 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x1000L ) != 0L ) return jjStopAtPos ( 1 , 12 ) ; else if ( ( active0 & 0x100000L ) != 0L ) return jjStopAtPos ( 1 , 20 ) ; break ; case 42 : if ( ( active0 & 0x4000L ) != 0L ) return jjStartNfaWithStates_7 ( 1 , 14 , 0 ) ; break ; default : break ; } return jjStartNfa_7 ( 0 , active0 ) ; } private final int jjMoveNfa_7 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 12 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( curChar == 36 ) { if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 9 , 10 ) ; } else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 0 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; break ; case 1 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 13 ) kind = 13 ; break ; case 2 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 0 ; break ; case 6 : if ( curChar == 36 && kind > 10 ) kind = 10 ; break ; case 8 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 9 , 10 ) ; break ; case 10 : if ( curChar == 33 && kind > 11 ) kind = 11 ; break ; case 11 : if ( curChar != 36 ) break ; if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 9 , 10 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( curChar == 92 ) jjCheckNAddStates ( 28 , 31 ) ; break ; case 1 : if ( kind > 13 ) kind = 13 ; break ; case 5 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 5 , 6 ) ; break ; case 7 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 7 , 8 ) ; break ; case 9 : if ( curChar == 92 ) jjAddStates ( 32 , 33 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 1 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 13 ) kind = 13 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 12 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_8 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0xd000L ) != 0L ) return 2 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_8 ( int pos , long active0 ) { return jjMoveNfa_8 ( jjStopStringLiteralDfa_8 ( pos , active0 ) , pos + 1 ) ; } private final int jjStartNfaWithStates_8 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_8 ( state , pos + 1 ) ; } private final int jjMoveStringLiteralDfa0_8 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 15 ; return jjMoveStringLiteralDfa1_8 ( 0x5000L ) ; default : return jjMoveNfa_8 ( 3 , 0 ) ; } } private final int jjMoveStringLiteralDfa1_8 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_8 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x1000L ) != 0L ) return jjStopAtPos ( 1 , 12 ) ; break ; case 42 : if ( ( active0 & 0x4000L ) != 0L ) return jjStartNfaWithStates_8 ( 1 , 14 , 0 ) ; break ; default : break ; } return jjStartNfa_8 ( 0 , active0 ) ; } private final int jjMoveNfa_8 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 15 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( ( 0x2400L & l ) != 0L ) { if ( kind > 19 ) kind = 19 ; } else if ( curChar == 36 ) { if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 12 , 13 ) ; } else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 0 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; break ; case 1 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 13 ) kind = 13 ; break ; case 2 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 0 ; break ; case 4 : if ( ( 0x2400L & l ) != 0L && kind > 19 ) kind = 19 ; break ; case 5 : if ( curChar == 10 && kind > 19 ) kind = 19 ; break ; case 6 : if ( curChar == 13 ) jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 9 : if ( curChar == 36 && kind > 10 ) kind = 10 ; break ; case 11 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 12 , 13 ) ; break ; case 13 : if ( curChar == 33 && kind > 11 ) kind = 11 ; break ; case 14 : if ( curChar != 36 ) break ; if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 12 , 13 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( curChar == 92 ) jjCheckNAddStates ( 56 , 59 ) ; break ; case 1 : if ( kind > 13 ) kind = 13 ; break ; case 8 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 8 , 9 ) ; break ; case 10 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 10 , 11 ) ; break ; case 12 : if ( curChar == 92 ) jjAddStates ( 60 , 61 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 1 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 13 ) kind = 13 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 15 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_5 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0xd000L ) != 0L ) return 2 ; if ( ( active0 & 0x6000000L ) != 0L ) { jjmatchedKind = 56 ; return 5 ; } return - 1 ; case 1 : if ( ( active0 & 0x4000L ) != 0L ) return 0 ; if ( ( active0 & 0x6000000L ) != 0L ) { jjmatchedKind = 56 ; jjmatchedPos = 1 ; return 5 ; } return - 1 ; case 2 : if ( ( active0 & 0x6000000L ) != 0L ) { jjmatchedKind = 56 ; jjmatchedPos = 2 ; return 5 ; } return - 1 ; case 3 : if ( ( active0 & 0x4000000L ) != 0L ) { jjmatchedKind = 56 ; jjmatchedPos = 3 ; return 5 ; } if ( ( active0 & 0x2000000L ) != 0L ) return 5 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_5 ( int pos , long active0 ) { return jjMoveNfa_5 ( jjStopStringLiteralDfa_5 ( pos , active0 ) , pos + 1 ) ; } private final int jjStartNfaWithStates_5 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_5 ( state , pos + 1 ) ; } private final int jjMoveStringLiteralDfa0_5 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 15 ; return jjMoveStringLiteralDfa1_5 ( 0x5000L ) ; case 102 : return jjMoveStringLiteralDfa1_5 ( 0x4000000L ) ; case 116 : return jjMoveStringLiteralDfa1_5 ( 0x2000000L ) ; case 123 : return jjStopAtPos ( 0 , 58 ) ; case 125 : return jjStopAtPos ( 0 , 59 ) ; default : return jjMoveNfa_5 ( 3 , 0 ) ; } } private final int jjMoveStringLiteralDfa1_5 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_5 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x1000L ) != 0L ) return jjStopAtPos ( 1 , 12 ) ; break ; case 42 : if ( ( active0 & 0x4000L ) != 0L ) return jjStartNfaWithStates_5 ( 1 , 14 , 0 ) ; break ; case 97 : return jjMoveStringLiteralDfa2_5 ( active0 , 0x4000000L ) ; case 114 : return jjMoveStringLiteralDfa2_5 ( active0 , 0x2000000L ) ; default : break ; } return jjStartNfa_5 ( 0 , active0 ) ; } private final int jjMoveStringLiteralDfa2_5 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_5 ( 0 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_5 ( 1 , active0 ) ; return 2 ; } switch ( curChar ) { case 108 : return jjMoveStringLiteralDfa3_5 ( active0 , 0x4000000L ) ; case 117 : return jjMoveStringLiteralDfa3_5 ( active0 , 0x2000000L ) ; default : break ; } return jjStartNfa_5 ( 1 , active0 ) ; } private final int jjMoveStringLiteralDfa3_5 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_5 ( 1 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_5 ( 2 , active0 ) ; return 3 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x2000000L ) != 0L ) return jjStartNfaWithStates_5 ( 3 , 25 , 5 ) ; break ; case 115 : return jjMoveStringLiteralDfa4_5 ( active0 , 0x4000000L ) ; default : break ; } return jjStartNfa_5 ( 2 , active0 ) ; } private final int jjMoveStringLiteralDfa4_5 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_5 ( 2 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_5 ( 3 , active0 ) ; return 4 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x4000000L ) != 0L ) return jjStartNfaWithStates_5 ( 4 , 26 , 5 ) ; break ; default : break ; } return jjStartNfa_5 ( 3 , active0 ) ; } private final int jjMoveNfa_5 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 16 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( curChar == 36 ) { if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 13 , 14 ) ; } else if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 0 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; break ; case 1 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 13 ) kind = 13 ; break ; case 2 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 0 ; break ; case 5 : if ( ( 0x3ff200000000000L & l ) == 0L ) break ; if ( kind > 56 ) kind = 56 ; jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 6 : if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; break ; case 10 : if ( curChar == 36 && kind > 10 ) kind = 10 ; break ; case 12 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 13 , 14 ) ; break ; case 14 : if ( curChar == 33 && kind > 11 ) kind = 11 ; break ; case 15 : if ( curChar != 36 ) break ; if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 13 , 14 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 56 ) kind = 56 ; jjCheckNAdd ( 5 ) ; } else if ( curChar == 92 ) jjCheckNAddStates ( 40 , 43 ) ; break ; case 1 : if ( kind > 13 ) kind = 13 ; break ; case 4 : case 5 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 56 ) kind = 56 ; jjCheckNAdd ( 5 ) ; break ; case 7 : if ( ( 0x7fffffe07fffffeL & l ) != 0L && kind > 57 ) kind = 57 ; break ; case 8 : if ( curChar == 92 ) jjCheckNAddStates ( 40 , 43 ) ; break ; case 9 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 9 , 10 ) ; break ; case 11 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 11 , 12 ) ; break ; case 13 : if ( curChar == 92 ) jjAddStates ( 46 , 47 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 1 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 13 ) kind = 13 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 16 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_1 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0xd000L ) != 0L ) return 2 ; if ( ( active0 & 0x6000000L ) != 0L ) { jjmatchedKind = 56 ; return 25 ; } if ( ( active0 & 0x10L ) != 0L ) return 27 ; return - 1 ; case 1 : if ( ( active0 & 0x4000L ) != 0L ) return 0 ; if ( ( active0 & 0x6000000L ) != 0L ) { jjmatchedKind = 56 ; jjmatchedPos = 1 ; return 25 ; } return - 1 ; case 2 : if ( ( active0 & 0x6000000L ) != 0L ) { jjmatchedKind = 56 ; jjmatchedPos = 2 ; return 25 ; } return - 1 ; case 3 : if ( ( active0 & 0x4000000L ) != 0L ) { jjmatchedKind = 56 ; jjmatchedPos = 3 ; return 25 ; } if ( ( active0 & 0x2000000L ) != 0L ) return 25 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_1 ( int pos , long active0 ) { return jjMoveNfa_1 ( jjStopStringLiteralDfa_1 ( pos , active0 ) , pos + 1 ) ; } private final int jjStartNfaWithStates_1 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_1 ( state , pos + 1 ) ; } private final int jjMoveStringLiteralDfa0_1 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 15 ; return jjMoveStringLiteralDfa1_1 ( 0x5000L ) ; case 41 : return jjStopAtPos ( 0 , 7 ) ; case 44 : return jjStopAtPos ( 0 , 3 ) ; case 46 : return jjMoveStringLiteralDfa1_1 ( 0x10L ) ; case 91 : return jjStopAtPos ( 0 , 1 ) ; case 93 : return jjStopAtPos ( 0 , 2 ) ; case 102 : return jjMoveStringLiteralDfa1_1 ( 0x4000000L ) ; case 116 : return jjMoveStringLiteralDfa1_1 ( 0x2000000L ) ; case 123 : return jjStopAtPos ( 0 , 58 ) ; case 125 : return jjStopAtPos ( 0 , 59 ) ; default : return jjMoveNfa_1 ( 3 , 0 ) ; } } private final int jjMoveStringLiteralDfa1_1 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_1 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x1000L ) != 0L ) return jjStopAtPos ( 1 , 12 ) ; break ; case 42 : if ( ( active0 & 0x4000L ) != 0L ) return jjStartNfaWithStates_1 ( 1 , 14 , 0 ) ; break ; case 46 : if ( ( active0 & 0x10L ) != 0L ) return jjStopAtPos ( 1 , 4 ) ; break ; case 97 : return jjMoveStringLiteralDfa2_1 ( active0 , 0x4000000L ) ; case 114 : return jjMoveStringLiteralDfa2_1 ( active0 , 0x2000000L ) ; default : break ; } return jjStartNfa_1 ( 0 , active0 ) ; } private final int jjMoveStringLiteralDfa2_1 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_1 ( 0 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_1 ( 1 , active0 ) ; return 2 ; } switch ( curChar ) { case 108 : return jjMoveStringLiteralDfa3_1 ( active0 , 0x4000000L ) ; case 117 : return jjMoveStringLiteralDfa3_1 ( active0 , 0x2000000L ) ; default : break ; } return jjStartNfa_1 ( 1 , active0 ) ; } private final int jjMoveStringLiteralDfa3_1 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_1 ( 1 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_1 ( 2 , active0 ) ; return 3 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x2000000L ) != 0L ) return jjStartNfaWithStates_1 ( 3 , 25 , 25 ) ; break ; case 115 : return jjMoveStringLiteralDfa4_1 ( active0 , 0x4000000L ) ; default : break ; } return jjStartNfa_1 ( 2 , active0 ) ; } private final int jjMoveStringLiteralDfa4_1 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_1 ( 2 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_1 ( 3 , active0 ) ; return 4 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x4000000L ) != 0L ) return jjStartNfaWithStates_1 ( 4 , 26 , 25 ) ; break ; default : break ; } return jjStartNfa_1 ( 3 , active0 ) ; } private final int jjMoveNfa_1 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 36 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( ( 0x3ff000000000000L & l ) != 0L ) { if ( kind > 49 ) kind = 49 ; jjCheckNAdd ( 23 ) ; } else if ( ( 0x100000200L & l ) != 0L ) { if ( kind > 23 ) kind = 23 ; jjCheckNAdd ( 4 ) ; } else if ( curChar == 36 ) { if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 33 , 34 ) ; } else if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 27 ; else if ( curChar == 45 ) jjCheckNAdd ( 23 ) ; else if ( curChar == 39 ) jjCheckNAddStates ( 62 , 64 ) ; else if ( curChar == 34 ) jjCheckNAddStates ( 65 , 67 ) ; else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 0 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; break ; case 1 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 13 ) kind = 13 ; break ; case 2 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 0 ; break ; case 4 : if ( ( 0x100000200L & l ) == 0L ) break ; if ( kind > 23 ) kind = 23 ; jjCheckNAdd ( 4 ) ; break ; case 5 : if ( curChar == 34 ) jjCheckNAddStates ( 65 , 67 ) ; break ; case 6 : if ( ( 0xfffffffbffffdbffL & l ) != 0L ) jjCheckNAddStates ( 65 , 67 ) ; break ; case 7 : if ( curChar == 34 && kind > 24 ) kind = 24 ; break ; case 9 : if ( ( 0x8400000000L & l ) != 0L ) jjCheckNAddStates ( 65 , 67 ) ; break ; case 10 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 68 , 71 ) ; break ; case 11 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAddStates ( 65 , 67 ) ; break ; case 12 : if ( ( 0xf000000000000L & l ) != 0L ) jjstateSet [ jjnewStateCnt ++ ] = 13 ; break ; case 13 : if ( ( 0xff000000000000L & l ) != 0L ) jjCheckNAdd ( 11 ) ; break ; case 14 : if ( curChar == 32 ) jjAddStates ( 72 , 73 ) ; break ; case 15 : if ( curChar == 10 ) jjCheckNAddStates ( 65 , 67 ) ; break ; case 16 : if ( curChar == 39 ) jjCheckNAddStates ( 62 , 64 ) ; break ; case 17 : if ( ( 0xffffff7fffffdbffL & l ) != 0L ) jjCheckNAddStates ( 62 , 64 ) ; break ; case 19 : if ( curChar == 32 ) jjAddStates ( 13 , 14 ) ; break ; case 20 : if ( curChar == 10 ) jjCheckNAddStates ( 62 , 64 ) ; break ; case 21 : if ( curChar == 39 && kind > 24 ) kind = 24 ; break ; case 22 : if ( curChar == 45 ) jjCheckNAdd ( 23 ) ; break ; case 23 : if ( ( 0x3ff000000000000L & l ) == 0L ) break ; if ( kind > 49 ) kind = 49 ; jjCheckNAdd ( 23 ) ; break ; case 25 : if ( ( 0x3ff200000000000L & l ) == 0L ) break ; if ( kind > 56 ) kind = 56 ; jjstateSet [ jjnewStateCnt ++ ] = 25 ; break ; case 26 : if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 27 ; break ; case 30 : if ( curChar == 36 && kind > 10 ) kind = 10 ; break ; case 32 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 33 , 34 ) ; break ; case 34 : if ( curChar == 33 && kind > 11 ) kind = 11 ; break ; case 35 : if ( curChar != 36 ) break ; if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 33 , 34 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 56 ) kind = 56 ; jjCheckNAdd ( 25 ) ; } else if ( curChar == 92 ) jjCheckNAddStates ( 74 , 77 ) ; break ; case 1 : if ( kind > 13 ) kind = 13 ; break ; case 6 : if ( ( 0xffffffffefffffffL & l ) != 0L ) jjCheckNAddStates ( 65 , 67 ) ; break ; case 8 : if ( curChar == 92 ) jjAddStates ( 78 , 82 ) ; break ; case 9 : if ( ( 0x14404410000000L & l ) != 0L ) jjCheckNAddStates ( 65 , 67 ) ; break ; case 17 : jjAddStates ( 62 , 64 ) ; break ; case 18 : if ( curChar == 92 ) jjAddStates ( 13 , 14 ) ; break ; case 24 : case 25 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 56 ) kind = 56 ; jjCheckNAdd ( 25 ) ; break ; case 27 : if ( ( 0x7fffffe07fffffeL & l ) != 0L && kind > 57 ) kind = 57 ; break ; case 28 : if ( curChar == 92 ) jjCheckNAddStates ( 74 , 77 ) ; break ; case 29 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 29 , 30 ) ; break ; case 31 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 31 , 32 ) ; break ; case 33 : if ( curChar == 92 ) jjAddStates ( 83 , 84 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 1 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 13 ) kind = 13 ; break ; case 6 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 65 , 67 ) ; break ; case 17 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) ) jjAddStates ( 62 , 64 ) ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 36 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } private final int jjStopStringLiteralDfa_2 ( int pos , long active0 ) { switch ( pos ) { case 0 : if ( ( active0 & 0xd000L ) != 0L ) return 2 ; if ( ( active0 & 0x6000000L ) != 0L ) { jjmatchedKind = 56 ; return 5 ; } return - 1 ; case 1 : if ( ( active0 & 0x4000L ) != 0L ) return 0 ; if ( ( active0 & 0x6000000L ) != 0L ) { jjmatchedKind = 56 ; jjmatchedPos = 1 ; return 5 ; } return - 1 ; case 2 : if ( ( active0 & 0x6000000L ) != 0L ) { jjmatchedKind = 56 ; jjmatchedPos = 2 ; return 5 ; } return - 1 ; case 3 : if ( ( active0 & 0x4000000L ) != 0L ) { jjmatchedKind = 56 ; jjmatchedPos = 3 ; return 5 ; } if ( ( active0 & 0x2000000L ) != 0L ) return 5 ; return - 1 ; default : return - 1 ; } } private final int jjStartNfa_2 ( int pos , long active0 ) { return jjMoveNfa_2 ( jjStopStringLiteralDfa_2 ( pos , active0 ) , pos + 1 ) ; } private final int jjStartNfaWithStates_2 ( int pos , int kind , int state ) { jjmatchedKind = kind ; jjmatchedPos = pos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return pos + 1 ; } return jjMoveNfa_2 ( state , pos + 1 ) ; } private final int jjMoveStringLiteralDfa0_2 ( ) { switch ( curChar ) { case 35 : jjmatchedKind = 15 ; return jjMoveStringLiteralDfa1_2 ( 0x5000L ) ; case 40 : return jjStopAtPos ( 0 , 5 ) ; case 102 : return jjMoveStringLiteralDfa1_2 ( 0x4000000L ) ; case 116 : return jjMoveStringLiteralDfa1_2 ( 0x2000000L ) ; case 123 : return jjStopAtPos ( 0 , 58 ) ; case 125 : return jjStopAtPos ( 0 , 59 ) ; default : return jjMoveNfa_2 ( 3 , 0 ) ; } } private final int jjMoveStringLiteralDfa1_2 ( long active0 ) { try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_2 ( 0 , active0 ) ; return 1 ; } switch ( curChar ) { case 35 : if ( ( active0 & 0x1000L ) != 0L ) return jjStopAtPos ( 1 , 12 ) ; break ; case 42 : if ( ( active0 & 0x4000L ) != 0L ) return jjStartNfaWithStates_2 ( 1 , 14 , 0 ) ; break ; case 97 : return jjMoveStringLiteralDfa2_2 ( active0 , 0x4000000L ) ; case 114 : return jjMoveStringLiteralDfa2_2 ( active0 , 0x2000000L ) ; default : break ; } return jjStartNfa_2 ( 0 , active0 ) ; } private final int jjMoveStringLiteralDfa2_2 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_2 ( 0 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_2 ( 1 , active0 ) ; return 2 ; } switch ( curChar ) { case 108 : return jjMoveStringLiteralDfa3_2 ( active0 , 0x4000000L ) ; case 117 : return jjMoveStringLiteralDfa3_2 ( active0 , 0x2000000L ) ; default : break ; } return jjStartNfa_2 ( 1 , active0 ) ; } private final int jjMoveStringLiteralDfa3_2 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_2 ( 1 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_2 ( 2 , active0 ) ; return 3 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x2000000L ) != 0L ) return jjStartNfaWithStates_2 ( 3 , 25 , 5 ) ; break ; case 115 : return jjMoveStringLiteralDfa4_2 ( active0 , 0x4000000L ) ; default : break ; } return jjStartNfa_2 ( 2 , active0 ) ; } private final int jjMoveStringLiteralDfa4_2 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0L ) return jjStartNfa_2 ( 2 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_2 ( 3 , active0 ) ; return 4 ; } switch ( curChar ) { case 101 : if ( ( active0 & 0x4000000L ) != 0L ) return jjStartNfaWithStates_2 ( 4 , 26 , 5 ) ; break ; default : break ; } return jjStartNfa_2 ( 3 , active0 ) ; } private final int jjMoveNfa_2 ( int startState , int curPos ) { int [ ] nextStates ; int startsAt = 0 ; jjnewStateCnt = 16 ; int i = 1 ; jjstateSet [ 0 ] = startState ; int j , kind = 0x7fffffff ; for ( ; ; ) { if ( ++ jjround == 0x7fffffff ) ReInitRounds ( ) ; if ( curChar < 64 ) { long l = 1L << curChar ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( curChar == 36 ) { if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 13 , 14 ) ; } else if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; else if ( curChar == 35 ) jjstateSet [ jjnewStateCnt ++ ] = 2 ; break ; case 0 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 1 ; break ; case 1 : if ( ( 0xfffffff7ffffffffL & l ) != 0L && kind > 13 ) kind = 13 ; break ; case 2 : if ( curChar == 42 ) jjstateSet [ jjnewStateCnt ++ ] = 0 ; break ; case 5 : if ( ( 0x3ff200000000000L & l ) == 0L ) break ; if ( kind > 56 ) kind = 56 ; jjstateSet [ jjnewStateCnt ++ ] = 5 ; break ; case 6 : if ( curChar == 46 ) jjstateSet [ jjnewStateCnt ++ ] = 7 ; break ; case 10 : if ( curChar == 36 && kind > 10 ) kind = 10 ; break ; case 12 : if ( curChar == 36 ) jjCheckNAddTwoStates ( 13 , 14 ) ; break ; case 14 : if ( curChar == 33 && kind > 11 ) kind = 11 ; break ; case 15 : if ( curChar != 36 ) break ; if ( kind > 10 ) kind = 10 ; jjCheckNAddTwoStates ( 13 , 14 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else if ( curChar < 128 ) { long l = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 3 : if ( ( 0x7fffffe87fffffeL & l ) != 0L ) { if ( kind > 56 ) kind = 56 ; jjCheckNAdd ( 5 ) ; } else if ( curChar == 92 ) jjCheckNAddStates ( 40 , 43 ) ; break ; case 1 : if ( kind > 13 ) kind = 13 ; break ; case 4 : case 5 : if ( ( 0x7fffffe87fffffeL & l ) == 0L ) break ; if ( kind > 56 ) kind = 56 ; jjCheckNAdd ( 5 ) ; break ; case 7 : if ( ( 0x7fffffe07fffffeL & l ) != 0L && kind > 57 ) kind = 57 ; break ; case 8 : if ( curChar == 92 ) jjCheckNAddStates ( 40 , 43 ) ; break ; case 9 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 9 , 10 ) ; break ; case 11 : if ( curChar == 92 ) jjCheckNAddTwoStates ( 11 , 12 ) ; break ; case 13 : if ( curChar == 92 ) jjAddStates ( 46 , 47 ) ; break ; default : break ; } } while ( i != startsAt ) ; } else { int hiByte = ( int ) ( curChar > > 8 ) ; int i1 = hiByte > > 6 ; long l1 = 1L << ( hiByte & 077 ) ; int i2 = ( curChar & 0xff ) > > 6 ; long l2 = 1L << ( curChar & 077 ) ; MatchLoop : do { switch ( jjstateSet [ -- i ] ) { case 1 : if ( jjCanMove_0 ( hiByte , i1 , i2 , l1 , l2 ) && kind > 13 ) kind = 13 ; break ; default : break ; } } while ( i != startsAt ) ; } if ( kind != 0x7fffffff ) { jjmatchedKind = kind ; jjmatchedPos = curPos ; kind = 0x7fffffff ; } ++ curPos ; if ( ( i = jjnewStateCnt ) == ( startsAt = 16 - ( jjnewStateCnt = startsAt ) ) ) return curPos ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return curPos ; } } } static final int [ ] jjnextStates = { 22 , 23 , 26 , 11 , 12 , 13 , 1 , 2 , 4 , 11 , 16 , 12 , 13 , 19 , 20 , 24 , 25 , 35 , 36 , 37 , 38 , 14 , 15 , 17 , 19 , 20 , 39 , 40 , 5 , 6 , 7 , 8 , 9 , 10 , 24 , 25 , 27 , 18 , 19 , 21 , 9 , 10 , 11 , 12 , 22 , 29 , 13 , 14 , 2 , 3 , 18 , 19 , 20 , 21 , 22 , 23 , 8 , 9 , 10 , 11 , 12 , 13 , 17 , 18 , 21 , 6 , 7 , 8 , 6 , 11 , 7 , 8 , 14 , 15 , 29 , 30 , 31 , 32 , 9 , 10 , 12 , 14 , 15 , 33 , 34 , } ; private static final boolean jjCanMove_0 ( int hiByte , int i1 , int i2 , long l1 , long l2 ) { switch ( hiByte ) { case 0 : return ( ( jjbitVec2 [ i2 ] & l2 ) != 0L ) ; default : if ( ( jjbitVec0 [ i1 ] & l1 ) != 0L ) return true ; return false ; } } public static final String [ ] jjstrLiteralImages = { null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , } ; public static final String [ ] lexStateNames = { "DIRECTIVE" , "REFMOD2" , "REFMODIFIER" , "DEFAULT" , "PRE_DIRECTIVE" , "REFERENCE" , "IN_MULTI_LINE_COMMENT" , "IN_FORMAL_COMMENT" , "IN_SINGLE_LINE_COMMENT" , } ; public static final int [ ] jjnewLexState = { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } ; static final long [ ] jjtoToken = { 0xf12ffffffbf03ffL , } ; static final long [ ] jjtoSkip = { 0x3000000000000000L , } ; static final long [ ] jjtoSpecial = { 0x3000000000000000L , } ; static final long [ ] jjtoMore = { 0x40fc00L , } ; private CharStream input_stream ; private final int [ ] jjrounds = new int [ 42 ] ; private final int [ ] jjstateSet = new int [ 84 ] ; StringBuffer image ; int jjimageLen ; int lengthOfMatch ; protected char curChar ; public ParserTokenManager ( CharStream stream ) { input_stream = stream ; } public ParserTokenManager ( CharStream stream , int lexState ) { this ( stream ) ; SwitchTo ( lexState ) ; } public void ReInit ( CharStream stream ) { jjmatchedPos = jjnewStateCnt = 0 ; curLexState = defaultLexState ; input_stream = stream ; ReInitRounds ( ) ; } private final void ReInitRounds ( ) { int i ; jjround = 0x80000001 ; for ( i = 42 ; i -- > 0 ; ) jjrounds [ i ] = 0x80000000 ; } public void ReInit ( CharStream stream , int lexState ) { ReInit ( stream ) ; SwitchTo ( lexState ) ; } public void SwitchTo ( int lexState ) { if ( lexState >= 9 || lexState < 0 ) throw new TokenMgrError ( "Error: Ignoring invalid lexical state : " + lexState + ". State unchanged." , TokenMgrError . INVALID_LEXICAL_STATE ) ; else curLexState = lexState ; } private final Token jjFillToken ( ) { Token t = Token . newToken ( jjmatchedKind ) ; t . kind = jjmatchedKind ; String im = jjstrLiteralImages [ jjmatchedKind ] ; t . image = ( im == null ) ? input_stream . GetImage ( ) : im ; t . beginLine = input_stream . getBeginLine ( ) ; t . beginColumn = input_stream . getBeginColumn ( ) ; t . endLine = input_stream . getEndLine ( ) ; t . endColumn = input_stream . getEndColumn ( ) ; return t ; } int curLexState = 3 ; int defaultLexState = 3 ; int jjnewStateCnt ; int jjround ; int jjmatchedPos ; int jjmatchedKind ; public final Token getNextToken ( ) { int kind ; Token specialToken = null ; Token matchedToken ; int curPos = 0 ; EOFLoop : for ( ; ; ) { try { curChar = input_stream . BeginToken ( ) ; } catch ( java . io . IOException e ) { jjmatchedKind = 0 ; matchedToken = jjFillToken ( ) ; matchedToken . specialToken = specialToken ; return matchedToken ; } image = null ; jjimageLen = 0 ; for ( ; ; ) { switch ( curLexState ) { case 0 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_0 ( ) ; break ; case 1 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_1 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 60 ) { jjmatchedKind = 60 ; } break ; case 2 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_2 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 60 ) { jjmatchedKind = 60 ; } break ; case 3 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_3 ( ) ; break ; case 4 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_4 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 61 ) { jjmatchedKind = 61 ; } break ; case 5 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_5 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 60 ) { jjmatchedKind = 60 ; } break ; case 6 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_6 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 22 ) { jjmatchedKind = 22 ; } break ; case 7 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_7 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 22 ) { jjmatchedKind = 22 ; } break ; case 8 : jjmatchedKind = 0x7fffffff ; jjmatchedPos = 0 ; curPos = jjMoveStringLiteralDfa0_8 ( ) ; if ( jjmatchedPos == 0 && jjmatchedKind > 22 ) { jjmatchedKind = 22 ; } break ; } if ( jjmatchedKind != 0x7fffffff ) { if ( jjmatchedPos + 1 < curPos ) input_stream . backup ( curPos - jjmatchedPos - 1 ) ; if ( ( jjtoToken [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { matchedToken = jjFillToken ( ) ; matchedToken . specialToken = specialToken ; TokenLexicalActions ( matchedToken ) ; if ( jjnewLexState [ jjmatchedKind ] != - 1 ) curLexState = jjnewLexState [ jjmatchedKind ] ; return matchedToken ; } else if ( ( jjtoSkip [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { if ( ( jjtoSpecial [ jjmatchedKind > > 6 ] & ( 1L << ( jjmatchedKind & 077 ) ) ) != 0L ) { matchedToken = jjFillToken ( ) ; if ( specialToken == null ) specialToken = matchedToken ; else { matchedToken . specialToken = specialToken ; specialToken = ( specialToken . next = matchedToken ) ; } SkipLexicalActions ( matchedToken ) ; } else SkipLexicalActions ( null ) ; if ( jjnewLexState [ jjmatchedKind ] != - 1 ) curLexState = jjnewLexState [ jjmatchedKind ] ; continue EOFLoop ; } MoreLexicalActions ( ) ; if ( jjnewLexState [ jjmatchedKind ] != - 1 ) curLexState = jjnewLexState [ jjmatchedKind ] ; curPos = 0 ; jjmatchedKind = 0x7fffffff ; try { curChar = input_stream . readChar ( ) ; continue ; } catch ( java . io . IOException e1 ) { } } int error_line = input_stream . getEndLine ( ) ; int error_column = input_stream . getEndColumn ( ) ; String error_after = null ; boolean EOFSeen = false ; try { input_stream . readChar ( ) ; input_stream . backup ( 1 ) ; } catch ( java . io . IOException e1 ) { EOFSeen = true ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; if ( curChar == '\n' || curChar == '\r' ) { error_line ++ ; error_column = 0 ; } else error_column ++ ; } if ( ! EOFSeen ) { input_stream . backup ( 1 ) ; error_after = curPos <= 1 ? "" : input_stream . GetImage ( ) ; } throw new TokenMgrError ( EOFSeen , curLexState , error_line , error_column , error_after , curChar , TokenMgrError . LEXICAL_ERROR ) ; } } } final void SkipLexicalActions ( Token matchedToken ) { switch ( jjmatchedKind ) { case 60 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; input_stream . backup ( 1 ) ; inReference = false ; if ( debugPrint ) System . out . print ( "REF_TERM :" ) ; stateStackPop ( ) ; break ; case 61 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( debugPrint ) System . out . print ( "DIRECTIVE_TERM :" ) ; input_stream . backup ( 1 ) ; inDirective = false ; stateStackPop ( ) ; break ; default : break ; } } final void MoreLexicalActions ( ) { jjimageLen += ( lengthOfMatch = jjmatchedPos + 1 ) ; switch ( jjmatchedKind ) { case 10 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen ) ) ; jjimageLen = 0 ; if ( ! inComment ) { if ( curLexState == REFERENCE ) { inReference = false ; stateStackPop ( ) ; } inReference = true ; if ( debugPrint ) System . out . print ( "$  : going to " + REFERENCE ) ; stateStackPush ( ) ; SwitchTo ( REFERENCE ) ; } break ; case 11 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen ) ) ; jjimageLen = 0 ; if ( ! inComment ) { if ( curLexState == REFERENCE ) { inReference = false ; stateStackPop ( ) ; } inReference = true ; if ( debugPrint ) System . out . print ( "$!  : going to " + REFERENCE ) ; stateStackPush ( ) ; SwitchTo ( REFERENCE ) ; } break ; case 12 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen ) ) ; jjimageLen = 0 ; if ( ! inComment ) { if ( curLexState == REFERENCE ) { inReference = false ; stateStackPop ( ) ; } inComment = true ; stateStackPush ( ) ; SwitchTo ( IN_SINGLE_LINE_COMMENT ) ; } break ; case 13 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen ) ) ; jjimageLen = 0 ; input_stream . backup ( 1 ) ; inComment = true ; stateStackPush ( ) ; SwitchTo ( IN_FORMAL_COMMENT ) ; break ; case 14 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen ) ) ; jjimageLen = 0 ; inComment = true ; stateStackPush ( ) ; SwitchTo ( IN_MULTI_LINE_COMMENT ) ; break ; case 15 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen ) ) ; jjimageLen = 0 ; if ( ! inComment ) { if ( curLexState == REFERENCE || curLexState == REFMODIFIER ) { inReference = false ; stateStackPop ( ) ; } inDirective = true ; if ( debugPrint ) System . out . print ( "# :  going to " + DIRECTIVE ) ; stateStackPush ( ) ; SwitchTo ( PRE_DIRECTIVE ) ; } break ; default : break ; } } final void TokenLexicalActions ( Token matchedToken ) { switch ( jjmatchedKind ) { case 5 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( ! inComment ) lparen ++ ; if ( curLexState == REFMODIFIER ) SwitchTo ( REFMOD2 ) ; break ; case 6 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; RPARENHandler ( ) ; break ; case 7 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; SwitchTo ( REFERENCE ) ; break ; case 9 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( ! inComment ) { inDirective = true ; if ( debugPrint ) System . out . print ( "#set :  going to " + DIRECTIVE ) ; stateStackPush ( ) ; inSet = true ; SwitchTo ( DIRECTIVE ) ; } if ( ! inComment ) { lparen ++ ; if ( curLexState == REFMODIFIER ) SwitchTo ( REFMOD2 ) ; } break ; case 19 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; inComment = false ; stateStackPop ( ) ; break ; case 20 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; inComment = false ; stateStackPop ( ) ; break ; case 21 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; inComment = false ; stateStackPop ( ) ; break ; case 24 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( curLexState == DIRECTIVE && ! inSet && lparen == 0 ) stateStackPop ( ) ; break ; case 27 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( debugPrint ) System . out . println ( " NEWLINE :" ) ; stateStackPop ( ) ; if ( inSet ) inSet = false ; if ( inDirective ) inDirective = false ; break ; case 43 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; inDirective = false ; stateStackPop ( ) ; break ; case 44 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; SwitchTo ( DIRECTIVE ) ; break ; case 45 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; SwitchTo ( DIRECTIVE ) ; break ; case 46 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; inDirective = false ; stateStackPop ( ) ; break ; case 47 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; matchedToken . kind = EOF ; fileDepth = 0 ; break ; case 49 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; if ( lparen == 0 && ! inSet && curLexState != REFMOD2 ) { stateStackPop ( ) ; } break ; case 57 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; input_stream . backup ( 1 ) ; matchedToken . image = "." ; if ( debugPrint ) System . out . print ( "DOT : switching to " + REFMODIFIER ) ; SwitchTo ( REFMODIFIER ) ; break ; case 59 : if ( image == null ) image = new StringBuffer ( new String ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ) ; else image . append ( input_stream . GetSuffix ( jjimageLen + ( lengthOfMatch = jjmatchedPos + 1 ) ) ) ; stateStackPop ( ) ; break ; default : break ; } } } 	0	['94', '1', '0', '5', '126', '413', '1', '4', '10', '0.802541544', '10760', '0.272727273', '1', '0', '0.338709677', '0', '0', '113.1170213', '95', '10.5426', '0']
package org . apache . velocity . test ; import java . io . FileWriter ; import java . util . Iterator ; import java . util . Vector ; import org . apache . commons . collections . ExtendedProperties ; public class CommonsExtPropTestCase extends BaseTestCase { private static final String COMPARE_DIR = "../test/configuration/compare" ; private static final String RESULTS_DIR = "../test/configuration/results" ; private static final String TEST_CONFIG = "../test/configuration/test.config" ; public CommonsExtPropTestCase ( ) { super ( "CommonsExtPropTestCase" ) ; } public static junit . framework . Test suite ( ) { return new CommonsExtPropTestCase ( ) ; } public void runTest ( ) { try { assureResultsDirectoryExists ( RESULTS_DIR ) ; ExtendedProperties c = new ExtendedProperties ( TEST_CONFIG ) ; FileWriter result = new FileWriter ( getFileName ( RESULTS_DIR , "output" , "res" ) ) ; message ( result , "Testing order of keys ..." ) ; showIterator ( result , c . getKeys ( ) ) ; message ( result , "Testing retrieval of CSV values ..." ) ; showVector ( result , c . getVector ( "resource.loader" ) ) ; message ( result , "Testing subset(prefix).getKeys() ..." ) ; ExtendedProperties subset = c . subset ( "file.resource.loader" ) ; showIterator ( result , subset . getKeys ( ) ) ; message ( result , "Testing getVector(prefix) ..." ) ; showVector ( result , subset . getVector ( "path" ) ) ; message ( result , "Testing getString(key) ..." ) ; result . write ( c . getString ( "config.string.value" ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getBoolean(key) ..." ) ; result . write ( new Boolean ( c . getBoolean ( "config.boolean.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getByte(key) ..." ) ; result . write ( new Byte ( c . getByte ( "config.byte.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getShort(key) ..." ) ; result . write ( new Short ( c . getShort ( "config.short.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getInt(key) ..." ) ; result . write ( new Integer ( c . getInt ( "config.int.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getLong(key) ..." ) ; result . write ( new Long ( c . getLong ( "config.long.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getFloat(key) ..." ) ; result . write ( new Float ( c . getFloat ( "config.float.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getDouble(key) ..." ) ; result . write ( new Double ( c . getDouble ( "config.double.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing escaped-comma scalar..." ) ; result . write ( c . getString ( "escape.comma1" ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing escaped-comma vector..." ) ; showVector ( result , c . getVector ( "escape.comma2" ) ) ; result . write ( "\n\n" ) ; result . flush ( ) ; result . close ( ) ; if ( ! isMatch ( RESULTS_DIR , COMPARE_DIR , "output" , "res" , "cmp" ) ) { fail ( "Output incorrect." ) ; } } catch ( Exception e ) { System . err . println ( "Cannot setup CommonsExtPropTestCase!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } private void showIterator ( FileWriter result , Iterator i ) throws Exception { while ( i . hasNext ( ) ) { result . write ( ( String ) i . next ( ) ) ; result . write ( "\n" ) ; } result . write ( "\n" ) ; } private void showVector ( FileWriter result , Vector v ) throws Exception { for ( int j = 0 ; j < v . size ( ) ; j ++ ) { result . write ( ( String ) v . get ( j ) ) ; result . write ( "\n" ) ; } result . write ( "\n" ) ; } private void message ( FileWriter result , String message ) throws Exception { result . write ( "--------------------------------------------------\n" ) ; result . write ( message + "\n" ) ; result . write ( "--------------------------------------------------\n" ) ; result . write ( "\n" ) ; } } 	0	['6', '4', '0', '4', '51', '15', '0', '4', '3', '1.2', '304', '1', '0', '0.915254237', '0.366666667', '2', '4', '49.16666667', '1', '0.8333', '0']
package org . apache . velocity . test ; import java . io . BufferedWriter ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . io . File ; import java . util . Properties ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . Template ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . test . provider . TestProvider ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . runtime . VelocimacroFactory ; import junit . framework . TestCase ; public class MultipleFileResourcePathTest extends BaseTestCase { private static final String TMPL_FILE_EXT = "vm" ; private static final String CMP_FILE_EXT = "cmp" ; private static final String RESULT_FILE_EXT = "res" ; private final static String FILE_RESOURCE_LOADER_PATH1 = "../test/multi/path1" ; private final static String FILE_RESOURCE_LOADER_PATH2 = "../test/multi/path2" ; private static final String RESULTS_DIR = "../test/multi/results" ; private static final String COMPARE_DIR = "../test/multi/compare" ; MultipleFileResourcePathTest ( ) { super ( "MultipleFileResourcePathTest" ) ; try { assureResultsDirectoryExists ( RESULTS_DIR ) ; Velocity . addProperty ( Velocity . FILE_RESOURCE_LOADER_PATH , FILE_RESOURCE_LOADER_PATH1 ) ; Velocity . addProperty ( Velocity . FILE_RESOURCE_LOADER_PATH , FILE_RESOURCE_LOADER_PATH2 ) ; Velocity . init ( ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup MultipleFileResourcePathTest!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } public static junit . framework . Test suite ( ) { return new MultipleFileResourcePathTest ( ) ; } public void runTest ( ) { try { Template template1 = RuntimeSingleton . getTemplate ( getFileName ( null , "path1" , TMPL_FILE_EXT ) ) ; Template template2 = RuntimeSingleton . getTemplate ( getFileName ( null , "path2" , TMPL_FILE_EXT ) ) ; FileOutputStream fos1 = new FileOutputStream ( getFileName ( RESULTS_DIR , "path1" , RESULT_FILE_EXT ) ) ; FileOutputStream fos2 = new FileOutputStream ( getFileName ( RESULTS_DIR , "path2" , RESULT_FILE_EXT ) ) ; Writer writer1 = new BufferedWriter ( new OutputStreamWriter ( fos1 ) ) ; Writer writer2 = new BufferedWriter ( new OutputStreamWriter ( fos2 ) ) ; VelocityContext context = new VelocityContext ( ) ; template1 . merge ( context , writer1 ) ; writer1 . flush ( ) ; writer1 . close ( ) ; template2 . merge ( context , writer2 ) ; writer2 . flush ( ) ; writer2 . close ( ) ; if ( ! isMatch ( RESULTS_DIR , COMPARE_DIR , "path1" , RESULT_FILE_EXT , CMP_FILE_EXT ) || ! isMatch ( RESULTS_DIR , COMPARE_DIR , "path2" , RESULT_FILE_EXT , CMP_FILE_EXT ) ) { fail ( "Output incorrect." ) ; } } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } } } 	0	['3', '4', '0', '8', '22', '3', '0', '8', '2', '1.5', '124', '1', '0', '0.964285714', '0.666666667', '3', '4', '38', '2', '1', '0']
package org . apache . velocity . test ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . exception . ParseErrorException ; import java . io . StringWriter ; public class ParserTestCase extends TestCase { public ParserTestCase ( String testName ) { super ( testName ) ; } public static Test suite ( ) { return new TestSuite ( ParserTestCase . class ) ; } public void testEquals ( ) throws Exception { VelocityEngine ve = new VelocityEngine ( ) ; ve . init ( ) ; String template = "#if($a == $b) foo #end" ; ve . evaluate ( new VelocityContext ( ) , new StringWriter ( ) , "foo" , template ) ; template = "#if($a = $b) foo #end" ; try { ve . evaluate ( new VelocityContext ( ) , new StringWriter ( ) , "foo" , template ) ; assertTrue ( false ) ; } catch ( ParseErrorException pe ) { } } public void testMacro ( ) throws Exception { VelocityEngine ve = new VelocityEngine ( ) ; ve . init ( ) ; String template = "#macro(foo) foo #end" ; ve . evaluate ( new VelocityContext ( ) , new StringWriter ( ) , "foo" , template ) ; template = "#macro($x) foo #end" ; try { ve . evaluate ( new VelocityContext ( ) , new StringWriter ( ) , "foo" , template ) ; assertTrue ( false ) ; } catch ( ParseErrorException pe ) { } } public void testArgs ( ) throws Exception { VelocityEngine ve = new VelocityEngine ( ) ; ve . init ( ) ; String template = "#macro(foo) foo #end" ; ve . evaluate ( new VelocityContext ( ) , new StringWriter ( ) , "foo" , template ) ; template = "#foreach(  $i     in  $woogie   ) end #end" ; ve . evaluate ( new VelocityContext ( ) , new StringWriter ( ) , "foo" , template ) ; template = "#macro(   foo $a) $a #end #foo(woogie)" ; try { ve . evaluate ( new VelocityContext ( ) , new StringWriter ( ) , "foo" , template ) ; assertTrue ( false ) ; } catch ( ParseErrorException pe ) { System . out . println ( "Caught pee!" ) ; } } } 	0	['6', '3', '0', '8', '18', '15', '0', '8', '5', '1', '160', '0', '0', '0.907407407', '0.5', '0', '0', '25.5', '2', '1', '0']
package org . apache . velocity . test . provider ; import java . util . * ; public class TestProvider { String title = "lunatic" ; boolean state ; Object ob = null ; public static String PUB_STAT_STRING = "Public Static String" ; int stateint = 0 ; public String getName ( ) { return "jason" ; } public Stack getStack ( ) { Stack stack = new Stack ( ) ; stack . push ( "stack element 1" ) ; stack . push ( "stack element 2" ) ; stack . push ( "stack element 3" ) ; return stack ; } public List getEmptyList ( ) { List list = new ArrayList ( ) ; return list ; } public List getList ( ) { List list = new ArrayList ( ) ; list . add ( "list element 1" ) ; list . add ( "list element 2" ) ; list . add ( "list element 3" ) ; return list ; } public Hashtable getSearch ( ) { Hashtable h = new Hashtable ( ) ; h . put ( "Text" , "this is some text" ) ; h . put ( "EscText" , "this is escaped text" ) ; h . put ( "Title" , "this is the title" ) ; h . put ( "Index" , "this is the index" ) ; h . put ( "URL" , "http://periapt.com" ) ; ArrayList al = new ArrayList ( ) ; al . add ( h ) ; h . put ( "RelatedLinks" , al ) ; return h ; } public Hashtable getHashtable ( ) { Hashtable h = new Hashtable ( ) ; h . put ( "key0" , "value0" ) ; h . put ( "key1" , "value1" ) ; h . put ( "key2" , "value2" ) ; return h ; } public ArrayList getRelSearches ( ) { ArrayList al = new ArrayList ( ) ; al . add ( getSearch ( ) ) ; return al ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public Object [ ] getMenu ( ) { Object [ ] menu = new Object [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { Hashtable item = new Hashtable ( ) ; item . put ( "id" , "item" + Integer . toString ( i + 1 ) ) ; item . put ( "name" , "name" + Integer . toString ( i + 1 ) ) ; item . put ( "label" , "label" + Integer . toString ( i + 1 ) ) ; menu [ i ] = item ; } return menu ; } public ArrayList getCustomers ( ) { ArrayList list = new ArrayList ( ) ; list . add ( "ArrayList element 1" ) ; list . add ( "ArrayList element 2" ) ; list . add ( "ArrayList element 3" ) ; list . add ( "ArrayList element 4" ) ; return list ; } public ArrayList getCustomers2 ( ) { ArrayList list = new ArrayList ( ) ; list . add ( new TestProvider ( ) ) ; list . add ( new TestProvider ( ) ) ; list . add ( new TestProvider ( ) ) ; list . add ( new TestProvider ( ) ) ; return list ; } public Object me ( ) { return this ; } public String toString ( ) { return ( "test provider" ) ; } public Vector getVector ( ) { Vector list = new Vector ( ) ; list . addElement ( "vector element 1" ) ; list . addElement ( "vector element 2" ) ; return list ; } public String [ ] getArray ( ) { String [ ] strings = new String [ 2 ] ; strings [ 0 ] = "first element" ; strings [ 1 ] = "second element" ; return strings ; } public boolean theAPLRules ( ) { return true ; } public boolean getStateTrue ( ) { return true ; } public boolean getStateFalse ( ) { return false ; } public String objectArrayMethod ( Object [ ] o ) { return "result of objectArrayMethod" ; } public String concat ( Object [ ] strings ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < strings . length ; i ++ ) { result . append ( ( String ) strings [ i ] ) . append ( ' ' ) ; } return result . toString ( ) ; } public String concat ( List strings ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < strings . size ( ) ; i ++ ) { result . append ( ( String ) strings . get ( i ) ) . append ( ' ' ) ; } return result . toString ( ) ; } public String objConcat ( List objects ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < objects . size ( ) ; i ++ ) { result . append ( objects . get ( i ) ) . append ( ' ' ) ; } return result . toString ( ) ; } public String parse ( String a , Object o , String c , String d ) { return a + o . toString ( ) + c + d ; } public String concat ( String a , String b ) { return a + b ; } public Person getPerson ( ) { return new Person ( ) ; } public Child getChild ( ) { return new Child ( ) ; } public String showPerson ( Person person ) { return person . getName ( ) ; } public String chop ( String string , int i ) { return ( string . substring ( 0 , string . length ( ) - i ) ) ; } public boolean allEmpty ( Object [ ] list ) { int size = list . length ; for ( int i = 0 ; i < size ; i ++ ) if ( list [ i ] . toString ( ) . length ( ) > 0 ) return false ; return true ; } public void setState ( Boolean state ) { } public void setBangStart ( Integer i ) { System . out . println ( "SetBangStart() : called with val = " + i ) ; stateint = i . intValue ( ) ; } public Integer bang ( ) { System . out . println ( "Bang! : " + stateint ) ; Integer ret = new Integer ( stateint ) ; stateint ++ ; return ret ; } public String get ( String key ) { return key ; } public String put ( String key , Object o ) { ob = o ; return key ; } public String getFoo ( ) throws Exception { System . out . println ( "Hello from getfoo" ) ; throw new Exception ( "From getFoo()" ) ; } public String getThrow ( ) throws Exception { System . out . println ( "Hello from geThrow" ) ; throw new Exception ( "From getThrow()" ) ; } } 	0	['39', '1', '0', '4', '68', '727', '2', '2', '38', '0.963157895', '537', '0', '0', '0', '0.160818713', '0', '0', '12.64102564', '3', '1.1026', '0']
package org . apache . velocity . test ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . ArrayList ; import java . util . Hashtable ; import java . util . HashMap ; import java . util . Vector ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . Template ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . test . provider . TestProvider ; import org . apache . velocity . test . provider . BoolObj ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . app . FieldMethodizer ; import junit . framework . TestCase ; public class TemplateTestCase extends BaseTestCase implements TemplateTestBase { protected String baseFileName ; private TestProvider provider ; private ArrayList al ; private Hashtable h ; private VelocityContext context ; private VelocityContext context1 ; private VelocityContext context2 ; private Vector vec ; public TemplateTestCase ( String baseFileName ) { super ( getTestCaseName ( baseFileName ) ) ; this . baseFileName = baseFileName ; } public static junit . framework . Test suite ( ) { return new TemplateTestSuite ( ) ; } protected void setUp ( ) { provider = new TestProvider ( ) ; al = provider . getCustomers ( ) ; h = new Hashtable ( ) ; h . put ( "Bar" , "this is from a hashtable!" ) ; h . put ( "Foo" , "this is from a hashtable too!" ) ; vec = new Vector ( ) ; vec . addElement ( new String ( "string1" ) ) ; vec . addElement ( new String ( "string2" ) ) ; context2 = new VelocityContext ( ) ; context1 = new VelocityContext ( context2 ) ; context = new VelocityContext ( context1 ) ; context . put ( "provider" , provider ) ; context1 . put ( "name" , "jason" ) ; context2 . put ( "providers" , provider . getCustomers2 ( ) ) ; context . put ( "list" , al ) ; context1 . put ( "hashtable" , h ) ; context2 . put ( "hashmap" , new HashMap ( ) ) ; context2 . put ( "search" , provider . getSearch ( ) ) ; context . put ( "relatedSearches" , provider . getRelSearches ( ) ) ; context1 . put ( "searchResults" , provider . getRelSearches ( ) ) ; context2 . put ( "stringarray" , provider . getArray ( ) ) ; context . put ( "vector" , vec ) ; context . put ( "mystring" , new String ( ) ) ; context . put ( "runtime" , new FieldMethodizer ( "org.apache.velocity.runtime.RuntimeSingleton" ) ) ; context . put ( "fmprov" , new FieldMethodizer ( provider ) ) ; context . put ( "Floog" , "floogie woogie" ) ; context . put ( "boolobj" , new BoolObj ( ) ) ; Object [ ] oarr = { "a" , "b" , "c" , "d" } ; int intarr [ ] = { 10 , 20 , 30 , 40 , 50 } ; context . put ( "collection" , vec ) ; context2 . put ( "iterator" , vec . iterator ( ) ) ; context1 . put ( "map" , h ) ; context . put ( "obarr" , oarr ) ; context . put ( "enumerator" , vec . elements ( ) ) ; context . put ( "intarr" , intarr ) ; } public void runTest ( ) { try { Template template = RuntimeSingleton . getTemplate ( getFileName ( null , baseFileName , TMPL_FILE_EXT ) ) ; assureResultsDirectoryExists ( RESULT_DIR ) ; FileOutputStream fos = new FileOutputStream ( getFileName ( RESULT_DIR , baseFileName , RESULT_FILE_EXT ) ) ; Writer writer = new BufferedWriter ( new OutputStreamWriter ( fos ) ) ; template . merge ( context , writer ) ; writer . flush ( ) ; writer . close ( ) ; if ( ! isMatch ( RESULT_DIR , COMPARE_DIR , baseFileName , RESULT_FILE_EXT , CMP_FILE_EXT ) ) { fail ( "Processed template did not match expected output" ) ; } } catch ( Exception e ) { System . out . println ( "EXCEPTION : " + e ) ; fail ( e . getMessage ( ) ) ; } } } 	0	['4', '4', '0', '13', '45', '2', '1', '13', '3', '0.916666667', '359', '1', '4', '0.947368421', '0.5', '3', '6', '86.75', '1', '0.75', '0']
package org . apache . velocity . test ; import java . util . ArrayList ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . RuntimeSingleton ; import junit . framework . TestCase ; public class IntrospectorTestCase extends BaseTestCase { private Method method ; private String result ; private String type ; private ArrayList failures = new ArrayList ( ) ; IntrospectorTestCase ( ) { super ( "IntrospectorTestCase" ) ; } public IntrospectorTestCase ( String name ) { super ( name ) ; } public static junit . framework . Test suite ( ) { return new IntrospectorTestCase ( ) ; } public void runTest ( ) { MethodProvider mp = new MethodProvider ( ) ; try { Object [ ] booleanParams = { new Boolean ( true ) } ; type = "boolean" ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , type + "Method" , booleanParams ) ; result = ( String ) method . invoke ( mp , booleanParams ) ; if ( ! result . equals ( type ) ) failures . add ( type + "Method could not be found!" ) ; Object [ ] byteParams = { new Byte ( "1" ) } ; type = "byte" ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , type + "Method" , byteParams ) ; result = ( String ) method . invoke ( mp , byteParams ) ; if ( ! result . equals ( type ) ) failures . add ( type + "Method could not be found!" ) ; Object [ ] characterParams = { new Character ( 'a' ) } ; type = "character" ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , type + "Method" , characterParams ) ; result = ( String ) method . invoke ( mp , characterParams ) ; if ( ! result . equals ( type ) ) failures . add ( type + "Method could not be found!" ) ; Object [ ] doubleParams = { new Double ( ( double ) 1 ) } ; type = "double" ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , type + "Method" , doubleParams ) ; result = ( String ) method . invoke ( mp , doubleParams ) ; if ( ! result . equals ( type ) ) failures . add ( type + "Method could not be found!" ) ; Object [ ] floatParams = { new Float ( ( float ) 1 ) } ; type = "float" ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , type + "Method" , floatParams ) ; result = ( String ) method . invoke ( mp , floatParams ) ; if ( ! result . equals ( type ) ) failures . add ( type + "Method could not be found!" ) ; Object [ ] integerParams = { new Integer ( ( int ) 1 ) } ; type = "integer" ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , type + "Method" , integerParams ) ; result = ( String ) method . invoke ( mp , integerParams ) ; if ( ! result . equals ( type ) ) failures . add ( type + "Method could not be found!" ) ; Object [ ] longParams = { new Long ( ( long ) 1 ) } ; type = "long" ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , type + "Method" , longParams ) ; result = ( String ) method . invoke ( mp , longParams ) ; if ( ! result . equals ( type ) ) failures . add ( type + "Method could not be found!" ) ; Object [ ] shortParams = { new Short ( ( short ) 1 ) } ; type = "short" ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , type + "Method" , shortParams ) ; result = ( String ) method . invoke ( mp , shortParams ) ; if ( ! result . equals ( type ) ) failures . add ( type + "Method could not be found!" ) ; Object [ ] params = { } ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , "untouchable" , params ) ; if ( method != null ) failures . add ( type + "able to access a private-access method." ) ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , "reallyuntouchable" , params ) ; if ( method != null ) failures . add ( type + "able to access a default-access method." ) ; int totalFailures = failures . size ( ) ; if ( totalFailures > 0 ) { StringBuffer sb = new StringBuffer ( "\nIntrospection Errors:\n" ) ; for ( int i = 0 ; i < totalFailures ; i ++ ) sb . append ( ( String ) failures . get ( i ) ) . append ( "\n" ) ; fail ( sb . toString ( ) ) ; } } catch ( Exception e ) { fail ( e . toString ( ) ) ; } } public static class MethodProvider { public String booleanMethod ( boolean p ) { return "boolean" ; } public String byteMethod ( byte p ) { return "byte" ; } public String characterMethod ( char p ) { return "character" ; } public String doubleMethod ( double p ) { return "double" ; } public String floatMethod ( float p ) { return "float" ; } public String integerMethod ( int p ) { return "integer" ; } public String longMethod ( long p ) { return "long" ; } public String shortMethod ( short p ) { return "short" ; } String untouchable ( ) { return "yech" ; } private String reallyuntouchable ( ) { return "yech!" ; } } } 	0	['5', '4', '0', '6', '32', '4', '0', '6', '3', '0.85', '642', '0.8', '0', '0.947368421', '0.5', '3', '3', '126.4', '22', '4.8', '0']
package org . apache . velocity . test . misc ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . io . StringWriter ; import java . util . ArrayList ; import java . util . Hashtable ; import java . util . HashMap ; import java . util . Properties ; import java . util . Stack ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . Template ; import org . apache . velocity . app . FieldMethodizer ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . test . provider . TestProvider ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . app . event . ReferenceInsertionEventHandler ; import org . apache . velocity . app . event . MethodExceptionEventHandler ; import org . apache . velocity . app . event . NullSetEventHandler ; import org . apache . velocity . context . Context ; public class Test implements ReferenceInsertionEventHandler , NullSetEventHandler , MethodExceptionEventHandler { private static Stack writerStack = new Stack ( ) ; public Test ( String templateFile , String encoding ) { Writer writer = null ; TestProvider provider = new TestProvider ( ) ; ArrayList al = provider . getCustomers ( ) ; Hashtable h = new Hashtable ( ) ; h . put ( "Bar" , "this is from a hashtable!" ) ; h . put ( "Foo" , "this is from a hashtable too!" ) ; Vector v = new Vector ( ) ; String str = "mystr" ; v . addElement ( new String ( "hello" ) ) ; v . addElement ( new String ( "hello2" ) ) ; v . addElement ( str ) ; try { Properties p = new Properties ( ) ; try { FileInputStream fis = new FileInputStream ( new File ( "velocity.properties" ) ) ; if ( fis != null ) p . load ( fis ) ; } catch ( Exception ex ) { } for ( Enumeration e = p . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String el = ( String ) e . nextElement ( ) ; Velocity . setProperty ( el , p . getProperty ( el ) ) ; } Velocity . setProperty ( Velocity . RUNTIME_LOG_ERROR_STACKTRACE , "true" ) ; Velocity . setProperty ( Velocity . RUNTIME_LOG_WARN_STACKTRACE , "true" ) ; Velocity . setProperty ( Velocity . RUNTIME_LOG_INFO_STACKTRACE , "true" ) ; Velocity . init ( ) ; if ( templateFile == null ) { templateFile = "examples/example.vm" ; } Template template = null ; try { template = RuntimeSingleton . getTemplate ( templateFile , encoding ) ; } catch ( ResourceNotFoundException rnfe ) { System . out . println ( "Test : RNFE : Cannot find template " + templateFile ) ; } catch ( ParseErrorException pee ) { System . out . println ( "Test : Syntax error in template " + templateFile + ":" + pee ) ; } VelocityContext context = new VelocityContext ( ) ; context . put ( "provider" , provider ) ; context . put ( "name" , "jason" ) ; context . put ( "providers" , provider . getCustomers2 ( ) ) ; context . put ( "list" , al ) ; context . put ( "hashtable" , h ) ; context . put ( "search" , provider . getSearch ( ) ) ; context . put ( "relatedSearches" , provider . getRelSearches ( ) ) ; context . put ( "searchResults" , provider . getRelSearches ( ) ) ; context . put ( "menu" , provider . getMenu ( ) ) ; context . put ( "stringarray" , provider . getArray ( ) ) ; context . put ( "vector" , v ) ; context . put ( "mystring" , new String ( ) ) ; context . put ( "hashmap" , new HashMap ( ) ) ; context . put ( "runtime" , new FieldMethodizer ( "org.apache.velocity.runtime.RuntimeSingleton" ) ) ; context . put ( "fmprov" , new FieldMethodizer ( provider ) ) ; context . put ( "Floog" , "floogie woogie" ) ; context . put ( "geirstring" , str ) ; context . put ( "mylong" , new Long ( 5 ) ) ; int intarr [ ] = { 10 , 20 , 30 , 40 , 50 } ; Object [ ] oarr = { "a" , "b" , "c" , "d" } ; context . put ( "collection" , v ) ; context . put ( "iterator" , v . iterator ( ) ) ; context . put ( "map" , h ) ; context . put ( "obarr" , oarr ) ; context . put ( "intarr" , intarr ) ; String stest = " My name is $name -> $Floog" ; StringWriter w = new StringWriter ( ) ; w = new StringWriter ( ) ; w = new StringWriter ( ) ; EventCartridge ec = new EventCartridge ( ) ; ec . addEventHandler ( this ) ; ec . attachToContext ( context ) ; VelocityContext vc = new VelocityContext ( context ) ; if ( template != null ) { writer = new BufferedWriter ( new OutputStreamWriter ( System . out , encoding ) ) ; template . merge ( vc , writer ) ; writer . flush ( ) ; writer . close ( ) ; } } catch ( MethodInvocationException mie ) { System . out . println ( "MIE : " + mie ) ; } catch ( Exception e ) { RuntimeSingleton . error ( "Test- exception : " + e ) ; e . printStackTrace ( ) ; } } public Object referenceInsert ( String reference , Object value ) { if ( value != null ) ; return value ; } public boolean shouldLogOnNullSet ( String lhs , String rhs ) { if ( lhs . equals ( "$woogie" ) ) return false ; return true ; } public Object methodException ( Class claz , String method , Exception e ) throws Exception { if ( method . equals ( "getThrow" ) ) return "I should have thrown" ; throw e ; } public static void main ( String [ ] args ) { Test t ; String encoding = "ISO-8859-1" ; if ( args . length > 1 ) encoding = args [ 1 ] ; t = new Test ( args [ 0 ] , encoding ) ; } } 	0	['6', '1', '0', '16', '57', '15', '0', '16', '5', '1', '437', '1', '0', '0', '0.4', '0', '0', '71.66666667', '2', '1.1667', '0']
package org . apache . velocity . test ; import java . io . BufferedWriter ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . io . File ; import java . util . Properties ; import org . apache . velocity . Template ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . test . provider . TestProvider ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . runtime . VelocimacroFactory ; import junit . framework . TestCase ; public class MultiLoaderTestCase extends BaseTestCase { private static final String TMPL_FILE_EXT = "vm" ; private static final String CMP_FILE_EXT = "cmp" ; private static final String RESULT_FILE_EXT = "res" ; private static final String RESULTS_DIR = "../test/multiloader/results" ; private final static String FILE_RESOURCE_LOADER_PATH = "../test/multiloader" ; private static final String COMPARE_DIR = "../test/multiloader/compare" ; public MultiLoaderTestCase ( ) { super ( "MultiLoaderTestCase" ) ; try { assureResultsDirectoryExists ( RESULTS_DIR ) ; Velocity . setProperty ( Velocity . RESOURCE_LOADER , "file" ) ; Velocity . setProperty ( Velocity . FILE_RESOURCE_LOADER_PATH , FILE_RESOURCE_LOADER_PATH ) ; Velocity . addProperty ( Velocity . RESOURCE_LOADER , "classpath" ) ; Velocity . addProperty ( Velocity . RESOURCE_LOADER , "jar" ) ; Velocity . setProperty ( "classpath." + Velocity . RESOURCE_LOADER + ".class" , "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader" ) ; Velocity . setProperty ( "classpath." + Velocity . RESOURCE_LOADER + ".cache" , "false" ) ; Velocity . setProperty ( "classpath." + Velocity . RESOURCE_LOADER + ".modificationCheckInterval" , "2" ) ; Velocity . setProperty ( "jar." + Velocity . RESOURCE_LOADER + ".class" , "org.apache.velocity.runtime.resource.loader.JarResourceLoader" ) ; Velocity . setProperty ( "jar." + Velocity . RESOURCE_LOADER + ".path" , "jar:file:" + FILE_RESOURCE_LOADER_PATH + "/test2.jar" ) ; Velocity . init ( ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup MultiLoaderTestCase!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } public static junit . framework . Test suite ( ) { return new MultiLoaderTestCase ( ) ; } public void runTest ( ) { try { assureResultsDirectoryExists ( RESULTS_DIR ) ; Template template1 = Velocity . getTemplate ( getFileName ( null , "path1" , TMPL_FILE_EXT ) ) ; Template template2 = Velocity . getTemplate ( getFileName ( null , "template/test1" , TMPL_FILE_EXT ) ) ; Template template3 = Velocity . getTemplate ( getFileName ( null , "template/test2" , TMPL_FILE_EXT ) ) ; FileOutputStream fos1 = new FileOutputStream ( getFileName ( RESULTS_DIR , "path1" , RESULT_FILE_EXT ) ) ; FileOutputStream fos2 = new FileOutputStream ( getFileName ( RESULTS_DIR , "test2" , RESULT_FILE_EXT ) ) ; FileOutputStream fos3 = new FileOutputStream ( getFileName ( RESULTS_DIR , "test3" , RESULT_FILE_EXT ) ) ; Writer writer1 = new BufferedWriter ( new OutputStreamWriter ( fos1 ) ) ; Writer writer2 = new BufferedWriter ( new OutputStreamWriter ( fos2 ) ) ; Writer writer3 = new BufferedWriter ( new OutputStreamWriter ( fos3 ) ) ; VelocityContext context = new VelocityContext ( ) ; template1 . merge ( context , writer1 ) ; writer1 . flush ( ) ; writer1 . close ( ) ; template2 . merge ( context , writer2 ) ; writer2 . flush ( ) ; writer2 . close ( ) ; template3 . merge ( context , writer3 ) ; writer3 . flush ( ) ; writer3 . close ( ) ; if ( ! isMatch ( RESULTS_DIR , COMPARE_DIR , "path1" , RESULT_FILE_EXT , CMP_FILE_EXT ) ) { fail ( "Output incorrect for FileResourceLoader test." ) ; } if ( ! isMatch ( RESULTS_DIR , COMPARE_DIR , "test2" , RESULT_FILE_EXT , CMP_FILE_EXT ) ) { fail ( "Output incorrect for ClasspathResourceLoader test." ) ; } if ( ! isMatch ( RESULTS_DIR , COMPARE_DIR , "test3" , RESULT_FILE_EXT , CMP_FILE_EXT ) ) { fail ( "Output incorrect for JarResourceLoader test." ) ; } } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } } } 	0	['3', '4', '0', '7', '23', '3', '0', '7', '3', '1.5', '188', '1', '0', '0.964285714', '0.666666667', '2', '4', '59.66666667', '3', '1.3333', '0']
package org . apache . velocity . runtime . directive ; import java . util . Stack ; public class ParseDirectiveException extends Exception { private Stack filenameStack = new Stack ( ) ; private String msg = "" ; private int depthCount = 0 ; ParseDirectiveException ( String m , int i ) { msg = m ; depthCount = i ; } public String getMessage ( ) { String returnStr = "#parse() exception : depth = " + depthCount + " -> " + msg ; returnStr += " File stack : " ; try { while ( ! filenameStack . empty ( ) ) { returnStr += ( String ) filenameStack . pop ( ) ; returnStr += " -> " ; } } catch ( Exception e ) { } return returnStr ; } public void addFile ( String s ) { filenameStack . push ( s ) ; } } 	0	['3', '3', '0', '0', '12', '0', '0', '0', '2', '0.333333333', '86', '1', '0', '0.866666667', '0.666666667', '1', '1', '26.66666667', '2', '1', '0']
package org . apache . velocity . test ; import java . io . FileWriter ; import java . util . Iterator ; import java . util . Vector ; import org . apache . velocity . runtime . configuration . Configuration ; public class ConfigurationTestCase extends BaseTestCase { private static final String COMPARE_DIR = "../test/configuration/compare" ; private static final String RESULTS_DIR = "../test/configuration/results" ; private static final String TEST_CONFIG = "../test/configuration/test.config" ; public ConfigurationTestCase ( ) { super ( "ConfigurationTestCase" ) ; } public static junit . framework . Test suite ( ) { return new ConfigurationTestCase ( ) ; } public void runTest ( ) { try { assureResultsDirectoryExists ( RESULTS_DIR ) ; Configuration c = new Configuration ( TEST_CONFIG ) ; FileWriter result = new FileWriter ( getFileName ( RESULTS_DIR , "output" , "res" ) ) ; message ( result , "Testing order of keys ..." ) ; showIterator ( result , c . getKeys ( ) ) ; message ( result , "Testing retrieval of CSV values ..." ) ; showVector ( result , c . getVector ( "resource.loader" ) ) ; message ( result , "Testing subset(prefix).getKeys() ..." ) ; Configuration subset = c . subset ( "file.resource.loader" ) ; showIterator ( result , subset . getKeys ( ) ) ; message ( result , "Testing getVector(prefix) ..." ) ; showVector ( result , subset . getVector ( "path" ) ) ; message ( result , "Testing getString(key) ..." ) ; result . write ( c . getString ( "config.string.value" ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getBoolean(key) ..." ) ; result . write ( new Boolean ( c . getBoolean ( "config.boolean.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getByte(key) ..." ) ; result . write ( new Byte ( c . getByte ( "config.byte.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getShort(key) ..." ) ; result . write ( new Short ( c . getShort ( "config.short.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getInt(key) ..." ) ; result . write ( new Integer ( c . getInt ( "config.int.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getLong(key) ..." ) ; result . write ( new Long ( c . getLong ( "config.long.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getFloat(key) ..." ) ; result . write ( new Float ( c . getFloat ( "config.float.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing getDouble(key) ..." ) ; result . write ( new Double ( c . getDouble ( "config.double.value" ) ) . toString ( ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing escaped-comma scalar..." ) ; result . write ( c . getString ( "escape.comma1" ) ) ; result . write ( "\n\n" ) ; message ( result , "Testing escaped-comma vector..." ) ; showVector ( result , c . getVector ( "escape.comma2" ) ) ; result . write ( "\n\n" ) ; result . flush ( ) ; result . close ( ) ; if ( ! isMatch ( RESULTS_DIR , COMPARE_DIR , "output" , "res" , "cmp" ) ) { fail ( "Output incorrect." ) ; } } catch ( Exception e ) { System . err . println ( "Cannot setup ConfigurationTestCase!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } private void showIterator ( FileWriter result , Iterator i ) throws Exception { while ( i . hasNext ( ) ) { result . write ( ( String ) i . next ( ) ) ; result . write ( "\n" ) ; } result . write ( "\n" ) ; } private void showVector ( FileWriter result , Vector v ) throws Exception { for ( int j = 0 ; j < v . size ( ) ; j ++ ) { result . write ( ( String ) v . get ( j ) ) ; result . write ( "\n" ) ; } result . write ( "\n" ) ; } private void message ( FileWriter result , String message ) throws Exception { result . write ( "--------------------------------------------------\n" ) ; result . write ( message + "\n" ) ; result . write ( "--------------------------------------------------\n" ) ; result . write ( "\n" ) ; } } 	0	['6', '4', '0', '4', '51', '15', '0', '4', '3', '1.2', '304', '1', '0', '0.915254237', '0.366666667', '2', '4', '49.16666667', '1', '0.8333', '0']
package org . apache . velocity . test ; import java . io . StringWriter ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . runtime . log . LogSystem ; import org . apache . velocity . exception . MethodInvocationException ; import junit . framework . TestCase ; public class MethodInvocationExceptionTest extends TestCase { public MethodInvocationExceptionTest ( ) { super ( "MethodInvocationExceptionTest" ) ; try { Velocity . init ( ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup MethodInvocationExceptionTest : " + e ) ; System . exit ( 1 ) ; } } public static junit . framework . Test suite ( ) { return new MethodInvocationExceptionTest ( ) ; } public void runTest ( ) { String template = "$woogie.doException() boing!" ; VelocityContext vc = new VelocityContext ( ) ; vc . put ( "woogie" , this ) ; StringWriter w = new StringWriter ( ) ; try { Velocity . evaluate ( vc , w , "test" , template ) ; fail ( "No exception thrown" ) ; } catch ( MethodInvocationException mie ) { System . out . println ( "Caught MIE (good!) :" ) ; System . out . println ( "  reference = " + mie . getReferenceName ( ) ) ; System . out . println ( "  method    = " + mie . getMethodName ( ) ) ; Throwable t = mie . getWrappedThrowable ( ) ; System . out . println ( "  throwable = " + t ) ; if ( t instanceof Exception ) { System . out . println ( "  exception = " + ( ( Exception ) t ) . getMessage ( ) ) ; } } catch ( Exception e ) { fail ( "Wrong exception thrown, first test." + e ) ; e . printStackTrace ( ) ; } template = "$woogie.foo boing!" ; try { Velocity . evaluate ( vc , w , "test" , template ) ; fail ( "No exception thrown, second test." ) ; } catch ( MethodInvocationException mie ) { System . out . println ( "Caught MIE (good!) :" ) ; System . out . println ( "  reference = " + mie . getReferenceName ( ) ) ; System . out . println ( "  method    = " + mie . getMethodName ( ) ) ; Throwable t = mie . getWrappedThrowable ( ) ; System . out . println ( "  throwable = " + t ) ; if ( t instanceof Exception ) { System . out . println ( "  exception = " + ( ( Exception ) t ) . getMessage ( ) ) ; } } catch ( Exception e ) { fail ( "Wrong exception thrown, second test" ) ; } template = "$woogie.Foo boing!" ; try { Velocity . evaluate ( vc , w , "test" , template ) ; fail ( "No exception thrown, third test." ) ; } catch ( MethodInvocationException mie ) { System . out . println ( "Caught MIE (good!) :" ) ; System . out . println ( "  reference = " + mie . getReferenceName ( ) ) ; System . out . println ( "  method    = " + mie . getMethodName ( ) ) ; Throwable t = mie . getWrappedThrowable ( ) ; System . out . println ( "  throwable = " + t ) ; if ( t instanceof Exception ) { System . out . println ( "  exception = " + ( ( Exception ) t ) . getMessage ( ) ) ; } } catch ( Exception e ) { fail ( "Wrong exception thrown, third test" ) ; } template = "#set($woogie.foo = 'lala') boing!" ; try { Velocity . evaluate ( vc , w , "test" , template ) ; fail ( "No exception thrown, set test." ) ; } catch ( MethodInvocationException mie ) { System . out . println ( "Caught MIE (good!) :" ) ; System . out . println ( "  reference = " + mie . getReferenceName ( ) ) ; System . out . println ( "  method    = " + mie . getMethodName ( ) ) ; Throwable t = mie . getWrappedThrowable ( ) ; System . out . println ( "  throwable = " + t ) ; if ( t instanceof Exception ) { System . out . println ( "  exception = " + ( ( Exception ) t ) . getMessage ( ) ) ; } } catch ( Exception e ) { fail ( "Wrong exception thrown, set test" ) ; } } public void doException ( ) throws Exception { throw new NullPointerException ( ) ; } public void getFoo ( ) throws Exception { throw new Exception ( "Hello from getFoo()" ) ; } public void setFoo ( String foo ) throws Exception { throw new Exception ( "Hello from setFoo()" ) ; } } 	0	['6', '3', '0', '8', '26', '15', '0', '8', '6', '2', '342', '0', '0', '0.907407407', '0.5', '2', '2', '56', '1', '0.8333', '0']
package org . apache . velocity . test ; import java . io . BufferedWriter ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . StringWriter ; import java . util . Vector ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . Template ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . test . provider . TestProvider ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . app . Velocity ; import junit . framework . TestCase ; public class VelocimacroTestCase extends TestCase { private String template1 = "#macro(foo $a)$a#end #macro(bar $b)#foo($b)#end #foreach($i in [1..3])#bar($i)#end" ; private String result1 = "  123" ; public VelocimacroTestCase ( ) { super ( "VelocimacroTestCase" ) ; try { Velocity . setProperty ( Velocity . VM_PERM_INLINE_LOCAL , Boolean . TRUE ) ; Velocity . init ( ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup VelocimacroTestCase!" ) ; System . exit ( 1 ) ; } } public static junit . framework . Test suite ( ) { return new VelocimacroTestCase ( ) ; } public void runTest ( ) { VelocityContext context = new VelocityContext ( ) ; try { StringWriter writer = new StringWriter ( ) ; Velocity . evaluate ( context , writer , "vm_chain1" , template1 ) ; String out = writer . toString ( ) ; if ( ! result1 . equals ( out ) ) { fail ( "output incorrect." ) ; } } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } } } 	0	['3', '3', '0', '6', '15', '1', '0', '6', '3', '0', '61', '1', '0', '0.960784314', '0.666666667', '3', '3', '18.66666667', '1', '0.6667', '0']
package org . apache . velocity . test ; import java . io . BufferedWriter ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import org . apache . velocity . Template ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . runtime . RuntimeSingleton ; public class ClasspathResourceTest extends BaseTestCase { private static final String TMPL_FILE_EXT = "vm" ; private static final String CMP_FILE_EXT = "cmp" ; private static final String RESULT_FILE_EXT = "res" ; private static final String RESULTS_DIR = "../test/cpload/results" ; private static final String COMPARE_DIR = "../test/cpload/compare" ; public ClasspathResourceTest ( ) { super ( "ClasspathResourceTest" ) ; try { assureResultsDirectoryExists ( RESULTS_DIR ) ; Velocity . setProperty ( Velocity . RESOURCE_LOADER , "classpath" ) ; Velocity . addProperty ( "classpath." + Velocity . RESOURCE_LOADER + ".class" , "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader" ) ; Velocity . setProperty ( "classpath." + Velocity . RESOURCE_LOADER + ".cache" , "false" ) ; Velocity . setProperty ( "classpath." + Velocity . RESOURCE_LOADER + ".modificationCheckInterval" , "2" ) ; Velocity . init ( ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup ClasspathResourceTest!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } public static junit . framework . Test suite ( ) { return new ClasspathResourceTest ( ) ; } public void runTest ( ) { try { assureResultsDirectoryExists ( RESULTS_DIR ) ; Template template1 = RuntimeSingleton . getTemplate ( getFileName ( null , "template/test1" , TMPL_FILE_EXT ) ) ; Template template2 = RuntimeSingleton . getTemplate ( getFileName ( null , "template/test2" , TMPL_FILE_EXT ) ) ; FileOutputStream fos1 = new FileOutputStream ( getFileName ( RESULTS_DIR , "test1" , RESULT_FILE_EXT ) ) ; FileOutputStream fos2 = new FileOutputStream ( getFileName ( RESULTS_DIR , "test2" , RESULT_FILE_EXT ) ) ; Writer writer1 = new BufferedWriter ( new OutputStreamWriter ( fos1 ) ) ; Writer writer2 = new BufferedWriter ( new OutputStreamWriter ( fos2 ) ) ; VelocityContext context = new VelocityContext ( ) ; template1 . merge ( context , writer1 ) ; writer1 . flush ( ) ; writer1 . close ( ) ; template2 . merge ( context , writer2 ) ; writer2 . flush ( ) ; writer2 . close ( ) ; if ( ! isMatch ( RESULTS_DIR , COMPARE_DIR , "test1" , RESULT_FILE_EXT , CMP_FILE_EXT ) || ! isMatch ( RESULTS_DIR , COMPARE_DIR , "test2" , RESULT_FILE_EXT , CMP_FILE_EXT ) ) { fail ( "Output is incorrect!" ) ; } } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } } } 	0	['3', '4', '0', '8', '23', '3', '0', '8', '3', '1.5', '130', '1', '0', '0.964285714', '0.666666667', '2', '4', '40.66666667', '2', '1', '0']
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTNumberLiteral extends SimpleNode { private Integer value = null ; public ASTNumberLiteral ( int id ) { super ( id ) ; } public ASTNumberLiteral ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws Exception { super . init ( context , data ) ; value = new Integer ( getFirstToken ( ) . image ) ; return data ; } public Object value ( InternalContextAdapter context ) { return value ; } } 	0	['5', '2', '0', '7', '11', '0', '4', '5', '5', '0.25', '44', '1', '0', '0.9', '0.433333333', '0', '0', '7.6', '1', '0.6', '0']
package org . apache . velocity . test . provider ; public class BoolObj { public boolean isBoolean ( ) { return true ; } public String isNotboolean ( ) { return "hello" ; } } 	0	['3', '1', '0', '1', '4', '3', '1', '0', '3', '2', '10', '0', '0', '0', '1', '0', '0', '2.333333333', '1', '0.6667', '0']
package org . apache . velocity . test ; import java . io . File ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . util . StringUtils ; import junit . framework . TestCase ; public class TexenTestCase extends BaseTestCase { private static final String RESULTS_DIR = "../test/texen/results" ; private static final String COMPARE_DIR = "../test/texen/compare" ; public TexenTestCase ( ) { super ( "TexenTestCase" ) ; } public static junit . framework . Test suite ( ) { return new TexenTestCase ( ) ; } protected void setUp ( ) { } public void runTest ( ) { try { assureResultsDirectoryExists ( RESULTS_DIR ) ; if ( ! isMatch ( RESULTS_DIR , COMPARE_DIR , "TurbineWeather" , "java" , "java" ) || ! isMatch ( RESULTS_DIR , COMPARE_DIR , "TurbineWeatherService" , "java" , "java" ) || ! isMatch ( RESULTS_DIR , COMPARE_DIR , "WeatherService" , "java" , "java" ) || ! isMatch ( RESULTS_DIR , COMPARE_DIR , "book" , "txt" , "txt" ) || ! isMatch ( RESULTS_DIR , COMPARE_DIR , "Test" , "txt" , "txt" ) ) { fail ( "Output is incorrect!" ) ; } } catch ( Exception e ) { } } } 	0	['4', '4', '0', '3', '8', '6', '0', '3', '3', '1.333333333', '62', '1', '0', '0.947368421', '0.75', '2', '4', '14', '5', '1.75', '0']
package org . apache . velocity . test ; import junit . framework . TestCase ; import junit . framework . Test ; import org . apache . velocity . util . StringUtils ; public class MiscTestCase extends BaseTestCase { public MiscTestCase ( ) { super ( "MiscTestCase" ) ; } public MiscTestCase ( String name ) { super ( name ) ; } public static Test suite ( ) { return new MiscTestCase ( ) ; } public void runTest ( ) { String eol = "XY" ; String arg = "XY" ; String res = StringUtils . chop ( arg , 1 , eol ) ; assertTrue ( "Test 1" , res . equals ( "" ) ) ; arg = "X" ; res = StringUtils . chop ( arg , 1 , eol ) ; assertTrue ( "Test 2" , res . equals ( "" ) ) ; arg = "ZXY" ; res = StringUtils . chop ( arg , 1 , eol ) ; assertTrue ( "Test 3" , res . equals ( "Z" ) ) ; arg = "Hello!" ; res = StringUtils . chop ( arg , 2 , eol ) ; assertTrue ( "Test 4" , res . equals ( "Hell" ) ) ; } } 	0	['4', '4', '0', '4', '8', '6', '0', '4', '4', '2', '67', '0', '0', '0.964285714', '0.5', '3', '3', '15.75', '1', '0.5', '0']
package org . apache . velocity . runtime . parser ; public interface ParserConstants { int EOF = 0 ; int LBRACKET = 1 ; int RBRACKET = 2 ; int COMMA = 3 ; int DOUBLEDOT = 4 ; int LPAREN = 5 ; int RPAREN = 6 ; int REFMOD2_RPAREN = 7 ; int ESCAPE_DIRECTIVE = 8 ; int SET_DIRECTIVE = 9 ; int DOLLAR = 10 ; int DOLLARBANG = 11 ; int HASH = 15 ; int DOUBLE_ESCAPE = 16 ; int ESCAPE = 17 ; int TEXT = 18 ; int SINGLE_LINE_COMMENT = 19 ; int FORMAL_COMMENT = 20 ; int MULTI_LINE_COMMENT = 21 ; int WHITESPACE = 23 ; int STRING_LITERAL = 24 ; int TRUE = 25 ; int FALSE = 26 ; int NEWLINE = 27 ; int MINUS = 28 ; int PLUS = 29 ; int MULTIPLY = 30 ; int DIVIDE = 31 ; int MODULUS = 32 ; int LOGICAL_AND = 33 ; int LOGICAL_OR = 34 ; int LOGICAL_LT = 35 ; int LOGICAL_LE = 36 ; int LOGICAL_GT = 37 ; int LOGICAL_GE = 38 ; int LOGICAL_EQUALS = 39 ; int LOGICAL_NOT_EQUALS = 40 ; int LOGICAL_NOT = 41 ; int EQUALS = 42 ; int END = 43 ; int IF_DIRECTIVE = 44 ; int ELSEIF_DIRECTIVE = 45 ; int ELSE_DIRECTIVE = 46 ; int STOP_DIRECTIVE = 47 ; int DIGIT = 48 ; int NUMBER_LITERAL = 49 ; int LETTER = 50 ; int DIRECTIVE_CHAR = 51 ; int WORD = 52 ; int ALPHA_CHAR = 53 ; int ALPHANUM_CHAR = 54 ; int IDENTIFIER_CHAR = 55 ; int IDENTIFIER = 56 ; int DOT = 57 ; int LCURLY = 58 ; int RCURLY = 59 ; int REFERENCE_TERMINATOR = 60 ; int DIRECTIVE_TERMINATOR = 61 ; int DIRECTIVE = 0 ; int REFMOD2 = 1 ; int REFMODIFIER = 2 ; int DEFAULT = 3 ; int PRE_DIRECTIVE = 4 ; int REFERENCE = 5 ; int IN_MULTI_LINE_COMMENT = 6 ; int IN_FORMAL_COMMENT = 7 ; int IN_SINGLE_LINE_COMMENT = 8 ; String [ ] tokenImage = { "<EOF>" , "\"[\"" , "\"]\"" , "\",\"" , "\"..\"" , "\"(\"" , "<RPAREN>" , "\")\"" , "<ESCAPE_DIRECTIVE>" , "<SET_DIRECTIVE>" , "<DOLLAR>" , "<DOLLARBANG>" , "\"##\"" , "<token of kind 13>" , "\"#*\"" , "\"#\"" , "\"\\\\\\\\\"" , "\"\\\\\"" , "<TEXT>" , "<SINGLE_LINE_COMMENT>" , "\"*#\"" , "\"*#\"" , "<token of kind 22>" , "<WHITESPACE>" , "<STRING_LITERAL>" , "\"true\"" , "\"false\"" , "<NEWLINE>" , "\"-\"" , "\"+\"" , "\"*\"" , "\"/\"" , "\"%\"" , "\"&&\"" , "\"||\"" , "\"<\"" , "\"<=\"" , "\">\"" , "\">=\"" , "\"==\"" , "\"!=\"" , "\"!\"" , "\"=\"" , "<END>" , "\"if\"" , "\"elseif\"" , "<ELSE_DIRECTIVE>" , "\"stop\"" , "<DIGIT>" , "<NUMBER_LITERAL>" , "<LETTER>" , "<DIRECTIVE_CHAR>" , "<WORD>" , "<ALPHA_CHAR>" , "<ALPHANUM_CHAR>" , "<IDENTIFIER_CHAR>" , "<IDENTIFIER>" , "<DOT>" , "\"{\"" , "\"}\"" , "<REFERENCE_TERMINATOR>" , "<DIRECTIVE_TERMINATOR>" , } ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '0', '2', '321', '0', '0', '0', '0', '0', '0', '252', '0', '0', '0']
package org . apache . velocity . test . provider ; public class Child extends Person { public String getName ( ) { return "Child" ; } } 	0	['2', '2', '0', '2', '3', '1', '1', '1', '2', '2', '7', '0', '0', '0.5', '1', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . velocity . test . provider ; public class Person { public String getName ( ) { return "Person" ; } } 	0	['2', '1', '1', '2', '3', '1', '2', '0', '2', '2', '7', '0', '0', '0', '1', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . velocity . test . view ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . FileInputStream ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . runtime . visitor . NodeViewMode ; import org . apache . velocity . runtime . parser . node . SimpleNode ; public class TemplateNodeView { private SimpleNode document ; private NodeViewMode visitor ; public TemplateNodeView ( String template ) { try { RuntimeSingleton . init ( "velocity.properties" ) ; InputStreamReader isr = new InputStreamReader ( new FileInputStream ( template ) , RuntimeSingleton . getString ( RuntimeSingleton . INPUT_ENCODING ) ) ; BufferedReader br = new BufferedReader ( isr ) ; document = RuntimeSingleton . parse ( br , template ) ; visitor = new NodeViewMode ( ) ; visitor . setContext ( null ) ; visitor . setWriter ( new PrintWriter ( System . out ) ) ; document . jjtAccept ( visitor , null ) ; } catch ( Exception e ) { System . out . println ( e ) ; e . printStackTrace ( ) ; } } public static void main ( String args [ ] ) { TemplateNodeView v = new TemplateNodeView ( args [ 0 ] ) ; } } 	0	['2', '1', '0', '6', '16', '1', '0', '6', '2', '0', '67', '1', '2', '0', '0.5', '0', '0', '31.5', '1', '0.5', '0']
package org . apache . velocity . runtime . parser ; public interface ParserTreeConstants { public int JJTPROCESS = 0 ; public int JJTVOID = 1 ; public int JJTESCAPEDDIRECTIVE = 2 ; public int JJTESCAPE = 3 ; public int JJTCOMMENT = 4 ; public int JJTNUMBERLITERAL = 5 ; public int JJTSTRINGLITERAL = 6 ; public int JJTIDENTIFIER = 7 ; public int JJTWORD = 8 ; public int JJTDIRECTIVE = 9 ; public int JJTBLOCK = 10 ; public int JJTOBJECTARRAY = 11 ; public int JJTINTEGERRANGE = 12 ; public int JJTMETHOD = 13 ; public int JJTREFERENCE = 14 ; public int JJTTRUE = 15 ; public int JJTFALSE = 16 ; public int JJTTEXT = 17 ; public int JJTIFSTATEMENT = 18 ; public int JJTELSESTATEMENT = 19 ; public int JJTELSEIFSTATEMENT = 20 ; public int JJTSETDIRECTIVE = 21 ; public int JJTEXPRESSION = 22 ; public int JJTASSIGNMENT = 23 ; public int JJTORNODE = 24 ; public int JJTANDNODE = 25 ; public int JJTEQNODE = 26 ; public int JJTNENODE = 27 ; public int JJTLTNODE = 28 ; public int JJTGTNODE = 29 ; public int JJTLENODE = 30 ; public int JJTGENODE = 31 ; public int JJTADDNODE = 32 ; public int JJTSUBTRACTNODE = 33 ; public int JJTMULNODE = 34 ; public int JJTDIVNODE = 35 ; public int JJTMODNODE = 36 ; public int JJTNOTNODE = 37 ; public String [ ] jjtNodeName = { "process" , "void" , "EscapedDirective" , "Escape" , "Comment" , "NumberLiteral" , "StringLiteral" , "Identifier" , "Word" , "Directive" , "Block" , "ObjectArray" , "IntegerRange" , "Method" , "Reference" , "True" , "False" , "Text" , "IfStatement" , "ElseStatement" , "ElseIfStatement" , "SetDirective" , "Expression" , "Assignment" , "OrNode" , "AndNode" , "EQNode" , "NENode" , "LTNode" , "GTNode" , "LENode" , "GENode" , "AddNode" , "SubtractNode" , "MulNode" , "DivNode" , "ModNode" , "NotNode" , } ; } 	0	['1', '1', '0', '3', '1', '0', '3', '0', '0', '2', '196', '0', '0', '0', '0', '0', '0', '156', '0', '0', '0']
package org . apache . velocity . test ; import java . io . InputStream ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Properties ; import javax . servlet . RequestDispatcher ; import javax . servlet . Servlet ; import javax . servlet . ServletConfig ; import javax . servlet . ServletContext ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . servlet . VelocityServlet ; import junit . framework . TestCase ; public class VelocityServletTest extends TestCase { public VelocityServletTest ( ) { super ( "VelocityServletTest" ) ; } public static junit . framework . Test suite ( ) { return new VelocityServletTest ( ) ; } public void runTest ( ) { MockVelocityServlet servlet = new MockVelocityServlet ( ) ; try { servlet . init ( new MockServletConfig ( ) ) ; } catch ( ServletException e ) { e . printStackTrace ( ) ; } System . out . println ( RuntimeConstants . OUTPUT_ENCODING + "=" + RuntimeSingleton . getProperty ( RuntimeConstants . OUTPUT_ENCODING ) ) ; HttpServletResponse res = new MockHttpServletResponse ( ) ; servlet . visibleSetContentType ( null , res ) ; assertEquals ( "Character encoding not set to UTF-8" , "UTF-8" , res . getCharacterEncoding ( ) ) ; } class MockVelocityServlet extends VelocityServlet { void visibleSetContentType ( HttpServletRequest req , HttpServletResponse res ) { setContentType ( req , res ) ; } protected Properties loadConfiguration ( ServletConfig config ) throws IOException { Properties p = new Properties ( ) ; p . setProperty ( RuntimeConstants . OUTPUT_ENCODING , "UTF-8" ) ; return p ; } public ServletConfig getServletConfig ( ) { return new MockServletConfig ( ) ; } } static class MockServletConfig implements ServletConfig { public String getInitParameter ( String ignored ) { return null ; } public Enumeration getInitParameterNames ( ) { return null ; } public ServletContext getServletContext ( ) { return new MockServletContext ( ) ; } public String getServletName ( ) { return "VelocityServlet" ; } } static class MockServletContext implements ServletContext { public Object getAttribute ( String ignored ) { return null ; } public Enumeration getAttributeNames ( ) { return null ; } public ServletContext getContext ( String ignored ) { return this ; } public String getInitParameter ( String ignored ) { return null ; } public Enumeration getInitParameterNames ( ) { return null ; } public int getMajorVersion ( ) { return - 1 ; } public String getMimeType ( String ignored ) { return null ; } public int getMinorVersion ( ) { return - 1 ; } public RequestDispatcher getNamedDispatcher ( String ignored ) { return null ; } public String getRealPath ( String ignored ) { return null ; } public RequestDispatcher getRequestDispatcher ( String ignored ) { return null ; } public URL getResource ( String ignored ) throws MalformedURLException { return null ; } public InputStream getResourceAsStream ( String ignored ) { return null ; } public String getServerInfo ( ) { return "Velocity Test Suite" ; } public Servlet getServlet ( String ignored ) throws ServletException { return null ; } public Enumeration getServletNames ( ) { return null ; } public Enumeration getServlets ( ) { return null ; } public void log ( Exception e , String msg ) { } public void log ( String msg ) { } public void log ( String msg , Throwable t ) { } public void removeAttribute ( String name ) { } public void setAttribute ( String name , Object value ) { } } static class MockHttpServletResponse implements HttpServletResponse { private String encoding ; public void flushBuffer ( ) throws IOException { } public int getBufferSize ( ) { return - 1 ; } public String getCharacterEncoding ( ) { return ( encoding != null ? encoding : "ISO-8859-1" ) ; } public java . util . Locale getLocale ( ) { return null ; } public javax . servlet . ServletOutputStream getOutputStream ( ) throws IOException { return null ; } public java . io . PrintWriter getWriter ( ) throws IOException { return null ; } public boolean isCommitted ( ) { return false ; } public void reset ( ) { } public void setBufferSize ( int i ) { } public void setContentLength ( int i ) { } public void setContentType ( String contentType ) { if ( contentType != null ) { int index = contentType . lastIndexOf ( ';' ) + 1 ; if ( 0 <= index || index < contentType . length ( ) ) { index = contentType . indexOf ( "charset=" , index ) ; if ( index != - 1 ) { index += 8 ; this . encoding = contentType . substring ( index ) . trim ( ) ; } } } } public void setLocale ( java . util . Locale l ) { } public void addCookie ( javax . servlet . http . Cookie c ) { } public void addDateHeader ( String s , long l ) { } public void addHeader ( String name , String value ) { } public void addIntHeader ( String name , int value ) { } public boolean containsHeader ( String name ) { return false ; } public String encodeRedirectURL ( String url ) { return url ; } public String encodeRedirectUrl ( String url ) { return url ; } public String encodeURL ( String url ) { return url ; } public String encodeUrl ( String url ) { return url ; } public void sendError ( int i ) throws IOException { } public void sendError ( int i , String s ) throws IOException { } public void sendRedirect ( String s ) throws IOException { } public void setDateHeader ( String s , long l ) { } public void setHeader ( String name , String value ) { } public void setIntHeader ( String s , int i ) { } public void setStatus ( int i ) { } public void setStatus ( int i , String s ) { } } } 	0	['3', '3', '0', '8', '18', '3', '1', '8', '3', '2', '50', '0', '0', '0.960784314', '0.666666667', '2', '2', '15.66666667', '1', '0.6667', '0']
package org . apache . velocity . runtime . configuration ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . io . Reader ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . NoSuchElementException ; import java . util . Properties ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . commons . collections . ExtendedProperties ; public class Configuration extends Hashtable { private ExtendedProperties deprecationCrutch = new ExtendedProperties ( ) ; private Configuration defaults ; protected String file ; protected String basePath ; protected String fileSeparator = System . getProperty ( "file.separator" ) ; protected boolean isInitialized = false ; protected static String include = "include" ; protected ArrayList keysAsListed = new ArrayList ( ) ; class PropertiesReader extends LineNumberReader { public PropertiesReader ( Reader reader ) { super ( reader ) ; } public String readProperty ( ) throws IOException { StringBuffer buffer = new StringBuffer ( ) ; try { while ( true ) { String line = readLine ( ) . trim ( ) ; if ( ( line . length ( ) != 0 ) && ( line . charAt ( 0 ) != '#' ) ) { if ( line . endsWith ( "\\" ) ) { line = line . substring ( 0 , line . length ( ) - 1 ) ; buffer . append ( line ) ; } else { buffer . append ( line ) ; break ; } } } } catch ( NullPointerException e ) { return null ; } return buffer . toString ( ) ; } } class PropertiesTokenizer extends StringTokenizer { static final String DELIMITER = "," ; public PropertiesTokenizer ( String string ) { super ( string , DELIMITER ) ; } public boolean hasMoreTokens ( ) { return super . hasMoreTokens ( ) ; } public String nextToken ( ) { StringBuffer buffer = new StringBuffer ( ) ; while ( hasMoreTokens ( ) ) { String token = super . nextToken ( ) ; if ( token . endsWith ( "\\" ) ) { buffer . append ( token . substring ( 0 , token . length ( ) - 1 ) ) ; buffer . append ( DELIMITER ) ; } else { buffer . append ( token ) ; break ; } } return buffer . toString ( ) . trim ( ) ; } } public Configuration ( ) { super ( ) ; } public Configuration ( String file ) throws IOException { this ( file , null ) ; } public Configuration ( String file , String defaultFile ) throws IOException { this . file = file ; basePath = new File ( file ) . getAbsolutePath ( ) ; basePath = basePath . substring ( 0 , basePath . lastIndexOf ( fileSeparator ) + 1 ) ; this . load ( new FileInputStream ( file ) ) ; if ( defaultFile != null ) { defaults = new Configuration ( defaultFile ) ; } } private void init ( Configuration exp ) throws IOException { isInitialized = true ; } public boolean isInitialized ( ) { return isInitialized ; } public String getInclude ( ) { return Configuration . include ; } public void setInclude ( String inc ) { Configuration . include = inc ; } public synchronized void load ( InputStream input ) throws IOException { PropertiesReader reader = new PropertiesReader ( new InputStreamReader ( input ) ) ; try { while ( true ) { String line = reader . readProperty ( ) ; int equalSign = line . indexOf ( '=' ) ; if ( equalSign > 0 ) { String key = line . substring ( 0 , equalSign ) . trim ( ) ; String value = line . substring ( equalSign + 1 ) . trim ( ) ; if ( "" . equals ( value ) ) continue ; if ( getInclude ( ) != null && key . equalsIgnoreCase ( getInclude ( ) ) ) { File file = null ; if ( value . startsWith ( fileSeparator ) ) { file = new File ( value ) ; } else { if ( value . startsWith ( "." + fileSeparator ) ) { value = value . substring ( 2 ) ; } file = new File ( basePath + value ) ; } if ( file != null && file . exists ( ) && file . canRead ( ) ) { load ( new FileInputStream ( file ) ) ; } } else { addProperty ( key , value ) ; } } } } catch ( NullPointerException e ) { return ; } } public Object getProperty ( String key ) { Object o = this . get ( key ) ; if ( o == null ) { if ( defaults != null ) { o = defaults . get ( key ) ; } } return o ; } public void addProperty ( String key , Object token ) { deprecationCrutch . addProperty ( key , token ) ; Object o = this . get ( key ) ; if ( o instanceof String ) { Vector v = new Vector ( 2 ) ; v . addElement ( o ) ; v . addElement ( token ) ; put ( key , v ) ; } else if ( o instanceof Vector ) { ( ( Vector ) o ) . addElement ( token ) ; } else { if ( token instanceof String && ( ( String ) token ) . indexOf ( PropertiesTokenizer . DELIMITER ) > 0 ) { PropertiesTokenizer tokenizer = new PropertiesTokenizer ( ( String ) token ) ; while ( tokenizer . hasMoreTokens ( ) ) { String value = tokenizer . nextToken ( ) ; addStringProperty ( key , value ) ; } } else { if ( ! containsKey ( key ) ) { keysAsListed . add ( key ) ; } put ( key , token ) ; } } } private void addStringProperty ( String key , String token ) { Object o = this . get ( key ) ; if ( o instanceof String ) { Vector v = new Vector ( 2 ) ; v . addElement ( o ) ; v . addElement ( token ) ; put ( key , v ) ; } else if ( o instanceof Vector ) { ( ( Vector ) o ) . addElement ( token ) ; } else { if ( ! containsKey ( key ) ) { keysAsListed . add ( key ) ; } put ( key , token ) ; } } public void setProperty ( String key , Object value ) { clearProperty ( key ) ; addProperty ( key , value ) ; } public synchronized void save ( OutputStream output , String Header ) throws IOException { if ( output != null ) { PrintWriter theWrtr = new PrintWriter ( output ) ; if ( Header != null ) { theWrtr . println ( Header ) ; } Enumeration theKeys = keys ( ) ; while ( theKeys . hasMoreElements ( ) ) { String key = ( String ) theKeys . nextElement ( ) ; Object value = get ( ( Object ) key ) ; if ( value != null ) { if ( value instanceof String ) { StringBuffer currentOutput = new StringBuffer ( ) ; currentOutput . append ( key ) ; currentOutput . append ( "=" ) ; currentOutput . append ( ( String ) value ) ; theWrtr . println ( currentOutput . toString ( ) ) ; } else if ( value instanceof Vector ) { Vector values = ( Vector ) value ; Enumeration valuesEnum = values . elements ( ) ; while ( valuesEnum . hasMoreElements ( ) ) { String currentElement = ( String ) valuesEnum . nextElement ( ) ; StringBuffer currentOutput = new StringBuffer ( ) ; currentOutput . append ( key ) ; currentOutput . append ( "=" ) ; currentOutput . append ( currentElement ) ; theWrtr . println ( currentOutput . toString ( ) ) ; } } } theWrtr . println ( ) ; theWrtr . flush ( ) ; } } } public void combine ( Configuration c ) { for ( Iterator i = c . getKeys ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; setProperty ( key , c . get ( key ) ) ; } } public void clearProperty ( String key ) { deprecationCrutch . clearProperty ( key ) ; if ( containsKey ( key ) ) { for ( int i = 0 ; i < keysAsListed . size ( ) ; i ++ ) { if ( ( ( String ) keysAsListed . get ( i ) ) . equals ( key ) ) { keysAsListed . remove ( i ) ; break ; } } remove ( key ) ; } } public Iterator getKeys ( ) { return keysAsListed . iterator ( ) ; } public Iterator getKeys ( String prefix ) { Iterator keys = getKeys ( ) ; ArrayList matchingKeys = new ArrayList ( ) ; while ( keys . hasNext ( ) ) { Object key = keys . next ( ) ; if ( key instanceof String && ( ( String ) key ) . startsWith ( prefix ) ) { matchingKeys . add ( key ) ; } } return matchingKeys . iterator ( ) ; } public Configuration subset ( String prefix ) { Configuration c = new Configuration ( ) ; Iterator keys = getKeys ( ) ; boolean validSubset = false ; while ( keys . hasNext ( ) ) { Object key = keys . next ( ) ; if ( key instanceof String && ( ( String ) key ) . startsWith ( prefix ) ) { if ( ! validSubset ) { validSubset = true ; } String newKey = null ; if ( ( ( String ) key ) . length ( ) == prefix . length ( ) ) { newKey = prefix ; } else { newKey = ( ( String ) key ) . substring ( prefix . length ( ) + 1 ) ; } c . setProperty ( newKey , get ( key ) ) ; } } if ( validSubset ) { return c ; } else { return null ; } } public void display ( ) { Iterator i = getKeys ( ) ; while ( i . hasNext ( ) ) { String key = ( String ) i . next ( ) ; Object value = get ( key ) ; System . out . println ( key + " => " + value ) ; } } public String getString ( String key ) { return getString ( key , null ) ; } public String getString ( String key , String defaultValue ) { Object value = get ( key ) ; if ( value instanceof String ) { return ( String ) value ; } else if ( value == null ) { if ( defaults != null ) { return defaults . getString ( key , defaultValue ) ; } else { return defaultValue ; } } else if ( value instanceof Vector ) { return ( String ) ( ( Vector ) value ) . get ( 0 ) ; } else { throw new ClassCastException ( '\'' + key + "' doesn't map to a String object" ) ; } } public Properties getProperties ( String key ) { return getProperties ( key , new Properties ( ) ) ; } public Properties getProperties ( String key , Properties defaults ) { String [ ] tokens = getStringArray ( key ) ; Properties props = new Properties ( defaults ) ; for ( int i = 0 ; i < tokens . length ; i ++ ) { String token = tokens [ i ] ; int equalSign = token . indexOf ( '=' ) ; if ( equalSign > 0 ) { String pkey = token . substring ( 0 , equalSign ) . trim ( ) ; String pvalue = token . substring ( equalSign + 1 ) . trim ( ) ; props . put ( pkey , pvalue ) ; } else { throw new IllegalArgumentException ( '\'' + token + "' does not contain " + "an equals sign" ) ; } } return props ; } public String [ ] getStringArray ( String key ) { Object value = get ( key ) ; Vector vector ; if ( value instanceof String ) { vector = new Vector ( 1 ) ; vector . addElement ( value ) ; } else if ( value instanceof Vector ) { vector = ( Vector ) value ; } else if ( value == null ) { if ( defaults != null ) { return defaults . getStringArray ( key ) ; } else { return new String [ 0 ] ; } } else { throw new ClassCastException ( '\'' + key + "' doesn't map to a String/Vector object" ) ; } String [ ] tokens = new String [ vector . size ( ) ] ; for ( int i = 0 ; i < tokens . length ; i ++ ) { tokens [ i ] = ( String ) vector . elementAt ( i ) ; } return tokens ; } public Vector getVector ( String key ) { return getVector ( key , null ) ; } public Vector getVector ( String key , Vector defaultValue ) { Object value = get ( key ) ; if ( value instanceof Vector ) { return ( Vector ) value ; } else if ( value instanceof String ) { Vector v = new Vector ( 1 ) ; v . addElement ( ( String ) value ) ; put ( key , v ) ; return v ; } else if ( value == null ) { if ( defaults != null ) { return defaults . getVector ( key , defaultValue ) ; } else { return ( ( defaultValue == null ) ? new Vector ( ) : defaultValue ) ; } } else { throw new ClassCastException ( '\'' + key + "' doesn't map to a Vector object" ) ; } } public boolean getBoolean ( String key ) { Boolean b = getBoolean ( key , ( Boolean ) null ) ; if ( b != null ) { return b . booleanValue ( ) ; } else { throw new NoSuchElementException ( '\'' + key + "' doesn't map to an existing object" ) ; } } public boolean getBoolean ( String key , boolean defaultValue ) { return getBoolean ( key , new Boolean ( defaultValue ) ) . booleanValue ( ) ; } public Boolean getBoolean ( String key , Boolean defaultValue ) { Object value = get ( key ) ; if ( value instanceof Boolean ) { return ( Boolean ) value ; } else if ( value instanceof String ) { String s = testBoolean ( ( String ) value ) ; Boolean b = new Boolean ( s ) ; put ( key , b ) ; return b ; } else if ( value == null ) { if ( defaults != null ) { return defaults . getBoolean ( key , defaultValue ) ; } else { return defaultValue ; } } else { throw new ClassCastException ( '\'' + key + "' doesn't map to a Boolean object" ) ; } } public String testBoolean ( String value ) { String s = ( ( String ) value ) . toLowerCase ( ) ; if ( s . equals ( "true" ) || s . equals ( "on" ) || s . equals ( "yes" ) ) { return "true" ; } else if ( s . equals ( "false" ) || s . equals ( "off" ) || s . equals ( "no" ) ) { return "false" ; } else { return null ; } } public byte getByte ( String key ) { Byte b = getByte ( key , null ) ; if ( b != null ) { return b . byteValue ( ) ; } else { throw new NoSuchElementException ( '\'' + key + " doesn't map to an existing object" ) ; } } public byte getByte ( String key , byte defaultValue ) { return getByte ( key , new Byte ( defaultValue ) ) . byteValue ( ) ; } public Byte getByte ( String key , Byte defaultValue ) { Object value = get ( key ) ; if ( value instanceof Byte ) { return ( Byte ) value ; } else if ( value instanceof String ) { Byte b = new Byte ( ( String ) value ) ; put ( key , b ) ; return b ; } else if ( value == null ) { if ( defaults != null ) { return defaults . getByte ( key , defaultValue ) ; } else { return defaultValue ; } } else { throw new ClassCastException ( '\'' + key + "' doesn't map to a Byte object" ) ; } } public short getShort ( String key ) { Short s = getShort ( key , null ) ; if ( s != null ) { return s . shortValue ( ) ; } else { throw new NoSuchElementException ( '\'' + key + "' doesn't map to an existing object" ) ; } } public short getShort ( String key , short defaultValue ) { return getShort ( key , new Short ( defaultValue ) ) . shortValue ( ) ; } public Short getShort ( String key , Short defaultValue ) { Object value = get ( key ) ; if ( value instanceof Short ) { return ( Short ) value ; } else if ( value instanceof String ) { Short s = new Short ( ( String ) value ) ; put ( key , s ) ; return s ; } else if ( value == null ) { if ( defaults != null ) { return defaults . getShort ( key , defaultValue ) ; } else { return defaultValue ; } } else { throw new ClassCastException ( '\'' + key + "' doesn't map to a Short object" ) ; } } public int getInt ( String name ) { return getInteger ( name ) ; } public int getInt ( String name , int def ) { return getInteger ( name , def ) ; } public int getInteger ( String key ) { Integer i = getInteger ( key , null ) ; if ( i != null ) { return i . intValue ( ) ; } else { throw new NoSuchElementException ( '\'' + key + "' doesn't map to an existing object" ) ; } } public int getInteger ( String key , int defaultValue ) { Integer i = getInteger ( key , null ) ; if ( i == null ) { return defaultValue ; } return i . intValue ( ) ; } public Integer getInteger ( String key , Integer defaultValue ) { Object value = get ( key ) ; if ( value instanceof Integer ) { return ( Integer ) value ; } else if ( value instanceof String ) { Integer i = new Integer ( ( String ) value ) ; put ( key , i ) ; return i ; } else if ( value == null ) { if ( defaults != null ) { return defaults . getInteger ( key , defaultValue ) ; } else { return defaultValue ; } } else { throw new ClassCastException ( '\'' + key + "' doesn't map to a Integer object" ) ; } } public long getLong ( String key ) { Long l = getLong ( key , null ) ; if ( l != null ) { return l . longValue ( ) ; } else { throw new NoSuchElementException ( '\'' + key + "' doesn't map to an existing object" ) ; } } public long getLong ( String key , long defaultValue ) { return getLong ( key , new Long ( defaultValue ) ) . longValue ( ) ; } public Long getLong ( String key , Long defaultValue ) { Object value = get ( key ) ; if ( value instanceof Long ) { return ( Long ) value ; } else if ( value instanceof String ) { Long l = new Long ( ( String ) value ) ; put ( key , l ) ; return l ; } else if ( value == null ) { if ( defaults != null ) { return defaults . getLong ( key , defaultValue ) ; } else { return defaultValue ; } } else { throw new ClassCastException ( '\'' + key + "' doesn't map to a Long object" ) ; } } public float getFloat ( String key ) { Float f = getFloat ( key , null ) ; if ( f != null ) { return f . floatValue ( ) ; } else { throw new NoSuchElementException ( '\'' + key + "' doesn't map to an existing object" ) ; } } public float getFloat ( String key , float defaultValue ) { return getFloat ( key , new Float ( defaultValue ) ) . floatValue ( ) ; } public Float getFloat ( String key , Float defaultValue ) { Object value = get ( key ) ; if ( value instanceof Float ) { return ( Float ) value ; } else if ( value instanceof String ) { Float f = new Float ( ( String ) value ) ; put ( key , f ) ; return f ; } else if ( value == null ) { if ( defaults != null ) { return defaults . getFloat ( key , defaultValue ) ; } else { return defaultValue ; } } else { throw new ClassCastException ( '\'' + key + "' doesn't map to a Float object" ) ; } } public double getDouble ( String key ) { Double d = getDouble ( key , null ) ; if ( d != null ) { return d . doubleValue ( ) ; } else { throw new NoSuchElementException ( '\'' + key + "' doesn't map to an existing object" ) ; } } public double getDouble ( String key , double defaultValue ) { return getDouble ( key , new Double ( defaultValue ) ) . doubleValue ( ) ; } public Double getDouble ( String key , Double defaultValue ) { Object value = get ( key ) ; if ( value instanceof Double ) { return ( Double ) value ; } else if ( value instanceof String ) { Double d = new Double ( ( String ) value ) ; put ( key , d ) ; return d ; } else if ( value == null ) { if ( defaults != null ) { return defaults . getDouble ( key , defaultValue ) ; } else { return defaultValue ; } } else { throw new ClassCastException ( '\'' + key + "' doesn't map to a Double object" ) ; } } public static Configuration convertProperties ( Properties p ) { Configuration c = new Configuration ( ) ; for ( Enumeration e = p . keys ( ) ; e . hasMoreElements ( ) ; ) { String s = ( String ) e . nextElement ( ) ; c . setProperty ( s , p . getProperty ( s ) ) ; } return c ; } public ExtendedProperties getExtendedProperties ( ) { return deprecationCrutch ; } } 	0	['53', '3', '0', '6', '139', '1188', '5', '3', '50', '0.834134615', '1625', '1', '1', '0.395061728', '0.102272727', '0', '0', '29.50943396', '7', '2.5094', '0']
package org . apache . velocity . runtime . compiler ; import org . apache . bcel . generic . * ; import org . apache . bcel . Constants ; public class Compiler implements InstructionConstants { public static void main ( String [ ] args ) { String template = args [ 0 ] . substring ( 0 , args [ 0 ] . indexOf ( "." ) ) ; ClassGen cg = new ClassGen ( template , "java.lang.Object" , "<generated>" , Constants . ACC_PUBLIC | Constants . ACC_SUPER , null ) ; ConstantPoolGen cp = cg . getConstantPool ( ) ; InstructionList il = new InstructionList ( ) ; MethodGen mg = new MethodGen ( Constants . ACC_STATIC | Constants . ACC_PUBLIC , Type . VOID , new Type [ ] { new ArrayType ( Type . STRING , 1 ) } , new String [ ] { "argv" } , "main" , template , il , cp ) ; int br_index = cp . addClass ( "java.io.BufferedReader" ) ; int ir_index = cp . addClass ( "java.io.InputStreamReader" ) ; int system_out = cp . addFieldref ( "java.lang.System" , "out" , "Ljava/io/PrintStream;" ) ; int system_in = cp . addFieldref ( "java.lang.System" , "in" , "Ljava/io/InputStream;" ) ; il . append ( new NEW ( br_index ) ) ; il . append ( DUP ) ; il . append ( new NEW ( ir_index ) ) ; il . append ( DUP ) ; il . append ( new GETSTATIC ( system_in ) ) ; il . append ( new INVOKESPECIAL ( cp . addMethodref ( "java.io.InputStreamReader" , "<init>" , "(Ljava/io/InputStream;)V" ) ) ) ; il . append ( new INVOKESPECIAL ( cp . addMethodref ( "java.io.BufferedReader" , "<init>" , "(Ljava/io/Reader;)V" ) ) ) ; LocalVariableGen lg = mg . addLocalVariable ( "in" , new ObjectType ( "java.io.BufferedReader" ) , null , null ) ; int in = lg . getIndex ( ) ; lg . setStart ( il . append ( new ASTORE ( in ) ) ) ; lg = mg . addLocalVariable ( "name" , Type . STRING , null , null ) ; int name = lg . getIndex ( ) ; il . append ( ACONST_NULL ) ; lg . setStart ( il . append ( new ASTORE ( name ) ) ) ; InstructionHandle try_start = il . append ( new GETSTATIC ( system_out ) ) ; il . append ( new PUSH ( cp , "I will be a template compiler!" ) ) ; il . append ( new INVOKEVIRTUAL ( cp . addMethodref ( "java.io.PrintStream" , "println" , "(Ljava/lang/String;)V" ) ) ) ; GOTO g = new GOTO ( null ) ; InstructionHandle try_end = il . append ( g ) ; InstructionHandle handler = il . append ( RETURN ) ; mg . addExceptionHandler ( try_start , try_end , handler , new ObjectType ( "java.io.IOException" ) ) ; InstructionHandle ih = il . append ( new GETSTATIC ( system_out ) ) ; g . setTarget ( ih ) ; il . append ( new NEW ( cp . addClass ( "java.lang.StringBuffer" ) ) ) ; il . append ( DUP ) ; il . append ( new PUSH ( cp , " " ) ) ; il . append ( new INVOKESPECIAL ( cp . addMethodref ( "java.lang.StringBuffer" , "<init>" , "(Ljava/lang/String;)V" ) ) ) ; il . append ( new ALOAD ( name ) ) ; String sig = Type . getMethodSignature ( Type . STRINGBUFFER , new Type [ ] { Type . STRING } ) ; il . append ( new INVOKEVIRTUAL ( cp . addMethodref ( "java.lang.StringBuffer" , "append" , sig ) ) ) ; il . append ( new INVOKEVIRTUAL ( cp . addMethodref ( "java.lang.StringBuffer" , "toString" , "()Ljava/lang/String;" ) ) ) ; il . append ( RETURN ) ; mg . setMaxStack ( 5 ) ; cg . addMethod ( mg . getMethod ( ) ) ; cg . addEmptyConstructor ( Constants . ACC_PUBLIC ) ; try { cg . getJavaClass ( ) . dump ( template + ".class" ) ; } catch ( java . io . IOException e ) { System . err . println ( e ) ; } } } 	0	['2', '1', '0', '28', '41', '1', '0', '28', '2', '2', '332', '0', '0', '0', '0.5', '0', '0', '165', '1', '0.5', '0']
package org . apache . velocity . runtime . parser ; public class TokenMgrError extends Error { static final int LEXICAL_ERROR = 0 ; static final int STATIC_LEXER_ERROR = 1 ; static final int INVALID_LEXICAL_STATE = 2 ; static final int LOOP_DETECTED = 3 ; int errorCode ; protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } private static final String LexicalError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar ) { return ( "Lexical error at line " + errorLine + ", column " + errorColumn + ".  Encountered: " + ( EOFSeen ? "<EOF> " : ( "\"" + addEscapes ( String . valueOf ( curChar ) ) + "\"" ) + " (" + ( int ) curChar + "), " ) + "after : \"" + addEscapes ( errorAfter ) + "\"" ) ; } public String getMessage ( ) { return super . getMessage ( ) ; } public TokenMgrError ( ) { } public TokenMgrError ( String message , int reason ) { super ( message ) ; errorCode = reason ; } public TokenMgrError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar , int reason ) { this ( LexicalError ( EOFSeen , lexState , errorLine , errorColumn , errorAfter , curChar ) , reason ) ; } } 	0	['6', '3', '0', '2', '19', '15', '2', '0', '4', '1.12', '184', '0', '0', '0.8125', '0.5', '1', '1', '28.83333333', '14', '2.8333', '0']
package org . apache . velocity . runtime . parser ; public class Token { public int kind ; public int beginLine , beginColumn , endLine , endColumn ; public String image ; public Token next ; public Token specialToken ; public final String toString ( ) { return image ; } public static final Token newToken ( int ofKind ) { switch ( ofKind ) { default : return new Token ( ) ; } } } 	0	['3', '1', '0', '20', '4', '3', '20', '0', '3', '1.4375', '23', '0', '2', '0', '0.5', '0', '0', '4', '2', '1', '0']
package org . apache . velocity . runtime . parser ; import org . apache . velocity . runtime . parser . node . * ; class JJTParserState { private java . util . Stack nodes ; private java . util . Stack marks ; private int sp ; private int mk ; private boolean node_created ; JJTParserState ( ) { nodes = new java . util . Stack ( ) ; marks = new java . util . Stack ( ) ; sp = 0 ; mk = 0 ; } boolean nodeCreated ( ) { return node_created ; } void reset ( ) { nodes . removeAllElements ( ) ; marks . removeAllElements ( ) ; sp = 0 ; mk = 0 ; } Node rootNode ( ) { return ( Node ) nodes . elementAt ( 0 ) ; } void pushNode ( Node n ) { nodes . push ( n ) ; ++ sp ; } Node popNode ( ) { if ( -- sp < mk ) { mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; } return ( Node ) nodes . pop ( ) ; } Node peekNode ( ) { return ( Node ) nodes . peek ( ) ; } int nodeArity ( ) { return sp - mk ; } void clearNodeScope ( Node n ) { while ( sp > mk ) { popNode ( ) ; } mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; } void openNodeScope ( Node n ) { marks . push ( new Integer ( mk ) ) ; mk = sp ; n . jjtOpen ( ) ; } void closeNodeScope ( Node n , int num ) { mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; while ( num -- > 0 ) { Node c = popNode ( ) ; c . jjtSetParent ( n ) ; n . jjtAddChild ( c , num ) ; } n . jjtClose ( ) ; pushNode ( n ) ; node_created = true ; } void closeNodeScope ( Node n , boolean condition ) { if ( condition ) { int a = nodeArity ( ) ; mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; while ( a -- > 0 ) { Node c = popNode ( ) ; c . jjtSetParent ( n ) ; n . jjtAddChild ( c , a ) ; } n . jjtClose ( ) ; pushNode ( n ) ; node_created = true ; } else { mk = ( ( Integer ) marks . pop ( ) ) . intValue ( ) ; node_created = false ; } } } 	0	['12', '1', '0', '2', '25', '0', '1', '1', '0', '0.436363636', '218', '1', '0', '0', '0.395833333', '0', '0', '16.75', '3', '1.3333', '0']
package org . apache . velocity . test ; import java . io . FileInputStream ; import java . util . Properties ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . velocity . app . Velocity ; import junit . framework . TestSuite ; public class TemplateTestSuite extends TestSuite implements TemplateTestBase { private Properties testProperties ; public TemplateTestSuite ( ) { try { Velocity . setProperty ( Velocity . FILE_RESOURCE_LOADER_PATH , FILE_RESOURCE_LOADER_PATH ) ; Velocity . setProperty ( Velocity . RUNTIME_LOG_ERROR_STACKTRACE , "true" ) ; Velocity . setProperty ( Velocity . RUNTIME_LOG_WARN_STACKTRACE , "true" ) ; Velocity . setProperty ( Velocity . RUNTIME_LOG_INFO_STACKTRACE , "true" ) ; Velocity . init ( ) ; testProperties = new Properties ( ) ; testProperties . load ( new FileInputStream ( TEST_CASE_PROPERTIES ) ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup TemplateTestSuite!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } addTemplateTestCases ( ) ; } private void addTemplateTestCases ( ) { String template ; for ( int i = 1 ; ; i ++ ) { template = testProperties . getProperty ( getTemplateTestKey ( i ) ) ; if ( template != null ) { System . out . println ( "Adding TemplateTestCase : " + template ) ; addTest ( new TemplateTestCase ( template ) ) ; } else { break ; } } } private static final String getTemplateTestKey ( int nbr ) { return ( "test.template." + nbr ) ; } } 	0	['3', '2', '0', '5', '19', '1', '1', '5', '1', '0.5', '82', '1', '0', '0.9', '0.5', '0', '0', '26', '2', '1', '0']
package org . apache . velocity . test ; import java . io . BufferedWriter ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . Vector ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . Template ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . runtime . RuntimeSingleton ; public class ContextSafetyTestCase extends BaseTestCase implements TemplateTestBase { public ContextSafetyTestCase ( ) { super ( "ContextSafetyTestCase" ) ; try { Velocity . setProperty ( Velocity . FILE_RESOURCE_LOADER_PATH , FILE_RESOURCE_LOADER_PATH ) ; Velocity . init ( ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup ContextSafetyTestCase!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } public static junit . framework . Test suite ( ) { return new ContextSafetyTestCase ( ) ; } public void runTest ( ) { Vector v = new Vector ( ) ; v . addElement ( new String ( "vector hello 1" ) ) ; v . addElement ( new String ( "vector hello 2" ) ) ; v . addElement ( new String ( "vector hello 3" ) ) ; String strArray [ ] = new String [ 3 ] ; strArray [ 0 ] = "array hello 1" ; strArray [ 1 ] = "array hello 2" ; strArray [ 2 ] = "array hello 3" ; VelocityContext context = new VelocityContext ( ) ; try { assureResultsDirectoryExists ( RESULT_DIR ) ; Template template = RuntimeSingleton . getTemplate ( getFileName ( null , "context_safety" , TMPL_FILE_EXT ) ) ; FileOutputStream fos1 = new FileOutputStream ( getFileName ( RESULT_DIR , "context_safety1" , RESULT_FILE_EXT ) ) ; FileOutputStream fos2 = new FileOutputStream ( getFileName ( RESULT_DIR , "context_safety2" , RESULT_FILE_EXT ) ) ; Writer writer1 = new BufferedWriter ( new OutputStreamWriter ( fos1 ) ) ; Writer writer2 = new BufferedWriter ( new OutputStreamWriter ( fos2 ) ) ; context . put ( "vector" , v ) ; template . merge ( context , writer1 ) ; writer1 . flush ( ) ; writer1 . close ( ) ; context . put ( "vector" , strArray ) ; template . merge ( context , writer2 ) ; writer2 . flush ( ) ; writer2 . close ( ) ; if ( ! isMatch ( RESULT_DIR , COMPARE_DIR , "context_safety1" , RESULT_FILE_EXT , CMP_FILE_EXT ) || ! isMatch ( RESULT_DIR , COMPARE_DIR , "context_safety2" , RESULT_FILE_EXT , CMP_FILE_EXT ) ) { fail ( "Output incorrect." ) ; } } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } } } 	0	['3', '4', '0', '10', '26', '3', '0', '10', '3', '2', '155', '0', '0', '0.964285714', '0.666666667', '2', '4', '50.66666667', '2', '1', '0']
package org . apache . velocity . test ; import java . util . ArrayList ; import java . lang . reflect . Method ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . runtime . RuntimeSingleton ; import junit . framework . TestCase ; public class IntrospectorTestCase2 extends BaseTestCase { IntrospectorTestCase2 ( ) { super ( "IntrospectorTestCase2" ) ; } public IntrospectorTestCase2 ( String name ) { super ( name ) ; } public static junit . framework . Test suite ( ) { return new IntrospectorTestCase2 ( ) ; } public void runTest ( ) { try { Velocity . init ( ) ; Method method ; String result ; Tester t = new Tester ( ) ; Object [ ] params = { new Foo ( ) , new Foo ( ) } ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( Tester . class , "find" , params ) ; if ( method == null ) fail ( "Returned method was null" ) ; result = ( String ) method . invoke ( t , params ) ; if ( ! result . equals ( "Bar-Bar" ) ) { fail ( "Should have gotten 'Bar-Bar' : recieved '" + result + "'" ) ; } method = RuntimeSingleton . getIntrospector ( ) . getMethod ( Tester2 . class , "find" , params ) ; if ( method != null ) fail ( "Introspector shouldn't have found a method as it's ambiguous." ) ; } catch ( Exception e ) { fail ( e . toString ( ) ) ; } } public interface Woogie { } public static class Bar implements Woogie { int i ; } public static class Foo extends Bar { int j ; } public static class Tester { public static String find ( Woogie w , Object o ) { return "Woogie-Object" ; } public static String find ( Object w , Bar o ) { return "Object-Bar" ; } public static String find ( Bar w , Bar o ) { return "Bar-Bar" ; } public static String find ( Object o ) { return "Object" ; } public static String find ( Woogie o ) { return "Woogie" ; } } public static class Tester2 { public static String find ( Woogie w , Object o ) { return "Woogie-Object" ; } public static String find ( Object w , Bar o ) { return "Object-Bar" ; } public static String find ( Bar w , Object o ) { return "Bar-Object" ; } public static String find ( Object o ) { return "Object" ; } public static String find ( Woogie o ) { return "Woogie" ; } } } 	0	['5', '4', '0', '8', '21', '10', '0', '8', '3', '1', '110', '0', '0', '0.947368421', '0.5', '3', '3', '20.6', '5', '1.4', '0']
package org . apache . velocity . test ; import java . util . ArrayList ; import java . util . List ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . RuntimeSingleton ; import junit . framework . TestCase ; import junit . framework . Test ; import junit . framework . TestSuite ; public class IntrospectorTestCase3 extends BaseTestCase { public IntrospectorTestCase3 ( String name ) { super ( name ) ; } public static Test suite ( ) { return new TestSuite ( IntrospectorTestCase3 . class ) ; } public void testSimple ( ) throws Exception { Method method ; String result ; String type ; MethodProvider mp = new MethodProvider ( ) ; Object [ ] listIntInt = { new ArrayList ( ) , new Integer ( 1 ) , new Integer ( 2 ) } ; Object [ ] listLongList = { new ArrayList ( ) , new Long ( 1 ) , new ArrayList ( ) } ; Object [ ] listLongInt = { new ArrayList ( ) , new Long ( 1 ) , new Integer ( 2 ) } ; Object [ ] intInt = { new Integer ( 1 ) , new Integer ( 2 ) } ; Object [ ] longInt = { new Long ( 1 ) , new Integer ( 2 ) } ; Object [ ] longLong = { new Long ( 1 ) , new Long ( 2 ) } ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , "lii" , listIntInt ) ; result = ( String ) method . invoke ( mp , listIntInt ) ; assertTrue ( result . equals ( "lii" ) ) ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , "ii" , intInt ) ; result = ( String ) method . invoke ( mp , intInt ) ; assertTrue ( result . equals ( "ii" ) ) ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , "ll" , longInt ) ; result = ( String ) method . invoke ( mp , longInt ) ; assertTrue ( result . equals ( "ll" ) ) ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , "ll" , longLong ) ; result = ( String ) method . invoke ( mp , longLong ) ; assertTrue ( result . equals ( "ll" ) ) ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , "lll" , listLongList ) ; result = ( String ) method . invoke ( mp , listLongList ) ; assertTrue ( result . equals ( "lll" ) ) ; Object [ ] oa = { null , new Integer ( 0 ) } ; method = RuntimeSingleton . getIntrospector ( ) . getMethod ( MethodProvider . class , "lll" , oa ) ; result = ( String ) method . invoke ( mp , oa ) ; assertTrue ( result . equals ( "Listl" ) ) ; } public static class MethodProvider { public String ii ( int p , int d ) { return "ii" ; } public String lii ( List s , int p , int d ) { return "lii" ; } public String lll ( List s , long p , List d ) { return "lll" ; } public String lll ( List s , long p , int d ) { return "lli" ; } public String lll ( List s , long p ) { return "Listl" ; } public String ll ( long p , long d ) { return "ll" ; } } } 	0	['4', '4', '0', '7', '18', '6', '0', '7', '3', '1', '308', '0', '0', '0.947368421', '0.5', '0', '0', '75.5', '2', '1', '0']
package org . apache . velocity . test ; public interface TemplateTestBase { public final static String TMPL_FILE_EXT = "vm" ; public final static String CMP_FILE_EXT = "cmp" ; public final static String RESULT_FILE_EXT = "res" ; public final static String FILE_RESOURCE_LOADER_PATH = "../test/templates" ; public final static String TEST_CASE_PROPERTIES = FILE_RESOURCE_LOADER_PATH + "/templates.properties" ; public final static String RESULT_DIR = FILE_RESOURCE_LOADER_PATH + "/results" ; public final static String COMPARE_DIR = FILE_RESOURCE_LOADER_PATH + "/compare" ; } 	0	['0', '1', '0', '6', '0', '0', '6', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . velocity . test ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . LogSystem ; import junit . framework . TestCase ; public class ExternalLoggerTest extends TestCase implements LogSystem { private String logString = null ; private VelocityEngine ve = null ; public ExternalLoggerTest ( ) { super ( "LoggerTest" ) ; try { ve = new VelocityEngine ( ) ; ve . setProperty ( VelocityEngine . RUNTIME_LOG_LOGSYSTEM , this ) ; ve . init ( ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup LoggerTest : " + e ) ; System . exit ( 1 ) ; } } public void init ( RuntimeServices rs ) { } public static junit . framework . Test suite ( ) { return new ExternalLoggerTest ( ) ; } public void runTest ( ) { logString = null ; String testString = "This is a test." ; ve . warn ( testString ) ; if ( logString == null || ! logString . equals ( VelocityEngine . WARN_PREFIX + testString ) ) { fail ( "Didn't recieve log message." ) ; } } public void logVelocityMessage ( int level , String message ) { String out = "" ; switch ( level ) { case LogSystem . DEBUG_ID : out = VelocityEngine . DEBUG_PREFIX ; break ; case LogSystem . INFO_ID : out = VelocityEngine . INFO_PREFIX ; break ; case LogSystem . WARN_ID : out = VelocityEngine . WARN_PREFIX ; break ; case LogSystem . ERROR_ID : out = VelocityEngine . ERROR_PREFIX ; break ; default : out = VelocityEngine . UNKNOWN_PREFIX ; break ; } logString = out + message ; } } 	0	['5', '3', '0', '6', '18', '4', '0', '6', '5', '0.375', '105', '1', '1', '0.924528302', '0.35', '3', '3', '19.6', '3', '1.4', '0']
package org . apache . velocity . test ; import java . io . File ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . util . StringUtils ; import junit . framework . TestCase ; import org . apache . oro . text . perl . Perl5Util ; public class BaseTestCase extends TestCase { private Perl5Util perl = new Perl5Util ( ) ; public BaseTestCase ( String name ) { super ( name ) ; } protected static String getFileName ( String dir , String base , String ext ) { StringBuffer buf = new StringBuffer ( ) ; if ( dir != null ) { buf . append ( dir ) . append ( '/' ) ; } buf . append ( base ) . append ( '.' ) . append ( ext ) ; return buf . toString ( ) ; } protected static void assureResultsDirectoryExists ( String resultsDirectory ) { File dir = new File ( resultsDirectory ) ; if ( ! dir . exists ( ) ) { RuntimeSingleton . info ( "Template results directory does not exist" ) ; if ( dir . mkdirs ( ) ) { RuntimeSingleton . info ( "Created template results directory" ) ; } else { String errMsg = "Unable to create template results directory" ; RuntimeSingleton . warn ( errMsg ) ; fail ( errMsg ) ; } } } protected String normalizeNewlines ( String source ) { return perl . substitute ( "s/\r[\n]/\n/g" , source ) ; } protected boolean isMatch ( String resultsDir , String compareDir , String baseFileName , String resultExt , String compareExt ) throws Exception { String result = StringUtils . fileContentsToString ( getFileName ( resultsDir , baseFileName , resultExt ) ) ; String compare = StringUtils . fileContentsToString ( getFileName ( compareDir , baseFileName , compareExt ) ) ; return normalizeNewlines ( result ) . equals ( normalizeNewlines ( compare ) ) ; } protected static final String getTestCaseName ( String s ) { StringBuffer name = new StringBuffer ( ) ; name . append ( Character . toTitleCase ( s . charAt ( 0 ) ) ) ; name . append ( s . substring ( 1 , s . length ( ) ) . toLowerCase ( ) ) ; return name . toString ( ) ; } } 	0	['6', '3', '17', '22', '26', '13', '17', '5', '1', '0.6', '111', '1', '0', '0.907407407', '0.75', '0', '0', '17.33333333', '3', '1.3333', '0']
package org . apache . velocity . runtime . parser ; public class ParseException extends Exception { public ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( "" ) ; specialConstructor = true ; currentToken = currentTokenVal ; expectedTokenSequences = expectedTokenSequencesVal ; tokenImage = tokenImageVal ; } public ParseException ( ) { super ( ) ; specialConstructor = false ; } public ParseException ( String message ) { super ( message ) ; specialConstructor = false ; } protected boolean specialConstructor ; public Token currentToken ; public int [ ] [ ] expectedTokenSequences ; public String [ ] tokenImage ; public String getMessage ( ) { if ( ! specialConstructor ) { return super . getMessage ( ) ; } String expected = "" ; int maxSize = 0 ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected += tokenImage [ expectedTokenSequences [ i ] [ j ] ] + " " ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected += "..." ; } expected += eol + "    " ; } String retval = "Encountered \"" ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) retval += " " ; if ( tok . kind == 0 ) { retval += tokenImage [ 0 ] ; break ; } retval += add_escapes ( tok . image ) ; tok = tok . next ; } retval += "\" at line " + currentToken . next . beginLine + ", column " + currentToken . next . beginColumn ; retval += "." + eol ; if ( expectedTokenSequences . length == 1 ) { retval += "Was expecting:" + eol + "    " ; } else { retval += "Was expecting one of:" + eol + "    " ; } retval += expected ; return retval ; } protected String eol = System . getProperty ( "line.separator" , "\n" ) ; protected String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } } 	0	['5', '3', '1', '11', '18', '0', '10', '1', '4', '0.55', '387', '0.4', '1', '0.866666667', '0.4', '1', '1', '75.4', '14', '4.8', '0']
package org . apache . velocity . test ; public class AnakiaTestCase extends BaseTestCase { private static final String COMPARE_DIR = "../test/anakia/compare" ; private static final String RESULTS_DIR = "../test/anakia/results" ; private static final String FILE_EXT = ".html" ; public AnakiaTestCase ( ) { super ( "AnakiaTestCase" ) ; } public static junit . framework . Test suite ( ) { return new AnakiaTestCase ( ) ; } public void runTest ( ) { try { assureResultsDirectoryExists ( RESULTS_DIR ) ; if ( ! isMatch ( RESULTS_DIR , COMPARE_DIR , "index" , FILE_EXT , FILE_EXT ) ) { fail ( "Output is incorrect!" ) ; } else { System . out . println ( "Passed!" ) ; } } catch ( Exception e ) { } } } 	0	['3', '4', '0', '3', '8', '3', '0', '3', '3', '1.5', '33', '1', '0', '0.964285714', '0.666666667', '2', '3', '9', '2', '1', '0']
package org . apache . velocity . test ; import java . io . BufferedWriter ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . Vector ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . Template ; import org . apache . velocity . app . Velocity ; import org . apache . velocity . test . provider . TestProvider ; import org . apache . velocity . util . StringUtils ; import junit . framework . TestCase ; public class EncodingTestCase extends BaseTestCase implements TemplateTestBase { public EncodingTestCase ( ) { super ( "EncodingTestCase" ) ; try { Velocity . setProperty ( Velocity . FILE_RESOURCE_LOADER_PATH , FILE_RESOURCE_LOADER_PATH ) ; Velocity . setProperty ( Velocity . INPUT_ENCODING , "UTF-8" ) ; Velocity . init ( ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup EncodingTestCase!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } public static junit . framework . Test suite ( ) { return new EncodingTestCase ( ) ; } public void runTest ( ) { VelocityContext context = new VelocityContext ( ) ; try { assureResultsDirectoryExists ( RESULT_DIR ) ; Template template = Velocity . getTemplate ( getFileName ( null , "encodingtest" , TMPL_FILE_EXT ) , "UTF-8" ) ; FileOutputStream fos = new FileOutputStream ( getFileName ( RESULT_DIR , "encodingtest" , RESULT_FILE_EXT ) ) ; Writer writer = new BufferedWriter ( new OutputStreamWriter ( fos , "UTF-8" ) ) ; template . merge ( context , writer ) ; writer . flush ( ) ; writer . close ( ) ; if ( ! isMatch ( RESULT_DIR , COMPARE_DIR , "encodingtest" , RESULT_FILE_EXT , CMP_FILE_EXT ) ) { fail ( "Output 1 incorrect." ) ; } template = Velocity . getTemplate ( getFileName ( null , "encodingtest2" , TMPL_FILE_EXT ) , "UTF-8" ) ; fos = new FileOutputStream ( getFileName ( RESULT_DIR , "encodingtest2" , RESULT_FILE_EXT ) ) ; writer = new BufferedWriter ( new OutputStreamWriter ( fos , "UTF-8" ) ) ; template . merge ( context , writer ) ; writer . flush ( ) ; writer . close ( ) ; if ( ! isMatch ( RESULT_DIR , COMPARE_DIR , "encodingtest2" , RESULT_FILE_EXT , CMP_FILE_EXT ) ) { fail ( "Output 2 incorrect." ) ; } template = Velocity . getTemplate ( getFileName ( null , "encodingtest3" , TMPL_FILE_EXT ) , "GBK" ) ; fos = new FileOutputStream ( getFileName ( RESULT_DIR , "encodingtest3" , RESULT_FILE_EXT ) ) ; writer = new BufferedWriter ( new OutputStreamWriter ( fos , "GBK" ) ) ; template . merge ( context , writer ) ; writer . flush ( ) ; writer . close ( ) ; if ( ! isMatch ( RESULT_DIR , COMPARE_DIR , "encodingtest3" , RESULT_FILE_EXT , CMP_FILE_EXT ) ) { fail ( "Output 3 incorrect." ) ; } template = Velocity . getTemplate ( getFileName ( null , "encodingtest_KOI8-R" , TMPL_FILE_EXT ) , "KOI8-R" ) ; fos = new FileOutputStream ( getFileName ( RESULT_DIR , "encodingtest_KOI8-R" , RESULT_FILE_EXT ) ) ; writer = new BufferedWriter ( new OutputStreamWriter ( fos , "KOI8-R" ) ) ; template . merge ( context , writer ) ; writer . flush ( ) ; writer . close ( ) ; if ( ! isMatch ( RESULT_DIR , COMPARE_DIR , "encodingtest_KOI8-R" , RESULT_FILE_EXT , CMP_FILE_EXT ) ) { fail ( "Output 4 incorrect." ) ; } } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } } } 	0	['3', '4', '0', '8', '22', '3', '0', '8', '3', '2', '207', '0', '0', '0.964285714', '0.666666667', '2', '4', '68', '4', '1.6667', '0']
package org . apache . velocity . test ; import java . io . File ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . util . StringUtils ; import junit . framework . TestCase ; public class TexenClasspathTestCase extends BaseTestCase { private static final String RESULTS_DIR = "../test/texen-classpath/results" ; private static final String COMPARE_DIR = "../test/texen-classpath/compare" ; public TexenClasspathTestCase ( ) { super ( "TexenClasspathTestCase" ) ; } public static junit . framework . Test suite ( ) { return new TexenClasspathTestCase ( ) ; } protected void setUp ( ) { } public void runTest ( ) { try { assureResultsDirectoryExists ( RESULTS_DIR ) ; if ( ! isMatch ( RESULTS_DIR , COMPARE_DIR , "TurbineWeather" , "java" , "java" ) || ! isMatch ( RESULTS_DIR , COMPARE_DIR , "TurbineWeatherService" , "java" , "java" ) || ! isMatch ( RESULTS_DIR , COMPARE_DIR , "WeatherService" , "java" , "java" ) || ! isMatch ( RESULTS_DIR , COMPARE_DIR , "book" , "txt" , "txt" ) || ! isMatch ( RESULTS_DIR , COMPARE_DIR , "Test" , "txt" , "txt" ) ) { fail ( "Output is incorrect!" ) ; } } catch ( Exception e ) { } } } 	0	['4', '4', '0', '3', '8', '6', '0', '3', '3', '1.333333333', '62', '1', '0', '0.947368421', '0.75', '2', '4', '14', '5', '1.75', '0']
package org . apache . velocity . test ; import java . lang . ClassLoader ; import java . io . File ; import java . io . FileInputStream ; import java . io . StringWriter ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . runtime . log . LogSystem ; import org . apache . velocity . util . introspection . Introspector ; import junit . framework . TestCase ; public class ClassloaderChangeTest extends TestCase implements LogSystem { private VelocityEngine ve = null ; private boolean sawCacheDump = false ; private static String OUTPUT = "Hello From Foo" ; public ClassloaderChangeTest ( ) { super ( "ClassloaderChangeTest" ) ; try { ve = new VelocityEngine ( ) ; ve . setProperty ( VelocityEngine . RUNTIME_LOG_LOGSYSTEM , this ) ; ve . init ( ) ; } catch ( Exception e ) { System . err . println ( "Cannot setup ClassloaderChnageTest : " + e ) ; System . exit ( 1 ) ; } } public void init ( RuntimeServices rs ) { } public static junit . framework . Test suite ( ) { return new ClassloaderChangeTest ( ) ; } public void runTest ( ) { sawCacheDump = false ; try { VelocityContext vc = new VelocityContext ( ) ; Object foo = null ; TestClassloader cl = new TestClassloader ( ) ; Class fooclass = cl . loadClass ( "Foo" ) ; foo = fooclass . newInstance ( ) ; vc . put ( "foo" , foo ) ; StringWriter writer = new StringWriter ( ) ; ve . evaluate ( vc , writer , "test" , "$foo.doIt()" ) ; if ( ! writer . toString ( ) . equals ( OUTPUT ) ) { fail ( "Output from doIt() incorrect" ) ; } cl = new TestClassloader ( ) ; fooclass = cl . loadClass ( "Foo" ) ; foo = fooclass . newInstance ( ) ; vc . put ( "foo" , foo ) ; writer = new StringWriter ( ) ; ve . evaluate ( vc , writer , "test" , "$foo.doIt()" ) ; if ( ! writer . toString ( ) . equals ( OUTPUT ) ) { fail ( "Output from doIt() incorrect" ) ; } } catch ( Exception ee ) { System . out . println ( "ClassloaderChangeTest : " + ee ) ; } if ( ! sawCacheDump ) { fail ( "Didn't see introspector cache dump." ) ; } } public void logVelocityMessage ( int level , String message ) { if ( message . equals ( Introspector . CACHEDUMP_MSG ) ) { sawCacheDump = true ; } } } class TestClassloader extends ClassLoader { private final static String testclass = "../test/classloader/Foo.class" ; private Class fooClass = null ; public TestClassloader ( ) { try { File f = new File ( testclass ) ; byte [ ] barr = new byte [ ( int ) f . length ( ) ] ; FileInputStream fis = new FileInputStream ( f ) ; fis . read ( barr ) ; fis . close ( ) ; fooClass = defineClass ( "Foo" , barr , 0 , barr . length ) ; } catch ( Exception e ) { System . out . println ( "TestClassloader : exception : " + e ) ; } } public Class findClass ( String name ) { return fooClass ; } } 	0	['6', '3', '0', '10', '26', '7', '0', '10', '5', '0.6', '159', '1', '1', '0.924528302', '0.35', '3', '3', '25', '3', '1.1667', '0']
package org . apache . velocity . runtime . parser ; public interface CharStream { char readChar ( ) throws java . io . IOException ; int getColumn ( ) ; int getLine ( ) ; int getEndColumn ( ) ; int getEndLine ( ) ; int getBeginColumn ( ) ; int getBeginLine ( ) ; void backup ( int amount ) ; char BeginToken ( ) throws java . io . IOException ; String GetImage ( ) ; char [ ] GetSuffix ( int len ) ; void Done ( ) ; } 	0	['12', '1', '0', '3', '12', '66', '3', '0', '12', '2', '12', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
