package org . xml . sax ; public class SAXException extends Exception { public SAXException ( String message ) { super ( message ) ; this . exception = null ; } public SAXException ( Exception e ) { super ( ) ; this . exception = e ; } public SAXException ( String message , Exception e ) { super ( message ) ; this . exception = e ; } public String getMessage ( ) { String message = super . getMessage ( ) ; if ( message == null && exception != null ) { return exception . getMessage ( ) ; } else { return message ; } } public Exception getException ( ) { return exception ; } public String toString ( ) { if ( exception != null ) { return exception . toString ( ) ; } else { return super . toString ( ) ; } } private Exception exception ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . range . * ; public class RangeExceptionImpl extends RangeException { public RangeExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . xerces . parsers ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . apache . xerces . dom . TextImpl ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . apache . xerces . validators . schema . XUtil ; import org . apache . xerces . dom . DeferredDocumentImpl ; import org . apache . xerces . dom . DocumentImpl ; import org . apache . xerces . dom . DocumentTypeImpl ; import org . apache . xerces . dom . NodeImpl ; import org . apache . xerces . dom . EntityImpl ; import org . apache . xerces . dom . NotationImpl ; import org . apache . xerces . dom . ElementDefinitionImpl ; import org . apache . xerces . dom . AttrImpl ; import org . apache . xerces . dom . TextImpl ; import org . apache . xerces . dom . ElementImpl ; import org . apache . xerces . dom . EntityImpl ; import org . apache . xerces . dom . EntityReferenceImpl ; import org . w3c . dom . Attr ; import org . w3c . dom . Comment ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . Entity ; import org . w3c . dom . EntityReference ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; public class DOMParser extends XMLParser implements XMLDocumentHandler { public static final String DEFAULT_DOCUMENT_CLASS_NAME = "org.apache.xerces.dom.DocumentImpl" ; public static final String DEFAULT_DEFERRED_DOCUMENT_CLASS_NAME = "org.apache.xerces.dom.DeferredDocumentImpl" ; private static final boolean DEBUG_ATTLIST_DECL = false ; private static final String RECOGNIZED_FEATURES [ ] = { "http://apache.org/xml/features/dom/defer-node-expansion" , "http://apache.org/xml/features/dom/create-entity-ref-nodes" , "http://apache.org/xml/features/dom/include-ignorable-whitespace" , "http://apache.org/xml/features/domx/grammar-access" , } ; private static final String RECOGNIZED_PROPERTIES [ ] = { "http://apache.org/xml/properties/dom/document-class-name" , "http://apache.org/xml/properties/dom/current-element-node" , } ; protected Document fDocument ; protected DeferredDocumentImpl fDeferredDocumentImpl ; protected int fDocumentIndex ; protected int fDocumentTypeIndex ; protected int fCurrentNodeIndex ; protected DocumentImpl fDocumentImpl ; protected DocumentType fDocumentType ; protected Node fCurrentElementNode ; protected boolean fInDTD ; protected boolean fWithinElement ; protected boolean fInCDATA ; private boolean fGrammarAccess ; private String fDocumentClassName ; private boolean fDeferNodeExpansion ; private boolean fCreateEntityReferenceNodes ; private boolean fIncludeIgnorableWhitespace ; protected int fAmpIndex ; protected int fLtIndex ; protected int fGtIndex ; protected int fAposIndex ; protected int fQuotIndex ; private boolean fSeenRootElement ; private boolean fStringPoolInUse ; private XMLAttrList fAttrList ; public DOMParser ( ) { initHandlers ( false , this , this ) ; init ( ) ; try { setDocumentClassName ( DEFAULT_DOCUMENT_CLASS_NAME ) ; setCreateEntityReferenceNodes ( true ) ; setDeferNodeExpansion ( true ) ; setIncludeIgnorableWhitespace ( true ) ; } catch ( SAXException e ) { throw new RuntimeException ( "PAR001 Fatal error constructing DOMParser." ) ; } } public Document getDocument ( ) { if ( fDocumentImpl != null ) { fDocumentImpl . setErrorChecking ( true ) ; } return fDocument ; } public String [ ] getFeaturesRecognized ( ) { String superRecognized [ ] = super . getFeaturesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_FEATURES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } public String [ ] getPropertiesRecognized ( ) { String superRecognized [ ] = super . getPropertiesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_PROPERTIES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } public void reset ( ) throws Exception { if ( fStringPoolInUse ) { fStringPool = new StringPool ( ) ; fStringPoolInUse = false ; } super . reset ( ) ; init ( ) ; } public void resetOrCopy ( ) throws Exception { super . resetOrCopy ( ) ; init ( ) ; } protected void init ( ) { fDocument = null ; fDeferredDocumentImpl = null ; fDocumentIndex = - 1 ; fDocumentTypeIndex = - 1 ; fCurrentNodeIndex = - 1 ; fDocumentImpl = null ; fDocumentType = null ; fCurrentElementNode = null ; fInDTD = false ; fWithinElement = false ; fInCDATA = false ; fAmpIndex = fStringPool . addSymbol ( "amp" ) ; fLtIndex = fStringPool . addSymbol ( "lt" ) ; fGtIndex = fStringPool . addSymbol ( "gt" ) ; fAposIndex = fStringPool . addSymbol ( "apos" ) ; fQuotIndex = fStringPool . addSymbol ( "quot" ) ; fSeenRootElement = false ; fStringPoolInUse = false ; fAttrList = new XMLAttrList ( fStringPool ) ; } protected void setDeferNodeExpansion ( boolean deferNodeExpansion ) throws SAXNotRecognizedException , SAXNotSupportedException { fDeferNodeExpansion = deferNodeExpansion ; } protected boolean getDeferNodeExpansion ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fDeferNodeExpansion ; } protected void setCreateEntityReferenceNodes ( boolean create ) throws SAXNotRecognizedException , SAXNotSupportedException { fCreateEntityReferenceNodes = create ; } public boolean getCreateEntityReferenceNodes ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fCreateEntityReferenceNodes ; } public void setIncludeIgnorableWhitespace ( boolean include ) throws SAXNotRecognizedException , SAXNotSupportedException { fIncludeIgnorableWhitespace = include ; } public boolean getIncludeIgnorableWhitespace ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fIncludeIgnorableWhitespace ; } protected void setDocumentClassName ( String documentClassName ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( documentClassName == null ) { documentClassName = DEFAULT_DOCUMENT_CLASS_NAME ; } try { Class _class = Class . forName ( documentClassName ) ; if ( ! Document . class . isAssignableFrom ( _class ) ) { throw new IllegalArgumentException ( "PAR002 Class, \"" + documentClassName + "\", is not of type org.w3c.dom.Document." + "\n" + documentClassName ) ; } } catch ( ClassNotFoundException e ) { throw new IllegalArgumentException ( "PAR003 Class, \"" + documentClassName + "\", not found." + "\n" + documentClassName ) ; } fDocumentClassName = documentClassName ; if ( ! documentClassName . equals ( DEFAULT_DOCUMENT_CLASS_NAME ) ) { setDeferNodeExpansion ( false ) ; } } protected String getDocumentClassName ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fDocumentClassName ; } protected Element getCurrentElementNode ( ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fCurrentElementNode != null && fCurrentElementNode . getNodeType ( ) == Node . ELEMENT_NODE ) { return ( Element ) fCurrentElementNode ; } return null ; } public void setFeature ( String featureId , boolean state ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { } else if ( featureId . startsWith ( XERCES_FEATURES_PREFIX ) ) { String feature = featureId . substring ( XERCES_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "dom/defer-node-expansion" ) ) { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR004 Cannot setFeature(" + featureId + "): parse is in progress." + "\n" + featureId ) ; } setDeferNodeExpansion ( state ) ; return ; } if ( feature . equals ( "dom/create-entity-ref-nodes" ) ) { setCreateEntityReferenceNodes ( state ) ; return ; } if ( feature . equals ( "dom/include-ignorable-whitespace" ) ) { setIncludeIgnorableWhitespace ( state ) ; return ; } if ( feature . equals ( "domx/grammar-access" ) ) { fGrammarAccess = state ; return ; } } super . setFeature ( featureId , state ) ; } public boolean getFeature ( String featureId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { } else if ( featureId . startsWith ( XERCES_FEATURES_PREFIX ) ) { String feature = featureId . substring ( XERCES_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "dom/defer-node-expansion" ) ) { return getDeferNodeExpansion ( ) ; } else if ( feature . equals ( "dom/create-entity-ref-nodes" ) ) { return getCreateEntityReferenceNodes ( ) ; } if ( feature . equals ( "dom/include-ignorable-whitespace" ) ) { return getIncludeIgnorableWhitespace ( ) ; } if ( feature . equals ( "domx/grammar-access" ) ) { return fGrammarAccess ; } } return super . getFeature ( featureId ) ; } public void setProperty ( String propertyId , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( XERCES_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( XERCES_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "dom/current-element-node" ) ) { throw new SAXNotSupportedException ( "PAR005 Property, \"" + propertyId + "\" is read-only.\n" + propertyId ) ; } else if ( property . equals ( "dom/document-class-name" ) ) { if ( value != null && ! ( value instanceof String ) ) { throw new SAXNotSupportedException ( "PAR006 Property value must be of type java.lang.String." ) ; } setDocumentClassName ( ( String ) value ) ; return ; } } super . setProperty ( propertyId , value ) ; } public Object getProperty ( String propertyId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( XERCES_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( XERCES_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "dom/current-element-node" ) ) { boolean throwException = false ; try { throwException = getFeature ( XERCES_FEATURES_PREFIX + "dom/defer-node-expansion" ) ; } catch ( SAXNotSupportedException e ) { } catch ( SAXNotRecognizedException e ) { } if ( throwException ) { throw new SAXNotSupportedException ( "PAR007 Current element node cannot be queried when node expansion is deferred." ) ; } return getCurrentElementNode ( ) ; } else if ( property . equals ( "dom/document-class-name" ) ) { return getDocumentClassName ( ) ; } } return super . getProperty ( propertyId ) ; } public void startDocument ( ) { String documentClassName = null ; try { documentClassName = getDocumentClassName ( ) ; } catch ( SAXException e ) { throw new RuntimeException ( "PAR008 Fatal error getting document factory." ) ; } boolean deferNodeExpansion = true ; try { deferNodeExpansion = getDeferNodeExpansion ( ) ; } catch ( SAXException e ) { throw new RuntimeException ( "PAR009 Fatal error reading expansion mode." ) ; } try { boolean isDocumentImpl = fDocumentClassName . equals ( DEFAULT_DOCUMENT_CLASS_NAME ) ; boolean isDeferredImpl = fDocumentClassName . equals ( DEFAULT_DEFERRED_DOCUMENT_CLASS_NAME ) ; if ( deferNodeExpansion && ( isDocumentImpl || isDeferredImpl ) ) { boolean nsEnabled = false ; try { nsEnabled = getNamespaces ( ) ; } catch ( SAXException s ) { } fDeferredDocumentImpl = new DeferredDocumentImpl ( fStringPool , nsEnabled , fGrammarAccess ) ; fStringPoolInUse = true ; fDocument = fDeferredDocumentImpl ; fDocumentIndex = fDeferredDocumentImpl . createDocument ( ) ; fCurrentNodeIndex = fDocumentIndex ; } else { Class docClass = Class . forName ( documentClassName ) ; Class defaultDocClass = Class . forName ( DEFAULT_DOCUMENT_CLASS_NAME ) ; if ( isDocumentImpl ) { fDocument = new DocumentImpl ( fGrammarAccess ) ; } else { try { Class documentClass = Class . forName ( documentClassName ) ; fDocument = ( Document ) documentClass . newInstance ( ) ; } catch ( Exception e ) { } } if ( docClass . isAssignableFrom ( defaultDocClass ) ) { fDocumentImpl = ( DocumentImpl ) fDocument ; fDocumentImpl . setErrorChecking ( false ) ; } fCurrentElementNode = fDocument ; } } catch ( ClassNotFoundException e ) { throw new RuntimeException ( documentClassName ) ; } } public void endDocument ( ) throws Exception { } public void xmlDecl ( int versionIndex , int encodingIndex , int standaloneIndex ) throws Exception { fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; fStringPool . releaseString ( standaloneIndex ) ; } public void textDecl ( int versionIndex , int encodingIndex ) throws Exception { fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { } public void endNamespaceDeclScope ( int prefix ) throws Exception { } public void startElement ( QName elementQName , XMLAttrList xmlAttrList , int attrListIndex ) throws Exception { if ( fDeferredDocumentImpl != null ) { int element = fDeferredDocumentImpl . createElement ( elementQName . rawname , elementQName . uri , xmlAttrList , attrListIndex ) ; fDeferredDocumentImpl . appendChild ( fCurrentNodeIndex , element ) ; fCurrentNodeIndex = element ; fWithinElement = true ; int index = xmlAttrList . getFirstAttr ( attrListIndex ) ; while ( index != - 1 ) { if ( xmlAttrList . getAttType ( index ) == fStringPool . addSymbol ( "ID" ) ) { int nameIndex = xmlAttrList . getAttValue ( index ) ; fDeferredDocumentImpl . putIdentifier ( nameIndex , element ) ; } index = xmlAttrList . getNextAttr ( index ) ; } if ( ! fSeenRootElement ) { fSeenRootElement = true ; if ( fDocumentTypeIndex == - 1 ) { fDocumentTypeIndex = fDeferredDocumentImpl . createDocumentType ( elementQName . rawname , - 1 , - 1 ) ; fDeferredDocumentImpl . appendChild ( 0 , fDocumentTypeIndex ) ; } if ( fGrammarAccess ) { int size = fGrammarResolver . size ( ) ; if ( size > 0 ) { Enumeration schemas = fGrammarResolver . nameSpaceKeys ( ) ; Document schemaDocument = fGrammarResolver . getGrammar ( ( String ) schemas . nextElement ( ) ) . getGrammarDocument ( ) ; if ( schemaDocument != null ) { Element schema = schemaDocument . getDocumentElement ( ) ; copyInto ( schema , fDocumentTypeIndex ) ; } } } } } else { boolean nsEnabled = false ; try { nsEnabled = getNamespaces ( ) ; } catch ( SAXException s ) { } String elementName = fStringPool . toString ( elementQName . rawname ) ; Element e ; if ( nsEnabled ) { e = fDocument . createElementNS ( fStringPool . toString ( elementQName . uri ) , fStringPool . toString ( elementQName . localpart ) ) ; } else { e = fDocument . createElement ( elementName ) ; } int attrHandle = xmlAttrList . getFirstAttr ( attrListIndex ) ; while ( attrHandle != - 1 ) { int attName = xmlAttrList . getAttrName ( attrHandle ) ; String attrName = fStringPool . toString ( attName ) ; String attrValue = fStringPool . toString ( xmlAttrList . getAttValue ( attrHandle ) ) ; if ( nsEnabled ) { int nsURIIndex = xmlAttrList . getAttrURI ( attrHandle ) ; String namespaceURI = fStringPool . toString ( nsURIIndex ) ; int prefixIndex = xmlAttrList . getAttrPrefix ( attrHandle ) ; String prefix = fStringPool . toString ( prefixIndex ) ; if ( namespaceURI == null ) { if ( prefix != null ) { if ( prefix . equals ( "xmlns" ) ) { namespaceURI = "http://www.w3.org/2000/xmlns/" ; } } else if ( attrName . equals ( "xmlns" ) ) { namespaceURI = "http://www.w3.org/2000/xmlns/" ; } } e . setAttributeNS ( namespaceURI , attrName , attrValue ) ; } else { e . setAttribute ( attrName , attrValue ) ; } if ( ! xmlAttrList . isSpecified ( attrHandle ) ) { ( ( AttrImpl ) e . getAttributeNode ( attrName ) ) . setSpecified ( false ) ; } attrHandle = xmlAttrList . getNextAttr ( attrHandle ) ; } fCurrentElementNode . appendChild ( e ) ; fCurrentElementNode = e ; fWithinElement = true ; if ( fDocumentImpl != null ) { int index = xmlAttrList . getFirstAttr ( attrListIndex ) ; while ( index != - 1 ) { if ( xmlAttrList . getAttType ( index ) == fStringPool . addSymbol ( "ID" ) ) { String name = fStringPool . toString ( xmlAttrList . getAttValue ( index ) ) ; fDocumentImpl . putIdentifier ( name , e ) ; } index = xmlAttrList . getNextAttr ( index ) ; } } xmlAttrList . releaseAttrList ( attrListIndex ) ; if ( ! fSeenRootElement ) { fSeenRootElement = true ; if ( fDocumentImpl != null && fGrammarAccess && fGrammarResolver . size ( ) > 0 ) { if ( fDocumentType == null ) { String rootName = elementName ; String systemId = "" ; String publicId = "" ; fDocumentType = fDocumentImpl . createDocumentType ( rootName , publicId , systemId ) ; fDocument . appendChild ( fDocumentType ) ; } Enumeration schemas = fGrammarResolver . nameSpaceKeys ( ) ; Document schemaDocument = fGrammarResolver . getGrammar ( ( String ) schemas . nextElement ( ) ) . getGrammarDocument ( ) ; if ( schemaDocument != null ) { Element schema = schemaDocument . getDocumentElement ( ) ; XUtil . copyInto ( schema , fDocumentType ) ; } } } } } public void endElement ( QName elementQName ) throws Exception { if ( fDeferredDocumentImpl != null ) { fCurrentNodeIndex = fDeferredDocumentImpl . getParentNode ( fCurrentNodeIndex , false ) ; fWithinElement = false ; } else { fCurrentElementNode = fCurrentElementNode . getParentNode ( ) ; fWithinElement = false ; } } public void characters ( int dataIndex ) throws Exception { if ( fDeferredDocumentImpl != null ) { int text ; if ( fInCDATA ) { text = fDeferredDocumentImpl . createCDATASection ( dataIndex , false ) ; } else { text = fDeferredDocumentImpl . createTextNode ( dataIndex , false ) ; } fDeferredDocumentImpl . appendChild ( fCurrentNodeIndex , text ) ; } else { Text text ; if ( fInCDATA ) { text = fDocument . createCDATASection ( fStringPool . orphanString ( dataIndex ) ) ; } else { if ( fWithinElement && fCurrentElementNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Node lastChild = fCurrentElementNode . getLastChild ( ) ; if ( lastChild != null && lastChild . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) lastChild ) . appendData ( fStringPool . orphanString ( dataIndex ) ) ; return ; } } text = fDocument . createTextNode ( fStringPool . orphanString ( dataIndex ) ) ; } fCurrentElementNode . appendChild ( text ) ; } } public void ignorableWhitespace ( int dataIndex ) throws Exception { if ( ! fIncludeIgnorableWhitespace ) { fStringPool . orphanString ( dataIndex ) ; return ; } if ( fDeferredDocumentImpl != null ) { int text ; if ( fInCDATA ) { text = fDeferredDocumentImpl . createCDATASection ( dataIndex , true ) ; } else { text = fDeferredDocumentImpl . createTextNode ( dataIndex , true ) ; } fDeferredDocumentImpl . appendChild ( fCurrentNodeIndex , text ) ; } else { Text text ; if ( fInCDATA ) { text = fDocument . createCDATASection ( fStringPool . orphanString ( dataIndex ) ) ; } else { if ( fWithinElement && fCurrentElementNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Node lastChild = fCurrentElementNode . getLastChild ( ) ; if ( lastChild != null && lastChild . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) lastChild ) . appendData ( fStringPool . orphanString ( dataIndex ) ) ; return ; } } text = fDocument . createTextNode ( fStringPool . orphanString ( dataIndex ) ) ; } if ( fDocumentImpl != null ) { ( ( TextImpl ) text ) . setIgnorableWhitespace ( true ) ; } fCurrentElementNode . appendChild ( text ) ; } } public void processingInstruction ( int targetIndex , int dataIndex ) throws Exception { if ( fDeferredDocumentImpl != null ) { int pi = fDeferredDocumentImpl . createProcessingInstruction ( targetIndex , dataIndex ) ; fDeferredDocumentImpl . appendChild ( fCurrentNodeIndex , pi ) ; } else { String target = fStringPool . orphanString ( targetIndex ) ; String data = fStringPool . orphanString ( dataIndex ) ; ProcessingInstruction pi = fDocument . createProcessingInstruction ( target , data ) ; fCurrentElementNode . appendChild ( pi ) ; } } public void comment ( int dataIndex ) throws Exception { if ( fInDTD && ! fGrammarAccess ) { fStringPool . orphanString ( dataIndex ) ; } else { if ( fDeferredDocumentImpl != null ) { int comment = fDeferredDocumentImpl . createComment ( dataIndex ) ; fDeferredDocumentImpl . appendChild ( fCurrentNodeIndex , comment ) ; } else { Comment comment = fDocument . createComment ( fStringPool . orphanString ( dataIndex ) ) ; fCurrentElementNode . appendChild ( comment ) ; } } } public void characters ( char ch [ ] , int start , int length ) throws Exception { } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws Exception { } public void startCDATA ( ) throws Exception { fInCDATA = true ; } public void endCDATA ( ) throws Exception { fInCDATA = false ; } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( ! fCreateEntityReferenceNodes ) { return ; } if ( entityName == fAmpIndex || entityName == fGtIndex || entityName == fLtIndex || entityName == fAposIndex || entityName == fQuotIndex ) { return ; } if ( entityContext != XMLEntityHandler . ENTITYREF_IN_CONTENT ) { return ; } if ( fDeferredDocumentImpl != null ) { int entityRefIndex = fDeferredDocumentImpl . createEntityReference ( entityName ) ; fDeferredDocumentImpl . appendChild ( fCurrentNodeIndex , entityRefIndex ) ; fCurrentNodeIndex = entityRefIndex ; } else { EntityReference er = fDocument . createEntityReference ( fStringPool . toString ( entityName ) ) ; fCurrentElementNode . appendChild ( er ) ; fCurrentElementNode = er ; try { EntityReferenceImpl xer = ( EntityReferenceImpl ) er ; xer . setReadOnly ( false , false ) ; } catch ( Exception e ) { } } } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( ! fCreateEntityReferenceNodes ) { return ; } if ( entityName == fAmpIndex || entityName == fGtIndex || entityName == fLtIndex || entityName == fAposIndex || entityName == fQuotIndex ) { return ; } if ( entityContext != XMLEntityHandler . ENTITYREF_IN_CONTENT ) { return ; } if ( fDeferredDocumentImpl != null ) { String name = fStringPool . toString ( entityName ) ; int erChild = fCurrentNodeIndex ; fCurrentNodeIndex = fDeferredDocumentImpl . getParentNode ( erChild , false ) ; if ( fDeferredDocumentImpl . getNodeType ( erChild , false ) != Node . ENTITY_REFERENCE_NODE ) return ; erChild = fDeferredDocumentImpl . getLastChild ( erChild , false ) ; if ( fDocumentTypeIndex != - 1 ) { int entityDecl = fDeferredDocumentImpl . getLastChild ( fDocumentTypeIndex , false ) ; while ( entityDecl != - 1 ) { if ( fDeferredDocumentImpl . getNodeType ( entityDecl , false ) == Node . ENTITY_NODE && fDeferredDocumentImpl . getNodeNameString ( entityDecl , false ) . equals ( name ) ) { break ; } entityDecl = fDeferredDocumentImpl . getPrevSibling ( entityDecl , false ) ; } if ( entityDecl != - 1 && fDeferredDocumentImpl . getLastChild ( entityDecl , false ) == - 1 ) { fDeferredDocumentImpl . setAsLastChild ( entityDecl , erChild ) ; } } } else { Node erNode = fCurrentElementNode ; fCurrentElementNode = erNode . getParentNode ( ) ; try { EntityReferenceImpl xer = ( EntityReferenceImpl ) erNode ; xer . setReadOnly ( false , false ) ; if ( fDocumentImpl != null ) { NamedNodeMap entities = fDocumentType . getEntities ( ) ; String name = fStringPool . toString ( entityName ) ; Node entityNode = entities . getNamedItem ( name ) ; if ( entityNode == null || entityNode . hasChildNodes ( ) ) { return ; } EntityImpl entity = ( EntityImpl ) entityNode ; entity . setReadOnly ( false , false ) ; for ( Node child = erNode . getFirstChild ( ) ; child != null ; child = child . getNextSibling ( ) ) { Node childClone = child . cloneNode ( true ) ; entity . appendChild ( childClone ) ; } entity . setReadOnly ( true , true ) ; } } catch ( Exception e ) { } } } public void startDTD ( QName rootElement , int publicId , int systemId ) throws Exception { fInDTD = true ; if ( fDocumentImpl != null ) { String rootElementName = fStringPool . toString ( rootElement . rawname ) ; String publicString = fStringPool . toString ( publicId ) ; String systemString = fStringPool . toString ( systemId ) ; fDocumentType = fDocumentImpl . createDocumentType ( rootElementName , publicString , systemString ) ; fDocumentImpl . appendChild ( fDocumentType ) ; if ( fGrammarAccess ) { Element schema = fDocument . createElement ( "schema" ) ; schema . setAttribute ( "xmlns" , "http://www.w3.org/1999/XMLSchema" ) ; ( ( AttrImpl ) schema . getAttributeNode ( "xmlns" ) ) . setSpecified ( false ) ; schema . setAttribute ( "finalDefault" , "" ) ; ( ( AttrImpl ) schema . getAttributeNode ( "finalDefault" ) ) . setSpecified ( false ) ; schema . setAttribute ( "exactDefault" , "" ) ; ( ( AttrImpl ) schema . getAttributeNode ( "exactDefault" ) ) . setSpecified ( false ) ; fDocumentType . appendChild ( schema ) ; fCurrentElementNode = schema ; } } else if ( fDeferredDocumentImpl != null ) { fDocumentTypeIndex = fDeferredDocumentImpl . createDocumentType ( rootElement . rawname , publicId , systemId ) ; fDeferredDocumentImpl . appendChild ( fDocumentIndex , fDocumentTypeIndex ) ; if ( fGrammarAccess ) { int handle = fAttrList . startAttrList ( ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "xmlns" ) , fStringPool . addString ( "http://www.w3.org/1999/XMLSchema" ) , fStringPool . addSymbol ( "CDATA" ) , false , false ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "finalDefault" ) , fStringPool . addString ( "" ) , fStringPool . addSymbol ( "CDATA" ) , false , false ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "exactDefault" ) , fStringPool . addString ( "" ) , fStringPool . addSymbol ( "CDATA" ) , false , false ) ; fAttrList . endAttrList ( ) ; int schemaIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "schema" ) , fAttrList , handle ) ; fDeferredDocumentImpl . appendChild ( fDocumentTypeIndex , schemaIndex ) ; fCurrentNodeIndex = schemaIndex ; } } } public void internalSubset ( int internalSubset ) { if ( fDocumentImpl != null && fDocumentType != null ) { ( ( DocumentTypeImpl ) fDocumentType ) . setInternalSubset ( fStringPool . toString ( internalSubset ) ) ; } else if ( fDeferredDocumentImpl != null ) { fDeferredDocumentImpl . setInternalSubset ( fDocumentTypeIndex , internalSubset ) ; } } public void endDTD ( ) throws Exception { fInDTD = false ; if ( fGrammarAccess ) { if ( fDocumentImpl != null ) { fCurrentElementNode = fDocumentImpl ; } else if ( fDeferredDocumentImpl != null ) { fCurrentNodeIndex = 0 ; } } } public void elementDecl ( QName elementDecl , int contentSpecType , int contentSpecIndex , XMLContentSpec . Provider contentSpecProvider ) throws Exception { if ( DEBUG_ATTLIST_DECL ) { String contentModel = XMLContentSpec . toString ( contentSpecProvider , fStringPool , contentSpecIndex ) ; System . out . println ( "elementDecl(" + fStringPool . toString ( elementDecl . rawname ) + ", " + contentModel + ")" ) ; } if ( fGrammarAccess ) { if ( fDeferredDocumentImpl != null ) { int schemaIndex = getLastChildElement ( fDocumentTypeIndex , "schema" ) ; String elementName = fStringPool . toString ( elementDecl . rawname ) ; int elementIndex = getLastChildElement ( schemaIndex , "element" , "name" , elementName ) ; if ( elementIndex == - 1 ) { int handle = fAttrList . startAttrList ( ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "name" ) , fStringPool . addString ( elementName ) , fStringPool . addSymbol ( "NMTOKEN" ) , true , false ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "minOccurs" ) , fStringPool . addString ( "1" ) , fStringPool . addSymbol ( "NMTOKEN" ) , false , false ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "nullable" ) , fStringPool . addString ( "false" ) , fStringPool . addSymbol ( "ENUMERATION" ) , false , false ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "abstract" ) , fStringPool . addString ( "false" ) , fStringPool . addSymbol ( "ENUMERATION" ) , false , false ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "final" ) , fStringPool . addString ( "false" ) , fStringPool . addSymbol ( "ENUMERATION" ) , false , false ) ; fAttrList . endAttrList ( ) ; elementIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "element" ) , fAttrList , handle ) ; fDeferredDocumentImpl . appendChild ( schemaIndex , elementIndex ) ; } int typeIndex = getLastChildElement ( elementIndex , "complexType" ) ; if ( typeIndex == - 1 && contentSpecType != XMLElementDecl . TYPE_MIXED ) { typeIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "complexType" ) , null , - 1 ) ; fDeferredDocumentImpl . insertBefore ( elementIndex , typeIndex , getFirstChildElement ( elementIndex ) ) ; } switch ( contentSpecType ) { case XMLElementDecl . TYPE_EMPTY : { int attributeIndex = fDeferredDocumentImpl . createAttribute ( fStringPool . addSymbol ( "content" ) , fStringPool . addString ( "empty" ) , true ) ; fDeferredDocumentImpl . setAttributeNode ( typeIndex , attributeIndex ) ; break ; } case XMLElementDecl . TYPE_ANY : { int anyIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "any" ) , null , - 1 ) ; fDeferredDocumentImpl . insertBefore ( typeIndex , anyIndex , getFirstChildElement ( typeIndex ) ) ; break ; } case XMLElementDecl . TYPE_MIXED : { XMLContentSpec contentSpec = new XMLContentSpec ( ) ; contentSpecProvider . getContentSpec ( contentSpecIndex , contentSpec ) ; contentSpecIndex = contentSpec . value ; if ( contentSpecIndex == - 1 ) { int attributeIndex = fDeferredDocumentImpl . createAttribute ( fStringPool . addSymbol ( "type" ) , fStringPool . addString ( "string" ) , true ) ; fDeferredDocumentImpl . setAttributeNode ( elementIndex , attributeIndex ) ; } else { if ( typeIndex == - 1 ) { typeIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "complexType" ) , null , - 1 ) ; fDeferredDocumentImpl . insertBefore ( elementIndex , typeIndex , getFirstChildElement ( elementIndex ) ) ; } int attributeIndex = fDeferredDocumentImpl . createAttribute ( fStringPool . addSymbol ( "content" ) , fStringPool . addString ( "mixed" ) , true ) ; fDeferredDocumentImpl . setAttributeNode ( typeIndex , attributeIndex ) ; int handle = fAttrList . startAttrList ( ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "minOccurs" ) , fStringPool . addString ( "0" ) , fStringPool . addSymbol ( "NMTOKEN" ) , true , false ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "maxOccurs" ) , fStringPool . addString ( "unbounded" ) , fStringPool . addSymbol ( "CDATA" ) , true , false ) ; fAttrList . endAttrList ( ) ; int choiceIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "choice" ) , fAttrList , handle ) ; fDeferredDocumentImpl . appendChild ( typeIndex , choiceIndex ) ; while ( contentSpecIndex != - 1 ) { contentSpecProvider . getContentSpec ( contentSpecIndex , contentSpec ) ; int type = contentSpec . type ; int left = contentSpec . value ; int right = contentSpec . otherValue ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { break ; } contentSpecProvider . getContentSpec ( right , contentSpec ) ; handle = fAttrList . startAttrList ( ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "ref" ) , fStringPool . addString ( fStringPool . toString ( contentSpec . value ) ) , fStringPool . addSymbol ( "NMTOKEN" ) , true , false ) ; fAttrList . endAttrList ( ) ; int rightIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "element" ) , fAttrList , handle ) ; int refIndex = getFirstChildElement ( choiceIndex ) ; fDeferredDocumentImpl . insertBefore ( choiceIndex , rightIndex , refIndex ) ; contentSpecIndex = left ; } } break ; } case XMLElementDecl . TYPE_CHILDREN : { int attributeIndex = fDeferredDocumentImpl . createAttribute ( fStringPool . addSymbol ( "content" ) , fStringPool . addString ( "elementOnly" ) , true ) ; fDeferredDocumentImpl . setAttributeNode ( typeIndex , attributeIndex ) ; int children = createChildren ( contentSpecProvider , contentSpecIndex , new XMLContentSpec ( ) , fDeferredDocumentImpl , - 1 ) ; fDeferredDocumentImpl . insertBefore ( typeIndex , children , getFirstChildElement ( typeIndex ) ) ; break ; } } } else if ( fDocumentImpl != null ) { Element schema = XUtil . getLastChildElement ( fDocumentType , "schema" ) ; String elementName = fStringPool . toString ( elementDecl . rawname ) ; Element element = XUtil . getLastChildElement ( schema , "element" , "name" , elementName ) ; if ( element == null ) { element = fDocumentImpl . createElement ( "element" ) ; element . setAttribute ( "name" , elementName ) ; element . setAttribute ( "minOccurs" , "1" ) ; ( ( AttrImpl ) element . getAttributeNode ( "minOccurs" ) ) . setSpecified ( false ) ; element . setAttribute ( "nullable" , "false" ) ; ( ( AttrImpl ) element . getAttributeNode ( "nullable" ) ) . setSpecified ( false ) ; element . setAttribute ( "abstract" , "false" ) ; ( ( AttrImpl ) element . getAttributeNode ( "abstract" ) ) . setSpecified ( false ) ; element . setAttribute ( "final" , "false" ) ; ( ( AttrImpl ) element . getAttributeNode ( "final" ) ) . setSpecified ( false ) ; schema . appendChild ( element ) ; } Element type = XUtil . getLastChildElement ( element , "complexType" ) ; if ( type == null && contentSpecType != XMLElementDecl . TYPE_MIXED ) { type = fDocumentImpl . createElement ( "complexType" ) ; element . insertBefore ( type , XUtil . getFirstChildElement ( element ) ) ; } switch ( contentSpecType ) { case XMLElementDecl . TYPE_EMPTY : { type . setAttribute ( "content" , "empty" ) ; break ; } case XMLElementDecl . TYPE_ANY : { Element any = fDocumentImpl . createElement ( "any" ) ; type . insertBefore ( any , XUtil . getFirstChildElement ( type ) ) ; break ; } case XMLElementDecl . TYPE_MIXED : { XMLContentSpec contentSpec = new XMLContentSpec ( ) ; contentSpecProvider . getContentSpec ( contentSpecIndex , contentSpec ) ; contentSpecIndex = contentSpec . value ; if ( contentSpecIndex == - 1 ) { element . setAttribute ( "type" , "string" ) ; } else { if ( type == null ) { type = fDocumentImpl . createElement ( "complexType" ) ; element . insertBefore ( type , XUtil . getFirstChildElement ( element ) ) ; } type . setAttribute ( "content" , "mixed" ) ; Element choice = fDocumentImpl . createElement ( "choice" ) ; choice . setAttribute ( "minOccurs" , "0" ) ; choice . setAttribute ( "maxOccurs" , "unbounded" ) ; type . appendChild ( choice ) ; while ( contentSpecIndex != - 1 ) { contentSpecProvider . getContentSpec ( contentSpecIndex , contentSpec ) ; int cstype = contentSpec . type ; int csleft = contentSpec . value ; int csright = contentSpec . otherValue ; if ( cstype == XMLContentSpec . CONTENTSPECNODE_LEAF ) { break ; } contentSpecProvider . getContentSpec ( csright , contentSpec ) ; Element right = fDocumentImpl . createElement ( "element" ) ; right . setAttribute ( "ref" , fStringPool . toString ( contentSpec . value ) ) ; Element ref = XUtil . getFirstChildElement ( choice ) ; choice . insertBefore ( right , ref ) ; contentSpecIndex = csleft ; } } break ; } case XMLElementDecl . TYPE_CHILDREN : { type . setAttribute ( "content" , "elementOnly" ) ; Element children = createChildren ( contentSpecProvider , contentSpecIndex , new XMLContentSpec ( ) , fDocumentImpl , null ) ; type . insertBefore ( children , XUtil . getFirstChildElement ( type ) ) ; break ; } } } } } public void attlistDecl ( QName elementDecl , QName attributeDecl , int attType , boolean attList , String enumString , int attDefaultType , int attDefaultValue ) throws Exception { if ( DEBUG_ATTLIST_DECL ) { System . out . println ( "attlistDecl(" + fStringPool . toString ( elementDecl . rawname ) + ", " + fStringPool . toString ( attributeDecl . rawname ) + ", " + fStringPool . toString ( attType ) + ", " + enumString + ", " + fStringPool . toString ( attDefaultType ) + ", " + fStringPool . toString ( attDefaultValue ) + ")" ) ; } if ( fDeferredDocumentImpl != null ) { if ( attDefaultValue != - 1 ) { if ( DEBUG_ATTLIST_DECL ) { System . out . println ( "  adding default attribute value: " + fStringPool . toString ( attDefaultValue ) ) ; } int elementDefIndex = fDeferredDocumentImpl . lookupElementDefinition ( elementDecl . rawname ) ; if ( elementDefIndex == - 1 ) { elementDefIndex = fDeferredDocumentImpl . createElementDefinition ( elementDecl . rawname ) ; fDeferredDocumentImpl . appendChild ( fDocumentTypeIndex , elementDefIndex ) ; } int attrIndex = fDeferredDocumentImpl . createAttribute ( attributeDecl . rawname , attributeDecl . uri , attDefaultValue , false ) ; fDeferredDocumentImpl . appendChild ( elementDefIndex , attrIndex ) ; } if ( fGrammarAccess ) { int schemaIndex = getLastChildElement ( fDocumentTypeIndex , "schema" ) ; String elementName = fStringPool . toString ( elementDecl . rawname ) ; int elementIndex = getLastChildElement ( schemaIndex , "element" , "name" , elementName ) ; if ( elementIndex == - 1 ) { int handle = fAttrList . startAttrList ( ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "name" ) , fStringPool . addString ( elementName ) , fStringPool . addSymbol ( "NMTOKEN" ) , true , false ) ; fAttrList . endAttrList ( ) ; elementIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "element" ) , fAttrList , handle ) ; fDeferredDocumentImpl . appendChild ( schemaIndex , elementIndex ) ; } int typeIndex = getLastChildElement ( elementIndex , "complexType" ) ; if ( typeIndex == - 1 ) { typeIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "complexType" ) , null , - 1 ) ; fDeferredDocumentImpl . insertBefore ( elementIndex , typeIndex , getLastChildElement ( elementIndex ) ) ; } String attributeName = fStringPool . toString ( attributeDecl . rawname ) ; int attributeIndex = getLastChildElement ( elementIndex , "attribute" , "name" , attributeName ) ; if ( attributeIndex == - 1 ) { int handle = fAttrList . startAttrList ( ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "name" ) , fStringPool . addString ( attributeName ) , fStringPool . addSymbol ( "NMTOKEN" ) , true , false ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "maxOccurs" ) , fStringPool . addString ( "1" ) , fStringPool . addSymbol ( "CDATA" ) , false , false ) ; fAttrList . endAttrList ( ) ; attributeIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "attribute" ) , fAttrList , handle ) ; fDeferredDocumentImpl . appendChild ( typeIndex , attributeIndex ) ; if ( attType == XMLAttributeDecl . TYPE_ENUMERATION ) { handle = fAttrList . startAttrList ( ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "base" ) , fStringPool . addString ( "NMTOKEN" ) , fStringPool . addSymbol ( "NMTOKEN" ) , true , false ) ; fAttrList . endAttrList ( ) ; int simpleTypeIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "simpleType" ) , fAttrList , handle ) ; fDeferredDocumentImpl . appendChild ( attributeIndex , simpleTypeIndex ) ; String tokenizerString = enumString . substring ( 1 , enumString . length ( ) - 1 ) ; StringTokenizer tokenizer = new StringTokenizer ( tokenizerString , "|" ) ; while ( tokenizer . hasMoreTokens ( ) ) { handle = fAttrList . startAttrList ( ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "value" ) , fStringPool . addString ( tokenizer . nextToken ( ) ) , fStringPool . addSymbol ( "CDATA" ) , true , false ) ; fAttrList . endAttrList ( ) ; int enumerationIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "enumeration" ) , fAttrList , handle ) ; fDeferredDocumentImpl . appendChild ( simpleTypeIndex , enumerationIndex ) ; } } else { int typeNameIndex = - 1 ; switch ( attType ) { case XMLAttributeDecl . TYPE_ENTITY : { typeNameIndex = fStringPool . addString ( attList ? "ENTITIES" : "ENTITY" ) ; break ; } case XMLAttributeDecl . TYPE_ID : { typeNameIndex = fStringPool . addString ( "ID" ) ; break ; } case XMLAttributeDecl . TYPE_IDREF : { typeNameIndex = fStringPool . addString ( attList ? "IDREFS" : "IDREF" ) ; break ; } case XMLAttributeDecl . TYPE_NMTOKEN : { typeNameIndex = fStringPool . addString ( attList ? "NMTOKENS" : "NMTOKEN" ) ; break ; } case XMLAttributeDecl . TYPE_NOTATION : { typeNameIndex = fStringPool . addString ( "NOTATION" ) ; break ; } case XMLAttributeDecl . TYPE_CDATA : default : { typeNameIndex = fStringPool . addString ( "string" ) ; break ; } } int attrIndex = fDeferredDocumentImpl . createAttribute ( fStringPool . addSymbol ( "type" ) , typeNameIndex , true ) ; fDeferredDocumentImpl . setAttributeNode ( attributeIndex , attrIndex ) ; } boolean fixed = false ; switch ( attDefaultType ) { case XMLAttributeDecl . DEFAULT_TYPE_REQUIRED : { int useAttrIndex = fDeferredDocumentImpl . createAttribute ( fStringPool . addSymbol ( "use" ) , fStringPool . addString ( "required" ) , true ) ; fDeferredDocumentImpl . setAttributeNode ( attributeIndex , useAttrIndex ) ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_FIXED : { fixed = true ; int useAttrIndex = fDeferredDocumentImpl . createAttribute ( fStringPool . addSymbol ( "use" ) , fStringPool . addString ( "fixed" ) , true ) ; fDeferredDocumentImpl . setAttributeNode ( attributeIndex , useAttrIndex ) ; break ; } } if ( attDefaultValue != - 1 ) { if ( ! fixed ) { int useAttrIndex = fDeferredDocumentImpl . createAttribute ( fStringPool . addSymbol ( "use" ) , fStringPool . addString ( "default" ) , true ) ; fDeferredDocumentImpl . setAttributeNode ( attributeIndex , useAttrIndex ) ; } int valueAttrIndex = fDeferredDocumentImpl . createAttribute ( fStringPool . addSymbol ( "value" ) , attDefaultValue , true ) ; fDeferredDocumentImpl . setAttributeNode ( attributeIndex , valueAttrIndex ) ; } } } } else if ( fDocumentImpl != null ) { if ( attDefaultValue != - 1 ) { if ( DEBUG_ATTLIST_DECL ) { System . out . println ( "  adding default attribute value: " + fStringPool . toString ( attDefaultValue ) ) ; } String elementName = fStringPool . toString ( elementDecl . rawname ) ; NamedNodeMap elements = ( ( DocumentTypeImpl ) fDocumentType ) . getElements ( ) ; ElementDefinitionImpl elementDef = ( ElementDefinitionImpl ) elements . getNamedItem ( elementName ) ; if ( elementDef == null ) { elementDef = fDocumentImpl . createElementDefinition ( elementName ) ; ( ( DocumentTypeImpl ) fDocumentType ) . getElements ( ) . setNamedItem ( elementDef ) ; } String attrName = fStringPool . toString ( attributeDecl . rawname ) ; String attrValue = fStringPool . toString ( attDefaultValue ) ; AttrImpl attr = ( AttrImpl ) fDocumentImpl . createAttribute ( attrName ) ; attr . setValue ( attrValue ) ; attr . setSpecified ( false ) ; elementDef . getAttributes ( ) . setNamedItem ( attr ) ; } try { if ( fGrammarAccess ) { Element schema = XUtil . getLastChildElement ( fDocumentType , "schema" ) ; String elementName = fStringPool . toString ( elementDecl . rawname ) ; Element element = XUtil . getLastChildElement ( schema , "element" , "name" , elementName ) ; if ( element == null ) { element = fDocumentImpl . createElement ( "element" ) ; element . setAttribute ( "name" , elementName ) ; schema . appendChild ( element ) ; } Element type = XUtil . getLastChildElement ( element , "complexType" ) ; if ( type == null ) { type = fDocumentImpl . createElement ( "complexType" ) ; element . insertBefore ( type , XUtil . getLastChildElement ( element ) ) ; } String attributeName = fStringPool . toString ( attributeDecl . rawname ) ; Element attribute = XUtil . getLastChildElement ( element , "attribute" , "name" , attributeName ) ; if ( attribute == null ) { attribute = fDocumentImpl . createElement ( "attribute" ) ; attribute . setAttribute ( "name" , attributeName ) ; attribute . setAttribute ( "maxOccurs" , "1" ) ; ( ( AttrImpl ) attribute . getAttributeNode ( "maxOccurs" ) ) . setSpecified ( false ) ; type . appendChild ( attribute ) ; if ( attType == XMLAttributeDecl . TYPE_ENUMERATION ) { Element simpleType = fDocumentImpl . createElement ( "simpleType" ) ; simpleType . setAttribute ( "base" , "NMTOKEN" ) ; attribute . appendChild ( simpleType ) ; String tokenizerString = enumString . substring ( 1 , enumString . length ( ) - 1 ) ; StringTokenizer tokenizer = new StringTokenizer ( tokenizerString , "|" ) ; while ( tokenizer . hasMoreTokens ( ) ) { Element enumeration = fDocumentImpl . createElement ( "enumeration" ) ; enumeration . setAttribute ( "value" , tokenizer . nextToken ( ) ) ; simpleType . appendChild ( enumeration ) ; } } else { String typeName = null ; switch ( attType ) { case XMLAttributeDecl . TYPE_ENTITY : { typeName = attList ? "ENTITIES" : "ENTITY" ; break ; } case XMLAttributeDecl . TYPE_ID : { typeName = "ID" ; break ; } case XMLAttributeDecl . TYPE_IDREF : { typeName = attList ? "IDREFS" : "IDREF" ; break ; } case XMLAttributeDecl . TYPE_NMTOKEN : { typeName = attList ? "NMTOKENS" : "NMTOKEN" ; break ; } case XMLAttributeDecl . TYPE_NOTATION : { typeName = "NOTATION" ; break ; } case XMLAttributeDecl . TYPE_CDATA : default : { typeName = "string" ; break ; } } attribute . setAttribute ( "type" , typeName ) ; } boolean fixed = false ; switch ( attDefaultType ) { case XMLAttributeDecl . DEFAULT_TYPE_REQUIRED : { attribute . setAttribute ( "use" , "required" ) ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_FIXED : { attribute . setAttribute ( "use" , "fixed" ) ; fixed = true ; break ; } } if ( attDefaultValue != - 1 ) { if ( ! fixed ) { attribute . setAttribute ( "use" , "default" ) ; } attribute . setAttribute ( "value" , fStringPool . toString ( attDefaultValue ) ) ; } } } } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } } } public void internalPEDecl ( int entityNameIndex , int entityValueIndex ) throws Exception { if ( fDeferredDocumentImpl != null ) { if ( fGrammarAccess ) { StringBuffer str = new StringBuffer ( ) ; str . append ( "<!ENTITY % " ) ; str . append ( fStringPool . toString ( entityNameIndex ) ) ; str . append ( " \"" ) ; str . append ( fStringPool . toString ( entityValueIndex ) ) ; str . append ( "\">" ) ; int commentIndex = fStringPool . addString ( str . toString ( ) ) ; int internalPEEntityIndex = fDeferredDocumentImpl . createComment ( commentIndex ) ; int schemaIndex = getFirstChildElement ( fDocumentTypeIndex , "schema" ) ; fDeferredDocumentImpl . appendChild ( schemaIndex , internalPEEntityIndex ) ; } } else if ( fDocumentImpl != null ) { if ( fGrammarAccess ) { StringBuffer str = new StringBuffer ( ) ; str . append ( "<!ENTITY % " ) ; str . append ( fStringPool . toString ( entityNameIndex ) ) ; str . append ( " \"" ) ; str . append ( fStringPool . orphanString ( entityValueIndex ) ) ; str . append ( "\">" ) ; Node internalPEEntity = fDocumentImpl . createComment ( str . toString ( ) ) ; Node schema = XUtil . getFirstChildElement ( fDocumentType , "schema" ) ; schema . appendChild ( internalPEEntity ) ; } } else { fStringPool . orphanString ( entityValueIndex ) ; } } public void externalPEDecl ( int entityNameIndex , int publicIdIndex , int systemIdIndex ) throws Exception { if ( fDeferredDocumentImpl != null ) { if ( fGrammarAccess ) { StringBuffer str = new StringBuffer ( ) ; str . append ( "<!ENTITY " ) ; str . append ( fStringPool . toString ( entityNameIndex ) ) ; str . append ( ' ' ) ; if ( publicIdIndex != - 1 ) { str . append ( "PUBLIC \"" ) ; str . append ( fStringPool . toString ( publicIdIndex ) ) ; str . append ( '"' ) ; if ( systemIdIndex != - 1 ) { str . append ( " \"" ) ; str . append ( fStringPool . toString ( systemIdIndex ) ) ; str . append ( '"' ) ; } } else if ( systemIdIndex != - 1 ) { str . append ( "SYSTEM \"" ) ; str . append ( fStringPool . toString ( systemIdIndex ) ) ; str . append ( '"' ) ; } str . append ( '>' ) ; int commentIndex = fStringPool . addString ( str . toString ( ) ) ; int externalPEEntityIndex = fDeferredDocumentImpl . createComment ( commentIndex ) ; int schemaIndex = getFirstChildElement ( fDocumentTypeIndex , "schema" ) ; fDeferredDocumentImpl . appendChild ( schemaIndex , externalPEEntityIndex ) ; } } else if ( fDocumentImpl != null ) { if ( fGrammarAccess ) { StringBuffer str = new StringBuffer ( ) ; str . append ( "<!ENTITY " ) ; str . append ( fStringPool . toString ( entityNameIndex ) ) ; str . append ( ' ' ) ; if ( publicIdIndex != - 1 ) { str . append ( "PUBLIC \"" ) ; str . append ( fStringPool . toString ( publicIdIndex ) ) ; str . append ( '"' ) ; if ( systemIdIndex != - 1 ) { str . append ( " \"" ) ; str . append ( fStringPool . toString ( systemIdIndex ) ) ; str . append ( '"' ) ; } } else if ( systemIdIndex != - 1 ) { str . append ( "SYSTEM \"" ) ; str . append ( fStringPool . toString ( systemIdIndex ) ) ; str . append ( '"' ) ; } str . append ( '>' ) ; Node externalPEEntity = fDocumentImpl . createComment ( str . toString ( ) ) ; Node schema = XUtil . getFirstChildElement ( fDocumentType , "schema" ) ; schema . appendChild ( externalPEEntity ) ; } } } public void internalEntityDecl ( int entityNameIndex , int entityValueIndex ) throws Exception { if ( fDeferredDocumentImpl != null ) { if ( fDocumentTypeIndex == - 1 ) return ; int newEntityIndex = fDeferredDocumentImpl . createEntity ( entityNameIndex , - 1 , - 1 , - 1 ) ; fDeferredDocumentImpl . appendChild ( fDocumentTypeIndex , newEntityIndex ) ; if ( fGrammarAccess ) { StringBuffer str = new StringBuffer ( ) ; str . append ( "<!ENTITY " ) ; str . append ( fStringPool . toString ( entityNameIndex ) ) ; str . append ( " \"" ) ; str . append ( fStringPool . toString ( entityValueIndex ) ) ; str . append ( "\">" ) ; int commentIndex = fStringPool . addString ( str . toString ( ) ) ; int textEntityIndex = fDeferredDocumentImpl . createComment ( commentIndex ) ; int schemaIndex = getFirstChildElement ( fDocumentTypeIndex , "schema" ) ; fDeferredDocumentImpl . appendChild ( schemaIndex , textEntityIndex ) ; } } else if ( fDocumentImpl != null ) { if ( fDocumentType == null ) return ; String entityName = fStringPool . toString ( entityNameIndex ) ; Entity entity = fDocumentImpl . createEntity ( entityName ) ; fDocumentType . getEntities ( ) . setNamedItem ( entity ) ; if ( fGrammarAccess ) { StringBuffer str = new StringBuffer ( ) ; str . append ( "<!ENTITY " ) ; str . append ( fStringPool . toString ( entityNameIndex ) ) ; str . append ( " \"" ) ; str . append ( fStringPool . toString ( entityValueIndex ) ) ; str . append ( "\">" ) ; Node textEntity = fDocumentImpl . createComment ( str . toString ( ) ) ; Node schema = XUtil . getFirstChildElement ( fDocumentType , "schema" ) ; schema . appendChild ( textEntity ) ; } } } public void externalEntityDecl ( int entityNameIndex , int publicIdIndex , int systemIdIndex ) throws Exception { if ( fDeferredDocumentImpl != null ) { int newEntityIndex = fDeferredDocumentImpl . createEntity ( entityNameIndex , publicIdIndex , systemIdIndex , - 1 ) ; fDeferredDocumentImpl . appendChild ( fDocumentTypeIndex , newEntityIndex ) ; if ( fGrammarAccess ) { StringBuffer str = new StringBuffer ( ) ; str . append ( "<!ENTITY " ) ; str . append ( fStringPool . toString ( entityNameIndex ) ) ; str . append ( ' ' ) ; if ( publicIdIndex != - 1 ) { str . append ( "PUBLIC \"" ) ; str . append ( fStringPool . toString ( publicIdIndex ) ) ; str . append ( '"' ) ; if ( systemIdIndex != - 1 ) { str . append ( " \"" ) ; str . append ( fStringPool . toString ( systemIdIndex ) ) ; str . append ( '"' ) ; } } else if ( systemIdIndex != - 1 ) { str . append ( "SYSTEM \"" ) ; str . append ( fStringPool . toString ( systemIdIndex ) ) ; str . append ( '"' ) ; } str . append ( '>' ) ; int commentIndex = fStringPool . addString ( str . toString ( ) ) ; int externalEntityIndex = fDeferredDocumentImpl . createComment ( commentIndex ) ; int schemaIndex = getFirstChildElement ( fDocumentTypeIndex , "schema" ) ; fDeferredDocumentImpl . appendChild ( schemaIndex , externalEntityIndex ) ; } } else if ( fDocumentImpl != null ) { String entityName = fStringPool . toString ( entityNameIndex ) ; String publicId = fStringPool . toString ( publicIdIndex ) ; String systemId = fStringPool . toString ( systemIdIndex ) ; EntityImpl entity = ( EntityImpl ) fDocumentImpl . createEntity ( entityName ) ; if ( publicIdIndex != - 1 ) { entity . setPublicId ( publicId ) ; } entity . setSystemId ( systemId ) ; fDocumentType . getEntities ( ) . setNamedItem ( entity ) ; if ( fGrammarAccess ) { StringBuffer str = new StringBuffer ( ) ; str . append ( "<!ENTITY " ) ; str . append ( fStringPool . toString ( entityNameIndex ) ) ; str . append ( ' ' ) ; if ( publicIdIndex != - 1 ) { str . append ( "PUBLIC \"" ) ; str . append ( fStringPool . toString ( publicIdIndex ) ) ; str . append ( '"' ) ; if ( systemIdIndex != - 1 ) { str . append ( " \"" ) ; str . append ( fStringPool . toString ( systemIdIndex ) ) ; str . append ( '"' ) ; } } else if ( systemIdIndex != - 1 ) { str . append ( "SYSTEM \"" ) ; str . append ( fStringPool . toString ( systemIdIndex ) ) ; str . append ( '"' ) ; } str . append ( '>' ) ; Node externalEntity = fDocumentImpl . createComment ( str . toString ( ) ) ; Node schema = XUtil . getFirstChildElement ( fDocumentType , "schema" ) ; schema . appendChild ( externalEntity ) ; } } } public void unparsedEntityDecl ( int entityNameIndex , int publicIdIndex , int systemIdIndex , int notationNameIndex ) throws Exception { if ( fDeferredDocumentImpl != null ) { int newEntityIndex = fDeferredDocumentImpl . createEntity ( entityNameIndex , publicIdIndex , systemIdIndex , notationNameIndex ) ; fDeferredDocumentImpl . appendChild ( fDocumentTypeIndex , newEntityIndex ) ; if ( fGrammarAccess ) { StringBuffer str = new StringBuffer ( ) ; str . append ( "<!ENTITY " ) ; str . append ( fStringPool . toString ( entityNameIndex ) ) ; str . append ( ' ' ) ; if ( publicIdIndex != - 1 ) { str . append ( "PUBLIC \"" ) ; str . append ( fStringPool . toString ( publicIdIndex ) ) ; str . append ( '"' ) ; if ( systemIdIndex != - 1 ) { str . append ( " \"" ) ; str . append ( fStringPool . toString ( systemIdIndex ) ) ; str . append ( '"' ) ; } } else if ( systemIdIndex != - 1 ) { str . append ( "SYSTEM \"" ) ; str . append ( fStringPool . toString ( systemIdIndex ) ) ; str . append ( '"' ) ; } str . append ( " NDATA " ) ; str . append ( fStringPool . toString ( notationNameIndex ) ) ; str . append ( '>' ) ; int commentIndex = fStringPool . addString ( str . toString ( ) ) ; int unparsedEntityIndex = fDeferredDocumentImpl . createComment ( commentIndex ) ; int schemaIndex = getFirstChildElement ( fDocumentTypeIndex , "schema" ) ; fDeferredDocumentImpl . appendChild ( schemaIndex , unparsedEntityIndex ) ; } } else if ( fDocumentImpl != null ) { String entityName = fStringPool . toString ( entityNameIndex ) ; String publicId = fStringPool . toString ( publicIdIndex ) ; String systemId = fStringPool . toString ( systemIdIndex ) ; String notationName = fStringPool . toString ( notationNameIndex ) ; EntityImpl entity = ( EntityImpl ) fDocumentImpl . createEntity ( entityName ) ; if ( publicIdIndex != - 1 ) { entity . setPublicId ( publicId ) ; } entity . setSystemId ( systemId ) ; entity . setNotationName ( notationName ) ; fDocumentType . getEntities ( ) . setNamedItem ( entity ) ; if ( fGrammarAccess ) { StringBuffer str = new StringBuffer ( ) ; str . append ( "<!ENTITY " ) ; str . append ( fStringPool . toString ( entityNameIndex ) ) ; str . append ( ' ' ) ; if ( publicIdIndex != - 1 ) { str . append ( "PUBLIC \"" ) ; str . append ( fStringPool . toString ( publicIdIndex ) ) ; str . append ( '"' ) ; if ( systemIdIndex != - 1 ) { str . append ( " \"" ) ; str . append ( fStringPool . toString ( systemIdIndex ) ) ; str . append ( '"' ) ; } } else if ( systemIdIndex != - 1 ) { str . append ( "SYSTEM \"" ) ; str . append ( fStringPool . toString ( systemIdIndex ) ) ; str . append ( '"' ) ; } str . append ( " NDATA " ) ; str . append ( fStringPool . toString ( notationNameIndex ) ) ; str . append ( '>' ) ; Node unparsedEntity = fDocumentImpl . createComment ( str . toString ( ) ) ; Node schema = XUtil . getFirstChildElement ( fDocumentType , "schema" ) ; schema . appendChild ( unparsedEntity ) ; } } } public void notationDecl ( int notationNameIndex , int publicIdIndex , int systemIdIndex ) throws Exception { if ( fDeferredDocumentImpl != null ) { int newNotationIndex = fDeferredDocumentImpl . createNotation ( notationNameIndex , publicIdIndex , systemIdIndex ) ; fDeferredDocumentImpl . appendChild ( fDocumentTypeIndex , newNotationIndex ) ; if ( fGrammarAccess ) { int schemaIndex = getLastChildElement ( fDocumentTypeIndex , "schema" ) ; String notationName = fStringPool . toString ( notationNameIndex ) ; int notationIndex = getLastChildElement ( schemaIndex , "notation" , "name" , notationName ) ; if ( notationIndex == - 1 ) { int handle = fAttrList . startAttrList ( ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "name" ) , fStringPool . addString ( notationName ) , fStringPool . addSymbol ( "NMTOKEN" ) , true , false ) ; if ( publicIdIndex != - 1 ) { fAttrList . addAttr ( fStringPool . addSymbol ( "public" ) , publicIdIndex , fStringPool . addSymbol ( "CDATA" ) , true , false ) ; } if ( systemIdIndex != - 1 ) { fAttrList . addAttr ( fStringPool . addSymbol ( "system" ) , systemIdIndex , fStringPool . addSymbol ( "CDATA" ) , true , false ) ; } fAttrList . endAttrList ( ) ; notationIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( "notation" ) , fAttrList , handle ) ; fDeferredDocumentImpl . appendChild ( schemaIndex , notationIndex ) ; } } } else if ( fDocumentImpl != null ) { String notationName = fStringPool . toString ( notationNameIndex ) ; String publicId = fStringPool . toString ( publicIdIndex ) ; String systemId = fStringPool . toString ( systemIdIndex ) ; NotationImpl notationImpl = ( NotationImpl ) fDocumentImpl . createNotation ( notationName ) ; notationImpl . setPublicId ( publicId ) ; if ( systemIdIndex != - 1 ) { notationImpl . setSystemId ( systemId ) ; } fDocumentType . getNotations ( ) . setNamedItem ( notationImpl ) ; if ( fGrammarAccess ) { Element schema = XUtil . getFirstChildElement ( fDocumentType , "schema" ) ; Element notation = XUtil . getFirstChildElement ( schema , "notation" , "name" , notationName ) ; if ( notation == null ) { notation = fDocument . createElement ( "notation" ) ; notation . setAttribute ( "name" , notationName ) ; if ( publicId != null ) { notation . setAttribute ( "public" , publicId ) ; } if ( systemIdIndex != - 1 ) { notation . setAttribute ( "system" , systemId ) ; } schema . appendChild ( notation ) ; } } } } private int getFirstChildElement ( int nodeIndex ) { int childIndex = getLastChildElement ( nodeIndex ) ; while ( childIndex != - 1 ) { int prevIndex = getPrevSiblingElement ( childIndex ) ; if ( prevIndex == - 1 ) { break ; } childIndex = prevIndex ; } return childIndex ; } private int getFirstChildElement ( int nodeIndex , String name ) { int childIndex = getLastChildElement ( nodeIndex ) ; if ( childIndex != - 1 ) { int nameIndex = fStringPool . addSymbol ( name ) ; while ( childIndex != - 1 ) { if ( fDeferredDocumentImpl . getNodeName ( childIndex , false ) == nameIndex ) { break ; } int prevIndex = getPrevSiblingElement ( childIndex ) ; childIndex = prevIndex ; } } return childIndex ; } private int getLastChildElement ( int nodeIndex ) { int childIndex = fDeferredDocumentImpl . getLastChild ( nodeIndex , false ) ; while ( childIndex != - 1 ) { if ( fDeferredDocumentImpl . getNodeType ( childIndex , false ) == Node . ELEMENT_NODE ) { return childIndex ; } childIndex = fDeferredDocumentImpl . getPrevSibling ( childIndex , false ) ; } return - 1 ; } private int getPrevSiblingElement ( int nodeIndex ) { int siblingIndex = fDeferredDocumentImpl . getPrevSibling ( nodeIndex , false ) ; while ( siblingIndex != - 1 ) { if ( fDeferredDocumentImpl . getNodeType ( siblingIndex , false ) == Node . ELEMENT_NODE ) { return siblingIndex ; } siblingIndex = fDeferredDocumentImpl . getPrevSibling ( siblingIndex , false ) ; } return - 1 ; } private int getLastChildElement ( int nodeIndex , String elementName ) { int childIndex = getLastChildElement ( nodeIndex ) ; if ( childIndex != - 1 ) { while ( childIndex != - 1 ) { String nodeName = fDeferredDocumentImpl . getNodeNameString ( childIndex , false ) ; if ( nodeName . equals ( elementName ) ) { return childIndex ; } childIndex = getPrevSiblingElement ( childIndex ) ; } } return - 1 ; } private int getPrevSiblingElement ( int nodeIndex , String elementName ) { int siblingIndex = getPrevSiblingElement ( nodeIndex ) ; if ( siblingIndex != - 1 ) { while ( siblingIndex != - 1 ) { String nodeName = fDeferredDocumentImpl . getNodeNameString ( siblingIndex , false ) ; if ( nodeName . equals ( elementName ) ) { return siblingIndex ; } siblingIndex = getPrevSiblingElement ( siblingIndex ) ; } } return - 1 ; } private int getLastChildElement ( int nodeIndex , String elemName , String attrName , String attrValue ) { int childIndex = getLastChildElement ( nodeIndex , elemName ) ; if ( childIndex != - 1 ) { while ( childIndex != - 1 ) { int attrIndex = fDeferredDocumentImpl . getNodeValue ( childIndex , false ) ; while ( attrIndex != - 1 ) { String nodeName = fDeferredDocumentImpl . getNodeNameString ( attrIndex , false ) ; if ( nodeName . equals ( attrName ) ) { int textIndex = fDeferredDocumentImpl . getLastChild ( attrIndex , false ) ; String nodeValue = fDeferredDocumentImpl . getNodeValueString ( textIndex , false ) ; if ( nodeValue . equals ( attrValue ) ) { return childIndex ; } } attrIndex = fDeferredDocumentImpl . getPrevSibling ( attrIndex , false ) ; } childIndex = getPrevSiblingElement ( childIndex , elemName ) ; } } return - 1 ; } private int getPrevSiblingElement ( int nodeIndex , String elemName , String attrName , String attrValue ) { int siblingIndex = getPrevSiblingElement ( nodeIndex , elemName ) ; if ( siblingIndex != - 1 ) { int attributeNameIndex = fStringPool . addSymbol ( attrName ) ; while ( siblingIndex != - 1 ) { int attrIndex = fDeferredDocumentImpl . getNodeValue ( siblingIndex , false ) ; while ( attrIndex != - 1 ) { int attrValueIndex = fDeferredDocumentImpl . getNodeValue ( attrIndex , false ) ; if ( attrValue . equals ( fStringPool . toString ( attrValueIndex ) ) ) { return siblingIndex ; } attrIndex = fDeferredDocumentImpl . getPrevSibling ( attrIndex , false ) ; } siblingIndex = getPrevSiblingElement ( siblingIndex , elemName ) ; } } return - 1 ; } private void copyInto ( Node src , int destIndex ) throws Exception { boolean domimpl = src != null && src instanceof DocumentImpl ; Node start = src ; Node parent = src ; Node place = src ; while ( place != null ) { int nodeIndex = - 1 ; short type = place . getNodeType ( ) ; switch ( type ) { case Node . CDATA_SECTION_NODE : { boolean ignorable = domimpl && ( ( TextImpl ) place ) . isIgnorableWhitespace ( ) ; nodeIndex = fDeferredDocumentImpl . createCDATASection ( fStringPool . addString ( place . getNodeValue ( ) ) , ignorable ) ; break ; } case Node . COMMENT_NODE : { nodeIndex = fDeferredDocumentImpl . createComment ( fStringPool . addString ( place . getNodeValue ( ) ) ) ; break ; } case Node . ELEMENT_NODE : { XMLAttrList attrList = null ; int handle = - 1 ; NamedNodeMap attrs = place . getAttributes ( ) ; if ( attrs != null ) { int length = attrs . getLength ( ) ; if ( length > 0 ) { handle = fAttrList . startAttrList ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; String attrName = attr . getNodeName ( ) ; String attrValue = attr . getNodeValue ( ) ; fAttrList . addAttr ( fStringPool . addSymbol ( attrName ) , fStringPool . addString ( attrValue ) , fStringPool . addSymbol ( "CDATA" ) , attr . getSpecified ( ) , false ) ; } fAttrList . endAttrList ( ) ; attrList = fAttrList ; } } nodeIndex = fDeferredDocumentImpl . createElement ( fStringPool . addSymbol ( place . getNodeName ( ) ) , attrList , handle ) ; break ; } case Node . ENTITY_REFERENCE_NODE : { nodeIndex = fDeferredDocumentImpl . createEntityReference ( fStringPool . addSymbol ( place . getNodeName ( ) ) ) ; break ; } case Node . PROCESSING_INSTRUCTION_NODE : { nodeIndex = fDeferredDocumentImpl . createProcessingInstruction ( fStringPool . addSymbol ( place . getNodeName ( ) ) , fStringPool . addString ( place . getNodeValue ( ) ) ) ; break ; } case Node . TEXT_NODE : { boolean ignorable = domimpl && ( ( TextImpl ) place ) . isIgnorableWhitespace ( ) ; nodeIndex = fDeferredDocumentImpl . createTextNode ( fStringPool . addString ( place . getNodeValue ( ) ) , ignorable ) ; break ; } default : { throw new IllegalArgumentException ( "PAR010 Can't copy node type, " + type + " (" + place . getNodeName ( ) + ')' + "\n" + type + "\t" + place . getNodeName ( ) ) ; } } fDeferredDocumentImpl . appendChild ( destIndex , nodeIndex ) ; if ( place . hasChildNodes ( ) ) { parent = place ; place = place . getFirstChild ( ) ; destIndex = nodeIndex ; } else { place = place . getNextSibling ( ) ; while ( place == null && parent != start ) { place = parent . getNextSibling ( ) ; parent = parent . getParentNode ( ) ; destIndex = fDeferredDocumentImpl . getParentNode ( destIndex , false ) ; } } } } private void setOccurrenceCount ( Element model , int minOccur , int maxOccur ) { model . setAttribute ( "minOccurs" , Integer . toString ( minOccur ) ) ; if ( minOccur == 1 ) { ( ( AttrImpl ) model . getAttributeNode ( "minOccurs" ) ) . setSpecified ( false ) ; } if ( maxOccur == - 1 ) { model . setAttribute ( "maxOccurs" , "*" ) ; } else if ( maxOccur != 1 ) { model . setAttribute ( "maxOccurs" , Integer . toString ( maxOccur ) ) ; } } private Element createChildren ( XMLContentSpec . Provider provider , int index , XMLContentSpec node , DocumentImpl factory , Element parent ) throws Exception { provider . getContentSpec ( index , node ) ; int occurs = - 1 ; switch ( node . type ) { case XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE : { occurs = '+' ; provider . getContentSpec ( node . value , node ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE : { occurs = '*' ; provider . getContentSpec ( node . value , node ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE : { occurs = '?' ; provider . getContentSpec ( node . value , node ) ; break ; } } int nodeType = node . type ; switch ( nodeType ) { case XMLContentSpec . CONTENTSPECNODE_CHOICE : case XMLContentSpec . CONTENTSPECNODE_SEQ : { int leftIndex = node . value ; int rightIndex = node . otherValue ; Element left = createChildren ( provider , leftIndex , node , factory , parent ) ; Element right = createChildren ( provider , rightIndex , node , factory , null ) ; boolean choice = nodeType == XMLContentSpec . CONTENTSPECNODE_CHOICE ; String type = choice ? "choice" : "sequence" ; Element model = left ; if ( ! left . getNodeName ( ) . equals ( type ) ) { String minOccurs = left . getAttribute ( "minOccurs" ) ; String maxOccurs = left . getAttribute ( "maxOccurs" ) ; boolean min1 = minOccurs . length ( ) == 0 || minOccurs . equals ( "1" ) ; boolean max1 = maxOccurs . length ( ) == 0 || maxOccurs . equals ( "1" ) ; if ( parent == null || ( min1 && max1 ) ) { model = factory . createElement ( type ) ; model . appendChild ( left ) ; } else { model = parent ; } } switch ( occurs ) { case '+' : { model . setAttribute ( "maxOccurs" , "unbounded" ) ; break ; } case '*' : { model . setAttribute ( "minOccurs" , "0" ) ; model . setAttribute ( "maxOccurs" , "unbounded" ) ; break ; } case '?' : { model . setAttribute ( "minOccurs" , "0" ) ; break ; } } model . appendChild ( right ) ; return model ; } case XMLContentSpec . CONTENTSPECNODE_LEAF : { Element leaf = factory . createElement ( "element" ) ; leaf . setAttribute ( "ref" , fStringPool . toString ( node . value ) ) ; switch ( occurs ) { case '+' : { leaf . setAttribute ( "maxOccurs" , "unbounded" ) ; break ; } case '*' : { leaf . setAttribute ( "minOccurs" , "0" ) ; leaf . setAttribute ( "maxOccurs" , "unbounded" ) ; break ; } case '?' : { leaf . setAttribute ( "minOccurs" , "0" ) ; break ; } } return leaf ; } } return null ; } private int createChildren ( XMLContentSpec . Provider provider , int index , XMLContentSpec node , DeferredDocumentImpl factory , int parent ) throws Exception { provider . getContentSpec ( index , node ) ; int occurs = - 1 ; switch ( node . type ) { case XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE : { occurs = '+' ; provider . getContentSpec ( node . value , node ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE : { occurs = '*' ; provider . getContentSpec ( node . value , node ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE : { occurs = '?' ; provider . getContentSpec ( node . value , node ) ; break ; } } int nodeType = node . type ; switch ( nodeType ) { case XMLContentSpec . CONTENTSPECNODE_CHOICE : case XMLContentSpec . CONTENTSPECNODE_SEQ : { int leftIndex = node . value ; int rightIndex = node . otherValue ; int left = createChildren ( provider , leftIndex , node , factory , parent ) ; int right = createChildren ( provider , rightIndex , node , factory , - 1 ) ; boolean choice = nodeType == XMLContentSpec . CONTENTSPECNODE_CHOICE ; int type = fStringPool . addSymbol ( choice ? "choice" : "sequence" ) ; int model = left ; if ( factory . getNodeName ( left , false ) != type ) { int minOccurs = factory . getAttribute ( left , fStringPool . addSymbol ( "minOccurs" ) ) ; int maxOccurs = factory . getAttribute ( left , fStringPool . addSymbol ( "maxOccurs" ) ) ; boolean min1 = minOccurs == - 1 || fStringPool . toString ( minOccurs ) . equals ( "1" ) ; boolean max1 = maxOccurs == - 1 || fStringPool . toString ( maxOccurs ) . equals ( "1" ) ; if ( parent == - 1 || ( min1 && max1 ) ) { model = factory . createElement ( type , null , - 1 ) ; factory . appendChild ( model , left ) ; } else { model = parent ; } } switch ( occurs ) { case '+' : { int maxOccurs = factory . createAttribute ( fStringPool . addSymbol ( "maxOccurs" ) , fStringPool . addString ( "unbounded" ) , true ) ; factory . setAttributeNode ( model , maxOccurs ) ; break ; } case '*' : { int minOccurs = factory . createAttribute ( fStringPool . addSymbol ( "minOccurs" ) , fStringPool . addString ( "0" ) , true ) ; factory . setAttributeNode ( model , minOccurs ) ; int maxOccurs = factory . createAttribute ( fStringPool . addSymbol ( "maxOccurs" ) , fStringPool . addString ( "unbounded" ) , true ) ; factory . setAttributeNode ( model , maxOccurs ) ; break ; } case '?' : { int minOccurs = factory . createAttribute ( fStringPool . addSymbol ( "minOccurs" ) , fStringPool . addString ( "0" ) , true ) ; factory . setAttributeNode ( model , minOccurs ) ; break ; } } factory . appendChild ( model , right ) ; return model ; } case XMLContentSpec . CONTENTSPECNODE_LEAF : { int handle = fAttrList . startAttrList ( ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "ref" ) , fStringPool . addString ( fStringPool . toString ( node . value ) ) , fStringPool . addSymbol ( "NMTOKEN" ) , true , false ) ; switch ( occurs ) { case '+' : { fAttrList . addAttr ( fStringPool . addSymbol ( "maxOccurs" ) , fStringPool . addString ( "unbounded" ) , fStringPool . addSymbol ( "CDATA" ) , true , false ) ; break ; } case '*' : { fAttrList . addAttr ( fStringPool . addSymbol ( "minOccurs" ) , fStringPool . addString ( "0" ) , fStringPool . addSymbol ( "NMTOKEN" ) , true , false ) ; fAttrList . addAttr ( fStringPool . addSymbol ( "maxOccurs" ) , fStringPool . addString ( "unbounded" ) , fStringPool . addSymbol ( "CDATA" ) , true , false ) ; break ; } case '?' : { fAttrList . addAttr ( fStringPool . addSymbol ( "minOccurs" ) , fStringPool . addString ( "0" ) , fStringPool . addSymbol ( "NMTOKEN" ) , true , false ) ; break ; } } fAttrList . endAttrList ( ) ; int leaf = factory . createElement ( fStringPool . addSymbol ( "element" ) , fAttrList , handle ) ; return leaf ; } } return - 1 ; } } 	0
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ChildAndParentNode extends ChildNode { static final long serialVersionUID = 0 ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ChildAndParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ChildAndParentNode ( ) { } public Node cloneNode ( boolean deep ) { ChildAndParentNode newnode = ( ChildAndParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLIFrameElementImpl extends HTMLElementImpl implements HTMLIFrameElement { public String getAlign ( ) { return capitalize ( getAttribute ( "align" ) ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public String getFrameBorder ( ) { return getAttribute ( "frameborder" ) ; } public void setFrameBorder ( String frameBorder ) { setAttribute ( "frameborder" , frameBorder ) ; } public String getHeight ( ) { return getAttribute ( "height" ) ; } public void setHeight ( String height ) { setAttribute ( "height" , height ) ; } public String getLongDesc ( ) { return getAttribute ( "longdesc" ) ; } public void setLongDesc ( String longDesc ) { setAttribute ( "longdesc" , longDesc ) ; } public String getMarginHeight ( ) { return getAttribute ( "marginheight" ) ; } public void setMarginHeight ( String marginHeight ) { setAttribute ( "marginheight" , marginHeight ) ; } public String getMarginWidth ( ) { return getAttribute ( "marginwidth" ) ; } public void setMarginWidth ( String marginWidth ) { setAttribute ( "marginwidth" , marginWidth ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public String getScrolling ( ) { return capitalize ( getAttribute ( "scrolling" ) ) ; } public void setScrolling ( String scrolling ) { setAttribute ( "scrolling" , scrolling ) ; } public String getSrc ( ) { return getAttribute ( "src" ) ; } public void setSrc ( String src ) { setAttribute ( "src" , src ) ; } public String getWidth ( ) { return getAttribute ( "width" ) ; } public void setWidth ( String width ) { setAttribute ( "width" , width ) ; } public HTMLIFrameElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom . events ; import org . w3c . dom . DOMException ; public interface DocumentEvent { public Event createEvent ( String eventType ) throws DOMException ; } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import java . util . Locale ; public interface DatatypeValidator { public static final int FACET_LENGTH = 1 ; public static final int FACET_MINLENGTH = 1 << 1 ; public static final int FACET_MAXLENGTH = 1 << 2 ; public static final int FACET_PATTERN = 1 << 3 ; public static final int FACET_ENUMERATION = 1 << 4 ; public static final int FACET_MAXINCLUSIVE = 1 << 5 ; public static final int FACET_MAXEXCLUSIVE = 1 << 6 ; public static final int FACET_MININCLUSIVE = 1 << 7 ; public static final int FACET_MINEXCLUSIVE = 1 << 8 ; public static final int FACET_PRECISSION = 1 << 9 ; public static final int FACET_SCALE = 1 << 10 ; public static final int FACET_ENCODING = 1 << 11 ; public static final int FACET_DURATION = 1 << 12 ; public static final int FACET_PERIOD = 1 << 13 ; public Object validate ( String content , Object state ) throws InvalidDatatypeValueException ; public Hashtable getFacets ( ) ; public int compare ( String value1 , String value2 ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ParentNode extends NodeImpl { static final long serialVersionUID = 2815829867152120872L ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ParentNode ( ) { } public Node cloneNode ( boolean deep ) { ParentNode newnode = ( ParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLTitleElementImpl extends HTMLElementImpl implements HTMLTitleElement { public String getText ( ) { Node child ; String text ; child = getFirstChild ( ) ; text = "" ; while ( child != null ) { if ( child instanceof Text ) text = text + ( ( Text ) child ) . getData ( ) ; child = child . getNextSibling ( ) ; } return text ; } public void setText ( String text ) { Node child ; Node next ; child = getFirstChild ( ) ; while ( child != null ) { next = child . getNextSibling ( ) ; removeChild ( child ) ; child = next ; } insertBefore ( getOwnerDocument ( ) . createTextNode ( text ) , getFirstChild ( ) ) ; } public HTMLTitleElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package javax . xml . parsers ; public abstract class DocumentBuilderFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.DocumentBuilderFactory" ; private static String factory = "org.apache.xerces.jaxp.DocumentBuilderFactoryImpl" ; protected DocumentBuilderFactory ( ) { super ( ) ; } public static DocumentBuilderFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( DocumentBuilderFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"" + "javax.xml.parsers.DocumentBuilderFactory\"" ) ; } } public abstract DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLSmallElementImpl extends WMLElementImpl implements WMLSmallElement { public WMLSmallElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; public class NamedNodeMapImpl implements NamedNodeMap , Serializable { static final long serialVersionUID = - 7039242451046758020L ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short CHANGED = 0x1 << 1 ; protected final static short HASDEFAULTS = 0x1 << 2 ; protected Vector nodes ; protected NodeImpl ownerNode ; protected NamedNodeMapImpl ( NodeImpl ownerNode ) { this . ownerNode = ownerNode ; } public int getLength ( ) { return ( nodes != null ) ? nodes . size ( ) : 0 ; } public Node item ( int index ) { return ( nodes != null && index < nodes . size ( ) ) ? ( Node ) ( nodes . elementAt ( index ) ) : null ; } public Node getNamedItem ( String name ) { int i = findNamePoint ( name , 0 ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node getNamedItemNS ( String namespaceURI , String localName ) { int i = findNamePoint ( namespaceURI , localName ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNamespaceURI ( ) , arg . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { NamedNodeMapImpl newmap = new NamedNodeMapImpl ( ownerNode ) ; newmap . cloneContent ( this ) ; return newmap ; } protected void cloneContent ( NamedNodeMapImpl srcmap ) { if ( srcmap . nodes != null ) { nodes = new Vector ( srcmap . nodes . size ( ) ) ; for ( int i = 0 ; i < srcmap . nodes . size ( ) ; ++ i ) { NodeImpl n = ( NodeImpl ) srcmap . nodes . elementAt ( i ) ; NodeImpl clone = ( NodeImpl ) n . cloneNode ( true ) ; clone . isSpecified ( n . isSpecified ( ) ) ; nodes . insertElementAt ( clone , i ) ; } } } void setReadOnly ( boolean readOnly , boolean deep ) { isReadOnly ( readOnly ) ; if ( deep && nodes != null ) { Enumeration e = nodes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( NodeImpl ) e . nextElement ( ) ) . setReadOnly ( readOnly , deep ) ; } } } boolean getReadOnly ( ) { return isReadOnly ( ) ; } void setOwnerDocument ( DocumentImpl doc ) { if ( nodes != null ) { for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { ( ( NodeImpl ) item ( i ) ) . setOwnerDocument ( doc ) ; } } } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean changed ( ) { return ( flags & CHANGED ) != 0 ; } final void changed ( boolean value ) { flags = ( short ) ( value ? flags | CHANGED : flags & ~ CHANGED ) ; } final boolean hasDefaults ( ) { return ( flags & HASDEFAULTS ) != 0 ; } final void hasDefaults ( boolean value ) { flags = ( short ) ( value ? flags | HASDEFAULTS : flags & ~ HASDEFAULTS ) ; } protected int findNamePoint ( String name , int start ) { int i = 0 ; if ( nodes != null ) { int first = start ; int last = nodes . size ( ) - 1 ; while ( first <= last ) { i = ( first + last ) / 2 ; int test = name . compareTo ( ( ( Node ) ( nodes . elementAt ( i ) ) ) . getNodeName ( ) ) ; if ( test == 0 ) { return i ; } else if ( test < 0 ) { last = i - 1 ; } else { first = i + 1 ; } } if ( first > i ) { i = first ; } } return - 1 - i ; } protected int findNamePoint ( String namespaceURI , String name ) { if ( nodes == null ) return - 1 ; if ( namespaceURI == null ) return - 1 ; if ( name == null ) return - 1 ; for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { NodeImpl a = ( NodeImpl ) nodes . elementAt ( i ) ; if ( namespaceURI . equals ( a . getNamespaceURI ( ) ) && name . equals ( a . getLocalName ( ) ) ) { return i ; } } return - 1 ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLButtonElementImpl extends HTMLElementImpl implements HTMLButtonElement , HTMLFormControl { public String getAccessKey ( ) { String accessKey ; accessKey = getAttribute ( "accesskey" ) ; if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; return accessKey ; } public void setAccessKey ( String accessKey ) { if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; setAttribute ( "accesskey" , accessKey ) ; } public boolean getDisabled ( ) { return getBinary ( "disabled" ) ; } public void setDisabled ( boolean disabled ) { setAttribute ( "disabled" , disabled ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public int getTabIndex ( ) { try { return Integer . parseInt ( getAttribute ( "tabindex" ) ) ; } catch ( NumberFormatException except ) { return 0 ; } } public void setTabIndex ( int tabIndex ) { setAttribute ( "tabindex" , String . valueOf ( tabIndex ) ) ; } public String getType ( ) { return capitalize ( getAttribute ( "type" ) ) ; } public String getValue ( ) { return getAttribute ( "value" ) ; } public void setValue ( String value ) { setAttribute ( "value" , value ) ; } public HTMLButtonElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom ; public interface NamedNodeMap { public Node getNamedItem ( String name ) ; public Node setNamedItem ( Node arg ) throws DOMException ; public Node removeNamedItem ( String name ) throws DOMException ; public Node item ( int index ) ; public int getLength ( ) ; public Node getNamedItemNS ( String namespaceURI , String localName ) ; public Node setNamedItemNS ( Node arg ) throws DOMException ; public Node removeNamedItemNS ( String namespaceURI , String localName ) throws DOMException ; } 	1
package org . apache . xerces . utils . regex ; import java . text . CharacterIterator ; public final class REUtil { private REUtil ( ) { } static final int composeFromSurrogates ( int high , int low ) { return 0x10000 + ( ( high - 0xd800 ) << 10 ) + low - 0xdc00 ; } static final boolean isLowSurrogate ( int ch ) { return ( ch & 0xfc00 ) == 0xdc00 ; } static final boolean isHighSurrogate ( int ch ) { return ( ch & 0xfc00 ) == 0xd800 ; } static final String decomposeToSurrogates ( int ch ) { char [ ] chs = new char [ 2 ] ; ch -= 0x10000 ; chs [ 0 ] = ( char ) ( ( ch > > 10 ) + 0xd800 ) ; chs [ 1 ] = ( char ) ( ( ch & 0x3ff ) + 0xdc00 ) ; return new String ( chs ) ; } static final String substring ( CharacterIterator iterator , int begin , int end ) { char [ ] src = new char [ end - begin ] ; for ( int i = 0 ; i < src . length ; i ++ ) src [ i ] = iterator . setIndex ( i + begin ) ; return new String ( src ) ; } static final int getOptionValue ( int ch ) { int ret = 0 ; switch ( ch ) { case 'i' : ret = RegularExpression . IGNORE_CASE ; break ; case 'm' : ret = RegularExpression . MULTIPLE_LINES ; break ; case 's' : ret = RegularExpression . SINGLE_LINE ; break ; case 'x' : ret = RegularExpression . EXTENDED_COMMENT ; break ; case 'u' : ret = RegularExpression . USE_UNICODE_CATEGORY ; break ; case 'w' : ret = RegularExpression . UNICODE_WORD_BOUNDARY ; break ; case 'F' : ret = RegularExpression . PROHIBIT_FIXED_STRING_OPTIMIZATION ; break ; case 'H' : ret = RegularExpression . PROHIBIT_HEAD_CHARACTER_OPTIMIZATION ; break ; case 'X' : ret = RegularExpression . XMLSCHEMA_MODE ; break ; case ',' : ret = RegularExpression . SPECIAL_COMMA ; break ; default : } return ret ; } static final int parseOptions ( String opts ) throws ParseException { if ( opts == null ) return 0 ; int options = 0 ; for ( int i = 0 ; i < opts . length ( ) ; i ++ ) { int v = getOptionValue ( opts . charAt ( i ) ) ; if ( v == 0 ) throw new ParseException ( "Unknown Option: " + opts . substring ( i ) , - 1 ) ; options |= v ; } return options ; } static final String createOptionString ( int options ) { StringBuffer sb = new StringBuffer ( 9 ) ; if ( ( options & RegularExpression . PROHIBIT_FIXED_STRING_OPTIMIZATION ) != 0 ) sb . append ( ( char ) 'F' ) ; if ( ( options & RegularExpression . PROHIBIT_HEAD_CHARACTER_OPTIMIZATION ) != 0 ) sb . append ( ( char ) 'H' ) ; if ( ( options & RegularExpression . XMLSCHEMA_MODE ) != 0 ) sb . append ( ( char ) 'X' ) ; if ( ( options & RegularExpression . IGNORE_CASE ) != 0 ) sb . append ( ( char ) 'i' ) ; if ( ( options & RegularExpression . MULTIPLE_LINES ) != 0 ) sb . append ( ( char ) 'm' ) ; if ( ( options & RegularExpression . SINGLE_LINE ) != 0 ) sb . append ( ( char ) 's' ) ; if ( ( options & RegularExpression . USE_UNICODE_CATEGORY ) != 0 ) sb . append ( ( char ) 'u' ) ; if ( ( options & RegularExpression . UNICODE_WORD_BOUNDARY ) != 0 ) sb . append ( ( char ) 'w' ) ; if ( ( options & RegularExpression . EXTENDED_COMMENT ) != 0 ) sb . append ( ( char ) 'x' ) ; if ( ( options & RegularExpression . SPECIAL_COMMA ) != 0 ) sb . append ( ( char ) ',' ) ; return sb . toString ( ) . intern ( ) ; } static String stripExtendedComment ( String regex ) { int len = regex . length ( ) ; StringBuffer buffer = new StringBuffer ( len ) ; int offset = 0 ; while ( offset < len ) { int ch = regex . charAt ( offset ++ ) ; if ( ch == '\t' || ch == '\n' || ch == '\f' || ch == '\r' || ch == ' ' ) continue ; if ( ch == '#' ) { while ( offset < len ) { ch = regex . charAt ( offset ++ ) ; if ( ch == '\r' || ch == '\n' ) break ; } continue ; } int next ; if ( ch == '\\' && offset < len ) { if ( ( next = regex . charAt ( offset ) ) == '#' || next == '\t' || next == '\n' || next == '\f' || next == '\r' || next == ' ' ) { buffer . append ( ( char ) next ) ; offset ++ ; } else { buffer . append ( ( char ) '\\' ) ; buffer . append ( ( char ) next ) ; offset ++ ; } } else buffer . append ( ( char ) ch ) ; } return buffer . toString ( ) ; } public static void main ( String [ ] argv ) { String pattern = null ; try { String options = "" ; String target = null ; if ( argv . length == 0 ) { System . out . println ( "Error:Usage: java REUtil -i|-m|-s|-u|-w|-X regularExpression String" ) ; System . exit ( 0 ) ; } for ( int i = 0 ; i < argv . length ; i ++ ) { if ( argv [ i ] . length ( ) == 0 || argv [ i ] . charAt ( 0 ) != '-' ) { if ( pattern == null ) pattern = argv [ i ] ; else if ( target == null ) target = argv [ i ] ; else System . err . println ( "Unnecessary: " + argv [ i ] ) ; } else if ( argv [ i ] . equals ( "-i" ) ) { options += "i" ; } else if ( argv [ i ] . equals ( "-m" ) ) { options += "m" ; } else if ( argv [ i ] . equals ( "-s" ) ) { options += "s" ; } else if ( argv [ i ] . equals ( "-u" ) ) { options += "u" ; } else if ( argv [ i ] . equals ( "-w" ) ) { options += "w" ; } else if ( argv [ i ] . equals ( "-X" ) ) { options += "X" ; } else { System . err . println ( "Unknown option: " + argv [ i ] ) ; } } RegularExpression reg = new RegularExpression ( pattern , options ) ; System . out . println ( "RegularExpression: " + reg ) ; Match match = new Match ( ) ; reg . matches ( target , match ) ; for ( int i = 0 ; i < match . getNumberOfGroups ( ) ; i ++ ) { if ( i == 0 ) System . out . print ( "Matched range for the whole pattern: " ) ; else System . out . print ( "[" + i + "]: " ) ; if ( match . getBeginning ( i ) < 0 ) System . out . println ( "-1" ) ; else { System . out . print ( match . getBeginning ( i ) + ", " + match . getEnd ( i ) + ", " ) ; System . out . println ( "\"" + match . getCapturedText ( i ) + "\"" ) ; } } } catch ( ParseException pe ) { if ( pattern == null ) { pe . printStackTrace ( ) ; } else { System . err . println ( "org.apache.xerces.utils.regex.ParseException: " + pe . getMessage ( ) ) ; String indent = "        " ; System . err . println ( indent + pattern ) ; int loc = pe . getLocation ( ) ; if ( loc >= 0 ) { System . err . print ( indent ) ; for ( int i = 0 ; i < loc ; i ++ ) System . err . print ( "-" ) ; System . err . println ( "^" ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } static final int CACHESIZE = 20 ; static RegularExpression [ ] regexCache = new RegularExpression [ CACHESIZE ] ; public static RegularExpression createRegex ( String pattern , String options ) throws ParseException { RegularExpression re = null ; int intOptions = REUtil . parseOptions ( options ) ; synchronized ( REUtil . regexCache ) { int i ; for ( i = 0 ; i < REUtil . CACHESIZE ; i ++ ) { re = REUtil . regexCache [ i ] ; if ( re == null ) { i = - 1 ; break ; } if ( re . equals ( pattern , intOptions ) ) break ; } if ( re != null ) { if ( i != 0 ) { System . arraycopy ( REUtil . regexCache , 0 , REUtil . regexCache , 1 , i ) ; REUtil . regexCache [ 0 ] = re ; } } else { re = new RegularExpression ( pattern , options ) ; System . arraycopy ( REUtil . regexCache , 0 , REUtil . regexCache , 1 , REUtil . CACHESIZE - 1 ) ; REUtil . regexCache [ 0 ] = re ; } } return re ; } public static boolean matches ( String regex , String target ) throws ParseException { return REUtil . createRegex ( regex , null ) . matches ( target ) ; } public static boolean matches ( String regex , String options , String target ) throws ParseException { return REUtil . createRegex ( regex , options ) . matches ( target ) ; } public static String quoteMeta ( String literal ) { int len = literal . length ( ) ; StringBuffer buffer = null ; for ( int i = 0 ; i < len ; i ++ ) { int ch = literal . charAt ( i ) ; if ( ".*+?{[()|\\^$" . indexOf ( ch ) >= 0 ) { if ( buffer == null ) { buffer = new StringBuffer ( i + ( len - i ) * 2 ) ; if ( i > 0 ) buffer . append ( literal . substring ( 0 , i ) ) ; } buffer . append ( ( char ) '\\' ) ; } else if ( buffer != null ) buffer . append ( ( char ) ch ) ; } return buffer != null ? buffer . toString ( ) : literal ; } static void dumpString ( String v ) { for ( int i = 0 ; i < v . length ( ) ; i ++ ) { System . out . print ( Integer . toHexString ( v . charAt ( i ) ) ) ; System . out . print ( " " ) ; } System . out . println ( ) ; } } 	0
package org . apache . xml . serialize ; import java . util . Hashtable ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Node ; import org . w3c . dom . html . HTMLDocument ; public class OutputFormat { public static class DTD { public static final String HTMLPublicId = "-//W3C//DTD HTML 4.0//EN" ; public static final String HTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; public static final String XHTMLPublicId = "-//W3C//DTD XHTML 1.0 Strict//EN" ; public static final String XHTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; } public static class Defaults { public static final int Indent = 4 ; public static final String Encoding = "UTF-8" ; public static final int LineWidth = 72 ; } private String _method ; private String _version ; private int _indent = 0 ; private String _encoding = Defaults . Encoding ; private String _mediaType ; private String _doctypeSystem ; private String _doctypePublic ; private boolean _omitXmlDeclaration = false ; private boolean _omitDoctype = false ; private boolean _omitComments = false ; private boolean _stripComments = false ; private boolean _standalone = false ; private String [ ] _cdataElements ; private String [ ] _nonEscapingElements ; private String _lineSeparator = LineSeparator . Web ; private int _lineWidth = Defaults . LineWidth ; private boolean _preserve = false ; public OutputFormat ( ) { } public OutputFormat ( String method , String encoding , boolean indenting ) { setMethod ( method ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public OutputFormat ( Document doc ) { setMethod ( whichMethod ( doc ) ) ; setDoctype ( whichDoctypePublic ( doc ) , whichDoctypeSystem ( doc ) ) ; setMediaType ( whichMediaType ( getMethod ( ) ) ) ; } public OutputFormat ( Document doc , String encoding , boolean indenting ) { this ( doc ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public String getMethod ( ) { return _method ; } public void setMethod ( String method ) { _method = method ; } public String getVersion ( ) { return _version ; } public void setVersion ( String version ) { _version = version ; } public int getIndent ( ) { return _indent ; } public boolean getIndenting ( ) { return ( _indent > 0 ) ; } public void setIndent ( int indent ) { if ( indent < 0 ) _indent = 0 ; else _indent = indent ; } public void setIndenting ( boolean on ) { if ( on ) { _indent = Defaults . Indent ; _lineWidth = Defaults . LineWidth ; } else { _indent = 0 ; _lineWidth = 0 ; } } public String getEncoding ( ) { return _encoding ; } public void setEncoding ( String encoding ) { _encoding = encoding ; } public String getMediaType ( ) { return _mediaType ; } public void setMediaType ( String mediaType ) { _mediaType = mediaType ; } public void setDoctype ( String publicId , String systemId ) { _doctypePublic = publicId ; _doctypeSystem = systemId ; } public String getDoctypePublic ( ) { return _doctypePublic ; } public String getDoctypeSystem ( ) { return _doctypeSystem ; } public boolean getOmitComments ( ) { return _omitComments ; } public void setOmitComments ( boolean omit ) { _omitComments = omit ; } public boolean getOmitDocumentType ( ) { return _omitDoctype ; } public void setOmitDocumentType ( boolean omit ) { _omitDoctype = omit ; } public boolean getOmitXMLDeclaration ( ) { return _omitXmlDeclaration ; } public void setOmitXMLDeclaration ( boolean omit ) { _omitXmlDeclaration = omit ; } public boolean getStandalone ( ) { return _standalone ; } public void setStandalone ( boolean standalone ) { _standalone = standalone ; } public String [ ] getCDataElements ( ) { return _cdataElements ; } public boolean isCDataElement ( String tagName ) { int i ; if ( _cdataElements == null ) return false ; for ( i = 0 ; i < _cdataElements . length ; ++ i ) if ( _cdataElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setCDataElements ( String [ ] cdataElements ) { _cdataElements = cdataElements ; } public String [ ] getNonEscapingElements ( ) { return _nonEscapingElements ; } public boolean isNonEscapingElement ( String tagName ) { int i ; if ( _nonEscapingElements == null ) return false ; for ( i = 0 ; i < _nonEscapingElements . length ; ++ i ) if ( _nonEscapingElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setNonEscapingElements ( String [ ] nonEscapingElements ) { _nonEscapingElements = nonEscapingElements ; } public String getLineSeparator ( ) { return _lineSeparator ; } public void setLineSeparator ( String lineSeparator ) { if ( lineSeparator == null ) _lineSeparator = LineSeparator . Web ; else _lineSeparator = lineSeparator ; } public boolean getPreserveSpace ( ) { return _preserve ; } public void setPreserveSpace ( boolean preserve ) { _preserve = preserve ; } public int getLineWidth ( ) { return _lineWidth ; } public void setLineWidth ( int lineWidth ) { if ( lineWidth <= 0 ) _lineWidth = 0 ; else _lineWidth = lineWidth ; } public char getLastPrintable ( ) { if ( getEncoding ( ) != null && ( getEncoding ( ) . equalsIgnoreCase ( "ASCII" ) ) ) return 0xFF ; else return 0xFFFF ; } public static String whichMethod ( Document doc ) { Node node ; String value ; int i ; if ( doc instanceof HTMLDocument ) return Method . HTML ; node = doc . getFirstChild ( ) ; while ( node != null ) { if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( node . getNodeName ( ) . equalsIgnoreCase ( "html" ) ) { return Method . HTML ; } else if ( node . getNodeName ( ) . equalsIgnoreCase ( "root" ) ) { return Method . FOP ; } else { return Method . XML ; } } else if ( node . getNodeType ( ) == Node . TEXT_NODE ) { value = node . getNodeValue ( ) ; for ( i = 0 ; i < value . length ( ) ; ++ i ) if ( value . charAt ( i ) != 0x20 && value . charAt ( i ) != 0x0A && value . charAt ( i ) != 0x09 && value . charAt ( i ) != 0x0D ) return Method . XML ; } node = node . getNextSibling ( ) ; } return Method . XML ; } public static String whichDoctypePublic ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLPublicId ; return null ; } public static String whichDoctypeSystem ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLSystemId ; return null ; } public static String whichMediaType ( String method ) { if ( method . equalsIgnoreCase ( Method . XML ) ) return "text/xml" ; if ( method . equalsIgnoreCase ( Method . HTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . XHTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . TEXT ) ) return "text/plain" ; if ( method . equalsIgnoreCase ( Method . FOP ) ) return "application/pdf" ; return null ; } } 	1
package org . apache . xerces . utils . regex ; final class RangeToken extends Token implements java . io . Serializable { int [ ] ranges ; boolean sorted ; boolean compacted ; RangeToken icaseCache = null ; int [ ] map = null ; int nonMapIndex ; RangeToken ( int type ) { super ( type ) ; this . setSorted ( false ) ; } protected void addRange ( int start , int end ) { this . icaseCache = null ; int r1 , r2 ; if ( start <= end ) { r1 = start ; r2 = end ; } else { r1 = end ; r2 = start ; } int pos = 0 ; if ( this . ranges == null ) { this . ranges = new int [ 2 ] ; this . ranges [ 0 ] = r1 ; this . ranges [ 1 ] = r2 ; this . setSorted ( true ) ; } else { pos = this . ranges . length ; if ( this . ranges [ pos - 1 ] + 1 == r1 ) { this . ranges [ pos - 1 ] = r2 ; return ; } int [ ] temp = new int [ pos + 2 ] ; System . arraycopy ( this . ranges , 0 , temp , 0 , pos ) ; this . ranges = temp ; if ( this . ranges [ pos - 1 ] >= r1 ) this . setSorted ( false ) ; this . ranges [ pos ++ ] = r1 ; this . ranges [ pos ] = r2 ; if ( ! this . sorted ) this . sortRanges ( ) ; } } private final boolean isSorted ( ) { return this . sorted ; } private final void setSorted ( boolean sort ) { this . sorted = sort ; if ( ! sort ) this . compacted = false ; } private final boolean isCompacted ( ) { return this . compacted ; } private final void setCompacted ( ) { this . compacted = true ; } protected void sortRanges ( ) { if ( this . isSorted ( ) ) return ; if ( this . ranges == null ) return ; for ( int i = this . ranges . length - 4 ; i >= 0 ; i -= 2 ) { for ( int j = 0 ; j <= i ; j += 2 ) { if ( this . ranges [ j ] > this . ranges [ j + 2 ] || this . ranges [ j ] == this . ranges [ j + 2 ] && this . ranges [ j + 1 ] > this . ranges [ j + 3 ] ) { int tmp ; tmp = this . ranges [ j + 2 ] ; this . ranges [ j + 2 ] = this . ranges [ j ] ; this . ranges [ j ] = tmp ; tmp = this . ranges [ j + 3 ] ; this . ranges [ j + 3 ] = this . ranges [ j + 1 ] ; this . ranges [ j + 1 ] = tmp ; } } } this . setSorted ( true ) ; } protected void compactRanges ( ) { boolean DEBUG = false ; if ( this . ranges == null || this . ranges . length <= 2 ) return ; if ( this . isCompacted ( ) ) return ; int base = 0 ; int target = 0 ; while ( target < this . ranges . length ) { if ( base != target ) { this . ranges [ base ] = this . ranges [ target ++ ] ; this . ranges [ base + 1 ] = this . ranges [ target ++ ] ; } else target += 2 ; int baseend = this . ranges [ base + 1 ] ; while ( target < this . ranges . length ) { if ( baseend + 1 < this . ranges [ target ] ) break ; if ( baseend + 1 == this . ranges [ target ] ) { if ( DEBUG ) System . err . println ( "Token#compactRanges(): Compaction: [" + this . ranges [ base ] + ", " + this . ranges [ base + 1 ] + "], [" + this . ranges [ target ] + ", " + this . ranges [ target + 1 ] + "] -> [" + this . ranges [ base ] + ", " + this . ranges [ target + 1 ] + "]" ) ; this . ranges [ base + 1 ] = this . ranges [ target + 1 ] ; baseend = this . ranges [ base + 1 ] ; target += 2 ; } else if ( baseend >= this . ranges [ target + 1 ] ) { if ( DEBUG ) System . err . println ( "Token#compactRanges(): Compaction: [" + this . ranges [ base ] + ", " + this . ranges [ base + 1 ] + "], [" + this . ranges [ target ] + ", " + this . ranges [ target + 1 ] + "] -> [" + this . ranges [ base ] + ", " + this . ranges [ base + 1 ] + "]" ) ; target += 2 ; } else if ( baseend < this . ranges [ target + 1 ] ) { if ( DEBUG ) System . err . println ( "Token#compactRanges(): Compaction: [" + this . ranges [ base ] + ", " + this . ranges [ base + 1 ] + "], [" + this . ranges [ target ] + ", " + this . ranges [ target + 1 ] + "] -> [" + this . ranges [ base ] + ", " + this . ranges [ target + 1 ] + "]" ) ; this . ranges [ base + 1 ] = this . ranges [ target + 1 ] ; baseend = this . ranges [ base + 1 ] ; target += 2 ; } else { throw new RuntimeException ( "Token#compactRanges(): Internel Error: [" + this . ranges [ base ] + "," + this . ranges [ base + 1 ] + "] [" + this . ranges [ target ] + "," + this . ranges [ target + 1 ] + "]" ) ; } } base += 2 ; } if ( base != this . ranges . length ) { int [ ] result = new int [ base ] ; System . arraycopy ( this . ranges , 0 , result , 0 , base ) ; this . ranges = result ; } this . setCompacted ( ) ; } protected void mergeRanges ( Token token ) { if ( token . type != this . type ) throw new IllegalArgumentException ( "Token#mergeRanges(): Mismatched Type: " + token . type ) ; RangeToken tok = ( RangeToken ) token ; this . sortRanges ( ) ; tok . sortRanges ( ) ; if ( tok . ranges == null ) return ; this . icaseCache = null ; this . setSorted ( true ) ; if ( this . ranges == null ) { this . ranges = new int [ tok . ranges . length ] ; System . arraycopy ( tok . ranges , 0 , this . ranges , 0 , tok . ranges . length ) ; return ; } int [ ] result = new int [ this . ranges . length + tok . ranges . length ] ; for ( int i = 0 , j = 0 , k = 0 ; i < this . ranges . length || j < tok . ranges . length ; ) { if ( i >= this . ranges . length ) { result [ k ++ ] = tok . ranges [ j ++ ] ; result [ k ++ ] = tok . ranges [ j ++ ] ; } else if ( j >= tok . ranges . length ) { result [ k ++ ] = this . ranges [ i ++ ] ; result [ k ++ ] = this . ranges [ i ++ ] ; } else if ( tok . ranges [ j ] < this . ranges [ i ] || tok . ranges [ j ] == this . ranges [ i ] && tok . ranges [ j + 1 ] < this . ranges [ i + 1 ] ) { result [ k ++ ] = tok . ranges [ j ++ ] ; result [ k ++ ] = tok . ranges [ j ++ ] ; } else { result [ k ++ ] = this . ranges [ i ++ ] ; result [ k ++ ] = this . ranges [ i ++ ] ; } } this . ranges = result ; } protected void subtractRanges ( Token token ) { if ( token . type == NRANGE ) { this . intersectRanges ( token ) ; return ; } RangeToken tok = ( RangeToken ) token ; if ( tok . ranges == null || this . ranges == null ) return ; this . icaseCache = null ; this . sortRanges ( ) ; this . compactRanges ( ) ; tok . sortRanges ( ) ; tok . compactRanges ( ) ; int [ ] result = new int [ this . ranges . length + tok . ranges . length ] ; int wp = 0 , src = 0 , sub = 0 ; while ( src < this . ranges . length && sub < tok . ranges . length ) { int srcbegin = this . ranges [ src ] ; int srcend = this . ranges [ src + 1 ] ; int subbegin = tok . ranges [ sub ] ; int subend = tok . ranges [ sub + 1 ] ; if ( srcend < subbegin ) { result [ wp ++ ] = this . ranges [ src ++ ] ; result [ wp ++ ] = this . ranges [ src ++ ] ; } else if ( srcend >= subbegin && srcbegin <= subend ) { if ( subbegin <= srcbegin && srcend <= subend ) { src += 2 ; } else if ( subbegin <= srcbegin ) { this . ranges [ src ] = subend + 1 ; sub += 2 ; } else if ( srcend <= subend ) { result [ wp ++ ] = srcbegin ; result [ wp ++ ] = subbegin - 1 ; src += 2 ; } else { result [ wp ++ ] = srcbegin ; result [ wp ++ ] = subbegin - 1 ; this . ranges [ src ] = subend + 1 ; sub += 2 ; } } else if ( subend < srcbegin ) { sub += 2 ; } else { throw new RuntimeException ( "Token#subtractRanges(): Internal Error: [" + this . ranges [ src ] + "," + this . ranges [ src + 1 ] + "] - [" + tok . ranges [ sub ] + "," + tok . ranges [ sub + 1 ] + "]" ) ; } } while ( src < this . ranges . length ) { result [ wp ++ ] = this . ranges [ src ++ ] ; result [ wp ++ ] = this . ranges [ src ++ ] ; } this . ranges = new int [ wp ] ; System . arraycopy ( result , 0 , this . ranges , 0 , wp ) ; } protected void intersectRanges ( Token token ) { RangeToken tok = ( RangeToken ) token ; if ( tok . ranges == null || this . ranges == null ) return ; this . icaseCache = null ; this . sortRanges ( ) ; this . compactRanges ( ) ; tok . sortRanges ( ) ; tok . compactRanges ( ) ; int [ ] result = new int [ this . ranges . length + tok . ranges . length ] ; int wp = 0 , src1 = 0 , src2 = 0 ; while ( src1 < this . ranges . length && src2 < tok . ranges . length ) { int src1begin = this . ranges [ src1 ] ; int src1end = this . ranges [ src1 + 1 ] ; int src2begin = tok . ranges [ src2 ] ; int src2end = tok . ranges [ src2 + 1 ] ; if ( src1end < src2begin ) { src1 += 2 ; } else if ( src1end >= src2begin && src1begin <= src2end ) { if ( src2begin <= src2begin && src1end <= src2end ) { result [ wp ++ ] = src1begin ; result [ wp ++ ] = src1end ; src1 += 2 ; } else if ( src2begin <= src1begin ) { result [ wp ++ ] = src1begin ; result [ wp ++ ] = src2end ; this . ranges [ src1 ] = src2end + 1 ; src2 += 2 ; } else if ( src1end <= src2end ) { result [ wp ++ ] = src2begin ; result [ wp ++ ] = src1end ; src1 += 2 ; } else { result [ wp ++ ] = src2begin ; result [ wp ++ ] = src2end ; this . ranges [ src1 ] = src2end + 1 ; } } else if ( src2end < src1begin ) { src2 += 2 ; } else { throw new RuntimeException ( "Token#intersectRanges(): Internal Error: [" + this . ranges [ src1 ] + "," + this . ranges [ src1 + 1 ] + "] & [" + tok . ranges [ src2 ] + "," + tok . ranges [ src2 + 1 ] + "]" ) ; } } while ( src1 < this . ranges . length ) { result [ wp ++ ] = this . ranges [ src1 ++ ] ; result [ wp ++ ] = this . ranges [ src1 ++ ] ; } this . ranges = new int [ wp ] ; System . arraycopy ( result , 0 , this . ranges , 0 , wp ) ; } static Token complementRanges ( Token token ) { if ( token . type != RANGE && token . type != NRANGE ) throw new IllegalArgumentException ( "Token#complementRanges(): must be RANGE: " + token . type ) ; RangeToken tok = ( RangeToken ) token ; tok . sortRanges ( ) ; tok . compactRanges ( ) ; int len = tok . ranges . length + 2 ; if ( tok . ranges [ 0 ] == 0 ) len -= 2 ; int last = tok . ranges [ tok . ranges . length - 1 ] ; if ( last == UTF16_MAX ) len -= 2 ; RangeToken ret = Token . createRange ( ) ; ret . ranges = new int [ len ] ; int wp = 0 ; if ( tok . ranges [ 0 ] > 0 ) { ret . ranges [ wp ++ ] = 0 ; ret . ranges [ wp ++ ] = tok . ranges [ 0 ] - 1 ; } for ( int i = 1 ; i < tok . ranges . length - 2 ; i += 2 ) { ret . ranges [ wp ++ ] = tok . ranges [ i ] + 1 ; ret . ranges [ wp ++ ] = tok . ranges [ i + 1 ] - 1 ; } if ( last != UTF16_MAX ) { ret . ranges [ wp ++ ] = last + 1 ; ret . ranges [ wp ] = UTF16_MAX ; } ret . setCompacted ( ) ; return ret ; } synchronized RangeToken getCaseInsensitiveToken ( ) { if ( this . icaseCache != null ) return this . icaseCache ; RangeToken uppers = this . type == Token . RANGE ? Token . createRange ( ) : Token . createNRange ( ) ; for ( int i = 0 ; i < this . ranges . length ; i += 2 ) { for ( int ch = this . ranges [ i ] ; ch <= this . ranges [ i + 1 ] ; ch ++ ) { if ( ch > 0xffff ) uppers . addRange ( ch , ch ) ; else { char uch = Character . toUpperCase ( ( char ) ch ) ; uppers . addRange ( uch , uch ) ; } } } RangeToken lowers = this . type == Token . RANGE ? Token . createRange ( ) : Token . createNRange ( ) ; for ( int i = 0 ; i < uppers . ranges . length ; i += 2 ) { for ( int ch = uppers . ranges [ i ] ; ch <= uppers . ranges [ i + 1 ] ; ch ++ ) { if ( ch > 0xffff ) lowers . addRange ( ch , ch ) ; else { char uch = Character . toUpperCase ( ( char ) ch ) ; lowers . addRange ( uch , uch ) ; } } } lowers . mergeRanges ( uppers ) ; lowers . mergeRanges ( this ) ; lowers . compactRanges ( ) ; this . icaseCache = lowers ; return lowers ; } void dumpRanges ( ) { System . err . print ( "RANGE: " ) ; if ( this . ranges == null ) System . err . println ( " NULL" ) ; for ( int i = 0 ; i < this . ranges . length ; i += 2 ) { System . err . print ( "[" + this . ranges [ i ] + "," + this . ranges [ i + 1 ] + "] " ) ; } System . err . println ( "" ) ; } boolean match ( int ch ) { if ( this . map == null ) this . createMap ( ) ; boolean ret ; if ( this . type == RANGE ) { if ( ch < MAPSIZE ) return ( this . map [ ch / 32 ] & ( 1 << ( ch & 0x1f ) ) ) != 0 ; ret = false ; for ( int i = this . nonMapIndex ; i < this . ranges . length ; i += 2 ) { if ( this . ranges [ i ] <= ch && ch <= this . ranges [ i + 1 ] ) return true ; } } else { if ( ch < MAPSIZE ) return ( this . map [ ch / 32 ] & ( 1 << ( ch & 0x1f ) ) ) == 0 ; ret = true ; for ( int i = this . nonMapIndex ; i < this . ranges . length ; i += 2 ) { if ( this . ranges [ i ] <= ch && ch <= this . ranges [ i + 1 ] ) return false ; } } return ret ; } private static final int MAPSIZE = 256 ; private void createMap ( ) { int asize = MAPSIZE / 32 ; this . map = new int [ asize ] ; this . nonMapIndex = this . ranges . length ; for ( int i = 0 ; i < asize ; i ++ ) this . map [ i ] = 0 ; for ( int i = 0 ; i < this . ranges . length ; i += 2 ) { int s = this . ranges [ i ] ; int e = this . ranges [ i + 1 ] ; if ( s < MAPSIZE ) { for ( int j = s ; j <= e && j < MAPSIZE ; j ++ ) this . map [ j / 32 ] |= 1 << ( j & 0x1f ) ; } else { this . nonMapIndex = i ; break ; } if ( e >= MAPSIZE ) { this . nonMapIndex = i ; break ; } } } public String toString ( int options ) { String ret ; if ( this . type == RANGE ) { if ( this == Token . token_dot ) ret = "." ; else if ( this == Token . token_0to9 ) ret = "\\d" ; else if ( this == Token . token_wordchars ) ret = "\\w" ; else if ( this == Token . token_spaces ) ret = "\\s" ; else { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "[" ) ; for ( int i = 0 ; i < this . ranges . length ; i += 2 ) { if ( ( options & RegularExpression . SPECIAL_COMMA ) != 0 && i > 0 ) sb . append ( "," ) ; if ( this . ranges [ i ] == this . ranges [ i + 1 ] ) { sb . append ( escapeCharInCharClass ( this . ranges [ i ] ) ) ; } else { sb . append ( escapeCharInCharClass ( this . ranges [ i ] ) ) ; sb . append ( ( char ) '-' ) ; sb . append ( escapeCharInCharClass ( this . ranges [ i + 1 ] ) ) ; } } sb . append ( "]" ) ; ret = sb . toString ( ) ; } } else { if ( this == Token . token_not_0to9 ) ret = "\\D" ; else if ( this == Token . token_not_wordchars ) ret = "\\W" ; else if ( this == Token . token_not_spaces ) ret = "\\S" ; else { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "[^" ) ; for ( int i = 0 ; i < this . ranges . length ; i += 2 ) { if ( ( options & RegularExpression . SPECIAL_COMMA ) != 0 && i > 0 ) sb . append ( "," ) ; if ( this . ranges [ i ] == this . ranges [ i + 1 ] ) { sb . append ( escapeCharInCharClass ( this . ranges [ i ] ) ) ; } else { sb . append ( escapeCharInCharClass ( this . ranges [ i ] ) ) ; sb . append ( '-' ) ; sb . append ( escapeCharInCharClass ( this . ranges [ i + 1 ] ) ) ; } } sb . append ( "]" ) ; ret = sb . toString ( ) ; } } return ret ; } private static String escapeCharInCharClass ( int ch ) { String ret ; switch ( ch ) { case '[' : case ']' : case '-' : case '^' : case ',' : case '\\' : ret = "\\" + ( char ) ch ; break ; case '\f' : ret = "\\f" ; break ; case '\n' : ret = "\\n" ; break ; case '\r' : ret = "\\r" ; break ; case '\t' : ret = "\\t" ; break ; case 0x1b : ret = "\\e" ; break ; default : if ( ch < 0x20 ) { String pre = "0" + Integer . toHexString ( ch ) ; ret = "\\x" + pre . substring ( pre . length ( ) - 2 , pre . length ( ) ) ; } else if ( ch >= 0x10000 ) { String pre = "0" + Integer . toHexString ( ch ) ; ret = "\\v" + pre . substring ( pre . length ( ) - 6 , pre . length ( ) ) ; } else ret = "" + ( char ) ch ; } return ret ; } } 	0
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public abstract class SAXParser { protected SAXParser ( ) { super ( ) ; } public void parse ( InputStream stream , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( stream ) , base ) ; } public void parse ( String uri , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( uri ) , base ) ; } public void parse ( File file , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; String path = file . getAbsolutePath ( ) ; if ( File . separatorChar != '/' ) { path = path . replace ( File . separatorChar , '/' ) ; } if ( ! path . startsWith ( "/" ) ) { path = "/" + path ; } if ( ! path . endsWith ( "/" ) && file . isDirectory ( ) ) { path = path + "/" ; } java . net . URL url = new java . net . URL ( "file" , "" , path ) ; this . parse ( new InputSource ( url . toString ( ) ) , base ) ; } public void parse ( InputSource source , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( source == null ) throw new IllegalArgumentException ( ) ; Parser p = this . getParser ( ) ; if ( base != null ) { p . setDocumentHandler ( base ) ; p . setDTDHandler ( base ) ; p . setEntityResolver ( base ) ; p . setErrorHandler ( base ) ; } p . parse ( source ) ; } public abstract Parser getParser ( ) throws SAXException ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; } 	1
package org . apache . xerces . validators . common ; public class CMException extends Exception { public CMException ( int errCode ) { fErrorCode = errCode ; } public int getErrorCode ( ) { return fErrorCode ; } static final int fUnused = - 1000 ; private int fErrorCode ; } ; 	0
package org . w3c . dom ; public interface Element extends Node { public String getTagName ( ) ; public String getAttribute ( String name ) ; public void setAttribute ( String name , String value ) throws DOMException ; public void removeAttribute ( String name ) throws DOMException ; public Attr getAttributeNode ( String name ) ; public Attr setAttributeNode ( Attr newAttr ) throws DOMException ; public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException ; public NodeList getElementsByTagName ( String name ) ; public String getAttributeNS ( String namespaceURI , String localName ) ; public void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException ; public void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException ; public Attr getAttributeNodeNS ( String namespaceURI , String localName ) ; public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public boolean hasAttribute ( String name ) ; public boolean hasAttributeNS ( String namespaceURI , String localName ) ; } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import java . io . InputStream ; public interface XMLEntityHandler extends Locator { public static final int CHARREF_RESULT_SEMICOLON_REQUIRED = - 1 , CHARREF_RESULT_INVALID_CHAR = - 2 , CHARREF_RESULT_OUT_OF_RANGE = - 3 ; public static final int STRINGLIT_RESULT_QUOTE_REQUIRED = - 1 , STRINGLIT_RESULT_INVALID_CHAR = - 2 ; public static final int ATTVALUE_RESULT_COMPLEX = - 1 , ATTVALUE_RESULT_LESSTHAN = - 2 , ATTVALUE_RESULT_INVALID_CHAR = - 3 ; public static final int ENTITYVALUE_RESULT_FINISHED = - 1 , ENTITYVALUE_RESULT_REFERENCE = - 2 , ENTITYVALUE_RESULT_PEREF = - 3 , ENTITYVALUE_RESULT_INVALID_CHAR = - 4 , ENTITYVALUE_RESULT_END_OF_INPUT = - 5 ; public static final int CONTENT_RESULT_START_OF_PI = 0 , CONTENT_RESULT_START_OF_COMMENT = 1 , CONTENT_RESULT_START_OF_CDSECT = 2 , CONTENT_RESULT_END_OF_CDSECT = 3 , CONTENT_RESULT_START_OF_ETAG = 4 , CONTENT_RESULT_MATCHING_ETAG = 5 , CONTENT_RESULT_START_OF_ELEMENT = 6 , CONTENT_RESULT_START_OF_CHARREF = 7 , CONTENT_RESULT_START_OF_ENTITYREF = 8 , CONTENT_RESULT_INVALID_CHAR = 9 , CONTENT_RESULT_MARKUP_NOT_RECOGNIZED = 10 , CONTENT_RESULT_MARKUP_END_OF_INPUT = 11 , CONTENT_RESULT_REFERENCE_END_OF_INPUT = 12 ; public static final int ENTITYTYPE_INTERNAL_PE = 0 , ENTITYTYPE_EXTERNAL_PE = 1 , ENTITYTYPE_INTERNAL = 2 , ENTITYTYPE_EXTERNAL = 3 , ENTITYTYPE_UNPARSED = 4 , ENTITYTYPE_DOCUMENT = 5 , ENTITYTYPE_EXTERNAL_SUBSET = 6 ; public static final int ENTITYREF_IN_ATTVALUE = 0 , ENTITYREF_IN_DEFAULTATTVALUE = 1 , ENTITYREF_IN_CONTENT = 2 , ENTITYREF_IN_DTD_AS_MARKUP = 3 , ENTITYREF_IN_ENTITYVALUE = 4 , ENTITYREF_IN_DTD_WITHIN_MARKUP = 5 , ENTITYREF_DOCUMENT = 6 , ENTITYREF_EXTERNAL_SUBSET = 7 ; public boolean startReadingFromDocument ( InputSource source ) throws Exception ; public boolean startReadingFromEntity ( int entityName , int readerDepth , int entityContext ) throws Exception ; public String expandSystemId ( String systemId ) ; public interface DTDHandler { public void startReadingFromExternalSubset ( String publicId , String systemId , int readerDepth ) throws Exception ; public void stopReadingFromExternalSubset ( ) throws Exception ; public boolean startEntityDecl ( boolean isPE , int entityName ) throws Exception ; public void endEntityDecl ( ) throws Exception ; public int addInternalPEDecl ( int entityName , int value , boolean isExternal ) throws Exception ; public int addExternalPEDecl ( int entityName , int publicId , int systemId , boolean isExternal ) throws Exception ; public int addInternalEntityDecl ( int entityName , int value , boolean isExternal ) throws Exception ; public int addExternalEntityDecl ( int entityName , int publicId , int systemId , boolean isExternal ) throws Exception ; public int addUnparsedEntityDecl ( int entityName , int publicId , int systemId , int notationName , boolean isExternal ) throws Exception ; public int addNotationDecl ( int notationName , int publicId , int systemId , boolean isExternal ) throws Exception ; public boolean isUnparsedEntity ( int entityName ) ; public boolean isNotationDeclared ( int entityName ) ; public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) ; public void checkRequiredNotations ( ) throws Exception ; } public int getReaderId ( ) ; public void setReaderDepth ( int depth ) ; public int getReaderDepth ( ) ; public EntityReader getEntityReader ( ) ; public EntityReader changeReaders ( ) throws Exception ; public interface CharBuffer { public void append ( char ch ) ; public void append ( char [ ] chars , int offset , int length ) ; public int length ( ) ; public int addString ( int offset , int length ) ; } public void setCharDataHandler ( XMLEntityHandler . CharDataHandler charDataHandler ) ; public XMLEntityHandler . CharDataHandler getCharDataHandler ( ) ; public interface CharDataHandler { public void processCharacters ( char [ ] chars , int offset , int length ) throws Exception ; public void processCharacters ( int stringHandle ) throws Exception ; public void processWhitespace ( char [ ] chars , int offset , int length ) throws Exception ; public void processWhitespace ( int stringHandle ) throws Exception ; } public interface EntityReader { public int currentOffset ( ) ; public int getLineNumber ( ) ; public int getColumnNumber ( ) ; public void setInCDSect ( boolean inCDSect ) ; public boolean getInCDSect ( ) ; public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) ; public int addString ( int offset , int length ) ; public int addSymbol ( int offset , int length ) ; public boolean lookingAtChar ( char ch , boolean skipPastChar ) throws Exception ; public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception ; public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception ; public void skipToChar ( char ch ) throws Exception ; public void skipPastSpaces ( ) throws Exception ; public void skipPastName ( char fastcheck ) throws Exception ; public void skipPastNmtoken ( char fastcheck ) throws Exception ; public boolean skippedString ( char [ ] s ) throws Exception ; public int scanInvalidChar ( ) throws Exception ; public int scanCharRef ( boolean isHexadecimal ) throws Exception ; public int scanStringLiteral ( ) throws Exception ; public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception ; public int scanEntityValue ( int qchar , boolean createString ) throws Exception ; public int scanName ( char fastcheck ) throws Exception ; public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception ; public void scanQName ( char fastcheck , QName qname ) throws Exception ; public int scanContent ( QName element ) throws Exception ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class NotationImpl extends NodeImpl implements Notation { static final long serialVersionUID = - 764632195890658402L ; protected String name ; protected String publicId ; protected String systemId ; public NotationImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; } public short getNodeType ( ) { return Node . NOTATION_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public String getPublicId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return publicId ; } public String getSystemId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return systemId ; } public void setPublicId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } publicId = id ; } public void setSystemId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } systemId = id ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLStrongElementImpl extends WMLElementImpl implements WMLStrongElement { public WMLStrongElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom . events ; public interface EventListener { public void handleEvent ( Event evt ) ; } 	1
package org . apache . xerces . utils ; import java . lang . * ; public final class Base64 { static private final int BASELENGTH = 255 ; static private final int LOOKUPLENGTH = 64 ; static private final int TWENTYFOURBITGROUP = 24 ; static private final int EIGHTBIT = 8 ; static private final int SIXTEENBIT = 16 ; static private final int SIXBIT = 6 ; static private final int FOURBYTE = 4 ; static private final int SIGN = - 128 ; static private final byte PAD = ( byte ) '=' ; static private final boolean fDebug = false ; static private byte [ ] base64Alphabet = new byte [ BASELENGTH ] ; static private byte [ ] lookUpBase64Alphabet = new byte [ LOOKUPLENGTH ] ; static { for ( int i = 0 ; i < BASELENGTH ; i ++ ) { base64Alphabet [ i ] = - 1 ; } for ( int i = 'Z' ; i >= 'A' ; i -- ) { base64Alphabet [ i ] = ( byte ) ( i - 'A' ) ; } for ( int i = 'z' ; i >= 'a' ; i -- ) { base64Alphabet [ i ] = ( byte ) ( i - 'a' + 26 ) ; } for ( int i = '9' ; i >= '0' ; i -- ) { base64Alphabet [ i ] = ( byte ) ( i - '0' + 52 ) ; } base64Alphabet [ '+' ] = 62 ; base64Alphabet [ '/' ] = 63 ; for ( int i = 0 ; i <= 25 ; i ++ ) lookUpBase64Alphabet [ i ] = ( byte ) ( 'A' + i ) ; for ( int i = 26 , j = 0 ; i <= 51 ; i ++ , j ++ ) lookUpBase64Alphabet [ i ] = ( byte ) ( 'a' + j ) ; for ( int i = 52 , j = 0 ; i <= 61 ; i ++ , j ++ ) lookUpBase64Alphabet [ i ] = ( byte ) ( '0' + j ) ; lookUpBase64Alphabet [ 62 ] = ( byte ) '+' ; lookUpBase64Alphabet [ 63 ] = ( byte ) '/' ; } public static boolean isBase64 ( String isValidString ) { return ( isArrayByteBase64 ( isValidString . getBytes ( ) ) ) ; } public static boolean isBase64 ( byte octect ) { return ( octect == PAD || base64Alphabet [ octect ] != - 1 ) ; } public static boolean isArrayByteBase64 ( byte [ ] arrayOctect ) { int length = arrayOctect . length ; if ( length == 0 ) return false ; for ( int i = 0 ; i < length ; i ++ ) { if ( Base64 . isBase64 ( arrayOctect [ i ] ) == false ) return false ; } return true ; } public static byte [ ] encode ( byte [ ] binaryData ) { int lengthDataBits = binaryData . length * EIGHTBIT ; int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP ; byte encodedData [ ] = null ; if ( fewerThan24bits != 0 ) encodedData = new byte [ ( numberTriplets + 1 ) * 4 ] ; else encodedData = new byte [ numberTriplets * 4 ] ; byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; int i = 0 ; if ( fDebug ) { System . out . println ( "number of triplets = " + numberTriplets ) ; } for ( i = 0 ; i < numberTriplets ; i ++ ) { dataIndex = i * 3 ; b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; b3 = binaryData [ dataIndex + 2 ] ; if ( fDebug ) { System . out . println ( "b1= " + b1 + ", b2= " + b2 + ", b3= " + b3 ) ; } l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; encodedIndex = i * 4 ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; byte val3 = ( ( b3 & SIGN ) == 0 ) ? ( byte ) ( b3 > > 6 ) : ( byte ) ( ( b3 ) > > 6 ^ 0xfc ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; if ( fDebug ) { System . out . println ( "val2 = " + val2 ) ; System . out . println ( "k4   = " + ( k << 4 ) ) ; System . out . println ( "vak  = " + ( val2 | ( k << 4 ) ) ) ; } encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ ( l << 2 ) | val3 ] ; encodedData [ encodedIndex + 3 ] = lookUpBase64Alphabet [ b3 & 0x3f ] ; } dataIndex = i * 3 ; encodedIndex = i * 4 ; if ( fewerThan24bits == EIGHTBIT ) { b1 = binaryData [ dataIndex ] ; k = ( byte ) ( b1 & 0x03 ) ; if ( fDebug ) { System . out . println ( "b1=" + b1 ) ; System . out . println ( "b1<<2 = " + ( b1 > > 2 ) ) ; } byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ k << 4 ] ; encodedData [ encodedIndex + 2 ] = PAD ; encodedData [ encodedIndex + 3 ] = PAD ; } else if ( fewerThan24bits == SIXTEENBIT ) { b1 = binaryData [ dataIndex ] ; b2 = binaryData [ dataIndex + 1 ] ; l = ( byte ) ( b2 & 0x0f ) ; k = ( byte ) ( b1 & 0x03 ) ; byte val1 = ( ( b1 & SIGN ) == 0 ) ? ( byte ) ( b1 > > 2 ) : ( byte ) ( ( b1 ) > > 2 ^ 0xc0 ) ; byte val2 = ( ( b2 & SIGN ) == 0 ) ? ( byte ) ( b2 > > 4 ) : ( byte ) ( ( b2 ) > > 4 ^ 0xf0 ) ; encodedData [ encodedIndex ] = lookUpBase64Alphabet [ val1 ] ; encodedData [ encodedIndex + 1 ] = lookUpBase64Alphabet [ val2 | ( k << 4 ) ] ; encodedData [ encodedIndex + 2 ] = lookUpBase64Alphabet [ l << 2 ] ; encodedData [ encodedIndex + 3 ] = PAD ; } return encodedData ; } public static byte [ ] decode ( byte [ ] base64Data ) { int numberQuadruple = base64Data . length / FOURBYTE ; byte decodedData [ ] = null ; byte b1 = 0 , b2 = 0 , b3 = 0 , b4 = 0 , marker0 = 0 , marker1 = 0 ; int encodedIndex = 0 ; int dataIndex = 0 ; decodedData = new byte [ numberQuadruple * 3 + 1 ] ; for ( int i = 0 ; i < numberQuadruple ; i ++ ) { dataIndex = i * 4 ; marker0 = base64Data [ dataIndex + 2 ] ; marker1 = base64Data [ dataIndex + 3 ] ; b1 = base64Alphabet [ base64Data [ dataIndex ] ] ; b2 = base64Alphabet [ base64Data [ dataIndex + 1 ] ] ; if ( marker0 != PAD && marker1 != PAD ) { b3 = base64Alphabet [ marker0 ] ; b4 = base64Alphabet [ marker1 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 << 6 | b4 ) ; } else if ( marker0 == PAD ) { decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( b2 & 0xf ) << 4 ) ; decodedData [ encodedIndex + 2 ] = ( byte ) 0 ; } else if ( marker1 == PAD ) { b3 = base64Alphabet [ marker0 ] ; decodedData [ encodedIndex ] = ( byte ) ( b1 << 2 | b2 > > 4 ) ; decodedData [ encodedIndex + 1 ] = ( byte ) ( ( ( b2 & 0xf ) << 4 ) | ( ( b3 > > 2 ) & 0xf ) ) ; decodedData [ encodedIndex + 2 ] = ( byte ) ( b3 << 6 ) ; } encodedIndex += 3 ; } return decodedData ; } } 	0
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface LexicalHandler { public abstract void startDTD ( String name , String publicId , String systemId ) throws SAXException ; public abstract void endDTD ( ) throws SAXException ; public abstract void startEntity ( String name ) throws SAXException ; public abstract void endEntity ( String name ) throws SAXException ; public abstract void startCDATA ( ) throws SAXException ; public abstract void endCDATA ( ) throws SAXException ; public abstract void comment ( char ch [ ] , int start , int length ) throws SAXException ; } 	1
package org . xml . sax ; public interface Attributes { public abstract int getLength ( ) ; public abstract String getURI ( int index ) ; public abstract String getLocalName ( int index ) ; public abstract String getQName ( int index ) ; public abstract String getType ( int index ) ; public abstract String getValue ( int index ) ; public int getIndex ( String uri , String localPart ) ; public int getIndex ( String qName ) ; public abstract String getType ( String uri , String localName ) ; public abstract String getType ( String qName ) ; public abstract String getValue ( String uri , String localName ) ; public abstract String getValue ( String qName ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrImpl extends ParentNode implements Attr { static final long serialVersionUID = 7277707688218972102L ; protected String name ; protected AttrImpl ( DocumentImpl ownerDocument , String name ) { super ( ownerDocument ) ; this . name = name ; isSpecified ( true ) ; } protected AttrImpl ( ) { } public Node cloneNode ( boolean deep ) { AttrImpl clone = ( AttrImpl ) super . cloneNode ( deep ) ; clone . isSpecified ( true ) ; return clone ; } public short getNodeType ( ) { return Node . ATTRIBUTE_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setNodeValue ( String value ) throws DOMException { setValue ( value ) ; } public String getNodeValue ( ) { return getValue ( ) ; } public String getName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setValue ( String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } LCount lc = null ; String oldvalue = "" ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 && ownerNode != null ) { oldvalue = getValue ( ) ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } while ( firstChild != null ) internalRemoveChild ( firstChild , MUTATION_LOCAL ) ; } else { if ( firstChild != null ) { firstChild . previousSibling = null ; firstChild . isFirstChild ( false ) ; firstChild = null ; } needsSyncChildren ( false ) ; } isSpecified ( true ) ; if ( value != null ) { internalInsertBefore ( ownerDocument . createTextNode ( value ) , null , MUTATION_LOCAL ) ; } changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( this , oldvalue ) ; } } public String getValue ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( firstChild == null ) { return "" ; } ChildNode node = firstChild . nextSibling ; if ( node == null ) { return firstChild . getNodeValue ( ) ; } StringBuffer value = new StringBuffer ( firstChild . getNodeValue ( ) ) ; while ( node != null ) { value . append ( node . getNodeValue ( ) ) ; node = node . nextSibling ; } return value . toString ( ) ; } public boolean getSpecified ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isSpecified ( ) ; } public Element getElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public Element getOwnerElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public void normalize ( ) { Node kid , next ; for ( kid = firstChild ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } } } public void setSpecified ( boolean arg ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isSpecified ( arg ) ; } public String toString ( ) { return getName ( ) + "=" + "\"" + getValue ( ) + "\"" ; } } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . CharDataChunk ; import org . apache . xerces . utils . StringPool ; import java . io . Reader ; final class CharReader extends AbstractCharReader { CharReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , Reader reader , StringPool stringPool ) throws Exception { super ( entityHandler , errorReporter , sendCharDataAsCharArray , stringPool ) ; fCharacterStream = reader ; fillCurrentChunk ( ) ; } private Reader fCharacterStream = null ; private boolean fCheckOverflow = false ; private char [ ] fOverflow = null ; private int fOverflowOffset = 0 ; private int fOverflowEnd = 0 ; private int fOutputOffset = 0 ; private boolean fSkipLinefeed = false ; protected int fillCurrentChunk ( ) throws Exception { char [ ] recycledData = fCurrentChunk . toCharArray ( ) ; fOutputOffset = 0 ; if ( fCheckOverflow ) { fMostRecentData = recycledData ; if ( fOverflowEnd < CharDataChunk . CHUNK_SIZE ) { recycledData = null ; if ( fOverflowEnd > 0 ) { if ( fMostRecentData == null || fMostRecentData . length < 1 + fOverflowEnd - fOverflowOffset ) fMostRecentData = new char [ 1 + fOverflowEnd - fOverflowOffset ] ; copyNormalize ( fOverflow , fOverflowOffset , fMostRecentData , fOutputOffset ) ; } else { if ( fMostRecentData == null ) fMostRecentData = new char [ 1 ] ; } fMostRecentData [ fOutputOffset ] = 0 ; fOverflow = null ; fLength += fOutputOffset ; fCurrentIndex = 0 ; fCurrentChunk . setCharArray ( fMostRecentData ) ; return ( fMostRecentChar = fMostRecentData [ 0 ] ) ; } if ( fMostRecentData == null || fMostRecentData . length < CharDataChunk . CHUNK_SIZE ) fMostRecentData = new char [ CharDataChunk . CHUNK_SIZE ] ; else recycledData = null ; copyNormalize ( fOverflow , fOverflowOffset , fMostRecentData , fOutputOffset ) ; fCheckOverflow = false ; } else { if ( fOverflow == null ) { fOverflow = recycledData ; if ( fOverflow == null || fOverflow . length < CharDataChunk . CHUNK_SIZE ) fOverflow = new char [ CharDataChunk . CHUNK_SIZE ] ; else recycledData = null ; } fMostRecentData = null ; } while ( true ) { fOverflowOffset = 0 ; fOverflowEnd = 0 ; int capacity = CharDataChunk . CHUNK_SIZE ; int result = 0 ; do { try { result = fCharacterStream . read ( fOverflow , fOverflowEnd , capacity ) ; } catch ( java . io . IOException ex ) { result = - 1 ; } if ( result == - 1 ) { fCharacterStream . close ( ) ; fCharacterStream = null ; if ( fMostRecentData == null ) { fMostRecentData = recycledData ; if ( fMostRecentData == null || fMostRecentData . length < 1 + fOverflowEnd ) fMostRecentData = new char [ 1 + fOverflowEnd ] ; else recycledData = null ; copyNormalize ( fOverflow , fOverflowOffset , fMostRecentData , fOutputOffset ) ; fOverflow = null ; fMostRecentData [ fOutputOffset ] = 0 ; } else { boolean alldone = copyNormalize ( fOverflow , fOverflowOffset , fMostRecentData , fOutputOffset ) ; if ( alldone ) { if ( fOverflowEnd == CharDataChunk . CHUNK_SIZE ) { fCheckOverflow = true ; fOverflowOffset = 0 ; fOverflowEnd = 0 ; } else { fOverflow = null ; fMostRecentData [ fOutputOffset ] = 0 ; } } else { fCheckOverflow = true ; } } break ; } if ( result > 0 ) { fOverflowEnd += result ; capacity -= result ; } } while ( capacity > 0 ) ; if ( result == - 1 ) break ; if ( fMostRecentData != null ) { boolean alldone = copyNormalize ( fOverflow , fOverflowOffset , fMostRecentData , fOutputOffset ) ; if ( fOutputOffset == CharDataChunk . CHUNK_SIZE ) { if ( ! alldone ) { fCheckOverflow = true ; } break ; } } else { fMostRecentData = recycledData ; if ( fMostRecentData == null || fMostRecentData . length < CharDataChunk . CHUNK_SIZE ) fMostRecentData = new char [ CharDataChunk . CHUNK_SIZE ] ; else recycledData = null ; copyNormalize ( fOverflow , fOverflowOffset , fMostRecentData , fOutputOffset ) ; if ( fOutputOffset == CharDataChunk . CHUNK_SIZE ) { break ; } } } fLength += fOutputOffset ; fCurrentIndex = 0 ; fCurrentChunk . setCharArray ( fMostRecentData ) ; return ( fMostRecentChar = fMostRecentData [ 0 ] ) ; } private boolean copyNormalize ( char [ ] in , int inOffset , char [ ] out , int outOffset ) throws Exception { int inEnd = fOverflowEnd ; int outEnd = out . length ; if ( inOffset == inEnd ) return true ; char b = in [ inOffset ] ; if ( fSkipLinefeed ) { fSkipLinefeed = false ; if ( b == 0x0A ) { if ( ++ inOffset == inEnd ) return exitNormalize ( inOffset , outOffset , true ) ; b = in [ inOffset ] ; } } while ( outOffset < outEnd ) { int inCount = inEnd - inOffset ; int outCount = outEnd - outOffset ; if ( inCount > outCount ) inCount = outCount ; inOffset ++ ; while ( true ) { while ( b == 0x0D ) { out [ outOffset ++ ] = 0x0A ; if ( inOffset == inEnd ) { fSkipLinefeed = true ; return exitNormalize ( inOffset , outOffset , true ) ; } b = in [ inOffset ] ; if ( b == 0x0A ) { if ( ++ inOffset == inEnd ) return exitNormalize ( inOffset , outOffset , true ) ; b = in [ inOffset ] ; } if ( outOffset == outEnd ) return exitNormalize ( inOffset , outOffset , false ) ; inCount = inEnd - inOffset ; outCount = outEnd - outOffset ; if ( inCount > outCount ) inCount = outCount ; inOffset ++ ; } while ( true ) { out [ outOffset ++ ] = b ; if ( -- inCount == 0 ) break ; b = in [ inOffset ++ ] ; if ( b == 0x0D ) break ; } if ( inCount == 0 ) break ; } if ( inOffset == inEnd ) break ; } return exitNormalize ( inOffset , outOffset , inOffset == inEnd ) ; } private boolean exitNormalize ( int inOffset , int outOffset , boolean result ) { fOverflowOffset = inOffset ; fOutputOffset = outOffset ; return result ; } } 	0
package org . w3c . dom ; public interface CharacterData extends Node { public String getData ( ) throws DOMException ; public void setData ( String data ) throws DOMException ; public int getLength ( ) ; public String substringData ( int offset , int count ) throws DOMException ; public void appendData ( String arg ) throws DOMException ; public void insertData ( int offset , String arg ) throws DOMException ; public void deleteData ( int offset , int count ) throws DOMException ; public void replaceData ( int offset , int count , String arg ) throws DOMException ; } 	1
package org . apache . xerces . framework ; import org . apache . xerces . utils . QName ; public interface XMLDocumentHandler { public void startDocument ( ) throws Exception ; public void endDocument ( ) throws Exception ; public void xmlDecl ( int version , int encoding , int standalone ) throws Exception ; public void textDecl ( int version , int encoding ) throws Exception ; public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception ; public void endNamespaceDeclScope ( int prefix ) throws Exception ; public void startElement ( QName element , XMLAttrList attrList , int attrListHandle ) throws Exception ; public void endElement ( QName element ) throws Exception ; public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void processingInstruction ( int target , int data ) throws Exception ; public void comment ( int comment ) throws Exception ; public void characters ( int data ) throws Exception ; public void characters ( char ch [ ] , int start , int length ) throws Exception ; public void ignorableWhitespace ( int data ) throws Exception ; public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws Exception ; public void startCDATA ( ) throws Exception ; public void endCDATA ( ) throws Exception ; public interface DTDHandler { public void startDTD ( QName rootElement , int publicId , int systemId ) throws Exception ; public void internalSubset ( int internalSubset ) throws Exception ; public void textDecl ( int version , int encoding ) throws Exception ; public void endDTD ( ) throws Exception ; public void elementDecl ( QName elementDecl , int contentSpecType , int contentSpecIndex , XMLContentSpec . Provider contentSpecProvider ) throws Exception ; public void attlistDecl ( QName elementDecl , QName attributeDecl , int attType , boolean attList , String enumString , int attDefaultType , int attDefaultValue ) throws Exception ; public void internalPEDecl ( int entityName , int entityValue ) throws Exception ; public void externalPEDecl ( int entityName , int publicId , int systemId ) throws Exception ; public void internalEntityDecl ( int entityName , int entityValue ) throws Exception ; public void externalEntityDecl ( int entityName , int publicId , int systemId ) throws Exception ; public void unparsedEntityDecl ( int entityName , int publicId , int systemId , int notationName ) throws Exception ; public void notationDecl ( int notationName , int publicId , int systemId ) throws Exception ; public void processingInstruction ( int targetIndex , int dataIndex ) throws Exception ; public void comment ( int dataIndex ) throws Exception ; } } 	0
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface Event { public static final short CAPTURING_PHASE = 1 ; public static final short AT_TARGET = 2 ; public static final short BUBBLING_PHASE = 3 ; public String getType ( ) ; public EventTarget getTarget ( ) ; public Node getCurrentNode ( ) ; public short getEventPhase ( ) ; public boolean getBubbles ( ) ; public boolean getCancelable ( ) ; public long getTimeStamp ( ) ; public void stopPropagation ( ) ; public void preventDefault ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLObjectElementImpl extends HTMLElementImpl implements HTMLObjectElement , HTMLFormControl { public String getCode ( ) { return getAttribute ( "code" ) ; } public void setCode ( String code ) { setAttribute ( "code" , code ) ; } public String getAlign ( ) { return capitalize ( getAttribute ( "align" ) ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public String getArchive ( ) { return getAttribute ( "archive" ) ; } public void setArchive ( String archive ) { setAttribute ( "archive" , archive ) ; } public String getBorder ( ) { return getAttribute ( "border" ) ; } public void setBorder ( String border ) { setAttribute ( "border" , border ) ; } public String getCodeBase ( ) { return getAttribute ( "codebase" ) ; } public void setCodeBase ( String codeBase ) { setAttribute ( "codebase" , codeBase ) ; } public String getCodeType ( ) { return getAttribute ( "codetype" ) ; } public void setCodeType ( String codeType ) { setAttribute ( "codetype" , codeType ) ; } public String getData ( ) { return getAttribute ( "data" ) ; } public void setData ( String data ) { setAttribute ( "data" , data ) ; } public boolean getDeclare ( ) { return getBinary ( "declare" ) ; } public void setDeclare ( boolean declare ) { setAttribute ( "declare" , declare ) ; } public String getHeight ( ) { return getAttribute ( "height" ) ; } public void setHeight ( String height ) { setAttribute ( "height" , height ) ; } public String getHspace ( ) { return getAttribute ( "hspace" ) ; } public void setHspace ( String hspace ) { setAttribute ( "hspace" , hspace ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public String getStandby ( ) { return getAttribute ( "standby" ) ; } public void setStandby ( String standby ) { setAttribute ( "standby" , standby ) ; } public int getTabIndex ( ) { try { return Integer . parseInt ( getAttribute ( "tabindex" ) ) ; } catch ( NumberFormatException except ) { return 0 ; } } public void setTabIndex ( int tabIndex ) { setAttribute ( "tabindex" , String . valueOf ( tabIndex ) ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } public void setType ( String type ) { setAttribute ( "type" , type ) ; } public String getUseMap ( ) { return getAttribute ( "useMap" ) ; } public void setUseMap ( String useMap ) { setAttribute ( "useMap" , useMap ) ; } public String getVspace ( ) { return getAttribute ( "vspace" ) ; } public void setVspace ( String vspace ) { setAttribute ( "vspace" , vspace ) ; } public String getWidth ( ) { return getAttribute ( "width" ) ; } public void setWidth ( String width ) { setAttribute ( "width" , width ) ; } public HTMLObjectElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Enumeration ; import java . util . Vector ; import org . w3c . dom . * ; public class ElementImpl extends ChildAndParentNode implements Element { static final long serialVersionUID = 3717253516652722278L ; protected String name ; protected AttributeMap attributes ; public ElementImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; needsSyncData ( true ) ; } protected ElementImpl ( ) { } public short getNodeType ( ) { return Node . ELEMENT_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public NamedNodeMap getAttributes ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return attributes ; } public Node cloneNode ( boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } ElementImpl newnode = ( ElementImpl ) super . cloneNode ( deep ) ; if ( attributes != null ) { newnode . attributes = ( AttributeMap ) attributes . cloneMap ( newnode ) ; } return newnode ; } void setOwnerDocument ( DocumentImpl doc ) { super . setOwnerDocument ( doc ) ; if ( attributes != null ) { attributes . setOwnerDocument ( doc ) ; } } public String getAttribute ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return "" ; } Attr attr = ( Attr ) ( attributes . getNamedItem ( name ) ) ; return ( attr == null ) ? "" : attr . getValue ( ) ; } public Attr getAttributeNode ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItem ( name ) ; } public NodeList getElementsByTagName ( String tagname ) { return new DeepNodeListImpl ( this , tagname ) ; } public String getTagName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void normalize ( ) { Node kid , next ; for ( kid = getFirstChild ( ) ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } else if ( kid . getNodeType ( ) == Node . ELEMENT_NODE ) { ( ( Element ) kid ) . normalize ( ) ; } } } public void removeAttribute ( String name ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItem ( name ) ; } public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } return ( Attr ) attributes . removeNamedItem ( oldAttr . getName ( ) ) ; } public void setAttribute ( String name , String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } Attr newAttr = getAttributeNode ( name ) ; if ( newAttr == null ) { newAttr = getOwnerDocument ( ) . createAttribute ( name ) ; if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } attributes . setNamedItem ( newAttr ) ; } newAttr . setNodeValue ( value ) ; } public Attr setAttributeNode ( Attr newAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ownerDocument . errorChecking && newAttr . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return ( Attr ) attributes . setNamedItem ( newAttr ) ; } public String getAttributeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return "" ; } Attr attr = ( Attr ) ( attributes . getNamedItemNS ( namespaceURI , localName ) ) ; return ( attr == null ) ? null : attr . getValue ( ) ; } public void setAttributeNS ( String namespaceURI , String localName , String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } Attr newAttr = getAttributeNodeNS ( namespaceURI , localName ) ; if ( newAttr == null ) { newAttr = getOwnerDocument ( ) . createAttributeNS ( namespaceURI , localName ) ; if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } attributes . setNamedItemNS ( newAttr ) ; } newAttr . setNodeValue ( value ) ; } public void removeAttributeNS ( String namespaceURI , String localName ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItemNS ( namespaceURI , localName ) ; } public Attr getAttributeNodeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItemNS ( namespaceURI , localName ) ; } public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ownerDocument . errorChecking && newAttr . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return ( Attr ) attributes . setNamedItemNS ( newAttr ) ; } public boolean hasAttributes ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return ( attributes != null && attributes . getLength ( ) != 0 ) ; } public boolean hasAttribute ( String name ) { return getAttributeNode ( name ) != null ; } public boolean hasAttributeNS ( String namespaceURI , String localName ) { return getAttributeNodeNS ( namespaceURI , localName ) != null ; } public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { return new DeepNodeListImpl ( this , namespaceURI , localName ) ; } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( attributes != null ) { attributes . setReadOnly ( readOnly , true ) ; } } protected void synchronizeData ( ) { needsSyncData ( false ) ; setupDefaultAttributes ( ) ; } protected void setupDefaultAttributes ( ) { NamedNodeMapImpl defaults = getDefaultAttributes ( ) ; if ( defaults != null ) { attributes = new AttributeMap ( this , defaults ) ; } } protected NamedNodeMapImpl getDefaultAttributes ( ) { DocumentTypeImpl doctype = ( DocumentTypeImpl ) ownerDocument . getDoctype ( ) ; if ( doctype == null ) { return null ; } ElementDefinitionImpl eldef = ( ElementDefinitionImpl ) doctype . getElements ( ) . getNamedItem ( getNodeName ( ) ) ; if ( eldef == null ) { return null ; } return ( NamedNodeMapImpl ) eldef . getAttributes ( ) ; } } 	1
package org . apache . wml ; public interface WMLCardElement extends WMLElement { public void setOnEnterBackward ( String href ) ; public String getOnEnterBackward ( ) ; public void setOnEnterForward ( String href ) ; public String getOnEnterForward ( ) ; public void setOnTimer ( String href ) ; public String getOnTimer ( ) ; public void setTitle ( String newValue ) ; public String getTitle ( ) ; public void setNewContext ( boolean newValue ) ; public boolean getNewContext ( ) ; public void setOrdered ( boolean newValue ) ; public boolean getOrdered ( ) ; public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class TextImpl extends CharacterDataImpl implements CharacterData , Text { static final long serialVersionUID = - 5294980852957403469L ; public TextImpl ( DocumentImpl ownerDoc , String data ) { super ( ownerDoc , data ) ; } public short getNodeType ( ) { return Node . TEXT_NODE ; } public String getNodeName ( ) { return "#text" ; } public void setIgnorableWhitespace ( boolean ignore ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isIgnorableWhitespace ( ignore ) ; } public boolean isIgnorableWhitespace ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return internalIsIgnorableWhitespace ( ) ; } public Text splitText ( int offset ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( offset < 0 || offset > data . length ( ) - 1 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } Text newText = getOwnerDocument ( ) . createTextNode ( data . substring ( offset ) ) ; setNodeValue ( data . substring ( 0 , offset ) ) ; Node parentNode = getParentNode ( ) ; if ( parentNode != null ) { parentNode . insertBefore ( newText , nextSibling ) ; } return newText ; } } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . ChunkyByteArray ; import org . apache . xerces . utils . StringPool ; import org . xml . sax . InputSource ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . URL ; import java . util . Stack ; public class DefaultReaderFactory implements XMLEntityReaderFactory { private static final boolean USE_CHAR_READER_FOR_UTF8 = false ; private static final boolean USE_BYTE_READER_FOR_UTF8 = true ; private boolean fSendCharDataAsCharArray = false ; private boolean fAllowJavaEncodingName = false ; private Stack fRecognizers = null ; public DefaultReaderFactory ( ) { } public void addRecognizer ( XMLDeclRecognizer recognizer ) { if ( fRecognizers == null ) { fRecognizers = new Stack ( ) ; XMLDeclRecognizer . registerDefaultRecognizers ( fRecognizers ) ; } fRecognizers . push ( recognizer ) ; } public void setSendCharDataAsCharArray ( boolean flag ) { fSendCharDataAsCharArray = flag ; } public void setAllowJavaEncodingName ( boolean flag ) { fAllowJavaEncodingName = flag ; } public boolean getAllowJavaEncodingName ( ) { return fAllowJavaEncodingName ; } public XMLEntityHandler . EntityReader createReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , InputSource source , String systemId , boolean xmlDecl , StringPool stringPool ) throws Exception { if ( source . getCharacterStream ( ) != null ) { return createCharReader ( entityHandler , errorReporter , fSendCharDataAsCharArray , source . getCharacterStream ( ) , stringPool ) ; } if ( source . getEncoding ( ) != null && source . getByteStream ( ) != null ) { java . io . Reader reader = new InputStreamReader ( source . getByteStream ( ) , source . getEncoding ( ) ) ; return createCharReader ( entityHandler , errorReporter , fSendCharDataAsCharArray , reader , stringPool ) ; } InputStream is = source . getByteStream ( ) ; if ( is == null ) { URL url = new URL ( systemId ) ; is = url . openStream ( ) ; } ChunkyByteArray data = new ChunkyByteArray ( is ) ; if ( fRecognizers == null ) { fRecognizers = new Stack ( ) ; XMLDeclRecognizer . registerDefaultRecognizers ( fRecognizers ) ; } for ( int i = fRecognizers . size ( ) - 1 ; i >= 0 ; i -- ) { XMLDeclRecognizer recognizer = ( XMLDeclRecognizer ) fRecognizers . elementAt ( i ) ; XMLEntityHandler . EntityReader reader = recognizer . recognize ( this , entityHandler , errorReporter , fSendCharDataAsCharArray , stringPool , data , xmlDecl , fAllowJavaEncodingName ) ; if ( reader != null ) { return reader ; } } return createUTF8Reader ( entityHandler , errorReporter , fSendCharDataAsCharArray , data , stringPool ) ; } public XMLEntityHandler . EntityReader createCharReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , Reader reader , StringPool stringPool ) throws Exception { return new CharReader ( entityHandler , errorReporter , sendCharDataAsCharArray , reader , stringPool ) ; } public XMLEntityHandler . EntityReader createUTF8Reader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , InputStream data , StringPool stringPool ) throws Exception { XMLEntityHandler . EntityReader reader ; if ( USE_CHAR_READER_FOR_UTF8 ) { reader = new CharReader ( entityHandler , errorReporter , sendCharDataAsCharArray , new InputStreamReader ( data , "UTF8" ) , stringPool ) ; } else if ( USE_BYTE_READER_FOR_UTF8 ) { reader = new UTF8Reader ( entityHandler , errorReporter , sendCharDataAsCharArray , data , stringPool ) ; } else { reader = new UTF8CharReader ( entityHandler , errorReporter , sendCharDataAsCharArray , data , stringPool ) ; } return reader ; } public XMLEntityHandler . EntityReader createStringReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , int lineNumber , int columnNumber , int stringHandle , StringPool stringPool , boolean addEnclosingSpaces ) throws Exception { return StringReader . createStringReader ( entityHandler , errorReporter , sendCharDataAsCharArray , lineNumber , columnNumber , stringHandle , stringPool , addEnclosingSpaces ) ; } } 	0
package org . w3c . dom ; public class DOMException extends RuntimeException { public DOMException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short INDEX_SIZE_ERR = 1 ; public static final short DOMSTRING_SIZE_ERR = 2 ; public static final short HIERARCHY_REQUEST_ERR = 3 ; public static final short WRONG_DOCUMENT_ERR = 4 ; public static final short INVALID_CHARACTER_ERR = 5 ; public static final short NO_DATA_ALLOWED_ERR = 6 ; public static final short NO_MODIFICATION_ALLOWED_ERR = 7 ; public static final short NOT_FOUND_ERR = 8 ; public static final short NOT_SUPPORTED_ERR = 9 ; public static final short INUSE_ATTRIBUTE_ERR = 10 ; public static final short INVALID_STATE_ERR = 11 ; public static final short SYNTAX_ERR = 12 ; public static final short INVALID_MODIFICATION_ERR = 13 ; public static final short NAMESPACE_ERR = 14 ; public static final short INVALID_ACCESS_ERR = 15 ; } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . utils . QName ; import org . apache . xerces . validators . datatype . DatatypeValidator ; public class XMLElementDecl { public static final int TYPE_EMPTY = 0 ; public static final int TYPE_ANY = 1 ; public static final int TYPE_MIXED = 2 ; public static final int TYPE_CHILDREN = 3 ; public static final int TYPE_SIMPLE = 4 ; public final QName name = new QName ( ) ; public int type ; public boolean list ; public DatatypeValidator datatypeValidator ; public int contentSpecIndex ; public int enclosingScope ; public XMLElementDecl ( ) { clear ( ) ; } public XMLElementDecl ( XMLElementDecl elementDecl ) { setValues ( elementDecl ) ; } public void clear ( ) { name . clear ( ) ; type = - 1 ; list = false ; datatypeValidator = null ; contentSpecIndex = - 1 ; enclosingScope = - 1 ; } public void setValues ( XMLElementDecl elementDecl ) { name . setValues ( elementDecl . name ) ; type = elementDecl . type ; list = elementDecl . list ; datatypeValidator = elementDecl . datatypeValidator ; contentSpecIndex = elementDecl . contentSpecIndex ; enclosingScope = elementDecl . enclosingScope ; } public int hashCode ( ) { return super . hashCode ( ) ; } public boolean equals ( Object object ) { return super . equals ( object ) ; } } 	0
package org . w3c . dom . events ; public interface EventTarget { public void addEventListener ( String type , EventListener listener , boolean useCapture ) ; public void removeEventListener ( String type , EventListener listener , boolean useCapture ) ; public boolean dispatchEvent ( Event evt ) throws EventException ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLOListElementImpl extends HTMLElementImpl implements HTMLOListElement { public boolean getCompact ( ) { return getBinary ( "compact" ) ; } public void setCompact ( boolean compact ) { setAttribute ( "compact" , compact ) ; } public int getStart ( ) { return getInteger ( getAttribute ( "start" ) ) ; } public void setStart ( int start ) { setAttribute ( "start" , String . valueOf ( start ) ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } public void setType ( String type ) { setAttribute ( "type" , type ) ; } public HTMLOListElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom ; public interface NodeList { public Node item ( int index ) ; public int getLength ( ) ; } 	1
package org . apache . xerces . validators . schema ; import org . apache . xerces . dom . AttrImpl ; import org . apache . xerces . dom . DocumentImpl ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . DOMException ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; public class XUtil { protected XUtil ( ) { } public static void copyInto ( Node src , Node dest ) throws DOMException { Document factory = dest . getOwnerDocument ( ) ; boolean domimpl = factory instanceof DocumentImpl ; Node start = src ; Node parent = src ; Node place = src ; while ( place != null ) { Node node = null ; int type = place . getNodeType ( ) ; switch ( type ) { case Node . CDATA_SECTION_NODE : { node = factory . createCDATASection ( place . getNodeValue ( ) ) ; break ; } case Node . COMMENT_NODE : { node = factory . createComment ( place . getNodeValue ( ) ) ; break ; } case Node . ELEMENT_NODE : { Element element = factory . createElement ( place . getNodeName ( ) ) ; node = element ; NamedNodeMap attrs = place . getAttributes ( ) ; int attrCount = attrs . getLength ( ) ; for ( int i = 0 ; i < attrCount ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; String attrName = attr . getNodeName ( ) ; String attrValue = attr . getNodeValue ( ) ; element . setAttribute ( attrName , attrValue ) ; if ( domimpl && ! attr . getSpecified ( ) ) { ( ( AttrImpl ) element . getAttributeNode ( attrName ) ) . setSpecified ( false ) ; } } break ; } case Node . ENTITY_REFERENCE_NODE : { node = factory . createEntityReference ( place . getNodeName ( ) ) ; break ; } case Node . PROCESSING_INSTRUCTION_NODE : { node = factory . createProcessingInstruction ( place . getNodeName ( ) , place . getNodeValue ( ) ) ; break ; } case Node . TEXT_NODE : { node = factory . createTextNode ( place . getNodeValue ( ) ) ; break ; } default : { throw new IllegalArgumentException ( "can't copy node type, " + type + " (" + node . getNodeName ( ) + ')' ) ; } } dest . appendChild ( node ) ; if ( place . hasChildNodes ( ) ) { parent = place ; place = place . getFirstChild ( ) ; dest = node ; } else { place = place . getNextSibling ( ) ; while ( place == null && parent != start ) { place = parent . getNextSibling ( ) ; parent = parent . getParentNode ( ) ; dest = dest . getParentNode ( ) ; } } } } public static Element getFirstChildElement ( Node parent ) { Node child = parent . getFirstChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { return ( Element ) child ; } child = child . getNextSibling ( ) ; } return null ; } public static Element getLastChildElement ( Node parent ) { Node child = parent . getLastChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { return ( Element ) child ; } child = child . getPreviousSibling ( ) ; } return null ; } public static Element getNextSiblingElement ( Node node ) { Node sibling = node . getNextSibling ( ) ; while ( sibling != null ) { if ( sibling . getNodeType ( ) == Node . ELEMENT_NODE ) { return ( Element ) sibling ; } sibling = sibling . getNextSibling ( ) ; } return null ; } public static Element getFirstChildElement ( Node parent , String elemName ) { Node child = parent . getFirstChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( child . getNodeName ( ) . equals ( elemName ) ) { return ( Element ) child ; } } child = child . getNextSibling ( ) ; } return null ; } public static Element getLastChildElement ( Node parent , String elemName ) { Node child = parent . getLastChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( child . getNodeName ( ) . equals ( elemName ) ) { return ( Element ) child ; } } child = child . getPreviousSibling ( ) ; } return null ; } public static Element getNextSiblingElement ( Node node , String elemName ) { Node sibling = node . getNextSibling ( ) ; while ( sibling != null ) { if ( sibling . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( sibling . getNodeName ( ) . equals ( elemName ) ) { return ( Element ) sibling ; } } sibling = sibling . getNextSibling ( ) ; } return null ; } public static Element getFirstChildElement ( Node parent , String elemNames [ ] ) { Node child = parent . getFirstChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { for ( int i = 0 ; i < elemNames . length ; i ++ ) { if ( child . getNodeName ( ) . equals ( elemNames [ i ] ) ) { return ( Element ) child ; } } } child = child . getNextSibling ( ) ; } return null ; } public static Element getLastChildElement ( Node parent , String elemNames [ ] ) { Node child = parent . getLastChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { for ( int i = 0 ; i < elemNames . length ; i ++ ) { if ( child . getNodeName ( ) . equals ( elemNames [ i ] ) ) { return ( Element ) child ; } } } child = child . getPreviousSibling ( ) ; } return null ; } public static Element getNextSiblingElement ( Node node , String elemNames [ ] ) { Node sibling = node . getNextSibling ( ) ; while ( sibling != null ) { if ( sibling . getNodeType ( ) == Node . ELEMENT_NODE ) { for ( int i = 0 ; i < elemNames . length ; i ++ ) { if ( sibling . getNodeName ( ) . equals ( elemNames [ i ] ) ) { return ( Element ) sibling ; } } } sibling = sibling . getNextSibling ( ) ; } return null ; } public static Element getFirstChildElement ( Node parent , String elemName , String attrName , String attrValue ) { Node child = parent . getFirstChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { Element element = ( Element ) child ; if ( element . getNodeName ( ) . equals ( elemName ) && element . getAttribute ( attrName ) . equals ( attrValue ) ) { return element ; } } child = child . getNextSibling ( ) ; } return null ; } public static Element getLastChildElement ( Node parent , String elemName , String attrName , String attrValue ) { Node child = parent . getLastChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { Element element = ( Element ) child ; if ( element . getNodeName ( ) . equals ( elemName ) && element . getAttribute ( attrName ) . equals ( attrValue ) ) { return element ; } } child = child . getPreviousSibling ( ) ; } return null ; } public static Element getNextSiblingElement ( Node node , String elemName , String attrName , String attrValue ) { Node sibling = node . getNextSibling ( ) ; while ( sibling != null ) { if ( sibling . getNodeType ( ) == Node . ELEMENT_NODE ) { Element element = ( Element ) sibling ; if ( element . getNodeName ( ) . equals ( elemName ) && element . getAttribute ( attrName ) . equals ( attrValue ) ) { return element ; } } sibling = sibling . getNextSibling ( ) ; } return null ; } } 	0
package javax . xml . parsers ; public class ParserConfigurationException extends Exception { public ParserConfigurationException ( ) { super ( ) ; } public ParserConfigurationException ( String msg ) { super ( msg ) ; } } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . ChunkyByteArray ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import java . io . InputStreamReader ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; final class UTF8Recognizer extends XMLDeclRecognizer { private byte [ ] fUTF8BOM = { ( byte ) 0xEF , ( byte ) 0xBB , ( byte ) 0xBF } ; public XMLEntityHandler . EntityReader recognize ( XMLEntityReaderFactory readerFactory , XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , StringPool stringPool , ChunkyByteArray data , boolean xmlDecl , boolean allowJavaEncodingName ) throws Exception { XMLEntityHandler . EntityReader reader = null ; boolean seeBOM = false ; byte bom0 = data . byteAt ( 0 ) ; if ( bom0 == fUTF8BOM [ 0 ] ) { byte bom1 = data . byteAt ( 1 ) ; if ( bom1 == fUTF8BOM [ 1 ] ) { byte bom2 = data . byteAt ( 2 ) ; if ( bom2 == fUTF8BOM [ 2 ] ) { seeBOM = true ; } } } if ( seeBOM ) { data . read ( fUTF8BOM , 0 , 3 ) ; } byte b0 = data . byteAt ( 0 ) ; boolean debug = false ; if ( b0 == '<' ) { int b1 = data . byteAt ( 1 ) ; if ( b1 == '?' ) { if ( data . byteAt ( 2 ) == 'x' && data . byteAt ( 3 ) == 'm' && data . byteAt ( 4 ) == 'l' ) { int b5 = data . byteAt ( 5 ) ; if ( b5 == 0x20 || b5 == 0x09 || b5 == 0x0a || b5 == 0x0d ) { XMLEntityHandler . EntityReader declReader = new XMLDeclReader ( entityHandler , errorReporter , sendCharDataAsCharArray , data , stringPool ) ; int encoding = prescanXMLDeclOrTextDecl ( declReader , xmlDecl ) ; if ( encoding != - 1 ) { String encname = stringPool . orphanString ( encoding ) ; String enc = encname . toUpperCase ( ) ; if ( "ISO-10646-UCS-2" . equals ( enc ) ) throw new UnsupportedEncodingException ( encname ) ; if ( "ISO-10646-UCS-4" . equals ( enc ) ) throw new UnsupportedEncodingException ( encname ) ; if ( "UTF-16" . equals ( enc ) ) throw new UnsupportedEncodingException ( encname ) ; String javaencname = MIME2Java . convert ( enc ) ; if ( null == javaencname ) { if ( allowJavaEncodingName ) { javaencname = encname ; } else { throw new UnsupportedEncodingException ( encname ) ; } } try { data . rewind ( ) ; if ( "UTF-8" . equalsIgnoreCase ( javaencname ) || "UTF8" . equalsIgnoreCase ( javaencname ) ) { reader = readerFactory . createUTF8Reader ( entityHandler , errorReporter , sendCharDataAsCharArray , data , stringPool ) ; } else { reader = readerFactory . createCharReader ( entityHandler , errorReporter , sendCharDataAsCharArray , new InputStreamReader ( data , javaencname ) , stringPool ) ; } } catch ( UnsupportedEncodingException e ) { throw new UnsupportedEncodingException ( encname ) ; } catch ( Exception e ) { if ( debug == true ) e . printStackTrace ( ) ; } } else { data . rewind ( ) ; reader = readerFactory . createUTF8Reader ( entityHandler , errorReporter , sendCharDataAsCharArray , data , stringPool ) ; } } } } } return reader ; } final class XMLDeclReader extends XMLEntityReader { private StringPool fStringPool = null ; private ChunkyByteArray fData = null ; XMLDeclReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , ChunkyByteArray data , StringPool stringPool ) { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fStringPool = stringPool ; fData = data ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) throws IOException { if ( fData . byteAt ( fCurrentOffset ) != ch ) return false ; if ( skipPastChar ) fCurrentOffset ++ ; return true ; } public boolean lookingAtSpace ( boolean skipPastChar ) throws IOException { int ch = fData . byteAt ( fCurrentOffset ) & 0xff ; if ( ch != 0x20 && ch != 0x09 && ch != 0x0A && ch != 0x0D ) return false ; if ( skipPastChar ) fCurrentOffset ++ ; return true ; } public void skipPastSpaces ( ) throws IOException { while ( true ) { int ch = fData . byteAt ( fCurrentOffset ) & 0xff ; if ( ch != 0x20 && ch != 0x09 && ch != 0x0A && ch != 0x0D ) return ; fCurrentOffset ++ ; } } public boolean skippedString ( char [ ] s ) throws IOException { int offset = fCurrentOffset ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( fData . byteAt ( offset ) != s [ i ] ) return false ; offset ++ ; } fCurrentOffset = offset ; return true ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( true ) { byte b = fData . byteAt ( fCurrentOffset ) ; if ( b == qchar ) break ; if ( b == - 1 ) return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; fCurrentOffset ++ ; } int length = fCurrentOffset - offset ; StringBuffer str = new StringBuffer ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { str . append ( ( char ) fData . byteAt ( offset + i ) ) ; } int stringIndex = fStringPool . addString ( str . toString ( ) ) ; fCurrentOffset ++ ; return stringIndex ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { throw new RuntimeException ( "RDR002 cannot happen" ) ; } public int addString ( int offset , int length ) { throw new RuntimeException ( "RDR002 cannot happen" ) ; } public int addSymbol ( int offset , int length ) { throw new RuntimeException ( "RDR002 cannot happen" ) ; } public void skipToChar ( char ch ) throws IOException { throw new IOException ( "RDR002 cannot happen" ) ; } public void skipPastName ( char fastcheck ) throws IOException { throw new IOException ( "RDR002 cannot happen" ) ; } public void skipPastNmtoken ( char fastcheck ) throws IOException { throw new IOException ( "RDR002 cannot happen" ) ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws IOException { throw new IOException ( "RDR002 cannot happen" ) ; } public int scanInvalidChar ( ) throws IOException { throw new IOException ( "RDR002 cannot happen" ) ; } public int scanCharRef ( boolean hex ) throws IOException { throw new IOException ( "RDR002 cannot happen" ) ; } public int scanAttValue ( char qchar , boolean asSymbol ) throws IOException { throw new IOException ( "RDR002 cannot happen" ) ; } public int scanEntityValue ( int qchar , boolean createString ) throws IOException { throw new IOException ( "RDR002 cannot happen" ) ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws IOException { throw new IOException ( "RDR002 cannot happen" ) ; } public void scanQName ( char fastcheck , QName qname ) throws IOException { throw new IOException ( "RDR002 cannot happen" ) ; } public int scanName ( char fastcheck ) throws IOException { throw new IOException ( "RDR002 cannot happen" ) ; } public int scanContent ( QName element ) throws IOException { throw new IOException ( "RDR002 cannot happen" ) ; } } } 	0
package org . apache . xerces . domx ; public abstract class DOMException extends org . w3c . dom . DOMException { public static final short UNSPECIFIED_EVENT_TYPE = 100 ; public static final short UNSUPPORTED_EVENT_TYPE = 101 ; public DOMException ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLIsIndexElementImpl extends HTMLElementImpl implements HTMLIsIndexElement { public String getPrompt ( ) { return getAttribute ( "prompt" ) ; } public void setPrompt ( String prompt ) { setAttribute ( "prompt" , prompt ) ; } public HTMLIsIndexElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrNSImpl extends AttrImpl { static final long serialVersionUID = - 781906615369795414L ; protected String namespaceURI ; protected String localName ; protected AttrNSImpl ( DocumentImpl ownerDocument , String namespaceURI , String qualifiedName ) { super ( ownerDocument , qualifiedName ) ; if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = qualifiedName ; } else { prefix = qualifiedName . substring ( 0 , index ) ; localName = qualifiedName . substring ( index + 1 ) ; } if ( ( prefix != null && ( namespaceURI == null || namespaceURI . equals ( "" ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) || ( prefix . equals ( "xmlns" ) && ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) ) || ( qualifiedName . equals ( "xmlns" ) && ( namespaceURI == null || ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } this . namespaceURI = namespaceURI ; } protected AttrNSImpl ( DocumentImpl ownerDocument , String value ) { super ( ownerDocument , value ) ; } public String getNamespaceURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return namespaceURI ; } public String getPrefix ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int index = name . indexOf ( ':' ) ; return index < 0 ? null : name . substring ( 0 , index ) ; } public void setPrefix ( String prefix ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( namespaceURI == null || ( prefix != null && ( ( prefix . equals ( "xmlns" ) && ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } if ( ownerDocument . errorChecking && ! DocumentImpl . isXMLName ( prefix ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } name = prefix + ":" + localName ; } public String getLocalName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return localName ; } } 	1
package org . apache . xerces . framework ; import java . io . InputStream ; import java . io . IOException ; import java . io . Reader ; import java . util . Locale ; import org . apache . xerces . readers . DefaultEntityHandler ; import org . apache . xerces . readers . XMLDeclRecognizer ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . readers . XMLEntityReaderFactory ; import org . apache . xerces . utils . ChunkyCharArray ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLMessageProvider ; import org . apache . xerces . utils . XMLMessages ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . validators . common . GrammarResolver ; import org . apache . xerces . validators . common . GrammarResolverImpl ; import org . apache . xerces . validators . common . XMLValidator ; import org . apache . xerces . validators . datatype . DatatypeMessageProvider ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . schema . SchemaMessageProvider ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . SAXParseException ; public abstract class XMLParser implements XMLErrorReporter , XMLDocumentHandler . DTDHandler { protected static final String SAX2_FEATURES_PREFIX = "http://xml.org/sax/features/" ; protected static final String SAX2_PROPERTIES_PREFIX = "http://xml.org/sax/properties/" ; protected static final String XERCES_FEATURES_PREFIX = "http://apache.org/xml/features/" ; protected static final String XERCES_PROPERTIES_PREFIX = "http://apache.org/xml/properties/" ; private static final String RECOGNIZED_FEATURES [ ] = { "http://xml.org/sax/features/validation" , "http://xml.org/sax/features/external-general-entities" , "http://xml.org/sax/features/external-parameter-entities" , "http://xml.org/sax/features/namespaces" , "http://apache.org/xml/features/validation/schema" , "http://apache.org/xml/features/validation/dynamic" , "http://apache.org/xml/features/validation/default-attribute-values" , "http://apache.org/xml/features/validation/validate-content-models" , "http://apache.org/xml/features/validation/validate-datatypes" , "http://apache.org/xml/features/validation/warn-on-duplicate-attdef" , "http://apache.org/xml/features/validation/warn-on-undeclared-elemdef" , "http://apache.org/xml/features/allow-java-encodings" , "http://apache.org/xml/features/continue-after-fatal-error" , "http://apache.org/xml/features/nonvalidating/load-dtd-grammar" } ; private static final String RECOGNIZED_PROPERTIES [ ] = { "http://xml.org/sax/properties/xml-string" , } ; private static final boolean PRINT_EXCEPTION_STACK_TRACE = false ; protected GrammarResolver fGrammarResolver = null ; protected boolean fParseInProgress = false ; private boolean fNeedReset = false ; private boolean fContinueAfterFatalError = false ; private ErrorHandler fErrorHandler = null ; private Locale fLocale = null ; private static XMLMessageProvider fgXMLMessages = new XMLMessages ( ) ; private static XMLMessageProvider fgImplementationMessages = new ImplementationMessages ( ) ; private static XMLMessageProvider fgSchemaMessages = new SchemaMessageProvider ( ) ; private static XMLMessageProvider fgDatatypeMessages = new DatatypeMessageProvider ( ) ; protected StringPool fStringPool = null ; protected XMLErrorReporter fErrorReporter = null ; protected DefaultEntityHandler fEntityHandler = null ; protected XMLDocumentScanner fScanner = null ; protected XMLValidator fValidator = null ; protected XMLParser ( ) { fStringPool = new StringPool ( ) ; fErrorReporter = this ; fEntityHandler = new DefaultEntityHandler ( fStringPool , fErrorReporter ) ; fScanner = new XMLDocumentScanner ( fStringPool , fErrorReporter , fEntityHandler , new ChunkyCharArray ( fStringPool ) ) ; fValidator = new XMLValidator ( fStringPool , fErrorReporter , fEntityHandler , fScanner ) ; fGrammarResolver = new GrammarResolverImpl ( ) ; fScanner . setGrammarResolver ( fGrammarResolver ) ; fValidator . setGrammarResolver ( fGrammarResolver ) ; try { setNamespaces ( true ) ; } catch ( Exception e ) { } } protected void initHandlers ( boolean sendCharDataAsCharArray , XMLDocumentHandler docHandler , XMLDocumentHandler . DTDHandler dtdHandler ) { fValidator . initHandlers ( sendCharDataAsCharArray , docHandler , dtdHandler ) ; fScanner . setDTDHandler ( this ) ; } public String [ ] getFeaturesRecognized ( ) { return RECOGNIZED_FEATURES ; } public boolean isFeatureRecognized ( String featureId ) { String [ ] recognizedFeatures = getFeaturesRecognized ( ) ; for ( int i = 0 ; i < recognizedFeatures . length ; i ++ ) { if ( featureId . equals ( recognizedFeatures [ i ] ) ) return true ; } return false ; } public String [ ] getPropertiesRecognized ( ) { return RECOGNIZED_PROPERTIES ; } public boolean isPropertyRecognized ( String propertyId ) { String [ ] recognizedProperties = getPropertiesRecognized ( ) ; for ( int i = 0 ; i < recognizedProperties . length ; i ++ ) { if ( propertyId . equals ( recognizedProperties [ i ] ) ) return true ; } return false ; } public boolean parseSomeSetup ( InputSource source ) throws Exception { if ( fNeedReset ) resetOrCopy ( ) ; fParseInProgress = true ; fNeedReset = true ; return fEntityHandler . startReadingFromDocument ( source ) ; } public boolean parseSome ( ) throws Exception { if ( ! fScanner . parseSome ( false ) ) { fParseInProgress = false ; return false ; } return true ; } public void reset ( ) throws Exception { fGrammarResolver . clearGrammarResolver ( ) ; fStringPool . reset ( ) ; fEntityHandler . reset ( fStringPool ) ; fScanner . reset ( fStringPool , new ChunkyCharArray ( fStringPool ) ) ; fValidator . reset ( fStringPool ) ; fNeedReset = false ; } public final Locator getLocator ( ) { return fEntityHandler ; } public void setReaderFactory ( XMLEntityReaderFactory readerFactory ) { fEntityHandler . setReaderFactory ( readerFactory ) ; } public void addRecognizer ( XMLDeclRecognizer recognizer ) { fEntityHandler . addRecognizer ( recognizer ) ; } protected void setValidation ( boolean validate ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR004 Cannot setFeature(http://xml.org/sax/features/validation): parse is in progress.\n" + "http://xml.org/sax/features/validation" ) ; } try { fScanner . setValidationEnabled ( validate ) ; fValidator . setValidationEnabled ( validate ) ; } catch ( Exception ex ) { throw new SAXNotSupportedException ( ex . getMessage ( ) ) ; } } protected boolean getValidation ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fValidator . getValidationEnabled ( ) ; } protected void setExternalGeneralEntities ( boolean expand ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR004 Cannot setFeature(http://xml.org/sax/features/external-general-entities): parse is in progress.\n" + "http://xml.org/sax/features/external-general-entities" ) ; } if ( ! expand ) { throw new SAXNotSupportedException ( "http://xml.org/sax/features/external-general-entities" ) ; } } protected boolean getExternalGeneralEntities ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return true ; } protected void setExternalParameterEntities ( boolean expand ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR004 Cannot setFeature(http://xml.org/sax/features/external-general-entities): parse is in progress.\n" + "http://xml.org/sax/features/external-general-entities" ) ; } if ( ! expand ) { throw new SAXNotSupportedException ( "http://xml.org/sax/features/external-parameter-entities" ) ; } } protected boolean getExternalParameterEntities ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return true ; } protected void setNamespaces ( boolean process ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR004 Cannot setFeature(http://xml.org/sax/features/namespaces): parse is in progress.\n" + "http://xml.org/sax/features/namespaces" ) ; } fScanner . setNamespacesEnabled ( process ) ; fValidator . setNamespacesEnabled ( process ) ; } protected boolean getNamespaces ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fValidator . getNamespacesEnabled ( ) ; } protected void setValidationSchema ( boolean schema ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "http://apache.org/xml/features/validation/schema: parse is in progress" ) ; } fValidator . setSchemaValidationEnabled ( schema ) ; } protected boolean getValidationSchema ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fValidator . getSchemaValidationEnabled ( ) ; } protected void setValidationDynamic ( boolean dynamic ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "http://apache.org/xml/features/validation/dynamic: parse is in progress" ) ; } try { fValidator . setDynamicValidationEnabled ( dynamic ) ; } catch ( Exception ex ) { throw new SAXNotSupportedException ( ex . getMessage ( ) ) ; } } protected boolean getValidationDynamic ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fValidator . getDynamicValidationEnabled ( ) ; } protected void setLoadDTDGrammar ( boolean loadDTDGrammar ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "http://apache.org/xml/features/nonvalidating/load-dtd-grammar: parse is in progress" ) ; } try { fValidator . setLoadDTDGrammar ( loadDTDGrammar ) ; } catch ( Exception ex ) { throw new SAXNotSupportedException ( ex . getMessage ( ) ) ; } } protected boolean getLoadDTDGrammar ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fValidator . getLoadDTDGrammar ( ) ; } protected void setValidationWarnOnDuplicateAttdef ( boolean warn ) throws SAXNotRecognizedException , SAXNotSupportedException { fValidator . setWarningOnDuplicateAttDef ( warn ) ; } protected boolean getValidationWarnOnDuplicateAttdef ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fValidator . getWarningOnDuplicateAttDef ( ) ; } protected void setValidationWarnOnUndeclaredElemdef ( boolean warn ) throws SAXNotRecognizedException , SAXNotSupportedException { fValidator . setWarningOnUndeclaredElements ( warn ) ; } protected boolean getValidationWarnOnUndeclaredElemdef ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fValidator . getWarningOnUndeclaredElements ( ) ; } protected void setAllowJavaEncodings ( boolean allow ) throws SAXNotRecognizedException , SAXNotSupportedException { fEntityHandler . setAllowJavaEncodings ( allow ) ; } protected boolean getAllowJavaEncodings ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fEntityHandler . getAllowJavaEncodings ( ) ; } protected void setContinueAfterFatalError ( boolean continueAfterFatalError ) throws SAXNotRecognizedException , SAXNotSupportedException { fContinueAfterFatalError = continueAfterFatalError ; } protected boolean getContinueAfterFatalError ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fContinueAfterFatalError ; } protected String getXMLString ( ) throws SAXNotRecognizedException , SAXNotSupportedException { throw new SAXNotSupportedException ( "http://xml.org/sax/properties/xml-string" ) ; } protected void resetOrCopy ( ) throws Exception { fStringPool = new StringPool ( ) ; fEntityHandler . reset ( fStringPool ) ; fScanner . reset ( fStringPool , new ChunkyCharArray ( fStringPool ) ) ; fValidator . resetOrCopy ( fStringPool ) ; fNeedReset = false ; fGrammarResolver = new GrammarResolverImpl ( ) ; fScanner . setGrammarResolver ( fGrammarResolver ) ; fValidator . setGrammarResolver ( fGrammarResolver ) ; DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) . resetRegistry ( ) ; } public void setEntityResolver ( EntityResolver resolver ) { fEntityHandler . setEntityResolver ( resolver ) ; } public EntityResolver getEntityResolver ( ) { return fEntityHandler . getEntityResolver ( ) ; } public void setErrorHandler ( ErrorHandler handler ) { fErrorHandler = handler ; } public ErrorHandler getErrorHandler ( ) { return fErrorHandler ; } public void parse ( InputSource source ) throws SAXException , IOException { if ( fParseInProgress ) { throw new org . xml . sax . SAXException ( "FWK005 parse may not be called while parsing." ) ; } try { if ( parseSomeSetup ( source ) ) { fScanner . parseSome ( true ) ; } fParseInProgress = false ; } catch ( org . xml . sax . SAXException ex ) { fParseInProgress = false ; if ( PRINT_EXCEPTION_STACK_TRACE ) ex . printStackTrace ( ) ; throw ex ; } catch ( IOException ex ) { fParseInProgress = false ; if ( PRINT_EXCEPTION_STACK_TRACE ) ex . printStackTrace ( ) ; throw ex ; } catch ( Exception ex ) { fParseInProgress = false ; if ( PRINT_EXCEPTION_STACK_TRACE ) ex . printStackTrace ( ) ; throw new org . xml . sax . SAXException ( ex ) ; } } public void parse ( String systemId ) throws SAXException , IOException { InputSource source = new InputSource ( systemId ) ; parse ( source ) ; try { Reader reader = source . getCharacterStream ( ) ; if ( reader != null ) { reader . close ( ) ; } else { InputStream is = source . getByteStream ( ) ; if ( is != null ) { is . close ( ) ; } } } catch ( IOException e ) { } } public void setLocale ( Locale locale ) throws SAXException { if ( fParseInProgress ) { throw new org . xml . sax . SAXException ( "FWK006 setLocale may not be called while parsing" ) ; } fLocale = locale ; fgXMLMessages . setLocale ( locale ) ; fgImplementationMessages . setLocale ( locale ) ; } public void reportError ( Locator locator , String errorDomain , int majorCode , int minorCode , Object args [ ] , int errorType ) throws Exception { SAXParseException spe ; if ( errorDomain . equals ( XMLMessages . XML_DOMAIN ) ) { spe = new SAXParseException ( fgXMLMessages . createMessage ( fLocale , majorCode , minorCode , args ) , locator ) ; } else if ( errorDomain . equals ( XMLMessages . XMLNS_DOMAIN ) ) { spe = new SAXParseException ( fgXMLMessages . createMessage ( fLocale , majorCode , minorCode , args ) , locator ) ; } else if ( errorDomain . equals ( ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN ) ) { spe = new SAXParseException ( fgImplementationMessages . createMessage ( fLocale , majorCode , minorCode , args ) , locator ) ; } else if ( errorDomain . equals ( SchemaMessageProvider . SCHEMA_DOMAIN ) ) { spe = new SAXParseException ( fgSchemaMessages . createMessage ( fLocale , majorCode , minorCode , args ) , locator ) ; } else if ( errorDomain . equals ( DatatypeMessageProvider . DATATYPE_DOMAIN ) ) { spe = new SAXParseException ( fgDatatypeMessages . createMessage ( fLocale , majorCode , minorCode , args ) , locator ) ; } else { throw new RuntimeException ( "FWK007 Unknown error domain \"" + errorDomain + "\"." + "\n" + errorDomain ) ; } if ( fErrorHandler == null ) { if ( errorType == XMLErrorReporter . ERRORTYPE_FATAL_ERROR && ! fContinueAfterFatalError ) { throw spe ; } return ; } if ( errorType == XMLErrorReporter . ERRORTYPE_WARNING ) { fErrorHandler . warning ( spe ) ; } else if ( errorType == XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) { fErrorHandler . fatalError ( spe ) ; if ( ! fContinueAfterFatalError ) { Object [ ] fatalArgs = { spe . getMessage ( ) } ; throw new SAXException ( fgImplementationMessages . createMessage ( fLocale , ImplementationMessages . FATAL_ERROR , 0 , fatalArgs ) ) ; } } else { fErrorHandler . error ( spe ) ; } } public void setFeature ( String featureId , boolean state ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "validation" ) ) { setValidation ( state ) ; return ; } if ( feature . equals ( "external-general-entities" ) ) { setExternalGeneralEntities ( state ) ; return ; } if ( feature . equals ( "external-parameter-entities" ) ) { setExternalParameterEntities ( state ) ; return ; } if ( feature . equals ( "namespaces" ) ) { setNamespaces ( state ) ; return ; } } else if ( featureId . startsWith ( XERCES_FEATURES_PREFIX ) ) { String feature = featureId . substring ( XERCES_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "validation/schema" ) ) { setValidationSchema ( state ) ; return ; } if ( feature . equals ( "validation/dynamic" ) ) { setValidationDynamic ( state ) ; return ; } if ( feature . equals ( "validation/default-attribute-values" ) ) { throw new SAXNotSupportedException ( featureId ) ; } if ( feature . equals ( "validation/validate-content-models" ) ) { throw new SAXNotSupportedException ( featureId ) ; } if ( feature . equals ( "nonvalidating/load-dtd-grammar" ) ) { setLoadDTDGrammar ( state ) ; return ; } if ( feature . equals ( "validation/validate-datatypes" ) ) { throw new SAXNotSupportedException ( featureId ) ; } if ( feature . equals ( "validation/warn-on-duplicate-attdef" ) ) { setValidationWarnOnDuplicateAttdef ( state ) ; return ; } if ( feature . equals ( "validation/warn-on-undeclared-elemdef" ) ) { setValidationWarnOnUndeclaredElemdef ( state ) ; return ; } if ( feature . equals ( "allow-java-encodings" ) ) { setAllowJavaEncodings ( state ) ; return ; } if ( feature . equals ( "continue-after-fatal-error" ) ) { setContinueAfterFatalError ( state ) ; return ; } } throw new SAXNotRecognizedException ( featureId ) ; } public boolean getFeature ( String featureId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "validation" ) ) { return getValidation ( ) ; } if ( feature . equals ( "external-general-entities" ) ) { return getExternalGeneralEntities ( ) ; } if ( feature . equals ( "external-parameter-entities" ) ) { return getExternalParameterEntities ( ) ; } if ( feature . equals ( "namespaces" ) ) { return getNamespaces ( ) ; } } else if ( featureId . startsWith ( XERCES_FEATURES_PREFIX ) ) { String feature = featureId . substring ( XERCES_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "validation/schema" ) ) { return getValidationSchema ( ) ; } if ( feature . equals ( "validation/dynamic" ) ) { return getValidationDynamic ( ) ; } if ( feature . equals ( "validation/default-attribute-values" ) ) { throw new SAXNotRecognizedException ( featureId ) ; } if ( feature . equals ( "validation/validate-content-models" ) ) { throw new SAXNotRecognizedException ( featureId ) ; } if ( feature . equals ( "load-dtd-grammar" ) ) { return getLoadDTDGrammar ( ) ; } if ( feature . equals ( "validation/validate-datatypes" ) ) { throw new SAXNotRecognizedException ( featureId ) ; } if ( feature . equals ( "validation/warn-on-duplicate-attdef" ) ) { return getValidationWarnOnDuplicateAttdef ( ) ; } if ( feature . equals ( "validation/warn-on-undeclared-elemdef" ) ) { return getValidationWarnOnUndeclaredElemdef ( ) ; } if ( feature . equals ( "allow-java-encodings" ) ) { return getAllowJavaEncodings ( ) ; } if ( feature . equals ( "continue-after-fatal-error" ) ) { return getContinueAfterFatalError ( ) ; } } throw new SAXNotRecognizedException ( featureId ) ; } public void setProperty ( String propertyId , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "xml-string" ) ) { throw new SAXNotSupportedException ( propertyId ) ; } } throw new SAXNotRecognizedException ( propertyId ) ; } public Object getProperty ( String propertyId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "xml-string" ) ) { return getXMLString ( ) ; } } throw new SAXNotRecognizedException ( propertyId ) ; } } 	0
package org . apache . xerces . jaxp ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . xml . sax . SAXException ; public class SAXParserFactoryImpl extends SAXParserFactory { public SAXParserFactoryImpl ( ) { super ( ) ; } public SAXParser newSAXParser ( ) throws ParserConfigurationException { return ( new SAXParserImpl ( this . isNamespaceAware ( ) , this . isValidating ( ) ) ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLBodyElement extends HTMLElement { public String getALink ( ) ; public void setALink ( String aLink ) ; public String getBackground ( ) ; public void setBackground ( String background ) ; public String getBgColor ( ) ; public void setBgColor ( String bgColor ) ; public String getLink ( ) ; public void setLink ( String link ) ; public String getText ( ) ; public void setText ( String text ) ; public String getVLink ( ) ; public void setVLink ( String vLink ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public class AttributeMap extends NamedNodeMapImpl { protected AttributeMap ( ElementImpl ownerNode , NamedNodeMapImpl defaults ) { super ( ownerNode ) ; if ( defaults != null ) { cloneContent ( defaults ) ; if ( nodes != null ) { hasDefaults ( true ) ; } } } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } NodeImpl argn = ( NodeImpl ) arg ; if ( argn . isOwned ( ) ) { throw new DOMExceptionImpl ( DOMException . INUSE_ATTRIBUTE_ERR , "DOM009 Attribute already in use" ) ; } argn . ownerNode = ownerNode ; argn . isOwned ( true ) ; int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; previous . ownerNode = ownerNode . ownerDocument ( ) ; previous . isOwned ( false ) ; previous . isSpecified ( true ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { ownerNode . dispatchAggregateEvents ( ( AttrImpl ) arg , previous == null ? null : previous . getNodeValue ( ) ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } NodeImpl argn = ( NodeImpl ) arg ; if ( argn . isOwned ( ) ) { throw new DOMExceptionImpl ( DOMException . INUSE_ATTRIBUTE_ERR , "DOM009 Attribute already in use" ) ; } argn . ownerNode = ownerNode ; argn . isOwned ( true ) ; int i = findNamePoint ( argn . getNamespaceURI ( ) , argn . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; previous . ownerNode = ownerNode . ownerDocument ( ) ; previous . isOwned ( false ) ; previous . isSpecified ( true ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { ownerNode . dispatchAggregateEvents ( ( AttrImpl ) arg , previous == null ? null : previous . getNodeValue ( ) ) ; } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { return internalRemoveNamedItem ( name , true ) ; } Node safeRemoveNamedItem ( String name ) { return internalRemoveNamedItem ( name , false ) ; } final protected Node internalRemoveNamedItem ( String name , boolean raiseEx ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { if ( raiseEx ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } else { return null ; } } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; if ( hasDefaults ( ) ) { NamedNodeMapImpl defaults = ( ( ElementImpl ) ownerNode ) . getDefaultAttributes ( ) ; Node d ; if ( defaults != null && ( d = defaults . getNamedItem ( name ) ) != null && findNamePoint ( name , i + 1 ) < 0 ) { NodeImpl clone = ( NodeImpl ) d . cloneNode ( true ) ; clone . ownerNode = ownerNode ; clone . isOwned ( true ) ; clone . isSpecified ( false ) ; nodes . setElementAt ( clone , i ) ; } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } n . ownerNode = ownerNode . ownerDocument ( ) ; n . isOwned ( false ) ; n . isSpecified ( true ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { return internalRemoveNamedItemNS ( namespaceURI , name , true ) ; } Node safeRemoveNamedItemNS ( String namespaceURI , String name ) { return internalRemoveNamedItemNS ( namespaceURI , name , false ) ; } final protected Node internalRemoveNamedItemNS ( String namespaceURI , String name , boolean raiseEx ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { if ( raiseEx ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } else { return null ; } } LCount lc = null ; String oldvalue = "" ; AttrImpl enclosingAttribute = null ; if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttribute = ( AttrImpl ) ( nodes . elementAt ( i ) ) ; oldvalue = enclosingAttribute . getNodeValue ( ) ; } } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; String nodeName = n . getNodeName ( ) ; if ( hasDefaults ( ) ) { NamedNodeMapImpl defaults = ( ( ElementImpl ) ownerNode ) . getDefaultAttributes ( ) ; Node d ; if ( defaults != null && ( d = defaults . getNamedItem ( nodeName ) ) != null ) { int j = findNamePoint ( nodeName , 0 ) ; if ( j >= 0 && findNamePoint ( nodeName , j + 1 ) < 0 ) { NodeImpl clone = ( NodeImpl ) d . cloneNode ( true ) ; clone . ownerNode = ownerNode ; clone . isOwned ( true ) ; clone . isSpecified ( false ) ; nodes . setElementAt ( clone , i ) ; } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } n . ownerNode = ownerNode . ownerDocument ( ) ; n . isOwned ( false ) ; n . isSpecified ( true ) ; if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_ATTR_MODIFIED , true , false , null , n . getNodeValue ( ) , ( ( ElementImpl ) ownerNode ) . getAttribute ( name ) , name ) ; ownerNode . dispatchEvent ( me ) ; } ownerNode . dispatchAggregateEvents ( null , null ) ; } return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { AttributeMap newmap = new AttributeMap ( ( ElementImpl ) ownerNode , null ) ; newmap . hasDefaults ( hasDefaults ( ) ) ; newmap . cloneContent ( this ) ; return newmap ; } } 	1
package org . apache . html . dom ; public interface HTMLFormControl { } 	0
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . w3c . dom . Document ; public abstract class DocumentBuilder { protected DocumentBuilder ( ) { super ( ) ; } public Document parse ( InputStream stream ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( stream ) ) ) ; } public Document parse ( String uri ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( uri ) ) ) ; } public Document parse ( File file ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( file . getName ( ) ) ) ) ; } public abstract Document parse ( InputSource source ) throws SAXException , IOException , IllegalArgumentException ; public abstract Document newDocument ( ) ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; public abstract void setEntityResolver ( EntityResolver er ) ; public abstract void setErrorHandler ( ErrorHandler eh ) ; } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Enumeration ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . datatype . InvalidDatatypeFacetException ; public class BooleanDatatypeValidator extends AbstractDatatypeValidator { private Locale fLocale = null ; private DatatypeValidator fBaseValidator = null ; private String fPattern = null ; private int fFacetsDefined = 0 ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; private static final String fValueSpace [ ] = { "false" , "true" , "0" , "1" } ; private boolean fDerivedByList = false ; private RegularExpression fRegex = null ; public BooleanDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public BooleanDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { if ( derivedByList == false ) { for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = ( String ) facets . get ( key ) ; if ( fPattern != null ) fRegex = new RegularExpression ( fPattern , "X" ) ; } else { throw new InvalidDatatypeFacetException ( "Only constraining facet in boolean datatype is PATTERN" ) ; } } } else { } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { if ( fDerivedByList == true ) { ; } else { checkContent ( content ) ; } return null ; } public int compare ( String content1 , String content2 ) { return 0 ; } public Hashtable getFacets ( ) { return null ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } private void checkContent ( String content ) throws InvalidDatatypeValueException { boolean isContentInDomain = false ; for ( int i = 0 ; i < fValueSpace . length ; i ++ ) { if ( content . equals ( fValueSpace [ i ] ) ) isContentInDomain = true ; } if ( isContentInDomain == false ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotBoolean , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; if ( ( fFacetsDefined & DatatypeValidator . FACET_PATTERN ) != 0 ) { if ( fRegex == null || fRegex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value'" + content + "does not match regular expression facet" + fPattern ) ; } } } 	0
package org . apache . xerces . dom . events ; import org . apache . xerces . dom . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; public class MutationEventImpl extends org . apache . xerces . dom . events . EventImpl implements MutationEvent { Node relatedNode = null ; String prevValue = null , newValue = null , attrName = null ; public static final String DOM_SUBTREE_MODIFIED = "DOMSubtreeModified" ; public static final String DOM_NODE_INSERTED = "DOMNodeInserted" ; public static final String DOM_NODE_REMOVED = "DOMNodeRemoved" ; public static final String DOM_NODE_REMOVED_FROM_DOCUMENT = "DOMNodeRemovedFromDocument" ; public static final String DOM_NODE_INSERTED_INTO_DOCUMENT = "DOMNodeInsertedIntoDocument" ; public static final String DOM_ATTR_MODIFIED = "DOMAttrModified" ; public static final String DOM_CHARACTER_DATA_MODIFIED = "DOMCharacterDataModified" ; public String getAttrName ( ) { return attrName ; } public String getNewValue ( ) { return newValue ; } public String getPrevValue ( ) { return prevValue ; } public Node getRelatedNode ( ) { return relatedNode ; } public void initMutationEvent ( String typeArg , boolean canBubbleArg , boolean cancelableArg , Node relatedNodeArg , String prevValueArg , String newValueArg , String attrNameArg ) { relatedNode = relatedNodeArg ; prevValue = prevValueArg ; newValue = newValueArg ; attrName = attrNameArg ; super . initEvent ( typeArg , canBubbleArg , cancelableArg ) ; } } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . CharDataChunk ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringHasher ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . ImplementationMessages ; import org . xml . sax . SAXParseException ; import java . io . Reader ; import java . util . Vector ; public class StreamingCharReader extends XMLEntityReader { public StreamingCharReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , Reader reader , StringPool stringPool ) throws Exception { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fStringPool = stringPool ; fCharacterStream = reader ; fCurrentChunk = CharDataChunk . createChunk ( fStringPool , null ) ; loadFirstChar ( ) ; } protected void deferException ( int errorCode , Object [ ] args , int offset ) { if ( fDeferredErrors == null ) fDeferredErrors = new Vector ( ) ; DeferredError de = new DeferredError ( errorCode , args , offset ) ; fDeferredErrors . addElement ( de ) ; } protected XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; return nextReader ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } public boolean lookingAtChar ( char chr , boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch != chr ) { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( chr , skipPastChar ) ; } } return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0xD800 ) { if ( ch >= 0x20 || ch == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } if ( ch == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } return true ; } if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } if ( ch > 0xFFFD ) { return false ; } if ( ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; boolean valid = ( ch >= 0xDC00 && ch < 0xE000 ) ; if ( ! valid || ! skipPastChar ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return valid ; } } else if ( ch < 0xE000 ) { return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } loadNextChar ( ) ; return true ; } public void skipToChar ( char chr ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == chr ) return ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( chr ) ; return ; } fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch >= 0xD800 && ch < 0xDC00 ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) continue ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } ch = loadNextChar ( ) ; } } public void skipPastName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return ; } while ( true ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int ch = fMostRecentChar ; if ( ch != s [ 0 ] ) return false ; int length = s . length ; CharDataChunk dataChunk = fCurrentChunk ; int offset = fCurrentOffset ; int index = fCurrentIndex ; ch = loadNextChar ( ) ; for ( int i = 1 ; i < length ; i ++ ) { if ( ch != s [ i ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ index ] & 0xFFFF ; return false ; } ch = loadNextChar ( ) ; } fCharacterCounter += length ; return true ; } public int scanInvalidChar ( ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } if ( fDeferredErrors != null ) { for ( int i = 0 ; i < fDeferredErrors . size ( ) ; i ++ ) { DeferredError de = ( DeferredError ) fDeferredErrors . elementAt ( i ) ; if ( de . offset == fCurrentIndex ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , de . errorCode , 0 , de . args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; fDeferredErrors . removeElementAt ( i ) ; fCharacterCounter ++ ; loadNextChar ( ) ; return - 1 ; } } } fCharacterCounter ++ ; loadNextChar ( ) ; } else { fCharacterCounter ++ ; if ( ch >= 0xD800 && ch < 0xDC00 ) { int ch2 = loadNextChar ( ) ; if ( ch2 >= 0xDC00 && ch2 < 0xE000 ) { ch = ( ( ch - 0xD800 ) << 10 ) + ( ch2 - 0xDC00 ) + 0x10000 ; loadNextChar ( ) ; } } else loadNextChar ( ) ; } return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextChar ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentChar ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextChar ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextChar ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( lookingAtChar ( qchar , false ) ) { break ; } if ( lookingAtChar ( ' ' , true ) ) { continue ; } if ( lookingAtSpace ( false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '<' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } int result = asSymbol ? addSymbol ( offset , fCurrentOffset - offset ) : addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return result ; } public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } if ( qchar != - 1 && lookingAtChar ( ( char ) qchar , false ) ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; break ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; } if ( lookingAtChar ( '%' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } int result = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( ( char ) qchar , true ) ; return result ; } public int scanName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return - 1 ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return - 1 ; } int offset = fCurrentOffset ; fCharacterCounter ++ ; int hashcode = 0 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = loadNextChar ( ) ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } fCharacterCounter ++ ; } hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; int nameIndex = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; return nameIndex ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int ch = fMostRecentChar ; for ( int i = 0 ; i < len ; i ++ ) { if ( ch != expected [ offset ++ ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; fCharacterCounter ++ ; int hashcode = 0 ; int prefixend = - 1 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = loadNextChar ( ) ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; CharDataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; int savedIndex = fCurrentIndex ; ch = loadNextChar ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fCurrentIndex = savedIndex ; fMostRecentData = savedChunk . toCharArray ( ) ; boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; fMostRecentChar = ch ; break ; } } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } fCharacterCounter ++ ; } hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; qname . rawname = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentChar ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeMarkup ( ch ) ; } break ; case 2 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } break ; case 3 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch != ']' ) break ; { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; break ; } } loadNextChar ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , true ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } break ; } } else if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , false ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextChar ( ) ; break ; } callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentChar ; } } } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool fStringPool = null ; private boolean fCallClearPreviousChunk = true ; private Vector fDeferredErrors = null ; private class DeferredError { int errorCode ; Object [ ] args ; int offset ; DeferredError ( int ec , Object [ ] a , int o ) { errorCode = ec ; args = a ; offset = o ; } } private int recognizeMarkup ( int ch ) throws Exception { switch ( ch ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( ch == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } private boolean skipMultiByteCharData ( int ch ) throws Exception { if ( ch < 0xD800 ) { loadNextChar ( ) ; return true ; } if ( ch > 0xFFFD ) return false ; if ( ch >= 0xDC00 && ch < 0xE000 ) return false ; if ( ch >= 0xD800 && ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } loadNextChar ( ) ; return true ; } private int skipAsciiCharData ( ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch >= 0x80 ) { return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { return ch ; } ch = loadNextChar ( ) ; } } private void callCharDataHandler ( int offset , int endOffset , boolean isWhitespace ) throws Exception { int length = endOffset - offset ; if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , length ) ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( stringIndex ) ; else fCharDataHandler . processCharacters ( stringIndex ) ; return ; } CharDataChunk dataChunk = fCurrentChunk . chunkFor ( offset ) ; int index = offset & CharDataChunk . CHUNK_MASK ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { if ( length != 0 ) { if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , length ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , length ) ; } return ; } int count = length ; int nbytes = CharDataChunk . CHUNK_SIZE - index ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , nbytes ) ; count -= nbytes ; do { dataChunk = dataChunk . nextChunk ( ) ; if ( dataChunk == null ) { throw new RuntimeException ( new ImplementationMessages ( ) . createMessage ( null , ImplementationMessages . INT_DCN , 0 , null ) ) ; } nbytes = count <= CharDataChunk . CHUNK_SIZE ? count : CharDataChunk . CHUNK_SIZE ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; count -= nbytes ; } while ( count > 0 ) ; } private int slowLoadNextChar ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toCharArray ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } else { fCurrentChunk = CharDataChunk . createChunk ( fStringPool , fCurrentChunk ) ; fCurrentIndex = 0 ; fFillIndex = 0 ; loadFirstChar ( ) ; return fMostRecentChar ; } } private int loadNextChar ( ) throws Exception { fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) return slowLoadNextChar ( ) ; if ( fCurrentIndex < fFillIndex ) return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; return loadMoreChars ( ) ; } private void loadFirstChar ( ) throws Exception { fMostRecentData = fCurrentChunk . toCharArray ( ) ; if ( fMostRecentData == null ) { fMostRecentData = new char [ CharDataChunk . CHUNK_SIZE ] ; fCurrentChunk . setCharArray ( fMostRecentData ) ; } loadMoreChars ( ) ; } private boolean seenCR = false ; private int oweChar = - 1 ; private char [ ] inBuffer = new char [ 2 ] ; private int loadMoreChars ( ) throws Exception { if ( oweChar != - 1 ) { fMostRecentData [ fFillIndex ] = ( char ) oweChar ; fFillIndex ++ ; fLength ++ ; fMostRecentChar = oweChar ; oweChar = - 1 ; return fMostRecentChar ; } int result = - 1 ; try { while ( true ) { result = fCharacterStream . read ( inBuffer , 0 , 2 ) ; switch ( result ) { case - 1 : break ; case 0 : continue ; case 1 : result = inBuffer [ 0 ] ; if ( seenCR ) { seenCR = false ; if ( result == 0x0A ) continue ; } if ( result == 0x0D ) { seenCR = true ; result = 0x0A ; } fMostRecentChar = ( fMostRecentData [ fFillIndex ] = ( char ) result ) ; fFillIndex ++ ; fLength ++ ; return fMostRecentChar ; case 2 : result = inBuffer [ 0 ] ; boolean readchar2 = false ; if ( seenCR ) { seenCR = false ; if ( result == 0x0A ) { result = inBuffer [ 1 ] ; readchar2 = true ; } } if ( result == 0x0D ) { seenCR = true ; result = 0x0A ; } fMostRecentChar = ( fMostRecentData [ fFillIndex ] = ( char ) result ) ; fFillIndex ++ ; fLength ++ ; if ( ! readchar2 ) { result = inBuffer [ 1 ] ; if ( seenCR ) { seenCR = false ; if ( result == 0x0A ) return fMostRecentChar ; } if ( result == 0x0D ) { seenCR = true ; result = 0x0A ; } oweChar = result ; } return fMostRecentChar ; } break ; } } catch ( java . io . IOException ex ) { } try { fCharacterStream . close ( ) ; } catch ( java . io . IOException ex ) { } fCharacterStream = null ; fMostRecentChar = ( fMostRecentData [ fFillIndex ] = 0 ) ; return 0 ; } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } protected Reader fCharacterStream = null ; protected CharDataChunk fCurrentChunk = null ; protected int fCurrentIndex = 0 ; protected int fFillIndex = 0 ; protected char [ ] fMostRecentData = null ; protected int fMostRecentChar = 0 ; protected int fLength = 0 ; protected boolean fCalledCharPropInit = false ; } 	0
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . SymbolCache ; import org . apache . xerces . utils . UTF8DataChunk ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . LocatorImpl ; import java . io . InputStream ; import java . util . Vector ; final class UTF8Reader extends XMLEntityReader { private final static boolean USE_OUT_OF_LINE_LOAD_NEXT_BYTE = false ; private final static boolean USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE = true ; public UTF8Reader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , InputStream dataStream , StringPool stringPool ) throws Exception { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fInputStream = dataStream ; fStringPool = stringPool ; fCharArrayRange = fStringPool . createCharArrayRange ( ) ; fCurrentChunk = UTF8DataChunk . createChunk ( fStringPool , null ) ; fillCurrentChunk ( ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } private int addSymbol ( int offset , int length , int hashcode ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , hashcode ) ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } private int slowLoadNextByte ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; return ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } else { fCurrentChunk = UTF8DataChunk . createChunk ( fStringPool , fCurrentChunk ) ; return fillCurrentChunk ( ) ; } } private int loadNextByte ( ) throws Exception { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; return fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { return slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) return slowLoadNextByte ( ) ; else return ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; fMostRecentData = null ; fMostRecentByte = 0 ; return nextReader ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) throws Exception { int b0 = fMostRecentByte ; if ( b0 != ch ) { if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( ch , skipPastChar ) ; } } if ( ch == 0x0A && b0 == 0x0D ) { if ( skipPastChar ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; b0 = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == 0x0A ) { fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } } return true ; } return false ; } if ( ch == 0x0D ) return false ; if ( skipPastChar ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int b0 = fMostRecentByte ; if ( b0 < 0x80 ) { if ( b0 >= 0x20 || b0 == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } if ( b0 == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } if ( b0 == 0x0D ) { if ( skipPastChar ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; b0 = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == 0x0A ) { fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } } return true ; } if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; } return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { boolean result = false ; if ( ! ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; return true ; } result = true ; } fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } int b3 = loadNextByte ( ) ; boolean result = false ; if ( ( ( b0 & 0xf8 ) == 0xf0 ) && ( ( b1 & 0xc0 ) == 0x80 ) && ( ( b2 & 0xc0 ) == 0x80 ) && ( ( b3 & 0xc0 ) == 0x80 ) ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; return true ; } result = true ; fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentByte ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { if ( ! skipPastChar ) return true ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) return true ; fLinefeedCounter ++ ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return true ; } public void skipToChar ( char ch ) throws Exception { int b0 = fMostRecentByte ; while ( true ) { if ( b0 == ch ) return ; if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( ch ) ; return ; } fCharacterCounter ++ ; } else if ( b0 == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( b0 == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; if ( b0 != 0x0A ) continue ; fLinefeedCounter ++ ; } else if ( b0 < 0x80 ) { fCharacterCounter ++ ; } else { fCharacterCounter ++ ; if ( ( 0xe0 & b0 ) == 0xc0 ) { loadNextByte ( ) ; } else if ( ( 0xf0 & b0 ) == 0xe0 ) { loadNextByte ( ) ; loadNextByte ( ) ; } else { loadNextByte ( ) ; loadNextByte ( ) ; loadNextByte ( ) ; } } b0 = loadNextByte ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentByte ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) continue ; fLinefeedCounter ++ ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } } protected boolean skippedMultiByteCharWithFlag ( int b0 , int flag ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { if ( ( XMLCharacterProperties . fgCharFlags [ ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ] & flag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } if ( ( XMLCharacterProperties . fgCharFlags [ ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ] & flag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } return true ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } public void skipPastName ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ b0 ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_InitialNameCharFlag ) ) return ; } while ( true ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( fastcheck == b0 ) return ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_NameCharFlag ) ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; while ( true ) { if ( fastcheck == b0 ) return ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) return ; } else { if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_NameCharFlag ) ) return ; } fCharacterCounter ++ ; b0 = loadNextByte ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int length = s . length ; byte [ ] data = fMostRecentData ; int index = fCurrentIndex + length ; int sindex = length ; try { while ( sindex -- > 0 ) { if ( data [ -- index ] != s [ sindex ] ) return false ; } fCurrentIndex += length ; } catch ( ArrayIndexOutOfBoundsException ex ) { int i = 0 ; index = fCurrentIndex ; while ( index < UTF8DataChunk . CHUNK_SIZE ) { if ( data [ index ++ ] != s [ i ++ ] ) return false ; } UTF8DataChunk dataChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; int savedIndex = fCurrentIndex ; slowLoadNextByte ( ) ; data = fMostRecentData ; index = 0 ; while ( i < length ) { if ( data [ index ++ ] != s [ i ++ ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; return false ; } } fCurrentIndex = index ; } fCharacterCounter += length ; fCurrentOffset += length ; try { fMostRecentByte = data [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } return true ; } public int scanInvalidChar ( ) throws Exception { int b0 = fMostRecentByte ; int ch = b0 ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; if ( ch != 0x0A ) return 0x0A ; fLinefeedCounter ++ ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } fCharacterCounter ++ ; } else if ( b0 >= 0x80 ) { fCharacterCounter ++ ; int b1 = loadNextByte ( ) ; int b2 = 0 ; if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; } else if ( ( 0xf0 & b0 ) == 0xe0 ) { b2 = loadNextByte ( ) ; ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; } else if ( ( 0xf8 & b0 ) == 0xf0 ) { b2 = loadNextByte ( ) ; int b3 = loadNextByte ( ) ; ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; } } loadNextByte ( ) ; return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentByte ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextByte ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentByte ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextByte ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextByte ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = fCurrentChunk . addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public static final byte fgAsciiAttValueChar [ ] = { 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 2 , 2 , 4 , 4 , 2 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 0 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; int b0 = fMostRecentByte ; while ( true ) { if ( b0 < 0x80 ) { switch ( fgAsciiAttValueChar [ b0 ] ) { case 1 : if ( b0 == qchar ) { int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : ( asSymbol ? fCurrentChunk . addSymbol ( offset , length , 0 ) : fCurrentChunk . addString ( offset , length ) ) ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return result ; } case 0 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 2 : return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; case 3 : return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; case 4 : return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( b0 ) ) return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; b0 = fMostRecentByte ; } } } public static final byte fgAsciiEntityValueChar [ ] = { 7 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 5 , 4 , 4 , 6 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 3 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; int b0 = fMostRecentByte ; while ( true ) { if ( b0 < 0x80 ) { switch ( fgAsciiEntityValueChar [ b0 ] ) { case 1 : if ( b0 == qchar ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : fCurrentChunk . addString ( offset , length ) ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return result ; } case 0 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 5 : fLinefeedCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 6 : fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 != 0x0A ) { continue ; } fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 2 : return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; case 3 : return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; case 7 : if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } case 4 : return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( b0 ) ) return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; b0 = fMostRecentByte ; } } } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int b0 = fMostRecentByte ; int ch = 0 ; int i = 0 ; while ( true ) { if ( b0 < 0x80 ) { ch = b0 ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } } else { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; skipPastNmtoken ( fastcheck ) ; return false ; } } else { int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; skipPastNmtoken ( fastcheck ) ; return false ; } } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } } i ++ ; offset ++ ; fCharacterCounter ++ ; fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentByte ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; int index = fCurrentIndex ; byte [ ] data = fMostRecentData ; int prefixend = - 1 ; while ( true ) { fCharacterCounter ++ ; fCurrentOffset ++ ; index ++ ; try { ch = data [ index ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; index = 0 ; data = fMostRecentData ; } if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; try { ch = data [ index + 1 ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { UTF8DataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; ch = slowLoadNextByte ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; } boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; break ; } } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } } fCurrentIndex = index ; fMostRecentByte = ch ; int length = fCurrentOffset - offset ; qname . rawname = addSymbol ( offset , length ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } private int getMultiByteSymbolChar ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } loadNextByte ( ) ; return ch ; } int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } loadNextByte ( ) ; return ch ; } fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } public int scanName ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; int ch ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ b0 ] == 0 ) { if ( b0 == 0 && atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanName ( fastcheck ) ; } return - 1 ; } ch = b0 ; } else { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } else { int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return scanMatchingName ( ch , b0 , fastcheck ) ; } private int scanMatchingName ( int ch , int b0 , int fastcheck ) throws Exception { SymbolCache cache = fStringPool . getSymbolCache ( ) ; int [ ] [ ] cacheLines = cache . fCacheLines ; char [ ] symbolChars = cache . fSymbolChars ; boolean lengthOfOne = fastcheck == fMostRecentByte ; int startOffset = cache . fSymbolCharsOffset ; int entry = 0 ; int [ ] entries = cacheLines [ entry ] ; int offset = 1 + ( ( entries [ 0 ] - 1 ) * SymbolCache . CACHE_RECORD_SIZE ) ; int totalMisses = 0 ; if ( lengthOfOne ) { while ( offset > 0 ) { if ( entries [ offset + SymbolCache . CHAR_OFFSET ] == ch ) { if ( entries [ offset + SymbolCache . INDEX_OFFSET ] != - 1 ) { int symbolIndex = entries [ offset + SymbolCache . INDEX_OFFSET ] ; if ( totalMisses > 3 ) fStringPool . updateCacheLine ( symbolIndex , totalMisses , 1 ) ; return symbolIndex ; } break ; } offset -= SymbolCache . CACHE_RECORD_SIZE ; totalMisses ++ ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; if ( offset < 0 ) { offset = 1 + ( entries [ 0 ] * SymbolCache . CACHE_RECORD_SIZE ) ; entries [ 0 ] ++ ; try { entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; entries = new int [ newSize ] ; System . arraycopy ( cacheLines [ entry ] , 0 , entries , 0 , offset ) ; cacheLines [ entry ] = entries ; entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } entries [ offset + SymbolCache . NEXT_OFFSET ] = - 1 ; } int result = fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; return result ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; int depth = 1 ; while ( true ) { if ( offset < 0 ) break ; if ( entries [ offset + SymbolCache . CHAR_OFFSET ] != ch ) { offset -= SymbolCache . CACHE_RECORD_SIZE ; totalMisses ++ ; continue ; } if ( b0 >= 0x80 ) { ch = getMultiByteSymbolChar ( b0 ) ; b0 = fMostRecentByte ; } else if ( b0 == fastcheck || XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) { ch = - 1 ; } else { ch = b0 ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } if ( ch == - 1 ) { if ( entries [ offset + SymbolCache . INDEX_OFFSET ] == - 1 ) { return fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; } cache . fSymbolCharsOffset = startOffset ; int symbolIndex = entries [ offset + SymbolCache . INDEX_OFFSET ] ; if ( totalMisses > ( depth * 3 ) ) fStringPool . updateCacheLine ( symbolIndex , totalMisses , depth ) ; return symbolIndex ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; entry = entries [ offset + SymbolCache . NEXT_OFFSET ] ; try { entries = cacheLines [ entry ] ; } catch ( ArrayIndexOutOfBoundsException ex ) { if ( entry == - 1 ) { entry = cache . fCacheLineCount ++ ; entries [ offset + SymbolCache . NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( SymbolCache . INITIAL_CACHE_RECORD_COUNT * SymbolCache . CACHE_RECORD_SIZE ) ] ; try { cacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex2 ) { cacheLines = new int [ entry * 2 ] [ ] ; System . arraycopy ( cache . fCacheLines , 0 , cacheLines , 0 , entry ) ; cache . fCacheLines = cacheLines ; cacheLines [ entry ] = entries ; } } else { entries = cacheLines [ entry ] ; throw new RuntimeException ( "RDR001 untested" ) ; } } offset = 1 + ( ( entries [ 0 ] - 1 ) * SymbolCache . CACHE_RECORD_SIZE ) ; depth ++ ; } if ( offset < 0 ) offset = 1 + ( entries [ 0 ] * SymbolCache . CACHE_RECORD_SIZE ) ; while ( true ) { entries [ 0 ] ++ ; try { entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; entries = new int [ newSize ] ; System . arraycopy ( cacheLines [ entry ] , 0 , entries , 0 , offset ) ; cacheLines [ entry ] = entries ; entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } if ( b0 >= 0x80 ) { ch = getMultiByteSymbolChar ( b0 ) ; b0 = fMostRecentByte ; } else if ( b0 == fastcheck || XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) { ch = - 1 ; } else { ch = b0 ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } if ( ch == - 1 ) { entries [ offset + SymbolCache . NEXT_OFFSET ] = - 1 ; break ; } entry = cache . fCacheLineCount ++ ; entries [ offset + SymbolCache . INDEX_OFFSET ] = - 1 ; entries [ offset + SymbolCache . NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( SymbolCache . INITIAL_CACHE_RECORD_COUNT * SymbolCache . CACHE_RECORD_SIZE ) ] ; try { cacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex ) { cacheLines = new int [ entry * 2 ] [ ] ; System . arraycopy ( cache . fCacheLines , 0 , cacheLines , 0 , entry ) ; cache . fCacheLines = cacheLines ; cacheLines [ entry ] = entries ; } offset = 1 ; try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; } int result = fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; return result ; } private int recognizeMarkup ( int b0 , QName element ) throws Exception { switch ( b0 ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 == '-' ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 == '-' ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( b0 == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } int expectedName = element . rawname ; fStringPool . getCharArrayRange ( expectedName , fCharArrayRange ) ; char [ ] expected = fCharArrayRange . chars ; int offset = fCharArrayRange . offset ; int len = fCharArrayRange . length ; if ( b0 == expected [ offset ++ ] ) { UTF8DataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; for ( int i = 1 ; i < len ; i ++ ) { if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 != expected [ offset ++ ] ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; } } fCharacterCounter += len ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == '>' ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG ; } while ( b0 == 0x20 || b0 == 0x09 || b0 == 0x0A || b0 == 0x0D ) { if ( b0 == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; } else if ( b0 == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; if ( b0 == 0x0A ) { fLinefeedCounter ++ ; b0 = loadNextByte ( ) ; } } else { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; } if ( b0 == '>' ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG ; } } fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; } return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; fCharDataLength = 0 ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentByte ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } break ; case 1 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ! fInCDSect ) { return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; break ; case 2 : fCharacterCounter ++ ; ch = loadNextByte ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; break ; case 3 : fCharacterCounter ++ ; ch = loadNextByte ( ) ; if ( ch != ']' ) { if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) { if ( fSendCharDataAsCharArray ) appendCharData ( 0x0A ) ; if ( ch == 0x20 || ch == 0x09 || ch == 0x0D ) continue ; break ; } fLinefeedCounter ++ ; } else { fCharacterCounter ++ ; } if ( fSendCharDataAsCharArray ) { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A || ch == 0x0D ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 1 : if ( ! fInCDSect ) { if ( fSendCharDataAsCharArray ) { fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = addString ( charDataOffset , fCurrentOffset - charDataOffset ) ; fCharDataHandler . processWhitespace ( stringIndex ) ; } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 2 : if ( ! fInCDSect ) { whitespace ( charDataOffset , fCurrentOffset ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextByte ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; whitespace ( charDataOffset , endOffset ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : whitespace ( charDataOffset , fCurrentOffset ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { whitespace ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { whitespace ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } break ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } } if ( fSendCharDataAsCharArray ) ch = copyAsciiCharData ( ) ; else ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 1 : if ( ! fInCDSect ) { if ( fSendCharDataAsCharArray ) { fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = addString ( charDataOffset , fCurrentOffset - charDataOffset ) ; fCharDataHandler . processCharacters ( stringIndex ) ; } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 2 : if ( ! fInCDSect ) { characters ( charDataOffset , fCurrentOffset ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextByte ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; characters ( charDataOffset , endOffset ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; break ; } if ( ch == 0x0D ) { if ( fSendCharDataAsCharArray ) appendCharData ( 0x0A ) ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; ch = loadNextByte ( ) ; } break ; } characters ( charDataOffset , fCurrentOffset ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { characters ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { characters ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentByte ; } } } private boolean copyMultiByteCharData ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; appendCharData ( ch ) ; loadNextByte ( ) ; return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; appendCharData ( ch ) ; loadNextByte ( ) ; return true ; } int b3 = loadNextByte ( ) ; if ( ( 0xf8 & b0 ) == 0xf0 ) { if ( b0 > 0xF4 || ( b0 == 0xF4 && b1 >= 0x90 ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } int ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; if ( ch < 0x10000 ) { appendCharData ( ch ) ; } else { appendCharData ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; appendCharData ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; } loadNextByte ( ) ; return true ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } private boolean skipMultiByteCharData ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { loadNextByte ( ) ; return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } loadNextByte ( ) ; return true ; } int b3 = loadNextByte ( ) ; if ( b0 > 0xF4 || ( b0 == 0xF4 && b1 >= 0x90 ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } loadNextByte ( ) ; return true ; } private int copyAsciiCharData ( ) throws Exception { int srcIndex = fCurrentIndex ; int offset = fCurrentOffset - srcIndex ; byte [ ] data = fMostRecentData ; int dstIndex = fCharDataLength ; boolean skiplf = false ; while ( true ) { int ch ; try { ch = data [ srcIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { offset += srcIndex ; slowLoadNextByte ( ) ; srcIndex = 0 ; data = fMostRecentData ; ch = data [ srcIndex ] & 0xFF ; } if ( ch >= 0x80 ) { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; skiplf = false ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; if ( skiplf ) { skiplf = false ; srcIndex ++ ; continue ; } fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; skiplf = true ; ch = 0x0A ; } else { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } srcIndex ++ ; try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } } private int skipAsciiCharData ( ) throws Exception { int srcIndex = fCurrentIndex ; int offset = fCurrentOffset - srcIndex ; byte [ ] data = fMostRecentData ; while ( true ) { int ch ; try { ch = data [ srcIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { offset += srcIndex ; slowLoadNextByte ( ) ; srcIndex = 0 ; data = fMostRecentData ; ch = data [ srcIndex ] & 0xFF ; } if ( ch >= 0x80 ) { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } srcIndex ++ ; } } private char [ ] fCharacters = new char [ UTF8DataChunk . CHUNK_SIZE ] ; private int fCharDataLength = 0 ; private void appendCharData ( int ch ) throws Exception { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } private void slowAppendCharData ( int ch ) throws Exception { characters ( 0 , fCharDataLength ) ; fCharDataLength = 0 ; fCharacters [ fCharDataLength ++ ] = ( char ) ch ; } private void characters ( int offset , int endOffset ) throws Exception { if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , endOffset - offset ) ; fCharDataHandler . processCharacters ( stringIndex ) ; return ; } fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } private void whitespace ( int offset , int endOffset ) throws Exception { if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , endOffset - offset ) ; fCharDataHandler . processWhitespace ( stringIndex ) ; return ; } fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool . CharArrayRange fCharArrayRange = null ; private InputStream fInputStream = null ; private StringPool fStringPool = null ; private UTF8DataChunk fCurrentChunk = null ; private int fCurrentIndex = 0 ; private byte [ ] fMostRecentData = null ; private int fMostRecentByte = 0 ; private int fLength = 0 ; private boolean fCalledCharPropInit = false ; private boolean fCallClearPreviousChunk = true ; private int fillCurrentChunk ( ) throws Exception { byte [ ] buf = fCurrentChunk . toByteArray ( ) ; if ( fInputStream == null ) { if ( buf == null ) buf = new byte [ 1 ] ; buf [ 0 ] = 0 ; fMostRecentData = buf ; fCurrentIndex = 0 ; fCurrentChunk . setByteArray ( fMostRecentData ) ; return ( fMostRecentByte = fMostRecentData [ 0 ] & 0xFF ) ; } if ( buf == null ) buf = new byte [ UTF8DataChunk . CHUNK_SIZE ] ; int offset = 0 ; int capacity = UTF8DataChunk . CHUNK_SIZE ; int result = 0 ; do { try { result = fInputStream . read ( buf , offset , capacity ) ; } catch ( java . io . IOException ex ) { result = - 1 ; } if ( result == - 1 ) { fInputStream . close ( ) ; fInputStream = null ; try { buf [ offset ] = 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { } break ; } if ( result > 0 ) { offset += result ; capacity -= result ; } } while ( capacity > 0 ) ; fMostRecentData = buf ; fLength += offset ; fCurrentIndex = 0 ; fCurrentChunk . setByteArray ( fMostRecentData ) ; return ( fMostRecentByte = fMostRecentData [ 0 ] & 0xFF ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLFrameSetElement extends HTMLElement { public String getCols ( ) ; public void setCols ( String cols ) ; public String getRows ( ) ; public void setRows ( String rows ) ; } 	0
package org . apache . xerces . dom . events ; import org . w3c . dom . events . * ; import org . w3c . dom . Node ; public class EventImpl implements Event { public String type = null ; public EventTarget target ; public Node currentNode ; public short eventPhase ; public boolean initialized = false , bubbles = true , cancelable = false ; public boolean stopPropagation = false , preventDefault = false ; protected long timeStamp = System . currentTimeMillis ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) { type = eventTypeArg ; bubbles = canBubbleArg ; cancelable = cancelableArg ; initialized = true ; } public boolean getBubbles ( ) { return bubbles ; } public boolean getCancelable ( ) { return cancelable ; } public Node getCurrentNode ( ) { return currentNode ; } public short getEventPhase ( ) { return eventPhase ; } public EventTarget getTarget ( ) { return target ; } public String getType ( ) { return type ; } public long getTimeStamp ( ) { return timeStamp ; } public void stopPropagation ( ) { stopPropagation = true ; } public void preventDefault ( ) { preventDefault = true ; } } 	1
package org . w3c . dom . html ; public interface HTMLLIElement extends HTMLElement { public String getType ( ) ; public void setType ( String type ) ; public int getValue ( ) ; public void setValue ( int value ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DOMImplementationImpl implements DOMImplementation { static DOMImplementationImpl singleton = new DOMImplementationImpl ( ) ; public boolean hasFeature ( String feature , String version ) { return ( feature . equalsIgnoreCase ( "XML" ) && ( version == null || version . equals ( "1.0" ) || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "Events" ) && ( version == null || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "MutationEvents" ) && ( version == null || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "Traversal" ) && ( version == null || version . equals ( "2.0" ) ) ) ; } public static DOMImplementation getDOMImplementation ( ) { return singleton ; } public DocumentType createDocumentType ( String qualifiedName , String publicID , String systemID ) { if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; if ( index == 0 || index == qualifiedName . length ( ) - 1 ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } return new DocumentTypeImpl ( null , qualifiedName , publicID , systemID ) ; } public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException { if ( doctype != null && doctype . getOwnerDocument ( ) != null ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } DocumentImpl doc = new DocumentImpl ( doctype ) ; Element e = doc . createElementNS ( namespaceURI , qualifiedName ) ; doc . appendChild ( e ) ; return doc ; } } 	1
package org . apache . xerces . validators . dtd ; import org . apache . xerces . dom . DocumentImpl ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDTDScanner ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . validators . common . Grammar ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . schema . XUtil ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; public class DTDGrammar extends Grammar implements XMLDTDScanner . EventHandler { private static final int CHUNK_SHIFT = 8 ; private static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; private static final int CHUNK_MASK = CHUNK_SIZE - 1 ; private static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; private StringPool fStringPool ; private XMLElementDecl fElementDecl = new XMLElementDecl ( ) ; private XMLAttributeDecl fAttributeDecl = new XMLAttributeDecl ( ) ; private XMLContentSpec fContentSpec = new XMLContentSpec ( ) ; private Document fGrammarDocument ; private Element fRootElement ; private QName fRootElementQName = new QName ( ) ; private Element fCurrentElement ; private int fElementDeclIsExternal [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fElementDeclMap [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fAttributeDeclIsExternal [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fAttributeDeclMap [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fContentSpecMap [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private QName fQName = new QName ( ) ; public DTDGrammar ( StringPool stringPool ) { reset ( stringPool ) ; } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; } public void callStartDTD ( ) throws Exception { setGrammarDocument ( null ) ; fGrammarDocument = new DocumentImpl ( ) ; fRootElement = fGrammarDocument . createElement ( "dtd" ) ; fCurrentElement = fRootElement ; } public void callEndDTD ( ) throws Exception { setGrammarDocument ( fGrammarDocument ) ; } public void callTextDecl ( int version , int encoding ) throws Exception { Element textDecl = fGrammarDocument . createElement ( "textDecl" ) ; textDecl . setAttribute ( "version" , fStringPool . toString ( version ) ) ; textDecl . setAttribute ( "encoding" , fStringPool . toString ( encoding ) ) ; fCurrentElement . appendChild ( textDecl ) ; } public void doctypeDecl ( QName rootElement , int publicId , int systemId ) throws Exception { Element doctypeDecl = fGrammarDocument . createElement ( "doctypeDecl" ) ; doctypeDecl . setAttribute ( "name" , fStringPool . toString ( rootElement . rawname ) ) ; if ( rootElement . uri != - 1 ) { doctypeDecl . setAttribute ( "xmlns:" + fStringPool . toString ( rootElement . prefix ) , fStringPool . toString ( rootElement . uri ) ) ; } doctypeDecl . setAttribute ( "publicId" , fStringPool . toString ( publicId ) ) ; doctypeDecl . setAttribute ( "systemId" , fStringPool . toString ( systemId ) ) ; fCurrentElement . appendChild ( doctypeDecl ) ; fRootElementQName . setValues ( rootElement ) ; } public void startReadingFromExternalSubset ( int publicId , int systemId ) throws Exception { Element externalSubset = fGrammarDocument . createElement ( "external" ) ; externalSubset . setAttribute ( "publicId" , fStringPool . toString ( publicId ) ) ; externalSubset . setAttribute ( "systemId" , fStringPool . toString ( systemId ) ) ; fCurrentElement . appendChild ( externalSubset ) ; fCurrentElement = externalSubset ; } public void stopReadingFromExternalSubset ( ) throws Exception { fCurrentElement = ( Element ) fCurrentElement . getParentNode ( ) ; } public int addElementDecl ( QName elementDecl ) throws Exception { Element elementDeclElement = fGrammarDocument . createElement ( "elementDecl" ) ; elementDeclElement . setAttribute ( "name" , fStringPool . toString ( elementDecl . localpart ) ) ; if ( elementDecl . uri != - 1 ) { elementDeclElement . setAttribute ( "xmlns:" + fStringPool . toString ( elementDecl . prefix ) , fStringPool . toString ( elementDecl . uri ) ) ; } fCurrentElement . appendChild ( elementDeclElement ) ; int elementDeclIndex = createElementDecl ( ) ; fElementDecl . clear ( ) ; fElementDecl . name . setValues ( elementDecl ) ; setElementDecl ( elementDeclIndex , fElementDecl ) ; return elementDeclIndex ; } public int addElementDecl ( QName elementDecl , int contentSpecType , int contentSpec , boolean isExternal ) throws Exception { Element elementDeclElement = fGrammarDocument . createElement ( "elementDecl" ) ; elementDeclElement . setAttribute ( "name" , fStringPool . toString ( elementDecl . localpart ) ) ; if ( elementDecl . uri != - 1 ) { elementDeclElement . setAttribute ( "xmlns:" + fStringPool . toString ( elementDecl . prefix ) , fStringPool . toString ( elementDecl . uri ) ) ; } elementDeclElement . setAttribute ( "type" , fStringPool . toString ( contentSpecType ) ) ; fCurrentElement . appendChild ( elementDeclElement ) ; int elementDeclIndex = createElementDecl ( ) ; fElementDecl . clear ( ) ; fElementDecl . name . setValues ( elementDecl ) ; fElementDecl . type = contentSpecType ; fElementDecl . contentSpecIndex = contentSpec ; setElementDecl ( elementDeclIndex , fElementDecl ) ; int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; ensureElementDeclCapacity ( chunk ) ; fElementDeclIsExternal [ chunk ] [ index ] = isExternal ? 1 : 0 ; return elementDeclIndex ; } protected void putElementNameMapping ( QName name , int scope , int elementDeclIndex ) { fQName . uri = - 1 ; fQName . localpart = name . rawname ; super . putElementNameMapping ( fQName , scope , elementDeclIndex ) ; } public int getElementDeclIndex ( QName element , int scopeIndex ) { return super . getElementDeclIndex ( element . rawname , - 1 ) ; } public void setElementDeclDTD ( int elementDeclIndex , XMLElementDecl elementDecl ) { super . setElementDecl ( elementDeclIndex , elementDecl ) ; } private XMLContentSpec fTempContentSpec = new XMLContentSpec ( ) ; public void setElementDeclIsExternal ( int elementDeclIndex , boolean isExternal ) { int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; ensureElementDeclCapacity ( chunk ) ; fElementDeclIsExternal [ chunk ] [ index ] = isExternal ? 1 : 0 ; } public boolean getElementDeclIsExternal ( int elementDeclIndex ) { if ( elementDeclIndex < 0 ) { return false ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; return ( fElementDeclIsExternal [ chunk ] [ index ] != 0 ) ; } public boolean getAttributeDeclIsExternal ( int attributeDeclIndex ) { if ( attributeDeclIndex < 0 ) { return false ; } int chunk = attributeDeclIndex > > CHUNK_SHIFT ; int index = attributeDeclIndex & CHUNK_MASK ; return ( fAttributeDeclIsExternal [ chunk ] [ index ] != 0 ) ; } public boolean getRootElementQName ( QName root ) { if ( fRootElementQName . rawname == - 1 ) { return false ; } root . setValues ( fRootElementQName ) ; return true ; } public int addAttDef ( QName elementDecl , QName attributeDecl , int attType , boolean attList , int enumeration , int attDefaultType , int attDefaultValue , boolean isExternal ) throws Exception { Element attributeDeclElement = fGrammarDocument . createElement ( "attributeDecl" ) ; attributeDeclElement . setAttribute ( "element" , fStringPool . toString ( elementDecl . localpart ) ) ; attributeDeclElement . setAttribute ( "name" , fStringPool . toString ( attributeDecl . localpart ) ) ; if ( attributeDecl . uri != - 1 ) { attributeDeclElement . setAttribute ( "xmlns:" + fStringPool . toString ( attributeDecl . prefix ) , fStringPool . toString ( attributeDecl . uri ) ) ; } attributeDeclElement . setAttribute ( "type" , fStringPool . toString ( attType ) ) ; attributeDeclElement . setAttribute ( "defaultType" , fStringPool . toString ( attDefaultType ) ) ; attributeDeclElement . setAttribute ( "defaultValue" , fStringPool . toString ( attDefaultValue ) ) ; fCurrentElement . appendChild ( attributeDeclElement ) ; int attributeDeclIndex = createAttributeDecl ( ) ; String attTypeString = "" ; switch ( attType ) { case XMLAttributeDecl . TYPE_CDATA : attTypeString = "string" ; case XMLAttributeDecl . TYPE_ENTITY : attTypeString = "ENTITY" ; ; case XMLAttributeDecl . TYPE_ENUMERATION : attTypeString = "ENUMERATION" ; ; case XMLAttributeDecl . TYPE_ID : attTypeString = "ID" ; ; case XMLAttributeDecl . TYPE_IDREF : attTypeString = "IDREF" ; ; case XMLAttributeDecl . TYPE_NMTOKEN : attTypeString = "NMTOKEN" ; ; case XMLAttributeDecl . TYPE_NOTATION : attTypeString = "NOTATION" ; ; default : ; } fAttributeDecl . clear ( ) ; fAttributeDecl . name . setValues ( attributeDecl ) ; fAttributeDecl . type = attType ; fAttributeDecl . list = attList ; fAttributeDecl . enumeration = enumeration ; fAttributeDecl . datatypeValidator = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) . getDatatypeValidator ( attTypeString ) ; fAttributeDecl . defaultType = attDefaultType ; fAttributeDecl . defaultValue = fStringPool . toString ( attDefaultValue ) ; int elementDeclIndex = getElementDeclIndex ( elementDecl , - 1 ) ; setAttributeDecl ( elementDeclIndex , attributeDeclIndex , fAttributeDecl ) ; int chunk = attributeDeclIndex > > CHUNK_SHIFT ; int index = attributeDeclIndex & CHUNK_MASK ; ensureAttributeDeclCapacity ( chunk ) ; fAttributeDeclIsExternal [ chunk ] [ index ] = isExternal ? 1 : 0 ; return attributeDeclIndex ; } public int addUniqueLeafNode ( int nameIndex ) throws Exception { int contentSpecIndex = createContentSpec ( ) ; fContentSpec . setValues ( XMLContentSpec . CONTENTSPECNODE_LEAF , nameIndex , - 1 ) ; setContentSpec ( contentSpecIndex , fContentSpec ) ; return contentSpecIndex ; } public int addContentSpecNode ( int nodeType , int nodeValue ) throws Exception { int contentSpecIndex = createContentSpec ( ) ; fContentSpec . setValues ( nodeType , nodeValue , - 1 ) ; setContentSpec ( contentSpecIndex , fContentSpec ) ; return contentSpecIndex ; } public int addContentSpecNode ( int nodeType , int leftNodeIndex , int rightNodeIndex ) throws Exception { int contentSpecIndex = createContentSpec ( ) ; fContentSpec . setValues ( nodeType , leftNodeIndex , rightNodeIndex ) ; setContentSpec ( contentSpecIndex , fContentSpec ) ; return contentSpecIndex ; } public String getContentSpecNodeAsString ( int nodeIndex ) throws Exception { return XMLContentSpec . toString ( this , fStringPool , nodeIndex ) ; } public boolean startEntityDecl ( boolean isPE , int entityName ) throws Exception { Element entityDecl = fGrammarDocument . createElement ( "entityDecl" ) ; entityDecl . setAttribute ( "name" , fStringPool . toString ( entityName ) ) ; entityDecl . setAttribute ( "parameter" , isPE ? "true" : "false" ) ; fCurrentElement . appendChild ( entityDecl ) ; fCurrentElement = entityDecl ; return true ; } public void endEntityDecl ( ) throws Exception { fCurrentElement = ( Element ) fCurrentElement . getParentNode ( ) ; } public int addInternalPEDecl ( int name , int value ) throws Exception { Element internalPEDecl = fGrammarDocument . createElement ( "internalPEDecl" ) ; internalPEDecl . setAttribute ( "name" , fStringPool . toString ( name ) ) ; internalPEDecl . setAttribute ( "value" , fStringPool . toString ( value ) ) ; fCurrentElement . appendChild ( internalPEDecl ) ; int peDeclIndex = - 1 ; return peDeclIndex ; } public int addExternalPEDecl ( int name , int publicId , int systemId ) throws Exception { Element externalPEDecl = fGrammarDocument . createElement ( "externalPEDecl" ) ; externalPEDecl . setAttribute ( "name" , fStringPool . toString ( name ) ) ; externalPEDecl . setAttribute ( "publicId" , fStringPool . toString ( publicId ) ) ; externalPEDecl . setAttribute ( "systemId" , fStringPool . toString ( systemId ) ) ; fCurrentElement . appendChild ( externalPEDecl ) ; int peDeclIndex = - 1 ; return peDeclIndex ; } public int addInternalEntityDecl ( int name , int value ) throws Exception { Element internalEntityDecl = fGrammarDocument . createElement ( "internalEntityDecl" ) ; internalEntityDecl . setAttribute ( "name" , fStringPool . toString ( name ) ) ; internalEntityDecl . setAttribute ( "value" , fStringPool . toString ( value ) ) ; fCurrentElement . appendChild ( internalEntityDecl ) ; int internalEntityDeclIndex = - 1 ; return internalEntityDeclIndex ; } public int addExternalEntityDecl ( int name , int publicId , int systemId ) throws Exception { Element externalEntityDecl = fGrammarDocument . createElement ( "externalEntityDecl" ) ; externalEntityDecl . setAttribute ( "name" , fStringPool . toString ( name ) ) ; externalEntityDecl . setAttribute ( "publicId" , fStringPool . toString ( publicId ) ) ; externalEntityDecl . setAttribute ( "systemId" , fStringPool . toString ( systemId ) ) ; fCurrentElement . appendChild ( externalEntityDecl ) ; int externalEntityDeclIndex = - 1 ; return externalEntityDeclIndex ; } public int addUnparsedEntityDecl ( int name , int publicId , int systemId , int notationName ) throws Exception { Element unparsedEntityDecl = fGrammarDocument . createElement ( "unparsedEntityDecl" ) ; unparsedEntityDecl . setAttribute ( "name" , fStringPool . toString ( name ) ) ; unparsedEntityDecl . setAttribute ( "publicId" , fStringPool . toString ( publicId ) ) ; unparsedEntityDecl . setAttribute ( "systemId" , fStringPool . toString ( systemId ) ) ; unparsedEntityDecl . setAttribute ( "notation" , fStringPool . toString ( notationName ) ) ; fCurrentElement . appendChild ( unparsedEntityDecl ) ; int unparsedEntityDeclIndex = - 1 ; return unparsedEntityDeclIndex ; } public int startEnumeration ( ) throws Exception { Element enumeration = fGrammarDocument . createElement ( "enumeration" ) ; fCurrentElement . appendChild ( enumeration ) ; fCurrentElement = enumeration ; int enumIndex = fStringPool . startStringList ( ) ; return enumIndex ; } public void addNameToEnumeration ( int enumIndex , int elementType , int attrName , int nameIndex , boolean isNotationType ) throws Exception { Element literal = fGrammarDocument . createElement ( "literal" ) ; literal . setAttribute ( "element" , fStringPool . toString ( elementType ) ) ; literal . setAttribute ( "attribute" , fStringPool . toString ( attrName ) ) ; literal . setAttribute ( "name" , fStringPool . toString ( nameIndex ) ) ; literal . setAttribute ( "notation" , isNotationType ? "true" : "false" ) ; fCurrentElement . appendChild ( literal ) ; fStringPool . addStringToList ( enumIndex , nameIndex ) ; } public void endEnumeration ( int enumIndex ) throws Exception { fCurrentElement = ( Element ) fCurrentElement . getParentNode ( ) ; fStringPool . finishStringList ( enumIndex ) ; } public int addNotationDecl ( int notationName , int publicId , int systemId ) throws Exception { Element notationDecl = fGrammarDocument . createElement ( "notationDecl" ) ; notationDecl . setAttribute ( "name" , fStringPool . toString ( notationName ) ) ; notationDecl . setAttribute ( "publicId" , fStringPool . toString ( publicId ) ) ; notationDecl . setAttribute ( "systemId" , fStringPool . toString ( systemId ) ) ; fCurrentElement . appendChild ( notationDecl ) ; int notationDeclIndex = - 1 ; return notationDeclIndex ; } public void callComment ( int data ) throws Exception { } public void callProcessingInstruction ( int piTarget , int piData ) throws Exception { ProcessingInstruction pi = fGrammarDocument . createProcessingInstruction ( fStringPool . toString ( piTarget ) , fStringPool . toString ( piData ) ) ; fCurrentElement . appendChild ( pi ) ; } public void internalSubset ( int internalSubset ) throws Exception { } protected boolean isDTD ( ) { return true ; } private boolean ensureElementDeclCapacity ( int chunk ) { try { return fElementDeclMap [ chunk ] [ 0 ] == 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { fElementDeclMap = resize ( fElementDeclMap , fElementDeclMap . length * 2 ) ; fElementDeclIsExternal = resize ( fElementDeclIsExternal , fElementDeclIsExternal . length * 2 ) ; } catch ( NullPointerException ex ) { } fElementDeclMap [ chunk ] = new int [ CHUNK_SIZE ] ; fElementDeclIsExternal [ chunk ] = new int [ CHUNK_SIZE ] ; return true ; } private boolean ensureAttributeDeclCapacity ( int chunk ) { try { return fAttributeDeclMap [ chunk ] [ 0 ] == 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { fAttributeDeclMap = resize ( fAttributeDeclMap , fAttributeDeclMap . length * 2 ) ; fAttributeDeclIsExternal = resize ( fAttributeDeclIsExternal , fAttributeDeclIsExternal . length * 2 ) ; } catch ( NullPointerException ex ) { } fAttributeDeclMap [ chunk ] = new int [ CHUNK_SIZE ] ; fAttributeDeclIsExternal [ chunk ] = new int [ CHUNK_SIZE ] ; return true ; } private boolean ensureContentSpecCapacity ( int chunk ) { try { return fContentSpecMap [ chunk ] [ 0 ] == 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { fContentSpecMap = resize ( fContentSpecMap , fContentSpecMap . length * 2 ) ; } catch ( NullPointerException ex ) { } fContentSpecMap [ chunk ] = new int [ CHUNK_SIZE ] ; return true ; } private int [ ] [ ] resize ( int array [ ] [ ] , int newsize ) { int newarray [ ] [ ] = new int [ newsize ] [ ] ; System . arraycopy ( array , 0 , newarray , 0 , array . length ) ; return newarray ; } } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface DocumentTraversal { public NodeIterator createNodeIterator ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) ; public TreeWalker createTreeWalker ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) throws DOMException ; } 	1
package org . apache . wml ; public interface WMLOneventElement extends WMLElement { public void setType ( String newValue ) ; public String getType ( ) ; } 	0
package org . apache . xerces . readers ; import java . io . FileNotFoundException ; import java . io . UnsupportedEncodingException ; import java . net . MalformedURLException ; import java . util . Stack ; import java . util . Vector ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . URI ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; public class DefaultEntityHandler implements XMLEntityHandler , XMLEntityHandler . DTDHandler { public interface EventHandler { public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void sendEndOfInputNotifications ( int entityName , boolean moreToFollow ) throws Exception ; public void sendReaderChangeNotifications ( XMLEntityHandler . EntityReader reader , int readerId ) throws Exception ; public boolean externalEntityStandaloneCheck ( ) ; public boolean getValidating ( ) ; } private class ReaderState { XMLEntityHandler . EntityReader reader ; InputSource source ; int entityName ; int entityType ; int entityContext ; String publicId ; String systemId ; int readerId ; int depth ; ReaderState nextReaderState ; } private ReaderState fReaderStateFreeList = null ; private StringPool fStringPool = null ; private EventHandler fEventHandler = null ; private XMLEntityHandler . CharDataHandler fCharDataHandler = null ; private XMLErrorReporter fErrorReporter = null ; private EntityResolver fResolver = null ; private EntityPool fEntityPool = null ; private EntityPool fParameterEntityPool = null ; private byte [ ] fEntityTypeStack = null ; private int [ ] fEntityNameStack = null ; private int fEntityStackDepth = 0 ; private Stack fReaderStack = new Stack ( ) ; private XMLEntityHandler . EntityReader fReader = null ; private InputSource fSource = null ; private int fEntityName = - 1 ; private int fEntityType = - 1 ; private int fEntityContext = - 1 ; private String fPublicId = null ; private String fSystemId = null ; private int fReaderId = - 1 ; private int fReaderDepth = - 1 ; private int fNextReaderId = 0 ; private NullReader fNullReader = null ; protected XMLEntityReaderFactory fReaderFactory = null ; private boolean fSendCharDataAsCharArray = false ; public DefaultEntityHandler ( StringPool stringPool , XMLErrorReporter errorReporter ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fReaderFactory = new DefaultReaderFactory ( ) ; fEntityPool = new EntityPool ( fStringPool , fErrorReporter , true ) ; } public void setEventHandler ( EventHandler eventHandler ) { fEventHandler = eventHandler ; } public void setCharDataHandler ( XMLEntityHandler . CharDataHandler charDataHandler ) { fCharDataHandler = charDataHandler ; } public XMLEntityHandler . CharDataHandler getCharDataHandler ( ) { return fCharDataHandler ; } public void setSendCharDataAsCharArray ( boolean flag ) { fSendCharDataAsCharArray = flag ; fReaderFactory . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; } public void setReaderFactory ( XMLEntityReaderFactory readerFactory ) { fReaderFactory = readerFactory ; fReaderFactory . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fEntityPool . reset ( fStringPool ) ; fParameterEntityPool = null ; fReaderStack . removeAllElements ( ) ; fEntityStackDepth = 0 ; fReader = null ; fSource = null ; fEntityName = - 1 ; fEntityType = - 1 ; fEntityContext = - 1 ; fPublicId = null ; fSystemId = null ; fReaderId = - 1 ; fReaderDepth = - 1 ; fNextReaderId = 0 ; } public void setAllowJavaEncodings ( boolean flag ) { fReaderFactory . setAllowJavaEncodingName ( flag ) ; } public boolean getAllowJavaEncodings ( ) { return fReaderFactory . getAllowJavaEncodingName ( ) ; } public int addInternalPEDecl ( int name , int value , boolean isExternal ) throws Exception { if ( fParameterEntityPool == null ) fParameterEntityPool = new EntityPool ( fStringPool , fErrorReporter , false ) ; int entityHandle = fParameterEntityPool . addEntityDecl ( name , value , - 1 , - 1 , - 1 , - 1 , isExternal ) ; return entityHandle ; } public int addExternalPEDecl ( int name , int publicId , int systemId , boolean isExternal ) throws Exception { if ( fParameterEntityPool == null ) fParameterEntityPool = new EntityPool ( fStringPool , fErrorReporter , false ) ; int entityHandle = fParameterEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , - 1 , isExternal ) ; return entityHandle ; } public int addInternalEntityDecl ( int name , int value , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , value , - 1 , - 1 , - 1 , - 1 , isExternal ) ; return entityHandle ; } public int addExternalEntityDecl ( int name , int publicId , int systemId , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , - 1 , isExternal ) ; return entityHandle ; } public int addUnparsedEntityDecl ( int name , int publicId , int systemId , int notationName , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , notationName , isExternal ) ; if ( ! fEntityPool . isNotationDeclared ( notationName ) ) { Object [ ] args = { fStringPool . toString ( name ) , fStringPool . toString ( notationName ) } ; fEntityPool . addRequiredNotation ( notationName , fErrorReporter . getLocator ( ) , XMLMessages . MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL , XMLMessages . VC_NOTATION_DECLARED , args ) ; } return entityHandle ; } public int addNotationDecl ( int notationName , int publicId , int systemId , boolean isExternal ) throws Exception { int notationHandle = fEntityPool . addNotationDecl ( notationName , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , isExternal ) ; return notationHandle ; } public boolean isUnparsedEntity ( int entityName ) { int entityHandle = fEntityPool . lookupEntity ( entityName ) ; return ( entityHandle != - 1 && fEntityPool . isUnparsedEntity ( entityHandle ) ) ; } public boolean isNotationDeclared ( int notationName ) { return fEntityPool . isNotationDeclared ( notationName ) ; } public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { fEntityPool . addRequiredNotation ( notationName , locator , majorCode , minorCode , args ) ; } public void checkRequiredNotations ( ) throws Exception { fEntityPool . checkRequiredNotations ( ) ; } protected int lookupEntity ( int entityNameIndex ) { int entityIndex = fEntityPool . lookupEntity ( entityNameIndex ) ; return entityIndex ; } private void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } public boolean externalReferenceInContent ( int entityHandle ) throws Exception { boolean external = fEntityPool . isExternalEntity ( entityHandle ) ; if ( fEventHandler . externalEntityStandaloneCheck ( ) ) { if ( external ) { reportRecoverableXMLError ( XMLMessages . MSG_EXTERNAL_ENTITY_NOT_PERMITTED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } else if ( fEntityPool . getEntityDeclIsExternal ( entityHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } } return external ; } protected int valueOfReferenceInAttValue ( int entityHandle ) throws Exception { if ( fEventHandler . externalEntityStandaloneCheck ( ) && fEntityPool . getEntityDeclIsExternal ( entityHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } int entityValue = fEntityPool . getEntityValue ( entityHandle ) ; return entityValue ; } protected boolean isExternalEntity ( int entityHandle ) { boolean external = fEntityPool . isExternalEntity ( entityHandle ) ; return external ; } protected int getEntityValue ( int entityHandle ) { int value = fEntityPool . getEntityValue ( entityHandle ) ; return value ; } protected String getPublicIdOfEntity ( int entityHandle ) { int publicId = fEntityPool . getPublicId ( entityHandle ) ; return fStringPool . toString ( publicId ) ; } protected String getSystemIdOfEntity ( int entityHandle ) { int systemId = fEntityPool . getSystemId ( entityHandle ) ; return fStringPool . toString ( systemId ) ; } protected int lookupParameterEntity ( int peName ) throws Exception { int entityHandle = - 1 ; if ( fParameterEntityPool != null ) entityHandle = fParameterEntityPool . lookupEntity ( peName ) ; return entityHandle ; } protected boolean isExternalParameterEntity ( int peIndex ) { boolean external = fParameterEntityPool . isExternalEntity ( peIndex ) ; return external ; } protected int getParameterEntityValue ( int peIndex ) { int value = fParameterEntityPool . getEntityValue ( peIndex ) ; return value ; } protected String getPublicIdOfParameterEntity ( int peIndex ) { int publicId = fParameterEntityPool . getPublicId ( peIndex ) ; return fStringPool . toString ( publicId ) ; } protected String getSystemIdOfParameterEntity ( int peIndex ) { int systemId = fParameterEntityPool . getSystemId ( peIndex ) ; return fStringPool . toString ( systemId ) ; } public XMLEntityHandler . EntityReader getEntityReader ( ) { return fReader ; } public void addRecognizer ( XMLDeclRecognizer recognizer ) { fReaderFactory . addRecognizer ( recognizer ) ; } public void setEntityResolver ( EntityResolver resolver ) { fResolver = resolver ; } public EntityResolver getEntityResolver ( ) { return fResolver ; } public String expandSystemId ( String systemId ) { return expandSystemId ( systemId , fSystemId ) ; } private String expandSystemId ( String systemId , String currentSystemId ) { String id = systemId ; if ( id == null || id . length ( ) == 0 ) { return systemId ; } try { URI uri = new URI ( id ) ; if ( uri != null ) { return systemId ; } } catch ( URI . MalformedURIException e ) { } id = fixURI ( id ) ; URI base = null ; URI uri = null ; try { if ( currentSystemId == null ) { String dir ; try { dir = fixURI ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { dir = "" ; } if ( ! dir . endsWith ( "/" ) ) { dir = dir + "/" ; } base = new URI ( "file" , "" , dir , null , null ) ; } else { base = new URI ( currentSystemId ) ; } uri = new URI ( base , id ) ; } catch ( Exception e ) { } if ( uri == null ) { return systemId ; } return uri . toString ( ) ; } private static String fixURI ( String str ) { str = str . replace ( java . io . File . separatorChar , '/' ) ; if ( str . length ( ) >= 2 ) { char ch1 = str . charAt ( 1 ) ; if ( ch1 == ':' ) { char ch0 = Character . toUpperCase ( str . charAt ( 0 ) ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { str = "/" + str ; } } } return str ; } public boolean startReadingFromDocument ( InputSource source ) throws Exception { pushEntity ( false , - 2 ) ; fSystemId = null ; pushNullReader ( ) ; fEntityName = - 2 ; fEntityType = ENTITYTYPE_DOCUMENT ; fEntityContext = ENTITYREF_DOCUMENT ; fReaderDepth = 0 ; fReaderId = fNextReaderId ++ ; fPublicId = source . getPublicId ( ) ; fSystemId = source . getSystemId ( ) ; fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; fSystemId = expandSystemId ( fSystemId , null ) ; fSource = source ; boolean xmlDecl = true ; try { fReader = fReaderFactory . createReader ( this , fErrorReporter , source , fSystemId , xmlDecl , fStringPool ) ; } catch ( MalformedURLException mu ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( FileNotFoundException fnf ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( UnsupportedEncodingException uee ) { fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; String encoding = uee . getMessage ( ) ; if ( encoding == null ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_REQUIRED , XMLMessages . P81_REQUIRED , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else if ( ! XMLCharacterProperties . validEncName ( encoding ) ) { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_NOT_SUPPORTED , XMLMessages . P81_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; return fReader != null ; } public void startReadingFromExternalSubset ( String publicId , String systemId , int readerDepth ) throws Exception { pushEntity ( true , - 1 ) ; pushReader ( ) ; pushNullReader ( ) ; fEntityName = - 1 ; fEntityType = ENTITYTYPE_EXTERNAL_SUBSET ; fEntityContext = ENTITYREF_EXTERNAL_SUBSET ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; fPublicId = publicId ; fSystemId = systemId ; startReadingFromExternalEntity ( false , - 1 ) ; } public void stopReadingFromExternalSubset ( ) throws Exception { if ( ! ( fReader instanceof NullReader ) ) throw new RuntimeException ( "FWK004 cannot happen 18" + "\n18" ) ; popReader ( ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; } public boolean startReadingFromEntity ( int entityName , int readerDepth , int context ) throws Exception { if ( context > XMLEntityHandler . ENTITYREF_IN_CONTENT ) return startReadingFromParameterEntity ( entityName , readerDepth , context ) ; int entityHandle = lookupEntity ( entityName ) ; if ( entityHandle < 0 ) { int minorCode = XMLMessages . VC_ENTITY_DECLARED ; int errorType = XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ; if ( fEntityContext == ENTITYREF_DOCUMENT || fEntityContext == ENTITYREF_IN_ATTVALUE ) { minorCode = XMLMessages . WFC_ENTITY_DECLARED ; errorType = XMLErrorReporter . ERRORTYPE_FATAL_ERROR ; } else if ( ! fEventHandler . getValidating ( ) ) { return false ; } Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENTITY_NOT_DECLARED , minorCode , args , errorType ) ; return false ; } if ( context == ENTITYREF_IN_CONTENT ) { if ( fEntityPool . isUnparsedEntity ( entityHandle ) ) { Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REFERENCE_TO_UNPARSED_ENTITY , XMLMessages . WFC_PARSED_ENTITY , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } } else { if ( isExternalEntity ( entityHandle ) ) { Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REFERENCE_TO_EXTERNAL_ENTITY , XMLMessages . WFC_NO_EXTERNAL_ENTITY_REFERENCES , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } } if ( ! pushEntity ( false , entityName ) ) { Object [ ] args = { fStringPool . toString ( entityName ) , entityReferencePath ( false , entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_RECURSIVE_REFERENCE , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } pushReader ( ) ; fEntityName = entityName ; fEntityContext = context ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; if ( context != ENTITYREF_IN_CONTENT || ! externalReferenceInContent ( entityHandle ) ) { fEntityType = ENTITYTYPE_INTERNAL ; fPublicId = null ; fSystemId = fSystemId ; int value = - 1 ; if ( context == ENTITYREF_IN_CONTENT || context == ENTITYREF_IN_DEFAULTATTVALUE ) value = getEntityValue ( entityHandle ) ; else value = valueOfReferenceInAttValue ( entityHandle ) ; startReadingFromInternalEntity ( value , false ) ; return false ; } fEntityType = ENTITYTYPE_EXTERNAL ; fPublicId = getPublicIdOfEntity ( entityHandle ) ; fSystemId = getSystemIdOfEntity ( entityHandle ) ; return startReadingFromExternalEntity ( true , entityHandle ) ; } private boolean startReadingFromParameterEntity ( int peName , int readerDepth , int context ) throws Exception { int entityHandle = lookupParameterEntity ( peName ) ; if ( entityHandle == - 1 ) { if ( fEventHandler . getValidating ( ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ENTITY_NOT_DECLARED , XMLMessages . VC_ENTITY_DECLARED , peName ) ; } return false ; } if ( ! pushEntity ( true , peName ) ) { Object [ ] args = { fStringPool . toString ( peName ) , entityReferencePath ( true , peName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_RECURSIVE_PEREFERENCE , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } pushReader ( ) ; fEntityName = peName ; fEntityContext = context ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; if ( ! isExternalParameterEntity ( entityHandle ) ) { fEntityType = ENTITYTYPE_INTERNAL_PE ; fPublicId = null ; fSystemId = fSystemId ; int value = getParameterEntityValue ( entityHandle ) ; startReadingFromInternalEntity ( value , fEntityContext == ENTITYREF_IN_ENTITYVALUE ? false : true ) ; return false ; } fEntityType = ENTITYTYPE_EXTERNAL_PE ; fPublicId = getPublicIdOfParameterEntity ( entityHandle ) ; fSystemId = getSystemIdOfParameterEntity ( entityHandle ) ; return startReadingFromExternalEntity ( true , entityHandle ) ; } private void startReadingFromInternalEntity ( int value , boolean addSpaces ) throws Exception { if ( fEntityContext == ENTITYREF_IN_ENTITYVALUE ) { } fSource = null ; fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; fReader = fReaderFactory . createStringReader ( this , fErrorReporter , fSendCharDataAsCharArray , getLineNumber ( ) , getColumnNumber ( ) , value , fStringPool , addSpaces ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; } private boolean startReadingFromExternalEntity ( boolean checkForTextDecl , int entityHandle ) throws Exception { if ( fEntityContext == ENTITYREF_IN_ENTITYVALUE ) { } if ( fEntityContext == ENTITYREF_IN_DTD_WITHIN_MARKUP ) { } fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; String baseSystemId = null ; if ( entityHandle != - 1 ) { if ( fEntityType == ENTITYTYPE_EXTERNAL_PE ) baseSystemId = fParameterEntityPool . getBaseSystemId ( entityHandle ) ; else baseSystemId = fEntityPool . getBaseSystemId ( entityHandle ) ; } if ( baseSystemId == null ) { ReaderState rs = ( ReaderState ) fReaderStack . peek ( ) ; baseSystemId = rs . systemId ; } fSystemId = expandSystemId ( fSystemId , baseSystemId ) ; fSource = fResolver == null ? null : fResolver . resolveEntity ( fPublicId , fSystemId ) ; if ( fSource == null ) { fSource = new InputSource ( fSystemId ) ; if ( fPublicId != null ) fSource . setPublicId ( fPublicId ) ; } else { if ( fSource . getSystemId ( ) != null ) { fSystemId = expandSystemId ( fSource . getSystemId ( ) , baseSystemId ) ; } if ( fSource . getPublicId ( ) != null ) { fPublicId = fSource . getPublicId ( ) ; } } boolean textDecl = false ; try { fReader = fReaderFactory . createReader ( this , fErrorReporter , fSource , fSystemId , textDecl , fStringPool ) ; } catch ( MalformedURLException mu ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( FileNotFoundException fnf ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( UnsupportedEncodingException uee ) { fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; String encoding = uee . getMessage ( ) ; if ( encoding == null ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_REQUIRED , XMLMessages . P81_REQUIRED , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else if ( ! XMLCharacterProperties . validEncName ( encoding ) ) { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_NOT_SUPPORTED , XMLMessages . P81_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } if ( fReader == null || ! checkForTextDecl ) { fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; return false ; } int readerId = fReaderId ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; boolean parseTextDecl = fReader . lookingAtChar ( '<' , false ) ; if ( readerId != fReaderId ) parseTextDecl = false ; return parseTextDecl ; } private void pushNullReader ( ) { ReaderState rs = fReaderStateFreeList ; if ( rs == null ) rs = new ReaderState ( ) ; else fReaderStateFreeList = rs . nextReaderState ; if ( fNullReader == null ) fNullReader = new NullReader ( ) ; rs . reader = fNullReader ; rs . source = null ; rs . entityName = - 1 ; rs . entityType = - 1 ; rs . entityContext = - 1 ; rs . publicId = "Null Entity" ; rs . systemId = fSystemId ; rs . readerId = fNextReaderId ++ ; rs . depth = - 1 ; rs . nextReaderState = null ; fReaderStack . push ( rs ) ; } private void pushReader ( ) { ReaderState rs = fReaderStateFreeList ; if ( rs == null ) rs = new ReaderState ( ) ; else fReaderStateFreeList = rs . nextReaderState ; rs . reader = fReader ; rs . source = fSource ; rs . entityName = fEntityName ; rs . entityType = fEntityType ; rs . entityContext = fEntityContext ; rs . publicId = fPublicId ; rs . systemId = fSystemId ; rs . readerId = fReaderId ; rs . depth = fReaderDepth ; rs . nextReaderState = null ; fReaderStack . push ( rs ) ; } private void popReader ( ) { if ( fReaderStack . empty ( ) ) throw new RuntimeException ( "FWK004 cannot happen 19" + "\n19" ) ; ReaderState rs = ( ReaderState ) fReaderStack . pop ( ) ; fReader = rs . reader ; fSource = rs . source ; fEntityName = rs . entityName ; fEntityType = rs . entityType ; fEntityContext = rs . entityContext ; fPublicId = rs . publicId ; fSystemId = rs . systemId ; fReaderId = rs . readerId ; fReaderDepth = rs . depth ; rs . nextReaderState = fReaderStateFreeList ; fReaderStateFreeList = rs ; } public boolean startEntityDecl ( boolean isPE , int entityName ) throws Exception { if ( ! pushEntity ( isPE , entityName ) ) { int majorCode = isPE ? XMLMessages . MSG_RECURSIVE_PEREFERENCE : XMLMessages . MSG_RECURSIVE_REFERENCE ; Object [ ] args = { fStringPool . toString ( entityName ) , entityReferencePath ( isPE , entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } return true ; } public void endEntityDecl ( ) throws Exception { popEntity ( ) ; } private boolean pushEntity ( boolean isPE , int entityName ) throws Exception { if ( entityName >= 0 ) { for ( int i = 0 ; i < fEntityStackDepth ; i ++ ) { if ( fEntityNameStack [ i ] == entityName && fEntityTypeStack [ i ] == ( isPE ? 1 : 0 ) ) { return false ; } } } if ( fEntityTypeStack == null ) { fEntityTypeStack = new byte [ 8 ] ; fEntityNameStack = new int [ 8 ] ; } else if ( fEntityStackDepth == fEntityTypeStack . length ) { byte [ ] newTypeStack = new byte [ fEntityStackDepth * 2 ] ; System . arraycopy ( fEntityTypeStack , 0 , newTypeStack , 0 , fEntityStackDepth ) ; fEntityTypeStack = newTypeStack ; int [ ] newNameStack = new int [ fEntityStackDepth * 2 ] ; System . arraycopy ( fEntityNameStack , 0 , newNameStack , 0 , fEntityStackDepth ) ; fEntityNameStack = newNameStack ; } fEntityTypeStack [ fEntityStackDepth ] = ( byte ) ( isPE ? 1 : 0 ) ; fEntityNameStack [ fEntityStackDepth ] = entityName ; fEntityStackDepth ++ ; return true ; } private String entityReferencePath ( boolean isPE , int entityName ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "(top-level)" ) ; for ( int i = 0 ; i < fEntityStackDepth ; i ++ ) { if ( fEntityNameStack [ i ] >= 0 ) { sb . append ( '-' ) ; sb . append ( fEntityTypeStack [ i ] == 1 ? '%' : '&' ) ; sb . append ( fStringPool . toString ( fEntityNameStack [ i ] ) ) ; sb . append ( ';' ) ; } } sb . append ( '-' ) ; sb . append ( isPE ? '%' : '&' ) ; sb . append ( fStringPool . toString ( entityName ) ) ; sb . append ( ';' ) ; return sb . toString ( ) ; } private void popEntity ( ) throws Exception { fEntityStackDepth -- ; } public int getReaderId ( ) { return fReaderId ; } public void setReaderDepth ( int depth ) { fReaderDepth = depth ; } public int getReaderDepth ( ) { return fReaderDepth ; } public String getPublicId ( ) { return fPublicId ; } public String getSystemId ( ) { return fSystemId ; } public int getLineNumber ( ) { return fReader == null ? 0 : fReader . getLineNumber ( ) ; } public int getColumnNumber ( ) { return fReader == null ? 0 : fReader . getColumnNumber ( ) ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { fEventHandler . sendEndOfInputNotifications ( fEntityName , fReaderStack . size ( ) > 1 ) ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; popEntity ( ) ; return fReader ; } private final class NullReader implements XMLEntityHandler . EntityReader { public NullReader ( ) { } public int currentOffset ( ) { return - 1 ; } public int getLineNumber ( ) { return - 1 ; } public int getColumnNumber ( ) { return - 1 ; } public void setInCDSect ( boolean inCDSect ) { } public boolean getInCDSect ( ) { return false ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { } public int addString ( int offset , int length ) { return - 1 ; } public int addSymbol ( int offset , int length ) { return - 1 ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) { return false ; } public boolean lookingAtValidChar ( boolean skipPastChar ) { return false ; } public boolean lookingAtSpace ( boolean skipPastChar ) { return false ; } public void skipToChar ( char ch ) { } public void skipPastSpaces ( ) { } public void skipPastName ( char fastcheck ) { } public void skipPastNmtoken ( char fastcheck ) { } public boolean skippedString ( char [ ] s ) { return false ; } public int scanInvalidChar ( ) { return - 1 ; } public int scanCharRef ( boolean hex ) { return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } public int scanStringLiteral ( ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } public int scanAttValue ( char qchar , boolean asSymbol ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } public int scanEntityValue ( int qchar , boolean createString ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) { return false ; } public void scanQName ( char fastcheck , QName qname ) { qname . clear ( ) ; } public int scanName ( char fastcheck ) { return - 1 ; } public int scanContent ( QName element ) throws Exception { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } static final int CHUNK_SHIFT = 5 ; static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; static final int CHUNK_MASK = CHUNK_SIZE - 1 ; static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; public final class EntityPool { private StringPool fStringPool = null ; private XMLErrorReporter fErrorReporter = null ; private int fEntityCount = 0 ; private int [ ] [ ] fName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fValue = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fPublicId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fSystemId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fBaseSystemId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fNotationName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private byte [ ] [ ] fDeclIsExternal = new byte [ INITIAL_CHUNK_COUNT ] [ ] ; private int fNotationListHead = - 1 ; private boolean fCreateStandardEntities = false ; private Vector fRequiredNotations = null ; public EntityPool ( StringPool stringPool , XMLErrorReporter errorReporter , boolean createStandardEntities ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fCreateStandardEntities = createStandardEntities ; if ( fCreateStandardEntities ) { createInternalEntity ( "lt" , "&#60;" ) ; createInternalEntity ( "gt" , ">" ) ; createInternalEntity ( "amp" , "&#38;" ) ; createInternalEntity ( "apos" , "\'" ) ; createInternalEntity ( "quot" , "\"" ) ; } } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fEntityCount = 0 ; fNotationListHead = - 1 ; if ( fRequiredNotations != null ) fRequiredNotations . removeAllElements ( ) ; if ( fCreateStandardEntities ) { createInternalEntity ( "lt" , "&#60;" ) ; createInternalEntity ( "gt" , ">" ) ; createInternalEntity ( "amp" , "&#38;" ) ; createInternalEntity ( "apos" , "\'" ) ; createInternalEntity ( "quot" , "\"" ) ; } } private void createInternalEntity ( String name , String value ) { int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = fStringPool . addSymbol ( name ) ; fValue [ chunk ] [ index ] = fStringPool . addString ( value ) ; fPublicId [ chunk ] [ index ] = - 1 ; fSystemId [ chunk ] [ index ] = - 1 ; fBaseSystemId [ chunk ] [ index ] = - 1 ; fNotationName [ chunk ] [ index ] = - 1 ; fEntityCount ++ ; } private boolean ensureCapacity ( int chunk ) { try { return fName [ chunk ] [ 0 ] == 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { int [ ] [ ] newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fName , 0 , newIntArray , 0 , chunk ) ; fName = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fValue , 0 , newIntArray , 0 , chunk ) ; fValue = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fPublicId , 0 , newIntArray , 0 , chunk ) ; fPublicId = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fSystemId , 0 , newIntArray , 0 , chunk ) ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fBaseSystemId , 0 , newIntArray , 0 , chunk ) ; fBaseSystemId = newIntArray ; fSystemId = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fNotationName , 0 , newIntArray , 0 , chunk ) ; fNotationName = newIntArray ; byte [ ] [ ] newByteArray = new byte [ chunk * 2 ] [ ] ; System . arraycopy ( fDeclIsExternal , 0 , newByteArray , 0 , chunk ) ; fDeclIsExternal = newByteArray ; } catch ( NullPointerException ex ) { } fName [ chunk ] = new int [ CHUNK_SIZE ] ; fValue [ chunk ] = new int [ CHUNK_SIZE ] ; fPublicId [ chunk ] = new int [ CHUNK_SIZE ] ; fSystemId [ chunk ] = new int [ CHUNK_SIZE ] ; fBaseSystemId [ chunk ] = new int [ CHUNK_SIZE ] ; fNotationName [ chunk ] = new int [ CHUNK_SIZE ] ; fDeclIsExternal [ chunk ] = new byte [ CHUNK_SIZE ] ; return true ; } public int addEntityDecl ( int name , int value , int publicId , int systemId , int baseSystemId , int notationName , boolean isExternal ) { int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = name ; fValue [ chunk ] [ index ] = value ; fPublicId [ chunk ] [ index ] = publicId ; fSystemId [ chunk ] [ index ] = systemId ; fBaseSystemId [ chunk ] [ index ] = baseSystemId ; fNotationName [ chunk ] [ index ] = notationName ; fDeclIsExternal [ chunk ] [ index ] = isExternal ? ( byte ) 0x80 : ( byte ) 0 ; int entityIndex = fEntityCount ++ ; return entityIndex ; } public int addNotationDecl ( int notationName , int publicId , int systemId , int baseSystemId , boolean isExternal ) { int nIndex = fNotationListHead ; while ( nIndex != - 1 ) { int chunk = nIndex > > CHUNK_SHIFT ; int index = nIndex & CHUNK_MASK ; if ( fNotationName [ chunk ] [ index ] == notationName ) return - 1 ; nIndex = fValue [ chunk ] [ index ] ; } int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = - 1 ; fValue [ chunk ] [ index ] = fNotationListHead ; fPublicId [ chunk ] [ index ] = publicId ; fSystemId [ chunk ] [ index ] = systemId ; fBaseSystemId [ chunk ] [ index ] = baseSystemId ; fNotationName [ chunk ] [ index ] = notationName ; fDeclIsExternal [ chunk ] [ index ] = isExternal ? ( byte ) 0x80 : ( byte ) 0 ; fNotationListHead = fEntityCount ++ ; return fNotationListHead ; } public int lookupEntity ( int nameIndex ) { if ( nameIndex == - 1 ) return - 1 ; int chunk = 0 ; int index = 0 ; for ( int entityIndex = 0 ; entityIndex < fEntityCount ; entityIndex ++ ) { if ( fName [ chunk ] [ index ] == nameIndex ) return entityIndex ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } return - 1 ; } public boolean isExternalEntity ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fValue [ chunk ] [ index ] == - 1 ) ; } public boolean isUnparsedEntity ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fNotationName [ chunk ] [ index ] != - 1 ) ; } public boolean getEntityDeclIsExternal ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fDeclIsExternal [ chunk ] [ index ] < 0 ) ; } public int getEntityName ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fName [ chunk ] [ index ] ; } public int getEntityValue ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fValue [ chunk ] [ index ] ; } public int getPublicId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fPublicId [ chunk ] [ index ] ; } public int getSystemId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fSystemId [ chunk ] [ index ] ; } public String getBaseSystemId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; int baseIndex = fBaseSystemId [ chunk ] [ index ] ; if ( baseIndex == - 1 ) { return null ; } else { return fStringPool . toString ( baseIndex ) ; } } public boolean isNotationDeclared ( int nameIndex ) { int nIndex = fNotationListHead ; while ( nIndex != - 1 ) { int chunk = nIndex > > CHUNK_SHIFT ; int index = nIndex & CHUNK_MASK ; if ( fNotationName [ chunk ] [ index ] == nameIndex ) return true ; nIndex = fValue [ chunk ] [ index ] ; } return false ; } public boolean getNotationDeclIsExternal ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fDeclIsExternal [ chunk ] [ index ] < 0 ) ; } public int getNotationName ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fNotationName [ chunk ] [ index ] ; } class RequiredNotation { RequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { fNotationName = notationName ; fLocator = new LocatorImpl ( locator ) ; fMajorCode = majorCode ; fMinorCode = minorCode ; fArgs = args ; } int fNotationName ; LocatorImpl fLocator ; int fMajorCode ; int fMinorCode ; Object [ ] fArgs ; } ; public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { if ( fRequiredNotations == null ) fRequiredNotations = new Vector ( ) ; for ( int index = 0 ; index < fRequiredNotations . size ( ) ; index ++ ) { RequiredNotation rn = ( RequiredNotation ) fRequiredNotations . elementAt ( index ) ; if ( rn . fNotationName == notationName ) return ; } fRequiredNotations . addElement ( new RequiredNotation ( notationName , locator , majorCode , minorCode , args ) ) ; } public void checkRequiredNotations ( ) throws Exception { if ( fRequiredNotations == null ) return ; for ( int index = 0 ; index < fRequiredNotations . size ( ) ; index ++ ) { RequiredNotation rn = ( RequiredNotation ) fRequiredNotations . elementAt ( index ) ; if ( ! isNotationDeclared ( rn . fNotationName ) ) { fErrorReporter . reportError ( rn . fLocator , XMLMessages . XML_DOMAIN , rn . fMajorCode , rn . fMinorCode , rn . fArgs , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Enumeration ; import java . util . StringTokenizer ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; public class IDREFDatatypeValidator extends AbstractDatatypeValidator { private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; private Hashtable fTableOfId = null ; private Hashtable fTableIDRefs = null ; private Object fNullValue = null ; private Locale fLocale = null ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; public static final int IDREF_STORE = 0 ; public static final int IDREF_CLEAR = 1 ; public static final int IDREF_VALIDATE = 2 ; public IDREFDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public IDREFDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { fDerivedByList = derivedByList ; setBasetype ( base ) ; } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { StateMessageDatatype message ; if ( this . fDerivedByList == false ) { if ( state != null ) { message = ( StateMessageDatatype ) state ; if ( message . getDatatypeState ( ) == IDREFDatatypeValidator . IDREF_CLEAR ) { if ( this . fTableOfId != null ) { fTableOfId . clear ( ) ; } if ( this . fTableIDRefs != null ) { fTableIDRefs . clear ( ) ; } return null ; } else if ( message . getDatatypeState ( ) == IDREFDatatypeValidator . IDREF_VALIDATE ) { this . checkIdRefs ( ) ; } else if ( message . getDatatypeState ( ) == IDREFDatatypeValidator . IDREF_STORE ) { this . fTableOfId = ( Hashtable ) message . getDatatypeObject ( ) ; if ( ! XMLCharacterProperties . validName ( content ) ) { InvalidDatatypeValueException error = new InvalidDatatypeValueException ( "IDREF is not valid" ) ; error . setMinorCode ( XMLMessages . MSG_IDREF_INVALID ) ; error . setMajorCode ( XMLMessages . VC_IDREF ) ; throw error ; } addIdRef ( content , state ) ; } } } else { if ( state != null ) { message = ( StateMessageDatatype ) state ; if ( message . getDatatypeState ( ) == IDREFDatatypeValidator . IDREF_CLEAR ) { if ( this . fTableOfId != null ) { fTableOfId . clear ( ) ; } if ( this . fTableIDRefs != null ) { fTableIDRefs . clear ( ) ; } return null ; } else if ( message . getDatatypeState ( ) == IDREFDatatypeValidator . IDREF_VALIDATE ) { this . checkIdRefs ( ) ; } else if ( message . getDatatypeState ( ) == IDREFDatatypeValidator . IDREF_STORE ) { StringTokenizer tokenizer = new StringTokenizer ( content ) ; this . fTableOfId = ( Hashtable ) message . getDatatypeObject ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { String idName = tokenizer . nextToken ( ) ; if ( this . fBaseValidator != null ) { this . fBaseValidator . validate ( idName , state ) ; } addIdRef ( idName , state ) ; } } } } return null ; } public int compare ( String content1 , String content2 ) { return - 1 ; } public Hashtable getFacets ( ) { return null ; } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } private void addIdRef ( String content , Object state ) { if ( this . fTableOfId != null && this . fTableOfId . containsKey ( content ) ) { return ; } if ( this . fTableIDRefs == null ) { this . fTableIDRefs = new Hashtable ( ) ; } else if ( fTableIDRefs . containsKey ( content ) ) { return ; } if ( this . fNullValue == null ) { fNullValue = new Object ( ) ; } try { this . fTableIDRefs . put ( content , fNullValue ) ; } catch ( OutOfMemoryError ex ) { System . out . println ( "Out of Memory: Hashtable of ID's has " + this . fTableIDRefs . size ( ) + " Elements" ) ; ex . printStackTrace ( ) ; } } private void checkIdRefs ( ) throws InvalidDatatypeValueException { if ( this . fTableIDRefs == null ) return ; Enumeration en = this . fTableIDRefs . keys ( ) ; while ( en . hasMoreElements ( ) ) { String key = ( String ) en . nextElement ( ) ; if ( this . fTableOfId == null || ! this . fTableOfId . containsKey ( key ) ) { InvalidDatatypeValueException error = new InvalidDatatypeValueException ( key ) ; error . setMinorCode ( XMLMessages . MSG_ELEMENT_WITH_ID_REQUIRED ) ; error . setMajorCode ( XMLMessages . VC_IDREF ) ; throw error ; } } } public void setLocale ( Locale locale ) { fLocale = locale ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } } 	0
package org . w3c . dom ; public interface DOMImplementation { public boolean hasFeature ( String feature , String version ) ; public DocumentType createDocumentType ( String qualifiedName , String publicId , String systemId ) throws DOMException ; public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException ; } 	1
package org . apache . xml . serialize ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . io . OutputStream ; import java . io . Writer ; import org . w3c . dom . * ; import org . xml . sax . DocumentHandler ; import org . xml . sax . ContentHandler ; import org . xml . sax . AttributeList ; import org . xml . sax . Attributes ; public final class TextSerializer extends BaseMarkupSerializer { public TextSerializer ( ) { super ( new OutputFormat ( Method . TEXT , null , false ) ) ; } public void setOutputFormat ( OutputFormat format ) { super . setOutputFormat ( format != null ? format : new OutputFormat ( Method . TEXT , null , false ) ) ; } public void startElement ( String namespaceURI , String localName , String rawName , Attributes attrs ) { startElement ( rawName == null ? localName : rawName , null ) ; } public void endElement ( String namespaceURI , String localName , String rawName ) { endElement ( rawName == null ? localName : rawName ) ; } public void startElement ( String tagName , AttributeList attrs ) { boolean preserveSpace ; ElementState state ; state = getElementState ( ) ; if ( isDocumentState ( ) ) { if ( ! _started ) startDocument ( tagName ) ; } preserveSpace = state . preserveSpace ; state = enterElementState ( null , null , tagName , preserveSpace ) ; } public void endElement ( String tagName ) { ElementState state ; state = getElementState ( ) ; state = leaveElementState ( ) ; state . afterElement = true ; state . empty = false ; if ( isDocumentState ( ) ) _printer . flush ( ) ; } public void processingInstruction ( String target , String code ) { } public void comment ( String text ) { } public void comment ( char [ ] chars , int start , int length ) { } public void characters ( char [ ] chars , int start , int length ) { ElementState state ; state = content ( ) ; state . doCData = state . inCData = false ; printText ( chars , start , length , true , true ) ; } protected void characters ( String text , boolean unescaped ) { ElementState state ; state = content ( ) ; state . doCData = state . inCData = false ; printText ( text , true , true ) ; } protected void startDocument ( String rootTagName ) { _printer . leaveDTD ( ) ; _started = true ; serializePreRoot ( ) ; } protected void serializeElement ( Element elem ) { Node child ; ElementState state ; boolean preserveSpace ; String tagName ; tagName = elem . getTagName ( ) ; state = getElementState ( ) ; if ( isDocumentState ( ) ) { if ( ! _started ) startDocument ( tagName ) ; } preserveSpace = state . preserveSpace ; if ( elem . hasChildNodes ( ) ) { state = enterElementState ( null , null , tagName , preserveSpace ) ; child = elem . getFirstChild ( ) ; while ( child != null ) { serializeNode ( child ) ; child = child . getNextSibling ( ) ; } endElement ( tagName ) ; } else { if ( ! isDocumentState ( ) ) { state . afterElement = true ; state . empty = false ; } } } protected void serializeNode ( Node node ) { switch ( node . getNodeType ( ) ) { case Node . TEXT_NODE : { String text ; text = node . getNodeValue ( ) ; if ( text != null ) characters ( node . getNodeValue ( ) , true ) ; break ; } case Node . CDATA_SECTION_NODE : { String text ; text = node . getNodeValue ( ) ; if ( text != null ) characters ( node . getNodeValue ( ) , true ) ; break ; } case Node . COMMENT_NODE : break ; case Node . ENTITY_REFERENCE_NODE : break ; case Node . PROCESSING_INSTRUCTION_NODE : break ; case Node . ELEMENT_NODE : serializeElement ( ( Element ) node ) ; break ; case Node . DOCUMENT_NODE : case Node . DOCUMENT_FRAGMENT_NODE : { Node child ; child = node . getFirstChild ( ) ; while ( child != null ) { serializeNode ( child ) ; child = child . getNextSibling ( ) ; } break ; } default : break ; } } protected ElementState content ( ) { ElementState state ; state = getElementState ( ) ; if ( ! isDocumentState ( ) ) { if ( state . empty ) state . empty = false ; state . afterElement = false ; } return state ; } protected String getEntityRef ( char ch ) { return null ; } } 	0
package org . apache . xerces . utils ; import java . lang . * ; public final class HexBin { static private final int BASELENGTH = 255 ; static private final int LOOKUPLENGTH = 16 ; static private byte [ ] hexNumberTable = new byte [ BASELENGTH ] ; static private byte [ ] lookUpHexAlphabet = new byte [ LOOKUPLENGTH ] ; static { for ( int i = 0 ; i < BASELENGTH ; i ++ ) { hexNumberTable [ i ] = - 1 ; } for ( int i = '9' ; i >= '0' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - '0' ) ; } for ( int i = 'F' ; i >= 'A' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - 'A' + 10 ) ; } for ( int i = 'f' ; i >= 'a' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - 'a' + 10 ) ; } for ( int i = 0 ; i <= 25 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( 'A' + i ) ; for ( int i = 0 ; i < 10 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( '0' + i ) ; for ( int i = 10 ; i <= 15 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( 'A' + i - 10 ) ; } static boolean isHex ( byte octect ) { return ( hexNumberTable [ octect ] != - 1 ) ; } static boolean isArrayByteHex ( byte [ ] arrayOctect ) { int length = arrayOctect . length ; if ( length == 0 ) return false ; for ( int i = 0 ; i < length ; i ++ ) { if ( HexBin . isHex ( arrayOctect [ i ] ) == false ) return false ; } return true ; } public static boolean isHex ( String isValidString ) { return ( isArrayByteHex ( isValidString . getBytes ( ) ) ) ; } static public byte [ ] encode ( byte [ ] binaryData ) { int lengthData = binaryData . length ; int lengthEncode = lengthData ; byte [ ] encodedData = new byte [ lengthData ] ; for ( int i = 0 ; i < lengthData ; i ++ ) { encodedData [ i ] = lookUpHexAlphabet [ binaryData [ i ] ] ; } return encodedData ; } static public byte [ ] decode ( byte [ ] binaryData ) { int lengthData = binaryData . length ; int lengthEncode = lengthData ; byte [ ] decodedData = new byte [ lengthData ] ; for ( int i = 0 ; i < lengthData ; i ++ ) { decodedData [ i ] = hexNumberTable [ binaryData [ i ] ] ; } return decodedData ; } } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . utils . QName ; public final class ContentLeafNameTypeVector { public QName [ ] leafNames = null ; public int [ ] leafTypes = null ; public int leafCount = 0 ; public ContentLeafNameTypeVector ( ) { } public ContentLeafNameTypeVector ( QName [ ] names , int [ ] types , int count ) { setValues ( names , types , count ) ; } public ContentLeafNameTypeVector ( ContentLeafNameTypeVector clntv ) { this ( clntv . leafNames , clntv . leafTypes , clntv . leafCount ) ; } public void setValues ( QName [ ] names , int [ ] types , int count ) { if ( count > 0 ) { leafNames = new QName [ count ] ; leafTypes = new int [ count ] ; leafCount = count ; System . arraycopy ( names , 0 , leafNames , 0 , count ) ; System . arraycopy ( types , 0 , leafTypes , 0 , count ) ; } } } 	0
package org . w3c . dom ; public interface EntityReference extends Node { } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLBrElementImpl extends WMLElementImpl implements WMLBrElement { public WMLBrElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom ; public interface Attr extends Node { public String getName ( ) ; public boolean getSpecified ( ) ; public String getValue ( ) ; public void setValue ( String value ) throws DOMException ; public Element getOwnerElement ( ) ; } 	1
package org . w3c . dom . html ; public interface HTMLStyleElement extends HTMLElement { public boolean getDisabled ( ) ; public void setDisabled ( boolean disabled ) ; public String getMedia ( ) ; public void setMedia ( String media ) ; public String getType ( ) ; public void setType ( String type ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . DOMException ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . CharacterData ; import org . apache . xerces . dom . DOMExceptionImpl ; import org . apache . xerces . dom . DocumentImpl ; import org . w3c . dom . range . * ; import java . util . Vector ; public class RangeImpl implements Range { static final int START = 0 ; static final int AFTER = 1 ; static final int BEFORE = - 1 ; DocumentImpl fDocument ; Node fStartContainer ; Node fEndContainer ; int fStartOffset ; int fEndOffset ; boolean fIsCollapsed ; boolean fDetach = false ; Node fInsertNode = null ; Node fDeleteNode = null ; Node fSplitNode = null ; public RangeImpl ( DocumentImpl document ) { fDocument = document ; fStartContainer = document ; fEndContainer = document ; fStartOffset = 0 ; fEndOffset = 0 ; fDetach = false ; } public Node getStartContainer ( ) { return fStartContainer ; } public int getStartOffset ( ) { return fStartOffset ; } public Node getEndContainer ( ) { return fEndContainer ; } public int getEndOffset ( ) { return fEndOffset ; } public boolean getCollapsed ( ) { return ( fStartContainer == fEndContainer && fStartOffset == fEndOffset ) ; } public Node getCommonAncestorContainer ( ) { Vector startV = new Vector ( ) ; Node node ; for ( node = fStartContainer ; node != null ; node = node . getParentNode ( ) ) { startV . addElement ( node ) ; } Vector endV = new Vector ( ) ; for ( node = fEndContainer ; node != null ; node = node . getParentNode ( ) ) { endV . addElement ( node ) ; } int s = startV . size ( ) - 1 ; int e = endV . size ( ) - 1 ; Object result = null ; while ( s >= 0 && e >= 0 ) { if ( startV . elementAt ( s ) == endV . elementAt ( e ) ) { result = startV . elementAt ( s ) ; } else { break ; } -- s ; -- e ; } return ( Node ) result ; } public void setStart ( Node refNode , int offset ) throws RangeException , DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } checkIndex ( refNode , offset ) ; fStartContainer = refNode ; fStartOffset = offset ; } public void setEnd ( Node refNode , int offset ) throws RangeException , DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } checkIndex ( refNode , offset ) ; fEndContainer = refNode ; fEndOffset = offset ; } public void setStartBefore ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i - 1 ; } public void setStartAfter ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i ; } public void setEndBefore ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fEndContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fEndOffset = i - 1 ; } public void setEndAfter ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fEndContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fEndOffset = i ; } public void collapse ( boolean toStart ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( toStart ) { fEndContainer = fStartContainer ; fEndOffset = fStartOffset ; } else { fStartContainer = fEndContainer ; fStartOffset = fEndOffset ; } } public void selectNode ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } Node parent = refNode . getParentNode ( ) ; if ( parent != null ) { fStartContainer = parent ; fEndContainer = parent ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i - 1 ; fEndOffset = fStartOffset + 1 ; } } public void selectNodeContents ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode ; fEndContainer = refNode ; Node first = refNode . getFirstChild ( ) ; fStartOffset = 0 ; if ( first == null ) { fEndOffset = 0 ; } else { int i = 0 ; for ( Node n = first ; n != null ; n = n . getNextSibling ( ) ) { i ++ ; } fEndOffset = i ; } } public short compareBoundaryPoints ( short how , Range sourceRange ) throws DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Node endPointA ; Node endPointB ; int offsetA ; int offsetB ; if ( how == START_TO_START ) { endPointA = sourceRange . getStartContainer ( ) ; endPointB = fStartContainer ; offsetA = sourceRange . getStartOffset ( ) ; offsetB = fStartOffset ; } else if ( how == START_TO_END ) { endPointA = sourceRange . getStartContainer ( ) ; endPointB = fEndContainer ; offsetA = sourceRange . getStartOffset ( ) ; offsetB = fEndOffset ; } else if ( how == END_TO_START ) { endPointA = sourceRange . getEndContainer ( ) ; endPointB = fStartContainer ; offsetA = sourceRange . getEndOffset ( ) ; offsetB = fStartOffset ; } else { endPointA = sourceRange . getEndContainer ( ) ; endPointB = fEndContainer ; offsetA = sourceRange . getEndOffset ( ) ; offsetB = fEndOffset ; } if ( endPointA == endPointB ) { if ( offsetA < offsetB ) return - 1 ; if ( offsetA == offsetB ) return 0 ; return 1 ; } for ( Node node = endPointA . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { if ( isAncestorOf ( node , endPointB ) ) { int index = indexOf ( node , endPointA ) ; if ( offsetA < index ) return - 1 ; if ( offsetA == index ) return 0 ; return 1 ; } } for ( Node node = endPointB . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { if ( isAncestorOf ( node , endPointA ) ) { int index = indexOf ( node , endPointB ) ; if ( offsetB < index ) return - 1 ; if ( offsetB == index ) return 0 ; return 1 ; } } Node ancestor = getCommonAncestorContainer ( ) ; Node current = ancestor ; do { if ( current == endPointA ) return - 1 ; if ( current == endPointB ) return 1 ; current = nextNode ( current , true ) ; } while ( current != null && current != ancestor ) ; return - 2 ; } public void deleteContents ( ) throws DOMException { Node current = fStartContainer ; Node parent = null ; Node next ; boolean deleteCurrent = false ; Node root = getCommonAncestorContainer ( ) ; if ( fStartContainer == fEndContainer ) { if ( fStartOffset == fEndOffset ) { return ; } if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { String value = fStartContainer . getNodeValue ( ) ; int realStart = fStartOffset ; int realEnd = fEndOffset ; if ( fStartOffset > value . length ( ) ) realStart = value . length ( ) - 1 ; if ( fEndOffset > value . length ( ) ) realEnd = value . length ( ) - 1 ; deleteData ( ( CharacterData ) fStartContainer , realStart , realEnd - realStart ) ; } else { current = fStartContainer . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } for ( i = 0 ; i < fEndOffset - fStartOffset && current != null ; i ++ ) { Node newCurrent = current . getNextSibling ( ) ; removeChild ( fStartContainer , current ) ; current = newCurrent ; } } collapse ( true ) ; return ; } Node partialNode = null ; int partialInt = START ; Node startRoot = null ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { deleteData ( ( CharacterData ) current , fStartOffset , current . getNodeValue ( ) . length ( ) - fStartOffset ) ; } else { current = current . getFirstChild ( ) ; for ( int i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fStartContainer ; } else if ( current != fStartContainer ) { deleteCurrent = true ; } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { if ( startRoot == null ) startRoot = current ; } else { if ( partialNode == null ) { partialNode = parent ; partialInt = AFTER ; } } if ( parent != root ) { next = current . getNextSibling ( ) ; Node nextnext ; while ( next != null ) { nextnext = next . getNextSibling ( ) ; removeChild ( parent , next ) ; next = nextnext ; } } if ( deleteCurrent ) { removeChild ( parent , current ) ; deleteCurrent = false ; } current = parent ; } Node endRoot = null ; current = fEndContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { deleteData ( ( CharacterData ) current , 0 , fEndOffset ) ; } else { if ( fEndOffset == 0 ) { current = fEndContainer ; } else { current = current . getFirstChild ( ) ; for ( int i = 1 ; i < fEndOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fEndContainer . getLastChild ( ) ; } else if ( current != fStartContainer ) { deleteCurrent = true ; } } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { if ( endRoot == null ) endRoot = current ; } else { if ( partialNode == null ) { partialNode = parent ; partialInt = BEFORE ; } } if ( parent != root && parent != null ) { next = current . getPreviousSibling ( ) ; Node nextnext ; while ( next != null ) { nextnext = next . getPreviousSibling ( ) ; removeChild ( parent , next ) ; next = nextnext ; } } if ( deleteCurrent ) { removeChild ( parent , current ) ; deleteCurrent = false ; } current = parent ; } current = endRoot . getPreviousSibling ( ) ; Node prev = null ; while ( current != null && current != startRoot ) { prev = current . getPreviousSibling ( ) ; parent = current . getParentNode ( ) ; if ( parent != null ) { removeChild ( parent , current ) ; } current = prev ; } if ( partialNode == null ) { collapse ( true ) ; } else if ( partialInt == AFTER ) { setStartAfter ( partialNode ) ; setEndAfter ( partialNode ) ; } else if ( partialInt == BEFORE ) { setStartBefore ( partialNode ) ; setEndBefore ( partialNode ) ; } } public DocumentFragment extractContents ( ) throws DOMException { return traverseContents ( EXTRACT_CONTENTS ) ; } public DocumentFragment cloneContents ( ) throws DOMException { return traverseContents ( CLONE_CONTENTS ) ; } public void insertNode ( Node newNode ) throws DOMException , RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } int type = newNode . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_NODE || type == Node . DOCUMENT_FRAGMENT_NODE ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } if ( newNode == null ) return ; Node cloneCurrent ; Node current ; boolean MULTIPLE_MODE = false ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( newNode . getNodeType ( ) != Node . TEXT_NODE ) { cloneCurrent = fStartContainer . cloneNode ( false ) ; ( ( TextImpl ) cloneCurrent ) . setNodeValueInternal ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset ) ) ; ( ( TextImpl ) fStartContainer ) . setNodeValueInternal ( ( fStartContainer . getNodeValue ( ) ) . substring ( 0 , fStartOffset ) ) ; Node next = fStartContainer . getNextSibling ( ) ; if ( next != null ) { Node parent = fStartContainer . getParentNode ( ) ; if ( parent != null ) { parent . insertBefore ( newNode , next ) ; parent . insertBefore ( cloneCurrent , next ) ; } } else { Node parent = fStartContainer . getParentNode ( ) ; if ( parent != null ) { parent . appendChild ( newNode ) ; parent . appendChild ( cloneCurrent ) ; } } signalSplitData ( fStartContainer , cloneCurrent , fStartOffset ) ; } else { String value = fStartContainer . getNodeValue ( ) ; String newValue = newNode . getNodeValue ( ) ; insertData ( ( CharacterData ) fStartContainer , fStartOffset , newValue ) ; } } else { current = fStartContainer . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current != null ) { fStartContainer . insertBefore ( newNode , current ) ; } else { fStartContainer . appendChild ( newNode ) ; } } } public void surroundContents ( Node newParent ) throws DOMException , RangeException { if ( newParent == null ) return ; if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } int type = newParent . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_TYPE_NODE || type == Node . DOCUMENT_NODE || type == Node . DOCUMENT_FRAGMENT_NODE ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } Node root = getCommonAncestorContainer ( ) ; Node realStart = fStartContainer ; Node realEnd = fEndContainer ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { realStart = fStartContainer . getParentNode ( ) ; } if ( fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { realEnd = fEndContainer . getParentNode ( ) ; } if ( realStart != realEnd ) { throw new RangeExceptionImpl ( RangeException . BAD_BOUNDARYPOINTS_ERR , "DOM013 Bad boundary points" ) ; } DocumentFragment frag = extractContents ( ) ; insertNode ( newParent ) ; newParent . appendChild ( frag ) ; selectNode ( newParent ) ; } public Range cloneRange ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Range range = fDocument . createRange ( ) ; range . setStart ( fStartContainer , fStartOffset ) ; range . setEnd ( fEndContainer , fEndOffset ) ; return range ; } public String toString ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Node node = fStartContainer ; StringBuffer sb = new StringBuffer ( ) ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE || fStartContainer . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { if ( fStartContainer == fEndContainer ) { sb . append ( fStartContainer . getNodeValue ( ) . substring ( fStartOffset , fEndOffset ) ) ; return sb . toString ( ) ; } else { sb . append ( fStartContainer . getNodeValue ( ) . substring ( fStartOffset ) ) ; } } while ( node != fEndContainer ) { node = nextNode ( node , true ) ; if ( node == null ) break ; if ( node . getNodeType ( ) == Node . TEXT_NODE || node . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { sb . append ( node . getNodeValue ( ) ) ; } } if ( fEndContainer . getNodeType ( ) == Node . TEXT_NODE || fEndContainer . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { sb . append ( fEndContainer . getNodeValue ( ) . substring ( 0 , fEndOffset ) ) ; } return sb . toString ( ) ; } public void detach ( ) { fDetach = true ; fDocument . removeRange ( this ) ; } void signalSplitData ( Node node , Node newNode , int offset ) { fSplitNode = node ; fDocument . splitData ( node , newNode , offset ) ; fSplitNode = null ; } void receiveSplitData ( Node node , Node newNode , int offset ) { if ( node == null || newNode == null ) return ; if ( fSplitNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fStartOffset > offset ) { fStartOffset = fStartOffset - offset ; fStartContainer = newNode ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fEndOffset > offset ) { fEndOffset = fEndOffset - offset ; fEndContainer = newNode ; } } } void deleteData ( CharacterData node , int offset , int count ) { fDeleteNode = node ; node . deleteData ( offset , count ) ; fDeleteNode = null ; } void receiveDeletedText ( Node node , int offset , int count ) { if ( node == null ) return ; if ( fDeleteNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fStartOffset > offset + count ) { fStartOffset = offset + ( fStartOffset - ( offset + count ) ) ; } else if ( fStartOffset > offset ) { fStartOffset = offset ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fEndOffset > offset + count ) { fEndOffset = offset + ( fEndOffset - ( offset + count ) ) ; } else if ( fEndOffset > offset ) { fEndOffset = offset ; } } } void insertData ( CharacterData node , int index , String insert ) { fInsertNode = node ; node . insertData ( index , insert ) ; fInsertNode = null ; } void receiveInsertedText ( Node node , int index , int len ) { if ( node == null ) return ; if ( fInsertNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( index < fStartOffset ) { fStartOffset = fStartOffset + len ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( index < fEndOffset ) { fEndOffset = fEndOffset + len ; } } } void receiveReplacedText ( Node node ) { if ( node == null ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { fStartOffset = 0 ; } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { fEndOffset = 0 ; } } public void insertedNodeFromDOM ( Node node ) { if ( node == null ) return ; if ( fInsertNode == node ) return ; Node parent = node . getParentNode ( ) ; if ( parent == fStartContainer ) { int index = indexOf ( node , fStartContainer ) ; if ( index < fStartOffset ) { fStartOffset ++ ; } } if ( parent == fEndContainer ) { int index = indexOf ( node , fEndContainer ) ; if ( index < fEndOffset ) { fEndOffset ++ ; } } } Node fRemoveChild = null ; Node removeChild ( Node parent , Node child ) { fRemoveChild = child ; Node n = parent . removeChild ( child ) ; fRemoveChild = null ; return n ; } void removeNode ( Node node ) { if ( node == null ) return ; if ( fRemoveChild == node ) return ; Node parent = node . getParentNode ( ) ; if ( parent == fStartContainer ) { int index = indexOf ( node , fStartContainer ) ; if ( index <= fStartOffset ) { fStartOffset -- ; } } if ( parent == fEndContainer ) { int index = indexOf ( node , fEndContainer ) ; if ( index < fEndOffset ) { fEndOffset -- ; } } if ( parent != fStartContainer && parent != fEndContainer ) { if ( isAncestorOf ( node , fStartContainer ) ) { fStartContainer = parent ; fStartOffset = indexOf ( node , parent ) - 1 ; } if ( isAncestorOf ( node , fEndContainer ) ) { fEndContainer = parent ; fEndOffset = indexOf ( node , parent ) - 1 ; } } } static final int EXTRACT_CONTENTS = 1 ; static final int CLONE_CONTENTS = 2 ; DocumentFragment traverseContents ( int traversalType ) throws DOMException { if ( fStartContainer == null || fEndContainer == null ) { return null ; } DocumentFragment frag = fDocument . createDocumentFragment ( ) ; Node current = fStartContainer ; Node cloneCurrent = null ; Node cloneParent = null ; Node partialNode = null ; int partialInt = START ; Vector d = new Vector ( ) ; if ( fStartContainer == fEndContainer ) { if ( fStartOffset == fEndOffset ) { return frag ; } if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = fStartContainer . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset , fEndOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , fStartOffset , fEndOffset - fStartOffset ) ; } frag . appendChild ( cloneCurrent ) ; } else { current = current . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } int n = fEndOffset - fStartOffset ; for ( i = 0 ; i < n && current != null ; i ++ ) { Node newCurrent = current . getNextSibling ( ) ; if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; frag . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { frag . appendChild ( current ) ; } current = newCurrent ; } } return frag ; } Node root = getCommonAncestorContainer ( ) ; Node parent = null ; current = fStartContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = current . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , fStartOffset , current . getNodeValue ( ) . length ( ) - fStartOffset ) ; } } else { current = current . getFirstChild ( ) ; for ( int i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fStartContainer ; } if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } } Node startRoot = null ; parent = null ; while ( current != root ) { parent = current . getParentNode ( ) ; if ( parent == root ) { cloneParent = frag ; startRoot = current ; } else { if ( parent == null ) System . out . println ( "parent==null: current=" + current ) ; cloneParent = parent . cloneNode ( false ) ; if ( partialNode == null && parent != root ) { partialNode = parent ; partialInt = AFTER ; } } Node next = null ; current = current . getNextSibling ( ) ; cloneParent . appendChild ( cloneCurrent ) ; while ( current != null ) { next = current . getNextSibling ( ) ; if ( current != null && parent != root ) { if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; cloneParent . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneParent . appendChild ( current ) ; } } current = next ; } current = parent ; cloneCurrent = cloneParent ; } Node endRoot = null ; current = fEndContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = current . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( 0 , fEndOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , 0 , fEndOffset ) ; } } else { if ( fEndOffset == 0 ) { current = fEndContainer ; } else { current = current . getFirstChild ( ) ; for ( int i = 1 ; i < fEndOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fEndContainer . getLastChild ( ) ; } } if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { cloneParent = frag ; endRoot = current ; } else { cloneParent = parent . cloneNode ( false ) ; if ( partialNode == null && parent != root ) { partialNode = parent ; partialInt = BEFORE ; } } Node holdCurrent = current ; current = parent . getFirstChild ( ) ; cloneParent . appendChild ( cloneCurrent ) ; Node next = null ; while ( current != holdCurrent && current != null ) { next = current . getNextSibling ( ) ; if ( current != null && parent != root ) { if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; cloneParent . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneParent . appendChild ( current ) ; } } current = next ; } current = parent ; cloneCurrent = cloneParent ; } d . removeAllElements ( ) ; Node clonedPrevious = frag . getLastChild ( ) ; current = endRoot . getPreviousSibling ( ) ; Node prev = null ; while ( current != startRoot && current != null ) { prev = current . getPreviousSibling ( ) ; if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } frag . insertBefore ( cloneCurrent , clonedPrevious ) ; current = prev ; clonedPrevious = cloneCurrent ; } if ( traversalType == EXTRACT_CONTENTS ) { if ( partialNode == null ) { collapse ( true ) ; } else if ( partialInt == AFTER ) { setStartAfter ( partialNode ) ; setEndAfter ( partialNode ) ; } else if ( partialInt == BEFORE ) { setStartBefore ( partialNode ) ; setEndBefore ( partialNode ) ; } } return frag ; } void checkIndex ( Node refNode , int offset ) throws DOMException { if ( offset < 0 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } int type = refNode . getNodeType ( ) ; if ( ( type == Node . TEXT_NODE || type == Node . CDATA_SECTION_NODE || type == Node . COMMENT_NODE || type == Node . PROCESSING_INSTRUCTION_NODE ) && offset > refNode . getNodeValue ( ) . length ( ) ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } Node child = refNode . getFirstChild ( ) ; int i = 1 ; for ( ; child != null ; i ++ ) { child = child . getNextSibling ( ) ; } if ( i > offset ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } boolean isAncestorTypeValid ( Node node ) { for ( Node n = node ; n != null ; n = n . getParentNode ( ) ) { int type = n . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_TYPE_NODE ) return false ; } return true ; } Node nextNode ( Node node , boolean visitChildren ) { if ( node == null ) return null ; Node result ; if ( visitChildren ) { result = node . getFirstChild ( ) ; if ( result != null ) { return result ; } } result = node . getNextSibling ( ) ; if ( result != null ) { return result ; } Node parent = node . getParentNode ( ) ; while ( parent != null && parent != fDocument ) { result = parent . getNextSibling ( ) ; if ( result != null ) { return result ; } else { parent = parent . getParentNode ( ) ; } } return null ; } boolean isAncestorOf ( Node a , Node b ) { for ( Node node = b ; node != null ; node = node . getParentNode ( ) ) { if ( node == a ) return true ; } return false ; } int indexOf ( Node child , Node parent ) { Node node ; int i = 0 ; if ( child . getParentNode ( ) != parent ) return - 1 ; for ( node = child ; node != null ; node = node . getPreviousSibling ( ) ) { i ++ ; } return i ; } } 	1
package org . w3c . dom . html ; public interface HTMLBRElement extends HTMLElement { public String getClear ( ) ; public void setClear ( String clear ) ; } 	0
package org . apache . xerces . jaxp ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xerces . parsers . SAXParser ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public class SAXParserImpl extends javax . xml . parsers . SAXParser { private boolean namespaces = false ; private boolean validation = false ; private Parser parser = null ; private SAXParserImpl ( ) { super ( ) ; } protected SAXParserImpl ( boolean namespaces , boolean validation ) throws ParserConfigurationException { this ( ) ; SAXParser p = new SAXParser ( ) ; try { p . setFeature ( "http://xml.org/sax/features/namespaces" , namespaces ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set namespace " + "awareness to " + namespaces ) ; } try { p . setFeature ( "http://xml.org/sax/features/validation" , validation ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set validation to " + validation ) ; } this . namespaces = namespaces ; this . validation = validation ; this . parser = p ; } public Parser getParser ( ) { return ( this . parser ) ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLLabelElementImpl extends HTMLElementImpl implements HTMLLabelElement , HTMLFormControl { public String getAccessKey ( ) { String accessKey ; accessKey = getAttribute ( "accesskey" ) ; if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; return accessKey ; } public void setAccessKey ( String accessKey ) { if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; setAttribute ( "accesskey" , accessKey ) ; } public String getHtmlFor ( ) { return getAttribute ( "for" ) ; } public void setHtmlFor ( String htmlFor ) { setAttribute ( "for" , htmlFor ) ; } public HTMLLabelElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package javax . xml . parsers ; import org . xml . sax . SAXException ; public abstract class SAXParserFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.SAXParserFactory" ; private static String factory = "org.apache.xerces.jaxp.SAXParserFactoryImpl" ; protected SAXParserFactory ( ) { super ( ) ; } public static SAXParserFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( SAXParserFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "SAXParserFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified SAXParserFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "SAXParserFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"javax.xml.parsers.SAXParserFactory\"" ) ; } } public abstract SAXParser newSAXParser ( ) throws ParserConfigurationException , SAXException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLUListElementImpl extends HTMLElementImpl implements HTMLUListElement { public boolean getCompact ( ) { return getBinary ( "compact" ) ; } public void setCompact ( boolean compact ) { setAttribute ( "compact" , compact ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } public void setType ( String type ) { setAttribute ( "type" , type ) ; } public HTMLUListElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . framework ; public class Version { public static String fVersion = "Xerces 1.2.0" ; public static void main ( String argv [ ] ) { System . out . println ( fVersion ) ; } } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Locale ; import java . util . Calendar ; import java . util . GregorianCalendar ; import java . text . ParseException ; import org . apache . xerces . utils . regex . RegularExpression ; import org . apache . xerces . validators . schema . SchemaSymbols ; public class TimeDurationDatatypeValidator extends AbstractDatatypeValidator { private Locale fLocale = null ; private DatatypeValidator fBaseValidator = null ; private String fPattern = null ; private long fMaxInclusive = 0L ; private long fMaxExclusive = 0L ; private long fMinInclusive = 0L ; private long fMinExclusive = 0L ; private long fDuration = 0L ; private long fPeriod = 0L ; private boolean isMaxExclusiveDefined = false ; private boolean isMaxInclusiveDefined = false ; private boolean isMinExclusiveDefined = false ; private boolean isMinInclusiveDefined = false ; private int fFacetsDefined = 0 ; private boolean fDerivedByList = false ; private long [ ] fEnumTimeDuration = null ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; public TimeDurationDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public TimeDurationDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { if ( base != null ) setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { if ( fDerivedByList == false ) { if ( fBaseValidator != null ) for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = ( String ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; continue ; } else if ( key . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMaxInclusive = normalizeDuration ( value . toCharArray ( ) , 0 ) ; } catch ( InvalidDatatypeValueException nfe ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXEXCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMaxExclusive = normalizeDuration ( value . toCharArray ( ) , 0 ) ; } catch ( InvalidDatatypeValueException nfe ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMinInclusive = normalizeDuration ( value . toCharArray ( ) , 0 ) ; } catch ( InvalidDatatypeValueException nfe ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMinExclusive = normalizeDuration ( value . toCharArray ( ) , 0 ) ; } catch ( InvalidDatatypeValueException nfe ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . MSG_FORMAT_FAILURE , DatatypeMessageProvider . MSG_NONE , null ) ) ; } } isMaxExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXEXCLUSIVE ) != 0 ) ? true : false ; isMaxInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXINCLUSIVE ) != 0 ) ? true : false ; isMinExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MINEXCLUSIVE ) != 0 ) ? true : false ; isMinInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MININCLUSIVE ) != 0 ) ? true : false ; if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both maxInclusive and maxExclusive to be specified for the same datatype." ) ; } if ( isMinExclusiveDefined && isMinInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both minInclusive and minExclusive to be specified for the same datatype." ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { Vector v = ( Vector ) facets . get ( SchemaSymbols . ELT_ENUMERATION ) ; if ( v != null ) { fEnumTimeDuration = new long [ v . size ( ) ] ; int i = 0 ; String value = null ; try { for ( ; i < v . size ( ) ; i ++ ) { value = ( String ) v . elementAt ( i ) ; fEnumTimeDuration [ i ] = normalizeDuration ( value . toCharArray ( ) , 0 ) ; boundsCheck ( fEnumTimeDuration [ i ] ) ; } } catch ( InvalidDatatypeValueException idve ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . InvalidEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { v . elementAt ( i ) } ) ) ; } } } } else { } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { long normalizedValue ; if ( fDerivedByList == false ) { if ( fPattern != null ) { RegularExpression regex = new RegularExpression ( fPattern , "X" ) ; if ( regex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value'" + content + "does not match regular expression facet" + fPattern ) ; } normalizedValue = normalizeDuration ( content . toCharArray ( ) , 0 ) ; try { boundsCheck ( normalizedValue ) ; } catch ( InvalidDatatypeFacetException ex ) { throw new InvalidDatatypeValueException ( "Boundary Exception" ) ; } if ( fEnumTimeDuration != null ) enumCheck ( normalizedValue ) ; } else { } return null ; } public void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } public void setLocale ( Locale locale ) { } public int compare ( String content1 , String content2 ) { return - 1 ; } public Hashtable getFacets ( ) { return null ; } public static long normalizeDuration ( char [ ] value , int start ) throws InvalidDatatypeValueException { int i = 0 , j = 0 , k = 0 , l = 0 , m = 0 ; int sepindex = 0 ; int index = start ; int lindex = 0 ; int endindex = ( start + value . length ) - 1 ; int pendindex = endindex ; final char [ ] dseps = { 'Y' , 'M' , 'D' } ; final char [ ] tseps = { 'H' , 'M' , 'S' } ; final char [ ] msc = { '0' , '0' , '0' } ; final int [ ] buckets = new int [ Calendar . FIELD_COUNT ] ; for ( i = 0 ; i < buckets . length ; i ++ ) buckets [ i ] = 0 ; boolean intime = false ; boolean fixed = false ; boolean p1negative = false ; boolean p2negative = false ; boolean p1specified = false ; boolean p2specified = false ; GregorianCalendar cstart = null ; GregorianCalendar cend = null ; try { if ( value [ index ] == '-' ) { p1negative = true ; } int ix = indexOf ( value , start , '/' ) ; if ( ix > - 1 && ix < endindex ) { if ( value [ ix + 1 ] == '-' ) { p2negative = true ; } if ( value [ ( p1negative ? index + 1 : index ) ] == 'P' ) { if ( p1negative ) index ++ ; p1specified = true ; pendindex = ix - 1 ; } else { cstart = ( GregorianCalendar ) normalizeInstant ( value , index , ix - index ) ; } if ( value [ ( p2negative ? ( ix + 2 ) : ( ix + 1 ) ) ] == 'P' ) { p2specified = true ; index = ( p2negative ? ( ix + 2 ) : ( ix + 1 ) ) ; } else { ix ++ ; cend = ( GregorianCalendar ) normalizeInstant ( value , ix , ( endindex - ix ) + 1 ) ; } } else { index = ( p1negative ? ( start + 1 ) : ( start ) ) ; } if ( cstart != null && cend != null ) { return ( ( cend . getTime ( ) . getTime ( ) - cstart . getTime ( ) . getTime ( ) ) ) ; } if ( p1specified && p2specified ) throw new ParseException ( "Period cannot be expressed as 2 durations." , 0 ) ; if ( p1specified && value [ index ] != 'P' ) { throw new ParseException ( "Invalid start character for timeDuration:" + value [ index ] , index ) ; } if ( p2specified && value [ index ] != 'P' ) { throw new ParseException ( "Invalid start character for timeDuration:" + value [ index ] , index ) ; } } catch ( Exception e ) { throw new InvalidDatatypeValueException ( e . toString ( ) ) ; } try { lindex = index + 1 ; for ( i = index + 1 ; i <= pendindex ; i ++ ) { if ( Character . isDigit ( value [ i ] ) || value [ i ] == '.' ) { if ( value [ i ] == '.' ) fixed = true ; continue ; } if ( value [ i ] == 'T' ) { intime = true ; sepindex = 0 ; lindex = i + 1 ; continue ; } sepindex = indexOf ( ( intime ? tseps : dseps ) , sepindex , value [ i ] ) ; if ( sepindex == - 1 ) throw new ParseException ( "Illegal or misplaced separator." , i ) ; sepindex ++ ; if ( fixed && value [ i ] != 'S' ) throw new ParseException ( "Fractional digits allowed only for 'seconds'." , i ) ; j = 0 ; switch ( value [ i ] ) { case ( 'Y' ) : { if ( intime ) throw new ParseException ( "Year must be specified before 'T' separator." , i ) ; buckets [ Calendar . YEAR ] = parseInt ( value , lindex , i - lindex ) ; break ; } case ( 'D' ) : { if ( intime ) throw new ParseException ( "Days must be specified before 'T' separator." , i ) ; buckets [ Calendar . DAY_OF_MONTH ] = parseInt ( value , lindex , i - lindex ) ; break ; } case ( 'H' ) : { if ( ! intime ) throw new ParseException ( "Hours must be specified after 'T' separator." , i ) ; buckets [ Calendar . HOUR_OF_DAY ] = parseInt ( value , lindex , i - lindex ) ; break ; } case ( 'M' ) : { buckets [ ( intime ? Calendar . MINUTE : Calendar . MONTH ) ] = parseInt ( value , lindex , i - lindex ) ; break ; } case ( 'S' ) : { if ( ! intime ) throw new ParseException ( "Seconds must be specified after 'T' separator." , i ) ; if ( ! fixed ) buckets [ Calendar . SECOND ] = parseInt ( value , lindex , i - lindex ) ; else { int ps = indexOf ( value , lindex , '.' ) ; buckets [ Calendar . SECOND ] = parseInt ( value , lindex , ps - lindex ) ; ps ++ ; k = 0 ; while ( ( ps <= pendindex ) && ( k < 3 ) && Character . isDigit ( value [ ps ] ) ) msc [ k ++ ] = value [ ps ++ ] ; buckets [ Calendar . MILLISECOND ] = parseInt ( msc , 0 , 3 ) ; fixed = false ; } break ; } default : { throw new ParseException ( "Illegal 'picture' character: " + value [ i ] , i ) ; } } lindex = i + 1 ; } } catch ( Exception e ) { throw new InvalidDatatypeValueException ( e . toString ( ) ) ; } try { if ( cstart != null ) { long st = cstart . getTime ( ) . getTime ( ) ; for ( k = 0 ; k < buckets . length ; k ++ ) if ( buckets [ k ] != 0 ) cstart . add ( k , ( p2negative ? - buckets [ k ] : buckets [ k ] ) ) ; long ms = cstart . getTime ( ) . getTime ( ) ; return ( ( ms - st ) ) ; } if ( cend != null ) { long st = cend . getTime ( ) . getTime ( ) ; for ( k = 0 ; k < buckets . length ; k ++ ) if ( buckets [ k ] > 0 ) cend . add ( k , ( p1negative ? buckets [ k ] : - buckets [ k ] ) ) ; long ms = cend . getTime ( ) . getTime ( ) ; return ( ( ms - st ) ) ; } long r = ( ( ( long ) ( ( ( buckets [ Calendar . YEAR ] * 31104000L ) + ( buckets [ Calendar . MONTH ] * 2592000L ) + ( buckets [ Calendar . DAY_OF_MONTH ] * 86400L ) + ( buckets [ Calendar . HOUR_OF_DAY ] * 3600L ) + ( buckets [ Calendar . MINUTE ] * 60L ) + ( buckets [ Calendar . SECOND ] ) ) * 1000L ) + ( buckets [ Calendar . MILLISECOND ] ) ) ) ; return ( ( p1negative ? - r : r ) ) ; } catch ( Exception e ) { throw new InvalidDatatypeValueException ( e . toString ( ) ) ; } } public static Calendar normalizeInstant ( char [ ] value , int start , int length ) throws InvalidDatatypeValueException { boolean negative = false ; boolean tznegative = false ; int tzoffset = 0 ; int tzhh = 0 , tzmm = 0 ; int i = start , j = 0 , k = 0 , l = 0 , m = 0 ; final char [ ] ms = { '0' , '0' , '0' } ; final Calendar cal = new GregorianCalendar ( ) ; final int endindex = ( start + length ) - 1 ; try { if ( length < 16 ) throw new ParseException ( "Value is too short." , 0 ) ; cal . clear ( ) ; cal . setLenient ( false ) ; if ( value [ i ] == '-' || value [ i ] == '+' ) { cal . set ( Calendar . ERA , ( value [ i ] == '-' ? GregorianCalendar . BC : GregorianCalendar . AD ) ) ; i ++ ; } j = indexOf ( value , i , '-' , i + 5 ) ; if ( j == - 1 || j > endindex ) throw new ParseException ( "Year separator is missing or misplaced." , i ) ; cal . set ( Calendar . YEAR , parseInt ( value , i , j - i ) ) ; i = j + 1 ; cal . set ( Calendar . MONTH , parseInt ( value , i , 2 ) - 1 ) ; i += 2 ; if ( value [ i ] != '-' ) throw new ParseException ( "Month separator is missing or misplaced." , i ) ; cal . set ( Calendar . DAY_OF_MONTH , parseInt ( value , i + 1 , 2 ) ) ; i += 3 ; if ( value [ i ] != 'T' ) throw new ParseException ( "Time separator is missing or misplaced." , i ) ; cal . set ( Calendar . HOUR_OF_DAY , parseInt ( value , i + 1 , 2 ) ) ; i += 3 ; if ( value [ i ] != ':' ) throw new ParseException ( "Hour separator is missing or misplaced." , i ) ; cal . set ( Calendar . MINUTE , parseInt ( value , i + 1 , 2 ) ) ; i += 3 ; if ( ( endindex - i ) > 1 && ( value [ i ] == ':' ) ) { cal . set ( Calendar . SECOND , parseInt ( value , i + 1 , 2 ) ) ; i += 3 ; if ( i < endindex && value [ i ] == '.' ) { i ++ ; k = 0 ; while ( ( i <= endindex ) && ( k < 3 ) && Character . isDigit ( value [ i ] ) ) ms [ k ++ ] = value [ i ++ ] ; cal . set ( Calendar . MILLISECOND , parseInt ( ms , 0 , 3 ) ) ; } while ( i <= endindex && Character . isDigit ( value [ i ] ) ) i ++ ; } if ( i <= endindex ) { if ( value [ i ] == 'Z' ) { cal . set ( Calendar . ZONE_OFFSET , 0 ) ; } else if ( value [ i ] == '-' || value [ i ] == '+' ) { tznegative = ( value [ i ] == '-' ) ; tzhh = parseInt ( value , i + 1 , 2 ) ; if ( ( endindex - i ) == 5 ) { if ( value [ i + 3 ] != ':' ) throw new ParseException ( "time zone must be 'hh:mm'." , i ) ; tzmm = parseInt ( value , i + 4 , 2 ) ; } tzoffset = ( ( tzhh * 3600000 ) + ( tzmm * 60000 ) ) ; cal . set ( Calendar . ZONE_OFFSET , ( tznegative ? - tzoffset : tzoffset ) ) ; } else throw new ParseException ( "Unrecognized time zone." , i ) ; } return ( cal ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new InvalidDatatypeValueException ( "Unable to parse timeInstant " + e . toString ( ) ) ; } } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } private void boundsCheck ( long f ) throws InvalidDatatypeFacetException { boolean inUpperBound = false ; boolean inLowerBound = false ; if ( isMaxInclusiveDefined ) { inUpperBound = ( f <= fMaxInclusive ) ; } else if ( isMaxExclusiveDefined ) { inUpperBound = ( f < fMaxExclusive ) ; } if ( isMinInclusiveDefined ) { inLowerBound = ( f >= fMinInclusive ) ; } else if ( isMinExclusiveDefined ) { inLowerBound = ( f > fMinExclusive ) ; } if ( inUpperBound == false || inLowerBound == false ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . OutOfBounds , DatatypeMessageProvider . MSG_NONE , new Object [ ] { new Long ( f ) , "" , "" , "" , "" } ) ) ; } } private void enumCheck ( long d ) throws InvalidDatatypeValueException { for ( int i = 0 ; i < this . fEnumTimeDuration . length ; i ++ ) { if ( d == fEnumTimeDuration [ i ] ) return ; } throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotAnEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { new Long ( d ) } ) ) ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } private static final int indexOf ( char [ ] value , int start , char s ) { return ( indexOf ( value , start , s , value . length - 1 ) ) ; } private static final int indexOf ( char [ ] value , int start , char s , int max ) { for ( int i = start ; i <= max ; i ++ ) if ( value [ i ] == s ) return ( i ) ; return ( - 1 ) ; } private static final int indexOneOf ( char [ ] value , int start , String s ) { return ( indexOneOf ( value , start , s , value . length - 1 ) ) ; } private static final int indexOneOf ( char [ ] value , int start , String s , int max ) { for ( int i = start ; i < max ; i ++ ) for ( int j = 0 ; j < s . length ( ) ; j ++ ) if ( value [ i ] == s . charAt ( j ) ) return ( i ) ; return ( - 1 ) ; } private static final int parseInt ( char [ ] s , int start , int length ) throws NumberFormatException { if ( s == null ) throw new NumberFormatException ( "null" ) ; int radix = 10 ; int result = 0 ; boolean negative = false ; int i = start ; int limit ; int multmin ; int digit = 0 ; if ( length <= 0 ) throw new NumberFormatException ( new String ( s , start , length ) ) ; if ( s [ i ] == '-' ) { negative = true ; limit = Integer . MIN_VALUE ; i ++ ; } else if ( s [ i ] == '+' ) { negative = false ; limit = - Integer . MAX_VALUE ; i ++ ; } else { limit = - Integer . MAX_VALUE ; } multmin = limit / radix ; if ( i < ( start + length ) ) { digit = Character . digit ( s [ i ++ ] , radix ) ; if ( digit < 0 ) throw new NumberFormatException ( new String ( s , start , length ) ) ; else result = - digit ; } while ( i < ( start + length ) ) { digit = Character . digit ( s [ i ++ ] , radix ) ; if ( digit < 0 ) throw new NumberFormatException ( new String ( s , start , length ) ) ; if ( result < multmin ) throw new NumberFormatException ( new String ( s , start , length ) ) ; result *= radix ; if ( result < limit + digit ) throw new NumberFormatException ( new String ( s , start , length ) ) ; result -= digit ; } if ( negative ) { if ( i > 1 ) return result ; else throw new NumberFormatException ( new String ( s , start , length ) ) ; } return - result ; } } 	0
package org . w3c . dom ; public interface CDATASection extends Text { } 	1
package org . apache . xerces . utils ; import java . io . IOException ; import java . io . Serializable ; public class URI implements Serializable { public static class MalformedURIException extends IOException { public MalformedURIException ( ) { super ( ) ; } public MalformedURIException ( String p_msg ) { super ( p_msg ) ; } } private static final String RESERVED_CHARACTERS = ";/?:@&=+$," ; private static final String MARK_CHARACTERS = "-_.!~*'() " ; private static final String SCHEME_CHARACTERS = "+-." ; private static final String USERINFO_CHARACTERS = ";:&=+$," ; private String m_scheme = null ; private String m_userinfo = null ; private String m_host = null ; private int m_port = - 1 ; private String m_path = null ; private String m_queryString = null ; private String m_fragment = null ; private static boolean DEBUG = false ; public URI ( ) { } public URI ( URI p_other ) { initialize ( p_other ) ; } public URI ( String p_uriSpec ) throws MalformedURIException { this ( ( URI ) null , p_uriSpec ) ; } public URI ( URI p_base , String p_uriSpec ) throws MalformedURIException { initialize ( p_base , p_uriSpec ) ; } public URI ( String p_scheme , String p_schemeSpecificPart ) throws MalformedURIException { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( "Cannot construct URI with null/empty scheme!" ) ; } if ( p_schemeSpecificPart == null || p_schemeSpecificPart . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( "Cannot construct URI with null/empty scheme-specific part!" ) ; } setScheme ( p_scheme ) ; setPath ( p_schemeSpecificPart ) ; } public URI ( String p_scheme , String p_host , String p_path , String p_queryString , String p_fragment ) throws MalformedURIException { this ( p_scheme , null , p_host , - 1 , p_path , p_queryString , p_fragment ) ; } public URI ( String p_scheme , String p_userinfo , String p_host , int p_port , String p_path , String p_queryString , String p_fragment ) throws MalformedURIException { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { throw new MalformedURIException ( "Scheme is required!" ) ; } if ( p_host == null ) { if ( p_userinfo != null ) { throw new MalformedURIException ( "Userinfo may not be specified if host is not specified!" ) ; } if ( p_port != - 1 ) { throw new MalformedURIException ( "Port may not be specified if host is not specified!" ) ; } } if ( p_path != null ) { if ( p_path . indexOf ( '?' ) != - 1 && p_queryString != null ) { throw new MalformedURIException ( "Query string cannot be specified in path and query string!" ) ; } if ( p_path . indexOf ( '#' ) != - 1 && p_fragment != null ) { throw new MalformedURIException ( "Fragment cannot be specified in both the path and fragment!" ) ; } } setScheme ( p_scheme ) ; setHost ( p_host ) ; setPort ( p_port ) ; setUserinfo ( p_userinfo ) ; setPath ( p_path ) ; setQueryString ( p_queryString ) ; setFragment ( p_fragment ) ; } private void initialize ( URI p_other ) { m_scheme = p_other . getScheme ( ) ; m_userinfo = p_other . getUserinfo ( ) ; m_host = p_other . getHost ( ) ; m_port = p_other . getPort ( ) ; m_path = p_other . getPath ( ) ; m_queryString = p_other . getQueryString ( ) ; m_fragment = p_other . getFragment ( ) ; } private void initialize ( URI p_base , String p_uriSpec ) throws MalformedURIException { if ( p_base == null && ( p_uriSpec == null || p_uriSpec . trim ( ) . length ( ) == 0 ) ) { throw new MalformedURIException ( "Cannot initialize URI with empty parameters." ) ; } if ( p_uriSpec == null || p_uriSpec . trim ( ) . length ( ) == 0 ) { initialize ( p_base ) ; return ; } String uriSpec = p_uriSpec . trim ( ) ; int uriSpecLen = uriSpec . length ( ) ; int index = 0 ; if ( uriSpec . indexOf ( ':' ) == - 1 ) { if ( p_base == null ) { throw new MalformedURIException ( "No scheme found in URI." ) ; } } else { initializeScheme ( uriSpec ) ; index = m_scheme . length ( ) + 1 ; } if ( ( ( index + 1 ) < uriSpecLen ) && ( uriSpec . substring ( index ) . startsWith ( "//" ) ) ) { index += 2 ; int startPos = index ; char testChar = '\0' ; while ( index < uriSpecLen ) { testChar = uriSpec . charAt ( index ) ; if ( testChar == '/' || testChar == '?' || testChar == '#' ) { break ; } index ++ ; } if ( index > startPos ) { initializeAuthority ( uriSpec . substring ( startPos , index ) ) ; } else { m_host = "" ; } } initializePath ( uriSpec . substring ( index ) ) ; if ( p_base != null ) { if ( m_path . length ( ) == 0 && m_scheme == null && m_host == null ) { m_scheme = p_base . getScheme ( ) ; m_userinfo = p_base . getUserinfo ( ) ; m_host = p_base . getHost ( ) ; m_port = p_base . getPort ( ) ; m_path = p_base . getPath ( ) ; if ( m_queryString == null ) { m_queryString = p_base . getQueryString ( ) ; } return ; } if ( m_scheme == null ) { m_scheme = p_base . getScheme ( ) ; } else { return ; } if ( m_host == null ) { m_userinfo = p_base . getUserinfo ( ) ; m_host = p_base . getHost ( ) ; m_port = p_base . getPort ( ) ; } else { return ; } if ( m_path . length ( ) > 0 && m_path . startsWith ( "/" ) ) { return ; } String path = new String ( ) ; String basePath = p_base . getPath ( ) ; if ( basePath != null ) { int lastSlash = basePath . lastIndexOf ( '/' ) ; if ( lastSlash != - 1 ) { path = basePath . substring ( 0 , lastSlash + 1 ) ; } } path = path . concat ( m_path ) ; index = - 1 ; while ( ( index = path . indexOf ( "/./" ) ) != - 1 ) { path = path . substring ( 0 , index + 1 ) . concat ( path . substring ( index + 3 ) ) ; } if ( path . endsWith ( "/." ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } index = - 1 ; int segIndex = - 1 ; String tempString = null ; while ( ( index = path . indexOf ( "/../" ) ) > 0 ) { tempString = path . substring ( 0 , path . indexOf ( "/../" ) ) ; segIndex = tempString . lastIndexOf ( '/' ) ; if ( segIndex != - 1 ) { if ( ! tempString . substring ( segIndex ++ ) . equals ( ".." ) ) { path = path . substring ( 0 , segIndex ) . concat ( path . substring ( index + 4 ) ) ; } } } if ( path . endsWith ( "/.." ) ) { tempString = path . substring ( 0 , path . length ( ) - 3 ) ; segIndex = tempString . lastIndexOf ( '/' ) ; if ( segIndex != - 1 ) { path = path . substring ( 0 , segIndex + 1 ) ; } } m_path = path ; } } private void initializeScheme ( String p_uriSpec ) throws MalformedURIException { int uriSpecLen = p_uriSpec . length ( ) ; int index = 0 ; String scheme = null ; char testChar = '\0' ; while ( index < uriSpecLen ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == ':' || testChar == '/' || testChar == '?' || testChar == '#' ) { break ; } index ++ ; } scheme = p_uriSpec . substring ( 0 , index ) ; if ( scheme . length ( ) == 0 ) { throw new MalformedURIException ( "No scheme found in URI." ) ; } else { setScheme ( scheme ) ; } } private void initializeAuthority ( String p_uriSpec ) throws MalformedURIException { int index = 0 ; int start = 0 ; int end = p_uriSpec . length ( ) ; char testChar = '\0' ; String userinfo = null ; if ( p_uriSpec . indexOf ( '@' , start ) != - 1 ) { while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '@' ) { break ; } index ++ ; } userinfo = p_uriSpec . substring ( start , index ) ; index ++ ; } String host = null ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == ':' ) { break ; } index ++ ; } host = p_uriSpec . substring ( start , index ) ; int port = - 1 ; if ( host . length ( ) > 0 ) { if ( testChar == ':' ) { index ++ ; start = index ; while ( index < end ) { index ++ ; } String portStr = p_uriSpec . substring ( start , index ) ; if ( portStr . length ( ) > 0 ) { for ( int i = 0 ; i < portStr . length ( ) ; i ++ ) { if ( ! isDigit ( portStr . charAt ( i ) ) ) { throw new MalformedURIException ( portStr + " is invalid. Port should only contain digits!" ) ; } } try { port = Integer . parseInt ( portStr ) ; } catch ( NumberFormatException nfe ) { } } } } setHost ( host ) ; setPort ( port ) ; setUserinfo ( userinfo ) ; } private void initializePath ( String p_uriSpec ) throws MalformedURIException { if ( p_uriSpec == null ) { throw new MalformedURIException ( "Cannot initialize path from null string!" ) ; } int index = 0 ; int start = 0 ; int end = p_uriSpec . length ( ) ; char testChar = '\0' ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '?' || testChar == '#' ) { break ; } if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Path contains invalid escape sequence!" ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { throw new MalformedURIException ( "Path contains invalid character: " + testChar ) ; } index ++ ; } m_path = p_uriSpec . substring ( start , index ) ; if ( testChar == '?' ) { index ++ ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '#' ) { break ; } if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Query string contains invalid escape sequence!" ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { throw new MalformedURIException ( "Query string contains invalid character:" + testChar ) ; } index ++ ; } m_queryString = p_uriSpec . substring ( start , index ) ; } if ( testChar == '#' ) { index ++ ; start = index ; while ( index < end ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Fragment contains invalid escape sequence!" ) ; } } else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { throw new MalformedURIException ( "Fragment contains invalid character:" + testChar ) ; } index ++ ; } m_fragment = p_uriSpec . substring ( start , index ) ; } } public String getScheme ( ) { return m_scheme ; } public String getSchemeSpecificPart ( ) { StringBuffer schemespec = new StringBuffer ( ) ; if ( m_userinfo != null || m_host != null || m_port != - 1 ) { schemespec . append ( "//" ) ; } if ( m_userinfo != null ) { schemespec . append ( m_userinfo ) ; schemespec . append ( '@' ) ; } if ( m_host != null ) { schemespec . append ( m_host ) ; } if ( m_port != - 1 ) { schemespec . append ( ':' ) ; schemespec . append ( m_port ) ; } if ( m_path != null ) { schemespec . append ( ( m_path ) ) ; } if ( m_queryString != null ) { schemespec . append ( '?' ) ; schemespec . append ( m_queryString ) ; } if ( m_fragment != null ) { schemespec . append ( '#' ) ; schemespec . append ( m_fragment ) ; } return schemespec . toString ( ) ; } public String getUserinfo ( ) { return m_userinfo ; } public String getHost ( ) { return m_host ; } public int getPort ( ) { return m_port ; } public String getPath ( boolean p_includeQueryString , boolean p_includeFragment ) { StringBuffer pathString = new StringBuffer ( m_path ) ; if ( p_includeQueryString && m_queryString != null ) { pathString . append ( '?' ) ; pathString . append ( m_queryString ) ; } if ( p_includeFragment && m_fragment != null ) { pathString . append ( '#' ) ; pathString . append ( m_fragment ) ; } return pathString . toString ( ) ; } public String getPath ( ) { return m_path ; } public String getQueryString ( ) { return m_queryString ; } public String getFragment ( ) { return m_fragment ; } public void setScheme ( String p_scheme ) throws MalformedURIException { if ( p_scheme == null ) { throw new MalformedURIException ( "Cannot set scheme from null string!" ) ; } if ( ! isConformantSchemeName ( p_scheme ) ) { throw new MalformedURIException ( "The scheme is not conformant." ) ; } m_scheme = p_scheme . toLowerCase ( ) ; } public void setUserinfo ( String p_userinfo ) throws MalformedURIException { if ( p_userinfo == null ) { m_userinfo = null ; } else { if ( m_host == null ) { throw new MalformedURIException ( "Userinfo cannot be set when host is null!" ) ; } int index = 0 ; int end = p_userinfo . length ( ) ; char testChar = '\0' ; while ( index < end ) { testChar = p_userinfo . charAt ( index ) ; if ( testChar == '%' ) { if ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { throw new MalformedURIException ( "Userinfo contains invalid escape sequence!" ) ; } } else if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { throw new MalformedURIException ( "Userinfo contains invalid character:" + testChar ) ; } index ++ ; } } m_userinfo = p_userinfo ; } public void setHost ( String p_host ) throws MalformedURIException { if ( p_host == null || p_host . trim ( ) . length ( ) == 0 ) { m_host = p_host ; m_userinfo = null ; m_port = - 1 ; } else if ( ! isWellFormedAddress ( p_host ) ) { throw new MalformedURIException ( "Host is not a well formed address!" ) ; } m_host = p_host ; } public void setPort ( int p_port ) throws MalformedURIException { if ( p_port >= 0 && p_port <= 65535 ) { if ( m_host == null ) { throw new MalformedURIException ( "Port cannot be set when host is null!" ) ; } } else if ( p_port != - 1 ) { throw new MalformedURIException ( "Invalid port number!" ) ; } m_port = p_port ; } public void setPath ( String p_path ) throws MalformedURIException { if ( p_path == null ) { m_path = null ; m_queryString = null ; m_fragment = null ; } else { initializePath ( p_path ) ; } } public void appendPath ( String p_addToPath ) throws MalformedURIException { if ( p_addToPath == null || p_addToPath . trim ( ) . length ( ) == 0 ) { return ; } if ( ! isURIString ( p_addToPath ) ) { throw new MalformedURIException ( "Path contains invalid character!" ) ; } if ( m_path == null || m_path . trim ( ) . length ( ) == 0 ) { if ( p_addToPath . startsWith ( "/" ) ) { m_path = p_addToPath ; } else { m_path = "/" + p_addToPath ; } } else if ( m_path . endsWith ( "/" ) ) { if ( p_addToPath . startsWith ( "/" ) ) { m_path = m_path . concat ( p_addToPath . substring ( 1 ) ) ; } else { m_path = m_path . concat ( p_addToPath ) ; } } else { if ( p_addToPath . startsWith ( "/" ) ) { m_path = m_path . concat ( p_addToPath ) ; } else { m_path = m_path . concat ( "/" + p_addToPath ) ; } } } public void setQueryString ( String p_queryString ) throws MalformedURIException { if ( p_queryString == null ) { m_queryString = null ; } else if ( ! isGenericURI ( ) ) { throw new MalformedURIException ( "Query string can only be set for a generic URI!" ) ; } else if ( getPath ( ) == null ) { throw new MalformedURIException ( "Query string cannot be set when path is null!" ) ; } else if ( ! isURIString ( p_queryString ) ) { throw new MalformedURIException ( "Query string contains invalid character!" ) ; } else { m_queryString = p_queryString ; } } public void setFragment ( String p_fragment ) throws MalformedURIException { if ( p_fragment == null ) { m_fragment = null ; } else if ( ! isGenericURI ( ) ) { throw new MalformedURIException ( "Fragment can only be set for a generic URI!" ) ; } else if ( getPath ( ) == null ) { throw new MalformedURIException ( "Fragment cannot be set when path is null!" ) ; } else if ( ! isURIString ( p_fragment ) ) { throw new MalformedURIException ( "Fragment contains invalid character!" ) ; } else { m_fragment = p_fragment ; } } public boolean equals ( Object p_test ) { if ( p_test instanceof URI ) { URI testURI = ( URI ) p_test ; if ( ( ( m_scheme == null && testURI . m_scheme == null ) || ( m_scheme != null && testURI . m_scheme != null && m_scheme . equals ( testURI . m_scheme ) ) ) && ( ( m_userinfo == null && testURI . m_userinfo == null ) || ( m_userinfo != null && testURI . m_userinfo != null && m_userinfo . equals ( testURI . m_userinfo ) ) ) && ( ( m_host == null && testURI . m_host == null ) || ( m_host != null && testURI . m_host != null && m_host . equals ( testURI . m_host ) ) ) && m_port == testURI . m_port && ( ( m_path == null && testURI . m_path == null ) || ( m_path != null && testURI . m_path != null && m_path . equals ( testURI . m_path ) ) ) && ( ( m_queryString == null && testURI . m_queryString == null ) || ( m_queryString != null && testURI . m_queryString != null && m_queryString . equals ( testURI . m_queryString ) ) ) && ( ( m_fragment == null && testURI . m_fragment == null ) || ( m_fragment != null && testURI . m_fragment != null && m_fragment . equals ( testURI . m_fragment ) ) ) ) { return true ; } } return false ; } public String toString ( ) { StringBuffer uriSpecString = new StringBuffer ( ) ; if ( m_scheme != null ) { uriSpecString . append ( m_scheme ) ; uriSpecString . append ( ':' ) ; } uriSpecString . append ( getSchemeSpecificPart ( ) ) ; return uriSpecString . toString ( ) ; } public boolean isGenericURI ( ) { return ( m_host != null ) ; } public static boolean isConformantSchemeName ( String p_scheme ) { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { return false ; } if ( ! isAlpha ( p_scheme . charAt ( 0 ) ) ) { return false ; } char testChar ; for ( int i = 1 ; i < p_scheme . length ( ) ; i ++ ) { testChar = p_scheme . charAt ( i ) ; if ( ! isAlphanum ( testChar ) && SCHEME_CHARACTERS . indexOf ( testChar ) == - 1 ) { return false ; } } return true ; } public static boolean isWellFormedAddress ( String p_address ) { if ( p_address == null ) { return false ; } String address = p_address . trim ( ) ; int addrLength = address . length ( ) ; if ( addrLength == 0 || addrLength > 255 ) { return false ; } if ( address . startsWith ( "." ) || address . startsWith ( "-" ) ) { return false ; } int index = address . lastIndexOf ( '.' ) ; if ( address . endsWith ( "." ) ) { index = address . substring ( 0 , index ) . lastIndexOf ( '.' ) ; } if ( index + 1 < addrLength && isDigit ( p_address . charAt ( index + 1 ) ) ) { char testChar ; int numDots = 0 ; for ( int i = 0 ; i < addrLength ; i ++ ) { testChar = address . charAt ( i ) ; if ( testChar == '.' ) { if ( ! isDigit ( address . charAt ( i - 1 ) ) || ( i + 1 < addrLength && ! isDigit ( address . charAt ( i + 1 ) ) ) ) { return false ; } numDots ++ ; } else if ( ! isDigit ( testChar ) ) { return false ; } } if ( numDots != 3 ) { return false ; } } else { char testChar ; for ( int i = 0 ; i < addrLength ; i ++ ) { testChar = address . charAt ( i ) ; if ( testChar == '.' ) { if ( ! isAlphanum ( address . charAt ( i - 1 ) ) ) { return false ; } if ( i + 1 < addrLength && ! isAlphanum ( address . charAt ( i + 1 ) ) ) { return false ; } } else if ( ! isAlphanum ( testChar ) && testChar != '-' ) { return false ; } } } return true ; } private static boolean isDigit ( char p_char ) { return p_char >= '0' && p_char <= '9' ; } private static boolean isHex ( char p_char ) { return ( isDigit ( p_char ) || ( p_char >= 'a' && p_char <= 'f' ) || ( p_char >= 'A' && p_char <= 'F' ) ) ; } private static boolean isAlpha ( char p_char ) { return ( ( p_char >= 'a' && p_char <= 'z' ) || ( p_char >= 'A' && p_char <= 'Z' ) ) ; } private static boolean isAlphanum ( char p_char ) { return ( isAlpha ( p_char ) || isDigit ( p_char ) ) ; } private static boolean isReservedCharacter ( char p_char ) { return RESERVED_CHARACTERS . indexOf ( p_char ) != - 1 ; } private static boolean isUnreservedCharacter ( char p_char ) { return ( isAlphanum ( p_char ) || MARK_CHARACTERS . indexOf ( p_char ) != - 1 ) ; } private static boolean isURIString ( String p_uric ) { if ( p_uric == null ) { return false ; } int end = p_uric . length ( ) ; char testChar = '\0' ; for ( int i = 0 ; i < end ; i ++ ) { testChar = p_uric . charAt ( i ) ; if ( testChar == '%' ) { if ( i + 2 >= end || ! isHex ( p_uric . charAt ( i + 1 ) ) || ! isHex ( p_uric . charAt ( i + 2 ) ) ) { return false ; } else { i += 2 ; continue ; } } if ( isReservedCharacter ( testChar ) || isUnreservedCharacter ( testChar ) ) { continue ; } else { return false ; } } return true ; } } 	0
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . validators . schema . EquivClassComparator ; public class DFAContentModel implements XMLContentModel { private static final int EPSILON = - 2 ; private static final int EOC = - 3 ; private static final boolean DEBUG_VALIDATE_CONTENT = false ; private EquivClassComparator comparator = null ; private QName fElemMap [ ] = null ; private int fElemMapType [ ] = null ; private int fElemMapSize = 0 ; private boolean fDTD ; private int fEOCIndex = 0 ; private int fEOCPos = 0 ; private int fEpsilonIndex = 0 ; private boolean fFinalStateFlags [ ] = null ; private CMStateSet fFollowList [ ] = null ; private CMNode fHeadNode = null ; private int fLeafCount = 0 ; private CMLeaf fLeafList [ ] = null ; private int fLeafListType [ ] = null ; private ContentLeafNameTypeVector fLeafNameTypeVector = null ; private int fTransTable [ ] [ ] = null ; private int fTransTableSize = 0 ; private boolean fEmptyContentIsValid = false ; private QName fQName = new QName ( ) ; public DFAContentModel ( CMNode syntaxTree , int leafCount ) throws CMException { this ( syntaxTree , leafCount , false ) ; } public DFAContentModel ( CMNode syntaxTree , int leafCount , boolean dtd ) throws CMException { fLeafCount = leafCount ; fEpsilonIndex = EPSILON ; fEOCIndex = EOC ; fDTD = dtd ; buildDFA ( syntaxTree ) ; } public int validateContent ( QName children [ ] , int offset , int length ) throws CMException { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "DFAContentModel#validateContent" ) ; if ( length == 0 ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! no children" ) ; System . out . println ( "elemMap=" + fElemMap ) ; for ( int i = 0 ; i < fElemMap . length ; i ++ ) { int uriIndex = fElemMap [ i ] . uri ; int localpartIndex = fElemMap [ i ] . localpart ; } System . out . println ( "EOCIndex=" + fEOCIndex ) ; } return fEmptyContentIsValid ? - 1 : 0 ; } int curState = 0 ; for ( int childIndex = 0 ; childIndex < length ; childIndex ++ ) { final QName curElem = children [ offset + childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { int type = fElemMapType [ elemIndex ] & 0x0f ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fDTD ) { if ( fElemMap [ elemIndex ] . rawname == curElem . rawname ) { break ; } } else { if ( fElemMap [ elemIndex ] . uri == curElem . uri && fElemMap [ elemIndex ] . localpart == curElem . localpart ) break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ elemIndex ] . uri ; if ( uri == - 1 || uri == curElem . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( curElem . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ elemIndex ] . uri != curElem . uri ) { break ; } } } if ( elemIndex == fElemMapSize ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! didn't find it" ) ; System . out . println ( "curElem : " + curElem ) ; for ( int i = 0 ; i < fElemMapSize ; i ++ ) { System . out . println ( "fElemMap[" + i + "] = " + fElemMap [ i ] ) ; System . out . println ( "fElemMapType[" + i + "] = " + fElemMapType [ i ] ) ; } } return childIndex ; } curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "!!! not a legal transition" ) ; return childIndex ; } } if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "curState=" + curState + ", childCount=" + length ) ; if ( ! fFinalStateFlags [ curState ] ) return length ; return - 1 ; } private boolean isEqual ( QName name1 , QName name2 ) { return name1 . localpart == name2 . localpart && name1 . uri == name2 . uri ; } public int validateContentSpecial ( QName children [ ] , int offset , int length ) throws Exception { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "DFAContentModel#validateContentSpecial" ) ; if ( comparator == null ) { return validateContent ( children , offset , length ) ; } if ( length == 0 ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! no children" ) ; System . out . println ( "elemMap=" + fElemMap ) ; for ( int i = 0 ; i < fElemMap . length ; i ++ ) { int uriIndex = fElemMap [ i ] . uri ; int localpartIndex = fElemMap [ i ] . localpart ; } System . out . println ( "EOCIndex=" + fEOCIndex ) ; } return fEmptyContentIsValid ? - 1 : 0 ; } int curState = 0 ; for ( int childIndex = 0 ; childIndex < length ; childIndex ++ ) { final QName curElem = children [ offset + childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { int type = fElemMapType [ elemIndex ] & 0x0f ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( comparator . isEquivalentTo ( curElem , fElemMap [ elemIndex ] ) ) break ; } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ elemIndex ] . uri ; if ( uri == - 1 || uri == curElem . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( curElem . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ elemIndex ] . uri != curElem . uri ) { break ; } } } if ( elemIndex == fElemMapSize ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! didn't find it" ) ; System . out . println ( "curElem : " + curElem ) ; for ( int i = 0 ; i < fElemMapSize ; i ++ ) { System . out . println ( "fElemMap[" + i + "] = " + fElemMap [ i ] ) ; System . out . println ( "fElemMapType[" + i + "] = " + fElemMapType [ i ] ) ; } } return childIndex ; } curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "!!! not a legal transition" ) ; return childIndex ; } } if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "curState=" + curState + ", childCount=" + length ) ; if ( ! fFinalStateFlags [ curState ] ) return length ; return - 1 ; } public void setEquivClassComparator ( EquivClassComparator comparator ) { this . comparator = comparator ; } public int whatCanGoHere ( boolean fullyValid , InsertableElementsInfo info ) throws CMException { int curState = 0 ; for ( int childIndex = 0 ; childIndex < info . insertAt ; childIndex ++ ) { final QName curElem = info . curChildren [ childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { if ( fElemMap [ elemIndex ] . uri == curElem . uri && fElemMap [ elemIndex ] . localpart == curElem . localpart ) break ; } if ( elemIndex == fElemMapSize ) return childIndex ; curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) return childIndex ; } final int insertState = curState ; info . canHoldPCData = false ; info . isValidEOC = fFinalStateFlags [ insertState ] ; info . resultsCount = fElemMapSize ; if ( ( info . results == null ) || ( info . results . length < info . resultsCount ) ) info . results = new boolean [ info . resultsCount ] ; if ( ( info . possibleChildren == null ) || ( info . possibleChildren . length < info . resultsCount ) ) { info . possibleChildren = new QName [ info . resultsCount ] ; for ( int i = 0 ; i < info . possibleChildren . length ; i ++ ) { info . possibleChildren [ i ] = new QName ( ) ; } } for ( int index = 0 ; index < fElemMapSize ; index ++ ) { info . possibleChildren [ index ] . setValues ( fElemMap [ index ] ) ; info . results [ index ] = ( fTransTable [ insertState ] [ index ] != - 1 ) ; } if ( fullyValid ) { for ( int index = 0 ; index < info . resultsCount ; index ++ ) { if ( ! info . results [ index ] ) continue ; info . curChildren [ info . insertAt ] = info . possibleChildren [ index ] ; if ( validateContent ( info . curChildren , 0 , info . childCount ) != - 1 ) info . results [ index ] = false ; } } return - 1 ; } public ContentLeafNameTypeVector getContentLeafNameTypeVector ( ) { return fLeafNameTypeVector ; } private void buildDFA ( CMNode syntaxTree ) throws CMException { fQName . setValues ( - 1 , fEOCIndex , fEOCIndex ) ; CMLeaf nodeEOC = new CMLeaf ( fQName ) ; fHeadNode = new CMBinOp ( XMLContentSpec . CONTENTSPECNODE_SEQ , syntaxTree , nodeEOC ) ; fEOCPos = fLeafCount ; nodeEOC . setPosition ( fLeafCount ++ ) ; fLeafList = new CMLeaf [ fLeafCount ] ; fLeafListType = new int [ fLeafCount ] ; postTreeBuildInit ( fHeadNode , 0 ) ; fFollowList = new CMStateSet [ fLeafCount ] ; for ( int index = 0 ; index < fLeafCount ; index ++ ) fFollowList [ index ] = new CMStateSet ( fLeafCount ) ; calcFollowList ( fHeadNode ) ; fElemMap = new QName [ fLeafCount ] ; fElemMapType = new int [ fLeafCount ] ; fElemMapSize = 0 ; for ( int outIndex = 0 ; outIndex < fLeafCount ; outIndex ++ ) { fElemMap [ outIndex ] = new QName ( ) ; if ( ( fLeafListType [ outIndex ] & 0x0f ) != 0 ) { if ( fLeafNameTypeVector == null ) { fLeafNameTypeVector = new ContentLeafNameTypeVector ( ) ; } } final QName element = fLeafList [ outIndex ] . getElement ( ) ; int inIndex = 0 ; for ( ; inIndex < fElemMapSize ; inIndex ++ ) { if ( fDTD ) { if ( fElemMap [ inIndex ] . rawname == element . rawname ) { break ; } } else { if ( fElemMap [ inIndex ] . uri == element . uri && fElemMap [ inIndex ] . localpart == element . localpart && fElemMapType [ inIndex ] == fLeafListType [ outIndex ] ) break ; } } if ( inIndex == fElemMapSize ) { fElemMap [ fElemMapSize ] . setValues ( element ) ; fElemMapType [ fElemMapSize ] = fLeafListType [ outIndex ] ; fElemMapSize ++ ; } } if ( fLeafNameTypeVector != null ) { fLeafNameTypeVector . setValues ( fElemMap , fElemMapType , fElemMapSize ) ; } int curArraySize = fLeafCount * 4 ; CMStateSet [ ] statesToDo = new CMStateSet [ curArraySize ] ; fFinalStateFlags = new boolean [ curArraySize ] ; fTransTable = new int [ curArraySize ] [ ] ; CMStateSet setT = fHeadNode . firstPos ( ) ; int unmarkedState = 0 ; int curState = 0 ; fTransTable [ curState ] = makeDefStateList ( ) ; statesToDo [ curState ] = setT ; curState ++ ; while ( unmarkedState < curState ) { setT = statesToDo [ unmarkedState ] ; int [ ] transEntry = fTransTable [ unmarkedState ] ; fFinalStateFlags [ unmarkedState ] = setT . getBit ( fEOCPos ) ; unmarkedState ++ ; CMStateSet newSet = null ; for ( int elemIndex = 0 ; elemIndex < fElemMapSize ; elemIndex ++ ) { if ( newSet == null ) newSet = new CMStateSet ( fLeafCount ) ; else newSet . zeroBits ( ) ; for ( int leafIndex = 0 ; leafIndex < fLeafCount ; leafIndex ++ ) { if ( setT . getBit ( leafIndex ) ) { final QName leaf = fLeafList [ leafIndex ] . getElement ( ) ; final QName element = fElemMap [ elemIndex ] ; if ( fDTD ) { if ( leaf . rawname == element . rawname ) { newSet . union ( fFollowList [ leafIndex ] ) ; } } else { if ( leaf . uri == element . uri && leaf . localpart == element . localpart ) newSet . union ( fFollowList [ leafIndex ] ) ; } } } if ( ! newSet . isEmpty ( ) ) { int stateIndex = 0 ; for ( ; stateIndex < curState ; stateIndex ++ ) { if ( statesToDo [ stateIndex ] . isSameSet ( newSet ) ) break ; } if ( stateIndex == curState ) { statesToDo [ curState ] = newSet ; fTransTable [ curState ] = makeDefStateList ( ) ; curState ++ ; newSet = null ; } transEntry [ elemIndex ] = stateIndex ; if ( curState == curArraySize ) { final int newSize = ( int ) ( curArraySize * 1.5 ) ; CMStateSet [ ] newToDo = new CMStateSet [ newSize ] ; boolean [ ] newFinalFlags = new boolean [ newSize ] ; int [ ] [ ] newTransTable = new int [ newSize ] [ ] ; for ( int expIndex = 0 ; expIndex < curArraySize ; expIndex ++ ) { newToDo [ expIndex ] = statesToDo [ expIndex ] ; newFinalFlags [ expIndex ] = fFinalStateFlags [ expIndex ] ; newTransTable [ expIndex ] = fTransTable [ expIndex ] ; } curArraySize = newSize ; statesToDo = newToDo ; fFinalStateFlags = newFinalFlags ; fTransTable = newTransTable ; } } } } fEmptyContentIsValid = ( ( CMBinOp ) fHeadNode ) . getLeft ( ) . isNullable ( ) ; if ( DEBUG_VALIDATE_CONTENT ) dumpTree ( fHeadNode , 0 ) ; fHeadNode = null ; fLeafList = null ; fFollowList = null ; } private void calcFollowList ( CMNode nodeCur ) throws CMException { if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) { calcFollowList ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( CMBinOp ) nodeCur ) . getRight ( ) ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) { calcFollowList ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( CMBinOp ) nodeCur ) . getRight ( ) ) ; final CMStateSet last = ( ( CMBinOp ) nodeCur ) . getLeft ( ) . lastPos ( ) ; final CMStateSet first = ( ( CMBinOp ) nodeCur ) . getRight ( ) . firstPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { calcFollowList ( ( ( CMUniOp ) nodeCur ) . getChild ( ) ) ; final CMStateSet first = nodeCur . firstPos ( ) ; final CMStateSet last = nodeCur . lastPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) || ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) ) { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } } private void dumpTree ( CMNode nodeCur , int level ) throws CMException { for ( int index = 0 ; index < level ; index ++ ) System . out . print ( "   " ) ; int type = nodeCur . type ( ) ; if ( ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( type == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { if ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) System . out . print ( "Choice Node " ) ; else System . out . print ( "Seq Node " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( "Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; dumpTree ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) , level + 1 ) ; dumpTree ( ( ( CMBinOp ) nodeCur ) . getRight ( ) , level + 1 ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { System . out . print ( "Rep Node " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( "Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; dumpTree ( ( ( CMUniOp ) nodeCur ) . getChild ( ) , level + 1 ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { System . out . print ( "Leaf: (pos=" + ( ( CMLeaf ) nodeCur ) . getPosition ( ) + "), " + ( ( CMLeaf ) nodeCur ) . getElement ( ) + "(elemIndex=" + ( ( CMLeaf ) nodeCur ) . getElement ( ) + ") " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( " Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; } else { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } } private int [ ] makeDefStateList ( ) { int [ ] retArray = new int [ fElemMapSize ] ; for ( int index = 0 ; index < fElemMapSize ; index ++ ) retArray [ index ] = - 1 ; return retArray ; } private int postTreeBuildInit ( CMNode nodeCur , int curIndex ) throws CMException { nodeCur . setMaxStates ( fLeafCount ) ; if ( ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY || ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL || ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { QName qname = new QName ( - 1 , - 1 , - 1 , ( ( CMAny ) nodeCur ) . getURI ( ) ) ; fLeafList [ curIndex ] = new CMLeaf ( qname , ( ( CMAny ) nodeCur ) . getPosition ( ) ) ; fLeafListType [ curIndex ] = nodeCur . type ( ) ; curIndex ++ ; } else if ( ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { curIndex = postTreeBuildInit ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) , curIndex ) ; curIndex = postTreeBuildInit ( ( ( CMBinOp ) nodeCur ) . getRight ( ) , curIndex ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { curIndex = postTreeBuildInit ( ( ( CMUniOp ) nodeCur ) . getChild ( ) , curIndex ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { final QName node = ( ( CMLeaf ) nodeCur ) . getElement ( ) ; if ( node . localpart != fEpsilonIndex ) { fLeafList [ curIndex ] = ( CMLeaf ) nodeCur ; fLeafListType [ curIndex ] = XMLContentSpec . CONTENTSPECNODE_LEAF ; curIndex ++ ; } } else { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } return curIndex ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLOptGroupElementImpl extends HTMLElementImpl implements HTMLOptGroupElement { public boolean getDisabled ( ) { return getBinary ( "disabled" ) ; } public void setDisabled ( boolean disabled ) { setAttribute ( "disabled" , disabled ) ; } public String getLabel ( ) { return capitalize ( getAttribute ( "label" ) ) ; } public void setLabel ( String label ) { setAttribute ( "label" , label ) ; } public HTMLOptGroupElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLDocumentScanner ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . readers . DefaultEntityHandler ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . ChunkyCharArray ; import org . apache . xerces . utils . Hash2intTable ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . parsers . DOMParser ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . InputSource ; import org . xml . sax . EntityResolver ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xerces . validators . dtd . DTDGrammar ; import org . apache . xerces . validators . schema . EquivClassComparator ; import org . apache . xerces . validators . schema . SchemaGrammar ; import org . apache . xerces . validators . schema . SchemaMessageProvider ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . schema . TraverseSchema ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . validators . datatype . StateMessageDatatype ; import org . apache . xerces . validators . datatype . IDREFDatatypeValidator ; import org . apache . xerces . validators . datatype . IDDatatypeValidator ; import org . apache . xerces . validators . datatype . ENTITYDatatypeValidator ; public final class XMLValidator implements DefaultEntityHandler . EventHandler , XMLEntityHandler . CharDataHandler , XMLDocumentScanner . EventHandler , NamespacesScope . NamespacesHandler { private static final boolean PRINT_EXCEPTION_STACK_TRACE = false ; private static final boolean DEBUG_PRINT_ATTRIBUTES = false ; private static final boolean DEBUG_PRINT_CONTENT = false ; private static final boolean DEBUG_SCHEMA_VALIDATION = false ; private static final boolean DEBUG_ELEMENT_CHILDREN = false ; private static final int CHUNK_SHIFT = 8 ; private static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; private static final int CHUNK_MASK = CHUNK_SIZE - 1 ; private static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; private Hashtable fIdDefs = null ; private StateMessageDatatype fStoreIDRef = new StateMessageDatatype ( ) { private Hashtable fIdDefs ; public Object getDatatypeObject ( ) { return ( Object ) fIdDefs ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_STORE ; } public void setDatatypeObject ( Object data ) { fIdDefs = ( Hashtable ) data ; } } ; private StateMessageDatatype fResetID = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDDatatypeValidator . ID_CLEAR ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fResetIDRef = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_CLEAR ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fValidateIDRef = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_VALIDATE ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fValidateENTITYMsg = new StateMessageDatatype ( ) { private Object packagedMessage = null ; public Object getDatatypeObject ( ) { return packagedMessage ; } public int getDatatypeState ( ) { return ENTITYDatatypeValidator . ENTITY_INITIALIZE ; } public void setDatatypeObject ( Object data ) { packagedMessage = data ; } } ; private AttributeValidator fAttValidatorNOTATION = new AttValidatorNOTATION ( ) ; private AttributeValidator fAttValidatorENUMERATION = new AttValidatorENUMERATION ( ) ; private AttributeValidator fAttValidatorDATATYPE = null ; StringPool fStringPool = null ; boolean fValidating = false ; boolean fInElementContent = false ; int fStandaloneReader = - 1 ; private boolean fValidationEnabled = false ; private boolean fDynamicValidation = false ; private boolean fSchemaValidation = true ; private boolean fValidationEnabledByDynamic = false ; private boolean fDynamicDisabledByValidation = false ; private boolean fWarningOnDuplicateAttDef = false ; private boolean fWarningOnUndeclaredElements = false ; private boolean fLoadDTDGrammar = true ; private int fDeclaration [ ] ; private XMLErrorReporter fErrorReporter = null ; private DefaultEntityHandler fEntityHandler = null ; private QName fCurrentElement = new QName ( ) ; private ContentLeafNameTypeVector [ ] fContentLeafStack = new ContentLeafNameTypeVector [ 8 ] ; private int [ ] fValidationFlagStack = new int [ 8 ] ; private int [ ] fScopeStack = new int [ 8 ] ; private int [ ] fGrammarNameSpaceIndexStack = new int [ 8 ] ; private int [ ] fElementEntityStack = new int [ 8 ] ; private int [ ] fElementIndexStack = new int [ 8 ] ; private int [ ] fContentSpecTypeStack = new int [ 8 ] ; private static final int sizeQNameParts = 8 ; private QName [ ] fElementQNamePartsStack = new QName [ sizeQNameParts ] ; private QName [ ] fElementChildren = new QName [ 32 ] ; private int fElementChildrenLength = 0 ; private int [ ] fElementChildrenOffsetStack = new int [ 32 ] ; private int fElementDepth = - 1 ; private boolean fNamespacesEnabled = false ; private NamespacesScope fNamespacesScope = null ; private int fNamespacesPrefix = - 1 ; private QName fRootElement = new QName ( ) ; private int fAttrListHandle = - 1 ; private int fCurrentElementEntity = - 1 ; private int fCurrentElementIndex = - 1 ; private int fCurrentContentSpecType = - 1 ; private boolean fSeenDoctypeDecl = false ; private final int TOP_LEVEL_SCOPE = - 1 ; private int fCurrentScope = TOP_LEVEL_SCOPE ; private int fCurrentSchemaURI = - 1 ; private int fEmptyURI = - 1 ; private int fXsiPrefix = - 1 ; private int fXsiURI = - 2 ; private int fXsiTypeAttValue = - 1 ; private DatatypeValidator fXsiTypeValidator = null ; private Grammar fGrammar = null ; private int fGrammarNameSpaceIndex = - 1 ; private GrammarResolver fGrammarResolver = null ; private boolean fScanningDTD = false ; private XMLDocumentScanner fDocumentScanner = null ; private boolean fCalledStartDocument = false ; private XMLDocumentHandler fDocumentHandler = null ; private XMLDocumentHandler . DTDHandler fDTDHandler = null ; private boolean fSeenRootElement = false ; private XMLAttrList fAttrList = null ; private int fXMLLang = - 1 ; private LocatorImpl fAttrNameLocator = null ; private boolean fCheckedForSchema = false ; private boolean fDeclsAreExternal = false ; private StringPool . CharArrayRange fCurrentElementCharArrayRange = null ; private char [ ] fCharRefData = null ; private boolean fSendCharDataAsCharArray = false ; private boolean fBufferDatatype = false ; private StringBuffer fDatatypeBuffer = new StringBuffer ( ) ; private QName fTempQName = new QName ( ) ; private XMLAttributeDecl fTempAttDecl = new XMLAttributeDecl ( ) ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; private boolean fGrammarIsDTDGrammar = false ; private boolean fGrammarIsSchemaGrammar = false ; private boolean fNeedValidationOff = false ; private int fEMPTYSymbol = - 1 ; private int fANYSymbol = - 1 ; private int fMIXEDSymbol = - 1 ; private int fCHILDRENSymbol = - 1 ; private int fCDATASymbol = - 1 ; private int fIDSymbol = - 1 ; private int fIDREFSymbol = - 1 ; private int fIDREFSSymbol = - 1 ; private int fENTITYSymbol = - 1 ; private int fENTITIESSymbol = - 1 ; private int fNMTOKENSymbol = - 1 ; private int fNMTOKENSSymbol = - 1 ; private int fNOTATIONSymbol = - 1 ; private int fENUMERATIONSymbol = - 1 ; private int fREQUIREDSymbol = - 1 ; private int fFIXEDSymbol = - 1 ; private int fDATATYPESymbol = - 1 ; private int fEpsilonIndex = - 1 ; private DatatypeValidatorFactoryImpl fDataTypeReg = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; private DatatypeValidator fValID = this . fDataTypeReg . getDatatypeValidator ( "ID" ) ; private DatatypeValidator fValIDRef = this . fDataTypeReg . getDatatypeValidator ( "IDREF" ) ; private DatatypeValidator fValIDRefs = this . fDataTypeReg . getDatatypeValidator ( "IDREFS" ) ; private DatatypeValidator fValENTITY = this . fDataTypeReg . getDatatypeValidator ( "ENTITY" ) ; private DatatypeValidator fValENTITIES = this . fDataTypeReg . getDatatypeValidator ( "ENTITIES" ) ; private DatatypeValidator fValNMTOKEN = this . fDataTypeReg . getDatatypeValidator ( "NMTOKEN" ) ; private DatatypeValidator fValNMTOKENS = this . fDataTypeReg . getDatatypeValidator ( "NMTOKENS" ) ; private DatatypeValidator fValNOTATION = this . fDataTypeReg . getDatatypeValidator ( "NOTATION" ) ; public XMLValidator ( StringPool stringPool , XMLErrorReporter errorReporter , DefaultEntityHandler entityHandler , XMLDocumentScanner documentScanner ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fEntityHandler = entityHandler ; fDocumentScanner = documentScanner ; fEmptyURI = fStringPool . addSymbol ( "" ) ; fXsiURI = fStringPool . addSymbol ( SchemaSymbols . URI_XSI ) ; fAttrList = new XMLAttrList ( fStringPool ) ; entityHandler . setEventHandler ( this ) ; entityHandler . setCharDataHandler ( this ) ; fDocumentScanner . setEventHandler ( this ) ; for ( int i = 0 ; i < sizeQNameParts ; i ++ ) { fElementQNamePartsStack [ i ] = new QName ( ) ; } init ( ) ; } public void setGrammarResolver ( GrammarResolver grammarResolver ) { fGrammarResolver = grammarResolver ; } public void initHandlers ( boolean sendCharDataAsCharArray , XMLDocumentHandler docHandler , XMLDocumentHandler . DTDHandler dtdHandler ) { fSendCharDataAsCharArray = sendCharDataAsCharArray ; fEntityHandler . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; fDocumentHandler = docHandler ; fDTDHandler = dtdHandler ; } public void resetOrCopy ( StringPool stringPool ) throws Exception { fAttrList = new XMLAttrList ( stringPool ) ; resetCommon ( stringPool ) ; } public void reset ( StringPool stringPool ) throws Exception { fAttrList . reset ( stringPool ) ; resetCommon ( stringPool ) ; } public void setValidationEnabled ( boolean flag ) throws Exception { fValidationEnabled = flag ; fValidationEnabledByDynamic = false ; if ( fValidationEnabled ) { if ( fDynamicDisabledByValidation ) { fDynamicValidation = true ; fDynamicDisabledByValidation = false ; } } else if ( fDynamicValidation ) { fDynamicValidation = false ; fDynamicDisabledByValidation = true ; } fValidating = fValidationEnabled ; } public boolean getValidationEnabled ( ) { return fValidationEnabled ; } public void setSchemaValidationEnabled ( boolean flag ) { fSchemaValidation = flag ; } public boolean getSchemaValidationEnabled ( ) { return fSchemaValidation ; } public void setDynamicValidationEnabled ( boolean flag ) throws Exception { fDynamicValidation = flag ; fDynamicDisabledByValidation = false ; if ( ! fDynamicValidation ) { if ( fValidationEnabledByDynamic ) { fValidationEnabled = false ; fValidationEnabledByDynamic = false ; } } else if ( ! fValidationEnabled ) { fValidationEnabled = true ; fValidationEnabledByDynamic = true ; } fValidating = fValidationEnabled ; } public boolean getDynamicValidationEnabled ( ) { return fDynamicValidation ; } public void setLoadDTDGrammar ( boolean loadDG ) { if ( fValidating ) { fLoadDTDGrammar = true ; } else { fLoadDTDGrammar = loadDG ; } } public boolean getLoadDTDGrammar ( ) { return fLoadDTDGrammar ; } public void setNamespacesEnabled ( boolean flag ) { fNamespacesEnabled = flag ; } public boolean getNamespacesEnabled ( ) { return fNamespacesEnabled ; } public void setWarningOnDuplicateAttDef ( boolean flag ) { fWarningOnDuplicateAttDef = flag ; } public boolean getWarningOnDuplicateAttDef ( ) { return fWarningOnDuplicateAttDef ; } public void setWarningOnUndeclaredElements ( boolean flag ) { fWarningOnUndeclaredElements = flag ; } public boolean getWarningOnUndeclaredElements ( ) { return fWarningOnUndeclaredElements ; } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { fDocumentHandler . startEntityReference ( entityName , entityType , entityContext ) ; } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { fDocumentHandler . endEntityReference ( entityName , entityType , entityContext ) ; } public void sendEndOfInputNotifications ( int entityName , boolean moreToFollow ) throws Exception { fDocumentScanner . endOfInput ( entityName , moreToFollow ) ; } public void sendReaderChangeNotifications ( XMLEntityHandler . EntityReader reader , int readerId ) throws Exception { fDocumentScanner . readerChange ( reader , readerId ) ; } public boolean externalEntityStandaloneCheck ( ) { return ( fStandaloneReader != - 1 && fValidating ) ; } public boolean getValidating ( ) { return fValidating ; } public void processCharacters ( char [ ] chars , int offset , int length ) throws Exception { if ( fValidating ) { if ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } if ( fBufferDatatype ) { fDatatypeBuffer . append ( chars , offset , length ) ; } } fDocumentHandler . characters ( chars , offset , length ) ; } public void processCharacters ( int data ) throws Exception { if ( fValidating ) { if ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } if ( fBufferDatatype ) { fDatatypeBuffer . append ( fStringPool . toString ( data ) ) ; } } fDocumentHandler . characters ( data ) ; } public void processWhitespace ( char [ ] chars , int offset , int length ) throws Exception { if ( fInElementContent ) { if ( fStandaloneReader != - 1 && fValidating && getElementDeclIsExternal ( fCurrentElementIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION ) ; } fDocumentHandler . ignorableWhitespace ( chars , offset , length ) ; } else { if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } fDocumentHandler . characters ( chars , offset , length ) ; } } public void processWhitespace ( int data ) throws Exception { if ( fInElementContent ) { if ( fStandaloneReader != - 1 && fValidating && getElementDeclIsExternal ( fCurrentElementIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION ) ; } fDocumentHandler . ignorableWhitespace ( data ) ; } else { if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } fDocumentHandler . characters ( data ) ; } } public void scanElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( ! fNamespacesEnabled ) { element . clear ( ) ; element . localpart = entityReader . scanName ( fastchar ) ; element . rawname = element . localpart ; } else { entityReader . scanQName ( fastchar , element ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } public boolean scanExpectedElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( fCurrentElementCharArrayRange == null ) { fCurrentElementCharArrayRange = fStringPool . createCharArrayRange ( ) ; } fStringPool . getCharArrayRange ( fCurrentElement . rawname , fCurrentElementCharArrayRange ) ; return entityReader . scanExpectedName ( fastchar , fCurrentElementCharArrayRange ) ; } public void scanAttributeName ( XMLEntityHandler . EntityReader entityReader , QName element , QName attribute ) throws Exception { if ( ! fSeenRootElement ) { fSeenRootElement = true ; rootElementSpecified ( element ) ; fStringPool . resetShuffleCount ( ) ; } if ( ! fNamespacesEnabled ) { attribute . clear ( ) ; attribute . localpart = entityReader . scanName ( '=' ) ; attribute . rawname = attribute . localpart ; } else { entityReader . scanQName ( '=' , attribute ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } public void callStartDocument ( ) throws Exception { if ( ! fCalledStartDocument ) { fDocumentHandler . startDocument ( ) ; fCalledStartDocument = true ; } } public void callEndDocument ( ) throws Exception { if ( fCalledStartDocument ) { fDocumentHandler . endDocument ( ) ; } } public void callXMLDecl ( int version , int encoding , int standalone ) throws Exception { fDocumentHandler . xmlDecl ( version , encoding , standalone ) ; } public void callStandaloneIsYes ( ) throws Exception { fStandaloneReader = fEntityHandler . getReaderId ( ) ; } public void callTextDecl ( int version , int encoding ) throws Exception { fDocumentHandler . textDecl ( version , encoding ) ; } public void element ( QName element ) throws Exception { fAttrListHandle = - 1 ; } public boolean attribute ( QName element , QName attrName , int attrValue ) throws Exception { if ( fAttrListHandle == - 1 ) { fAttrListHandle = fAttrList . startAttrList ( ) ; } return fAttrList . addAttr ( attrName , attrValue , fCDATASymbol , true , true ) == - 1 ; } public void callStartElement ( QName element ) throws Exception { if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "\n=======StartElement : " + fStringPool . toString ( element . localpart ) ) ; if ( ! fSeenRootElement ) { fSeenRootElement = true ; rootElementSpecified ( element ) ; fStringPool . resetShuffleCount ( ) ; } if ( fGrammar != null && fGrammarIsDTDGrammar ) { fAttrListHandle = addDTDDefaultAttributes ( element , fAttrList , fAttrListHandle , fValidating , fStandaloneReader != - 1 ) ; } fCheckedForSchema = true ; if ( fNamespacesEnabled ) { bindNamespacesToElementAndAttributes ( element , fAttrList ) ; } validateElementAndAttributes ( element , fAttrList ) ; if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; } fDocumentHandler . startElement ( element , fAttrList , fAttrListHandle ) ; fAttrListHandle = - 1 ; fElementDepth ++ ; if ( fValidating ) { if ( fElementChildrenOffsetStack . length < fElementDepth ) { int newarray [ ] = new int [ fElementChildrenOffsetStack . length * 2 ] ; System . arraycopy ( fElementChildrenOffsetStack , 0 , newarray , 0 , fElementChildrenOffsetStack . length ) ; fElementChildrenOffsetStack = newarray ; } fElementChildrenOffsetStack [ fElementDepth ] = fElementChildrenLength ; if ( fElementChildren . length <= fElementChildrenLength ) { QName [ ] newarray = new QName [ fElementChildrenLength * 2 ] ; System . arraycopy ( fElementChildren , 0 , newarray , 0 , fElementChildren . length ) ; fElementChildren = newarray ; } QName qname = fElementChildren [ fElementChildrenLength ] ; if ( qname == null ) { for ( int i = fElementChildrenLength ; i < fElementChildren . length ; i ++ ) { fElementChildren [ i ] = new QName ( ) ; } qname = fElementChildren [ fElementChildrenLength ] ; } qname . setValues ( element ) ; fElementChildrenLength ++ ; if ( DEBUG_ELEMENT_CHILDREN ) { printChildren ( ) ; printStack ( ) ; } } ensureStackCapacity ( fElementDepth ) ; fCurrentElement . setValues ( element ) ; fCurrentElementEntity = fEntityHandler . getReaderId ( ) ; fElementQNamePartsStack [ fElementDepth ] . setValues ( fCurrentElement ) ; fElementEntityStack [ fElementDepth ] = fCurrentElementEntity ; fElementIndexStack [ fElementDepth ] = fCurrentElementIndex ; fContentSpecTypeStack [ fElementDepth ] = fCurrentContentSpecType ; if ( fNeedValidationOff ) { fValidating = false ; fNeedValidationOff = false ; } if ( fValidating && fGrammarIsSchemaGrammar ) { pushContentLeafStack ( ) ; } fValidationFlagStack [ fElementDepth ] = fValidating ? 0 : - 1 ; fScopeStack [ fElementDepth ] = fCurrentScope ; fGrammarNameSpaceIndexStack [ fElementDepth ] = fGrammarNameSpaceIndex ; } private void pushContentLeafStack ( ) throws Exception { int contentType = getContentSpecType ( fCurrentElementIndex ) ; if ( contentType == XMLElementDecl . TYPE_CHILDREN ) { XMLContentModel cm = getElementContentModel ( fCurrentElementIndex ) ; ContentLeafNameTypeVector cv = cm . getContentLeafNameTypeVector ( ) ; if ( cm != null ) { fContentLeafStack [ fElementDepth ] = cv ; } } } private void ensureStackCapacity ( int newElementDepth ) { if ( newElementDepth == fElementQNamePartsStack . length ) { int [ ] newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fScopeStack , 0 , newStack , 0 , newElementDepth ) ; fScopeStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fGrammarNameSpaceIndexStack , 0 , newStack , 0 , newElementDepth ) ; fGrammarNameSpaceIndexStack = newStack ; QName [ ] newStackOfQueue = new QName [ newElementDepth * 2 ] ; System . arraycopy ( this . fElementQNamePartsStack , 0 , newStackOfQueue , 0 , newElementDepth ) ; fElementQNamePartsStack = newStackOfQueue ; QName qname = fElementQNamePartsStack [ newElementDepth ] ; if ( qname == null ) { for ( int i = newElementDepth ; i < fElementQNamePartsStack . length ; i ++ ) { fElementQNamePartsStack [ i ] = new QName ( ) ; } } newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fElementEntityStack , 0 , newStack , 0 , newElementDepth ) ; fElementEntityStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fElementIndexStack , 0 , newStack , 0 , newElementDepth ) ; fElementIndexStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fContentSpecTypeStack , 0 , newStack , 0 , newElementDepth ) ; fContentSpecTypeStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fValidationFlagStack , 0 , newStack , 0 , newElementDepth ) ; fValidationFlagStack = newStack ; ContentLeafNameTypeVector [ ] newStackV = new ContentLeafNameTypeVector [ newElementDepth * 2 ] ; System . arraycopy ( fContentLeafStack , 0 , newStackV , 0 , newElementDepth ) ; fContentLeafStack = newStackV ; } } public void callEndElement ( int readerId ) throws Exception { if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "=======EndElement : " + fStringPool . toString ( fCurrentElement . localpart ) + "\n" ) ; int prefixIndex = fCurrentElement . prefix ; int elementType = fCurrentElement . rawname ; if ( fCurrentElementEntity != readerId ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ELEMENT_ENTITY_MISMATCH , XMLMessages . P78_NOT_WELLFORMED , new Object [ ] { fStringPool . toString ( elementType ) } , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } fElementDepth -- ; if ( fValidating ) { int elementIndex = fCurrentElementIndex ; if ( elementIndex != - 1 && fCurrentContentSpecType != - 1 ) { QName children [ ] = fElementChildren ; int childrenOffset = fElementChildrenOffsetStack [ fElementDepth + 1 ] + 1 ; int childrenLength = fElementChildrenLength - childrenOffset ; if ( DEBUG_ELEMENT_CHILDREN ) { System . out . println ( "endElement(" + fStringPool . toString ( fCurrentElement . rawname ) + ')' ) ; System . out . println ( "fCurrentContentSpecType : " + fCurrentContentSpecType ) ; System . out . print ( "offset: " ) ; System . out . print ( childrenOffset ) ; System . out . print ( ", length: " ) ; System . out . print ( childrenLength ) ; System . out . println ( ) ; printChildren ( ) ; printStack ( ) ; } int result = checkContent ( elementIndex , children , childrenOffset , childrenLength ) ; if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "!!!!!!!!In XMLValidator, the return value from checkContent : " + result ) ; if ( result != - 1 ) { int majorCode = result != childrenLength ? XMLMessages . MSG_CONTENT_INVALID : XMLMessages . MSG_CONTENT_INCOMPLETE ; fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; if ( fTempElementDecl . type == XMLElementDecl . TYPE_EMPTY ) { reportRecoverableXMLError ( majorCode , 0 , fStringPool . toString ( elementType ) , "EMPTY" ) ; } else reportRecoverableXMLError ( majorCode , 0 , fStringPool . toString ( elementType ) , XMLContentSpec . toString ( fGrammar , fStringPool , fTempElementDecl . contentSpecIndex ) ) ; } } fElementChildrenLength = fElementChildrenOffsetStack [ fElementDepth + 1 ] + 1 ; } fDocumentHandler . endElement ( fCurrentElement ) ; if ( fNamespacesEnabled ) { fNamespacesScope . decreaseDepth ( ) ; } if ( fElementDepth < - 1 ) { throw new RuntimeException ( "FWK008 Element stack underflow" ) ; } if ( fElementDepth < 0 ) { fCurrentElement . clear ( ) ; fCurrentElementEntity = - 1 ; fCurrentElementIndex = - 1 ; fCurrentContentSpecType = - 1 ; fInElementContent = false ; if ( fValidating ) { try { this . fValIDRef . validate ( null , this . fValidateIDRef ) ; this . fValIDRefs . validate ( null , this . fValidateIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , ex . getMessage ( ) ) ; } } try { this . fValID . validate ( null , this . fResetID ) ; this . fValIDRef . validate ( null , this . fResetIDRef ) ; this . fValIDRefs . validate ( null , this . fResetIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error re-Initializing: ID,IDRef,IDRefs pools" ) ; } return ; } fCurrentElement . prefix = - 1 ; if ( fNamespacesEnabled ) { fCurrentElement . localpart = fElementQNamePartsStack [ fElementDepth ] . localpart ; } else { fCurrentElement . localpart = fElementQNamePartsStack [ fElementDepth ] . rawname ; } fCurrentElement . rawname = fElementQNamePartsStack [ fElementDepth ] . rawname ; fCurrentElement . uri = fElementQNamePartsStack [ fElementDepth ] . uri ; fCurrentElement . prefix = fElementQNamePartsStack [ fElementDepth ] . prefix ; fCurrentElementEntity = fElementEntityStack [ fElementDepth ] ; fCurrentElementIndex = fElementIndexStack [ fElementDepth ] ; fCurrentContentSpecType = fContentSpecTypeStack [ fElementDepth ] ; fValidating = fValidationFlagStack [ fElementDepth ] == 0 ? true : false ; fCurrentScope = fScopeStack [ fElementDepth ] ; if ( fGrammarNameSpaceIndex != fGrammarNameSpaceIndexStack [ fElementDepth ] ) { fGrammarNameSpaceIndex = fGrammarNameSpaceIndexStack [ fElementDepth ] ; if ( fValidating && fGrammarIsSchemaGrammar ) if ( ! switchGrammar ( fGrammarNameSpaceIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fGrammarNameSpaceIndex ) + " , can not found" ) ; } } if ( fValidating ) { fBufferDatatype = false ; } fInElementContent = ( fCurrentContentSpecType == XMLElementDecl . TYPE_CHILDREN ) ; } public void callStartCDATA ( ) throws Exception { fDocumentHandler . startCDATA ( ) ; } public void callEndCDATA ( ) throws Exception { fDocumentHandler . endCDATA ( ) ; } public void callCharacters ( int ch ) throws Exception { if ( fCharRefData == null ) { fCharRefData = new char [ 2 ] ; } int count = ( ch < 0x10000 ) ? 1 : 2 ; if ( count == 1 ) { fCharRefData [ 0 ] = ( char ) ch ; } else { fCharRefData [ 0 ] = ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; fCharRefData [ 1 ] = ( char ) ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; } if ( fValidating && ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) ) { charDataInContent ( ) ; } if ( fSendCharDataAsCharArray ) { fDocumentHandler . characters ( fCharRefData , 0 , count ) ; } else { int index = fStringPool . addString ( new String ( fCharRefData , 0 , count ) ) ; fDocumentHandler . characters ( index ) ; } } public void callProcessingInstruction ( int target , int data ) throws Exception { fDocumentHandler . processingInstruction ( target , data ) ; } public void callComment ( int comment ) throws Exception { fDocumentHandler . comment ( comment ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { fDocumentHandler . startNamespaceDeclScope ( prefix , uri ) ; } public void endNamespaceDeclScope ( int prefix ) throws Exception { fDocumentHandler . endNamespaceDeclScope ( prefix ) ; } public void setRootElementType ( QName rootElement ) { fRootElement . setValues ( rootElement ) ; } private boolean getElementDeclIsExternal ( int elementIndex ) { if ( fGrammarIsDTDGrammar ) { return ( ( DTDGrammar ) fGrammar ) . getElementDeclIsExternal ( elementIndex ) ; } return false ; } public int getContentSpecType ( int elementIndex ) { int contentSpecType = - 1 ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentSpecType = fTempElementDecl . type ; } } return contentSpecType ; } public int getContentSpecHandle ( int elementIndex ) { int contentSpecHandle = - 1 ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentSpecHandle = fTempElementDecl . contentSpecIndex ; } } return contentSpecHandle ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode ) throws Exception { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , null , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 ) throws Exception { Object [ ] args = { string1 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 , int stringIndex2 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) , fStringPool . toString ( stringIndex2 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 ) throws Exception { Object [ ] args = { string1 , string2 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 , String string3 ) throws Exception { Object [ ] args = { string1 , string2 , string3 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected int whatCanGoHere ( int elementIndex , boolean fullyValid , InsertableElementsInfo info ) throws Exception { if ( info . insertAt > info . childCount || info . curChildren == null || info . childCount < 1 || info . childCount > info . curChildren . length ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . VAL_WCGHI , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } int retVal = 0 ; try { final XMLContentModel cmElem = getElementContentModel ( elementIndex ) ; retVal = cmElem . whatCanGoHere ( fullyValid , info ) ; } catch ( CMException excToCatch ) { int majorCode = excToCatch . getErrorCode ( ) ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , majorCode , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; throw excToCatch ; } return retVal ; } protected boolean getAttDefIsExternal ( QName element , QName attribute ) { int attDefIndex = getAttDef ( element , attribute ) ; if ( fGrammarIsDTDGrammar ) { return ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attDefIndex ) ; } return false ; } private boolean usingStandaloneReader ( ) { return fStandaloneReader == - 1 || fEntityHandler . getReaderId ( ) == fStandaloneReader ; } private LocatorImpl getLocatorImpl ( LocatorImpl fillin ) { Locator here = fErrorReporter . getLocator ( ) ; if ( fillin == null ) return new LocatorImpl ( here ) ; fillin . setPublicId ( here . getPublicId ( ) ) ; fillin . setSystemId ( here . getSystemId ( ) ) ; fillin . setLineNumber ( here . getLineNumber ( ) ) ; fillin . setColumnNumber ( here . getColumnNumber ( ) ) ; return fillin ; } private void poolReset ( ) { try { this . fValID . validate ( null , this . fResetID ) ; this . fValIDRef . validate ( null , this . fResetIDRef ) ; this . fValIDRefs . validate ( null , this . fResetIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error re-Initializing: ID,IDRef,IDRefs pools" ) ; } } private void resetCommon ( StringPool stringPool ) throws Exception { fStringPool = stringPool ; fValidating = fValidationEnabled ; fValidationEnabledByDynamic = false ; fDynamicDisabledByValidation = false ; poolReset ( ) ; fCalledStartDocument = false ; fStandaloneReader = - 1 ; fElementChildrenLength = 0 ; fElementDepth = - 1 ; fSeenRootElement = false ; fSeenDoctypeDecl = false ; fNamespacesScope = null ; fNamespacesPrefix = - 1 ; fRootElement . clear ( ) ; fAttrListHandle = - 1 ; fCheckedForSchema = false ; fCurrentScope = TOP_LEVEL_SCOPE ; fCurrentSchemaURI = - 1 ; fEmptyURI = - 1 ; fXsiPrefix = - 1 ; fXsiTypeValidator = null ; fGrammar = null ; fGrammarNameSpaceIndex = - 1 ; if ( fGrammarResolver != null ) { fGrammarResolver . clearGrammarResolver ( ) ; } fGrammarIsDTDGrammar = false ; fGrammarIsSchemaGrammar = false ; init ( ) ; } private void init ( ) { fEmptyURI = fStringPool . addSymbol ( "" ) ; fXsiURI = fStringPool . addSymbol ( SchemaSymbols . URI_XSI ) ; fEMPTYSymbol = fStringPool . addSymbol ( "EMPTY" ) ; fANYSymbol = fStringPool . addSymbol ( "ANY" ) ; fMIXEDSymbol = fStringPool . addSymbol ( "MIXED" ) ; fCHILDRENSymbol = fStringPool . addSymbol ( "CHILDREN" ) ; fCDATASymbol = fStringPool . addSymbol ( "CDATA" ) ; fIDSymbol = fStringPool . addSymbol ( "ID" ) ; fIDREFSymbol = fStringPool . addSymbol ( "IDREF" ) ; fIDREFSSymbol = fStringPool . addSymbol ( "IDREFS" ) ; fENTITYSymbol = fStringPool . addSymbol ( "ENTITY" ) ; fENTITIESSymbol = fStringPool . addSymbol ( "ENTITIES" ) ; fNMTOKENSymbol = fStringPool . addSymbol ( "NMTOKEN" ) ; fNMTOKENSSymbol = fStringPool . addSymbol ( "NMTOKENS" ) ; fNOTATIONSymbol = fStringPool . addSymbol ( "NOTATION" ) ; fENUMERATIONSymbol = fStringPool . addSymbol ( "ENUMERATION" ) ; fREQUIREDSymbol = fStringPool . addSymbol ( "#REQUIRED" ) ; fFIXEDSymbol = fStringPool . addSymbol ( "#FIXED" ) ; fDATATYPESymbol = fStringPool . addSymbol ( "<<datatype>>" ) ; fEpsilonIndex = fStringPool . addSymbol ( "<<CMNODE_EPSILON>>" ) ; fXMLLang = fStringPool . addSymbol ( "xml:lang" ) ; try { Object [ ] packageArgsEntityVal = { ( Object ) this . fEntityHandler , ( Object ) this . fStringPool } ; fValidateENTITYMsg . setDatatypeObject ( ( Object ) packageArgsEntityVal ) ; fValENTITIES . validate ( null , fValidateENTITYMsg ) ; fValENTITY . validate ( null , fValidateENTITYMsg ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } private int addDefaultAttributes ( int elementIndex , XMLAttrList attrList , int attrIndex , boolean validationEnabled , boolean standalone ) throws Exception { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; int elementNameIndex = fTempElementDecl . name . localpart ; int attlistIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int firstCheck = attrIndex ; int lastCheck = - 1 ; while ( attlistIndex != - 1 ) { fGrammar . getAttributeDecl ( attlistIndex , fTempAttDecl ) ; int attPrefix = fTempAttDecl . name . prefix ; int attName = fTempAttDecl . name . localpart ; int attType = attributeTypeName ( fTempAttDecl ) ; int attDefType = fTempAttDecl . defaultType ; int attValue = - 1 ; if ( fTempAttDecl . defaultValue != null ) { attValue = fStringPool . addSymbol ( fTempAttDecl . defaultValue ) ; } boolean specified = false ; boolean required = attDefType == XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; if ( firstCheck != - 1 ) { boolean cdata = attType == fCDATASymbol ; if ( ! cdata || required || attValue != - 1 ) { int i = attrList . getFirstAttr ( firstCheck ) ; while ( i != - 1 && ( lastCheck == - 1 || i <= lastCheck ) ) { if ( ( fGrammarIsDTDGrammar && ( attrList . getAttrName ( i ) == fTempAttDecl . name . rawname ) ) || ( fStringPool . equalNames ( attrList . getAttrLocalpart ( i ) , attName ) && fStringPool . equalNames ( attrList . getAttrURI ( i ) , fTempAttDecl . name . uri ) ) ) { if ( validationEnabled && attDefType == XMLAttributeDecl . DEFAULT_TYPE_FIXED ) { int alistValue = attrList . getAttValue ( i ) ; if ( alistValue != attValue && ! fStringPool . toString ( alistValue ) . equals ( fStringPool . toString ( attValue ) ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) , fStringPool . toString ( alistValue ) , fStringPool . toString ( attValue ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_FIXED_ATTVALUE_INVALID , XMLMessages . VC_FIXED_ATTRIBUTE_DEFAULT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } specified = true ; break ; } i = attrList . getNextAttr ( i ) ; } } } if ( ! specified ) { if ( required ) { if ( validationEnabled ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_REQUIRED_ATTRIBUTE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else if ( attValue != - 1 ) { if ( validationEnabled && standalone ) if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attlistIndex ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( attType == fIDREFSymbol ) { this . fValIDRef . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } else if ( attType == fIDREFSSymbol ) { this . fValIDRefs . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } if ( attrIndex == - 1 ) { attrIndex = attrList . startAttrList ( ) ; } fTempQName . setValues ( attPrefix , attName , attName , fTempAttDecl . name . uri ) ; int newAttr = attrList . addAttr ( fTempQName , attValue , attType , false , false ) ; if ( lastCheck == - 1 ) { lastCheck = newAttr ; } } } attlistIndex = fGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } return attrIndex ; } private int addDTDDefaultAttributes ( QName element , XMLAttrList attrList , int attrIndex , boolean validationEnabled , boolean standalone ) throws Exception { int elementIndex = fGrammar . getElementDeclIndex ( element , - 1 ) ; if ( elementIndex == - 1 ) { return attrIndex ; } fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; int elementNameIndex = fTempElementDecl . name . rawname ; int attlistIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int firstCheck = attrIndex ; int lastCheck = - 1 ; while ( attlistIndex != - 1 ) { fGrammar . getAttributeDecl ( attlistIndex , fTempAttDecl ) ; int attPrefix = fTempAttDecl . name . prefix ; int attName = fTempAttDecl . name . rawname ; int attLocalpart = fTempAttDecl . name . localpart ; int attType = attributeTypeName ( fTempAttDecl ) ; int attDefType = fTempAttDecl . defaultType ; int attValue = - 1 ; if ( fTempAttDecl . defaultValue != null ) { attValue = fStringPool . addSymbol ( fTempAttDecl . defaultValue ) ; } boolean specified = false ; boolean required = attDefType == XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; if ( firstCheck != - 1 ) { boolean cdata = attType == fCDATASymbol ; if ( ! cdata || required || attValue != - 1 ) { int i = attrList . getFirstAttr ( firstCheck ) ; while ( i != - 1 && ( lastCheck == - 1 || i <= lastCheck ) ) { if ( attrList . getAttrName ( i ) == fTempAttDecl . name . rawname ) { if ( validationEnabled && attDefType == XMLAttributeDecl . DEFAULT_TYPE_FIXED ) { int alistValue = attrList . getAttValue ( i ) ; if ( alistValue != attValue && ! fStringPool . toString ( alistValue ) . equals ( fStringPool . toString ( attValue ) ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) , fStringPool . toString ( alistValue ) , fStringPool . toString ( attValue ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_FIXED_ATTVALUE_INVALID , XMLMessages . VC_FIXED_ATTRIBUTE_DEFAULT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } specified = true ; break ; } i = attrList . getNextAttr ( i ) ; } } } if ( ! specified ) { if ( required ) { if ( validationEnabled ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_REQUIRED_ATTRIBUTE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else if ( attValue != - 1 ) { if ( validationEnabled && standalone ) if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attlistIndex ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( attType == fIDREFSymbol ) { this . fValIDRef . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } else if ( attType == fIDREFSSymbol ) { this . fValIDRefs . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } if ( attrIndex == - 1 ) { attrIndex = attrList . startAttrList ( ) ; } fTempQName . setValues ( attPrefix , attLocalpart , attName , fTempAttDecl . name . uri ) ; int newAttr = attrList . addAttr ( fTempQName , attValue , attType , false , false ) ; if ( lastCheck == - 1 ) { lastCheck = newAttr ; } } } attlistIndex = fGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } return attrIndex ; } private XMLContentModel getElementContentModel ( int elementIndex ) throws CMException { XMLContentModel contentModel = null ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentModel = fGrammar . getElementContentModel ( elementIndex ) ; } } return contentModel ; } private int getAttDef ( QName element , QName attribute ) { if ( fGrammar != null ) { int scope = fCurrentScope ; if ( element . uri > - 1 ) { scope = TOP_LEVEL_SCOPE ; } int elementIndex = fGrammar . getElementDeclIndex ( element , scope ) ; if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { fGrammar . getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . name . localpart == attribute . localpart && fTempAttributeDecl . name . uri == attribute . uri ) { return attDefIndex ; } attDefIndex = fGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } return - 1 ; } private int getAttDefByElementIndex ( int elementIndex , QName attribute ) { if ( fGrammar != null && elementIndex > - 1 ) { if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { fGrammar . getAttributeDecl ( attDefIndex , fTempAttDecl ) ; if ( fGrammarIsDTDGrammar ) { if ( fTempAttDecl . name . rawname == attribute . rawname ) return attDefIndex ; } else if ( fTempAttDecl . name . localpart == attribute . localpart && fTempAttDecl . name . uri == attribute . uri ) { return attDefIndex ; } if ( fGrammarIsSchemaGrammar ) { if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return attDefIndex ; } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { if ( attribute . uri == - 1 ) { return attDefIndex ; } } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( attribute . uri != fTempAttDecl . name . uri ) { return attDefIndex ; } } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( fStringPool . stringInList ( fTempAttDecl . enumeration , attribute . uri ) ) { return attDefIndex ; } } } attDefIndex = fGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } return - 1 ; } private void rootElementSpecified ( QName rootElement ) throws Exception { if ( fLoadDTDGrammar ) if ( fGrammar == null ) { fGrammar = fGrammarResolver . getGrammar ( "" ) ; if ( fGrammar == null && DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "Oops! no grammar is found for validation" ) ; } if ( fDynamicValidation && fGrammar == null ) { fValidating = false ; } if ( fGrammar != null ) { if ( fGrammar instanceof DTDGrammar ) { fGrammarIsDTDGrammar = true ; fGrammarIsSchemaGrammar = false ; } else if ( fGrammar instanceof SchemaGrammar ) { fGrammarIsSchemaGrammar = true ; fGrammarIsDTDGrammar = false ; } fGrammarNameSpaceIndex = fEmptyURI ; } } if ( fValidating ) { if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getRootElementQName ( fRootElement ) ) { String root1 = fStringPool . toString ( fRootElement . rawname ) ; String root2 = fStringPool . toString ( rootElement . rawname ) ; if ( ! root1 . equals ( root2 ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ROOT_ELEMENT_TYPE , XMLMessages . VC_ROOT_ELEMENT_TYPE , fRootElement . rawname , rootElement . rawname ) ; } } } if ( fNamespacesEnabled ) { if ( fNamespacesScope == null ) { fNamespacesScope = new NamespacesScope ( this ) ; fNamespacesPrefix = fStringPool . addSymbol ( "xmlns" ) ; fNamespacesScope . setNamespaceForPrefix ( fNamespacesPrefix , - 1 ) ; int xmlSymbol = fStringPool . addSymbol ( "xml" ) ; int xmlNamespace = fStringPool . addSymbol ( "http://www.w3.org/XML/1998/namespace" ) ; fNamespacesScope . setNamespaceForPrefix ( xmlSymbol , xmlNamespace ) ; } } } private boolean switchGrammar ( int newGrammarNameSpaceIndex ) throws Exception { Grammar tempGrammar = fGrammarResolver . getGrammar ( fStringPool . toString ( newGrammarNameSpaceIndex ) ) ; if ( tempGrammar == null ) { tempGrammar = fGrammarResolver . getGrammar ( "" ) ; } if ( tempGrammar == null ) { return false ; } else { fGrammar = tempGrammar ; if ( fGrammar instanceof DTDGrammar ) { fGrammarIsDTDGrammar = true ; fGrammarIsSchemaGrammar = false ; } else if ( fGrammar instanceof SchemaGrammar ) { fGrammarIsSchemaGrammar = true ; fGrammarIsDTDGrammar = false ; } return true ; } } private void bindNamespacesToElementAndAttributes ( QName element , XMLAttrList attrList ) throws Exception { fNamespacesScope . increaseDepth ( ) ; Hashtable locationUriPairs = null ; if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; int attPrefix = attrList . getAttrPrefix ( index ) ; if ( fStringPool . equalNames ( attName , fXMLLang ) ) { } else if ( fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int uri = fStringPool . addSymbol ( attrList . getAttValue ( index ) ) ; fNamespacesScope . setNamespaceForPrefix ( StringPool . EMPTY_STRING , uri ) ; } else { if ( attPrefix == fNamespacesPrefix ) { int nsPrefix = attrList . getAttrLocalpart ( index ) ; int uri = fStringPool . addSymbol ( attrList . getAttValue ( index ) ) ; fNamespacesScope . setNamespaceForPrefix ( nsPrefix , uri ) ; if ( fValidating && fSchemaValidation ) { boolean seeXsi = false ; String attrValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; if ( attrValue . equals ( SchemaSymbols . URI_XSI ) ) { fXsiPrefix = nsPrefix ; seeXsi = true ; } if ( ! seeXsi ) { } } } } index = attrList . getNextAttr ( index ) ; } if ( fValidating && fSchemaValidation ) { fXsiTypeAttValue = - 1 ; index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; int attPrefix = attrList . getAttrPrefix ( index ) ; if ( fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { } else { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "deal with XSI" ) ; System . out . println ( "before find XSI: " + fStringPool . toString ( attPrefix ) + "," + fStringPool . toString ( fXsiPrefix ) ) ; } if ( fXsiPrefix != - 1 && attPrefix == fXsiPrefix ) { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "find XSI: " + fStringPool . toString ( attPrefix ) + "," + fStringPool . toString ( attName ) ) ; } int localpart = attrList . getAttrLocalpart ( index ) ; if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_SCHEMALOCACTION ) ) { if ( locationUriPairs == null ) { locationUriPairs = new Hashtable ( ) ; } parseSchemaLocation ( fStringPool . toString ( attrList . getAttValue ( index ) ) , locationUriPairs ) ; } else if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_NONAMESPACESCHEMALOCACTION ) ) { if ( locationUriPairs == null ) { locationUriPairs = new Hashtable ( ) ; } locationUriPairs . put ( fStringPool . toString ( attrList . getAttValue ( index ) ) , "" ) ; if ( fNamespacesScope != null ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } } else if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_TYPE ) ) { fXsiTypeAttValue = attrList . getAttValue ( index ) ; } } } index = attrList . getNextAttr ( index ) ; } if ( locationUriPairs != null ) { Enumeration locations = locationUriPairs . keys ( ) ; while ( locations . hasMoreElements ( ) ) { String loc = ( String ) locations . nextElement ( ) ; String uri = ( String ) locationUriPairs . get ( loc ) ; resolveSchemaGrammar ( loc , uri ) ; } } } } int prefix = element . prefix != - 1 ? element . prefix : 0 ; int uri = fNamespacesScope . getNamespaceForPrefix ( prefix ) ; if ( element . prefix != - 1 || uri != - 1 ) { element . uri = uri ; if ( element . uri == - 1 ) { Object [ ] args = { fStringPool . toString ( element . prefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; if ( ! fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int attPrefix = attrList . getAttrPrefix ( index ) ; if ( attPrefix != fNamespacesPrefix ) { if ( attPrefix != - 1 ) { int attrUri = fNamespacesScope . getNamespaceForPrefix ( attPrefix ) ; if ( attrUri == - 1 ) { Object [ ] args = { fStringPool . toString ( attPrefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } attrList . setAttrURI ( index , attrUri ) ; } } } index = attrList . getNextAttr ( index ) ; } } } void parseSchemaLocation ( String schemaLocationStr , Hashtable locationUriPairs ) { if ( locationUriPairs != null ) { StringTokenizer tokenizer = new StringTokenizer ( schemaLocationStr , " \n\t\r" , false ) ; int tokenTotal = tokenizer . countTokens ( ) ; if ( tokenTotal % 2 != 0 ) { } else { while ( tokenizer . hasMoreTokens ( ) ) { String uri = tokenizer . nextToken ( ) ; String location = tokenizer . nextToken ( ) ; locationUriPairs . put ( location , uri ) ; } } } else { } } private void resolveSchemaGrammar ( String loc , String uri ) throws Exception { SchemaGrammar grammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uri ) ; if ( grammar == null ) { DOMParser parser = new DOMParser ( ) ; parser . setEntityResolver ( new Resolver ( fEntityHandler ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } InputSource source = null ; EntityResolver currentER = parser . getEntityResolver ( ) ; if ( currentER != null ) { source = currentER . resolveEntity ( "" , loc ) ; } if ( source == null ) { loc = fEntityHandler . expandSystemId ( loc ) ; source = new InputSource ( loc ) ; } try { parser . parse ( source ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , e . getMessage ( ) ) ; } Document document = parser . getDocument ( ) ; TraverseSchema tst = null ; try { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "I am geting the Schema Document" ) ; } Element root = document . getDocumentElement ( ) ; if ( root == null ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Can't get back Schema document's root element :" + loc ) ; } else { if ( uri == null || ! uri . equals ( root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ) ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Schema in " + loc + " has a different target namespace " + "from the one specified in the instance document :" + uri ) ; } grammar = new SchemaGrammar ( ) ; grammar . setGrammarDocument ( document ) ; tst = new TraverseSchema ( root , fStringPool , ( SchemaGrammar ) grammar , fGrammarResolver , fErrorReporter , source . getSystemId ( ) ) ; fGrammarResolver . putGrammar ( document . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) , grammar ) ; } } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } } } private void resolveSchemaGrammar ( String uri ) throws Exception { resolveSchemaGrammar ( uri , uri ) ; } static class Resolver implements EntityResolver { private static final String SYSTEM [ ] = { "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/structures.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/datatypes.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/versionInfo.ent" , } ; private static final String PATH [ ] = { "structures.dtd" , "datatypes.dtd" , "versionInfo.ent" , } ; private DefaultEntityHandler fEntityHandler ; public Resolver ( DefaultEntityHandler handler ) { fEntityHandler = handler ; } public InputSource resolveEntity ( String publicId , String systemId ) throws IOException , SAXException { for ( int i = 0 ; i < SYSTEM . length ; i ++ ) { if ( systemId . equals ( SYSTEM [ i ] ) ) { InputSource source = new InputSource ( getClass ( ) . getResourceAsStream ( PATH [ i ] ) ) ; source . setPublicId ( publicId ) ; source . setSystemId ( systemId ) ; return source ; } } EntityResolver resolver = fEntityHandler . getEntityResolver ( ) ; if ( resolver != null ) { InputSource source = resolver . resolveEntity ( publicId , systemId ) ; if ( source != null ) { return source ; } } return new InputSource ( fEntityHandler . expandSystemId ( systemId ) ) ; } } static class ErrorHandler implements org . xml . sax . ErrorHandler { public void warning ( SAXParseException ex ) { System . err . println ( "[Warning] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { System . err . println ( "[Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) { System . err . println ( "[Fatal Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId_ = ex . getSystemId ( ) ; if ( systemId_ != null ) { int index = systemId_ . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId_ = systemId_ . substring ( index + 1 ) ; str . append ( systemId_ ) ; } str . append ( ':' ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( ':' ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } } private int attributeTypeName ( XMLAttributeDecl attrDecl ) { switch ( attrDecl . type ) { case XMLAttributeDecl . TYPE_ENTITY : { return attrDecl . list ? fENTITIESSymbol : fENTITYSymbol ; } case XMLAttributeDecl . TYPE_ENUMERATION : { String enumeration = fStringPool . stringListAsString ( attrDecl . enumeration ) ; return fStringPool . addString ( enumeration ) ; } case XMLAttributeDecl . TYPE_ID : { return fIDSymbol ; } case XMLAttributeDecl . TYPE_IDREF : { return attrDecl . list ? fIDREFSSymbol : fIDREFSymbol ; } case XMLAttributeDecl . TYPE_NMTOKEN : { return attrDecl . list ? fNMTOKENSSymbol : fNMTOKENSSymbol ; } case XMLAttributeDecl . TYPE_NOTATION : { return fNOTATIONSymbol ; } } return fCDATASymbol ; } private void validateElementAndAttributes ( QName element , XMLAttrList attrList ) throws Exception { if ( ( fElementDepth >= 0 && fValidationFlagStack [ fElementDepth ] != 0 ) || ( fGrammar == null && ! fValidating && ! fNamespacesEnabled ) ) { fCurrentElementIndex = - 1 ; fCurrentContentSpecType = - 1 ; fInElementContent = false ; if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; int index = fAttrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { if ( fStringPool . equalNames ( fAttrList . getAttrName ( index ) , fXMLLang ) ) { fDocumentScanner . checkXMLLangAttributeValue ( fAttrList . getAttValue ( index ) ) ; break ; } index = fAttrList . getNextAttr ( index ) ; } } return ; } int elementIndex = - 1 ; int contentSpecType = - 1 ; boolean skipThisOne = false ; boolean laxThisOne = false ; if ( fGrammarIsSchemaGrammar && fContentLeafStack [ fElementDepth ] != null ) { ContentLeafNameTypeVector cv = fContentLeafStack [ fElementDepth ] ; QName [ ] fElemMap = cv . leafNames ; for ( int i = 0 ; i < cv . leafCount ; i ++ ) { int type = cv . leafTypes [ i ] ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fElemMap [ i ] . uri == element . uri && fElemMap [ i ] . localpart == element . localpart ) break ; } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( element . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ i ] . uri != element . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_SKIP ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_SKIP ) { if ( element . uri == - 1 ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_SKIP ) { if ( fElemMap [ i ] . uri != element . uri ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LAX ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { laxThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_LAX ) { if ( element . uri == - 1 ) { laxThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_LAX ) { if ( fElemMap [ i ] . uri != element . uri ) { laxThisOne = true ; break ; } } } } if ( skipThisOne ) { fNeedValidationOff = true ; } else { if ( fNamespacesEnabled && fValidating && element . uri != fGrammarNameSpaceIndex && element . uri != - 1 ) { fGrammarNameSpaceIndex = element . uri ; boolean success = switchGrammar ( fGrammarNameSpaceIndex ) ; if ( ! success && ! laxThisOne ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fGrammarNameSpaceIndex ) + " , can not found" ) ; } } if ( fGrammar != null ) { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "*******Lookup element: uri: " + fStringPool . toString ( element . uri ) + "localpart: '" + fStringPool . toString ( element . localpart ) + "' and scope : " + fCurrentScope + "\n" ) ; } elementIndex = fGrammar . getElementDeclIndex ( element , fCurrentScope ) ; if ( elementIndex == - 1 ) { elementIndex = fGrammar . getElementDeclIndex ( element , TOP_LEVEL_SCOPE ) ; } if ( elementIndex == - 1 ) { if ( fGrammarIsSchemaGrammar && fCurrentElementIndex != - 1 ) { TraverseSchema . ComplexTypeInfo baseTypeInfo = null ; baseTypeInfo = ( ( SchemaGrammar ) fGrammar ) . getElementComplexTypeInfo ( fCurrentElementIndex ) ; while ( baseTypeInfo != null ) { elementIndex = fGrammar . getElementDeclIndex ( element , baseTypeInfo . scopeDefined ) ; if ( elementIndex > - 1 ) { break ; } baseTypeInfo = baseTypeInfo . baseComplexTypeInfo ; } } if ( elementIndex == - 1 ) { if ( laxThisOne ) { fNeedValidationOff = true ; } else if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "!!! can not find elementDecl in the grammar, " + " the element localpart: " + element . localpart + "[" + fStringPool . toString ( element . localpart ) + "]" + " the element uri: " + element . uri + "[" + fStringPool . toString ( element . uri ) + "]" + " and the current enclosing scope: " + fCurrentScope ) ; } } if ( DEBUG_SCHEMA_VALIDATION ) { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; System . out . println ( "elementIndex: " + elementIndex + " \n and itsName : '" + fStringPool . toString ( fTempElementDecl . name . localpart ) + "' \n its ContentType:" + fTempElementDecl . type + "\n its ContentSpecIndex : " + fTempElementDecl . contentSpecIndex + "\n" + " and the current enclosing scope: " + fCurrentScope ) ; } } contentSpecType = getContentSpecType ( elementIndex ) ; if ( fGrammarIsSchemaGrammar && elementIndex != - 1 ) { if ( fXsiTypeAttValue > - 1 ) { String xsiType = fStringPool . toString ( fXsiTypeAttValue ) ; int colonP = xsiType . indexOf ( ":" ) ; String prefix = "" ; String localpart = xsiType ; if ( colonP > - 1 ) { prefix = xsiType . substring ( 0 , colonP ) ; localpart = xsiType . substring ( colonP + 1 ) ; } String uri = "" ; int uriIndex = - 1 ; if ( fNamespacesScope != null ) { uriIndex = fNamespacesScope . getNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) ) ; if ( uriIndex > - 1 ) { uri = fStringPool . toString ( uriIndex ) ; if ( uriIndex != fGrammarNameSpaceIndex ) { fGrammarNameSpaceIndex = fCurrentSchemaURI = uriIndex ; boolean success = switchGrammar ( fCurrentSchemaURI ) ; if ( ! success && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fCurrentSchemaURI ) + " , can not found" ) ; } } } } Hashtable complexRegistry = ( ( SchemaGrammar ) fGrammar ) . getComplexTypeRegistry ( ) ; DatatypeValidatorFactoryImpl dataTypeReg = ( ( SchemaGrammar ) fGrammar ) . getDatatypeRegistry ( ) ; if ( complexRegistry == null || dataTypeReg == null ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , fErrorReporter . getLocator ( ) . getSystemId ( ) + " line" + fErrorReporter . getLocator ( ) . getLineNumber ( ) + ", canot resolve xsi:type = " + xsiType + "  ---2" ) ; } else { TraverseSchema . ComplexTypeInfo typeInfo = ( TraverseSchema . ComplexTypeInfo ) complexRegistry . get ( uri + "," + localpart ) ; if ( typeInfo == null ) { if ( uri . length ( ) == 0 || uri . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { fXsiTypeValidator = dataTypeReg . getDatatypeValidator ( localpart ) ; } else fXsiTypeValidator = dataTypeReg . getDatatypeValidator ( uri + "," + localpart ) ; if ( fXsiTypeValidator == null ) reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "unresolved type : " + uri + "," + localpart + " found  in xsi:type handling" ) ; } else elementIndex = typeInfo . templateElementIndex ; } fXsiTypeAttValue = - 1 ; } fCurrentScope = ( ( SchemaGrammar ) fGrammar ) . getElementDefinedScope ( elementIndex ) ; String anotherSchemaURI = ( ( SchemaGrammar ) fGrammar ) . getElementFromAnotherSchemaURI ( elementIndex ) ; if ( anotherSchemaURI != null ) { if ( contentSpecType != - 1 && contentSpecType != XMLElementDecl . TYPE_SIMPLE && contentSpecType != XMLElementDecl . TYPE_EMPTY ) { TraverseSchema . ComplexTypeInfo typeInfo = ( ( SchemaGrammar ) fGrammar ) . getElementComplexTypeInfo ( elementIndex ) ; if ( typeInfo != null ) { elementIndex = typeInfo . templateElementIndex ; } } fGrammarNameSpaceIndex = fCurrentSchemaURI = fStringPool . addSymbol ( anotherSchemaURI ) ; boolean success = switchGrammar ( fCurrentSchemaURI ) ; if ( ! success && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fCurrentSchemaURI ) + " , can not found" ) ; } } } if ( contentSpecType == - 1 && fValidating && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_NOT_DECLARED , XMLMessages . VC_ELEMENT_VALID , element . rawname ) ; } if ( fGrammar != null && fGrammarIsSchemaGrammar && elementIndex != - 1 ) { fAttrListHandle = addDefaultAttributes ( elementIndex , attrList , fAttrListHandle , fValidating , fStandaloneReader != - 1 ) ; } if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; } if ( DEBUG_PRINT_ATTRIBUTES ) { String elementStr = fStringPool . toString ( element . rawname ) ; System . out . print ( "startElement: <" + elementStr ) ; if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { System . out . print ( " " + fStringPool . toString ( attrList . getAttrName ( index ) ) + "=\"" + fStringPool . toString ( attrList . getAttValue ( index ) ) + "\"" ) ; index = attrList . getNextAttr ( index ) ; } } System . out . println ( ">" ) ; } if ( fAttrListHandle != - 1 && ! fNeedValidationOff ) { int index = fAttrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attrNameIndex = attrList . getAttrName ( index ) ; if ( fStringPool . equalNames ( attrNameIndex , fXMLLang ) ) { fDocumentScanner . checkXMLLangAttributeValue ( attrList . getAttValue ( index ) ) ; } int _xmlns = fStringPool . addSymbol ( "xmlns" ) ; if ( attrNameIndex != _xmlns && attrList . getAttrPrefix ( index ) != _xmlns ) if ( fGrammar != null ) { fAttrNameLocator = getLocatorImpl ( fAttrNameLocator ) ; fTempQName . setValues ( attrList . getAttrPrefix ( index ) , attrList . getAttrLocalpart ( index ) , attrList . getAttrName ( index ) , attrList . getAttrURI ( index ) ) ; int attDefIndex = getAttDefByElementIndex ( elementIndex , fTempQName ) ; if ( fTempQName . uri != fXsiURI ) if ( attDefIndex == - 1 ) { if ( fValidating ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( attrList . getAttrName ( index ) ) } ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else { fGrammar . getAttributeDecl ( attDefIndex , fTempAttDecl ) ; int attributeType = attributeTypeName ( fTempAttDecl ) ; attrList . setAttType ( index , attributeType ) ; if ( fValidating ) { if ( fGrammarIsDTDGrammar && ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ENTITY || fTempAttDecl . type == XMLAttributeDecl . TYPE_ENUMERATION || fTempAttDecl . type == XMLAttributeDecl . TYPE_ID || fTempAttDecl . type == XMLAttributeDecl . TYPE_IDREF || fTempAttDecl . type == XMLAttributeDecl . TYPE_NMTOKEN || fTempAttDecl . type == XMLAttributeDecl . TYPE_NOTATION ) ) { validateDTDattribute ( element , attrList . getAttValue ( index ) , fTempAttDecl ) ; } else if ( fGrammarIsSchemaGrammar && ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_ANY || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LIST || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) ) { if ( fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_SKIP ) { } else if ( fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_STRICT || fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_LAX ) { boolean reportError = false ; boolean processContentStrict = fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_STRICT ; if ( fTempQName . uri == - 1 ) { if ( processContentStrict ) { reportError = true ; } } else { Grammar aGrammar = fGrammarResolver . getGrammar ( fStringPool . toString ( fTempQName . uri ) ) ; if ( aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { if ( processContentStrict ) { reportError = true ; } } else { SchemaGrammar sGrammar = ( SchemaGrammar ) aGrammar ; Hashtable attRegistry = sGrammar . getAttirubteDeclRegistry ( ) ; if ( attRegistry == null ) { if ( processContentStrict ) { reportError = true ; } } else { XMLAttributeDecl attDecl = ( XMLAttributeDecl ) attRegistry . get ( fStringPool . toString ( fTempQName . localpart ) ) ; if ( attDecl == null ) { if ( processContentStrict ) { reportError = true ; } } else { DatatypeValidator attDV = attDecl . datatypeValidator ; if ( attDV == null ) { if ( processContentStrict ) { reportError = true ; } } else { try { String unTrimValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; String value = unTrimValue . trim ( ) ; if ( attDecl . type == XMLAttributeDecl . TYPE_ID ) { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } if ( attDecl . type == XMLAttributeDecl . TYPE_IDREF ) { attDV . validate ( value , this . fStoreIDRef ) ; } else attDV . validate ( unTrimValue , null ) ; } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } } if ( reportError ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , "ANY---" + fStringPool . toString ( attrList . getAttrName ( index ) ) } ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } else if ( fTempAttDecl . datatypeValidator == null ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( attrList . getAttrName ( index ) ) } ; System . out . println ( "[Error] Datatypevalidator for attribute " + fStringPool . toString ( attrList . getAttrName ( index ) ) + " not found in element type " + fStringPool . toString ( element . rawname ) ) ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } else { try { String unTrimValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; String value = unTrimValue . trim ( ) ; if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ID ) { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_IDREF ) { fTempAttDecl . datatypeValidator . validate ( value , this . fStoreIDRef ) ; } else { fTempAttDecl . datatypeValidator . validate ( unTrimValue , null ) ; } } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } index = fAttrList . getNextAttr ( index ) ; } } } if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; if ( ! fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int attPrefix = attrList . getAttrPrefix ( index ) ; if ( attPrefix != fNamespacesPrefix ) { if ( attPrefix != - 1 ) { int uri = fNamespacesScope . getNamespaceForPrefix ( attPrefix ) ; if ( uri == - 1 ) { Object [ ] args = { fStringPool . toString ( attPrefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } attrList . setAttrURI ( index , uri ) ; } } } index = attrList . getNextAttr ( index ) ; } } fCurrentElementIndex = elementIndex ; fCurrentContentSpecType = contentSpecType ; if ( fValidating && contentSpecType == XMLElementDecl . TYPE_SIMPLE ) { fBufferDatatype = true ; fDatatypeBuffer . setLength ( 0 ) ; } fInElementContent = ( contentSpecType == XMLElementDecl . TYPE_CHILDREN ) ; } private void validateDTDattribute ( QName element , int attValue , XMLAttributeDecl attributeDecl ) throws Exception { AttributeValidator av = null ; switch ( attributeDecl . type ) { case XMLAttributeDecl . TYPE_ENTITY : { boolean isAlistAttribute = attributeDecl . list ; String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValENTITIES . validate ( value , null ) ; } else { fValENTITY . validate ( value , null ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( ex . getMajorCode ( ) != 1 && ex . getMinorCode ( ) != - 1 ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } else { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } } break ; case XMLAttributeDecl . TYPE_ENUMERATION : av = fAttValidatorENUMERATION ; break ; case XMLAttributeDecl . TYPE_ID : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } } break ; case XMLAttributeDecl . TYPE_IDREF : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; boolean isAlistAttribute = attributeDecl . list ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValIDRefs . validate ( value , this . fStoreIDRef ) ; } else { fValIDRef . validate ( value , this . fStoreIDRef ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( ex . getMajorCode ( ) != 1 && ex . getMinorCode ( ) != - 1 ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } else { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } } break ; case XMLAttributeDecl . TYPE_NOTATION : { av = fAttValidatorNOTATION ; } break ; case XMLAttributeDecl . TYPE_NMTOKEN : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; boolean isAlistAttribute = attributeDecl . list ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValNMTOKENS . validate ( value , null ) ; } else { fValNMTOKEN . validate ( value , null ) ; } } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( XMLMessages . MSG_NMTOKEN_INVALID , XMLMessages . VC_NAME_TOKEN , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } } break ; } if ( av != null ) av . normalize ( element , attributeDecl . name , attValue , attributeDecl . type , attributeDecl . enumeration ) ; } private void charDataInContent ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . println ( "charDataInContent()" ) ; } if ( fElementChildren . length <= fElementChildrenLength ) { QName [ ] newarray = new QName [ fElementChildren . length * 2 ] ; System . arraycopy ( fElementChildren , 0 , newarray , 0 , fElementChildren . length ) ; fElementChildren = newarray ; } QName qname = fElementChildren [ fElementChildrenLength ] ; if ( qname == null ) { for ( int i = fElementChildrenLength ; i < fElementChildren . length ; i ++ ) { fElementChildren [ i ] = new QName ( ) ; } qname = fElementChildren [ fElementChildrenLength ] ; } qname . clear ( ) ; fElementChildrenLength ++ ; } private int checkContent ( int elementIndex , QName [ ] children , int childOffset , int childCount ) throws Exception { final int elementType = fCurrentElement . rawname ; if ( DEBUG_PRINT_CONTENT ) { String strTmp = fStringPool . toString ( elementType ) ; System . out . println ( "Name: " + strTmp + ", " + "Count: " + childCount + ", " + "ContentSpecType: " + fCurrentContentSpecType ) ; for ( int index = childOffset ; index < ( childOffset + childCount ) && index < 10 ; index ++ ) { if ( index == 0 ) { System . out . print ( "  (" ) ; } String childName = ( children [ index ] . localpart == - 1 ) ? "#PCDATA" : fStringPool . toString ( children [ index ] . localpart ) ; if ( index + 1 == childCount ) { System . out . println ( childName + ")" ) ; } else if ( index + 1 == 10 ) { System . out . println ( childName + ",...)" ) ; } else { System . out . print ( childName + "," ) ; } } } final int contentType = fCurrentContentSpecType ; if ( contentType == XMLElementDecl . TYPE_EMPTY ) { if ( childCount != 0 ) { return 0 ; } } else if ( contentType == XMLElementDecl . TYPE_ANY ) { } else if ( contentType == XMLElementDecl . TYPE_MIXED || contentType == XMLElementDecl . TYPE_CHILDREN ) { XMLContentModel cmElem = null ; try { cmElem = getElementContentModel ( elementIndex ) ; int result = cmElem . validateContent ( children , childOffset , childCount ) ; if ( result != - 1 && fGrammarIsSchemaGrammar ) { EquivClassComparator comparator = new EquivClassComparator ( fGrammarResolver , fStringPool ) ; cmElem . setEquivClassComparator ( comparator ) ; result = cmElem . validateContentSpecial ( children , childOffset , childCount ) ; } return result ; } catch ( CMException excToCatch ) { int majorCode = excToCatch . getErrorCode ( ) ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , majorCode , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } else if ( contentType == - 1 ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_NOT_DECLARED , XMLMessages . VC_ELEMENT_VALID , elementType ) ; } else if ( contentType == XMLElementDecl . TYPE_SIMPLE ) { XMLContentModel cmElem = null ; if ( childCount > 0 ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { "In element '" + fStringPool . toString ( elementType ) + "' : " + "Can not have element children within a simple type content" } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } else { try { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; DatatypeValidator dv = fTempElementDecl . datatypeValidator ; if ( fXsiTypeValidator != null ) { dv = fXsiTypeValidator ; fXsiTypeValidator = null ; } if ( dv == null ) { System . out . println ( "Internal Error: this element have a simpletype " + "but no datatypevalidator was found, element " + fTempElementDecl . name + ",locapart: " + fStringPool . toString ( fTempElementDecl . name . localpart ) ) ; } else { dv . validate ( fDatatypeBuffer . toString ( ) , null ) ; } } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } else { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . VAL_CST , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } return - 1 ; } private void printChildren ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . print ( '[' ) ; for ( int i = 0 ; i < fElementChildrenLength ; i ++ ) { System . out . print ( ' ' ) ; QName qname = fElementChildren [ i ] ; if ( qname != null ) { System . out . print ( fStringPool . toString ( qname . rawname ) ) ; } else { System . out . print ( "null" ) ; } if ( i < fElementChildrenLength - 1 ) { System . out . print ( ", " ) ; } System . out . flush ( ) ; } System . out . print ( " ]" ) ; System . out . println ( ) ; } } private void printStack ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . print ( '{' ) ; for ( int i = 0 ; i <= fElementDepth ; i ++ ) { System . out . print ( ' ' ) ; System . out . print ( fElementChildrenOffsetStack [ i ] ) ; if ( i < fElementDepth ) { System . out . print ( ", " ) ; } System . out . flush ( ) ; } System . out . print ( " }" ) ; System . out . println ( ) ; } } public interface AttributeValidator { public int normalize ( QName element , QName attribute , int attValue , int attType , int enumHandle ) throws Exception ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } final class AttValidatorNOTATION implements AttributeValidator { public int normalize ( QName element , QName attribute , int attValueHandle , int attType , int enumHandle ) throws Exception { String attValue = fStringPool . toString ( attValueHandle ) ; String newAttValue = attValue . trim ( ) ; if ( fValidating ) { if ( newAttValue != attValue ) { if ( invalidStandaloneAttDef ( element , attribute ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attribute . rawname ) , attValue , newAttValue ) ; } attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } else { attValueHandle = fStringPool . addSymbol ( attValueHandle ) ; } if ( ! fStringPool . stringInList ( enumHandle , attValueHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_NOT_IN_LIST , XMLMessages . VC_NOTATION_ATTRIBUTES , fStringPool . toString ( attribute . rawname ) , newAttValue , fStringPool . stringListAsString ( enumHandle ) ) ; } } else if ( newAttValue != attValue ) { attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } return attValueHandle ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } } final class AttValidatorENUMERATION implements AttributeValidator { public int normalize ( QName element , QName attribute , int attValueHandle , int attType , int enumHandle ) throws Exception { String attValue = fStringPool . toString ( attValueHandle ) ; String newAttValue = attValue . trim ( ) ; if ( fValidating ) { if ( newAttValue != attValue ) { if ( invalidStandaloneAttDef ( element , attribute ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attribute . rawname ) , attValue , newAttValue ) ; } attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } else { attValueHandle = fStringPool . addSymbol ( attValueHandle ) ; } if ( ! fStringPool . stringInList ( enumHandle , attValueHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_NOT_IN_LIST , XMLMessages . VC_ENUMERATION , fStringPool . toString ( attribute . rawname ) , newAttValue , fStringPool . stringListAsString ( enumHandle ) ) ; } } else if ( newAttValue != attValue ) { attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } return attValueHandle ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } } } 	1
package org . w3c . dom . html ; public interface HTMLTitleElement extends HTMLElement { public String getText ( ) ; public void setText ( String text ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class ElementNSImpl extends ElementImpl { static final long serialVersionUID = - 9142310625494392642L ; protected String namespaceURI ; protected String localName ; protected ElementNSImpl ( DocumentImpl ownerDocument , String namespaceURI , String qualifiedName ) throws DOMException { super ( ownerDocument , qualifiedName ) ; if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = qualifiedName ; } else { prefix = qualifiedName . substring ( 0 , index ) ; localName = qualifiedName . substring ( index + 1 ) ; } if ( prefix != null && ( namespaceURI == null || namespaceURI . equals ( "" ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } this . namespaceURI = namespaceURI ; } protected ElementNSImpl ( DocumentImpl ownerDocument , String value ) { super ( ownerDocument , value ) ; } public String getNamespaceURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return namespaceURI ; } public String getPrefix ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int index = name . indexOf ( ':' ) ; return index < 0 ? null : name . substring ( 0 , index ) ; } public void setPrefix ( String prefix ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( namespaceURI == null || ( prefix != null && prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } if ( ownerDocument . errorChecking && ! DocumentImpl . isXMLName ( prefix ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } name = prefix + ":" + localName ; } public String getLocalName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return localName ; } } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import java . lang . reflect . * ; import org . apache . xerces . validators . datatype . * ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactory ; import org . apache . xerces . validators . datatype . InvalidDatatypeFacetException ; public class DatatypeValidatorFactoryImpl implements DatatypeValidatorFactory { private static final boolean fDebug = false ; private static DatatypeValidatorFactoryImpl _instance = new DatatypeValidatorFactoryImpl ( ) ; private Hashtable fRegistry = new Hashtable ( ) ; private DatatypeValidatorFactoryImpl ( ) { initializeRegistry ( ) ; } void initializeRegistry ( ) { DatatypeValidator v = null ; try { fRegistry . put ( "string" , new StringDatatypeValidator ( ) ) ; fRegistry . put ( "boolean" , new BooleanDatatypeValidator ( ) ) ; fRegistry . put ( "float" , new FloatDatatypeValidator ( ) ) ; fRegistry . put ( "double" , new DoubleDatatypeValidator ( ) ) ; fRegistry . put ( "decimal" , new DecimalDatatypeValidator ( ) ) ; fRegistry . put ( "timeDuration" , new TimeDurationDatatypeValidator ( ) ) ; fRegistry . put ( "recurringDuration" , new RecurringDurationDatatypeValidator ( ) ) ; fRegistry . put ( "binary" , new BinaryDatatypeValidator ( ) ) ; fRegistry . put ( "uriReference" , new URIReferenceDatatypeValidator ( ) ) ; fRegistry . put ( "ID" , new IDDatatypeValidator ( ) ) ; fRegistry . put ( "IDREF" , new IDREFDatatypeValidator ( ) ) ; fRegistry . put ( "ENTITY" , new ENTITYDatatypeValidator ( ) ) ; fRegistry . put ( "NOTATION" , new NOTATIONDatatypeValidator ( ) ) ; fRegistry . put ( "QName" , new QNameDatatypeValidator ( ) ) ; Hashtable facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_PATTERN , "([a-zA-Z]{2}|[iI]-[a-zA-Z]+|[xX]-[a-zA-Z]+)(-[a-zA-Z]+)*" ) ; createDatatypeValidator ( "language" , new StringDatatypeValidator ( ) , facets , false ) ; createDatatypeValidator ( "IDREFS" , new IDREFDatatypeValidator ( ) , null , true ) ; createDatatypeValidator ( "ENTITIES" , new ENTITYDatatypeValidator ( ) , null , true ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_PATTERN , "\\c+" ) ; createDatatypeValidator ( "NMTOKEN" , new StringDatatypeValidator ( ) , facets , false ) ; createDatatypeValidator ( "NMTOKENS" , getDatatypeValidator ( "NMTOKEN" ) , null , true ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_PATTERN , "\\i\\c*" ) ; createDatatypeValidator ( "Name" , new StringDatatypeValidator ( ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_PATTERN , "[\\i-[:]][\\c-[:]]*" ) ; createDatatypeValidator ( "NCName" , new StringDatatypeValidator ( ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_SCALE , "0" ) ; createDatatypeValidator ( "integer" , new DecimalDatatypeValidator ( ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_MAXINCLUSIVE , "0" ) ; createDatatypeValidator ( "nonPositiveInteger" , getDatatypeValidator ( "integer" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_MAXINCLUSIVE , "-1" ) ; createDatatypeValidator ( "negativeInteger" , getDatatypeValidator ( "nonPositiveInteger" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_MAXINCLUSIVE , "9223372036854775807" ) ; facets . put ( SchemaSymbols . ELT_MININCLUSIVE , "-9223372036854775808" ) ; createDatatypeValidator ( "long" , getDatatypeValidator ( "integer" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_MAXINCLUSIVE , "2147483647" ) ; facets . put ( SchemaSymbols . ELT_MININCLUSIVE , "-2147483648" ) ; createDatatypeValidator ( "int" , getDatatypeValidator ( "long" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_MAXINCLUSIVE , "32767" ) ; facets . put ( SchemaSymbols . ELT_MININCLUSIVE , "-32768" ) ; createDatatypeValidator ( "short" , getDatatypeValidator ( "int" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_MAXINCLUSIVE , "127" ) ; facets . put ( SchemaSymbols . ELT_MININCLUSIVE , "-128" ) ; createDatatypeValidator ( "byte" , getDatatypeValidator ( "short" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_MININCLUSIVE , "0" ) ; createDatatypeValidator ( "nonNegativeInteger" , getDatatypeValidator ( "integer" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_MAXINCLUSIVE , "18446744073709551615" ) ; createDatatypeValidator ( "unsignedLong" , getDatatypeValidator ( "nonNegativeInteger" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_MAXINCLUSIVE , "4294967295" ) ; createDatatypeValidator ( "unsignedInt" , getDatatypeValidator ( "unsignedLong" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_MAXINCLUSIVE , "65535" ) ; createDatatypeValidator ( "unsignedShort" , getDatatypeValidator ( "unsignedInt" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_MAXINCLUSIVE , "255" ) ; createDatatypeValidator ( "unsignedByte" , getDatatypeValidator ( "unsignedShort" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_MININCLUSIVE , "1" ) ; createDatatypeValidator ( "positiveInteger" , getDatatypeValidator ( "nonNegativeInteger" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_DURATION , "P0Y" ) ; facets . put ( SchemaSymbols . ELT_PERIOD , "P0Y" ) ; createDatatypeValidator ( "timeInstant" , getDatatypeValidator ( "recurringDuration" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_DURATION , "P0Y" ) ; createDatatypeValidator ( "time" , getDatatypeValidator ( "recurringDuration" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_PERIOD , "P0Y" ) ; createDatatypeValidator ( "timePeriod" , getDatatypeValidator ( "recurringDuration" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_DURATION , "PT24H" ) ; createDatatypeValidator ( "date" , getDatatypeValidator ( "timePeriod" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_DURATION , "P1M" ) ; createDatatypeValidator ( "month" , getDatatypeValidator ( "timePeriod" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_DURATION , "P1Y" ) ; createDatatypeValidator ( "year" , getDatatypeValidator ( "timePeriod" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_DURATION , "P100Y" ) ; createDatatypeValidator ( "century" , getDatatypeValidator ( "timePeriod" ) , facets , false ) ; facets = new Hashtable ( ) ; facets . put ( SchemaSymbols . ELT_PERIOD , "P1Y" ) ; facets . put ( SchemaSymbols . ELT_DURATION , "PT24H" ) ; createDatatypeValidator ( "recurringDate" , getDatatypeValidator ( "recurringDuration" ) , facets , false ) ; } catch ( InvalidDatatypeFacetException ex ) { ex . printStackTrace ( ) ; } } public void resetRegistry ( ) { fRegistry . clear ( ) ; initializeRegistry ( ) ; } public DatatypeValidator createDatatypeValidator ( String typeName , DatatypeValidator base , Hashtable facets , boolean list ) throws InvalidDatatypeFacetException { DatatypeValidator simpleType = null ; if ( this . fDebug == true ) { System . out . println ( "type name = " + typeName ) ; } if ( base != null ) { try { Class validatorDef = base . getClass ( ) ; Class [ ] validatorArgsClass = new Class [ ] { org . apache . xerces . validators . datatype . DatatypeValidator . class , java . util . Hashtable . class , boolean . class } ; Object [ ] validatorArgs = new Object [ ] { base , facets , new Boolean ( list ) } ; Constructor validatorConstructor = validatorDef . getConstructor ( validatorArgsClass ) ; simpleType = ( DatatypeValidator ) createDatatypeValidator ( validatorConstructor , validatorArgs ) ; if ( simpleType != null ) { addValidator ( typeName , simpleType ) ; } } catch ( NoSuchMethodException e ) { e . printStackTrace ( ) ; } } return simpleType ; } private static Object createDatatypeValidator ( Constructor validatorConstructor , Object [ ] arguments ) throws InvalidDatatypeFacetException { Object validator = null ; try { validator = validatorConstructor . newInstance ( arguments ) ; return validator ; } catch ( InstantiationException e ) { if ( fDebug ) { e . printStackTrace ( ) ; } else { return null ; } } catch ( IllegalAccessException e ) { if ( fDebug ) { e . printStackTrace ( ) ; } else { return null ; } } catch ( IllegalArgumentException e ) { if ( fDebug ) { e . printStackTrace ( ) ; } else { return null ; } } catch ( InvocationTargetException e ) { if ( fDebug ) { System . out . println ( "!! The original error message is: " + e . getTargetException ( ) . getMessage ( ) ) ; e . getTargetException ( ) . printStackTrace ( ) ; } else { throw new InvalidDatatypeFacetException ( e . getTargetException ( ) . getMessage ( ) ) ; } } return validator ; } public DatatypeValidator getDatatypeValidator ( String type ) { AbstractDatatypeValidator simpleType = null ; if ( fDebug ) { System . out . println ( "type = >" + type + "<" ) ; System . out . println ( "fRegistry = >" + fRegistry + "<" ) ; simpleType = ( AbstractDatatypeValidator ) fRegistry . get ( type ) ; } if ( type != null && fRegistry != null && fRegistry . containsKey ( type ) == true ) { simpleType = ( AbstractDatatypeValidator ) fRegistry . get ( type ) ; } return ( DatatypeValidator ) simpleType ; } private void addValidator ( String name , DatatypeValidator v ) { fRegistry . put ( name , v ) ; } static public DatatypeValidatorFactoryImpl getDatatypeRegistry ( ) { return _instance ; } static public void main ( String argv [ ] ) { DatatypeValidatorFactoryImpl tstRegistry = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; DatatypeValidator tstData1 = tstRegistry . getDatatypeValidator ( "NTOKEN" ) ; DatatypeValidator tstData2 = tstRegistry . getDatatypeValidator ( "NTOKENS" ) ; System . out . println ( "NMTOKEN = " + tstData1 ) ; System . out . println ( "NMTOKENS = " + tstData2 ) ; } } 	0
package org . w3c . dom ; public interface Document extends Node { public DocumentType getDoctype ( ) ; public DOMImplementation getImplementation ( ) ; public Element getDocumentElement ( ) ; public Element createElement ( String tagName ) throws DOMException ; public DocumentFragment createDocumentFragment ( ) ; public Text createTextNode ( String data ) ; public Comment createComment ( String data ) ; public CDATASection createCDATASection ( String data ) throws DOMException ; public ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException ; public Attr createAttribute ( String name ) throws DOMException ; public EntityReference createEntityReference ( String name ) throws DOMException ; public NodeList getElementsByTagName ( String tagname ) ; public Node importNode ( Node importedNode , boolean deep ) throws DOMException ; public Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException ; public Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public Element getElementById ( String elementId ) ; } 	1
package org . apache . wml ; public interface WMLBigElement extends WMLElement { public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface NodeIterator { public Node getRoot ( ) ; public int getWhatToShow ( ) ; public NodeFilter getFilter ( ) ; public boolean getExpandEntityReferences ( ) ; public Node nextNode ( ) throws DOMException ; public Node previousNode ( ) throws DOMException ; public void detach ( ) ; } 	1
package org . apache . xerces . utils ; public final class StringHasher { public static int hashString ( String str , int strLength ) { int hashcode = 0 ; for ( int i = 0 ; i < strLength ; i ++ ) { int top = hashcode > > 24 ; hashcode += ( ( hashcode * 37 ) + top + ( ( int ) str . charAt ( i ) ) ) ; } hashcode = ( hashcode & 0x7fffffff ) ; return ( hashcode == 0 ) ? 1 : hashcode ; } public static int hashChars ( char [ ] chars , int offset , int length ) { int hashcode = 0 ; for ( int i = 0 ; i < length ; i ++ ) { int top = hashcode > > 24 ; hashcode += ( ( hashcode * 37 ) + top + ( ( int ) ( chars [ offset ++ ] & 0xFFFF ) ) ) ; } hashcode = ( hashcode & 0x7fffffff ) ; return ( hashcode == 0 ) ? 1 : hashcode ; } public static int hashChar ( int hashcode , int ch ) { int top = hashcode > > 24 ; hashcode += ( ( hashcode * 37 ) + top + ch ) ; return hashcode ; } public static int finishHash ( int hashcode ) { hashcode = ( hashcode & 0x7fffffff ) ; return ( hashcode == 0 ) ? 1 : hashcode ; } } 	0
package org . w3c . dom . events ; public class EventException extends RuntimeException { public EventException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short UNSPECIFIED_EVENT_TYPE_ERR = 0 ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLHtmlElementImpl extends HTMLElementImpl implements HTMLHtmlElement { public String getVersion ( ) { return capitalize ( getAttribute ( "version" ) ) ; } public void setVersion ( String version ) { setAttribute ( "version" , version ) ; } public HTMLHtmlElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface DeclHandler { public abstract void elementDecl ( String name , String model ) throws SAXException ; public abstract void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException ; public abstract void internalEntityDecl ( String name , String value ) throws SAXException ; public abstract void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException ; } 	1
package org . apache . xml . serialize ; public final class LineSeparator { public static final String Unix = "\n" ; public static final String Windows = "\r\n" ; public static final String Macintosh = "\r" ; public static final String Web = "\n" ; } 	0
package org . apache . xerces . validators . schema ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . validators . common . Grammar ; import org . apache . xerces . validators . common . GrammarResolver ; import org . apache . xerces . validators . common . GrammarResolverImpl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . schema . XUtil ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . utils . StringPool ; import org . w3c . dom . Element ; import org . w3c . dom . * ; import java . util . * ; import java . net . URL ; import java . net . MalformedURLException ; import org . apache . xerces . parsers . DOMParser ; import org . apache . xerces . validators . common . XMLValidator ; import org . apache . xerces . validators . datatype . DatatypeValidator . * ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . parsers . SAXParser ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . framework . XMLDocumentScanner ; import org . xml . sax . InputSource ; import org . xml . sax . SAXParseException ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import java . io . IOException ; import org . w3c . dom . Document ; import org . apache . xml . serialize . OutputFormat ; import org . apache . xml . serialize . XMLSerializer ; import org . apache . xerces . validators . schema . SchemaSymbols ; public class TraverseSchema implements NamespacesScope . NamespacesHandler { private static final int TOP_LEVEL_SCOPE = - 1 ; private static boolean DEBUGGING = false ; private XMLErrorReporter fErrorReporter = null ; private StringPool fStringPool = null ; private GrammarResolver fGrammarResolver = null ; private SchemaGrammar fSchemaGrammar = null ; private Element fSchemaRootElement ; private DatatypeValidatorFactoryImpl fDatatypeRegistry = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; private Hashtable fComplexTypeRegistry = new Hashtable ( ) ; private Hashtable fAttributeDeclRegistry = new Hashtable ( ) ; private Vector fIncludeLocations = new Vector ( ) ; private Vector fImportLocations = new Vector ( ) ; private int fAnonTypeCount = 0 ; private int fScopeCount = 0 ; private int fCurrentScope = TOP_LEVEL_SCOPE ; private int fSimpleTypeAnonCount = 0 ; private Stack fCurrentTypeNameStack = new Stack ( ) ; private Hashtable fElementRecurseComplex = new Hashtable ( ) ; private boolean fElementDefaultQualified = false ; private boolean fAttributeDefaultQualified = false ; private int fTargetNSURI ; private String fTargetNSURIString = "" ; private NamespacesScope fNamespacesScope = null ; private String fCurrentSchemaURL = "" ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; public class ComplexTypeInfo { public String typeName ; public DatatypeValidator baseDataTypeValidator ; public ComplexTypeInfo baseComplexTypeInfo ; public int derivedBy = 0 ; public int blockSet = 0 ; public int finalSet = 0 ; public boolean isAbstract = false ; public int scopeDefined = - 1 ; public int contentType ; public int contentSpecHandle = - 1 ; public int templateElementIndex = - 1 ; public int attlistHead = - 1 ; public DatatypeValidator datatypeValidator ; } public final static String SchemaForSchemaURI = "http://www.w3.org/TR-1/Schema" ; private TraverseSchema ( ) { } public void setGrammarResolver ( GrammarResolver grammarResolver ) { fGrammarResolver = grammarResolver ; } public void startNamespaceDeclScope ( int prefix , int uri ) { } public void endNamespaceDeclScope ( int prefix ) { } private String resolvePrefixToURI ( String prefix ) throws Exception { String uriStr = fStringPool . toString ( fNamespacesScope . getNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) ) ) ; if ( uriStr == null ) { reportGenericSchemaError ( "prefix : [" + prefix + "] can not be resolved to a URI" ) ; return "" ; } if ( prefix . length ( ) == 0 && uriStr . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && fTargetNSURIString . length ( ) == 0 ) { uriStr = "" ; } return uriStr ; } public TraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver , XMLErrorReporter errorReporter , String schemaURL ) throws Exception { fErrorReporter = errorReporter ; fCurrentSchemaURL = schemaURL ; doTraverseSchema ( root , stringPool , schemaGrammar , grammarResolver ) ; } public TraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver ) throws Exception { doTraverseSchema ( root , stringPool , schemaGrammar , grammarResolver ) ; } public void doTraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver ) throws Exception { fNamespacesScope = new NamespacesScope ( this ) ; fSchemaRootElement = root ; fStringPool = stringPool ; fSchemaGrammar = schemaGrammar ; fGrammarResolver = grammarResolver ; if ( root == null ) { return ; } String rootPrefix = root . getPrefix ( ) ; if ( rootPrefix == null || rootPrefix . length ( ) == 0 ) { String xmlns = root . getAttribute ( "xmlns" ) ; if ( xmlns . length ( ) == 0 ) root . setAttribute ( "xmlns" , SchemaSymbols . URI_SCHEMAFORSCHEMA ) ; } fTargetNSURIString = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( fTargetNSURIString == null ) { fTargetNSURIString = "" ; } fTargetNSURI = fStringPool . addSymbol ( fTargetNSURIString ) ; if ( fGrammarResolver == null ) { reportGenericSchemaError ( "Internal error: don't have a GrammarResolver for TraverseSchema" ) ; } else { fSchemaGrammar . setComplexTypeRegistry ( fComplexTypeRegistry ) ; fSchemaGrammar . setDatatypeRegistry ( fDatatypeRegistry ) ; fSchemaGrammar . setAttributeDeclRegistry ( fAttributeDeclRegistry ) ; fSchemaGrammar . setNamespacesScope ( fNamespacesScope ) ; fSchemaGrammar . setTargetNamespaceURI ( fTargetNSURIString ) ; fGrammarResolver . putGrammar ( fTargetNSURIString , fSchemaGrammar ) ; } NamedNodeMap schemaEltAttrs = root . getAttributes ( ) ; int i = 0 ; Attr sattr = null ; boolean seenXMLNS = false ; while ( ( sattr = ( Attr ) schemaEltAttrs . item ( i ++ ) ) != null ) { String attName = sattr . getName ( ) ; if ( attName . startsWith ( "xmlns:" ) ) { String attValue = sattr . getValue ( ) ; String prefix = attName . substring ( attName . indexOf ( ":" ) + 1 ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) , fStringPool . addSymbol ( attValue ) ) ; } if ( attName . equals ( "xmlns" ) ) { String attValue = sattr . getValue ( ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( attValue ) ) ; seenXMLNS = true ; } } if ( ! seenXMLNS && fTargetNSURIString . length ( ) == 0 ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } fElementDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ELEMENTFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; fAttributeDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ATTRIBUTEFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; if ( fTargetNSURI == StringPool . EMPTY_STRING ) { fElementDefaultQualified = true ; } fCurrentScope = - 1 ; checkTopLevelDuplicateNames ( root ) ; extractTopLevel3Components ( root ) ; for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { traverseSimpleTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { traverseComplexTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ELEMENT ) ) { traverseElementDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , null ) ; } else if ( name . equals ( SchemaSymbols . ELT_WILDCARD ) ) { traverseWildcardDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { } else if ( name . equals ( SchemaSymbols . ELT_NOTATION ) ) { ; } else if ( name . equals ( SchemaSymbols . ELT_INCLUDE ) ) { traverseInclude ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_IMPORT ) ) { traverseImport ( child ) ; } } } private void checkTopLevelDuplicateNames ( Element root ) { } private void extractTopLevel3Components ( Element root ) { for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { fSchemaGrammar . topLevelAttrGrpDecls . put ( name , child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { fSchemaGrammar . topLevelAttrDecls . put ( name , child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { fSchemaGrammar . topLevelGroupDecls . put ( name , child ) ; } } } private String expandSystemId ( String systemId , String currentSystemId ) throws Exception { String id = systemId ; if ( id == null || id . length ( ) == 0 ) { return systemId ; } try { URL url = new URL ( id ) ; if ( url != null ) { return systemId ; } } catch ( MalformedURLException e ) { } id = fixURI ( id ) ; URL base = null ; URL url = null ; try { if ( currentSystemId == null ) { String dir ; try { dir = fixURI ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { dir = "" ; } if ( ! dir . endsWith ( "/" ) ) { dir = dir + "/" ; } base = new URL ( "file" , "" , dir ) ; } else { base = new URL ( currentSystemId ) ; } url = new URL ( base , id ) ; } catch ( Exception e ) { } if ( url == null ) { return systemId ; } return url . toString ( ) ; } private static String fixURI ( String str ) { str = str . replace ( java . io . File . separatorChar , '/' ) ; if ( str . length ( ) >= 2 ) { char ch1 = str . charAt ( 1 ) ; if ( ch1 == ':' ) { char ch0 = Character . toUpperCase ( str . charAt ( 0 ) ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { str = "/" + str ; } } } return str ; } private void traverseInclude ( Element includeDecl ) throws Exception { String location = includeDecl . getAttribute ( SchemaSymbols . ATT_SCHEMALOCATION ) ; location = expandSystemId ( location , fCurrentSchemaURL ) ; if ( fIncludeLocations . contains ( ( Object ) location ) ) { return ; } fIncludeLocations . addElement ( ( Object ) location ) ; DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( location ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { } Document document = parser . getDocument ( ) ; Element root = null ; if ( document != null ) { root = document . getDocumentElement ( ) ; } if ( root != null ) { String targetNSURI = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( targetNSURI . length ( ) > 0 && ! targetNSURI . equals ( fTargetNSURIString ) ) { reportGenericSchemaError ( "included schema '" + location + "' has a different targetNameSpace '" + targetNSURI + "'" ) ; } else { boolean saveElementDefaultQualified = fElementDefaultQualified ; boolean saveAttributeDefaultQualified = fAttributeDefaultQualified ; int saveScope = fCurrentScope ; String savedSchemaURL = fCurrentSchemaURL ; Element saveRoot = fSchemaRootElement ; fSchemaRootElement = root ; fCurrentSchemaURL = location ; traverseIncludedSchema ( root ) ; fCurrentSchemaURL = savedSchemaURL ; fCurrentScope = saveScope ; fElementDefaultQualified = saveElementDefaultQualified ; fAttributeDefaultQualified = saveAttributeDefaultQualified ; fSchemaRootElement = saveRoot ; } } } private void traverseIncludedSchema ( Element root ) throws Exception { NamedNodeMap schemaEltAttrs = root . getAttributes ( ) ; int i = 0 ; Attr sattr = null ; boolean seenXMLNS = false ; while ( ( sattr = ( Attr ) schemaEltAttrs . item ( i ++ ) ) != null ) { String attName = sattr . getName ( ) ; if ( attName . startsWith ( "xmlns:" ) ) { String attValue = sattr . getValue ( ) ; String prefix = attName . substring ( attName . indexOf ( ":" ) + 1 ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) , fStringPool . addSymbol ( attValue ) ) ; } if ( attName . equals ( "xmlns" ) ) { String attValue = sattr . getValue ( ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( attValue ) ) ; seenXMLNS = true ; } } if ( ! seenXMLNS && fTargetNSURIString . length ( ) == 0 ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } fElementDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ELEMENTFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; fAttributeDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ATTRIBUTEFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; if ( fTargetNSURI == StringPool . EMPTY_STRING ) { fElementDefaultQualified = true ; } fCurrentScope = - 1 ; checkTopLevelDuplicateNames ( root ) ; extractTopLevel3Components ( root ) ; for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { traverseSimpleTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { traverseComplexTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ELEMENT ) ) { traverseElementDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , null ) ; } else if ( name . equals ( SchemaSymbols . ELT_WILDCARD ) ) { traverseWildcardDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { } else if ( name . equals ( SchemaSymbols . ELT_NOTATION ) ) { ; } else if ( name . equals ( SchemaSymbols . ELT_INCLUDE ) ) { traverseInclude ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_IMPORT ) ) { traverseImport ( child ) ; } } } private void traverseImport ( Element importDecl ) throws Exception { String location = importDecl . getAttribute ( SchemaSymbols . ATT_SCHEMALOCATION ) ; location = expandSystemId ( location , fCurrentSchemaURL ) ; String namespaceString = importDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) ; SchemaGrammar importedGrammar = new SchemaGrammar ( ) ; if ( fGrammarResolver . getGrammar ( namespaceString ) != null ) { importedGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( namespaceString ) ; } if ( fImportLocations . contains ( ( Object ) location ) ) { return ; } fImportLocations . addElement ( ( Object ) location ) ; DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( location ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } Document document = parser . getDocument ( ) ; Element root = null ; if ( document != null ) { root = document . getDocumentElement ( ) ; } if ( root != null ) { String targetNSURI = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( ! targetNSURI . equals ( namespaceString ) ) { reportGenericSchemaError ( "imported schema '" + location + "' has a different targetNameSpace '" + targetNSURI + "' from what is declared '" + namespaceString + "'." ) ; } else new TraverseSchema ( root , fStringPool , importedGrammar , fGrammarResolver , fErrorReporter , location ) ; } else { reportGenericSchemaError ( "Could not get the doc root for imported Schema file: " + location ) ; } } private void traverseAnnotationDecl ( Element comment ) { return ; } private int traverseSimpleTypeDecl ( Element simpleTypeDecl ) throws Exception { String varietyProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_DERIVEDBY ) ; if ( varietyProperty . length ( ) == 0 ) { varietyProperty = SchemaSymbols . ATTVAL_RESTRICTION ; } String nameProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; String baseTypeQNameProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) ; String abstractProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) ; int newSimpleTypeName = - 1 ; if ( nameProperty . equals ( "" ) ) { newSimpleTypeName = fStringPool . addSymbol ( "#S#" + fSimpleTypeAnonCount ++ ) ; } else newSimpleTypeName = fStringPool . addSymbol ( nameProperty ) ; int basetype ; DatatypeValidator baseValidator = null ; if ( baseTypeQNameProperty != null ) { basetype = fStringPool . addSymbol ( baseTypeQNameProperty ) ; String prefix = "" ; String localpart = baseTypeQNameProperty ; int colonptr = baseTypeQNameProperty . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = baseTypeQNameProperty . substring ( 0 , colonptr ) ; localpart = baseTypeQNameProperty . substring ( colonptr + 1 ) ; } String uri = resolvePrefixToURI ( prefix ) ; baseValidator = getDatatypeValidator ( uri , localpart ) ; if ( baseValidator == null ) { Element baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( baseTypeNode != null ) { traverseSimpleTypeDecl ( baseTypeNode ) ; baseValidator = getDatatypeValidator ( uri , localpart ) ; if ( baseValidator == null ) { reportSchemaError ( SchemaMessageProvider . UnknownBaseDatatype , new Object [ ] { simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) , simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) } ) ; return - 1 ; } } else { reportSchemaError ( SchemaMessageProvider . UnknownBaseDatatype , new Object [ ] { simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) , simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) } ) ; return - 1 ; } } } Element content = XUtil . getFirstChildElement ( simpleTypeDecl ) ; int numFacets = 0 ; Hashtable facetData = null ; if ( content != null ) { if ( content . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content ) ; content = XUtil . getNextSiblingElement ( content ) ; } int numEnumerationLiterals = 0 ; facetData = new Hashtable ( ) ; Vector enumData = new Vector ( ) ; while ( content != null ) { if ( content . getNodeType ( ) == Node . ELEMENT_NODE ) { Element facetElt = ( Element ) content ; numFacets ++ ; if ( facetElt . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { numEnumerationLiterals ++ ; String enumVal = facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ; enumData . addElement ( enumVal ) ; Element enumContent = XUtil . getFirstChildElement ( facetElt ) ; if ( enumContent != null && enumContent != null && enumContent . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content ) ; } } else { facetData . put ( facetElt . getNodeName ( ) , facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; } } content = XUtil . getNextSiblingElement ( content ) ; } if ( numEnumerationLiterals > 0 ) { facetData . put ( SchemaSymbols . ELT_ENUMERATION , enumData ) ; } } String nameOfType = fStringPool . toString ( newSimpleTypeName ) ; if ( fTargetNSURIString . length ( ) != 0 ) { nameOfType = fTargetNSURIString + "," + nameOfType ; } try { DatatypeValidator newValidator = fDatatypeRegistry . getDatatypeValidator ( nameOfType ) ; if ( newValidator == null ) { boolean derivedByList = varietyProperty . equals ( SchemaSymbols . ATTVAL_LIST ) ? true : false ; fDatatypeRegistry . createDatatypeValidator ( nameOfType , baseValidator , facetData , derivedByList ) ; } } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . DatatypeError , new Object [ ] { e . getMessage ( ) } ) ; } return fStringPool . addSymbol ( nameOfType ) ; } private int traverseAny ( Element child ) throws Exception { int anyIndex = - 1 ; String namespace = child . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) . trim ( ) ; String processContents = child . getAttribute ( "processContents" ) . trim ( ) ; int processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY ; int processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ; int processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ; if ( processContents . length ( ) > 0 && ! processContents . equals ( "strict" ) ) { if ( processContents . equals ( "lax" ) ) { processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY_LAX ; processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_LAX ; processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_LAX ; } else if ( processContents . equals ( "skip" ) ) { processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY_SKIP ; processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_SKIP ; processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_SKIP ; } } if ( namespace . length ( ) == 0 || namespace . equals ( "##any" ) ) { anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , - 1 , false ) ; } else if ( namespace . equals ( "##other" ) ) { String uri = child . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; int uriIndex = fStringPool . addSymbol ( uri ) ; anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAnyOther , - 1 , uriIndex , false ) ; } else if ( namespace . equals ( "##local" ) ) { anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAnyLocal , - 1 , - 1 , false ) ; } else if ( namespace . length ( ) > 0 ) { StringTokenizer tokenizer = new StringTokenizer ( namespace ) ; Vector tokens = new Vector ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( "##targetNamespace" ) ) { token = child . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; } tokens . addElement ( token ) ; } String uri = ( String ) tokens . elementAt ( 0 ) ; int uriIndex = fStringPool . addSymbol ( uri ) ; int leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; int valueIndex = leafIndex ; int count = tokens . size ( ) ; if ( count > 1 ) { uri = ( String ) tokens . elementAt ( 1 ) ; uriIndex = fStringPool . addSymbol ( uri ) ; leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; int otherValueIndex = leafIndex ; int choiceIndex = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , valueIndex , otherValueIndex , false ) ; for ( int i = 2 ; i < count ; i ++ ) { uri = ( String ) tokens . elementAt ( i ) ; uriIndex = fStringPool . addSymbol ( uri ) ; leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; otherValueIndex = leafIndex ; choiceIndex = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , choiceIndex , otherValueIndex , false ) ; } anyIndex = choiceIndex ; } else { anyIndex = leafIndex ; } } else { reportGenericSchemaError ( "Empty namespace attribute for any element" ) ; } return anyIndex ; } public DatatypeValidator getDatatypeValidator ( String uri , String localpart ) { DatatypeValidator dv = null ; if ( uri . length ( ) == 0 || uri . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { dv = fDatatypeRegistry . getDatatypeValidator ( localpart ) ; } else { dv = fDatatypeRegistry . getDatatypeValidator ( uri + "," + localpart ) ; } return dv ; } private XMLAttributeDecl traverseAnyAttribute ( Element anyAttributeDecl ) throws Exception { XMLAttributeDecl anyAttDecl = new XMLAttributeDecl ( ) ; String processContents = anyAttributeDecl . getAttribute ( SchemaSymbols . ATT_PROCESSCONTENTS ) . trim ( ) ; String namespace = anyAttributeDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) . trim ( ) ; String curTargetUri = anyAttributeDecl . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; if ( namespace . length ( ) == 0 || namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDANY ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_ANY ; } else if ( namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDOTHER ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_OTHER ; anyAttDecl . name . uri = fStringPool . addSymbol ( curTargetUri ) ; } else if ( namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDLOCAL ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_LOCAL ; } else if ( namespace . length ( ) > 0 ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_LIST ; StringTokenizer tokenizer = new StringTokenizer ( namespace ) ; int aStringList = fStringPool . startStringList ( ) ; Vector tokens = new Vector ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( "##targetNamespace" ) ) { token = curTargetUri ; } if ( ! fStringPool . addStringToList ( aStringList , fStringPool . addSymbol ( token ) ) ) { reportGenericSchemaError ( "Internal StringPool error when reading the " + "namespace attribute for anyattribute declaration" ) ; } } fStringPool . finishStringList ( aStringList ) ; anyAttDecl . enumeration = aStringList ; } else { reportGenericSchemaError ( "Empty namespace attribute for anyattribute declaration" ) ; } anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_STRICT ; if ( processContents . equals ( SchemaSymbols . ATTVAL_SKIP ) ) { anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_SKIP ; } else if ( processContents . equals ( SchemaSymbols . ATTVAL_LAX ) ) { anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_LAX ; } return anyAttDecl ; } private XMLAttributeDecl mergeTwoAnyAttribute ( XMLAttributeDecl oneAny , XMLAttributeDecl anotherAny ) { if ( oneAny . type == - 1 ) { return oneAny ; } if ( anotherAny . type == - 1 ) { return anotherAny ; } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return anotherAny ; } if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return oneAny ; } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( anotherAny . name . uri == oneAny . name . uri ) { return oneAny ; } else { oneAny . type = - 1 ; return oneAny ; } } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { return anotherAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( ! fStringPool . stringInList ( anotherAny . enumeration , oneAny . name . uri ) ) { return anotherAny ; } else { int [ ] anotherAnyURIs = fStringPool . stringListAsIntArray ( anotherAny . enumeration ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < anotherAnyURIs . length ; i ++ ) { if ( anotherAnyURIs [ i ] != oneAny . name . uri ) { fStringPool . addStringToList ( newList , anotherAnyURIs [ i ] ) ; } } fStringPool . finishStringList ( newList ) ; anotherAny . enumeration = newList ; return anotherAny ; } } } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER || anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { return oneAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { oneAny . type = - 1 ; return oneAny ; } } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( ! fStringPool . stringInList ( oneAny . enumeration , anotherAny . name . uri ) ) { return oneAny ; } else { int [ ] oneAnyURIs = fStringPool . stringListAsIntArray ( oneAny . enumeration ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < oneAnyURIs . length ; i ++ ) { if ( oneAnyURIs [ i ] != anotherAny . name . uri ) { fStringPool . addStringToList ( newList , oneAnyURIs [ i ] ) ; } } fStringPool . finishStringList ( newList ) ; oneAny . enumeration = newList ; return oneAny ; } } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { oneAny . type = - 1 ; return oneAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { int [ ] result = intersect2sets ( fStringPool . stringListAsIntArray ( oneAny . enumeration ) , fStringPool . stringListAsIntArray ( anotherAny . enumeration ) ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < result . length ; i ++ ) { fStringPool . addStringToList ( newList , result [ i ] ) ; } fStringPool . finishStringList ( newList ) ; oneAny . enumeration = newList ; return oneAny ; } } return oneAny ; } int [ ] intersect2sets ( int [ ] one , int [ ] theOther ) { int [ ] result = new int [ ( one . length > theOther . length ? one . length : theOther . length ) ] ; int count = 0 ; for ( int i = 0 ; i < one . length ; i ++ ) { for ( int j = 0 ; j < theOther . length ; j ++ ) { if ( one [ i ] == theOther [ j ] ) { result [ count ++ ] = one [ i ] ; } } } int [ ] result2 = new int [ count ] ; System . arraycopy ( result , 0 , result2 , 0 , count ) ; return result2 ; } private int traverseComplexTypeDecl ( Element complexTypeDecl ) throws Exception { String isAbstract = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) ; String base = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) ; String blockSet = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ; String content = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_CONTENT ) ; String derivedBy = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_DERIVEDBY ) ; String finalSet = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ; String typeId = complexTypeDecl . getAttribute ( SchemaSymbols . ATTVAL_ID ) ; String typeName = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; boolean isNamedType = false ; if ( DEBUGGING ) System . out . println ( "traversing complex Type : " + typeName + "," + base + "," + content + "." ) ; if ( typeName . equals ( "" ) ) { typeName = "#" + fAnonTypeCount ++ ; } else { fCurrentTypeNameStack . push ( typeName ) ; isNamedType = true ; } if ( isTopLevel ( complexTypeDecl ) ) { String fullName = fTargetNSURIString + "," + typeName ; ComplexTypeInfo temp = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fullName ) ; if ( temp != null ) { return fStringPool . addSymbol ( fullName ) ; } } int scopeDefined = fScopeCount ++ ; int previousScope = fCurrentScope ; fCurrentScope = scopeDefined ; Element child = null ; int contentSpecType = - 1 ; int csnType = 0 ; int left = - 2 ; int right = - 2 ; ComplexTypeInfo baseTypeInfo = null ; DatatypeValidator baseTypeValidator = null ; DatatypeValidator simpleTypeValidator = null ; int baseTypeSymbol = - 1 ; String fullBaseName = "" ; boolean baseIsSimpleSimple = false ; boolean baseIsComplexSimple = false ; boolean derivedByRestriction = true ; boolean derivedByExtension = false ; int baseContentSpecHandle = - 1 ; Element baseTypeNode = null ; if ( base . length ( ) > 0 ) { if ( derivedBy . length ( ) == 0 ) { reportGenericSchemaError ( "derivedBy must be present when base is present in " + SchemaSymbols . ELT_COMPLEXTYPE + " " + typeName ) ; } else { if ( derivedBy . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { derivedByRestriction = false ; } String prefix = "" ; String localpart = base ; int colonptr = base . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = base . substring ( 0 , colonptr ) ; localpart = base . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String typeURI = resolvePrefixToURI ( prefix ) ; if ( ! typeURI . equals ( fTargetNSURIString ) && ! typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && typeURI . length ( ) != 0 ) { baseTypeInfo = getTypeInfoFromNS ( typeURI , localpart ) ; if ( baseTypeInfo == null ) { baseTypeValidator = getTypeValidatorFromNS ( typeURI , localpart ) ; if ( baseTypeValidator == null ) { System . out . println ( "Could not find base type " + localpart + " in schema " + typeURI ) ; } else { baseIsSimpleSimple = true ; } } } else { fullBaseName = typeURI + "," + localpart ; baseTypeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fullBaseName ) ; if ( baseTypeInfo == null ) { baseTypeValidator = getDatatypeValidator ( typeURI , localpart ) ; if ( baseTypeValidator == null ) { baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_COMPLEXTYPE , localpart ) ; if ( baseTypeNode != null ) { baseTypeSymbol = traverseComplexTypeDecl ( baseTypeNode ) ; baseTypeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( baseTypeSymbol ) ) ; } else { baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( baseTypeNode != null ) { baseTypeSymbol = traverseSimpleTypeDecl ( baseTypeNode ) ; simpleTypeValidator = baseTypeValidator = getDatatypeValidator ( typeURI , localpart ) ; if ( simpleTypeValidator == null ) { } baseIsSimpleSimple = true ; } else { reportGenericSchemaError ( "Base type could not be found : " + base ) ; } } } else { simpleTypeValidator = baseTypeValidator ; baseIsSimpleSimple = true ; } } } if ( baseIsSimpleSimple && derivedByRestriction ) { reportGenericSchemaError ( "base is a simpledType, can't derive by restriction in " + typeName ) ; } if ( baseTypeInfo != null ) { if ( derivedByRestriction ) { } else { } if ( baseTypeInfo . contentSpecHandle > - 1 ) { if ( derivedByRestriction ) { checkParticleDerivationOK ( complexTypeDecl , baseTypeNode ) ; } baseContentSpecHandle = baseTypeInfo . contentSpecHandle ; } else if ( baseTypeInfo . datatypeValidator != null ) { baseTypeValidator = baseTypeInfo . datatypeValidator ; baseIsComplexSimple = true ; } } if ( baseIsComplexSimple && ! derivedByRestriction ) { reportGenericSchemaError ( "base is ComplexSimple, can't derive by extension in " + typeName ) ; } } } child = null ; if ( baseIsComplexSimple ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; int numEnumerationLiterals = 0 ; int numFacets = 0 ; Hashtable facetData = new Hashtable ( ) ; Vector enumData = new Vector ( ) ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null && ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MININCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PRECISION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SCALE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_LENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MINLENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXLENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENCODING ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PERIOD ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_DURATION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PATTERN ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { Element facetElt = ( Element ) child ; numFacets ++ ; if ( facetElt . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { numEnumerationLiterals ++ ; enumData . addElement ( facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; Element enumContent = XUtil . getFirstChildElement ( facetElt ) ; if ( enumContent != null && enumContent . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } } else { facetData . put ( facetElt . getNodeName ( ) , facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; } } } if ( numEnumerationLiterals > 0 ) { facetData . put ( SchemaSymbols . ELT_ENUMERATION , enumData ) ; } if ( numFacets > 0 ) { simpleTypeValidator = fDatatypeRegistry . createDatatypeValidator ( typeName , baseTypeValidator , facetData , false ) ; } else simpleTypeValidator = baseTypeValidator ; if ( child != null ) { reportGenericSchemaError ( "Invalid child '" + child . getNodeName ( ) + "' in complexType : '" + typeName + "', because it restricts another complexSimpleType" ) ; } } if ( content . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { if ( base . length ( ) == 0 ) { simpleTypeValidator = baseTypeValidator = getDatatypeValidator ( "" , SchemaSymbols . ATTVAL_STRING ) ; } else if ( baseTypeValidator == null && baseTypeInfo != null && baseTypeInfo . datatypeValidator == null ) reportSchemaError ( SchemaMessageProvider . NotADatatype , new Object [ ] { base } ) ; contentSpecType = XMLElementDecl . TYPE_SIMPLE ; } else { if ( ! baseIsComplexSimple ) { contentSpecType = XMLElementDecl . TYPE_CHILDREN ; } csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; boolean mixedContent = false ; boolean elementContent = true ; boolean textContent = false ; boolean emptyContent = false ; left = - 2 ; right = - 2 ; boolean hadContent = false ; if ( content . equals ( SchemaSymbols . ATTVAL_EMPTY ) ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; emptyContent = true ; elementContent = false ; left = - 1 ; } else if ( content . equals ( SchemaSymbols . ATTVAL_MIXED ) ) { contentSpecType = XMLElementDecl . TYPE_MIXED ; mixedContent = true ; elementContent = false ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; } else if ( content . equals ( SchemaSymbols . ATTVAL_ELEMENTONLY ) || content . equals ( "" ) ) { elementContent = true ; } else if ( content . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { textContent = true ; elementContent = false ; } if ( mixedContent ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , - 1 , - 1 , false ) ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; } boolean seeParticle = false ; boolean seeOtherParticle = false ; boolean seeAll = false ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { if ( mixedContent || elementContent ) { if ( DEBUGGING ) System . out . println ( " child element name " + child . getAttribute ( SchemaSymbols . ATT_NAME ) ) ; QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; seeOtherParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . EltRefOnlyInMixedElemOnly , null ) ; } } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeParticle = true ; seeAll = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTE ) || childName . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { break ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } else if ( childName . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { break ; } else { if ( ! baseIsComplexSimple ) if ( base . equals ( "" ) ) reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "unrecogized child '" + childName + "' in compelx type " + typeName } ) ; else reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "unrecogized child '" + childName + "' in compelx type '" + typeName + "' with base " + base } ) ; } if ( baseIsComplexSimple && seeParticle ) { reportGenericSchemaError ( "In complexType " + typeName + ", base type is complextype with simpleType content, can't have any particle children at all" ) ; hadContent = false ; left = index = - 2 ; contentSpecType = XMLElementDecl . TYPE_SIMPLE ; break ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( seeAll && seeOtherParticle ) { reportGenericSchemaError ( " 'All' group needs to be the only child in Complextype : " + typeName ) ; } if ( seeAll ) { } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( ! ( seeOtherParticle || seeAll ) && ( elementContent || mixedContent ) && ( base . length ( ) == 0 || ( base . length ( ) > 0 && derivedByRestriction && ! baseIsComplexSimple ) ) ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; simpleTypeValidator = getDatatypeValidator ( "" , SchemaSymbols . ATTVAL_STRING ) ; reportGenericSchemaError ( " complexType '" + typeName + "' with a elementOnly or mixed content " + "need to have at least one particle child" ) ; } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; if ( mixedContent && hadContent ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , left , - 1 , false ) ; } } if ( ! derivedByRestriction && baseContentSpecHandle > - 1 ) { if ( left == - 2 ) { left = baseContentSpecHandle ; } else left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , baseContentSpecHandle , left , false ) ; } if ( content . length ( ) == 0 && base . length ( ) == 0 && left == - 2 ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } if ( content . length ( ) == 0 && simpleTypeValidator == null && left == - 2 ) { if ( base . length ( ) > 0 && baseTypeInfo != null && baseTypeInfo . contentType == XMLElementDecl . TYPE_EMPTY ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; } } if ( DEBUGGING ) System . out . println ( "!!!!!>>>>>" + typeName + ", " + baseTypeInfo + ", " + baseContentSpecHandle + ", " + left + ", " + scopeDefined ) ; ComplexTypeInfo typeInfo = new ComplexTypeInfo ( ) ; typeInfo . baseComplexTypeInfo = baseTypeInfo ; typeInfo . baseDataTypeValidator = baseTypeValidator ; int derivedByInt = - 1 ; if ( derivedBy . length ( ) > 0 ) { derivedByInt = parseComplexDerivedBy ( derivedBy ) ; } typeInfo . derivedBy = derivedByInt ; typeInfo . scopeDefined = scopeDefined ; typeInfo . contentSpecHandle = left ; typeInfo . contentType = contentSpecType ; typeInfo . datatypeValidator = simpleTypeValidator ; typeInfo . blockSet = parseBlockSet ( complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ) ; typeInfo . finalSet = parseFinalSet ( complexTypeDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ) ; typeInfo . isAbstract = isAbstract . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; int typeNameIndex = fStringPool . addSymbol ( typeName ) ; int templateElementNameIndex = fStringPool . addSymbol ( "$" + typeName ) ; typeInfo . templateElementIndex = fSchemaGrammar . addElementDecl ( new QName ( - 1 , templateElementNameIndex , typeNameIndex , fTargetNSURI ) , ( fTargetNSURI == - 1 ) ? - 1 : fCurrentScope , scopeDefined , contentSpecType , left , - 1 , simpleTypeValidator ) ; typeInfo . attlistHead = fSchemaGrammar . getFirstAttributeDeclIndex ( typeInfo . templateElementIndex ) ; XMLAttributeDecl attWildcard = null ; Vector anyAttDecls = new Vector ( ) ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { if ( ( baseIsComplexSimple || baseIsSimpleSimple ) && derivedByRestriction ) { reportGenericSchemaError ( "In complexType " + typeName + ", base type has simpleType " + "content and derivation method is" + " 'restriction', can't have any " + "attribute children at all" ) ; break ; } traverseAttributeDecl ( child , typeInfo ) ; } else if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { if ( ( baseIsComplexSimple || baseIsSimpleSimple ) && derivedByRestriction ) { reportGenericSchemaError ( "In complexType " + typeName + ", base " + "type has simpleType content and " + "derivation method is 'restriction'," + " can't have any attribute children at all" ) ; break ; } traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( childName . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { attWildcard = traverseAnyAttribute ( child ) ; } } if ( attWildcard != null ) { XMLAttributeDecl fromGroup = null ; final int count = anyAttDecls . size ( ) ; if ( count > 0 ) { fromGroup = ( XMLAttributeDecl ) anyAttDecls . elementAt ( 0 ) ; for ( int i = 1 ; i < count ; i ++ ) { fromGroup = mergeTwoAnyAttribute ( fromGroup , ( XMLAttributeDecl ) anyAttDecls . elementAt ( i ) ) ; } } if ( fromGroup != null ) { int saveProcessContents = attWildcard . defaultType ; attWildcard = mergeTwoAnyAttribute ( attWildcard , fromGroup ) ; attWildcard . defaultType = saveProcessContents ; } } else { } XMLAttributeDecl baseAttWildcard = null ; if ( baseTypeInfo != null && baseTypeInfo . attlistHead > - 1 ) { int attDefIndex = baseTypeInfo . attlistHead ; while ( attDefIndex > - 1 ) { fTempAttributeDecl . clear ( ) ; fSchemaGrammar . getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_ANY || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_LIST || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( attWildcard == null ) { baseAttWildcard = fTempAttributeDecl ; } attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; continue ; } int temp = fSchemaGrammar . getAttributeDeclIndex ( typeInfo . templateElementIndex , fTempAttributeDecl . name ) ; if ( temp > - 1 ) { if ( derivedByRestriction ) { attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; continue ; } } fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , fTempAttributeDecl . name , fTempAttributeDecl . type , fTempAttributeDecl . enumeration , fTempAttributeDecl . defaultType , fTempAttributeDecl . defaultValue , fTempAttributeDecl . datatypeValidator , fTempAttributeDecl . list ) ; attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } if ( attWildcard != null ) { if ( attWildcard . type != - 1 ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , attWildcard . name , attWildcard . type , attWildcard . enumeration , attWildcard . defaultType , attWildcard . defaultValue , attWildcard . datatypeValidator , attWildcard . list ) ; } else { } } else if ( baseAttWildcard != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , baseAttWildcard . name , baseAttWildcard . type , baseAttWildcard . enumeration , baseAttWildcard . defaultType , baseAttWildcard . defaultValue , baseAttWildcard . datatypeValidator , baseAttWildcard . list ) ; } typeInfo . attlistHead = fSchemaGrammar . getFirstAttributeDeclIndex ( typeInfo . templateElementIndex ) ; if ( ! typeName . startsWith ( "#" ) ) { typeName = fTargetNSURIString + "," + typeName ; } typeInfo . typeName = new String ( typeName ) ; if ( DEBUGGING ) System . out . println ( "add complex Type to Registry: " + typeName + "," + content + "." ) ; fComplexTypeRegistry . put ( typeName , typeInfo ) ; fCurrentScope = previousScope ; if ( isNamedType ) { fCurrentTypeNameStack . pop ( ) ; checkRecursingComplexType ( ) ; } fSchemaGrammar . setElementComplexTypeInfo ( typeInfo . templateElementIndex , typeInfo ) ; typeNameIndex = fStringPool . addSymbol ( typeName ) ; return typeNameIndex ; } private void checkRecursingComplexType ( ) throws Exception { if ( fCurrentTypeNameStack . empty ( ) ) { if ( ! fElementRecurseComplex . isEmpty ( ) ) { Enumeration e = fElementRecurseComplex . keys ( ) ; while ( e . hasMoreElements ( ) ) { QName nameThenScope = ( QName ) e . nextElement ( ) ; String typeName = ( String ) fElementRecurseComplex . get ( nameThenScope ) ; int eltUriIndex = nameThenScope . uri ; int eltNameIndex = nameThenScope . localpart ; int enclosingScope = nameThenScope . prefix ; ComplexTypeInfo typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fTargetNSURIString + "," + typeName ) ; if ( typeInfo == null ) { throw new Exception ( "Internal Error in void checkRecursingComplexType(). " ) ; } else { int elementIndex = fSchemaGrammar . addElementDecl ( new QName ( - 1 , eltNameIndex , eltNameIndex , eltUriIndex ) , enclosingScope , typeInfo . scopeDefined , typeInfo . contentType , typeInfo . contentSpecHandle , typeInfo . attlistHead , typeInfo . datatypeValidator ) ; fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } } fElementRecurseComplex . clear ( ) ; } } } private void checkParticleDerivationOK ( Element derivedTypeNode , Element baseTypeNode ) { } private int expandContentModel ( int index , Element particle ) throws Exception { String minOccurs = particle . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ; String maxOccurs = particle . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ; int min = 1 , max = 1 ; if ( minOccurs . equals ( "" ) ) { minOccurs = "1" ; } if ( maxOccurs . equals ( "" ) ) { if ( minOccurs . equals ( "0" ) ) { maxOccurs = "1" ; } else { maxOccurs = minOccurs ; } } int leafIndex = index ; if ( minOccurs . equals ( "1" ) && maxOccurs . equals ( "1" ) ) { } else if ( minOccurs . equals ( "0" ) && maxOccurs . equals ( "1" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , index , - 1 , false ) ; } else if ( minOccurs . equals ( "0" ) && maxOccurs . equals ( "unbounded" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , index , - 1 , false ) ; } else if ( minOccurs . equals ( "1" ) && maxOccurs . equals ( "unbounded" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , index , - 1 , false ) ; } else if ( maxOccurs . equals ( "unbounded" ) ) { try { min = Integer . parseInt ( minOccurs ) ; } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "illegal value for minOccurs : '" + e . getMessage ( ) + "' " } ) ; } if ( min < 2 ) { } index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , index , - 1 , false ) ; for ( int i = 0 ; i < ( min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , leafIndex , index , false ) ; } } else { try { min = Integer . parseInt ( minOccurs ) ; max = Integer . parseInt ( maxOccurs ) ; } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "illegal value for minOccurs or maxOccurs : '" + e . getMessage ( ) + "' " } ) ; } if ( min == 0 ) { int optional = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , leafIndex , - 1 , false ) ; index = optional ; for ( int i = 0 ; i < ( max - min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , optional , false ) ; } } else { for ( int i = 0 ; i < ( min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , leafIndex , false ) ; } int optional = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , leafIndex , - 1 , false ) ; for ( int i = 0 ; i < ( max - min ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , optional , false ) ; } } } return index ; } private int traverseAttributeDecl ( Element attrDecl , ComplexTypeInfo typeInfo ) throws Exception { String attNameStr = attrDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; int attName = fStringPool . addSymbol ( attNameStr ) ; String isQName = attrDecl . getAttribute ( SchemaSymbols . ATT_FORM ) ; DatatypeValidator dv = null ; int attType = - 1 ; boolean attIsList = false ; int dataTypeSymbol = - 1 ; String ref = attrDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; String datatype = attrDecl . getAttribute ( SchemaSymbols . ATT_TYPE ) ; String localpart = null ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( attrDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { addAttributeDeclFromAnotherSchema ( localpart , uriStr , typeInfo ) ; return - 1 ; } Element referredAttribute = getTopLevelComponentByName ( SchemaSymbols . ELT_ATTRIBUTE , localpart ) ; if ( referredAttribute != null ) { traverseAttributeDecl ( referredAttribute , typeInfo ) ; } else { reportGenericSchemaError ( "Couldn't find top level attribute " + ref ) ; } return - 1 ; } if ( datatype . equals ( "" ) ) { Element child = XUtil . getFirstChildElement ( attrDecl ) ; while ( child != null && ! child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) child = XUtil . getNextSiblingElement ( child ) ; if ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { attType = XMLAttributeDecl . TYPE_SIMPLE ; dataTypeSymbol = traverseSimpleTypeDecl ( child ) ; localpart = fStringPool . toString ( dataTypeSymbol ) ; } else { attType = XMLAttributeDecl . TYPE_SIMPLE ; localpart = "string" ; dataTypeSymbol = fStringPool . addSymbol ( localpart ) ; } localpart = fStringPool . toString ( dataTypeSymbol ) ; dv = fDatatypeRegistry . getDatatypeValidator ( localpart ) ; } else { String prefix = "" ; localpart = datatype ; dataTypeSymbol = fStringPool . addSymbol ( localpart ) ; int colonptr = datatype . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = datatype . substring ( 0 , colonptr ) ; localpart = datatype . substring ( colonptr + 1 ) ; } String typeURI = resolvePrefixToURI ( prefix ) ; if ( typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) || typeURI . length ( ) == 0 ) { dv = getDatatypeValidator ( "" , localpart ) ; if ( localpart . equals ( "ID" ) ) { attType = XMLAttributeDecl . TYPE_ID ; } else if ( localpart . equals ( "IDREF" ) ) { attType = XMLAttributeDecl . TYPE_IDREF ; } else if ( localpart . equals ( "IDREFS" ) ) { attType = XMLAttributeDecl . TYPE_IDREF ; attIsList = true ; } else if ( localpart . equals ( "ENTITY" ) ) { attType = XMLAttributeDecl . TYPE_ENTITY ; } else if ( localpart . equals ( "ENTITIES" ) ) { attType = XMLAttributeDecl . TYPE_ENTITY ; attIsList = true ; } else if ( localpart . equals ( "NMTOKEN" ) ) { attType = XMLAttributeDecl . TYPE_NMTOKEN ; } else if ( localpart . equals ( "NMTOKENS" ) ) { attType = XMLAttributeDecl . TYPE_NMTOKEN ; attIsList = true ; } else if ( localpart . equals ( SchemaSymbols . ELT_NOTATION ) ) { attType = XMLAttributeDecl . TYPE_NOTATION ; } else { attType = XMLAttributeDecl . TYPE_SIMPLE ; if ( dv == null && typeURI . length ( ) == 0 ) { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { reportGenericSchemaError ( "simpleType not found : " + localpart ) ; } } } } else { dv = getDatatypeValidator ( typeURI , localpart ) ; if ( dv == null && typeURI . equals ( fTargetNSURIString ) ) { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { reportGenericSchemaError ( "simpleType not found : " + localpart ) ; } } attType = XMLAttributeDecl . TYPE_SIMPLE ; } } int attDefaultType = - 1 ; int attDefaultValue = - 1 ; String use = attrDecl . getAttribute ( SchemaSymbols . ATT_USE ) ; boolean required = use . equals ( SchemaSymbols . ATTVAL_REQUIRED ) ; if ( dv == null ) { reportGenericSchemaError ( "could not resolve the type or get a null validator for datatype : " + fStringPool . toString ( dataTypeSymbol ) ) ; } if ( required ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; } else { if ( use . equals ( SchemaSymbols . ATTVAL_FIXED ) ) { String fixed = attrDecl . getAttribute ( SchemaSymbols . ATT_VALUE ) ; if ( ! fixed . equals ( "" ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_FIXED ; attDefaultValue = fStringPool . addString ( fixed ) ; } } else if ( use . equals ( SchemaSymbols . ATTVAL_DEFAULT ) ) { String defaultValue = attrDecl . getAttribute ( SchemaSymbols . ATT_VALUE ) ; if ( ! defaultValue . equals ( "" ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_DEFAULT ; attDefaultValue = fStringPool . addString ( defaultValue ) ; } } else if ( use . equals ( SchemaSymbols . ATTVAL_PROHIBITED ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } else { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } if ( attType == XMLAttributeDecl . TYPE_SIMPLE && attDefaultValue != - 1 ) { try { if ( dv != null ) dv . validate ( fStringPool . toString ( attDefaultValue ) , null ) ; else reportSchemaError ( SchemaMessageProvider . NoValidatorFor , new Object [ ] { datatype } ) ; } catch ( InvalidDatatypeValueException idve ) { reportSchemaError ( SchemaMessageProvider . IncorrectDefaultType , new Object [ ] { attrDecl . getAttribute ( SchemaSymbols . ATT_NAME ) , idve . getMessage ( ) } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . out . println ( "Internal error in attribute datatype validation" ) ; } } } int uriIndex = - 1 ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fAttributeDefaultQualified || isTopLevel ( attrDecl ) ) { uriIndex = fTargetNSURI ; } QName attQName = new QName ( - 1 , attName , attName , uriIndex ) ; if ( DEBUGGING ) System . out . println ( " the dataType Validator for " + fStringPool . toString ( attName ) + " is " + dv ) ; if ( isTopLevel ( attrDecl ) ) { fTempAttributeDecl . datatypeValidator = dv ; fTempAttributeDecl . name . setValues ( attQName ) ; fTempAttributeDecl . type = attType ; fTempAttributeDecl . defaultType = attDefaultType ; fTempAttributeDecl . list = attIsList ; if ( attDefaultValue != - 1 ) { fTempAttributeDecl . defaultValue = new String ( fStringPool . toString ( attDefaultValue ) ) ; } fAttributeDeclRegistry . put ( attNameStr , new XMLAttributeDecl ( fTempAttributeDecl ) ) ; } if ( typeInfo != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , attQName , attType , dataTypeSymbol , attDefaultType , fStringPool . toString ( attDefaultValue ) , dv , attIsList ) ; } return - 1 ; } private int addAttributeDeclFromAnotherSchema ( String name , String uriStr , ComplexTypeInfo typeInfo ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #addAttributeDeclFromAnotherSchema, schema uri : " + uriStr ) ; return - 1 ; } Hashtable attrRegistry = aGrammar . getAttirubteDeclRegistry ( ) ; if ( attrRegistry == null ) { reportGenericSchemaError ( "no attribute was defined in schema : " + uriStr ) ; return - 1 ; } XMLAttributeDecl tempAttrDecl = ( XMLAttributeDecl ) attrRegistry . get ( name ) ; if ( tempAttrDecl == null ) { reportGenericSchemaError ( "no attribute named \"" + name + "\" was defined in schema : " + uriStr ) ; return - 1 ; } if ( typeInfo != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , tempAttrDecl . name , tempAttrDecl . type , - 1 , tempAttrDecl . defaultType , tempAttrDecl . defaultValue , tempAttrDecl . datatypeValidator , tempAttrDecl . list ) ; } return 0 ; } private int traverseAttributeGroupDecl ( Element attrGrpDecl , ComplexTypeInfo typeInfo , Vector anyAttDecls ) throws Exception { int attGrpName = fStringPool . addSymbol ( attrGrpDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ) ; String ref = attrGrpDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; int attType = - 1 ; int enumeration = - 1 ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( attrGrpDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { traverseAttributeGroupDeclFromAnotherSchema ( localpart , uriStr , typeInfo , anyAttDecls ) ; return - 1 ; } Element referredAttrGrp = getTopLevelComponentByName ( SchemaSymbols . ELT_ATTRIBUTEGROUP , localpart ) ; if ( referredAttrGrp != null ) { traverseAttributeGroupDecl ( referredAttrGrp , typeInfo , anyAttDecls ) ; } else { reportGenericSchemaError ( "Couldn't find top level attributegroup " + ref ) ; } return - 1 ; } for ( Element child = XUtil . getFirstChildElement ( attrGrpDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , typeInfo ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { anyAttDecls . addElement ( traverseAnyAttribute ( child ) ) ; break ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } } return - 1 ; } private int traverseAttributeGroupDeclFromAnotherSchema ( String attGrpName , String uriStr , ComplexTypeInfo typeInfo , Vector anyAttDecls ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #traverseAttributeGroupDeclFromAnotherSchema, schema uri : " + uriStr ) ; return - 1 ; } Element attGrpDecl = ( Element ) aGrammar . topLevelAttrGrpDecls . get ( ( Object ) attGrpName ) ; if ( attGrpDecl == null ) { reportGenericSchemaError ( "no attribute group named \"" + attGrpName + "\" was defined in schema : " + uriStr ) ; return - 1 ; } NamespacesScope saveNSMapping = fNamespacesScope ; int saveTargetNSUri = fTargetNSURI ; fTargetNSURI = fStringPool . addSymbol ( aGrammar . getTargetNamespaceURI ( ) ) ; fNamespacesScope = aGrammar . getNamespacesScope ( ) ; int attType = - 1 ; int enumeration = - 1 ; for ( Element child = XUtil . getFirstChildElement ( attGrpDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { String childAttName = child . getAttribute ( SchemaSymbols . ATT_NAME ) ; if ( childAttName . length ( ) > 0 ) { Hashtable attDeclRegistry = aGrammar . getAttirubteDeclRegistry ( ) ; if ( attDeclRegistry != null ) { if ( attDeclRegistry . get ( ( Object ) childAttName ) != null ) { addAttributeDeclFromAnotherSchema ( childAttName , uriStr , typeInfo ) ; return - 1 ; } } } else traverseAttributeDecl ( child , typeInfo ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { anyAttDecls . addElement ( traverseAnyAttribute ( child ) ) ; break ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } } fNamespacesScope = saveNSMapping ; fTargetNSURI = saveTargetNSUri ; return - 1 ; } private QName traverseElementDecl ( Element elementDecl ) throws Exception { int contentSpecType = - 1 ; int contentSpecNodeIndex = - 1 ; int typeNameIndex = - 1 ; int scopeDefined = - 2 ; DatatypeValidator dv = null ; String name = elementDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; if ( DEBUGGING ) System . out . println ( "traversing element decl : " + name ) ; String ref = elementDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; String type = elementDecl . getAttribute ( SchemaSymbols . ATT_TYPE ) ; String minOccurs = elementDecl . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ; String maxOccurs = elementDecl . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ; String dflt = elementDecl . getAttribute ( SchemaSymbols . ATT_DEFAULT ) ; String fixed = elementDecl . getAttribute ( SchemaSymbols . ATT_FIXED ) ; String equivClass = elementDecl . getAttribute ( SchemaSymbols . ATT_EQUIVCLASS ) ; String isQName = elementDecl . getAttribute ( SchemaSymbols . ATT_FORM ) ; String fromAnotherSchema = null ; if ( isTopLevel ( elementDecl ) ) { int nameIndex = fStringPool . addSymbol ( name ) ; int eltKey = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , nameIndex , TOP_LEVEL_SCOPE ) ; if ( eltKey > - 1 ) { return new QName ( - 1 , nameIndex , nameIndex , fTargetNSURI ) ; } } int blockSet = parseBlockSet ( elementDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ) ; int finalSet = parseFinalSet ( elementDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ) ; boolean isNullable = elementDecl . getAttribute ( SchemaSymbols . ATT_NULLABLE ) . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; boolean isAbstract = elementDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; int elementMiscFlags = 0 ; if ( isNullable ) { elementMiscFlags += SchemaSymbols . NULLABLE ; } if ( isAbstract ) { elementMiscFlags += SchemaSymbols . ABSTRACT ; } int attrCount = 0 ; if ( ! ref . equals ( "" ) ) attrCount ++ ; if ( ! type . equals ( "" ) ) attrCount ++ ; if ( attrCount > 1 ) reportSchemaError ( SchemaMessageProvider . OneOfTypeRefArchRef , null ) ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( elementDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String uriString = resolvePrefixToURI ( prefix ) ; QName eltName = new QName ( prefix != null ? fStringPool . addSymbol ( prefix ) : - 1 , localpartIndex , fStringPool . addSymbol ( ref ) , uriString != null ? fStringPool . addSymbol ( uriString ) : - 1 ) ; if ( ! uriString . equals ( fTargetNSURIString ) ) { return eltName ; } int elementIndex = fSchemaGrammar . getElementDeclIndex ( eltName , TOP_LEVEL_SCOPE ) ; if ( elementIndex == - 1 ) { Element targetElement = getTopLevelComponentByName ( SchemaSymbols . ELT_ELEMENT , localpart ) ; if ( targetElement == null ) { reportGenericSchemaError ( "Element " + localpart + " not found in the Schema" ) ; return eltName ; } else { } } return eltName ; } Element equivClassElementDecl = null ; int equivClassElementDeclIndex = - 1 ; boolean noErrorSoFar = true ; String equivClassUri = null ; String equivClassLocalpart = null ; String equivClassFullName = null ; ComplexTypeInfo equivClassEltTypeInfo = null ; DatatypeValidator equivClassEltDV = null ; if ( equivClass . length ( ) > 0 ) { equivClassUri = resolvePrefixToURI ( getPrefix ( equivClass ) ) ; equivClassLocalpart = getLocalPart ( equivClass ) ; equivClassFullName = equivClassUri + "," + equivClassLocalpart ; if ( ! equivClassUri . equals ( fTargetNSURIString ) ) { equivClassEltTypeInfo = getElementDeclTypeInfoFromNS ( equivClassUri , equivClassLocalpart ) ; if ( equivClassEltTypeInfo == null ) { equivClassEltDV = getElementDeclTypeValidatorFromNS ( equivClassUri , equivClassLocalpart ) ; if ( equivClassEltDV == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type for element '" + equivClassLocalpart + "' in schema '" + equivClassUri + "'" ) ; } } } else { equivClassElementDecl = getTopLevelComponentByName ( SchemaSymbols . ELT_ELEMENT , equivClassLocalpart ) ; if ( equivClassElementDecl == null ) { equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; if ( equivClassElementDeclIndex == - 1 ) { noErrorSoFar = false ; reportGenericSchemaError ( "Equivclass affiliation element " + equivClass + " in element declaration " + name ) ; } } else { equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; if ( equivClassElementDeclIndex == - 1 ) { traverseElementDecl ( equivClassElementDecl ) ; equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; } } if ( equivClassElementDeclIndex != - 1 ) { equivClassEltTypeInfo = fSchemaGrammar . getElementComplexTypeInfo ( equivClassElementDeclIndex ) ; if ( equivClassEltTypeInfo == null ) { fSchemaGrammar . getElementDecl ( equivClassElementDeclIndex , fTempElementDecl ) ; equivClassEltDV = fTempElementDecl . datatypeValidator ; if ( equivClassEltDV == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type for element '" + equivClassLocalpart + "' in schema '" + equivClassUri + "'" ) ; } } } } } ComplexTypeInfo typeInfo = null ; Element child = XUtil . getFirstChildElement ( elementDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; boolean haveAnonType = false ; if ( child != null ) { String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . length ( ) > 0 ) { noErrorSoFar = false ; reportGenericSchemaError ( "anonymous complexType in element '" + name + "' has a name attribute" ) ; } else typeNameIndex = traverseComplexTypeDecl ( child ) ; if ( typeNameIndex != - 1 ) { typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( typeNameIndex ) ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "traverse complexType error in element '" + name + "'" ) ; } haveAnonType = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . length ( ) > 0 ) { noErrorSoFar = false ; reportGenericSchemaError ( "anonymous simpleType in element '" + name + "' has a name attribute" ) ; } else typeNameIndex = traverseSimpleTypeDecl ( child ) ; if ( typeNameIndex != - 1 ) { dv = fDatatypeRegistry . getDatatypeValidator ( fStringPool . toString ( typeNameIndex ) ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "traverse simpleType error in element '" + name + "'" ) ; } contentSpecType = XMLElementDecl . TYPE_SIMPLE ; haveAnonType = true ; } else if ( type . equals ( "" ) ) { contentSpecType = XMLElementDecl . TYPE_ANY ; contentSpecNodeIndex = - 1 ; } else { System . out . println ( "unhandled case in TraverseElementDecl" ) ; } } if ( haveAnonType && ( type . length ( ) > 0 ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "Element '" + name + "' have both a type attribute and a annoymous type child" ) ; } else if ( ! type . equals ( "" ) ) { if ( equivClassElementDecl != null ) { checkEquivClassOK ( elementDecl , equivClassElementDecl ) ; } String prefix = "" ; String localpart = type ; int colonptr = type . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = type . substring ( 0 , colonptr ) ; localpart = type . substring ( colonptr + 1 ) ; } String typeURI = resolvePrefixToURI ( prefix ) ; if ( ! typeURI . equals ( fTargetNSURIString ) && ! typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && typeURI . length ( ) != 0 ) { fromAnotherSchema = typeURI ; typeInfo = getTypeInfoFromNS ( typeURI , localpart ) ; if ( typeInfo == null ) { dv = getTypeValidatorFromNS ( typeURI , localpart ) ; if ( dv == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type " + localpart + " in schema " + typeURI ) ; } } } else { typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( typeURI + "," + localpart ) ; if ( typeInfo == null ) { dv = getDatatypeValidator ( typeURI , localpart ) ; if ( dv == null ) if ( typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && ! fTargetNSURIString . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "type not found : " + typeURI + ":" + localpart ) ; } else { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_COMPLEXTYPE , localpart ) ; if ( topleveltype != null ) { if ( fCurrentTypeNameStack . search ( ( Object ) localpart ) > - 1 ) { int uriInd = - 1 ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fElementDefaultQualified ) { uriInd = fTargetNSURI ; } int nameIndex = fStringPool . addSymbol ( name ) ; QName tempQName = new QName ( fCurrentScope , nameIndex , nameIndex , uriInd ) ; fElementRecurseComplex . put ( tempQName , localpart ) ; return new QName ( - 1 , nameIndex , nameIndex , uriInd ) ; } else { typeNameIndex = traverseComplexTypeDecl ( topleveltype ) ; typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( typeNameIndex ) ) ; } } else { topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { typeNameIndex = traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "type not found : " + typeURI + ":" + localpart ) ; } } } } } } else if ( haveAnonType ) { if ( equivClassElementDecl != null ) { checkEquivClassOK ( elementDecl , equivClassElementDecl ) ; } } else { if ( typeInfo == null && dv == null ) typeInfo = equivClassEltTypeInfo ; if ( typeInfo == null && dv == null ) dv = equivClassEltDV ; } if ( typeInfo == null && dv == null ) { if ( noErrorSoFar ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "untyped element : " + name ) ; } } if ( typeInfo != null ) { contentSpecNodeIndex = typeInfo . contentSpecHandle ; contentSpecType = typeInfo . contentType ; scopeDefined = typeInfo . scopeDefined ; dv = typeInfo . datatypeValidator ; } if ( dv != null ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; } child = XUtil . getFirstChildElement ( elementDecl ) ; Vector idConstraints = null ; while ( child != null ) { String childName = child . getNodeName ( ) ; child = XUtil . getNextSiblingElement ( child ) ; } int elementNameIndex = fStringPool . addSymbol ( name ) ; int localpartIndex = elementNameIndex ; int uriIndex = - 1 ; int enclosingScope = fCurrentScope ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fElementDefaultQualified ) { uriIndex = fTargetNSURI ; } if ( isTopLevel ( elementDecl ) ) { uriIndex = fTargetNSURI ; enclosingScope = TOP_LEVEL_SCOPE ; } int existSuchElementIndex = fSchemaGrammar . getElementDeclIndex ( uriIndex , localpartIndex , enclosingScope ) ; if ( existSuchElementIndex > - 1 ) { fSchemaGrammar . getElementDecl ( existSuchElementIndex , fTempElementDecl ) ; DatatypeValidator edv = fTempElementDecl . datatypeValidator ; ComplexTypeInfo eTypeInfo = fSchemaGrammar . getElementComplexTypeInfo ( existSuchElementIndex ) ; if ( ( ( eTypeInfo != null ) && ( eTypeInfo != typeInfo ) ) || ( ( edv != null ) && ( edv != dv ) ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "duplicate element decl in the same scope : " + fStringPool . toString ( localpartIndex ) ) ; } } QName eltQName = new QName ( - 1 , localpartIndex , elementNameIndex , uriIndex ) ; int attrListHead = - 1 ; if ( typeInfo != null ) { attrListHead = typeInfo . attlistHead ; } int elementIndex = fSchemaGrammar . addElementDecl ( eltQName , enclosingScope , scopeDefined , contentSpecType , contentSpecNodeIndex , attrListHead , dv ) ; if ( DEBUGGING ) { System . out . println ( "########elementIndex:" + elementIndex + " (" + fStringPool . toString ( eltQName . uri ) + "," + fStringPool . toString ( eltQName . localpart ) + ")" + " eltType:" + type + " contentSpecType:" + contentSpecType + " SpecNodeIndex:" + contentSpecNodeIndex + " enclosingScope: " + enclosingScope + " scopeDefined: " + scopeDefined + "\n" ) ; } if ( typeInfo != null ) { fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } else { fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } fSchemaGrammar . setElementFromAnotherSchemaURI ( elementIndex , fromAnotherSchema ) ; fSchemaGrammar . setElementDeclBlockSet ( elementIndex , blockSet ) ; fSchemaGrammar . setElementDeclFinalSet ( elementIndex , finalSet ) ; fSchemaGrammar . setElementDeclMiscFlags ( elementIndex , elementMiscFlags ) ; fSchemaGrammar . setElementDeclEquivClassElementFullName ( elementIndex , equivClassFullName ) ; return eltQName ; } int getLocalPartIndex ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String localpart = fullName ; if ( colonAt > - 1 ) { localpart = fullName . substring ( colonAt + 1 ) ; } return fStringPool . addSymbol ( localpart ) ; } String getLocalPart ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String localpart = fullName ; if ( colonAt > - 1 ) { localpart = fullName . substring ( colonAt + 1 ) ; } return localpart ; } int getPrefixIndex ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String prefix = "" ; if ( colonAt > - 1 ) { prefix = fullName . substring ( 0 , colonAt ) ; } return fStringPool . addSymbol ( prefix ) ; } String getPrefix ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String prefix = "" ; if ( colonAt > - 1 ) { prefix = fullName . substring ( 0 , colonAt ) ; } return prefix ; } private void checkEquivClassOK ( Element elementDecl , Element equivClassElementDecl ) { } private Element getTopLevelComponentByName ( String componentCategory , String name ) throws Exception { Element child = XUtil . getFirstChildElement ( fSchemaRootElement ) ; if ( child == null ) { return null ; } while ( child != null ) { if ( child . getNodeName ( ) . equals ( componentCategory ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . equals ( name ) ) { return child ; } } child = XUtil . getNextSiblingElement ( child ) ; } return null ; } private boolean isTopLevel ( Element component ) { if ( component . getParentNode ( ) . getNodeName ( ) . endsWith ( SchemaSymbols . ELT_SCHEMA ) ) { return true ; } return false ; } DatatypeValidator getTypeValidatorFromNS ( String newSchemaURI , String localpart ) throws Exception { return getDatatypeValidator ( newSchemaURI , localpart ) ; } ComplexTypeInfo getTypeInfoFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; ComplexTypeInfo typeInfo = ( ComplexTypeInfo ) sGrammar . getComplexTypeRegistry ( ) . get ( newSchemaURI + "," + localpart ) ; return typeInfo ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getTypeInfoFromNS" ) ; } return null ; } DatatypeValidator getElementDeclTypeValidatorFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; int eltIndex = sGrammar . getElementDeclIndex ( fStringPool . addSymbol ( newSchemaURI ) , fStringPool . addSymbol ( localpart ) , TOP_LEVEL_SCOPE ) ; DatatypeValidator dv = null ; if ( eltIndex > - 1 ) { sGrammar . getElementDecl ( eltIndex , fTempElementDecl ) ; dv = fTempElementDecl . datatypeValidator ; } else { reportGenericSchemaError ( "could not find global element : '" + localpart + " in the SchemaGrammar " + newSchemaURI ) ; } return dv ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getELementDeclTypeValidatorFromNS" ) ; } return null ; } ComplexTypeInfo getElementDeclTypeInfoFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; int eltIndex = sGrammar . getElementDeclIndex ( fStringPool . addSymbol ( newSchemaURI ) , fStringPool . addSymbol ( localpart ) , TOP_LEVEL_SCOPE ) ; ComplexTypeInfo typeInfo = null ; if ( eltIndex > - 1 ) { typeInfo = sGrammar . getElementComplexTypeInfo ( eltIndex ) ; } else { reportGenericSchemaError ( "could not find global element : '" + localpart + " in the SchemaGrammar " + newSchemaURI ) ; } return typeInfo ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getElementDeclTypeInfoFromNS" ) ; } return null ; } private int traverseGroupDecl ( Element groupDecl ) throws Exception { String groupName = groupDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; String ref = groupDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( groupDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { return traverseGroupDeclFromAnotherSchema ( localpart , uriStr ) ; } int contentSpecIndex = - 1 ; Element referredGroup = getTopLevelComponentByName ( SchemaSymbols . ELT_GROUP , localpart ) ; if ( referredGroup == null ) { reportGenericSchemaError ( "Group " + localpart + " not found in the Schema" ) ; throw new Exception ( "Group " + localpart + " not found in the Schema" ) ; } else { contentSpecIndex = traverseGroupDecl ( referredGroup ) ; } return contentSpecIndex ; } boolean traverseElt = true ; if ( fCurrentScope == TOP_LEVEL_SCOPE ) { traverseElt = false ; } Element child = XUtil . getFirstChildElement ( groupDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; int allChildren [ ] = null ; int allChildCount = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; boolean seeAll = false ; boolean seeParticle = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean illegalChild = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeAll = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { illegalChild = true ; reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( ! illegalChild ) { index = expandContentModel ( index , child ) ; } if ( seeParticle && seeAll ) { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "'all' needs to be 'the' only Child" , childName } ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } private int traverseGroupDeclFromAnotherSchema ( String groupName , String uriStr ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #traverseGroupDeclFromAnotherSchema, " + "schema uri: " + uriStr + ", groupName: " + groupName ) ; return - 1 ; } Element groupDecl = ( Element ) aGrammar . topLevelGroupDecls . get ( ( Object ) groupName ) ; if ( groupDecl == null ) { reportGenericSchemaError ( "no group named \"" + groupName + "\" was defined in schema : " + uriStr ) ; return - 1 ; } NamespacesScope saveNSMapping = fNamespacesScope ; int saveTargetNSUri = fTargetNSURI ; fTargetNSURI = fStringPool . addSymbol ( aGrammar . getTargetNamespaceURI ( ) ) ; fNamespacesScope = aGrammar . getNamespacesScope ( ) ; boolean traverseElt = true ; if ( fCurrentScope == TOP_LEVEL_SCOPE ) { traverseElt = false ; } Element child = XUtil . getFirstChildElement ( groupDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; int allChildren [ ] = null ; int allChildCount = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; int childNameIndex = fStringPool . addSymbol ( childName ) ; String formAttrVal = child . getAttribute ( SchemaSymbols . ATT_FORM ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; fNamespacesScope = saveNSMapping ; fTargetNSURI = saveTargetNSUri ; return left ; } int traverseSequence ( Element sequenceDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( sequenceDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } int traverseChoice ( Element choiceDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( choiceDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } int traverseAll ( Element allDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( allDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int allChildren [ ] = null ; int allChildCount = 0 ; int left = - 2 ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } try { allChildren [ allChildCount ] = index ; } catch ( NullPointerException ne ) { allChildren = new int [ 32 ] ; allChildren [ allChildCount ] = index ; } catch ( ArrayIndexOutOfBoundsException ae ) { int [ ] newArray = new int [ allChildren . length * 2 ] ; System . arraycopy ( allChildren , 0 , newArray , 0 , allChildren . length ) ; allChildren [ allChildCount ] = index ; } allChildCount ++ ; } left = buildAllModel ( allChildren , allChildCount ) ; return left ; } private int buildAllModel ( int children [ ] , int count ) throws Exception { if ( count > 1 ) { XMLContentSpec choice = new XMLContentSpec ( ) ; choice . type = XMLContentSpec . CONTENTSPECNODE_CHOICE ; choice . value = - 1 ; choice . otherValue = - 1 ; int [ ] exactChildren = new int [ count ] ; System . arraycopy ( children , 0 , exactChildren , 0 , count ) ; sort ( exactChildren , 0 , count ) ; int index = buildAllModel ( exactChildren , 0 , choice ) ; return index ; } if ( count > 0 ) { return children [ 0 ] ; } return - 1 ; } private int buildAllModel ( int src [ ] , int offset , XMLContentSpec choice ) throws Exception { if ( src . length - offset == 2 ) { int seqIndex = createSeq ( src ) ; if ( choice . value == - 1 ) { choice . value = seqIndex ; } else { if ( choice . otherValue != - 1 ) { choice . value = fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } choice . otherValue = seqIndex ; } swap ( src , offset , offset + 1 ) ; seqIndex = createSeq ( src ) ; if ( choice . value == - 1 ) { choice . value = seqIndex ; } else { if ( choice . otherValue != - 1 ) { choice . value = fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } choice . otherValue = seqIndex ; } return fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } for ( int i = offset ; i < src . length - 1 ; i ++ ) { choice . value = buildAllModel ( src , offset + 1 , choice ) ; choice . otherValue = - 1 ; sort ( src , offset , src . length - offset ) ; shift ( src , offset , i + 1 ) ; } int choiceIndex = buildAllModel ( src , offset + 1 , choice ) ; sort ( src , offset , src . length - offset ) ; return choiceIndex ; } private int createSeq ( int src [ ] ) throws Exception { int left = src [ 0 ] ; int right = src [ 1 ] ; for ( int i = 2 ; i < src . length ; i ++ ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , left , right , false ) ; right = src [ i ] ; } return fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , left , right , false ) ; } private void shift ( int src [ ] , int pos , int offset ) { int temp = src [ offset ] ; for ( int i = offset ; i > pos ; i -- ) { src [ i ] = src [ i - 1 ] ; } src [ pos ] = temp ; } private void sort ( int src [ ] , final int offset , final int length ) { for ( int i = offset ; i < offset + length - 1 ; i ++ ) { int lowest = i ; for ( int j = i + 1 ; j < offset + length ; j ++ ) { if ( src [ j ] < src [ lowest ] ) { lowest = j ; } } if ( lowest != i ) { int temp = src [ i ] ; src [ i ] = src [ lowest ] ; src [ lowest ] = temp ; } } } private void swap ( int src [ ] , int i , int j ) { int temp = src [ i ] ; src [ i ] = src [ j ] ; src [ j ] = temp ; } private int traverseWildcardDecl ( Element wildcardDecl ) throws Exception { int wildcardID = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATTVAL_ID ) ) ; int wildcardMaxOccurs = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ) ; int wildcardMinOccurs = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ) ; int wildcardNamespace = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) ) ; int wildcardProcessContents = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_PROCESSCONTENTS ) ) ; int wildcardContent = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_CONTENT ) ) ; return - 1 ; } private int parseInt ( String intString ) throws Exception { if ( intString . equals ( "*" ) ) { return SchemaSymbols . INFINITY ; } else { return Integer . parseInt ( intString ) ; } } private int parseSimpleDerivedBy ( String derivedByString ) throws Exception { if ( derivedByString . equals ( SchemaSymbols . ATTVAL_LIST ) ) { return SchemaSymbols . LIST ; } else if ( derivedByString . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { return SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "SimpleType: Invalid value for 'derivedBy'" ) ; return - 1 ; } } private int parseComplexDerivedBy ( String derivedByString ) throws Exception { if ( derivedByString . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { return SchemaSymbols . EXTENSION ; } else if ( derivedByString . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { return SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "ComplexType: Invalid value for 'derivedBy'" ) ; return - 1 ; } } private int parseSimpleFinal ( String finalString ) throws Exception { if ( finalString . equals ( SchemaSymbols . ATTVAL_POUNDALL ) ) { return SchemaSymbols . ENUMERATION + SchemaSymbols . RESTRICTION + SchemaSymbols . LIST + SchemaSymbols . REPRODUCTION ; } else { int enumerate = 0 ; int restrict = 0 ; int list = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction in set twice" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( list == 0 ) { list = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "list in set twice" ) ; } } else { reportGenericSchemaError ( "Invalid value (" + finalString + ")" ) ; } } return enumerate + restrict + list + reproduce ; } } private int parseComplexContent ( String contentString ) throws Exception { if ( contentString . equals ( SchemaSymbols . ATTVAL_EMPTY ) ) { return XMLElementDecl . TYPE_EMPTY ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_ELEMENTONLY ) ) { return XMLElementDecl . TYPE_CHILDREN ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { return XMLElementDecl . TYPE_SIMPLE ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_MIXED ) ) { return XMLElementDecl . TYPE_MIXED ; } else { reportGenericSchemaError ( "Invalid value for content" ) ; return - 1 ; } } private int parseDerivationSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EXTENSION + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private int parseBlockSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EQUIVCLASS + SchemaSymbols . EXTENSION + SchemaSymbols . LIST + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EQUIVCLASS ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EQUIVCLASS ; } else { reportGenericSchemaError ( "'equivClass' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( extend == 0 ) { extend = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "'list' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private int parseFinalSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EQUIVCLASS + SchemaSymbols . EXTENSION + SchemaSymbols . LIST + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EQUIVCLASS ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EQUIVCLASS ; } else { reportGenericSchemaError ( "'equivClass' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( extend == 0 ) { extend = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "'list' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private void reportGenericSchemaError ( String error ) throws Exception { if ( fErrorReporter == null ) { System . err . println ( "__TraverseSchemaError__ : " + error ) ; } else { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { error } ) ; } } private void reportSchemaError ( int major , Object args [ ] ) throws Exception { if ( fErrorReporter == null ) { System . out . println ( "__TraverseSchemaError__ : " + SchemaMessageProvider . fgMessageKeys [ major ] ) ; for ( int i = 0 ; i < args . length ; i ++ ) { System . out . println ( ( String ) args [ i ] ) ; } } else { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , major , SchemaMessageProvider . MSG_NONE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } public static void main ( String args [ ] ) { if ( args . length != 1 ) { System . out . println ( "Error: Usage java TraverseSchema yourFile.xsd" ) ; System . exit ( 0 ) ; } DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( args [ 0 ] ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } Document document = parser . getDocument ( ) ; OutputFormat format = new OutputFormat ( document ) ; java . io . StringWriter outWriter = new java . io . StringWriter ( ) ; XMLSerializer serial = new XMLSerializer ( outWriter , format ) ; TraverseSchema tst = null ; try { Element root = document . getDocumentElement ( ) ; tst = new TraverseSchema ( root , new StringPool ( ) , new SchemaGrammar ( ) , ( GrammarResolver ) new GrammarResolverImpl ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } parser . getDocument ( ) ; } static class Resolver implements EntityResolver { private static final String SYSTEM [ ] = { "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/structures.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/datatypes.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/versionInfo.ent" , } ; private static final String PATH [ ] = { "structures.dtd" , "datatypes.dtd" , "versionInfo.ent" , } ; public InputSource resolveEntity ( String publicId , String systemId ) throws IOException { for ( int i = 0 ; i < SYSTEM . length ; i ++ ) { if ( systemId . equals ( SYSTEM [ i ] ) ) { InputSource source = new InputSource ( getClass ( ) . getResourceAsStream ( PATH [ i ] ) ) ; source . setPublicId ( publicId ) ; source . setSystemId ( systemId ) ; return source ; } } return null ; } } static class ErrorHandler implements org . xml . sax . ErrorHandler { public void warning ( SAXParseException ex ) { System . err . println ( "[Warning] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { System . err . println ( "[Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) throws SAXException { System . err . println ( "[Fatal Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; throw ex ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId_ = ex . getSystemId ( ) ; if ( systemId_ != null ) { int index = systemId_ . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId_ = systemId_ . substring ( index + 1 ) ; str . append ( systemId_ ) ; } str . append ( ':' ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( ':' ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } } } 	1
package org . xml . sax . helpers ; import org . xml . sax . Attributes ; public class AttributesImpl implements Attributes { public AttributesImpl ( ) { length = 0 ; data = null ; } public AttributesImpl ( Attributes atts ) { setAttributes ( atts ) ; } public int getLength ( ) { return length ; } public String getURI ( int index ) { if ( index >= 0 && index < length ) { return data [ index * 5 ] ; } else { return null ; } } public String getLocalName ( int index ) { if ( index >= 0 && index < length ) { return data [ index * 5 + 1 ] ; } else { return null ; } } public String getQName ( int index ) { if ( index >= 0 && index < length ) { return data [ index * 5 + 2 ] ; } else { return null ; } } public String getType ( int index ) { if ( index >= 0 && index < length ) { return data [ index * 5 + 3 ] ; } else { return null ; } } public String getValue ( int index ) { if ( index >= 0 && index < length ) { return data [ index * 5 + 4 ] ; } else { return null ; } } public int getIndex ( String uri , String localName ) { int max = length * 5 ; for ( int i = 0 ; i < max ; i += 5 ) { if ( data [ i ] . equals ( uri ) && data [ i + 1 ] . equals ( localName ) ) { return i / 5 ; } } return - 1 ; } public int getIndex ( String qName ) { int max = length * 5 ; for ( int i = 0 ; i < max ; i += 5 ) { if ( data [ i + 2 ] . equals ( qName ) ) { return i / 5 ; } } return - 1 ; } public String getType ( String uri , String localName ) { int max = length * 5 ; for ( int i = 0 ; i < max ; i += 5 ) { if ( data [ i ] . equals ( uri ) && data [ i + 1 ] . equals ( localName ) ) { return data [ i + 3 ] ; } } return null ; } public String getType ( String qName ) { int max = length * 5 ; for ( int i = 0 ; i < max ; i += 5 ) { if ( data [ i + 2 ] . equals ( qName ) ) { return data [ i + 3 ] ; } } return null ; } public String getValue ( String uri , String localName ) { int max = length * 5 ; for ( int i = 0 ; i < max ; i += 5 ) { if ( data [ i ] . equals ( uri ) && data [ i + 1 ] . equals ( localName ) ) { return data [ i + 4 ] ; } } return null ; } public String getValue ( String qName ) { int max = length * 5 ; for ( int i = 0 ; i < max ; i += 5 ) { if ( data [ i + 2 ] . equals ( qName ) ) { return data [ i + 4 ] ; } } return null ; } public void clear ( ) { length = 0 ; } public void setAttributes ( Attributes atts ) { clear ( ) ; length = atts . getLength ( ) ; data = new String [ length * 5 ] ; for ( int i = 0 ; i < length ; i ++ ) { data [ i * 5 ] = atts . getURI ( i ) ; data [ i * 5 + 1 ] = atts . getLocalName ( i ) ; data [ i * 5 + 2 ] = atts . getQName ( i ) ; data [ i * 5 + 3 ] = atts . getType ( i ) ; data [ i * 5 + 4 ] = atts . getValue ( i ) ; } } public void addAttribute ( String uri , String localName , String qName , String type , String value ) { ensureCapacity ( length + 1 ) ; data [ length * 5 ] = uri ; data [ length * 5 + 1 ] = localName ; data [ length * 5 + 2 ] = qName ; data [ length * 5 + 3 ] = type ; data [ length * 5 + 4 ] = value ; length ++ ; } public void setAttribute ( int index , String uri , String localName , String qName , String type , String value ) { if ( index >= 0 && index < length ) { data [ index * 5 ] = uri ; data [ index * 5 + 1 ] = localName ; data [ index * 5 + 2 ] = qName ; data [ index * 5 + 3 ] = type ; data [ index * 5 + 4 ] = value ; } else { badIndex ( index ) ; } } public void removeAttribute ( int index ) { if ( index >= 0 && index < length ) { data [ index ] = null ; if ( index < length - 1 ) { System . arraycopy ( data , ( index + 1 ) * 5 , data , index * 5 , ( length - index ) * 5 ) ; } length -- ; } else { badIndex ( index ) ; } } public void setURI ( int index , String uri ) { if ( index >= 0 && index < length ) { data [ index * 5 ] = uri ; } else { badIndex ( index ) ; } } public void setLocalName ( int index , String localName ) { if ( index >= 0 && index < length ) { data [ index * 5 + 1 ] = localName ; } else { badIndex ( index ) ; } } public void setQName ( int index , String qName ) { if ( index >= 0 && index < length ) { data [ index * 5 + 2 ] = qName ; } else { badIndex ( index ) ; } } public void setType ( int index , String type ) { if ( index >= 0 && index < length ) { data [ index * 5 + 3 ] = type ; } else { badIndex ( index ) ; } } public void setValue ( int index , String value ) { if ( index >= 0 && index < length ) { data [ index * 5 + 4 ] = value ; } else { badIndex ( index ) ; } } private void ensureCapacity ( int n ) { if ( n > 0 && data == null ) { data = new String [ 25 ] ; } int max = data . length ; if ( max >= n * 5 ) { return ; } while ( max < n * 5 ) { max *= 2 ; } String newData [ ] = new String [ max ] ; System . arraycopy ( data , 0 , newData , 0 , length * 5 ) ; data = newData ; } private void badIndex ( int index ) throws ArrayIndexOutOfBoundsException { String msg = "Attempt to modify attribute at illegal index: " + index ; throw new ArrayIndexOutOfBoundsException ( msg ) ; } int length ; String data [ ] ; } 	0
package org . w3c . dom ; public interface Node { public static final short ELEMENT_NODE = 1 ; public static final short ATTRIBUTE_NODE = 2 ; public static final short TEXT_NODE = 3 ; public static final short CDATA_SECTION_NODE = 4 ; public static final short ENTITY_REFERENCE_NODE = 5 ; public static final short ENTITY_NODE = 6 ; public static final short PROCESSING_INSTRUCTION_NODE = 7 ; public static final short COMMENT_NODE = 8 ; public static final short DOCUMENT_NODE = 9 ; public static final short DOCUMENT_TYPE_NODE = 10 ; public static final short DOCUMENT_FRAGMENT_NODE = 11 ; public static final short NOTATION_NODE = 12 ; public String getNodeName ( ) ; public String getNodeValue ( ) throws DOMException ; public void setNodeValue ( String nodeValue ) throws DOMException ; public short getNodeType ( ) ; public Node getParentNode ( ) ; public NodeList getChildNodes ( ) ; public Node getFirstChild ( ) ; public Node getLastChild ( ) ; public Node getPreviousSibling ( ) ; public Node getNextSibling ( ) ; public NamedNodeMap getAttributes ( ) ; public Document getOwnerDocument ( ) ; public Node insertBefore ( Node newChild , Node refChild ) throws DOMException ; public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException ; public Node removeChild ( Node oldChild ) throws DOMException ; public Node appendChild ( Node newChild ) throws DOMException ; public boolean hasChildNodes ( ) ; public Node cloneNode ( boolean deep ) ; public void normalize ( ) ; public boolean supports ( String feature , String version ) ; public String getNamespaceURI ( ) ; public String getPrefix ( ) ; public void setPrefix ( String prefix ) throws DOMException ; public String getLocalName ( ) ; public boolean hasAttributes ( ) ; } 	1
package org . xml . sax . helpers ; import java . io . IOException ; import java . util . Enumeration ; import org . xml . sax . Parser ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . AttributeList ; import org . xml . sax . EntityResolver ; import org . xml . sax . DTDHandler ; import org . xml . sax . DocumentHandler ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; public class ParserAdapter implements XMLReader , DocumentHandler { public ParserAdapter ( ) throws SAXException { super ( ) ; String driver = System . getProperty ( "org.xml.sax.parser" ) ; try { setup ( ParserFactory . makeParser ( ) ) ; } catch ( ClassNotFoundException e1 ) { throw new SAXException ( "Cannot find SAX1 driver class " + driver , e1 ) ; } catch ( IllegalAccessException e2 ) { throw new SAXException ( "SAX1 driver class " + driver + " found but cannot be loaded" , e2 ) ; } catch ( InstantiationException e3 ) { throw new SAXException ( "SAX1 driver class " + driver + " loaded but cannot be instantiated" , e3 ) ; } catch ( ClassCastException e4 ) { throw new SAXException ( "SAX1 driver class " + driver + " does not implement org.xml.sax.Parser" ) ; } catch ( NullPointerException e5 ) { throw new SAXException ( "System property org.xml.sax.parser not specified" ) ; } } public ParserAdapter ( Parser parser ) { super ( ) ; setup ( parser ) ; } private void setup ( Parser parser ) { if ( parser == null ) { throw new NullPointerException ( "Parser argument must not be null" ) ; } this . parser = parser ; atts = new AttributesImpl ( ) ; nsSupport = new NamespaceSupport ( ) ; attAdapter = new AttributeListAdapter ( ) ; } private final static String FEATURES = "http://xml.org/sax/features/" ; private final static String NAMESPACES = FEATURES + "namespaces" ; private final static String NAMESPACE_PREFIXES = FEATURES + "namespace-prefixes" ; private final static String VALIDATION = FEATURES + "validation" ; private final static String EXTERNAL_GENERAL = FEATURES + "external-general-entities" ; private final static String EXTERNAL_PARAMETER = FEATURES + "external-parameter-entities" ; public void setFeature ( String name , boolean state ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( name . equals ( NAMESPACES ) ) { checkNotParsing ( "feature" , name ) ; namespaces = state ; if ( ! namespaces && ! prefixes ) { prefixes = true ; } } else if ( name . equals ( NAMESPACE_PREFIXES ) ) { checkNotParsing ( "feature" , name ) ; prefixes = state ; if ( ! prefixes && ! namespaces ) { namespaces = true ; } } else if ( name . equals ( VALIDATION ) || name . equals ( EXTERNAL_GENERAL ) || name . equals ( EXTERNAL_PARAMETER ) ) { throw new SAXNotSupportedException ( "Feature: " + name ) ; } else { throw new SAXNotRecognizedException ( "Feature: " + name ) ; } } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( name . equals ( NAMESPACES ) ) { return namespaces ; } else if ( name . equals ( NAMESPACE_PREFIXES ) ) { return prefixes ; } else if ( name . equals ( VALIDATION ) || name . equals ( EXTERNAL_GENERAL ) || name . equals ( EXTERNAL_PARAMETER ) ) { throw new SAXNotSupportedException ( "Feature: " + name ) ; } else { throw new SAXNotRecognizedException ( "Feature: " + name ) ; } } public void setProperty ( String name , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { throw new SAXNotRecognizedException ( "Property: " + name ) ; } public Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { throw new SAXNotRecognizedException ( "Property: " + name ) ; } public void setEntityResolver ( EntityResolver resolver ) { if ( resolver == null ) { throw new NullPointerException ( "Null entity resolver" ) ; } entityResolver = resolver ; } public EntityResolver getEntityResolver ( ) { return entityResolver ; } public void setDTDHandler ( DTDHandler handler ) { if ( handler == null ) { throw new NullPointerException ( "Null DTD handler" ) ; } dtdHandler = handler ; } public DTDHandler getDTDHandler ( ) { return dtdHandler ; } public void setContentHandler ( ContentHandler handler ) { if ( handler == null ) { throw new NullPointerException ( "Null content handler" ) ; } contentHandler = handler ; } public ContentHandler getContentHandler ( ) { return contentHandler ; } public void setErrorHandler ( ErrorHandler handler ) { if ( handler == null ) { throw new NullPointerException ( "Null error handler" ) ; } errorHandler = handler ; } public ErrorHandler getErrorHandler ( ) { return errorHandler ; } public void parse ( String systemId ) throws IOException , SAXException { parse ( new InputSource ( systemId ) ) ; } public void parse ( InputSource input ) throws IOException , SAXException { if ( parsing ) { throw new SAXException ( "Parser is already in use" ) ; } setupParser ( ) ; parsing = true ; try { parser . parse ( input ) ; } finally { parsing = false ; } parsing = false ; } public void setDocumentLocator ( Locator locator ) { this . locator = locator ; if ( contentHandler != null ) { contentHandler . setDocumentLocator ( locator ) ; } } public void startDocument ( ) throws SAXException { if ( contentHandler != null ) { contentHandler . startDocument ( ) ; } } public void endDocument ( ) throws SAXException { if ( contentHandler != null ) { contentHandler . endDocument ( ) ; } } public void startElement ( String qName , AttributeList qAtts ) throws SAXException { if ( ! namespaces ) { if ( contentHandler != null ) { attAdapter . setAttributeList ( qAtts ) ; contentHandler . startElement ( "" , "" , qName . intern ( ) , attAdapter ) ; } return ; } nsSupport . pushContext ( ) ; boolean seenDecl = false ; atts . clear ( ) ; int length = qAtts . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { String attQName = qAtts . getName ( i ) ; String type = qAtts . getType ( i ) ; String value = qAtts . getValue ( i ) ; if ( attQName . startsWith ( "xmlns" ) ) { String prefix ; int n = attQName . indexOf ( ':' ) ; if ( n == - 1 ) { prefix = "" ; } else { prefix = attQName . substring ( n + 1 ) ; } if ( ! nsSupport . declarePrefix ( prefix , value ) ) { reportError ( "Illegal Namespace prefix: " + prefix ) ; } if ( contentHandler != null ) { contentHandler . startPrefixMapping ( prefix , value ) ; } if ( prefixes ) { atts . addAttribute ( "" , "" , attQName . intern ( ) , type , value ) ; } seenDecl = true ; } else { String attName [ ] = processName ( attQName , true ) ; atts . addAttribute ( attName [ 0 ] , attName [ 1 ] , attName [ 2 ] , type , value ) ; } } if ( seenDecl ) { length = atts . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { String attQName = atts . getQName ( i ) ; if ( ! attQName . startsWith ( "xmlns" ) ) { String attName [ ] = processName ( attQName , true ) ; atts . setURI ( i , attName [ 0 ] ) ; atts . setLocalName ( i , attName [ 1 ] ) ; } } } if ( contentHandler != null ) { String name [ ] = processName ( qName , false ) ; contentHandler . startElement ( name [ 0 ] , name [ 1 ] , name [ 2 ] , atts ) ; } } public void endElement ( String qName ) throws SAXException { if ( ! namespaces ) { if ( contentHandler != null ) { contentHandler . endElement ( "" , "" , qName . intern ( ) ) ; } return ; } String names [ ] = processName ( qName , false ) ; if ( contentHandler != null ) { contentHandler . endElement ( names [ 0 ] , names [ 1 ] , names [ 2 ] ) ; Enumeration prefixes = nsSupport . getDeclaredPrefixes ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; contentHandler . endPrefixMapping ( prefix ) ; } } nsSupport . popContext ( ) ; } public void characters ( char ch [ ] , int start , int length ) throws SAXException { if ( contentHandler != null ) { contentHandler . characters ( ch , start , length ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { if ( contentHandler != null ) { contentHandler . ignorableWhitespace ( ch , start , length ) ; } } public void processingInstruction ( String target , String data ) throws SAXException { if ( contentHandler != null ) { contentHandler . processingInstruction ( target , data ) ; } } private void setupParser ( ) { nsSupport . reset ( ) ; if ( entityResolver != null ) { parser . setEntityResolver ( entityResolver ) ; } if ( dtdHandler != null ) { parser . setDTDHandler ( dtdHandler ) ; } if ( errorHandler != null ) { parser . setErrorHandler ( errorHandler ) ; } parser . setDocumentHandler ( this ) ; locator = null ; } private String [ ] processName ( String qName , boolean isAttribute ) throws SAXException { String parts [ ] = nsSupport . processName ( qName , nameParts , isAttribute ) ; if ( parts == null ) { parts = new String [ 3 ] ; parts [ 2 ] = qName . intern ( ) ; reportError ( "Undeclared prefix: " + qName ) ; } return parts ; } void reportError ( String message ) throws SAXException { if ( errorHandler == null ) { return ; } SAXParseException e ; if ( locator != null ) { e = new SAXParseException ( message , locator ) ; } else { e = new SAXParseException ( message , null , null , - 1 , - 1 ) ; } errorHandler . error ( e ) ; } private void checkNotParsing ( String type , String name ) throws SAXNotSupportedException { if ( parsing ) { throw new SAXNotSupportedException ( "Cannot change " + type + ' ' + name + " while parsing" ) ; } } private NamespaceSupport nsSupport ; private AttributeListAdapter attAdapter ; private boolean parsing = false ; private String nameParts [ ] = new String [ 3 ] ; private Parser parser = null ; private AttributesImpl atts = null ; private boolean namespaces = true ; private boolean prefixes = false ; Locator locator ; EntityResolver entityResolver = null ; DTDHandler dtdHandler = null ; ContentHandler contentHandler = null ; ErrorHandler errorHandler = null ; final class AttributeListAdapter implements Attributes { AttributeListAdapter ( ) { } void setAttributeList ( AttributeList qAtts ) { this . qAtts = qAtts ; } public int getLength ( ) { return qAtts . getLength ( ) ; } public String getURI ( int i ) { return "" ; } public String getLocalName ( int i ) { return "" ; } public String getQName ( int i ) { return qAtts . getName ( i ) . intern ( ) ; } public String getType ( int i ) { return qAtts . getType ( i ) . intern ( ) ; } public String getValue ( int i ) { return qAtts . getValue ( i ) ; } public int getIndex ( String uri , String localName ) { return - 1 ; } public int getIndex ( String qName ) { int max = atts . getLength ( ) ; for ( int i = 0 ; i < max ; i ++ ) { if ( qAtts . getName ( i ) . equals ( qName ) ) { return i ; } } return - 1 ; } public String getType ( String uri , String localName ) { return null ; } public String getType ( String qName ) { return qAtts . getType ( qName ) . intern ( ) ; } public String getValue ( String uri , String localName ) { return null ; } public String getValue ( String qName ) { return qAtts . getValue ( qName ) ; } private AttributeList qAtts ; } } 	0
package org . w3c . dom ; public interface Entity extends Node { public String getPublicId ( ) ; public String getSystemId ( ) ; public String getNotationName ( ) ; } 	1
package org . w3c . dom . html ; public interface HTMLParagraphElement extends HTMLElement { public String getAlign ( ) ; public void setAlign ( String align ) ; } 	0
package org . w3c . dom ; public interface Text extends CharacterData { public Text splitText ( int offset ) throws DOMException ; } 	1
package org . apache . wml ; public interface WMLMetaElement extends WMLElement { public void setName ( String newValue ) ; public String getName ( ) ; public void setHttpEquiv ( String newValue ) ; public String getHttpEquiv ( ) ; public void setForua ( boolean newValue ) ; public boolean getForua ( ) ; public void setScheme ( String newValue ) ; public String getScheme ( ) ; public void setContent ( String newValue ) ; public String getContent ( ) ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . Node ; public interface NodeFilter { public static final short FILTER_ACCEPT = 1 ; public static final short FILTER_REJECT = 2 ; public static final short FILTER_SKIP = 3 ; public static final int SHOW_ALL = 0xFFFFFFFF ; public static final int SHOW_ELEMENT = 0x00000001 ; public static final int SHOW_ATTRIBUTE = 0x00000002 ; public static final int SHOW_TEXT = 0x00000004 ; public static final int SHOW_CDATA_SECTION = 0x00000008 ; public static final int SHOW_ENTITY_REFERENCE = 0x00000010 ; public static final int SHOW_ENTITY = 0x00000020 ; public static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040 ; public static final int SHOW_COMMENT = 0x00000080 ; public static final int SHOW_DOCUMENT = 0x00000100 ; public static final int SHOW_DOCUMENT_TYPE = 0x00000200 ; public static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400 ; public static final int SHOW_NOTATION = 0x00000800 ; public short acceptNode ( Node n ) ; } 	1
package org . apache . wml ; public interface WMLStrongElement extends WMLElement { public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . w3c . dom ; public interface Notation extends Node { public String getPublicId ( ) ; public String getSystemId ( ) ; } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . Hash2intTable ; import org . apache . xerces . utils . QName ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . common . XMLContentModel ; import org . apache . xerces . validators . common . CMException ; import org . apache . xerces . utils . ImplementationMessages ; import org . w3c . dom . Document ; import java . util . Vector ; public class Grammar implements XMLContentSpec . Provider { private static final int CHUNK_SHIFT = 8 ; private static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; private static final int CHUNK_MASK = CHUNK_SIZE - 1 ; private static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; private static final int LIST_FLAG = 0x8000 ; private static final int LIST_MASK = ~ LIST_FLAG ; private int fTargetNamespace ; private Document fGrammarDocument ; private int fElementDeclCount = 0 ; private QName fElementDeclName [ ] [ ] = new QName [ INITIAL_CHUNK_COUNT ] [ ] ; private int fElementDeclType [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private DatatypeValidator fElementDeclDatatypeValidator [ ] [ ] = new DatatypeValidator [ INITIAL_CHUNK_COUNT ] [ ] ; private int fElementDeclContentSpecIndex [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private XMLContentModel fElementDeclContentModelValidator [ ] [ ] = new XMLContentModel [ INITIAL_CHUNK_COUNT ] [ ] ; private int fElementDeclFirstAttributeDeclIndex [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fElementDeclLastAttributeDeclIndex [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fContentSpecCount = 0 ; private int fContentSpecType [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fContentSpecValue [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fContentSpecOtherValue [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fAttributeDeclCount = 0 ; private QName fAttributeDeclName [ ] [ ] = new QName [ INITIAL_CHUNK_COUNT ] [ ] ; private int fAttributeDeclType [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fAttributeDeclEnumeration [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fAttributeDeclDefaultType [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private DatatypeValidator fAttributeDeclDatatypeValidator [ ] [ ] = new DatatypeValidator [ INITIAL_CHUNK_COUNT ] [ ] ; private String fAttributeDeclDefaultValue [ ] [ ] = new String [ INITIAL_CHUNK_COUNT ] [ ] ; private int fAttributeDeclNextAttributeDeclIndex [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private Hash2intTable fElementNameAndScopeToElementDeclIndexMapping = new Hash2intTable ( ) ; private QName fQName1 = new QName ( ) ; private QName fQName2 = new QName ( ) ; public Document getGrammarDocument ( ) { return fGrammarDocument ; } public int getElementDeclIndex ( int localpartIndex , int scopeIndex ) { if ( localpartIndex > - 1 && scopeIndex > - 2 ) { return fElementNameAndScopeToElementDeclIndexMapping . get ( - 1 , localpartIndex , scopeIndex ) ; } return - 1 ; } public int getElementDeclIndex ( int uriIndex , int localpartIndex , int scopeIndex ) { if ( localpartIndex > - 1 && scopeIndex > - 2 ) { return fElementNameAndScopeToElementDeclIndexMapping . get ( uriIndex , localpartIndex , scopeIndex ) ; } return - 1 ; } public int getElementDeclIndex ( QName element , int scopeIndex ) { if ( element . localpart > - 1 && scopeIndex > - 2 ) { return fElementNameAndScopeToElementDeclIndexMapping . get ( element . uri , element . localpart , scopeIndex ) ; } return - 1 ; } public boolean getElementDecl ( int elementDeclIndex , XMLElementDecl elementDecl ) { if ( elementDeclIndex < 0 || elementDeclIndex >= fElementDeclCount ) { return false ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; elementDecl . name . setValues ( fElementDeclName [ chunk ] [ index ] ) ; if ( fElementDeclType [ chunk ] [ index ] == - 1 ) { elementDecl . type = - 1 ; elementDecl . list = false ; } else { elementDecl . type = fElementDeclType [ chunk ] [ index ] & LIST_MASK ; elementDecl . list = ( fElementDeclType [ chunk ] [ index ] & LIST_FLAG ) != 0 ; } elementDecl . datatypeValidator = fElementDeclDatatypeValidator [ chunk ] [ index ] ; elementDecl . contentSpecIndex = fElementDeclContentSpecIndex [ chunk ] [ index ] ; return true ; } public int getFirstAttributeDeclIndex ( int elementDeclIndex ) { int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; return fElementDeclFirstAttributeDeclIndex [ chunk ] [ index ] ; } public int getNextAttributeDeclIndex ( int attributeDeclIndex ) { int chunk = attributeDeclIndex > > CHUNK_SHIFT ; int index = attributeDeclIndex & CHUNK_MASK ; return fAttributeDeclNextAttributeDeclIndex [ chunk ] [ index ] ; } public boolean getContentSpec ( int contentSpecIndex , XMLContentSpec contentSpec ) { if ( contentSpecIndex < 0 || contentSpecIndex >= fContentSpecCount ) return false ; int chunk = contentSpecIndex > > CHUNK_SHIFT ; int index = contentSpecIndex & CHUNK_MASK ; contentSpec . type = fContentSpecType [ chunk ] [ index ] ; contentSpec . value = fContentSpecValue [ chunk ] [ index ] ; contentSpec . otherValue = fContentSpecOtherValue [ chunk ] [ index ] ; return true ; } public XMLContentModel getElementContentModel ( int elementDeclIndex ) throws CMException { if ( elementDeclIndex < 0 || elementDeclIndex >= fElementDeclCount ) return null ; int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; XMLContentModel contentModel = fElementDeclContentModelValidator [ chunk ] [ index ] ; if ( contentModel != null ) return contentModel ; int contentType = fElementDeclType [ chunk ] [ index ] ; if ( contentType == XMLElementDecl . TYPE_SIMPLE ) { return null ; } int contentSpecIndex = fElementDeclContentSpecIndex [ chunk ] [ index ] ; XMLContentSpec contentSpec = new XMLContentSpec ( ) ; getContentSpec ( contentSpecIndex , contentSpec ) ; if ( contentType == XMLElementDecl . TYPE_MIXED ) { Vector vQName = new Vector ( ) ; try { ChildrenList children = new ChildrenList ( ) ; contentSpecTree ( contentSpecIndex , contentSpec , children ) ; contentModel = new MixedContentModel ( children . qname , children . type , 0 , children . length , false , isDTD ( ) ) ; } catch ( CMException ex ) { ex . printStackTrace ( ) ; } } else if ( contentType == XMLElementDecl . TYPE_CHILDREN ) { try { contentModel = createChildModel ( contentSpecIndex ) ; } catch ( CMException ex ) { ex . printStackTrace ( ) ; } } else { throw new CMException ( ImplementationMessages . VAL_CST ) ; } fElementDeclContentModelValidator [ chunk ] [ index ] = contentModel ; return contentModel ; } public boolean getAttributeDecl ( int attributeDeclIndex , XMLAttributeDecl attributeDecl ) { if ( attributeDeclIndex < 0 || attributeDeclIndex >= fAttributeDeclCount ) { return false ; } int chunk = attributeDeclIndex > > CHUNK_SHIFT ; int index = attributeDeclIndex & CHUNK_MASK ; attributeDecl . name . setValues ( fAttributeDeclName [ chunk ] [ index ] ) ; if ( fAttributeDeclType [ chunk ] [ index ] == - 1 ) { attributeDecl . type = - 1 ; attributeDecl . list = false ; } else { attributeDecl . type = fAttributeDeclType [ chunk ] [ index ] & LIST_MASK ; attributeDecl . list = ( fAttributeDeclType [ chunk ] [ index ] & LIST_FLAG ) != 0 ; } attributeDecl . datatypeValidator = fAttributeDeclDatatypeValidator [ chunk ] [ index ] ; attributeDecl . enumeration = fAttributeDeclEnumeration [ chunk ] [ index ] ; attributeDecl . defaultType = fAttributeDeclDefaultType [ chunk ] [ index ] ; attributeDecl . defaultValue = fAttributeDeclDefaultValue [ chunk ] [ index ] ; return true ; } protected void setGrammarDocument ( Document grammarDocument ) { fGrammarDocument = grammarDocument ; } protected int createElementDecl ( ) { int chunk = fElementDeclCount > > CHUNK_SHIFT ; int index = fElementDeclCount & CHUNK_MASK ; ensureElementDeclCapacity ( chunk ) ; fElementDeclName [ chunk ] [ index ] = new QName ( ) ; fElementDeclType [ chunk ] [ index ] = - 1 ; fElementDeclDatatypeValidator [ chunk ] [ index ] = null ; fElementDeclContentSpecIndex [ chunk ] [ index ] = - 1 ; fElementDeclContentModelValidator [ chunk ] [ index ] = null ; fElementDeclFirstAttributeDeclIndex [ chunk ] [ index ] = - 1 ; fElementDeclLastAttributeDeclIndex [ chunk ] [ index ] = - 1 ; return fElementDeclCount ++ ; } protected void setElementDecl ( int elementDeclIndex , XMLElementDecl elementDecl ) { if ( elementDeclIndex < 0 || elementDeclIndex >= fElementDeclCount ) { return ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; fElementDeclName [ chunk ] [ index ] . setValues ( elementDecl . name ) ; fElementDeclType [ chunk ] [ index ] = elementDecl . type ; if ( elementDecl . list ) { fElementDeclType [ chunk ] [ index ] |= LIST_FLAG ; } fElementDeclDatatypeValidator [ chunk ] [ index ] = elementDecl . datatypeValidator ; fElementDeclContentSpecIndex [ chunk ] [ index ] = elementDecl . contentSpecIndex ; putElementNameMapping ( elementDecl . name , elementDecl . enclosingScope , elementDeclIndex ) ; } protected void putElementNameMapping ( QName name , int scope , int elementDeclIndex ) { fElementNameAndScopeToElementDeclIndexMapping . put ( name . uri , name . localpart , scope , elementDeclIndex ) ; } protected void setFirstAttributeDeclIndex ( int elementDeclIndex , int newFirstAttrIndex ) { if ( elementDeclIndex < 0 || elementDeclIndex >= fElementDeclCount ) { return ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; fElementDeclFirstAttributeDeclIndex [ chunk ] [ index ] = newFirstAttrIndex ; } protected int createContentSpec ( ) { int chunk = fContentSpecCount > > CHUNK_SHIFT ; int index = fContentSpecCount & CHUNK_MASK ; ensureContentSpecCapacity ( chunk ) ; fContentSpecType [ chunk ] [ index ] = - 1 ; fContentSpecValue [ chunk ] [ index ] = - 1 ; fContentSpecOtherValue [ chunk ] [ index ] = - 1 ; return fContentSpecCount ++ ; } protected void setContentSpec ( int contentSpecIndex , XMLContentSpec contentSpec ) { int chunk = contentSpecIndex > > CHUNK_SHIFT ; int index = contentSpecIndex & CHUNK_MASK ; fContentSpecType [ chunk ] [ index ] = contentSpec . type ; fContentSpecValue [ chunk ] [ index ] = contentSpec . value ; fContentSpecOtherValue [ chunk ] [ index ] = contentSpec . otherValue ; } protected int createAttributeDecl ( ) { int chunk = fAttributeDeclCount > > CHUNK_SHIFT ; int index = fAttributeDeclCount & CHUNK_MASK ; ensureAttributeDeclCapacity ( chunk ) ; fAttributeDeclName [ chunk ] [ index ] = new QName ( ) ; fAttributeDeclType [ chunk ] [ index ] = - 1 ; fAttributeDeclDatatypeValidator [ chunk ] [ index ] = null ; fAttributeDeclEnumeration [ chunk ] [ index ] = - 1 ; fAttributeDeclDefaultType [ chunk ] [ index ] = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; fAttributeDeclDefaultValue [ chunk ] [ index ] = null ; fAttributeDeclNextAttributeDeclIndex [ chunk ] [ index ] = - 1 ; return fAttributeDeclCount ++ ; } protected void setAttributeDecl ( int elementDeclIndex , int attributeDeclIndex , XMLAttributeDecl attributeDecl ) { int attrChunk = attributeDeclIndex > > CHUNK_SHIFT ; int attrIndex = attributeDeclIndex & CHUNK_MASK ; fAttributeDeclName [ attrChunk ] [ attrIndex ] . setValues ( attributeDecl . name ) ; fAttributeDeclType [ attrChunk ] [ attrIndex ] = attributeDecl . type ; if ( attributeDecl . list ) { fAttributeDeclType [ attrChunk ] [ attrIndex ] |= LIST_FLAG ; } fAttributeDeclEnumeration [ attrChunk ] [ attrIndex ] = attributeDecl . enumeration ; fAttributeDeclDefaultType [ attrChunk ] [ attrIndex ] = attributeDecl . defaultType ; fAttributeDeclDatatypeValidator [ attrChunk ] [ attrIndex ] = attributeDecl . datatypeValidator ; fAttributeDeclDefaultValue [ attrChunk ] [ attrIndex ] = attributeDecl . defaultValue ; int elemChunk = elementDeclIndex > > CHUNK_SHIFT ; int elemIndex = elementDeclIndex & CHUNK_MASK ; int index = fElementDeclFirstAttributeDeclIndex [ elemChunk ] [ elemIndex ] ; while ( index != - 1 ) { if ( index == attributeDeclIndex ) { break ; } attrChunk = index > > CHUNK_SHIFT ; attrIndex = index & CHUNK_MASK ; index = fAttributeDeclNextAttributeDeclIndex [ attrChunk ] [ attrIndex ] ; } if ( index == - 1 ) { if ( fElementDeclFirstAttributeDeclIndex [ elemChunk ] [ elemIndex ] == - 1 ) { fElementDeclFirstAttributeDeclIndex [ elemChunk ] [ elemIndex ] = attributeDeclIndex ; } else { index = fElementDeclLastAttributeDeclIndex [ elemChunk ] [ elemIndex ] ; attrChunk = index > > CHUNK_SHIFT ; attrIndex = index & CHUNK_MASK ; fAttributeDeclNextAttributeDeclIndex [ attrChunk ] [ attrIndex ] = attributeDeclIndex ; } fElementDeclLastAttributeDeclIndex [ elemChunk ] [ elemIndex ] = attributeDeclIndex ; } } protected boolean isDTD ( ) { return false ; } public void printElements ( org . apache . xerces . utils . StringPool pool ) { int elementDeclIndex = 0 ; XMLElementDecl elementDecl = new XMLElementDecl ( ) ; while ( getElementDecl ( elementDeclIndex ++ , elementDecl ) ) { System . out . println ( "element decl: " + elementDecl . name + ", " + pool . toString ( elementDecl . name . rawname ) + ", " + XMLContentSpec . toString ( this , pool , elementDecl . contentSpecIndex ) ) ; } } public void printAttributes ( int elementDeclIndex ) { int attributeDeclIndex = getFirstAttributeDeclIndex ( elementDeclIndex ) ; System . out . print ( elementDeclIndex ) ; System . out . print ( " [" ) ; while ( attributeDeclIndex != - 1 ) { System . out . print ( ' ' ) ; System . out . print ( attributeDeclIndex ) ; printAttribute ( attributeDeclIndex ) ; attributeDeclIndex = getNextAttributeDeclIndex ( attributeDeclIndex ) ; if ( attributeDeclIndex != - 1 ) { System . out . print ( "," ) ; } } System . out . println ( " ]" ) ; } private void printAttribute ( int attributeDeclIndex ) { XMLAttributeDecl attributeDecl = new XMLAttributeDecl ( ) ; if ( getAttributeDecl ( attributeDeclIndex , attributeDecl ) ) { System . out . print ( " { " ) ; System . out . print ( attributeDecl . name . localpart ) ; System . out . print ( " }" ) ; } } private final XMLContentModel createChildModel ( int contentSpecIndex ) throws CMException { XMLContentSpec contentSpec = new XMLContentSpec ( ) ; getContentSpec ( contentSpecIndex , contentSpec ) ; if ( ( contentSpec . type & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY || ( contentSpec . type & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER || ( contentSpec . type & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { } else if ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( contentSpec . value == - 1 && contentSpec . otherValue == - 1 ) throw new CMException ( ImplementationMessages . VAL_NPCD ) ; fQName1 . setValues ( - 1 , contentSpec . value , contentSpec . value , contentSpec . otherValue ) ; return new SimpleContentModel ( fQName1 , null , contentSpec . type , isDTD ( ) ) ; } else if ( ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { XMLContentSpec contentSpecLeft = new XMLContentSpec ( ) ; XMLContentSpec contentSpecRight = new XMLContentSpec ( ) ; getContentSpec ( contentSpec . value , contentSpecLeft ) ; getContentSpec ( contentSpec . otherValue , contentSpecRight ) ; if ( ( contentSpecLeft . type == XMLContentSpec . CONTENTSPECNODE_LEAF ) && ( contentSpecRight . type == XMLContentSpec . CONTENTSPECNODE_LEAF ) ) { fQName1 . setValues ( - 1 , contentSpecLeft . value , contentSpecLeft . value , contentSpecLeft . otherValue ) ; fQName2 . setValues ( - 1 , contentSpecRight . value , contentSpecRight . value , contentSpecRight . otherValue ) ; return new SimpleContentModel ( fQName1 , fQName2 , contentSpec . type , isDTD ( ) ) ; } } else if ( ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) || ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) || ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) ) { XMLContentSpec contentSpecLeft = new XMLContentSpec ( ) ; getContentSpec ( contentSpec . value , contentSpecLeft ) ; if ( contentSpecLeft . type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { fQName1 . setValues ( - 1 , contentSpecLeft . value , contentSpecLeft . value , contentSpecLeft . otherValue ) ; return new SimpleContentModel ( fQName1 , null , contentSpec . type , isDTD ( ) ) ; } } else { throw new CMException ( ImplementationMessages . VAL_CST ) ; } fLeafCount = 0 ; CMNode cmn = buildSyntaxTree ( contentSpecIndex , contentSpec ) ; return new DFAContentModel ( cmn , fLeafCount , isDTD ( ) ) ; } private void printSyntaxTree ( CMNode cmn ) { System . out . println ( "CMNode : " + cmn . type ( ) ) ; if ( cmn . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { System . out . println ( "     Leaf: " + ( ( CMLeaf ) cmn ) . getElement ( ) ) ; return ; } if ( cmn instanceof CMBinOp ) { printSyntaxTree ( ( ( CMBinOp ) cmn ) . getLeft ( ) ) ; printSyntaxTree ( ( ( CMBinOp ) cmn ) . getRight ( ) ) ; } if ( cmn instanceof CMUniOp ) { printSyntaxTree ( ( ( CMUniOp ) cmn ) . getChild ( ) ) ; } } private int countLeaves ( int contentSpecIndex ) { return countLeaves ( contentSpecIndex , new XMLContentSpec ( ) ) ; } private int countLeaves ( int contentSpecIndex , XMLContentSpec contentSpec ) { if ( contentSpecIndex == - 1 ) { return 0 ; } getContentSpec ( contentSpecIndex , contentSpec ) ; if ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { return 1 ; } int value = contentSpec . value ; int otherValue = contentSpec . otherValue ; return countLeaves ( value , contentSpec ) + countLeaves ( otherValue , contentSpec ) ; } private int fLeafCount = 0 ; private int fEpsilonIndex = - 1 ; private final CMNode buildSyntaxTree ( int startNode , XMLContentSpec contentSpec ) throws CMException { CMNode nodeRet = null ; getContentSpec ( startNode , contentSpec ) ; if ( ( contentSpec . type & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY ) { nodeRet = new CMAny ( contentSpec . type , contentSpec . otherValue , fLeafCount ++ ) ; } else if ( ( contentSpec . type & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { nodeRet = new CMAny ( contentSpec . type , contentSpec . otherValue , fLeafCount ++ ) ; } else if ( ( contentSpec . type & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { nodeRet = new CMAny ( contentSpec . type , - 1 , fLeafCount ++ ) ; } else if ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { fQName1 . setValues ( - 1 , contentSpec . value , contentSpec . value , contentSpec . otherValue ) ; nodeRet = new CMLeaf ( fQName1 , fLeafCount ++ ) ; } else { final int leftNode = contentSpec . value ; final int rightNode = contentSpec . otherValue ; if ( ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { nodeRet = new CMBinOp ( contentSpec . type , buildSyntaxTree ( leftNode , contentSpec ) , buildSyntaxTree ( rightNode , contentSpec ) ) ; } else if ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { nodeRet = new CMUniOp ( contentSpec . type , buildSyntaxTree ( leftNode , contentSpec ) ) ; } else if ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) { nodeRet = new CMBinOp ( XMLContentSpec . CONTENTSPECNODE_CHOICE , buildSyntaxTree ( leftNode , contentSpec ) , new CMLeaf ( new QName ( - 1 , - 2 , - 2 , - 1 ) , fEpsilonIndex ) ) ; } else if ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) { nodeRet = new CMBinOp ( XMLContentSpec . CONTENTSPECNODE_SEQ , buildSyntaxTree ( leftNode , contentSpec ) , new CMUniOp ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , buildSyntaxTree ( leftNode , contentSpec ) ) ) ; } else { throw new CMException ( ImplementationMessages . VAL_CST ) ; } } return nodeRet ; } private void contentSpecTree ( int contentSpecIndex , XMLContentSpec contentSpec , ChildrenList children ) throws CMException { getContentSpec ( contentSpecIndex , contentSpec ) ; if ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_LEAF || contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ANY || contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL || contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( children . length == children . qname . length ) { QName [ ] newQName = new QName [ children . length * 2 ] ; System . arraycopy ( children . qname , 0 , newQName , 0 , children . length ) ; children . qname = newQName ; int [ ] newType = new int [ children . length * 2 ] ; System . arraycopy ( children . type , 0 , newType , 0 , children . length ) ; children . type = newType ; } children . qname [ children . length ] = new QName ( - 1 , contentSpec . value , contentSpec . value , contentSpec . otherValue ) ; children . type [ children . length ] = contentSpec . type ; children . length ++ ; return ; } final int leftNode = contentSpec . value ; final int rightNode = contentSpec . otherValue ; if ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_CHOICE || contentSpec . type == XMLContentSpec . CONTENTSPECNODE_SEQ ) { contentSpecTree ( leftNode , contentSpec , children ) ; contentSpecTree ( rightNode , contentSpec , children ) ; return ; } if ( contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE || contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE || contentSpec . type == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) { contentSpecTree ( leftNode , contentSpec , children ) ; return ; } throw new CMException ( ImplementationMessages . VAL_CST ) ; } private boolean ensureElementDeclCapacity ( int chunk ) { try { return fElementDeclName [ chunk ] [ 0 ] == null ; } catch ( ArrayIndexOutOfBoundsException ex ) { fElementDeclName = resize ( fElementDeclName , fElementDeclName . length * 2 ) ; fElementDeclType = resize ( fElementDeclType , fElementDeclType . length * 2 ) ; fElementDeclDatatypeValidator = resize ( fElementDeclDatatypeValidator , fElementDeclDatatypeValidator . length * 2 ) ; fElementDeclContentSpecIndex = resize ( fElementDeclContentSpecIndex , fElementDeclContentSpecIndex . length * 2 ) ; fElementDeclContentModelValidator = resize ( fElementDeclContentModelValidator , fElementDeclContentModelValidator . length * 2 ) ; fElementDeclFirstAttributeDeclIndex = resize ( fElementDeclFirstAttributeDeclIndex , fElementDeclFirstAttributeDeclIndex . length * 2 ) ; fElementDeclLastAttributeDeclIndex = resize ( fElementDeclLastAttributeDeclIndex , fElementDeclLastAttributeDeclIndex . length * 2 ) ; } catch ( NullPointerException ex ) { } fElementDeclName [ chunk ] = new QName [ CHUNK_SIZE ] ; fElementDeclType [ chunk ] = new int [ CHUNK_SIZE ] ; fElementDeclDatatypeValidator [ chunk ] = new DatatypeValidator [ CHUNK_SIZE ] ; fElementDeclContentSpecIndex [ chunk ] = new int [ CHUNK_SIZE ] ; fElementDeclContentModelValidator [ chunk ] = new XMLContentModel [ CHUNK_SIZE ] ; fElementDeclFirstAttributeDeclIndex [ chunk ] = new int [ CHUNK_SIZE ] ; fElementDeclLastAttributeDeclIndex [ chunk ] = new int [ CHUNK_SIZE ] ; return true ; } private boolean ensureContentSpecCapacity ( int chunk ) { try { return fContentSpecType [ chunk ] [ 0 ] == 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { fContentSpecType = resize ( fContentSpecType , fContentSpecType . length * 2 ) ; fContentSpecValue = resize ( fContentSpecValue , fContentSpecValue . length * 2 ) ; fContentSpecOtherValue = resize ( fContentSpecOtherValue , fContentSpecOtherValue . length * 2 ) ; } catch ( NullPointerException ex ) { } fContentSpecType [ chunk ] = new int [ CHUNK_SIZE ] ; fContentSpecValue [ chunk ] = new int [ CHUNK_SIZE ] ; fContentSpecOtherValue [ chunk ] = new int [ CHUNK_SIZE ] ; return true ; } private boolean ensureAttributeDeclCapacity ( int chunk ) { try { return fAttributeDeclName [ chunk ] [ 0 ] == null ; } catch ( ArrayIndexOutOfBoundsException ex ) { fAttributeDeclName = resize ( fAttributeDeclName , fAttributeDeclName . length * 2 ) ; fAttributeDeclType = resize ( fAttributeDeclType , fAttributeDeclType . length * 2 ) ; fAttributeDeclEnumeration = resize ( fAttributeDeclEnumeration , fAttributeDeclEnumeration . length * 2 ) ; fAttributeDeclDefaultType = resize ( fAttributeDeclDefaultType , fAttributeDeclDefaultType . length * 2 ) ; fAttributeDeclDatatypeValidator = resize ( fAttributeDeclDatatypeValidator , fAttributeDeclDatatypeValidator . length * 2 ) ; fAttributeDeclDefaultValue = resize ( fAttributeDeclDefaultValue , fAttributeDeclDefaultValue . length * 2 ) ; fAttributeDeclNextAttributeDeclIndex = resize ( fAttributeDeclNextAttributeDeclIndex , fAttributeDeclNextAttributeDeclIndex . length * 2 ) ; } catch ( NullPointerException ex ) { } fAttributeDeclName [ chunk ] = new QName [ CHUNK_SIZE ] ; fAttributeDeclType [ chunk ] = new int [ CHUNK_SIZE ] ; fAttributeDeclEnumeration [ chunk ] = new int [ CHUNK_SIZE ] ; fAttributeDeclDefaultType [ chunk ] = new int [ CHUNK_SIZE ] ; fAttributeDeclDatatypeValidator [ chunk ] = new DatatypeValidator [ CHUNK_SIZE ] ; fAttributeDeclDefaultValue [ chunk ] = new String [ CHUNK_SIZE ] ; fAttributeDeclNextAttributeDeclIndex [ chunk ] = new int [ CHUNK_SIZE ] ; return true ; } private int [ ] [ ] resize ( int array [ ] [ ] , int newsize ) { int newarray [ ] [ ] = new int [ newsize ] [ ] ; System . arraycopy ( array , 0 , newarray , 0 , array . length ) ; return newarray ; } private DatatypeValidator [ ] [ ] resize ( DatatypeValidator array [ ] [ ] , int newsize ) { DatatypeValidator newarray [ ] [ ] = new DatatypeValidator [ newsize ] [ ] ; System . arraycopy ( array , 0 , newarray , 0 , array . length ) ; return newarray ; } private XMLContentModel [ ] [ ] resize ( XMLContentModel array [ ] [ ] , int newsize ) { XMLContentModel newarray [ ] [ ] = new XMLContentModel [ newsize ] [ ] ; System . arraycopy ( array , 0 , newarray , 0 , array . length ) ; return newarray ; } private QName [ ] [ ] resize ( QName array [ ] [ ] , int newsize ) { QName newarray [ ] [ ] = new QName [ newsize ] [ ] ; System . arraycopy ( array , 0 , newarray , 0 , array . length ) ; return newarray ; } private String [ ] [ ] resize ( String array [ ] [ ] , int newsize ) { String newarray [ ] [ ] = new String [ newsize ] [ ] ; System . arraycopy ( array , 0 , newarray , 0 , array . length ) ; return newarray ; } static class ChildrenList { public int length = 0 ; public QName [ ] qname = new QName [ 2 ] ; public int [ ] type = new int [ 2 ] ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public abstract class CharacterDataImpl extends ChildNode { static final long serialVersionUID = 7931170150428474230L ; protected String data ; private static transient NodeList singletonNodeList = new NodeList ( ) { public Node item ( int index ) { return null ; } public int getLength ( ) { return 0 ; } } ; protected CharacterDataImpl ( DocumentImpl ownerDocument , String data ) { super ( ownerDocument ) ; this . data = data ; } public NodeList getChildNodes ( ) { return singletonNodeList ; } public String getNodeValue ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } void setNodeValueInternal ( String value ) { setValueCalled ( true ) ; setNodeValue ( value ) ; setValueCalled ( false ) ; } public void setNodeValue ( String value ) { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; if ( needsSyncData ( ) ) { synchronizeData ( ) ; } String oldvalue = value ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } this . data = value ; if ( ! setValueCalled ( ) ) { ownerDocument ( ) . replacedText ( this ) ; } if ( MUTATIONEVENTS ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_CHARACTER_DATA_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_CHARACTER_DATA_MODIFIED , true , false , null , oldvalue , value , null ) ; dispatchEvent ( me ) ; } dispatchAggregateEvents ( enclosingAttr ) ; } } public String getData ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } public int getLength ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data . length ( ) ; } public void appendData ( String data ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } setNodeValue ( this . data + data ) ; } public void deleteData ( int offset , int count ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( count < 0 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int tailLength = Math . max ( data . length ( ) - count - offset , 0 ) ; try { setNodeValueInternal ( data . substring ( 0 , offset ) + ( tailLength > 0 ? data . substring ( offset + count , offset + count + tailLength ) : "" ) ) ; ownerDocument ( ) . deletedText ( this , offset , count ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } public void insertData ( int offset , String data ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } try { setNodeValueInternal ( new StringBuffer ( this . data ) . insert ( offset , data ) . toString ( ) ) ; ownerDocument ( ) . insertedText ( this , offset , data . length ( ) ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } public void replaceData ( int offset , int count , String data ) throws DOMException { deleteData ( offset , count ) ; insertData ( offset , data ) ; } public void setData ( String value ) throws DOMException { setNodeValue ( value ) ; } public String substringData ( int offset , int count ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int length = data . length ( ) ; if ( count < 0 || offset < 0 || offset > length - 1 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } int tailIndex = Math . min ( offset + count , length ) ; return data . substring ( offset , tailIndex ) ; } } 	1
package org . apache . xerces . validators . datatype ; public class XMLException extends Exception { public XMLException ( ) { } public XMLException ( String message ) { super ( message ) ; } public XMLException ( Exception exception ) { } public XMLException ( String message , Exception exception ) { } public Exception getException ( ) { return null ; } } 	0
package org . apache . xerces . jaxp ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . xml . sax . SAXException ; public class DocumentBuilderFactoryImpl extends DocumentBuilderFactory { public DocumentBuilderFactoryImpl ( ) { super ( ) ; } public DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException { return ( new DocumentBuilderImpl ( this . isNamespaceAware ( ) , this . isValidating ( ) ) ) ; } } 	1
package org . apache . xml . serialize ; import java . io . OutputStream ; import java . io . Writer ; import java . io . UnsupportedEncodingException ; final class SerializerFactoryImpl extends SerializerFactory { private String _method ; SerializerFactoryImpl ( String method ) { _method = method ; if ( ! _method . equals ( Method . XML ) && ! _method . equals ( Method . HTML ) && ! _method . equals ( Method . XHTML ) && ! _method . equals ( Method . TEXT ) ) throw new IllegalArgumentException ( "SER004 The method '" + method + "' is not supported by this factory\n" + method ) ; } public Serializer makeSerializer ( OutputFormat format ) { Serializer serializer ; serializer = getSerializer ( format ) ; serializer . setOutputFormat ( format ) ; return serializer ; } public Serializer makeSerializer ( Writer writer , OutputFormat format ) { Serializer serializer ; serializer = getSerializer ( format ) ; serializer . setOutputCharStream ( writer ) ; return serializer ; } public Serializer makeSerializer ( OutputStream output , OutputFormat format ) throws UnsupportedEncodingException { Serializer serializer ; serializer = getSerializer ( format ) ; serializer . setOutputByteStream ( output ) ; return serializer ; } private Serializer getSerializer ( OutputFormat format ) { if ( _method . equals ( Method . XML ) ) { return new XMLSerializer ( format ) ; } else if ( _method . equals ( Method . HTML ) ) { return new HTMLSerializer ( format ) ; } else if ( _method . equals ( Method . XHTML ) ) { return new XHTMLSerializer ( format ) ; } else if ( _method . equals ( Method . TEXT ) ) { return new TextSerializer ( ) ; } else { throw new IllegalStateException ( "SER005 The method '" + _method + "' is not supported by this factory\n" + _method ) ; } } protected String getSupportedMethod ( ) { return _method ; } } 	0
package org . apache . xerces . parsers ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . xml . sax . Attributes ; import org . xml . sax . AttributeList ; import org . xml . sax . ContentHandler ; import org . xml . sax . DocumentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . Parser ; import org . xml . sax . XMLReader ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . AttributesImpl ; public class SAXParser extends XMLParser implements XMLDocumentHandler , XMLDocumentHandler . DTDHandler , Parser , XMLReader { private static final String RECOGNIZED_FEATURES [ ] = { "http://xml.org/sax/features/namespace-prefixes" , "http://xml.org/sax/features/string-interning" , } ; private static final String RECOGNIZED_PROPERTIES [ ] = { "http://xml.org/sax/properties/lexical-handler" , "http://xml.org/sax/properties/declaration-handler" , "http://xml.org/sax/properties/dom-node" , } ; private static final boolean DEBUG_CALLBACKS = false ; private DocumentHandler fDocumentHandler ; private org . xml . sax . DTDHandler fDTDHandler ; private ContentHandler fContentHandler ; private DeclHandler fDeclHandler ; private LexicalHandler fLexicalHandler ; private boolean fNamespacePrefixes = false ; private transient AttributesImpl fAttributes = new AttributesImpl ( ) ; public SAXParser ( ) { initHandlers ( true , this , this ) ; } public String [ ] getFeaturesRecognized ( ) { String superRecognized [ ] = super . getFeaturesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_FEATURES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } public String [ ] getPropertiesRecognized ( ) { String superRecognized [ ] = super . getPropertiesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_PROPERTIES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } protected void setDeclHandler ( DeclHandler handler ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR011 Feature: http://xml.org/sax/properties/declaration-handler" + " is not supported during parse." + "\nhttp://xml.org/sax/properties/declaration-handler" ) ; } fDeclHandler = handler ; } protected DeclHandler getDeclHandler ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fDeclHandler ; } protected void setLexicalHandler ( LexicalHandler handler ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR011 Feature: http://xml.org/sax/properties/lexical-handler" + " is not supported during parse." + "\nhttp://xml.org/sax/properties/lexical-handler" ) ; } fLexicalHandler = handler ; } protected LexicalHandler getLexicalHandler ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fLexicalHandler ; } public void setDocumentHandler ( DocumentHandler handler ) { fDocumentHandler = handler ; } public void setDTDHandler ( org . xml . sax . DTDHandler handler ) { fDTDHandler = handler ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return fDTDHandler ; } protected void setNamespacePrefixes ( boolean process ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR004 Cannot setFeature(http://xml.org/sax/features/namespace-prefixes): parse is in progress.\n" + "http://xml.org/sax/features/namespace-prefixes" ) ; } fNamespacePrefixes = process ; } protected boolean getNamespacePrefixes ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fNamespacePrefixes ; } public void setFeature ( String featureId , boolean state ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "namespace-prefixes" ) ) { setNamespacePrefixes ( state ) ; return ; } if ( feature . equals ( "string-interning" ) ) { if ( state ) { throw new SAXNotSupportedException ( "PAR018 " + state + " state for feature \"" + featureId + "\" is not supported.\n" + state + '\t' + featureId ) ; } return ; } } super . setFeature ( featureId , state ) ; } public boolean getFeature ( String featureId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "namespace-prefixes" ) ) { return getNamespacePrefixes ( ) ; } if ( feature . equals ( "string-interning" ) ) { return false ; } } return super . getFeature ( featureId ) ; } public void setProperty ( String propertyId , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "lexical-handler" ) ) { try { setLexicalHandler ( ( LexicalHandler ) value ) ; } catch ( ClassCastException e ) { throw new SAXNotSupportedException ( "PAR012 For propertyID \"" + propertyId + "\", the value \"" + value + "\" cannot be cast to LexicalHandler." + '\n' + propertyId + '\t' + value + "\tLexicalHandler" ) ; } return ; } if ( property . equals ( "declaration-handler" ) ) { try { setDeclHandler ( ( DeclHandler ) value ) ; } catch ( ClassCastException e ) { throw new SAXNotSupportedException ( "PAR012 For propertyID \"" + propertyId + "\", the value \"" + value + "\" cannot be cast to DeclHandler." + '\n' + propertyId + '\t' + value + "\tDeclHandler" ) ; } return ; } if ( property . equals ( "dom-node" ) ) { throw new SAXNotSupportedException ( "PAR013 Property \"" + propertyId + "\" is read only." + '\n' + propertyId ) ; } } super . setProperty ( propertyId , value ) ; } public Object getProperty ( String propertyId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "lexical-handler" ) ) { return getLexicalHandler ( ) ; } if ( property . equals ( "declaration-handler" ) ) { return getDeclHandler ( ) ; } if ( property . equals ( "dom-node" ) ) { throw new SAXNotSupportedException ( "PAR014 Cannot getProperty(\"" + propertyId + "\". No DOM Tree exists.\n" + propertyId ) ; } } return super . getProperty ( propertyId ) ; } public void setContentHandler ( ContentHandler handler ) { if ( handler == null ) { throw new NullPointerException ( ) ; } fContentHandler = handler ; } public ContentHandler getContentHandler ( ) { return fContentHandler ; } public void startDTD ( QName rootElement , int publicId , int systemId ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( rootElement . rawname ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "startDTD(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startDTD ( name , pubid , sysid ) ; } } } public void endDTD ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endDTD()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endDTD ( ) ; } } public void elementDecl ( QName elementDecl , int contentSpecType , int contentSpecIndex , XMLContentSpec . Provider contentSpecProvider ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( elementDecl . rawname ) ; String contentModel ; if ( contentSpecType == XMLElementDecl . TYPE_ANY ) { contentModel = "ANY" ; } else if ( contentSpecType == XMLElementDecl . TYPE_EMPTY ) { contentModel = "EMPTY" ; } else { contentModel = XMLContentSpec . toString ( contentSpecProvider , fStringPool , contentSpecIndex ) ; } if ( DEBUG_CALLBACKS ) { System . err . println ( "elementDecl(" + name + ", " + contentModel + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . elementDecl ( name , contentModel ) ; } } } public void attlistDecl ( QName elementDecl , QName attributeDecl , int attType , boolean attList , String enumString , int attDefaultType , int attDefaultValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String eName = fStringPool . toString ( elementDecl . rawname ) ; String aName = fStringPool . toString ( attributeDecl . rawname ) ; String aType = enumString ; if ( attType != XMLAttributeDecl . TYPE_ENUMERATION ) { switch ( attType ) { case XMLAttributeDecl . TYPE_CDATA : { aType = "CDATA" ; break ; } case XMLAttributeDecl . TYPE_ENTITY : { aType = attList ? "ENTITIES" : "ENTITY" ; break ; } case XMLAttributeDecl . TYPE_ID : { aType = "ID" ; break ; } case XMLAttributeDecl . TYPE_IDREF : { aType = attList ? "IDREFS" : "IDREF" ; break ; } case XMLAttributeDecl . TYPE_NMTOKEN : { aType = attList ? "NMTOKENS" : "NMTOKEN" ; break ; } case XMLAttributeDecl . TYPE_NOTATION : { aType = "NOTATION" ; break ; } } } String aDefaultType = "" ; switch ( attDefaultType ) { case XMLAttributeDecl . DEFAULT_TYPE_FIXED : { aDefaultType = "#FIXED" ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_IMPLIED : { aDefaultType = "#IMPLIED" ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_REQUIRED : { aDefaultType = "#REQUIRED" ; break ; } } String aDefaultValue = fStringPool . toString ( attDefaultValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "attributeDecl(" + eName + ", " + aName + ", " + aType + ", " + aDefaultType + ", " + aDefaultValue + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . attributeDecl ( eName , aName , aType , aDefaultType , aDefaultValue ) ; } } } public void internalPEDecl ( int entityName , int entityValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = "%" + fStringPool . toString ( entityName ) ; String value = fStringPool . toString ( entityValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "internalEntityDecl(" + name + ", " + value + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , value ) ; } } } public void externalPEDecl ( int entityName , int publicId , int systemId ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = "%" + fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "externalEntityDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . externalEntityDecl ( name , pubid , sysid ) ; } } } public void internalEntityDecl ( int entityName , int entityValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String value = fStringPool . toString ( entityValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "internalEntityDecl(" + name + ", " + value + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , value ) ; } } } public void externalEntityDecl ( int entityName , int publicId , int systemId ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "externalEntityDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . externalEntityDecl ( name , pubid , sysid ) ; } } } public void unparsedEntityDecl ( int entityName , int publicId , int systemId , int notationName ) throws Exception { if ( fDTDHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; String notation = fStringPool . toString ( notationName ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "unparsedEntityDecl(" + name + ", " + pubid + ", " + sysid + ", " + notation + ")" ) ; } if ( fDTDHandler != null ) { fDTDHandler . unparsedEntityDecl ( name , pubid , sysid , notation ) ; } } } public void notationDecl ( int notationName , int publicId , int systemId ) throws Exception { if ( fDTDHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( notationName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "notationDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDTDHandler != null ) { fDTDHandler . notationDecl ( name , pubid , sysid ) ; } } } public void startDocument ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "setDocumentLocator(<locator>)" ) ; System . err . println ( "startDocument()" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . setDocumentLocator ( getLocator ( ) ) ; fDocumentHandler . startDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . setDocumentLocator ( getLocator ( ) ) ; fContentHandler . startDocument ( ) ; } } public void endDocument ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endDocument()" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . endDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . endDocument ( ) ; } } public void xmlDecl ( int versionIndex , int encodingIndex , int standaloneIndex ) throws Exception { if ( DEBUG_CALLBACKS ) { String notes = "" ; if ( versionIndex != - 1 ) notes += " version='" + fStringPool . toString ( versionIndex ) + "'" ; if ( encodingIndex != - 1 ) notes += " encoding='" + fStringPool . toString ( encodingIndex ) + "'" ; if ( standaloneIndex != - 1 ) notes += " standalone='" + fStringPool . toString ( standaloneIndex ) + "'" ; System . err . println ( "xmlDecl(<?xml" + notes + "?>)" ) ; } fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; fStringPool . releaseString ( standaloneIndex ) ; } public void textDecl ( int versionIndex , int encodingIndex ) throws Exception { if ( DEBUG_CALLBACKS ) { String notes = "" ; if ( versionIndex != - 1 ) notes += " version='" + fStringPool . toString ( versionIndex ) + "'" ; if ( encodingIndex != - 1 ) notes += " encoding='" + fStringPool . toString ( encodingIndex ) + "'" ; System . err . println ( "textDecl(<?xml" + notes + "?>)" ) ; } fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { if ( fContentHandler != null || DEBUG_CALLBACKS ) { String p = fStringPool . toString ( prefix ) ; String ns = fStringPool . toString ( uri ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "startNamespaceDeclScope(" + p + ", " + ns + ")" ) ; } if ( fContentHandler != null ) { fContentHandler . startPrefixMapping ( p , ns ) ; } } } public void endNamespaceDeclScope ( int prefix ) throws Exception { if ( fContentHandler != null || DEBUG_CALLBACKS ) { String p = fStringPool . toString ( prefix ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "endNamespaceDeclScope(" + p + ")" ) ; } if ( fContentHandler != null ) { fContentHandler . endPrefixMapping ( p ) ; } } } public void internalSubset ( int internalSubset ) { } public void startElement ( QName element , XMLAttrList attrList , int attrListIndex ) throws Exception { String name = fStringPool . toString ( element . rawname ) ; AttributeList attrs = attrList . getAttributeList ( attrListIndex ) ; if ( DEBUG_CALLBACKS ) { String atts = attrs . getLength ( ) > 0 ? "" : " " ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { atts += " " + attrs . getName ( i ) + "='" + attrs . getValue ( i ) + "'" ; } System . err . println ( "startElement(" + name + "," + atts + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . startElement ( name , attrs ) ; } if ( fContentHandler != null ) { boolean namespaces = getNamespaces ( ) ; int uriIndex = element . uri ; String uri = uriIndex != - 1 && namespaces ? fStringPool . toString ( uriIndex ) : "" ; int localIndex = element . localpart ; String local = localIndex != - 1 && namespaces ? fStringPool . toString ( localIndex ) : "" ; String raw = name ; fAttributes . clear ( ) ; for ( int attrIndex = attrList . getFirstAttr ( attrListIndex ) ; attrIndex != - 1 ; attrIndex = attrList . getNextAttr ( attrIndex ) ) { int attrNameIndex = attrList . getAttrName ( attrIndex ) ; int attrUriIndex = attrList . getAttrURI ( attrIndex ) ; String attrUri = attrUriIndex != - 1 && namespaces ? fStringPool . toString ( attrUriIndex ) : "" ; int attrLocalIndex = attrList . getAttrLocalpart ( attrIndex ) ; String attrLocal = attrLocalIndex != - 1 && namespaces ? fStringPool . toString ( attrLocalIndex ) : "" ; String attrRaw = fStringPool . toString ( attrNameIndex ) ; String attrType = fStringPool . toString ( attrList . getAttType ( attrIndex ) ) ; String attrValue = fStringPool . toString ( attrList . getAttValue ( attrIndex ) ) ; int attrPrefix = attrList . getAttrPrefix ( attrIndex ) ; boolean namespacePrefixes = getNamespacePrefixes ( ) ; if ( ! namespaces || namespacePrefixes || ( attrPrefix != fStringPool . addSymbol ( "xmlns" ) && attrLocalIndex != fStringPool . addSymbol ( "xmlns" ) ) ) fAttributes . addAttribute ( attrUri , attrLocal , attrRaw , attrType , attrValue ) ; } fContentHandler . startElement ( uri , local , raw , fAttributes ) ; } attrList . releaseAttrList ( attrListIndex ) ; } public void endElement ( QName element ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endElement(" + fStringPool . toString ( element . rawname ) + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . endElement ( fStringPool . toString ( element . rawname ) ) ; } if ( fContentHandler != null ) { boolean namespaces = getNamespaces ( ) ; int uriIndex = element . uri ; String uri = uriIndex != - 1 && namespaces ? fStringPool . toString ( uriIndex ) : "" ; int localIndex = element . localpart ; String local = localIndex != - 1 && namespaces ? fStringPool . toString ( localIndex ) : "" ; String raw = fStringPool . toString ( element . rawname ) ; fContentHandler . endElement ( uri , local , raw ) ; } } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { switch ( entityType ) { case XMLEntityHandler . ENTITYTYPE_INTERNAL_PE : case XMLEntityHandler . ENTITYTYPE_EXTERNAL_PE : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(%" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( "%" + fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_INTERNAL : case XMLEntityHandler . ENTITYTYPE_EXTERNAL : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_UNPARSED : throw new RuntimeException ( "PAR015 startEntityReference(): ENTITYTYPE_UNPARSED" ) ; case XMLEntityHandler . ENTITYTYPE_DOCUMENT : break ; case XMLEntityHandler . ENTITYTYPE_EXTERNAL_SUBSET : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(\"[dtd]\")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( "[dtd]" ) ; } break ; } } } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { switch ( entityType ) { case XMLEntityHandler . ENTITYTYPE_INTERNAL_PE : case XMLEntityHandler . ENTITYTYPE_EXTERNAL_PE : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(%" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( "%" + fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_INTERNAL : case XMLEntityHandler . ENTITYTYPE_EXTERNAL : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_UNPARSED : throw new RuntimeException ( "PAR016 endEntityReference(): ENTITYTYPE_UNPARSED" ) ; case XMLEntityHandler . ENTITYTYPE_DOCUMENT : break ; case XMLEntityHandler . ENTITYTYPE_EXTERNAL_SUBSET : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(\"[dtd]\")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( "[dtd]" ) ; } break ; } } } public void startCDATA ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "startCDATA()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endCDATA()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endCDATA ( ) ; } } public void characters ( int dataIndex ) throws Exception { throw new RuntimeException ( "PAR017 cannot happen 5\n5" ) ; } public void ignorableWhitespace ( int dataIndex ) throws Exception { throw new RuntimeException ( "PAR017 cannot happen 6\n6" ) ; } public void processingInstruction ( int piTarget , int piData ) throws Exception { if ( fDocumentHandler != null || fContentHandler != null || DEBUG_CALLBACKS ) { String target = fStringPool . orphanString ( piTarget ) ; String data = piData == - 1 ? "" : fStringPool . orphanString ( piData ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "processingInstruction(" + target + ", " + data + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . processingInstruction ( target , data ) ; } if ( fContentHandler != null ) { fContentHandler . processingInstruction ( target , data ) ; } } else { fStringPool . releaseString ( piTarget ) ; fStringPool . releaseString ( piData ) ; } } public void comment ( int dataIndex ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { String data = fStringPool . orphanString ( dataIndex ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "comment(" + data + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } else { fStringPool . releaseString ( dataIndex ) ; } } public void characters ( char ch [ ] , int start , int length ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "characters(<char-data>) length " + length ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . characters ( ch , start , length ) ; } if ( fContentHandler != null ) { fContentHandler . characters ( ch , start , length ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "ignorableWhitespace(<white-space>)" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . ignorableWhitespace ( ch , start , length ) ; } if ( fContentHandler != null ) { fContentHandler . ignorableWhitespace ( ch , start , length ) ; } } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLOptionElementImpl extends WMLElementImpl implements WMLOptionElement { public WMLOptionElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setValue ( String newValue ) { setAttribute ( "value" , newValue ) ; } public String getValue ( ) { return getAttribute ( "value" ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setTitle ( String newValue ) { setAttribute ( "title" , newValue ) ; } public String getTitle ( ) { return getAttribute ( "title" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setOnPick ( String newValue ) { setAttribute ( "onpick" , newValue ) ; } public String getOnPick ( ) { return getAttribute ( "onpick" ) ; } } 	0
package org . w3c . dom ; public interface DocumentType extends Node { public String getName ( ) ; public NamedNodeMap getEntities ( ) ; public NamedNodeMap getNotations ( ) ; public String getPublicId ( ) ; public String getSystemId ( ) ; public String getInternalSubset ( ) ; } 	1
package org . apache . xerces . validators . datatype ; public class InvalidDatatypeValueException extends XMLException { private int majorCode = - 1 ; private int minorCode = - 1 ; public int getMinorCode ( ) { return minorCode ; } public int getMajorCode ( ) { return majorCode ; } public void setMinorCode ( int code ) { majorCode = code ; } public void setMajorCode ( int code ) { minorCode = code ; } public InvalidDatatypeValueException ( ) { super ( ) ; } public InvalidDatatypeValueException ( String msg ) { super ( msg ) ; } public InvalidDatatypeValueException ( Exception exception ) { super ( exception ) ; } public InvalidDatatypeValueException ( String message , Exception exception ) { super ( message , exception ) ; } } 	0
package org . apache . xerces . dom ; import org . apache . xerces . domx . DOMException ; public class DOMExceptionImpl extends DOMException { public DOMExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . wml ; public interface WMLPrevElement extends WMLElement { } 	0
package org . w3c . dom ; public interface Comment extends CharacterData { } 	1
package org . w3c . dom . html ; public interface HTMLUListElement extends HTMLElement { public boolean getCompact ( ) ; public void setCompact ( boolean compact ) ; public String getType ( ) ; public void setType ( String type ) ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface TreeWalker { public Node getRoot ( ) ; public int getWhatToShow ( ) ; public NodeFilter getFilter ( ) ; public boolean getExpandEntityReferences ( ) ; public Node getCurrentNode ( ) ; public void setCurrentNode ( Node currentNode ) throws DOMException ; public Node parentNode ( ) ; public Node firstChild ( ) ; public Node lastChild ( ) ; public Node previousSibling ( ) ; public Node nextSibling ( ) ; public Node previousNode ( ) ; public Node nextNode ( ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLDListElementImpl extends HTMLElementImpl implements HTMLDListElement { public boolean getCompact ( ) { return getBinary ( "compact" ) ; } public void setCompact ( boolean compact ) { setAttribute ( "compact" , compact ) ; } public HTMLDListElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom ; public interface ProcessingInstruction extends Node { public String getTarget ( ) ; public String getData ( ) ; public void setData ( String data ) throws DOMException ; } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DocumentTypeImpl extends ChildAndParentNode implements DocumentType { static final long serialVersionUID = 7751299192316526485L ; protected String name ; protected NamedNodeMapImpl entities ; protected NamedNodeMapImpl notations ; protected NamedNodeMapImpl elements ; protected String publicID ; protected String systemID ; protected String internalSubset ; public DocumentTypeImpl ( DocumentImpl ownerDocument , String name ) { super ( ownerDocument ) ; this . name = name ; entities = new NamedNodeMapImpl ( this ) ; notations = new NamedNodeMapImpl ( this ) ; elements = new NamedNodeMapImpl ( this ) ; } public DocumentTypeImpl ( DocumentImpl ownerDocument , String qualifiedName , String publicID , String systemID ) { this ( ownerDocument , qualifiedName ) ; this . publicID = publicID ; this . systemID = systemID ; } public String getPublicId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return publicID ; } public String getSystemId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return systemID ; } public void setInternalSubset ( String internalSubset ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } this . internalSubset = internalSubset ; } public String getInternalSubset ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return internalSubset ; } public short getNodeType ( ) { return Node . DOCUMENT_TYPE_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public Node cloneNode ( boolean deep ) { DocumentTypeImpl newnode = ( DocumentTypeImpl ) super . cloneNode ( deep ) ; newnode . entities = entities . cloneMap ( newnode ) ; newnode . notations = notations . cloneMap ( newnode ) ; newnode . elements = elements . cloneMap ( newnode ) ; return newnode ; } void setOwnerDocument ( DocumentImpl doc ) { super . setOwnerDocument ( doc ) ; entities . setOwnerDocument ( doc ) ; notations . setOwnerDocument ( doc ) ; elements . setOwnerDocument ( doc ) ; } public String getName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public NamedNodeMap getEntities ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return entities ; } public NamedNodeMap getNotations ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return notations ; } public void setReadOnly ( boolean readOnly , boolean deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } setReadOnly ( readOnly , deep ) ; elements . setReadOnly ( readOnly , true ) ; entities . setReadOnly ( readOnly , true ) ; notations . setReadOnly ( readOnly , true ) ; } public NamedNodeMap getElements ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return elements ; } } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . EventImpl ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public abstract class NodeImpl implements Node , NodeList , EventTarget , Cloneable , Serializable { static final long serialVersionUID = - 6316591992167219696L ; public static final short ELEMENT_DEFINITION_NODE = - 1 ; protected NodeImpl ownerNode ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short SYNCDATA = 0x1 << 1 ; protected final static short SYNCCHILDREN = 0x1 << 2 ; protected final static short OWNED = 0x1 << 3 ; protected final static short FIRSTCHILD = 0x1 << 4 ; protected final static short SPECIFIED = 0x1 << 5 ; protected final static short IGNORABLEWS = 0x1 << 6 ; protected final static short SETVALUE = 0x1 << 7 ; protected NodeImpl ( DocumentImpl ownerDocument ) { ownerNode = ownerDocument ; } public NodeImpl ( ) { } public abstract short getNodeType ( ) ; public abstract String getNodeName ( ) ; public String getNodeValue ( ) { return null ; } public void setNodeValue ( String x ) throws DOMException { } public Node appendChild ( Node newChild ) throws DOMException { return insertBefore ( newChild , null ) ; } public Node cloneNode ( boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } NodeImpl newnode ; try { newnode = ( NodeImpl ) clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } newnode . ownerNode = ownerDocument ( ) ; newnode . isOwned ( false ) ; newnode . isReadOnly ( false ) ; return newnode ; } public Document getOwnerDocument ( ) { if ( isOwned ( ) ) { return ownerNode . ownerDocument ( ) ; } else { return ( Document ) ownerNode ; } } DocumentImpl ownerDocument ( ) { if ( isOwned ( ) ) { return ownerNode . ownerDocument ( ) ; } else { return ( DocumentImpl ) ownerNode ; } } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ! isOwned ( ) ) { ownerNode = doc ; } } public Node getParentNode ( ) { return null ; } NodeImpl parentNode ( ) { return null ; } public Node getNextSibling ( ) { return null ; } public Node getPreviousSibling ( ) { return null ; } ChildNode previousSibling ( ) { return null ; } public NamedNodeMap getAttributes ( ) { return null ; } public boolean hasAttributes ( ) { return false ; } public boolean hasChildNodes ( ) { return false ; } public NodeList getChildNodes ( ) { return this ; } public Node getFirstChild ( ) { return null ; } public Node getLastChild ( ) { return null ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } public Node removeChild ( Node oldChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } public int getLength ( ) { return 0 ; } public Node item ( int index ) { return null ; } public void normalize ( ) { } public boolean supports ( String feature , String version ) { return ownerDocument ( ) . getImplementation ( ) . hasFeature ( feature , version ) ; } public String getNamespaceURI ( ) { return null ; } public String getPrefix ( ) { return null ; } public void setPrefix ( String prefix ) throws DOMException { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } public String getLocalName ( ) { return null ; } protected final static boolean MUTATIONEVENTS = true ; protected final static int MUTATION_NONE = 0x00 ; protected final static int MUTATION_LOCAL = 0x01 ; protected final static int MUTATION_AGGREGATE = 0x02 ; protected final static int MUTATION_ALL = 0xffff ; class LEntry { String type ; EventListener listener ; boolean useCapture ; LEntry ( String type , EventListener listener , boolean useCapture ) { this . type = type ; this . listener = listener ; this . useCapture = useCapture ; } } ; public void addEventListener ( String type , EventListener listener , boolean useCapture ) { if ( type == null || type . equals ( "" ) || listener == null ) return ; removeEventListener ( type , listener , useCapture ) ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null ) { nodeListeners = new Vector ( ) ; ownerDocument ( ) . setEventListeners ( this , nodeListeners ) ; } nodeListeners . addElement ( new LEntry ( type , listener , useCapture ) ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) ++ lc . captures ; else ++ lc . bubbles ; } public void removeEventListener ( String type , EventListener listener , boolean useCapture ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null || type == null || type . equals ( "" ) || listener == null ) return ; for ( int i = nodeListeners . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nodeListeners . elementAt ( i ) ) ; if ( le . useCapture == useCapture && le . listener == listener && le . type . equals ( type ) ) { nodeListeners . removeElementAt ( i ) ; if ( nodeListeners . size ( ) == 0 ) ownerDocument ( ) . setEventListeners ( this , null ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) -- lc . captures ; else -- lc . bubbles ; break ; } } } public boolean dispatchEvent ( Event event ) { if ( event == null ) return false ; EventImpl evt = ( EventImpl ) event ; if ( ! evt . initialized || evt . type == null || evt . type . equals ( "" ) ) throw new DOMExceptionImpl ( DOMExceptionImpl . UNSPECIFIED_EVENT_TYPE , "DOM010 Unspecified event type" ) ; LCount lc = LCount . lookup ( evt . getType ( ) ) ; if ( lc . captures + lc . bubbles + lc . defaults == 0 ) return evt . preventDefault ; evt . target = this ; evt . stopPropagation = false ; evt . preventDefault = false ; Vector pv = new Vector ( 10 , 10 ) ; Node p = this , n = p . getParentNode ( ) ; while ( n != null ) { pv . addElement ( n ) ; p = n ; n = n . getParentNode ( ) ; } if ( lc . captures > 0 ) { evt . eventPhase = Event . CAPTURING_PHASE ; for ( int j = pv . size ( ) - 1 ; j >= 0 ; -- j ) { if ( evt . stopPropagation ) break ; NodeImpl nn = ( NodeImpl ) pv . elementAt ( j ) ; evt . currentNode = nn ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( nn ) ; if ( nodeListeners != null ) { Vector nl = ( Vector ) ( nodeListeners . clone ( ) ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nl . elementAt ( i ) ) ; if ( le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } } } if ( lc . bubbles > 0 ) { evt . eventPhase = Event . AT_TARGET ; evt . currentNode = this ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( ! evt . stopPropagation && nodeListeners != null ) { Vector nl = ( Vector ) nodeListeners . clone ( ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) nl . elementAt ( i ) ; if ( le != null && ! le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } if ( evt . bubbles ) { evt . eventPhase = Event . BUBBLING_PHASE ; for ( int j = 0 ; j < pv . size ( ) ; ++ j ) { if ( evt . stopPropagation ) break ; NodeImpl nn = ( NodeImpl ) pv . elementAt ( j ) ; evt . currentNode = nn ; nodeListeners = ownerDocument ( ) . getEventListeners ( nn ) ; if ( nodeListeners != null ) { Vector nl = ( Vector ) ( nodeListeners . clone ( ) ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nl . elementAt ( i ) ) ; if ( ! le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } } } } if ( lc . defaults > 0 && ( ! evt . cancelable || ! evt . preventDefault ) ) { } return evt . preventDefault ; } void dispatchEventToSubtree ( Node n , Event e ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null || n == null ) return ; ( ( NodeImpl ) n ) . dispatchEvent ( e ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap a = n . getAttributes ( ) ; for ( int i = a . getLength ( ) - 1 ; i >= 0 ; -- i ) dispatchEventToSubtree ( a . item ( i ) , e ) ; } dispatchEventToSubtree ( n . getFirstChild ( ) , e ) ; dispatchEventToSubtree ( n . getNextSibling ( ) , e ) ; } } class EnclosingAttr { AttrImpl node ; String oldvalue ; } EnclosingAttr getEnclosingAttr ( ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { NodeImpl eventAncestor = this ; while ( true ) { if ( eventAncestor == null ) return null ; int type = eventAncestor . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE ) { EnclosingAttr retval = new EnclosingAttr ( ) ; retval . node = ( AttrImpl ) eventAncestor ; retval . oldvalue = retval . node . getNodeValue ( ) ; return retval ; } else if ( type == Node . ENTITY_REFERENCE_NODE ) eventAncestor = eventAncestor . parentNode ( ) ; else return null ; } } return null ; } void dispatchAggregateEvents ( EnclosingAttr ea ) { if ( ea != null ) dispatchAggregateEvents ( ea . node , ea . oldvalue ) ; else dispatchAggregateEvents ( null , null ) ; } void dispatchAggregateEvents ( AttrImpl enclosingAttr , String oldvalue ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null ) return ; NodeImpl owner = null ; if ( enclosingAttr != null ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { owner = ( ( NodeImpl ) ( enclosingAttr . getOwnerElement ( ) ) ) ; if ( owner != null ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_ATTR_MODIFIED , true , false , null , oldvalue , enclosingAttr . getNodeValue ( ) , enclosingAttr . getNodeName ( ) ) ; owner . dispatchEvent ( me ) ; } } } LCount lc = LCount . lookup ( MutationEventImpl . DOM_SUBTREE_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_SUBTREE_MODIFIED , true , false , null , null , null , null ) ; if ( enclosingAttr != null ) { enclosingAttr . dispatchEvent ( me ) ; if ( owner != null ) owner . dispatchEvent ( me ) ; } else dispatchEvent ( me ) ; } } } public void setReadOnly ( boolean readOnly , boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isReadOnly ( readOnly ) ; } public boolean getReadOnly ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isReadOnly ( ) ; } public void setUserData ( Object data ) { ownerDocument ( ) . setUserData ( this , data ) ; } public Object getUserData ( ) { return ownerDocument ( ) . getUserData ( this ) ; } protected void changed ( ) { ownerDocument ( ) . changed ( ) ; } protected int changes ( ) { return ownerDocument ( ) . changes ( ) ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean needsSyncData ( ) { return ( flags & SYNCDATA ) != 0 ; } final void needsSyncData ( boolean value ) { flags = ( short ) ( value ? flags | SYNCDATA : flags & ~ SYNCDATA ) ; } final boolean needsSyncChildren ( ) { return ( flags & SYNCCHILDREN ) != 0 ; } final void needsSyncChildren ( boolean value ) { flags = ( short ) ( value ? flags | SYNCCHILDREN : flags & ~ SYNCCHILDREN ) ; } final boolean isOwned ( ) { return ( flags & OWNED ) != 0 ; } final void isOwned ( boolean value ) { flags = ( short ) ( value ? flags | OWNED : flags & ~ OWNED ) ; } final boolean isFirstChild ( ) { return ( flags & FIRSTCHILD ) != 0 ; } final void isFirstChild ( boolean value ) { flags = ( short ) ( value ? flags | FIRSTCHILD : flags & ~ FIRSTCHILD ) ; } final boolean isSpecified ( ) { return ( flags & SPECIFIED ) != 0 ; } final void isSpecified ( boolean value ) { flags = ( short ) ( value ? flags | SPECIFIED : flags & ~ SPECIFIED ) ; } final boolean internalIsIgnorableWhitespace ( ) { return ( flags & IGNORABLEWS ) != 0 ; } final void isIgnorableWhitespace ( boolean value ) { flags = ( short ) ( value ? flags | IGNORABLEWS : flags & ~ IGNORABLEWS ) ; } final boolean setValueCalled ( ) { return ( flags & SETVALUE ) != 0 ; } final void setValueCalled ( boolean value ) { flags = ( short ) ( value ? flags | SETVALUE : flags & ~ SETVALUE ) ; } public String toString ( ) { return "[" + getNodeName ( ) + ": " + getNodeValue ( ) + "]" ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } out . defaultWriteObject ( ) ; } } 	1
package org . w3c . dom . html ; import org . w3c . dom . Node ; public interface HTMLCollection { public int getLength ( ) ; public Node item ( int index ) ; public Node namedItem ( String name ) ; } 	0
package org . apache . xerces . validators . datatype ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import java . io . IOException ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; public class DecimalDatatypeValidator extends AbstractDatatypeValidator { private Locale fLocale = null ; private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; private BigDecimal [ ] fEnumDecimal = null ; private String fPattern = null ; private BigDecimal fMaxInclusive = null ; private BigDecimal fMaxExclusive = null ; private BigDecimal fMinInclusive = null ; private BigDecimal fMinExclusive = null ; private int fFacetsDefined = 0 ; private int fScale = 0 ; private int fPrecision = 0 ; private boolean isMaxExclusiveDefined = false ; private boolean isMaxInclusiveDefined = false ; private boolean isMinExclusiveDefined = false ; private boolean isMinInclusiveDefined = false ; private boolean isScaleDefined = false ; private boolean isPrecisionDefined = false ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; private RegularExpression fRegex = null ; private Hashtable fFacets = null ; public DecimalDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public DecimalDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { fFacets = checkForFacetConsistency ( facets , base . getFacets ( ) ) ; fFacets = facets ; if ( fDerivedByList == false ) { Vector enumeration = null ; String value = null ; for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; try { if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = value ; if ( fPattern != null ) fRegex = new RegularExpression ( fPattern , "X" ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; enumeration = ( Vector ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; fMaxInclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MAXEXCLUSIVE ; fMaxExclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; fMinInclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MINEXCLUSIVE ; fMinExclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_PRECISION ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_PRECISSION ; isPrecisionDefined = true ; fPrecision = Integer . parseInt ( value ) ; } else if ( key . equals ( SchemaSymbols . ELT_SCALE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_SCALE ; isScaleDefined = true ; fScale = Integer . parseInt ( value ) ; } else { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . MSG_FORMAT_FAILURE , DatatypeMessageProvider . MSG_NONE , null ) ) ; } } catch ( Exception ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } isMaxExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXEXCLUSIVE ) != 0 ) ? true : false ; isMaxInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXINCLUSIVE ) != 0 ) ? true : false ; isMinExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MINEXCLUSIVE ) != 0 ) ? true : false ; isMinInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MININCLUSIVE ) != 0 ) ? true : false ; if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both maxInclusive and maxExclusive to be specified for the same datatype." ) ; } if ( isMinExclusiveDefined && isMinInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both minInclusive and minExclusive to be specified for the same datatype." ) ; } if ( isMaxExclusiveDefined && isMinExclusiveDefined ) { int compareTo = this . fMaxExclusive . compareTo ( this . fMinExclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxExclusive value ='" + this . fMaxExclusive + "'must be > than minExclusive value ='" + this . fMinExclusive + "'. " ) ; } if ( isMaxInclusiveDefined && isMinInclusiveDefined ) { int compareTo = this . fMaxInclusive . compareTo ( this . fMinInclusive ) ; if ( compareTo == - 1 ) throw new InvalidDatatypeFacetException ( "maxInclusive value ='" + this . fMaxInclusive + "'must be >= than minInclusive value ='" + this . fMinInclusive + "'. " ) ; } if ( isMaxExclusiveDefined && isMinInclusiveDefined ) { int compareTo = this . fMaxExclusive . compareTo ( this . fMinInclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxExclusive value ='" + this . fMaxExclusive + "'must be > than minInclusive value ='" + this . fMinInclusive + "'. " ) ; } if ( isMaxInclusiveDefined && isMinExclusiveDefined ) { int compareTo = this . fMaxInclusive . compareTo ( this . fMinExclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxInclusive value ='" + this . fMaxInclusive + "'must be > than minExclusive value ='" + this . fMinExclusive + "'. " ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { if ( enumeration != null ) { fEnumDecimal = new BigDecimal [ enumeration . size ( ) ] ; int i = 0 ; try { for ( ; i < enumeration . size ( ) ; i ++ ) { fEnumDecimal [ i ] = new BigDecimal ( stripPlusIfPresent ( ( ( String ) enumeration . elementAt ( i ) ) ) ) ; boundsCheck ( fEnumDecimal [ i ] ) ; } } catch ( Exception idve ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . InvalidEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { enumeration . elementAt ( i ) } ) ) ; } } } } else { } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { if ( fDerivedByList == false ) { if ( this . fBaseValidator != null ) { this . fBaseValidator . validate ( content , state ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_PATTERN ) != 0 ) { if ( fRegex == null || fRegex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value'" + content + "' does not match regular expression facet " + fRegex . getPattern ( ) ) ; } BigDecimal d = null ; try { d = new BigDecimal ( stripPlusIfPresent ( content ) ) ; } catch ( Exception nfe ) { throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotDecimal , DatatypeMessageProvider . MSG_NONE , new Object [ ] { "'" + content + "'" } ) ) ; } if ( isScaleDefined == true ) { if ( d . scale ( ) > fScale ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . ScaleExceeded , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } if ( isPrecisionDefined == true ) { int precision = d . movePointRight ( d . scale ( ) ) . toString ( ) . length ( ) - ( ( d . signum ( ) < 0 ) ? 1 : 0 ) ; if ( precision > fPrecision ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . PrecisionExceeded , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } boundsCheck ( d ) ; if ( fEnumDecimal != null ) enumCheck ( d ) ; } else { } return null ; } public void boundsCheck ( BigDecimal d ) throws InvalidDatatypeValueException { boolean minOk = false ; boolean maxOk = false ; String upperBound = ( fMaxExclusive != null ) ? ( fMaxExclusive . toString ( ) ) : ( ( fMaxInclusive != null ) ? fMaxInclusive . toString ( ) : "" ) ; String lowerBound = ( fMinExclusive != null ) ? ( fMinExclusive . toString ( ) ) : ( ( fMinInclusive != null ) ? fMinInclusive . toString ( ) : "" ) ; String lowerBoundIndicator = "" ; String upperBoundIndicator = "" ; if ( isMaxInclusiveDefined ) { maxOk = ( d . compareTo ( fMaxInclusive ) <= 0 ) ; upperBound = fMaxInclusive . toString ( ) ; if ( upperBound != null ) { upperBoundIndicator = "<=" ; } else { upperBound = "" ; } } else if ( isMaxExclusiveDefined ) { maxOk = ( d . compareTo ( fMaxExclusive ) < 0 ) ; upperBound = fMaxExclusive . toString ( ) ; if ( upperBound != null ) { upperBoundIndicator = "<" ; } else { upperBound = "" ; } } else { maxOk = ( ! isMaxInclusiveDefined && ! isMaxExclusiveDefined ) ; } if ( isMinInclusiveDefined ) { minOk = ( d . compareTo ( fMinInclusive ) >= 0 ) ; lowerBound = fMinInclusive . toString ( ) ; if ( lowerBound != null ) { lowerBoundIndicator = "<=" ; } else { lowerBound = "" ; } } else if ( isMinExclusiveDefined ) { minOk = ( d . compareTo ( fMinExclusive ) > 0 ) ; lowerBound = fMinExclusive . toString ( ) ; if ( lowerBound != null ) { lowerBoundIndicator = "<" ; } else { lowerBound = "" ; } } else { minOk = ( ! isMinInclusiveDefined && ! isMinExclusiveDefined ) ; } if ( ! ( minOk && maxOk ) ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . OutOfBounds , DatatypeMessageProvider . MSG_NONE , new Object [ ] { d . toString ( ) , lowerBound , upperBound , lowerBoundIndicator , upperBoundIndicator } ) ) ; } private void enumCheck ( BigDecimal v ) throws InvalidDatatypeValueException { for ( int i = 0 ; i < fEnumDecimal . length ; i ++ ) { if ( v . equals ( fEnumDecimal [ i ] ) ) { return ; } } throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotAnEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { v } ) ) ; } public void setLocale ( Locale locale ) { fLocale = locale ; } public Hashtable getFacets ( ) { return fFacets ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } public int compare ( String content1 , String content2 ) { return 0 ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } static private String stripPlusIfPresent ( String value ) { String strippedPlus = value ; if ( value . length ( ) >= 2 && value . charAt ( 0 ) == '+' && value . charAt ( 1 ) != '-' ) { strippedPlus = value . substring ( 1 ) ; } return strippedPlus ; } private Hashtable checkForFacetConsistency ( Hashtable thisTypeFacets , Hashtable baseTypeFacets ) throws InvalidDatatypeFacetException { String thisTypeFacetValue ; String baseValue ; if ( baseTypeFacets != null ) { Enumeration setOfBaseKeys = baseTypeFacets . keys ( ) ; String keyInBase ; BigDecimal valueOfThisType = null ; BigDecimal valueOfBase = null ; while ( setOfBaseKeys . hasMoreElements ( ) ) { keyInBase = ( String ) setOfBaseKeys . nextElement ( ) ; baseValue = ( String ) baseTypeFacets . get ( keyInBase ) ; thisTypeFacetValue = ( String ) thisTypeFacets . get ( keyInBase ) ; if ( thisTypeFacetValue == null ) { String strThisType = null ; thisTypeFacets . put ( keyInBase , baseValue ) ; if ( keyInBase . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MAXINCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == - 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MAXINCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == - 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MININCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MININCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MININCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MININCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MINEXCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MINEXCLUSIVE ) ; } } } else { if ( keyInBase . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } } } } return thisTypeFacets ; } } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . w3c . dom . traversal . * ; public class TreeWalkerImpl implements TreeWalker { private boolean fEntityReferenceExpansion = false ; int fWhatToShow = NodeFilter . SHOW_ALL ; NodeFilter fNodeFilter ; Node fCurrentNode ; Node fRoot ; public TreeWalkerImpl ( Node root , int whatToShow , NodeFilter nodeFilter , boolean entityReferenceExpansion ) { fCurrentNode = root ; fRoot = root ; fWhatToShow = whatToShow ; fNodeFilter = nodeFilter ; fEntityReferenceExpansion = entityReferenceExpansion ; } public Node getRoot ( ) { return fRoot ; } public int getWhatToShow ( ) { return fWhatToShow ; } public NodeFilter getFilter ( ) { return fNodeFilter ; } public boolean getExpandEntityReferences ( ) { return fEntityReferenceExpansion ; } public Node getCurrentNode ( ) { return fCurrentNode ; } public void setCurrentNode ( Node node ) { fCurrentNode = node ; } public Node parentNode ( ) { if ( fCurrentNode == null ) return null ; Node node = getParentNode ( fCurrentNode ) ; if ( node != null ) { fCurrentNode = node ; } return node ; } public Node firstChild ( ) { if ( fCurrentNode == null ) return null ; Node node = getFirstChild ( fCurrentNode ) ; if ( node != null ) { fCurrentNode = node ; } return node ; } public Node lastChild ( ) { if ( fCurrentNode == null ) return null ; Node node = getLastChild ( fCurrentNode ) ; if ( node != null ) { fCurrentNode = node ; } return node ; } public Node previousSibling ( ) { if ( fCurrentNode == null ) return null ; Node node = getPreviousSibling ( fCurrentNode ) ; if ( node != null ) { fCurrentNode = node ; } return node ; } public Node nextSibling ( ) { if ( fCurrentNode == null ) return null ; Node node = getNextSibling ( fCurrentNode ) ; if ( node != null ) { fCurrentNode = node ; } return node ; } public Node previousNode ( ) { Node result ; if ( fCurrentNode == null ) return null ; result = getPreviousSibling ( fCurrentNode ) ; if ( result == null ) { result = getParentNode ( fCurrentNode ) ; if ( result != null ) { fCurrentNode = result ; return fCurrentNode ; } return null ; } Node lastChild = getLastChild ( result ) ; Node prev = lastChild ; while ( lastChild != null ) { prev = lastChild ; lastChild = getLastChild ( prev ) ; } lastChild = prev ; if ( lastChild != null ) { fCurrentNode = lastChild ; return fCurrentNode ; } if ( result != null ) { fCurrentNode = result ; return fCurrentNode ; } return null ; } public Node nextNode ( ) { if ( fCurrentNode == null ) return null ; Node result = getFirstChild ( fCurrentNode ) ; if ( result != null ) { fCurrentNode = result ; return result ; } result = getNextSibling ( fCurrentNode ) ; if ( result != null ) { fCurrentNode = result ; return result ; } Node parent = getParentNode ( fCurrentNode ) ; while ( parent != null ) { result = getNextSibling ( parent ) ; if ( result != null ) { fCurrentNode = result ; return result ; } else { parent = getParentNode ( parent ) ; } } return null ; } Node getParentNode ( Node node ) { if ( node == null || node == fRoot ) return null ; Node newNode = node . getParentNode ( ) ; if ( newNode == null ) return null ; int accept = acceptNode ( newNode ) ; if ( accept == NodeFilter . FILTER_ACCEPT ) return newNode ; else { return getParentNode ( newNode ) ; } } Node getNextSibling ( Node node ) { if ( node == null || node == fRoot ) return null ; Node newNode = node . getNextSibling ( ) ; if ( newNode == null ) { newNode = node . getParentNode ( ) ; if ( newNode == null || node == fRoot ) return null ; int parentAccept = acceptNode ( newNode ) ; if ( parentAccept == NodeFilter . FILTER_SKIP ) { return getNextSibling ( newNode ) ; } return null ; } int accept = acceptNode ( newNode ) ; if ( accept == NodeFilter . FILTER_ACCEPT ) return newNode ; else if ( accept == NodeFilter . FILTER_SKIP ) { Node fChild = getFirstChild ( newNode ) ; if ( fChild == null ) { return getNextSibling ( newNode ) ; } return fChild ; } else { return getNextSibling ( newNode ) ; } } Node getPreviousSibling ( Node node ) { if ( node == null || node == fRoot ) return null ; Node newNode = node . getPreviousSibling ( ) ; if ( newNode == null ) { newNode = node . getParentNode ( ) ; if ( newNode == null || node == fRoot ) return null ; int parentAccept = acceptNode ( newNode ) ; if ( parentAccept == NodeFilter . FILTER_SKIP ) { return getPreviousSibling ( newNode ) ; } return null ; } int accept = acceptNode ( newNode ) ; if ( accept == NodeFilter . FILTER_ACCEPT ) return newNode ; else if ( accept == NodeFilter . FILTER_SKIP ) { Node fChild = getLastChild ( newNode ) ; if ( fChild == null ) { return getPreviousSibling ( newNode ) ; } return fChild ; } else { return getPreviousSibling ( newNode ) ; } } Node getFirstChild ( Node node ) { if ( node == null ) return null ; if ( ! fEntityReferenceExpansion && node . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) return null ; Node newNode = node . getFirstChild ( ) ; if ( newNode == null ) return null ; int accept = acceptNode ( newNode ) ; if ( accept == NodeFilter . FILTER_ACCEPT ) return newNode ; else if ( accept == NodeFilter . FILTER_SKIP && newNode . hasChildNodes ( ) ) { return getFirstChild ( newNode ) ; } else { return getNextSibling ( newNode ) ; } } Node getLastChild ( Node node ) { if ( node == null ) return null ; if ( ! fEntityReferenceExpansion && node . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) return null ; Node newNode = node . getLastChild ( ) ; if ( newNode == null ) return null ; int accept = acceptNode ( newNode ) ; if ( accept == NodeFilter . FILTER_ACCEPT ) return newNode ; else if ( accept == NodeFilter . FILTER_SKIP && newNode . hasChildNodes ( ) ) { return getLastChild ( newNode ) ; } else { return getPreviousSibling ( newNode ) ; } } short acceptNode ( Node node ) { if ( fNodeFilter == null ) { if ( ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ) { return NodeFilter . FILTER_ACCEPT ; } else { return NodeFilter . FILTER_SKIP ; } } else { if ( ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ) { return fNodeFilter . acceptNode ( node ) ; } else { return NodeFilter . FILTER_SKIP ; } } } } 	0
package javax . xml . parsers ; public class FactoryConfigurationError extends Error { private Exception exception = null ; public FactoryConfigurationError ( ) { this ( null , null ) ; } public FactoryConfigurationError ( String msg ) { this ( null , msg ) ; } public FactoryConfigurationError ( Exception e ) { this ( e , null ) ; } public FactoryConfigurationError ( Exception e , String msg ) { super ( msg ) ; this . exception = e ; } public Exception getException ( ) { return ( this . exception ) ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLOptgroupElementImpl extends WMLElementImpl implements WMLOptgroupElement { public WMLOptgroupElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setTitle ( String newValue ) { setAttribute ( "title" , newValue ) ; } public String getTitle ( ) { return getAttribute ( "title" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom ; public interface DocumentFragment extends Node { } 	1
package org . apache . xml . serialize ; public final class Method { public static final String XML = "xml" ; public static final String HTML = "html" ; public static final String XHTML = "xhtml" ; public static final String TEXT = "text" ; public static final String FOP = "fop" ; } 	0
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface MutationEvent extends Event { public Node getRelatedNode ( ) ; public String getPrevValue ( ) ; public String getNewValue ( ) ; public String getAttrName ( ) ; public void initMutationEvent ( String typeArg , boolean canBubbleArg , boolean cancelableArg , Node relatedNodeArg , String prevValueArg , String newValueArg , String attrNameArg ) ; } 	1
package org . apache . wml ; public interface WMLSetvarElement extends WMLElement { public void setValue ( String newValue ) ; public String getValue ( ) ; public void setName ( String newValue ) ; public String getName ( ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . w3c . dom . traversal . * ; import org . apache . xerces . dom . DocumentImpl ; import org . apache . xerces . dom . DOMExceptionImpl ; public class NodeIteratorImpl implements NodeIterator { private DocumentImpl fDocument ; private Node fRoot ; private int fWhatToShow = NodeFilter . SHOW_ALL ; private NodeFilter fNodeFilter ; private boolean fDetach = false ; private Node fCurrentNode ; private boolean fForward = true ; private boolean fEntityReferenceExpansion ; public NodeIteratorImpl ( DocumentImpl document , Node root , int whatToShow , NodeFilter nodeFilter , boolean entityReferenceExpansion ) { fDocument = document ; fRoot = root ; fCurrentNode = null ; fWhatToShow = whatToShow ; fNodeFilter = nodeFilter ; fEntityReferenceExpansion = entityReferenceExpansion ; } public Node getRoot ( ) { return fRoot ; } public int getWhatToShow ( ) { return fWhatToShow ; } public NodeFilter getFilter ( ) { return fNodeFilter ; } public boolean getExpandEntityReferences ( ) { return fEntityReferenceExpansion ; } public Node nextNode ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMExceptionImpl . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( fRoot == null ) return null ; Node nextNode = fCurrentNode ; boolean accepted = false ; accepted_loop : while ( ! accepted ) { if ( ! fForward && nextNode != null ) { nextNode = fCurrentNode ; } else { if ( ! fEntityReferenceExpansion && nextNode != null && nextNode . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) { nextNode = nextNode ( nextNode , false ) ; } else { nextNode = nextNode ( nextNode , true ) ; } } fForward = true ; if ( nextNode == null ) return null ; accepted = acceptNode ( nextNode ) ; if ( accepted ) { fCurrentNode = nextNode ; return fCurrentNode ; } else continue accepted_loop ; } return null ; } public Node previousNode ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMExceptionImpl . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( fRoot == null || fCurrentNode == null ) return null ; Node previousNode = fCurrentNode ; boolean accepted = false ; accepted_loop : while ( ! accepted ) { if ( fForward && previousNode != null ) { previousNode = fCurrentNode ; } else { previousNode = previousNode ( previousNode ) ; } fForward = false ; if ( previousNode == null ) return null ; accepted = acceptNode ( previousNode ) ; if ( accepted ) { fCurrentNode = previousNode ; return fCurrentNode ; } else continue accepted_loop ; } return null ; } boolean acceptNode ( Node node ) { if ( fNodeFilter == null ) { return ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ; } else { return ( ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ) && fNodeFilter . acceptNode ( node ) == NodeFilter . FILTER_ACCEPT ; } } Node matchNodeOrParent ( Node node ) { for ( Node n = node ; n != fRoot ; n = n . getParentNode ( ) ) { if ( node == n ) return n ; } return null ; } Node nextNode ( Node node , boolean visitChildren ) { if ( node == null ) return fRoot ; Node result ; if ( visitChildren ) { if ( node . hasChildNodes ( ) ) { result = node . getFirstChild ( ) ; return result ; } } result = node . getNextSibling ( ) ; if ( result != null ) return result ; Node parent = node . getParentNode ( ) ; while ( parent != null && parent != fRoot ) { result = parent . getNextSibling ( ) ; if ( result != null ) { return result ; } else { parent = parent . getParentNode ( ) ; } } return null ; } Node previousNode ( Node node ) { Node result ; if ( node == fRoot ) return null ; result = node . getPreviousSibling ( ) ; if ( result == null ) { result = node . getParentNode ( ) ; return result ; } if ( result . hasChildNodes ( ) && ! ( ! fEntityReferenceExpansion && result != null && result . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) ) { while ( result . hasChildNodes ( ) ) { result = result . getLastChild ( ) ; } } return result ; } public void removeNode ( Node node ) { if ( node == null ) return ; Node deleted = matchNodeOrParent ( node ) ; if ( deleted == null ) return ; if ( fForward ) { fCurrentNode = previousNode ( deleted ) ; } else { Node next = nextNode ( deleted , false ) ; if ( next != null ) { fCurrentNode = next ; } else { fCurrentNode = previousNode ( deleted ) ; fForward = true ; } } } public void detach ( ) { fDetach = true ; fDocument . removeNodeIterator ( this ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLFieldSetElementImpl extends HTMLElementImpl implements HTMLFieldSetElement , HTMLFormControl { public HTMLFieldSetElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . CharDataChunk ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringHasher ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . ImplementationMessages ; import org . xml . sax . SAXParseException ; import java . util . Vector ; abstract class AbstractCharReader extends XMLEntityReader { protected AbstractCharReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , StringPool stringPool ) { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fStringPool = stringPool ; fCurrentChunk = CharDataChunk . createChunk ( fStringPool , null ) ; } protected CharDataChunk fCurrentChunk = null ; protected int fCurrentIndex = 0 ; protected char [ ] fMostRecentData = null ; protected int fMostRecentChar = 0 ; protected int fLength = 0 ; protected abstract int fillCurrentChunk ( ) throws Exception ; protected void deferException ( int errorCode , Object [ ] args , int offset ) { if ( fDeferredErrors == null ) fDeferredErrors = new Vector ( ) ; DeferredError de = new DeferredError ( errorCode , args , offset ) ; fDeferredErrors . addElement ( de ) ; } protected XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; return nextReader ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } public boolean lookingAtChar ( char chr , boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch != chr ) { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( chr , skipPastChar ) ; } } return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ; } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0xD800 ) { if ( ch >= 0x20 || ch == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } if ( ch == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } return true ; } if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } if ( ch > 0xFFFD ) { return false ; } if ( ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; boolean valid = ( ch >= 0xDC00 && ch < 0xE000 ) ; if ( ! valid || ! skipPastChar ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return valid ; } } else if ( ch < 0xE000 ) { return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ; return true ; } public void skipToChar ( char chr ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == chr ) return ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( chr ) ; return ; } fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch >= 0xD800 && ch < 0xDC00 ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) continue ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } ch = loadNextChar ( ) ; } } public void skipPastName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return ; } while ( true ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int length = s . length ; char [ ] data = fMostRecentData ; int index = fCurrentIndex ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { for ( int i = 0 ; i < length ; i ++ ) { if ( data [ index ++ ] != s [ i ] ) return false ; } fCharacterCounter += length ; fCurrentOffset += length ; fCurrentIndex = index ; if ( index == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = data [ index ] & 0xFFFF ; return true ; } CharDataChunk dataChunk = fCurrentChunk ; int offset = fCurrentOffset ; int savedIndex = index ; int i = 0 ; while ( index < CharDataChunk . CHUNK_SIZE ) { if ( data [ index ++ ] != s [ i ++ ] ) return false ; } slowLoadNextChar ( ) ; data = fMostRecentData ; index = 0 ; while ( i < length ) { if ( data [ index ++ ] != s [ i ++ ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } fCharacterCounter += length ; fCurrentOffset += length ; fCurrentIndex = index ; if ( index == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = data [ index ] & 0xFFFF ; return true ; } public int scanInvalidChar ( ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } if ( fDeferredErrors != null ) { for ( int i = 0 ; i < fDeferredErrors . size ( ) ; i ++ ) { DeferredError de = ( DeferredError ) fDeferredErrors . elementAt ( i ) ; if ( de . offset == fCurrentIndex ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , de . errorCode , 0 , de . args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; fDeferredErrors . removeElementAt ( i ) ; fCharacterCounter ++ ; loadNextChar ( ) ; return - 1 ; } } } fCharacterCounter ++ ; loadNextChar ( ) ; } else { fCharacterCounter ++ ; if ( ch >= 0xD800 && ch < 0xDC00 ) { int ch2 = loadNextChar ( ) ; if ( ch2 >= 0xDC00 && ch2 < 0xE000 ) { ch = ( ( ch - 0xD800 ) << 10 ) + ( ch2 - 0xDC00 ) + 0x10000 ; loadNextChar ( ) ; } } else loadNextChar ( ) ; } return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextChar ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentChar ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextChar ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextChar ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( lookingAtChar ( qchar , false ) ) { break ; } if ( lookingAtChar ( ' ' , true ) ) { continue ; } if ( lookingAtSpace ( false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '<' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } int result = asSymbol ? addSymbol ( offset , fCurrentOffset - offset ) : addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return result ; } public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } if ( qchar != - 1 && lookingAtChar ( ( char ) qchar , false ) ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; break ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; } if ( lookingAtChar ( '%' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } int result = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( ( char ) qchar , true ) ; return result ; } public int scanName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return - 1 ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return - 1 ; } int offset = fCurrentOffset ; int index = fCurrentIndex ; char [ ] data = fMostRecentData ; if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; int hashcode = 0 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = data [ index ] & 0xFFFF ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; } fCurrentIndex = index ; fMostRecentChar = ch ; hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; int nameIndex = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; return nameIndex ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int ch = fMostRecentChar ; for ( int i = 0 ; i < len ; i ++ ) { if ( ch != expected [ offset ++ ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } fCharacterCounter ++ ; fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) ch = slowLoadNextChar ( ) ; else ch = ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; int index = fCurrentIndex ; char [ ] data = fMostRecentData ; if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; int hashcode = 0 ; int prefixend = - 1 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = data [ index ] & 0xFFFF ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; if ( index + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; ch = slowLoadNextChar ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; } else ch = data [ index + 1 ] & 0xFFFF ; boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; break ; } } } else { if ( fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; } fCurrentIndex = index ; fMostRecentChar = ch ; hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; qname . rawname = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentChar ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeMarkup ( ch ) ; } break ; case 2 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } break ; case 3 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch != ']' ) break ; if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) break ; fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , true ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } break ; } } else if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , false ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextChar ( ) ; break ; } callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentChar ; } } } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool fStringPool = null ; private boolean fCalledCharPropInit = false ; private boolean fCallClearPreviousChunk = true ; private Vector fDeferredErrors = null ; private class DeferredError { int errorCode ; Object [ ] args ; int offset ; DeferredError ( int ec , Object [ ] a , int o ) { errorCode = ec ; args = a ; offset = o ; } } private int recognizeMarkup ( int ch ) throws Exception { switch ( ch ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( ch == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } private boolean skipMultiByteCharData ( int ch ) throws Exception { if ( ch < 0xD800 ) { loadNextChar ( ) ; return true ; } if ( ch > 0xFFFD ) return false ; if ( ch >= 0xDC00 && ch < 0xE000 ) return false ; if ( ch >= 0xD800 && ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } loadNextChar ( ) ; return true ; } private int skipAsciiCharData ( ) throws Exception { int index = fCurrentIndex ; int offset = fCurrentOffset - index ; while ( true ) { char [ ] data = fMostRecentData ; while ( index < CharDataChunk . CHUNK_SIZE ) { int ch = data [ index ] & 0xFFFF ; if ( ch >= 0x80 ) { fCurrentOffset = offset + index ; fCurrentIndex = index ; fMostRecentChar = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { fCurrentOffset = offset + index ; fCurrentIndex = index ; fMostRecentChar = ch ; return ch ; } index ++ ; } offset += index ; slowLoadNextChar ( ) ; index = 0 ; } } private void callCharDataHandler ( int offset , int endOffset , boolean isWhitespace ) throws Exception { int length = endOffset - offset ; if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , length ) ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( stringIndex ) ; else fCharDataHandler . processCharacters ( stringIndex ) ; return ; } CharDataChunk dataChunk = fCurrentChunk . chunkFor ( offset ) ; int index = offset & CharDataChunk . CHUNK_MASK ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { if ( length != 0 ) { if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , length ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , length ) ; } return ; } int count = length ; int nbytes = CharDataChunk . CHUNK_SIZE - index ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , nbytes ) ; count -= nbytes ; do { dataChunk = dataChunk . nextChunk ( ) ; if ( dataChunk == null ) { throw new RuntimeException ( new ImplementationMessages ( ) . createMessage ( null , ImplementationMessages . INT_DCN , 0 , null ) ) ; } nbytes = count <= CharDataChunk . CHUNK_SIZE ? count : CharDataChunk . CHUNK_SIZE ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; count -= nbytes ; } while ( count > 0 ) ; } private int slowLoadNextChar ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toCharArray ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } else { fCurrentChunk = CharDataChunk . createChunk ( fStringPool , fCurrentChunk ) ; return fillCurrentChunk ( ) ; } } private int loadNextChar ( ) throws Exception { fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) return slowLoadNextChar ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class EntityReferenceImpl extends ChildAndParentNode implements EntityReference { static final long serialVersionUID = - 7381452955687102062L ; protected String name ; public EntityReferenceImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; isReadOnly ( true ) ; } public short getNodeType ( ) { return Node . ENTITY_REFERENCE_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public NodeList getChildNodes ( ) { synchronize ( ) ; return super . getChildNodes ( ) ; } public Node getFirstChild ( ) { synchronize ( ) ; return super . getFirstChild ( ) ; } public Node getLastChild ( ) { synchronize ( ) ; return super . getLastChild ( ) ; } public int getLength ( ) { synchronize ( ) ; return super . getLength ( ) ; } public boolean hasChildNodes ( ) { synchronize ( ) ; return super . hasChildNodes ( ) ; } public Node item ( int index ) { synchronize ( ) ; return super . item ( index ) ; } protected void synchronize ( ) { if ( firstChild != null ) { return ; } DocumentType doctype ; NamedNodeMap entities ; EntityImpl entDef ; if ( null != ( doctype = getOwnerDocument ( ) . getDoctype ( ) ) && null != ( entities = doctype . getEntities ( ) ) ) { entDef = ( EntityImpl ) entities . getNamedItem ( getNodeName ( ) ) ; if ( entDef == null ) return ; isReadOnly ( false ) ; for ( Node defkid = entDef . getFirstChild ( ) ; defkid != null ; defkid = defkid . getNextSibling ( ) ) { Node newkid = defkid . cloneNode ( true ) ; insertBefore ( newkid , null ) ; } setReadOnly ( true , true ) ; } } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . range . * ; public class RangeExceptionImpl extends RangeException { public RangeExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLAnchorElement extends HTMLElement { public String getAccessKey ( ) ; public void setAccessKey ( String accessKey ) ; public String getCharset ( ) ; public void setCharset ( String charset ) ; public String getCoords ( ) ; public void setCoords ( String coords ) ; public String getHref ( ) ; public void setHref ( String href ) ; public String getHreflang ( ) ; public void setHreflang ( String hreflang ) ; public String getName ( ) ; public void setName ( String name ) ; public String getRel ( ) ; public void setRel ( String rel ) ; public String getRev ( ) ; public void setRev ( String rev ) ; public String getShape ( ) ; public void setShape ( String shape ) ; public int getTabIndex ( ) ; public void setTabIndex ( int tabIndex ) ; public String getTarget ( ) ; public void setTarget ( String target ) ; public String getType ( ) ; public void setType ( String type ) ; public void blur ( ) ; public void focus ( ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ChildAndParentNode extends ChildNode { static final long serialVersionUID = 0 ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ChildAndParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ChildAndParentNode ( ) { } public Node cloneNode ( boolean deep ) { ChildAndParentNode newnode = ( ChildAndParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1
package org . apache . xerces . validators . schema ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . utils . QName ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . common . XMLContentModel ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . apache . xerces . validators . common . Grammar ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import java . util . Hashtable ; public class SchemaGrammar extends Grammar { private static final int CHUNK_SHIFT = 8 ; private static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; private static final int CHUNK_MASK = CHUNK_SIZE - 1 ; private static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; private XMLContentSpec fTempContentSpecNode = new XMLContentSpec ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private int fScopeDefinedByElement [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private String fFromAnotherSchemaURI [ ] [ ] = new String [ INITIAL_CHUNK_COUNT ] [ ] ; private TraverseSchema . ComplexTypeInfo fComplexTypeInfo [ ] [ ] = new TraverseSchema . ComplexTypeInfo [ INITIAL_CHUNK_COUNT ] [ ] ; private int fElementDeclDefaultType [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private String fElementDeclDefaultValue [ ] [ ] = new String [ INITIAL_CHUNK_COUNT ] [ ] ; private String fElementDeclEquivClassFullName [ ] [ ] = new String [ INITIAL_CHUNK_COUNT ] [ ] ; private int fElementDeclBlockSet [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fElementDeclFinalSet [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fElementDeclMiscFlags [ ] [ ] = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private Hashtable fComplexTypeRegistry = null ; private Hashtable fAttributeDeclRegistry = null ; private DatatypeValidatorFactoryImpl fDatatypeRegistry = null ; Hashtable topLevelGroupDecls = new Hashtable ( ) ; Hashtable topLevelAttrDecls = new Hashtable ( ) ; Hashtable topLevelAttrGrpDecls = new Hashtable ( ) ; private NamespacesScope fNamespacesScope = null ; private String fTargetNamespaceURI = "" ; public NamespacesScope getNamespacesScope ( ) { return fNamespacesScope ; } public String getTargetNamespaceURI ( ) { return fTargetNamespaceURI ; } public Hashtable getAttirubteDeclRegistry ( ) { return fAttributeDeclRegistry ; } public Hashtable getComplexTypeRegistry ( ) { return fComplexTypeRegistry ; } public DatatypeValidatorFactoryImpl getDatatypeRegistry ( ) { return fDatatypeRegistry ; } public int getElementDefinedScope ( int elementDeclIndex ) { if ( elementDeclIndex < - 1 ) { return - 1 ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; return fScopeDefinedByElement [ chunk ] [ index ] ; } public int getElementDefaultTYpe ( int elementDeclIndex ) { if ( elementDeclIndex < - 1 ) { return - 1 ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; return fElementDeclDefaultType [ chunk ] [ index ] ; } public int getElementDeclBlockSet ( int elementDeclIndex ) { if ( elementDeclIndex < - 1 ) { return - 1 ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; return fElementDeclBlockSet [ chunk ] [ index ] ; } public int getElementDeclFinalSet ( int elementDeclIndex ) { if ( elementDeclIndex < - 1 ) { return - 1 ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; return fElementDeclFinalSet [ chunk ] [ index ] ; } public int getElementDeclMiscFlags ( int elementDeclIndex ) { if ( elementDeclIndex < - 1 ) { return - 1 ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; return fElementDeclMiscFlags [ chunk ] [ index ] ; } public String getElementFromAnotherSchemaURI ( int elementDeclIndex ) { if ( elementDeclIndex < 0 ) { return null ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; return fFromAnotherSchemaURI [ chunk ] [ index ] ; } public String getElementDefaultValue ( int elementDeclIndex ) { if ( elementDeclIndex < 0 ) { return null ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; return fElementDeclDefaultValue [ chunk ] [ index ] ; } public String getElementDeclEquivClassElementFullName ( int elementDeclIndex ) { if ( elementDeclIndex < 0 ) { return null ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; return fElementDeclEquivClassFullName [ chunk ] [ index ] ; } public TraverseSchema . ComplexTypeInfo getElementComplexTypeInfo ( int elementDeclIndex ) { if ( elementDeclIndex < - 1 ) { return null ; } int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; return fComplexTypeInfo [ chunk ] [ index ] ; } protected void setAttributeDeclRegistry ( Hashtable attrReg ) { fAttributeDeclRegistry = attrReg ; } protected void setComplexTypeRegistry ( Hashtable cTypeReg ) { fComplexTypeRegistry = cTypeReg ; } protected void setDatatypeRegistry ( DatatypeValidatorFactoryImpl dTypeReg ) { fDatatypeRegistry = dTypeReg ; } protected void setNamespacesScope ( NamespacesScope nsScope ) { fNamespacesScope = nsScope ; } protected void setTargetNamespaceURI ( String targetNSUri ) { fTargetNamespaceURI = targetNSUri ; } protected int createElementDecl ( ) { return super . createElementDecl ( ) ; } protected void setElementDecl ( int elementDeclIndex , XMLElementDecl elementDecl ) { super . setElementDecl ( elementDeclIndex , elementDecl ) ; } protected int createContentSpec ( ) { return super . createContentSpec ( ) ; } protected void setContentSpec ( int contentSpecIndex , XMLContentSpec contentSpec ) { super . setContentSpec ( contentSpecIndex , contentSpec ) ; } protected int createAttributeDecl ( ) { return super . createAttributeDecl ( ) ; } protected void setAttributeDecl ( int elementDeclIndex , int attributeDeclIndex , XMLAttributeDecl attributeDecl ) { super . setAttributeDecl ( elementDeclIndex , attributeDeclIndex , attributeDecl ) ; } protected void setElementDefinedScope ( int elementDeclIndex , int scopeDefined ) { int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; ensureElementDeclCapacity ( chunk ) ; if ( elementDeclIndex > - 1 ) { fScopeDefinedByElement [ chunk ] [ index ] = scopeDefined ; } } protected void setElementFromAnotherSchemaURI ( int elementDeclIndex , String anotherSchemaURI ) { int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; ensureElementDeclCapacity ( chunk ) ; if ( elementDeclIndex > - 1 ) { fFromAnotherSchemaURI [ chunk ] [ index ] = anotherSchemaURI ; } } protected void setElementComplexTypeInfo ( int elementDeclIndex , TraverseSchema . ComplexTypeInfo typeInfo ) { int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; ensureElementDeclCapacity ( chunk ) ; if ( elementDeclIndex > - 1 ) { fComplexTypeInfo [ chunk ] [ index ] = typeInfo ; } } protected void setElementDefault ( int elementDeclIndex , int defaultType , String defaultValue ) { int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; ensureElementDeclCapacity ( chunk ) ; if ( elementDeclIndex > - 1 ) { fElementDeclDefaultType [ chunk ] [ index ] = defaultType ; fElementDeclDefaultValue [ chunk ] [ index ] = defaultValue ; } } protected void setElementDeclBlockSet ( int elementDeclIndex , int blockSet ) { int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; ensureElementDeclCapacity ( chunk ) ; if ( elementDeclIndex > - 1 ) { fElementDeclBlockSet [ chunk ] [ index ] = blockSet ; } } protected void setElementDeclFinalSet ( int elementDeclIndex , int finalSet ) { int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; ensureElementDeclCapacity ( chunk ) ; if ( elementDeclIndex > - 1 ) { fElementDeclFinalSet [ chunk ] [ index ] = finalSet ; } } protected void setElementDeclMiscFlags ( int elementDeclIndex , int miscFlags ) { int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; ensureElementDeclCapacity ( chunk ) ; if ( elementDeclIndex > - 1 ) { fElementDeclMiscFlags [ chunk ] [ index ] = miscFlags ; } } protected void setElementDeclEquivClassElementFullName ( int elementDeclIndex , String equivClassFullName ) { int chunk = elementDeclIndex > > CHUNK_SHIFT ; int index = elementDeclIndex & CHUNK_MASK ; ensureElementDeclCapacity ( chunk ) ; if ( elementDeclIndex > - 1 ) { fElementDeclEquivClassFullName [ chunk ] [ index ] = equivClassFullName ; } } protected int addElementDecl ( QName eltQName , int enclosingScope , int scopeDefined , int contentSpecType , int contentSpecIndex , int attrListHead , DatatypeValidator dv ) { int elementDeclIndex = getElementDeclIndex ( eltQName , enclosingScope ) ; if ( elementDeclIndex == - 1 ) { if ( enclosingScope < - 1 || scopeDefined < - 1 ) { } fTempElementDecl . name . setValues ( eltQName ) ; fTempElementDecl . enclosingScope = enclosingScope ; fTempElementDecl . type = contentSpecType ; fTempElementDecl . contentSpecIndex = contentSpecIndex ; fTempElementDecl . datatypeValidator = dv ; elementDeclIndex = createElementDecl ( ) ; setElementDecl ( elementDeclIndex , fTempElementDecl ) ; setFirstAttributeDeclIndex ( elementDeclIndex , attrListHead ) ; setElementDefinedScope ( elementDeclIndex , scopeDefined ) ; } return elementDeclIndex ; } protected void addAttDef ( int templateElementIndex , QName attQName , int attType , int enumeration , int attDefaultType , String attDefaultValue , DatatypeValidator dv , boolean isList ) { int attrDeclIndex = createAttributeDecl ( ) ; fTempAttributeDecl . name . setValues ( attQName ) ; fTempAttributeDecl . datatypeValidator = dv ; fTempAttributeDecl . type = attType ; fTempAttributeDecl . defaultType = attDefaultType ; fTempAttributeDecl . defaultValue = attDefaultValue ; fTempAttributeDecl . list = isList ; fTempAttributeDecl . enumeration = enumeration ; super . setAttributeDecl ( templateElementIndex , attrDeclIndex , fTempAttributeDecl ) ; } public int getAttributeDeclIndex ( int elementIndex , QName attribute ) { if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . name . localpart == attribute . localpart && fTempAttributeDecl . name . uri == attribute . uri ) { return attDefIndex ; } attDefIndex = getNextAttributeDeclIndex ( attDefIndex ) ; } return - 1 ; } protected int addContentSpecNode ( int contentSpecType , int value , int otherValue , boolean mustBeUnique ) { fTempContentSpecNode . type = contentSpecType ; fTempContentSpecNode . value = value ; fTempContentSpecNode . otherValue = otherValue ; int contentSpecIndex = createContentSpec ( ) ; setContentSpec ( contentSpecIndex , fTempContentSpecNode ) ; return contentSpecIndex ; } private boolean ensureElementDeclCapacity ( int chunk ) { try { return fScopeDefinedByElement [ chunk ] [ 0 ] == - 2 ; } catch ( ArrayIndexOutOfBoundsException ex ) { fScopeDefinedByElement = resize ( fScopeDefinedByElement , fScopeDefinedByElement . length * 2 ) ; fFromAnotherSchemaURI = resize ( fFromAnotherSchemaURI , fFromAnotherSchemaURI . length * 2 ) ; fComplexTypeInfo = resize ( fComplexTypeInfo , fComplexTypeInfo . length * 2 ) ; fElementDeclDefaultType = resize ( fElementDeclDefaultType , fElementDeclDefaultType . length * 2 ) ; fElementDeclDefaultValue = resize ( fElementDeclDefaultValue , fElementDeclDefaultValue . length * 2 ) ; fElementDeclBlockSet = resize ( fElementDeclBlockSet , fElementDeclBlockSet . length * 2 ) ; fElementDeclFinalSet = resize ( fElementDeclFinalSet , fElementDeclFinalSet . length * 2 ) ; fElementDeclMiscFlags = resize ( fElementDeclMiscFlags , fElementDeclMiscFlags . length * 2 ) ; fElementDeclEquivClassFullName = resize ( fElementDeclEquivClassFullName , fElementDeclEquivClassFullName . length * 2 ) ; } catch ( NullPointerException ex ) { } fScopeDefinedByElement [ chunk ] = new int [ CHUNK_SIZE ] ; for ( int i = 0 ; i < CHUNK_SIZE ; i ++ ) { fScopeDefinedByElement [ chunk ] [ i ] = - 2 ; } fFromAnotherSchemaURI [ chunk ] = new String [ CHUNK_SIZE ] ; fComplexTypeInfo [ chunk ] = new TraverseSchema . ComplexTypeInfo [ CHUNK_SIZE ] ; fElementDeclDefaultType [ chunk ] = new int [ CHUNK_SIZE ] ; fElementDeclDefaultValue [ chunk ] = new String [ CHUNK_SIZE ] ; fElementDeclEquivClassFullName [ chunk ] = new String [ CHUNK_SIZE ] ; fElementDeclBlockSet [ chunk ] = new int [ CHUNK_SIZE ] ; fElementDeclFinalSet [ chunk ] = new int [ CHUNK_SIZE ] ; fElementDeclMiscFlags [ chunk ] = new int [ CHUNK_SIZE ] ; return true ; } private int [ ] [ ] resize ( int array [ ] [ ] , int newsize ) { int newarray [ ] [ ] = new int [ newsize ] [ ] ; System . arraycopy ( array , 0 , newarray , 0 , array . length ) ; return newarray ; } private DatatypeValidator [ ] [ ] resize ( DatatypeValidator array [ ] [ ] , int newsize ) { return array ; } private XMLContentModel [ ] [ ] resize ( XMLContentModel array [ ] [ ] , int newsize ) { return array ; } private QName [ ] [ ] resize ( QName array [ ] [ ] , int newsize ) { return array ; } private String [ ] [ ] resize ( String array [ ] [ ] , int newsize ) { String newarray [ ] [ ] = new String [ newsize ] [ ] ; System . arraycopy ( array , 0 , newarray , 0 , array . length ) ; return newarray ; } private TraverseSchema . ComplexTypeInfo [ ] [ ] resize ( TraverseSchema . ComplexTypeInfo array [ ] [ ] , int newsize ) { TraverseSchema . ComplexTypeInfo newarray [ ] [ ] = new TraverseSchema . ComplexTypeInfo [ newsize ] [ ] ; System . arraycopy ( array , 0 , newarray , 0 , array . length ) ; return newarray ; } } 	0
package org . w3c . dom . events ; import org . w3c . dom . DOMException ; public interface DocumentEvent { public Event createEvent ( String eventType ) throws DOMException ; } 	1
package org . xml . sax . helpers ; import java . io . IOException ; import org . xml . sax . XMLReader ; import org . xml . sax . XMLFilter ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . Attributes ; import org . xml . sax . EntityResolver ; import org . xml . sax . DTDHandler ; import org . xml . sax . ContentHandler ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . SAXNotRecognizedException ; public class XMLFilterImpl implements XMLFilter , EntityResolver , DTDHandler , ContentHandler , ErrorHandler { public XMLFilterImpl ( ) { super ( ) ; } public XMLFilterImpl ( XMLReader parent ) { super ( ) ; setParent ( parent ) ; } public void setParent ( XMLReader parent ) { if ( parent == null ) { throw new NullPointerException ( "Null parent" ) ; } this . parent = parent ; } public XMLReader getParent ( ) { return parent ; } public void setFeature ( String name , boolean state ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( parent != null ) { parent . setFeature ( name , state ) ; } else { throw new SAXNotRecognizedException ( "Feature: " + name ) ; } } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( parent != null ) { return parent . getFeature ( name ) ; } else { throw new SAXNotRecognizedException ( "Feature: " + name ) ; } } public void setProperty ( String name , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( parent != null ) { parent . setProperty ( name , value ) ; } else { throw new SAXNotRecognizedException ( "Property: " + name ) ; } } public Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( parent != null ) { return parent . getProperty ( name ) ; } else { throw new SAXNotRecognizedException ( "Property: " + name ) ; } } public void setEntityResolver ( EntityResolver resolver ) { if ( resolver == null ) { throw new NullPointerException ( "Null entity resolver" ) ; } else { entityResolver = resolver ; } } public EntityResolver getEntityResolver ( ) { return entityResolver ; } public void setDTDHandler ( DTDHandler handler ) { if ( handler == null ) { throw new NullPointerException ( "Null DTD handler" ) ; } else { dtdHandler = handler ; } } public DTDHandler getDTDHandler ( ) { return dtdHandler ; } public void setContentHandler ( ContentHandler handler ) { if ( handler == null ) { throw new NullPointerException ( "Null content handler" ) ; } else { contentHandler = handler ; } } public ContentHandler getContentHandler ( ) { return contentHandler ; } public void setErrorHandler ( ErrorHandler handler ) { if ( handler == null ) { throw new NullPointerException ( "Null error handler" ) ; } else { errorHandler = handler ; } } public ErrorHandler getErrorHandler ( ) { return errorHandler ; } public void parse ( InputSource input ) throws SAXException , IOException { setupParse ( ) ; parent . parse ( input ) ; } public void parse ( String systemId ) throws SAXException , IOException { parse ( new InputSource ( systemId ) ) ; } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( entityResolver != null ) { return entityResolver . resolveEntity ( publicId , systemId ) ; } else { return null ; } } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { if ( dtdHandler != null ) { dtdHandler . notationDecl ( name , publicId , systemId ) ; } } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( dtdHandler != null ) { dtdHandler . unparsedEntityDecl ( name , publicId , systemId , notationName ) ; } } public void setDocumentLocator ( Locator locator ) { this . locator = locator ; if ( contentHandler != null ) { contentHandler . setDocumentLocator ( locator ) ; } } public void startDocument ( ) throws SAXException { if ( contentHandler != null ) { contentHandler . startDocument ( ) ; } } public void endDocument ( ) throws SAXException { if ( contentHandler != null ) { contentHandler . endDocument ( ) ; } } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { if ( contentHandler != null ) { contentHandler . startPrefixMapping ( prefix , uri ) ; } } public void endPrefixMapping ( String prefix ) throws SAXException { if ( contentHandler != null ) { contentHandler . endPrefixMapping ( prefix ) ; } } public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { if ( contentHandler != null ) { contentHandler . startElement ( uri , localName , qName , atts ) ; } } public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( contentHandler != null ) { contentHandler . endElement ( uri , localName , qName ) ; } } public void characters ( char ch [ ] , int start , int length ) throws SAXException { if ( contentHandler != null ) { contentHandler . characters ( ch , start , length ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { if ( contentHandler != null ) { contentHandler . ignorableWhitespace ( ch , start , length ) ; } } public void processingInstruction ( String target , String data ) throws SAXException { if ( contentHandler != null ) { contentHandler . processingInstruction ( target , data ) ; } } public void skippedEntity ( String name ) throws SAXException { if ( contentHandler != null ) { contentHandler . skippedEntity ( name ) ; } } public void warning ( SAXParseException e ) throws SAXException { if ( errorHandler != null ) { errorHandler . warning ( e ) ; } } public void error ( SAXParseException e ) throws SAXException { if ( errorHandler != null ) { errorHandler . error ( e ) ; } } public void fatalError ( SAXParseException e ) throws SAXException { if ( errorHandler != null ) { errorHandler . fatalError ( e ) ; } } private void setupParse ( ) { if ( parent == null ) { throw new NullPointerException ( "No parent for filter" ) ; } parent . setEntityResolver ( this ) ; parent . setDTDHandler ( this ) ; parent . setContentHandler ( this ) ; parent . setErrorHandler ( this ) ; } private XMLReader parent = null ; private Locator locator = null ; private EntityResolver entityResolver = null ; private DTDHandler dtdHandler = null ; private ContentHandler contentHandler = null ; private ErrorHandler errorHandler = null ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ParentNode extends NodeImpl { static final long serialVersionUID = 2815829867152120872L ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ParentNode ( ) { } public Node cloneNode ( boolean deep ) { ParentNode newnode = ( ParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1
package org . apache . xerces . utils ; import java . util . Locale ; import java . util . ResourceBundle ; import java . util . ListResourceBundle ; public class XMLMessages implements XMLMessageProvider { public static final String XML_DOMAIN = "http://www.w3.org/TR/1998/REC-xml-19980210" ; public static final String XMLNS_DOMAIN = "http://www.w3.org/TR/1999/REC-xml-names-19990114" ; public void setLocale ( Locale locale ) { fLocale = locale ; } public Locale getLocale ( ) { return fLocale ; } public String createMessage ( Locale locale , int majorCode , int minorCode , Object args [ ] ) { boolean throwex = false ; if ( fResourceBundle == null || locale != fLocale ) { if ( locale != null ) fResourceBundle = ListResourceBundle . getBundle ( "org.apache.xerces.msg.XMLMessages" , locale ) ; if ( fResourceBundle == null ) fResourceBundle = ListResourceBundle . getBundle ( "org.apache.xerces.msg.XMLMessages" ) ; } if ( majorCode < 0 || majorCode >= fgMessageKeys . length - 1 ) { majorCode = MSG_BAD_MAJORCODE ; throwex = true ; } String msgKey = fgMessageKeys [ majorCode ] ; String msg = fResourceBundle . getString ( msgKey ) ; if ( args != null ) { try { msg = java . text . MessageFormat . format ( msg , args ) ; } catch ( Exception e ) { msg = fResourceBundle . getString ( fgMessageKeys [ MSG_FORMAT_FAILURE ] ) ; msg += " " + fResourceBundle . getString ( msgKey ) ; } } if ( throwex ) { throw new RuntimeException ( msg ) ; } return msg ; } private Locale fLocale = null ; private ResourceBundle fResourceBundle = null ; public static final int MSG_BAD_MAJORCODE = 0 , MSG_FORMAT_FAILURE = 1 , MSG_LESSTHAN_IN_ATTVALUE = 2 , MSG_ROOT_ELEMENT_TYPE = 3 , MSG_IDREFS_INVALID = 4 , MSG_NMTOKENS_INVALID = 5 , MSG_RESERVED_PITARGET = 6 , MSG_SPACE_REQUIRED_IN_PI = 7 , MSG_INVALID_CHAR_IN_PI = 8 , MSG_DASH_DASH_IN_COMMENT = 9 , MSG_INVALID_CHAR_IN_COMMENT = 10 , MSG_INVALID_CHARREF = 11 , MSG_INVALID_CHAR_IN_ATTVALUE = 12 , MSG_QUOTE_REQUIRED_IN_ATTVALUE = 13 , MSG_NAME_REQUIRED_IN_REFERENCE = 14 , MSG_SEMICOLON_REQUIRED_IN_REFERENCE = 15 , MSG_DIGIT_REQUIRED_IN_CHARREF = 16 , MSG_HEXDIGIT_REQUIRED_IN_CHARREF = 17 , MSG_SEMICOLON_REQUIRED_IN_CHARREF = 18 , MSG_QUOTE_REQUIRED_IN_SYSTEMID = 19 , MSG_INVALID_CHAR_IN_SYSTEMID = 20 , MSG_QUOTE_REQUIRED_IN_PUBLICID = 21 , MSG_INVALID_CHAR_IN_PUBLICID = 22 , MSG_INCLUDESECT_UNTERMINATED = 23 , MSG_IGNORESECT_UNTERMINATED = 24 , MSG_INVALID_CHAR_IN_IGNORESECT = 25 , MSG_ELEMENT_UNTERMINATED = 26 , MSG_EQ_REQUIRED_IN_ATTRIBUTE = 27 , MSG_ATTRIBUTE_NOT_UNIQUE = 28 , MSG_ENCODINGDECL_REQUIRED = 29 , MSG_VERSIONINFO_REQUIRED = 30 , MSG_EQ_REQUIRED_IN_XMLDECL = 31 , MSG_EQ_REQUIRED_IN_TEXTDECL = 32 , MSG_QUOTE_REQUIRED_IN_XMLDECL = 33 , MSG_QUOTE_REQUIRED_IN_TEXTDECL = 34 , MSG_INVALID_CHAR_IN_XMLDECL = 35 , MSG_INVALID_CHAR_IN_TEXTDECL = 36 , MSG_VERSIONINFO_INVALID = 37 , MSG_VERSION_NOT_SUPPORTED = 38 , MSG_SPACE_REQUIRED_IN_TEXTDECL = 39 , MSG_ENCODINGDECL_INVALID = 40 , MSG_SDDECL_INVALID = 41 , MSG_XMLDECL_UNTERMINATED = 42 , MSG_TEXTDECL_UNTERMINATED = 43 , MSG_INVALID_CHAR_IN_INTERNAL_SUBSET = 44 , MSG_INVALID_CHAR_IN_EXTERNAL_SUBSET = 45 , MSG_INVALID_CHAR_IN_ENTITYVALUE = 46 , MSG_MIXED_CONTENT_UNTERMINATED = 47 , MSG_NAME_REQUIRED_IN_PEREFERENCE = 48 , MSG_SEMICOLON_REQUIRED_IN_PEREFERENCE = 49 , MSG_EXTERNALID_REQUIRED = 50 , MSG_PEREFERENCE_WITHIN_MARKUP = 51 , MSG_INVALID_CHAR_IN_PROLOG = 52 , MSG_INVALID_CHAR_IN_MISC = 53 , MSG_INVALID_CHAR_IN_CDSECT = 54 , MSG_INVALID_CHAR_IN_CONTENT = 55 , MSG_ETAG_REQUIRED = 56 , MSG_ETAG_UNTERMINATED = 57 , MSG_ATTRIBUTE_NAME_REQUIRED_IN_ATTDEF = 58 , MSG_ATTTYPE_REQUIRED_IN_ATTDEF = 59 , MSG_PUBIDCHAR_ILLEGAL = 60 , MSG_ENCODING_NOT_SUPPORTED = 61 , MSG_ENTITY_NOT_DECLARED = 62 , MSG_REFERENCE_TO_UNPARSED_ENTITY = 63 , MSG_REFERENCE_TO_EXTERNAL_ENTITY = 64 , MSG_XML_LANG_INVALID = 65 , MSG_CDSECT_UNTERMINATED = 66 , MSG_DUPLICATE_TYPE_IN_MIXED_CONTENT = 67 , MSG_ELEMENT_ENTITY_MISMATCH = 68 , MSG_ID_DEFAULT_TYPE_INVALID = 69 , MSG_ENCODING_REQUIRED = 70 , MSG_RECURSIVE_REFERENCE = 71 , MSG_RECURSIVE_PEREFERENCE = 72 , MSG_IMPROPER_DECLARATION_NESTING = 73 , MSG_IMPROPER_GROUP_NESTING = 74 , MSG_ID_INVALID = 75 , MSG_ID_NOT_UNIQUE = 76 , MSG_IDREF_INVALID = 77 , MSG_NMTOKEN_INVALID = 78 , MSG_ENTITY_INVALID = 79 , MSG_ENTITIES_INVALID = 80 , MSG_ELEMENT_WITH_ID_REQUIRED = 81 , MSG_ATTRIBUTE_NOT_DECLARED = 82 , MSG_ELEMENT_NOT_DECLARED = 83 , MSG_AVAILABLE1 = 84 , MSG_DUPLICATE_ATTDEF = 85 , MSG_MORE_THAN_ONE_ID_ATTRIBUTE = 86 , MSG_CONTENT_INVALID = 87 , MSG_CONTENT_INCOMPLETE = 88 , MSG_ELEMENT_ALREADY_DECLARED = 89 , MSG_ATTRIBUTE_VALUE_NOT_IN_LIST = 90 , MSG_AVAILABLE2 = 91 , MSG_UNDECLARED_ELEMENT_IN_CONTENTSPEC = 92 , MSG_FIXED_ATTVALUE_INVALID = 93 , MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED = 94 , MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED = 95 , MSG_AVAILABLE3 = 96 , MSG_AVAILABLE4 = 97 , MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN = 98 , MSG_AVAILABLE5 = 99 , MSG_SYSTEMID_UNTERMINATED = 100 , MSG_PUBLICID_UNTERMINATED = 101 , MSG_EXTERNAL_ENTITY_NOT_PERMITTED = 102 , MSG_AVAILABLE6 = 103 , MSG_XMLDECL_MUST_BE_FIRST = 104 , MSG_TEXTDECL_MUST_BE_FIRST = 105 , MSG_ELEMENTDECL_UNTERMINATED = 106 , MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL = 107 , MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL = 108 , MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL = 109 , MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL = 110 , MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL = 111 , MSG_ENTITYDECL_UNTERMINATED = 112 , MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL = 113 , MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL = 114 , MSG_NAME_REQUIRED_IN_NOTATIONTYPE = 115 , MSG_NMTOKEN_REQUIRED_IN_ENUMERATION = 116 , MSG_NOTATION_NOT_DECLARED_FOR_NOTATIONTYPE_ATTRIBUTE = 117 , MSG_NOTATIONTYPE_UNTERMINATED = 118 , MSG_ENUMERATION_UNTERMINATED = 119 , MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL = 120 , MSG_MORE_THAN_ONE_NOTATION_ATTRIBUTE = 121 , MSG_NOTATIONDECL_UNTERMINATED = 122 , MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE = 123 , MSG_CDEND_IN_CONTENT = 124 , MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL = 125 , MSG_TWO_COLONS_IN_QNAME = 126 , MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT = 127 , MSG_MARKUP_NOT_RECOGNIZED_IN_MISC = 128 , MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG = 129 , MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE = 130 , MSG_PITARGET_REQUIRED = 131 , MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE = 132 , MSG_URI_FRAGMENT_IN_SYSTEMID = 133 , MSG_ROOT_ELEMENT_REQUIRED = 134 , MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL = 135 , MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE = 136 , MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL = 137 , MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF = 138 , MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF = 139 , MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF = 140 , MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL = 141 , MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL = 142 , MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE = 143 , MSG_XML_SPACE_DECLARATION_ILLEGAL = 144 , MSG_CLOSE_PAREN_REQUIRED_IN_MIXED = 145 , MSG_CONTENTSPEC_REQUIRED_IN_ELEMENTDECL = 146 , MSG_DOCTYPEDECL_UNTERMINATED = 147 , MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL = 148 , MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT = 149 , MSG_MARKUP_NOT_RECOGNIZED_IN_DTD = 150 , MSG_ATTRIBUTE_VALUE_UNTERMINATED = 151 , MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN = 152 , MSG_ROOT_ELEMENT_TYPE_REQUIRED = 153 , MSG_SPACE_REQUIRED_AFTER_PUBIDLITERAL_IN_EXTERNALID = 154 , MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL = 155 , MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL = 156 , MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL = 157 , MSG_SPACE_REQUIRED_BEFORE_PUBIDLITERAL_IN_EXTERNALID = 158 , MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL = 159 , MSG_SPACE_REQUIRED_BEFORE_SYSTEMLITERAL_IN_EXTERNALID = 160 , MSG_REFERENCE_NOT_IN_ONE_ENTITY = 161 , MSG_COMMENT_NOT_IN_ONE_ENTITY = 162 , MSG_COMMENT_UNTERMINATED = 163 , MSG_PI_UNTERMINATED = 164 , MSG_PI_NOT_IN_ONE_ENTITY = 165 , MSG_REFERENCE_UNTERMINATED = 166 , MSG_PREFIX_DECLARED = 167 , MSG_ATT_DEFAULT_INVALID = 168 , MSG_GENERIC_SCHEMA_ERROR = 169 , MSG_MAX_CODE = 200 ; private static final String [ ] fgMessageKeys = { "BadMajorCode" , "FormatFailed" , "LessthanInAttValue" , "RootElementTypeMustMatchDoctypedecl" , "IDREFSInvalid" , "NMTOKENSInvalid" , "ReservedPITarget" , "SpaceRequiredInPI" , "InvalidCharInPI" , "DashDashInComment" , "InvalidCharInComment" , "InvalidCharRef" , "InvalidCharInAttValue" , "QuoteRequiredInAttValue" , "NameRequiredInReference" , "SemicolonRequiredInReference" , "DigitRequiredInCharRef" , "HexdigitRequiredInCharRef" , "SemicolonRequiredInCharRef" , "QuoteRequiredInSystemID" , "InvalidCharInSystemID" , "QuoteRequiredInPublicID" , "InvalidCharInPublicID" , "IncludeSectUnterminated" , "IgnoreSectUnterminated" , "InvalidCharInIgnoreSect" , "ElementUnterminated" , "EqRequiredInAttribute" , "AttributeNotUnique" , "EncodingDeclRequired" , "VersionInfoRequired" , "EqRequiredInXMLDecl" , "EqRequiredInTextDecl" , "QuoteRequiredInXMLDecl" , "QuoteRequiredInTextDecl" , "InvalidCharInXMLDecl" , "InvalidCharInTextDecl" , "VersionInfoInvalid" , "VersionNotSupported" , "SpaceRequiredInTextDecl" , "EncodingDeclInvalid" , "SDDeclInvalid" , "XMLDeclUnterminated" , "TextDeclUnterminated" , "InvalidCharInInternalSubset" , "InvalidCharInExternalSubset" , "InvalidCharInEntityValue" , "MixedContentUnterminated" , "NameRequiredInPEReference" , "SemicolonRequiredInPEReference" , "ExternalIDRequired" , "PEReferenceWithinMarkup" , "InvalidCharInProlog" , "InvalidCharInMisc" , "InvalidCharInCDSect" , "InvalidCharInContent" , "ETagRequired" , "ETagUnterminated" , "AttNameRequiredInAttDef" , "AttTypeRequiredInAttDef" , "PubidCharIllegal" , "EncodingNotSupported" , "EntityNotDeclared" , "ReferenceToUnparsedEntity" , "ReferenceToExternalEntity" , "XMLLangInvalid" , "CDSectUnterminated" , "DuplicateTypeInMixedContent" , "ElementEntityMismatch" , "IDDefaultTypeInvalid" , "EncodingRequired" , "RecursiveReference" , "RecursivePEReference" , "ImproperDeclarationNesting" , "ImproperGroupNesting" , "IDInvalid" , "IDNotUnique" , "IDREFInvalid" , "NMTOKENInvalid" , "ENTITYInvalid" , "ENTITIESInvalid" , "MSG_ELEMENT_WITH_ID_REQUIRED" , "MSG_ATTRIBUTE_NOT_DECLARED" , "MSG_ELEMENT_NOT_DECLARED" , "MSG_AVAILABLE1" , "MSG_DUPLICATE_ATTDEF" , "MSG_MORE_THAN_ONE_ID_ATTRIBUTE" , "MSG_CONTENT_INVALID" , "MSG_CONTENT_INCOMPLETE" , "MSG_ELEMENT_ALREADY_DECLARED" , "MSG_ATTRIBUTE_VALUE_NOT_IN_LIST" , "MSG_AVAILABLE2" , "UndeclaredElementInContentSpec" , "MSG_FIXED_ATTVALUE_INVALID" , "MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED" , "MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED" , "MSG_AVAILABLE3" , "MSG_AVAILABLE4" , "MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN" , "MSG_AVAILABLE5" , "SystemIDUnterminated" , "PublicIDUnterminated" , "MSG_EXTERNAL_ENTITY_NOT_PERMITTED" , "MSG_AVAILABLE6" , "XMLDeclMustBeFirst" , "TextDeclMustBeFirst" , "ElementDeclUnterminated" , "MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL" , "MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL" , "MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL" , "MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL" , "MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL" , "EntityDeclUnterminated" , "MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL" , "MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL" , "MSG_NAME_REQUIRED_IN_NOTATIONTYPE" , "MSG_NMTOKEN_REQUIRED_IN_ENUMERATION" , "MSG_NOTATION_NOT_DECLARED_FOR_NOTATIONTYPE_ATTRIBUTE" , "NotationTypeUnterminated" , "EnumerationUnterminated" , "MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL" , "MSG_MORE_THAN_ONE_NOTATION_ATTRIBUTE" , "NotationDeclUnterminated" , "MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE" , "CDEndInContent" , "MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL" , "TwoColonsInQName" , "MarkupNotRecognizedInContent" , "MarkupNotRecognizedInMisc" , "MarkupNotRecognizedInProlog" , "MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE" , "PITargetRequired" , "MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE" , "MSG_URI_FRAGMENT_IN_SYSTEMID" , "RootElementRequired" , "MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL" , "MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE" , "MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL" , "MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF" , "MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF" , "MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF" , "MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL" , "MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL" , "MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE" , "MSG_XML_SPACE_DECLARATION_ILLEGAL" , "MSG_CLOSE_PAREN_REQUIRED_IN_MIXED" , "MSG_CONTENTSPEC_REQUIRED_IN_ELEMENTDECL" , "DoctypedeclUnterminated" , "MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL" , "MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT" , "MSG_MARKUP_NOT_RECOGNIZED_IN_DTD" , "AttributeValueUnterminated" , "MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN" , "MSG_ROOT_ELEMENT_TYPE_REQUIRED" , "MSG_SPACE_REQUIRED_AFTER_PUBIDLITERAL_IN_EXTERNALID" , "MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL" , "MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL" , "MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL" , "MSG_SPACE_REQUIRED_BEFORE_PUBIDLITERAL_IN_EXTERNALID" , "MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL" , "MSG_SPACE_REQUIRED_BEFORE_SYSTEMLITERAL_IN_EXTERNALID" , "ReferenceNotInOneEntity" , "CommentNotInOneEntity" , "CommentUnterminated" , "PIUnterminated" , "PINotInOneEntity" , "ReferenceUnterminated" , "PrefixDeclared" , "MSG_ATT_DEFAULT_INVALID" , "MSG_GENERIC_SCHEMA_ERROR" , "" } ; public static final int VC_ROOT_ELEMENT_TYPE = 1 , VC_IDREF = 2 , VC_NAME_TOKEN = 3 , P17_RESERVED_PITARGET = 4 , P16_WHITESPACE_REQUIRED = 5 , P16_INVALID_CHARACTER = 6 , P15_DASH_DASH = 7 , P15_INVALID_CHARACTER = 8 , WFC_LEGAL_CHARACTER = 9 , P10_INVALID_CHARACTER = 10 , WFC_NO_LESSTHAN_IN_ATTVALUE = 11 , P10_QUOTE_REQUIRED = 12 , P68_NAME_REQUIRED = 13 , P68_SEMICOLON_REQUIRED = 14 , P66_DIGIT_REQUIRED = 15 , P66_HEXDIGIT_REQUIRED = 16 , P66_SEMICOLON_REQUIRED = 17 , P11_QUOTE_REQUIRED = 18 , P11_INVALID_CHARACTER = 19 , P12_QUOTE_REQUIRED = 20 , P12_INVALID_CHARACTER = 21 , P62_UNTERMINATED = 22 , P63_UNTERMINATED = 23 , P65_INVALID_CHARACTER = 24 , P40_UNTERMINATED = 25 , P41_EQ_REQUIRED = 26 , WFC_UNIQUE_ATT_SPEC = 27 , P77_ENCODINGDECL_REQUIRED = 28 , P23_VERSIONINFO_REQUIRED = 29 , P24_EQ_REQUIRED = 30 , P32_EQ_REQUIRED = 31 , P80_EQ_REQUIRED = 32 , P24_QUOTE_REQUIRED = 33 , P32_QUOTE_REQUIRED = 34 , P80_QUOTE_REQUIRED = 35 , P26_INVALID_CHARACTER = 36 , P32_INVALID_CHARACTER = 37 , P81_INVALID_CHARACTER = 38 , P26_INVALID_VALUE = 39 , P26_NOT_SUPPORTED = 40 , P80_WHITESPACE_REQUIRED = 41 , P81_INVALID_VALUE = 42 , P32_INVALID_VALUE = 43 , P23_UNTERMINATED = 44 , P77_UNTERMINATED = 45 , P28_INVALID_CHARACTER = 46 , P30_INVALID_CHARACTER = 47 , P9_INVALID_CHARACTER = 48 , P51_UNTERMINATED = 49 , P69_NAME_REQUIRED = 50 , P69_SEMICOLON_REQUIRED = 51 , P75_INVALID = 52 , WFC_PES_IN_INTERNAL_SUBSET = 53 , P22_INVALID_CHARACTER = 54 , P27_INVALID_CHARACTER = 55 , P20_INVALID_CHARACTER = 56 , P43_INVALID_CHARACTER = 57 , P39_UNTERMINATED = 58 , P42_UNTERMINATED = 59 , P81_NOT_SUPPORTED = 60 , WFC_ENTITY_DECLARED = 61 , VC_ENTITY_DECLARED = 62 , WFC_PARSED_ENTITY = 63 , WFC_NO_EXTERNAL_ENTITY_REFERENCES = 64 , P33_INVALID = 65 , P18_UNTERMINATED = 66 , VC_NO_DUPLICATE_TYPES = 67 , P78_NOT_WELLFORMED = 68 , VC_ID_ATTRIBUTE_DEFAULT = 69 , P53_NAME_REQUIRED = 70 , P53_ATTTYPE_REQUIRED = 71 , P81_REQUIRED = 72 , WFC_NO_RECURSION = 73 , VC_PROPER_DECLARATION_PE_NESTING = 74 , VC_PROPER_GROUP_PE_NESTING = 75 , VC_ID = 76 , VC_ENTITY_NAME = 77 , VC_ATTRIBUTE_VALUE_TYPE = 78 , VC_ELEMENT_VALID = 79 , VC_STANDALONE_DOCUMENT_DECLARATION = 80 , VC_ONE_ID_PER_ELEMENT_TYPE = 81 , VC_UNIQUE_ELEMENT_TYPE_DECLARATION = 82 , P45_UNDECLARED_ELEMENT_IN_CONTENTSPEC = 83 , VC_NOTATION_ATTRIBUTES = 84 , P53_DUPLICATE = 85 , VC_ENUMERATION = 86 , VC_FIXED_ATTRIBUTE_DEFAULT = 87 , VC_REQUIRED_ATTRIBUTE = 88 , VC_NOTATION_DECLARED = 89 , P58_NAME_REQUIRED = 90 , P58_UNTERMINATED = 91 , P59_NMTOKEN_REQUIRED = 92 , P59_UNTERMINATED = 93 , P70_SPACE = 94 , P70_REQUIRED_NAME = 95 , P70_REQUIRED_SPACE = 96 , P71_UNTERMINATED = 97 , P72_SPACE = 98 , P72_UNTERMINATED = 99 , P76_REQUIRED = 100 , P82_NAME_REQUIRED = 101 , P82_SPACE_REQUIRED = 102 , P82_UNTERMINATED = 103 , P14_INVALID = 104 , P16_PITARGET_REQUIRED = 105 , P16_REQUIRED = 106 , P1_ELEMENT_REQUIRED = 107 , P22_NOT_RECOGNIZED = 108 , P27_NOT_RECOGNIZED = 109 , P43_NOT_RECOGNIZED = 110 , P52_ELEMENT_TYPE_REQUIRED = 111 , P52_SPACE_REQUIRED = 112 , P53_SPACE_REQUIRED = 113 , P58_OPEN_PAREN_REQUIRED = 114 , P58_SPACE_REQUIRED = 115 , P60_SPACE_REQUIRED = 116 , S2_10_DECLARATION_ILLEGAL = 117 , P39_ELEMENT_TYPE_REQUIRED = 118 , P28_ROOT_ELEMENT_TYPE_REQUIRED = 119 , P28_SPACE_REQUIRED = 120 , P28_UNTERMINATED = 121 , P29_NOT_RECOGNIZED = 122 , P45_CONTENTSPEC_REQUIRED = 123 , P45_ELEMENT_TYPE_REQUIRED = 124 , P45_SPACE_REQUIRED = 125 , P45_UNTERMINATED = 126 , P47_CLOSE_PAREN_REQUIRED = 127 , P47_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED = 128 , P51_CLOSE_PAREN_REQUIRED = 129 , P51_ELEMENT_TYPE_REQUIRED = 130 , P75_SPACE_REQUIRED = 131 , P76_SPACE_REQUIRED = 132 , P15_UNTERMINATED = 133 , P16_UNTERMINATED = 134 , P67_UNTERMINATED = 135 , P10_UNTERMINATED = 136 , P22_XMLDECL_MUST_BE_FIRST = 137 , P30_TEXTDECL_MUST_BE_FIRST = 138 , P5_INVALID_CHARACTER = 139 , P11_UNTERMINATED = 140 , P12_UNTERMINATED = 141 , P11_URI_FRAGMENT = 142 , VC_ONE_NOTATION_PER_ELEMENT_TYPE = 143 , NC_PREFIX_DECLARED = 144 , VC_ATTRIBUTE_DEFAULT_LEGAL = 145 , SCHEMA_GENERIC_ERROR = 146 , CONSTRAINT_MAX_CODE = 200 ; } 	0
package javax . xml . parsers ; public abstract class DocumentBuilderFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.DocumentBuilderFactory" ; private static String factory = "org.apache.xerces.jaxp.DocumentBuilderFactoryImpl" ; protected DocumentBuilderFactory ( ) { super ( ) ; } public static DocumentBuilderFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( DocumentBuilderFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"" + "javax.xml.parsers.DocumentBuilderFactory\"" ) ; } } public abstract DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLTimerElementImpl extends WMLElementImpl implements WMLTimerElement { public WMLTimerElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setValue ( String newValue ) { setAttribute ( "value" , newValue ) ; } public String getValue ( ) { return getAttribute ( "value" ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setName ( String newValue ) { setAttribute ( "name" , newValue ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; public class NamedNodeMapImpl implements NamedNodeMap , Serializable { static final long serialVersionUID = - 7039242451046758020L ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short CHANGED = 0x1 << 1 ; protected final static short HASDEFAULTS = 0x1 << 2 ; protected Vector nodes ; protected NodeImpl ownerNode ; protected NamedNodeMapImpl ( NodeImpl ownerNode ) { this . ownerNode = ownerNode ; } public int getLength ( ) { return ( nodes != null ) ? nodes . size ( ) : 0 ; } public Node item ( int index ) { return ( nodes != null && index < nodes . size ( ) ) ? ( Node ) ( nodes . elementAt ( index ) ) : null ; } public Node getNamedItem ( String name ) { int i = findNamePoint ( name , 0 ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node getNamedItemNS ( String namespaceURI , String localName ) { int i = findNamePoint ( namespaceURI , localName ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNamespaceURI ( ) , arg . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { NamedNodeMapImpl newmap = new NamedNodeMapImpl ( ownerNode ) ; newmap . cloneContent ( this ) ; return newmap ; } protected void cloneContent ( NamedNodeMapImpl srcmap ) { if ( srcmap . nodes != null ) { nodes = new Vector ( srcmap . nodes . size ( ) ) ; for ( int i = 0 ; i < srcmap . nodes . size ( ) ; ++ i ) { NodeImpl n = ( NodeImpl ) srcmap . nodes . elementAt ( i ) ; NodeImpl clone = ( NodeImpl ) n . cloneNode ( true ) ; clone . isSpecified ( n . isSpecified ( ) ) ; nodes . insertElementAt ( clone , i ) ; } } } void setReadOnly ( boolean readOnly , boolean deep ) { isReadOnly ( readOnly ) ; if ( deep && nodes != null ) { Enumeration e = nodes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( NodeImpl ) e . nextElement ( ) ) . setReadOnly ( readOnly , deep ) ; } } } boolean getReadOnly ( ) { return isReadOnly ( ) ; } void setOwnerDocument ( DocumentImpl doc ) { if ( nodes != null ) { for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { ( ( NodeImpl ) item ( i ) ) . setOwnerDocument ( doc ) ; } } } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean changed ( ) { return ( flags & CHANGED ) != 0 ; } final void changed ( boolean value ) { flags = ( short ) ( value ? flags | CHANGED : flags & ~ CHANGED ) ; } final boolean hasDefaults ( ) { return ( flags & HASDEFAULTS ) != 0 ; } final void hasDefaults ( boolean value ) { flags = ( short ) ( value ? flags | HASDEFAULTS : flags & ~ HASDEFAULTS ) ; } protected int findNamePoint ( String name , int start ) { int i = 0 ; if ( nodes != null ) { int first = start ; int last = nodes . size ( ) - 1 ; while ( first <= last ) { i = ( first + last ) / 2 ; int test = name . compareTo ( ( ( Node ) ( nodes . elementAt ( i ) ) ) . getNodeName ( ) ) ; if ( test == 0 ) { return i ; } else if ( test < 0 ) { last = i - 1 ; } else { first = i + 1 ; } } if ( first > i ) { i = first ; } } return - 1 - i ; } protected int findNamePoint ( String namespaceURI , String name ) { if ( nodes == null ) return - 1 ; if ( namespaceURI == null ) return - 1 ; if ( name == null ) return - 1 ; for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { NodeImpl a = ( NodeImpl ) nodes . elementAt ( i ) ; if ( namespaceURI . equals ( a . getNamespaceURI ( ) ) && name . equals ( a . getLocalName ( ) ) ) { return i ; } } return - 1 ; } } 	1
package org . xml . sax . helpers ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . Attributes ; import org . xml . sax . EntityResolver ; import org . xml . sax . DTDHandler ; import org . xml . sax . ContentHandler ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class DefaultHandler implements EntityResolver , DTDHandler , ContentHandler , ErrorHandler { public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException { return null ; } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { } public void setDocumentLocator ( Locator locator ) { } public void startDocument ( ) throws SAXException { } public void endDocument ( ) throws SAXException { } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { } public void endPrefixMapping ( String prefix ) throws SAXException { } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { } public void endElement ( String uri , String localName , String qName ) throws SAXException { } public void characters ( char ch [ ] , int start , int length ) throws SAXException { } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { } public void processingInstruction ( String target , String data ) throws SAXException { } public void skippedEntity ( String name ) throws SAXException { } public void warning ( SAXParseException e ) throws SAXException { } public void error ( SAXParseException e ) throws SAXException { } public void fatalError ( SAXParseException e ) throws SAXException { throw e ; } } 	0
package org . w3c . dom ; public interface NamedNodeMap { public Node getNamedItem ( String name ) ; public Node setNamedItem ( Node arg ) throws DOMException ; public Node removeNamedItem ( String name ) throws DOMException ; public Node item ( int index ) ; public int getLength ( ) ; public Node getNamedItemNS ( String namespaceURI , String localName ) ; public Node setNamedItemNS ( Node arg ) throws DOMException ; public Node removeNamedItemNS ( String namespaceURI , String localName ) throws DOMException ; } 	1
package org . w3c . dom . html ; import org . w3c . dom . DOMException ; public interface HTMLTableSectionElement extends HTMLElement { public String getAlign ( ) ; public void setAlign ( String align ) ; public String getCh ( ) ; public void setCh ( String ch ) ; public String getChOff ( ) ; public void setChOff ( String chOff ) ; public String getVAlign ( ) ; public void setVAlign ( String vAlign ) ; public HTMLCollection getRows ( ) ; public HTMLElement insertRow ( int index ) throws DOMException ; public void deleteRow ( int index ) throws DOMException ; } 	0
package org . apache . xml . serialize ; import java . util . Hashtable ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Node ; import org . w3c . dom . html . HTMLDocument ; public class OutputFormat { public static class DTD { public static final String HTMLPublicId = "-//W3C//DTD HTML 4.0//EN" ; public static final String HTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; public static final String XHTMLPublicId = "-//W3C//DTD XHTML 1.0 Strict//EN" ; public static final String XHTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; } public static class Defaults { public static final int Indent = 4 ; public static final String Encoding = "UTF-8" ; public static final int LineWidth = 72 ; } private String _method ; private String _version ; private int _indent = 0 ; private String _encoding = Defaults . Encoding ; private String _mediaType ; private String _doctypeSystem ; private String _doctypePublic ; private boolean _omitXmlDeclaration = false ; private boolean _omitDoctype = false ; private boolean _omitComments = false ; private boolean _stripComments = false ; private boolean _standalone = false ; private String [ ] _cdataElements ; private String [ ] _nonEscapingElements ; private String _lineSeparator = LineSeparator . Web ; private int _lineWidth = Defaults . LineWidth ; private boolean _preserve = false ; public OutputFormat ( ) { } public OutputFormat ( String method , String encoding , boolean indenting ) { setMethod ( method ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public OutputFormat ( Document doc ) { setMethod ( whichMethod ( doc ) ) ; setDoctype ( whichDoctypePublic ( doc ) , whichDoctypeSystem ( doc ) ) ; setMediaType ( whichMediaType ( getMethod ( ) ) ) ; } public OutputFormat ( Document doc , String encoding , boolean indenting ) { this ( doc ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public String getMethod ( ) { return _method ; } public void setMethod ( String method ) { _method = method ; } public String getVersion ( ) { return _version ; } public void setVersion ( String version ) { _version = version ; } public int getIndent ( ) { return _indent ; } public boolean getIndenting ( ) { return ( _indent > 0 ) ; } public void setIndent ( int indent ) { if ( indent < 0 ) _indent = 0 ; else _indent = indent ; } public void setIndenting ( boolean on ) { if ( on ) { _indent = Defaults . Indent ; _lineWidth = Defaults . LineWidth ; } else { _indent = 0 ; _lineWidth = 0 ; } } public String getEncoding ( ) { return _encoding ; } public void setEncoding ( String encoding ) { _encoding = encoding ; } public String getMediaType ( ) { return _mediaType ; } public void setMediaType ( String mediaType ) { _mediaType = mediaType ; } public void setDoctype ( String publicId , String systemId ) { _doctypePublic = publicId ; _doctypeSystem = systemId ; } public String getDoctypePublic ( ) { return _doctypePublic ; } public String getDoctypeSystem ( ) { return _doctypeSystem ; } public boolean getOmitComments ( ) { return _omitComments ; } public void setOmitComments ( boolean omit ) { _omitComments = omit ; } public boolean getOmitDocumentType ( ) { return _omitDoctype ; } public void setOmitDocumentType ( boolean omit ) { _omitDoctype = omit ; } public boolean getOmitXMLDeclaration ( ) { return _omitXmlDeclaration ; } public void setOmitXMLDeclaration ( boolean omit ) { _omitXmlDeclaration = omit ; } public boolean getStandalone ( ) { return _standalone ; } public void setStandalone ( boolean standalone ) { _standalone = standalone ; } public String [ ] getCDataElements ( ) { return _cdataElements ; } public boolean isCDataElement ( String tagName ) { int i ; if ( _cdataElements == null ) return false ; for ( i = 0 ; i < _cdataElements . length ; ++ i ) if ( _cdataElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setCDataElements ( String [ ] cdataElements ) { _cdataElements = cdataElements ; } public String [ ] getNonEscapingElements ( ) { return _nonEscapingElements ; } public boolean isNonEscapingElement ( String tagName ) { int i ; if ( _nonEscapingElements == null ) return false ; for ( i = 0 ; i < _nonEscapingElements . length ; ++ i ) if ( _nonEscapingElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setNonEscapingElements ( String [ ] nonEscapingElements ) { _nonEscapingElements = nonEscapingElements ; } public String getLineSeparator ( ) { return _lineSeparator ; } public void setLineSeparator ( String lineSeparator ) { if ( lineSeparator == null ) _lineSeparator = LineSeparator . Web ; else _lineSeparator = lineSeparator ; } public boolean getPreserveSpace ( ) { return _preserve ; } public void setPreserveSpace ( boolean preserve ) { _preserve = preserve ; } public int getLineWidth ( ) { return _lineWidth ; } public void setLineWidth ( int lineWidth ) { if ( lineWidth <= 0 ) _lineWidth = 0 ; else _lineWidth = lineWidth ; } public char getLastPrintable ( ) { if ( getEncoding ( ) != null && ( getEncoding ( ) . equalsIgnoreCase ( "ASCII" ) ) ) return 0xFF ; else return 0xFFFF ; } public static String whichMethod ( Document doc ) { Node node ; String value ; int i ; if ( doc instanceof HTMLDocument ) return Method . HTML ; node = doc . getFirstChild ( ) ; while ( node != null ) { if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( node . getNodeName ( ) . equalsIgnoreCase ( "html" ) ) { return Method . HTML ; } else if ( node . getNodeName ( ) . equalsIgnoreCase ( "root" ) ) { return Method . FOP ; } else { return Method . XML ; } } else if ( node . getNodeType ( ) == Node . TEXT_NODE ) { value = node . getNodeValue ( ) ; for ( i = 0 ; i < value . length ( ) ; ++ i ) if ( value . charAt ( i ) != 0x20 && value . charAt ( i ) != 0x0A && value . charAt ( i ) != 0x09 && value . charAt ( i ) != 0x0D ) return Method . XML ; } node = node . getNextSibling ( ) ; } return Method . XML ; } public static String whichDoctypePublic ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLPublicId ; return null ; } public static String whichDoctypeSystem ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLSystemId ; return null ; } public static String whichMediaType ( String method ) { if ( method . equalsIgnoreCase ( Method . XML ) ) return "text/xml" ; if ( method . equalsIgnoreCase ( Method . HTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . XHTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . TEXT ) ) return "text/plain" ; if ( method . equalsIgnoreCase ( Method . FOP ) ) return "application/pdf" ; return null ; } } 	1
package org . apache . xerces . dom ; import java . util . Enumeration ; import java . util . Vector ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; public abstract class ChildNode extends NodeImpl { static final long serialVersionUID = - 6112455738802414002L ; protected ChildNode previousSibling ; protected ChildNode nextSibling ; protected ChildNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; } public ChildNode ( ) { } public Node cloneNode ( boolean deep ) { ChildNode newnode = ( ChildNode ) super . cloneNode ( deep ) ; newnode . previousSibling = null ; newnode . nextSibling = null ; newnode . isFirstChild ( false ) ; return newnode ; } public Node getParentNode ( ) { return isOwned ( ) ? ownerNode : null ; } final NodeImpl parentNode ( ) { return isOwned ( ) ? ownerNode : null ; } public Node getNextSibling ( ) { return nextSibling ; } public Node getPreviousSibling ( ) { return isFirstChild ( ) ? null : previousSibling ; } final ChildNode previousSibling ( ) { return isFirstChild ( ) ? null : previousSibling ; } } 	0
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public abstract class SAXParser { protected SAXParser ( ) { super ( ) ; } public void parse ( InputStream stream , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( stream ) , base ) ; } public void parse ( String uri , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( uri ) , base ) ; } public void parse ( File file , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; String path = file . getAbsolutePath ( ) ; if ( File . separatorChar != '/' ) { path = path . replace ( File . separatorChar , '/' ) ; } if ( ! path . startsWith ( "/" ) ) { path = "/" + path ; } if ( ! path . endsWith ( "/" ) && file . isDirectory ( ) ) { path = path + "/" ; } java . net . URL url = new java . net . URL ( "file" , "" , path ) ; this . parse ( new InputSource ( url . toString ( ) ) , base ) ; } public void parse ( InputSource source , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( source == null ) throw new IllegalArgumentException ( ) ; Parser p = this . getParser ( ) ; if ( base != null ) { p . setDocumentHandler ( base ) ; p . setDTDHandler ( base ) ; p . setEntityResolver ( base ) ; p . setErrorHandler ( base ) ; } p . parse ( source ) ; } public abstract Parser getParser ( ) throws SAXException ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLAnchorElementImpl extends HTMLElementImpl implements HTMLAnchorElement { public String getAccessKey ( ) { String accessKey ; accessKey = getAttribute ( "accesskey" ) ; if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; return accessKey ; } public void setAccessKey ( String accessKey ) { if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; setAttribute ( "accesskey" , accessKey ) ; } public String getCharset ( ) { return getAttribute ( "charset" ) ; } public void setCharset ( String charset ) { setAttribute ( "charset" , charset ) ; } public String getCoords ( ) { return getAttribute ( "coords" ) ; } public void setCoords ( String coords ) { setAttribute ( "coords" , coords ) ; } public String getHref ( ) { return getAttribute ( "href" ) ; } public void setHref ( String href ) { setAttribute ( "href" , href ) ; } public String getHreflang ( ) { return getAttribute ( "hreflang" ) ; } public void setHreflang ( String hreflang ) { setAttribute ( "hreflang" , hreflang ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public String getRel ( ) { return getAttribute ( "rel" ) ; } public void setRel ( String rel ) { setAttribute ( "rel" , rel ) ; } public String getRev ( ) { return getAttribute ( "rev" ) ; } public void setRev ( String rev ) { setAttribute ( "rev" , rev ) ; } public String getShape ( ) { return capitalize ( getAttribute ( "shape" ) ) ; } public void setShape ( String shape ) { setAttribute ( "shape" , shape ) ; } public int getTabIndex ( ) { return this . getInteger ( getAttribute ( "tabindex" ) ) ; } public void setTabIndex ( int tabIndex ) { setAttribute ( "tabindex" , String . valueOf ( tabIndex ) ) ; } public String getTarget ( ) { return getAttribute ( "target" ) ; } public void setTarget ( String target ) { setAttribute ( "target" , target ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } public void setType ( String type ) { setAttribute ( "type" , type ) ; } public void blur ( ) { } public void focus ( ) { } public HTMLAnchorElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom ; public interface Element extends Node { public String getTagName ( ) ; public String getAttribute ( String name ) ; public void setAttribute ( String name , String value ) throws DOMException ; public void removeAttribute ( String name ) throws DOMException ; public Attr getAttributeNode ( String name ) ; public Attr setAttributeNode ( Attr newAttr ) throws DOMException ; public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException ; public NodeList getElementsByTagName ( String name ) ; public String getAttributeNS ( String namespaceURI , String localName ) ; public void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException ; public void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException ; public Attr getAttributeNodeNS ( String namespaceURI , String localName ) ; public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public boolean hasAttribute ( String name ) ; public boolean hasAttributeNS ( String namespaceURI , String localName ) ; } 	1
package org . apache . wml . dom ; import java . io . * ; import java . util . * ; import java . lang . reflect . * ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; import org . apache . xerces . dom . DocumentImpl ; import org . apache . xerces . dom . NodeImpl ; import org . apache . xerces . dom . AttrImpl ; import org . apache . xerces . dom . DOMExceptionImpl ; import org . apache . wml . * ; public class WMLDocumentImpl extends DocumentImpl implements WMLDocument { private static Hashtable _elementTypesWML ; private static final Class [ ] _elemClassSigWML = new Class [ ] { WMLDocumentImpl . class , String . class } ; public Element createElement ( String tagName ) throws DOMException { Class elemClass ; Constructor cnst ; elemClass = ( Class ) _elementTypesWML . get ( tagName ) ; if ( elemClass != null ) { try { cnst = elemClass . getConstructor ( _elemClassSigWML ) ; return ( Element ) cnst . newInstance ( new Object [ ] { this , tagName } ) ; } catch ( Exception except ) { Throwable thrw ; if ( except instanceof java . lang . reflect . InvocationTargetException ) thrw = ( ( java . lang . reflect . InvocationTargetException ) except ) . getTargetException ( ) ; else thrw = except ; System . out . println ( "Exception " + thrw . getClass ( ) . getName ( ) ) ; System . out . println ( thrw . getMessage ( ) ) ; throw new IllegalStateException ( "Tag '" + tagName + "' associated with an Element class that failed to construct." ) ; } } return new WMLElementImpl ( this , tagName ) ; } static { _elementTypesWML = new Hashtable ( ) ; _elementTypesWML . put ( "b" , WMLBElementImpl . class ) ; _elementTypesWML . put ( "noop" , WMLNoopElementImpl . class ) ; _elementTypesWML . put ( "a" , WMLAElementImpl . class ) ; _elementTypesWML . put ( "setvar" , WMLSetvarElementImpl . class ) ; _elementTypesWML . put ( "access" , WMLAccessElementImpl . class ) ; _elementTypesWML . put ( "strong" , WMLStrongElementImpl . class ) ; _elementTypesWML . put ( "postfield" , WMLPostfieldElementImpl . class ) ; _elementTypesWML . put ( "do" , WMLDoElementImpl . class ) ; _elementTypesWML . put ( "wml" , WMLWmlElementImpl . class ) ; _elementTypesWML . put ( "tr" , WMLTrElementImpl . class ) ; _elementTypesWML . put ( "go" , WMLGoElementImpl . class ) ; _elementTypesWML . put ( "big" , WMLBigElementImpl . class ) ; _elementTypesWML . put ( "anchor" , WMLAnchorElementImpl . class ) ; _elementTypesWML . put ( "timer" , WMLTimerElementImpl . class ) ; _elementTypesWML . put ( "small" , WMLSmallElementImpl . class ) ; _elementTypesWML . put ( "optgroup" , WMLOptgroupElementImpl . class ) ; _elementTypesWML . put ( "head" , WMLHeadElementImpl . class ) ; _elementTypesWML . put ( "td" , WMLTdElementImpl . class ) ; _elementTypesWML . put ( "fieldset" , WMLFieldsetElementImpl . class ) ; _elementTypesWML . put ( "img" , WMLImgElementImpl . class ) ; _elementTypesWML . put ( "refresh" , WMLRefreshElementImpl . class ) ; _elementTypesWML . put ( "onevent" , WMLOneventElementImpl . class ) ; _elementTypesWML . put ( "input" , WMLInputElementImpl . class ) ; _elementTypesWML . put ( "prev" , WMLPrevElementImpl . class ) ; _elementTypesWML . put ( "table" , WMLTableElementImpl . class ) ; _elementTypesWML . put ( "meta" , WMLMetaElementImpl . class ) ; _elementTypesWML . put ( "template" , WMLTemplateElementImpl . class ) ; _elementTypesWML . put ( "br" , WMLBrElementImpl . class ) ; _elementTypesWML . put ( "option" , WMLOptionElementImpl . class ) ; _elementTypesWML . put ( "u" , WMLUElementImpl . class ) ; _elementTypesWML . put ( "p" , WMLPElementImpl . class ) ; _elementTypesWML . put ( "select" , WMLSelectElementImpl . class ) ; _elementTypesWML . put ( "em" , WMLEmElementImpl . class ) ; _elementTypesWML . put ( "i" , WMLIElementImpl . class ) ; _elementTypesWML . put ( "card" , WMLCardElementImpl . class ) ; } public WMLDocumentImpl ( DocumentType doctype ) { super ( doctype , false ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class NotationImpl extends NodeImpl implements Notation { static final long serialVersionUID = - 764632195890658402L ; protected String name ; protected String publicId ; protected String systemId ; public NotationImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; } public short getNodeType ( ) { return Node . NOTATION_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public String getPublicId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return publicId ; } public String getSystemId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return systemId ; } public void setPublicId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } publicId = id ; } public void setSystemId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } systemId = id ; } } 	1
package org . apache . xerces . utils ; import org . apache . xerces . readers . XMLEntityHandler ; import java . util . Vector ; public class UTF8DataChunk implements StringPool . StringProducer { public static final int CHUNK_SHIFT = 14 ; public static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; public static final int CHUNK_MASK = CHUNK_SIZE - 1 ; public static UTF8DataChunk createChunk ( StringPool stringPool , UTF8DataChunk prev ) { synchronized ( UTF8DataChunk . class ) { if ( fgFreeChunks != null ) { UTF8DataChunk newChunk = fgFreeChunks ; fgFreeChunks = newChunk . fNextChunk ; newChunk . fNextChunk = null ; newChunk . init ( stringPool , prev ) ; return newChunk ; } } UTF8DataChunk chunk = new UTF8DataChunk ( stringPool , prev ) ; return chunk ; } public final byte [ ] toByteArray ( ) { return fData ; } public void setByteArray ( byte [ ] data ) { fData = data ; } public UTF8DataChunk nextChunk ( ) { return fNextChunk ; } public boolean clearPreviousChunk ( ) { if ( fPreviousChunk != null ) { fPreviousChunk . setNextChunk ( null ) ; fPreviousChunk . removeRef ( ) ; fPreviousChunk = null ; return true ; } return fChunk == 0 ; } public void releaseChunk ( ) { removeRef ( ) ; } public void releaseString ( int offset , int length ) { removeRef ( ) ; } public String toString ( int offset , int length ) { synchronized ( fgTempBufferLock ) { int outOffset = 0 ; UTF8DataChunk dataChunk = this ; int endOffset = offset + length ; int index = offset & CHUNK_MASK ; byte [ ] data = fData ; boolean skiplf = false ; while ( offset < endOffset ) { int b0 = data [ index ++ ] & 0xff ; offset ++ ; if ( index == CHUNK_SIZE && offset < endOffset ) { dataChunk = dataChunk . fNextChunk ; data = dataChunk . fData ; index = 0 ; } if ( b0 < 0x80 ) { if ( skiplf ) { skiplf = false ; if ( b0 == 0x0A ) continue ; } if ( b0 == 0x0D ) { b0 = 0x0A ; skiplf = true ; } try { fgTempBuffer [ outOffset ] = ( char ) b0 ; outOffset ++ ; } catch ( NullPointerException ex ) { fgTempBuffer = new char [ CHUNK_SIZE ] ; fgTempBuffer [ outOffset ++ ] = ( char ) b0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { char [ ] newBuffer = new char [ outOffset * 2 ] ; System . arraycopy ( fgTempBuffer , 0 , newBuffer , 0 , outOffset ) ; fgTempBuffer = newBuffer ; fgTempBuffer [ outOffset ++ ] = ( char ) b0 ; } continue ; } int b1 = data [ index ++ ] & 0xff ; offset ++ ; if ( index == CHUNK_SIZE && offset < endOffset ) { dataChunk = dataChunk . fNextChunk ; data = dataChunk . fData ; index = 0 ; } if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; try { fgTempBuffer [ outOffset ] = ( char ) ch ; outOffset ++ ; } catch ( NullPointerException ex ) { fgTempBuffer = new char [ CHUNK_SIZE ] ; fgTempBuffer [ outOffset ++ ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { char [ ] newBuffer = new char [ outOffset * 2 ] ; System . arraycopy ( fgTempBuffer , 0 , newBuffer , 0 , outOffset ) ; fgTempBuffer = newBuffer ; fgTempBuffer [ outOffset ++ ] = ( char ) ch ; } continue ; } int b2 = data [ index ++ ] & 0xff ; offset ++ ; if ( index == CHUNK_SIZE && offset < endOffset ) { dataChunk = dataChunk . fNextChunk ; data = dataChunk . fData ; index = 0 ; } if ( ( 0xf0 & b0 ) == 0xe0 ) { int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; try { fgTempBuffer [ outOffset ] = ( char ) ch ; outOffset ++ ; } catch ( NullPointerException ex ) { fgTempBuffer = new char [ CHUNK_SIZE ] ; fgTempBuffer [ outOffset ++ ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { char [ ] newBuffer = new char [ outOffset * 2 ] ; System . arraycopy ( fgTempBuffer , 0 , newBuffer , 0 , outOffset ) ; fgTempBuffer = newBuffer ; fgTempBuffer [ outOffset ++ ] = ( char ) ch ; } continue ; } int b3 = data [ index ++ ] & 0xff ; offset ++ ; if ( index == CHUNK_SIZE && offset < endOffset ) { dataChunk = dataChunk . fNextChunk ; data = dataChunk . fData ; index = 0 ; } int ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; if ( ch < 0x10000 ) { try { fgTempBuffer [ outOffset ] = ( char ) ch ; outOffset ++ ; } catch ( NullPointerException ex ) { fgTempBuffer = new char [ CHUNK_SIZE ] ; fgTempBuffer [ outOffset ++ ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { char [ ] newBuffer = new char [ outOffset * 2 ] ; System . arraycopy ( fgTempBuffer , 0 , newBuffer , 0 , outOffset ) ; fgTempBuffer = newBuffer ; fgTempBuffer [ outOffset ++ ] = ( char ) ch ; } } else { char ch1 = ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; char ch2 = ( char ) ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; try { fgTempBuffer [ outOffset ] = ( char ) ch1 ; outOffset ++ ; } catch ( NullPointerException ex ) { fgTempBuffer = new char [ CHUNK_SIZE ] ; fgTempBuffer [ outOffset ++ ] = ( char ) ch1 ; } catch ( ArrayIndexOutOfBoundsException ex ) { char [ ] newBuffer = new char [ outOffset * 2 ] ; System . arraycopy ( fgTempBuffer , 0 , newBuffer , 0 , outOffset ) ; fgTempBuffer = newBuffer ; fgTempBuffer [ outOffset ++ ] = ( char ) ch1 ; } try { fgTempBuffer [ outOffset ] = ( char ) ch2 ; outOffset ++ ; } catch ( NullPointerException ex ) { fgTempBuffer = new char [ CHUNK_SIZE ] ; fgTempBuffer [ outOffset ++ ] = ( char ) ch2 ; } catch ( ArrayIndexOutOfBoundsException ex ) { char [ ] newBuffer = new char [ outOffset * 2 ] ; System . arraycopy ( fgTempBuffer , 0 , newBuffer , 0 , outOffset ) ; fgTempBuffer = newBuffer ; fgTempBuffer [ outOffset ++ ] = ( char ) ch2 ; } } } return new String ( fgTempBuffer , 0 , outOffset ) ; } } public boolean equalsString ( int offset , int length , char [ ] strChars , int strOffset , int strLength ) { UTF8DataChunk dataChunk = this ; int endOffset = offset + length ; int index = offset & CHUNK_MASK ; byte [ ] data = fData ; boolean skiplf = false ; while ( offset < endOffset ) { if ( strLength -- == 0 ) return false ; int b0 = data [ index ++ ] & 0xff ; offset ++ ; if ( index == CHUNK_SIZE && offset < endOffset ) { dataChunk = dataChunk . fNextChunk ; data = dataChunk . fData ; index = 0 ; } if ( b0 < 0x80 ) { if ( skiplf ) { skiplf = false ; if ( b0 == 0x0A ) continue ; } if ( b0 == 0x0D ) { b0 = 0x0A ; skiplf = true ; } if ( b0 != strChars [ strOffset ++ ] ) return false ; continue ; } int b1 = data [ index ++ ] & 0xff ; offset ++ ; if ( index == CHUNK_SIZE && offset < endOffset ) { dataChunk = dataChunk . fNextChunk ; data = dataChunk . fData ; index = 0 ; } if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ch != strChars [ strOffset ++ ] ) return false ; continue ; } int b2 = data [ index ++ ] & 0xff ; offset ++ ; if ( index == CHUNK_SIZE && offset < endOffset ) { dataChunk = dataChunk . fNextChunk ; data = dataChunk . fData ; index = 0 ; } if ( ( 0xf0 & b0 ) == 0xe0 ) { int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ch != strChars [ strOffset ++ ] ) return false ; continue ; } int b3 = data [ index ++ ] & 0xff ; offset ++ ; if ( index == CHUNK_SIZE && offset < endOffset ) { dataChunk = dataChunk . fNextChunk ; data = dataChunk . fData ; index = 0 ; } int ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; if ( ch < 0x10000 ) { if ( ch != strChars [ strOffset ++ ] ) return false ; } else { if ( ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) != strChars [ strOffset ++ ] ) return false ; if ( strLength -- == 0 ) return false ; if ( ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) != strChars [ strOffset ++ ] ) return false ; } } return ( strLength == 0 ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return StringPool . EMPTY_STRING ; int chunk = offset > > CHUNK_SHIFT ; if ( chunk != fChunk ) { if ( fPreviousChunk == null ) throw new RuntimeException ( new ImplementationMessages ( ) . createMessage ( null , ImplementationMessages . INT_PCN , 0 , null ) ) ; return fPreviousChunk . addString ( offset , length ) ; } int lastChunk = ( offset + length - 1 ) > > CHUNK_SHIFT ; if ( chunk == lastChunk ) { addRef ( ) ; return fStringPool . addString ( this , offset & CHUNK_MASK , length ) ; } String str = toString ( offset & CHUNK_MASK , length ) ; return fStringPool . addString ( str ) ; } public int addSymbol ( int offset , int length , int hashcode ) { if ( length == 0 ) return StringPool . EMPTY_STRING ; int chunk = offset > > CHUNK_SHIFT ; if ( chunk != fChunk ) { if ( fPreviousChunk == null ) throw new RuntimeException ( new ImplementationMessages ( ) . createMessage ( null , ImplementationMessages . INT_PCN , 0 , null ) ) ; return fPreviousChunk . addSymbol ( offset , length , hashcode ) ; } int lastChunk = ( offset + length - 1 ) > > CHUNK_SHIFT ; int index = offset & CHUNK_MASK ; if ( chunk == lastChunk ) { if ( hashcode == 0 ) { hashcode = getHashcode ( index , length ) ; } int symbol = fStringPool . lookupSymbol ( this , index , length , hashcode ) ; if ( symbol == - 1 ) { String str = toString ( index , length ) ; symbol = fStringPool . addNewSymbol ( str , hashcode ) ; } return symbol ; } String str = toString ( index , length ) ; return fStringPool . addSymbol ( str ) ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { UTF8DataChunk dataChunk = chunkFor ( offset ) ; int endOffset = offset + length ; int index = offset & CHUNK_MASK ; byte [ ] data = dataChunk . fData ; boolean skiplf = false ; while ( offset < endOffset ) { int b0 = data [ index ++ ] & 0xff ; offset ++ ; if ( index == CHUNK_SIZE && offset < endOffset ) { dataChunk = dataChunk . fNextChunk ; data = dataChunk . fData ; index = 0 ; } if ( b0 < 0x80 ) { if ( skiplf ) { skiplf = false ; if ( b0 == 0x0A ) continue ; } if ( b0 == 0x0D ) { b0 = 0x0A ; skiplf = true ; } charBuffer . append ( ( char ) b0 ) ; continue ; } int b1 = data [ index ++ ] & 0xff ; offset ++ ; if ( index == CHUNK_SIZE && offset < endOffset ) { dataChunk = dataChunk . fNextChunk ; data = dataChunk . fData ; index = 0 ; } if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; charBuffer . append ( ( char ) ch ) ; continue ; } int b2 = data [ index ++ ] & 0xff ; offset ++ ; if ( index == CHUNK_SIZE && offset < endOffset ) { dataChunk = dataChunk . fNextChunk ; data = dataChunk . fData ; index = 0 ; } if ( ( 0xf0 & b0 ) == 0xe0 ) { int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; charBuffer . append ( ( char ) ch ) ; continue ; } int b3 = data [ index ++ ] & 0xff ; offset ++ ; if ( index == CHUNK_SIZE && offset < endOffset ) { dataChunk = dataChunk . fNextChunk ; data = dataChunk . fData ; index = 0 ; } int ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; if ( ch < 0x10000 ) charBuffer . append ( ( char ) ch ) ; else { charBuffer . append ( ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ) ; charBuffer . append ( ( char ) ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ) ; } } } private int getHashcode ( int index , int length ) { int endIndex = index + length ; int hashcode = 0 ; byte [ ] data = fData ; while ( index < endIndex ) { int b0 = data [ index ++ ] & 0xff ; if ( ( b0 & 0x80 ) == 0 ) { hashcode = StringHasher . hashChar ( hashcode , b0 ) ; continue ; } int b1 = data [ index ++ ] & 0xff ; if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; hashcode = StringHasher . hashChar ( hashcode , ch ) ; continue ; } int b2 = data [ index ++ ] & 0xff ; if ( ( 0xf0 & b0 ) == 0xe0 ) { int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; hashcode = StringHasher . hashChar ( hashcode , ch ) ; continue ; } int b3 = data [ index ++ ] & 0xff ; int ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; if ( ch < 0x10000 ) hashcode = StringHasher . hashChar ( hashcode , ch ) ; else { hashcode = StringHasher . hashChar ( hashcode , ( int ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ) ; hashcode = StringHasher . hashChar ( hashcode , ( int ) ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ) ; } } return StringHasher . finishHash ( hashcode ) ; } private void init ( StringPool stringPool , UTF8DataChunk prev ) { fStringPool = stringPool ; fRefCount = 1 ; fChunk = prev == null ? 0 : prev . fChunk + 1 ; fNextChunk = null ; fPreviousChunk = prev ; if ( prev != null ) { prev . addRef ( ) ; prev . setNextChunk ( this ) ; prev . removeRef ( ) ; } } private UTF8DataChunk ( StringPool stringPool , UTF8DataChunk prev ) { init ( stringPool , prev ) ; } private final UTF8DataChunk chunkFor ( int offset ) { if ( ( offset > > CHUNK_SHIFT ) == fChunk ) return this ; return slowChunkFor ( offset ) ; } private UTF8DataChunk slowChunkFor ( int offset ) { int firstChunk = offset > > CHUNK_SHIFT ; UTF8DataChunk dataChunk = this ; while ( firstChunk != dataChunk . fChunk ) dataChunk = dataChunk . fPreviousChunk ; return dataChunk ; } private final void addRef ( ) { fRefCount ++ ; } private final void removeRef ( ) { fRefCount -- ; if ( fRefCount == 0 ) { fStringPool = null ; fChunk = - 1 ; fPreviousChunk = null ; synchronized ( UTF8DataChunk . class ) { fNextChunk = null ; fgFreeChunks = this ; } } } private void setNextChunk ( UTF8DataChunk nextChunk ) { if ( nextChunk == null ) { if ( fNextChunk != null ) fNextChunk . removeRef ( ) ; } else if ( fNextChunk == null ) { nextChunk . addRef ( ) ; } else throw new RuntimeException ( "UTF8DataChunk::setNextChunk" ) ; fNextChunk = nextChunk ; } private StringPool fStringPool ; private int fRefCount ; private int fChunk ; private byte [ ] fData = null ; private UTF8DataChunk fNextChunk ; private UTF8DataChunk fPreviousChunk ; private static UTF8DataChunk fgFreeChunks = null ; private static char [ ] fgTempBuffer = null ; private static Object fgTempBufferLock = new Object ( ) ; } 	0
package org . w3c . dom . events ; public interface EventListener { public void handleEvent ( Event evt ) ; } 	1
package org . apache . wml ; import org . w3c . dom . * ; public interface WMLDocument extends Document { } 	0
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface LexicalHandler { public abstract void startDTD ( String name , String publicId , String systemId ) throws SAXException ; public abstract void endDTD ( ) throws SAXException ; public abstract void startEntity ( String name ) throws SAXException ; public abstract void endEntity ( String name ) throws SAXException ; public abstract void startCDATA ( ) throws SAXException ; public abstract void endCDATA ( ) throws SAXException ; public abstract void comment ( char ch [ ] , int start , int length ) throws SAXException ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLDirectoryElementImpl extends HTMLElementImpl implements HTMLDirectoryElement { public boolean getCompact ( ) { return getBinary ( "compact" ) ; } public void setCompact ( boolean compact ) { setAttribute ( "compact" , compact ) ; } public HTMLDirectoryElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrImpl extends ParentNode implements Attr { static final long serialVersionUID = 7277707688218972102L ; protected String name ; protected AttrImpl ( DocumentImpl ownerDocument , String name ) { super ( ownerDocument ) ; this . name = name ; isSpecified ( true ) ; } protected AttrImpl ( ) { } public Node cloneNode ( boolean deep ) { AttrImpl clone = ( AttrImpl ) super . cloneNode ( deep ) ; clone . isSpecified ( true ) ; return clone ; } public short getNodeType ( ) { return Node . ATTRIBUTE_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setNodeValue ( String value ) throws DOMException { setValue ( value ) ; } public String getNodeValue ( ) { return getValue ( ) ; } public String getName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setValue ( String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } LCount lc = null ; String oldvalue = "" ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 && ownerNode != null ) { oldvalue = getValue ( ) ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } while ( firstChild != null ) internalRemoveChild ( firstChild , MUTATION_LOCAL ) ; } else { if ( firstChild != null ) { firstChild . previousSibling = null ; firstChild . isFirstChild ( false ) ; firstChild = null ; } needsSyncChildren ( false ) ; } isSpecified ( true ) ; if ( value != null ) { internalInsertBefore ( ownerDocument . createTextNode ( value ) , null , MUTATION_LOCAL ) ; } changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( this , oldvalue ) ; } } public String getValue ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( firstChild == null ) { return "" ; } ChildNode node = firstChild . nextSibling ; if ( node == null ) { return firstChild . getNodeValue ( ) ; } StringBuffer value = new StringBuffer ( firstChild . getNodeValue ( ) ) ; while ( node != null ) { value . append ( node . getNodeValue ( ) ) ; node = node . nextSibling ; } return value . toString ( ) ; } public boolean getSpecified ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isSpecified ( ) ; } public Element getElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public Element getOwnerElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public void normalize ( ) { Node kid , next ; for ( kid = firstChild ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } } } public void setSpecified ( boolean arg ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isSpecified ( arg ) ; } public String toString ( ) { return getName ( ) + "=" + "\"" + getValue ( ) + "\"" ; } } 	1
package org . w3c . dom . range ; public class RangeException extends RuntimeException { public RangeException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short BAD_BOUNDARYPOINTS_ERR = 1 ; public static final short INVALID_NODE_TYPE_ERR = 2 ; } 	0
package org . w3c . dom ; public interface CharacterData extends Node { public String getData ( ) throws DOMException ; public void setData ( String data ) throws DOMException ; public int getLength ( ) ; public String substringData ( int offset , int count ) throws DOMException ; public void appendData ( String arg ) throws DOMException ; public void insertData ( int offset , String arg ) throws DOMException ; public void deleteData ( int offset , int count ) throws DOMException ; public void replaceData ( int offset , int count , String arg ) throws DOMException ; } 	1
package org . w3c . dom . html ; public interface HTMLHeadElement extends HTMLElement { public String getProfile ( ) ; public void setProfile ( String profile ) ; } 	0
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface Event { public static final short CAPTURING_PHASE = 1 ; public static final short AT_TARGET = 2 ; public static final short BUBBLING_PHASE = 3 ; public String getType ( ) ; public EventTarget getTarget ( ) ; public Node getCurrentNode ( ) ; public short getEventPhase ( ) ; public boolean getBubbles ( ) ; public boolean getCancelable ( ) ; public long getTimeStamp ( ) ; public void stopPropagation ( ) ; public void preventDefault ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) ; } 	1
package org . apache . html . dom ; import java . io . * ; import java . util . * ; import java . lang . reflect . * ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; import org . apache . xerces . dom . DocumentImpl ; import org . apache . xerces . dom . NodeImpl ; import org . apache . xerces . dom . AttrImpl ; import org . apache . xerces . dom . DOMExceptionImpl ; public class HTMLDocumentImpl extends DocumentImpl implements HTMLDocument { private HTMLCollectionImpl _anchors ; private HTMLCollectionImpl _forms ; private HTMLCollectionImpl _images ; private HTMLCollectionImpl _links ; private HTMLCollectionImpl _applets ; private StringWriter _writer ; private static Hashtable _elementTypesHTML ; private static final Class [ ] _elemClassSigHTML = new Class [ ] { HTMLDocumentImpl . class , String . class } ; public HTMLDocumentImpl ( ) { super ( ) ; populateElementTypes ( ) ; } public synchronized Element getDocumentElement ( ) { Node html ; Node child ; Node next ; html = getFirstChild ( ) ; while ( html != null ) { if ( html instanceof HTMLHtmlElement ) { synchronized ( html ) { child = getFirstChild ( ) ; while ( child != null && child != html ) { next = child . getNextSibling ( ) ; html . appendChild ( child ) ; child = next ; } } return ( HTMLElement ) html ; } html = html . getNextSibling ( ) ; } html = new HTMLHtmlElementImpl ( this , "HTML" ) ; child = getFirstChild ( ) ; while ( child != null ) { next = child . getNextSibling ( ) ; html . appendChild ( child ) ; child = next ; } appendChild ( html ) ; return ( HTMLElement ) html ; } public synchronized HTMLElement getHead ( ) { Node head ; Node html ; Node child ; Node next ; html = getDocumentElement ( ) ; synchronized ( html ) { head = html . getFirstChild ( ) ; while ( head != null && ! ( head instanceof HTMLHeadElement ) ) head = head . getNextSibling ( ) ; if ( head != null ) { synchronized ( head ) { child = html . getFirstChild ( ) ; while ( child != null && child != head ) { next = child . getNextSibling ( ) ; head . insertBefore ( child , head . getFirstChild ( ) ) ; child = next ; } } return ( HTMLElement ) head ; } head = new HTMLHeadElementImpl ( this , "HEAD" ) ; html . insertBefore ( head , html . getFirstChild ( ) ) ; } return ( HTMLElement ) head ; } public synchronized String getTitle ( ) { HTMLElement head ; NodeList list ; Node title ; head = getHead ( ) ; title = head . getElementsByTagName ( "TITLE" ) . item ( 0 ) ; list = head . getElementsByTagName ( "TITLE" ) ; if ( list . getLength ( ) > 0 ) { title = list . item ( 0 ) ; return ( ( HTMLTitleElement ) title ) . getText ( ) ; } return "" ; } public synchronized void setTitle ( String newTitle ) { HTMLElement head ; NodeList list ; Node title ; head = getHead ( ) ; list = head . getElementsByTagName ( "TITLE" ) ; if ( list . getLength ( ) > 0 ) { title = list . item ( 0 ) ; if ( title . getParentNode ( ) != head ) head . appendChild ( title ) ; ( ( HTMLTitleElement ) title ) . setText ( newTitle ) ; } else { title = new HTMLTitleElementImpl ( this , "TITLE" ) ; ( ( HTMLTitleElement ) title ) . setText ( newTitle ) ; head . appendChild ( title ) ; } } public synchronized HTMLElement getBody ( ) { Node html ; Node head ; Node body ; Node child ; Node next ; html = getDocumentElement ( ) ; head = getHead ( ) ; synchronized ( html ) { body = head . getNextSibling ( ) ; while ( body != null && ! ( body instanceof HTMLBodyElement ) && ! ( body instanceof HTMLFrameSetElement ) ) body = body . getNextSibling ( ) ; if ( body != null ) { synchronized ( body ) { child = head . getNextSibling ( ) ; while ( child != null && child != body ) { next = child . getNextSibling ( ) ; body . insertBefore ( child , body . getFirstChild ( ) ) ; child = next ; } } return ( HTMLElement ) body ; } body = new HTMLBodyElementImpl ( this , "BODY" ) ; html . appendChild ( body ) ; } return ( HTMLElement ) body ; } public synchronized void setBody ( HTMLElement newBody ) { Node html ; Node body ; Node head ; Node child ; NodeList list ; synchronized ( newBody ) { html = getDocumentElement ( ) ; head = getHead ( ) ; synchronized ( html ) { list = this . getElementsByTagName ( "BODY" ) ; if ( list . getLength ( ) > 0 ) { body = list . item ( 0 ) ; synchronized ( body ) { child = head ; while ( child != null ) { if ( child instanceof Element ) { if ( child != body ) html . insertBefore ( newBody , child ) ; else html . replaceChild ( newBody , body ) ; return ; } child = child . getNextSibling ( ) ; } html . appendChild ( newBody ) ; } return ; } html . appendChild ( newBody ) ; } } } public synchronized Element getElementById ( String elementId ) { return getElementById ( elementId , this ) ; } public NodeList getElementsByName ( String elementName ) { return new NameNodeListImpl ( this , elementName ) ; } public final NodeList getElementsByTagName ( String tagName ) { return super . getElementsByTagName ( tagName . toUpperCase ( ) ) ; } public final NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { if ( namespaceURI != null && namespaceURI . length ( ) > 0 ) return super . getElementsByTagNameNS ( namespaceURI , localName . toUpperCase ( ) ) ; else return super . getElementsByTagName ( localName . toUpperCase ( ) ) ; } public Element createElementNS ( String namespaceURI , String qualifiedName ) { if ( namespaceURI == null || namespaceURI . length ( ) == 0 ) return createElement ( qualifiedName ) ; else return super . createElementNS ( namespaceURI , qualifiedName ) ; } public Element createElement ( String tagName ) throws DOMException { Class elemClass ; Constructor cnst ; tagName = tagName . toUpperCase ( ) ; elemClass = ( Class ) _elementTypesHTML . get ( tagName ) ; if ( elemClass != null ) { try { cnst = elemClass . getConstructor ( _elemClassSigHTML ) ; return ( Element ) cnst . newInstance ( new Object [ ] { this , tagName } ) ; } catch ( Exception except ) { Throwable thrw ; if ( except instanceof java . lang . reflect . InvocationTargetException ) thrw = ( ( java . lang . reflect . InvocationTargetException ) except ) . getTargetException ( ) ; else thrw = except ; throw new IllegalStateException ( "HTM15 Tag '" + tagName + "' associated with an Element class that failed to construct.\n" + tagName ) ; } } return new HTMLElementImpl ( this , tagName ) ; } public Attr createAttribute ( String name ) throws DOMException { return super . createAttribute ( name . toLowerCase ( ) ) ; } public String getReferrer ( ) { return null ; } public String getDomain ( ) { return null ; } public String getURL ( ) { return null ; } public String getCookie ( ) { return null ; } public void setCookie ( String cookie ) { } public HTMLCollection getImages ( ) { if ( _images == null ) _images = new HTMLCollectionImpl ( getBody ( ) , HTMLCollectionImpl . IMAGE ) ; return _images ; } public HTMLCollection getApplets ( ) { if ( _applets == null ) _applets = new HTMLCollectionImpl ( getBody ( ) , HTMLCollectionImpl . APPLET ) ; return _applets ; } public HTMLCollection getLinks ( ) { if ( _links == null ) _links = new HTMLCollectionImpl ( getBody ( ) , HTMLCollectionImpl . LINK ) ; return _links ; } public HTMLCollection getForms ( ) { if ( _forms == null ) _forms = new HTMLCollectionImpl ( getBody ( ) , HTMLCollectionImpl . FORM ) ; return _forms ; } public HTMLCollection getAnchors ( ) { if ( _anchors == null ) _anchors = new HTMLCollectionImpl ( getBody ( ) , HTMLCollectionImpl . ANCHOR ) ; return _anchors ; } public void open ( ) { if ( _writer == null ) _writer = new StringWriter ( ) ; } public void close ( ) { if ( _writer != null ) { _writer = null ; } } public void write ( String text ) { if ( _writer != null ) _writer . write ( text ) ; } public void writeln ( String text ) { if ( _writer != null ) _writer . write ( text + "\n" ) ; } public Node cloneNode ( boolean deep ) { HTMLDocumentImpl clone ; NodeImpl node ; clone = new HTMLDocumentImpl ( ) ; if ( deep ) { node = ( NodeImpl ) getFirstChild ( ) ; while ( node != null ) { clone . appendChild ( clone . importNode ( node , true ) ) ; node = ( NodeImpl ) node . getNextSibling ( ) ; } } return clone ; } private Element getElementById ( String elementId , Node node ) { Node child ; Element result ; child = node . getFirstChild ( ) ; while ( child != null ) { if ( child instanceof Element ) { if ( elementId . equals ( ( ( Element ) child ) . getAttribute ( "id" ) ) ) return ( Element ) child ; result = getElementById ( elementId , child ) ; if ( result != null ) return result ; } child = child . getNextSibling ( ) ; } return null ; } private static void populateElementTypes ( ) { if ( _elementTypesHTML != null ) return ; _elementTypesHTML = new Hashtable ( 63 ) ; populateElementType ( "A" , "HTMLAnchorElementImpl" ) ; populateElementType ( "APPLET" , "HTMLAppletElementImpl" ) ; populateElementType ( "AREA" , "HTMLAreaElementImpl" ) ; populateElementType ( "BASE" , "HTMLBaseElementImpl" ) ; populateElementType ( "BASEFONT" , "HTMLBaseFontElementImpl" ) ; populateElementType ( "BLOCKQUOTE" , "HTMLQuoteElementImpl" ) ; populateElementType ( "BODY" , "HTMLBodyElementImpl" ) ; populateElementType ( "BR" , "HTMLBRElementImpl" ) ; populateElementType ( "BUTTON" , "HTMLButtonElementImpl" ) ; populateElementType ( "DEL" , "HTMLModElementImpl" ) ; populateElementType ( "DIR" , "HTMLDirectoryElementImpl" ) ; populateElementType ( "DIV" , "HTMLDivElementImpl" ) ; populateElementType ( "DL" , "HTMLDListElementImpl" ) ; populateElementType ( "FIELDSET" , "HTMLFieldSetElementImpl" ) ; populateElementType ( "FONT" , "HTMLFontElementImpl" ) ; populateElementType ( "FORM" , "HTMLFormElementImpl" ) ; populateElementType ( "FRAME" , "HTMLFrameElementImpl" ) ; populateElementType ( "FRAMESET" , "HTMLFrameSetElementImpl" ) ; populateElementType ( "HEAD" , "HTMLHeadElementImpl" ) ; populateElementType ( "H1" , "HTMLHeadingElementImpl" ) ; populateElementType ( "H2" , "HTMLHeadingElementImpl" ) ; populateElementType ( "H3" , "HTMLHeadingElementImpl" ) ; populateElementType ( "H4" , "HTMLHeadingElementImpl" ) ; populateElementType ( "H5" , "HTMLHeadingElementImpl" ) ; populateElementType ( "H6" , "HTMLHeadingElementImpl" ) ; populateElementType ( "HR" , "HTMLHRElementImpl" ) ; populateElementType ( "HTML" , "HTMLHtmlElementImpl" ) ; populateElementType ( "IFRAME" , "HTMLIFrameElementImpl" ) ; populateElementType ( "IMG" , "HTMLImageElementImpl" ) ; populateElementType ( "INPUT" , "HTMLInputElementImpl" ) ; populateElementType ( "INS" , "HTMLModElementImpl" ) ; populateElementType ( "ISINDEX" , "HTMLIsIndexElementImpl" ) ; populateElementType ( "LABEL" , "HTMLLabelElementImpl" ) ; populateElementType ( "LEGEND" , "HTMLLegendElementImpl" ) ; populateElementType ( "LI" , "HTMLLIElementImpl" ) ; populateElementType ( "LINK" , "HTMLLinkElementImpl" ) ; populateElementType ( "MAP" , "HTMLMapElementImpl" ) ; populateElementType ( "MENU" , "HTMLMenuElementImpl" ) ; populateElementType ( "META" , "HTMLMetaElementImpl" ) ; populateElementType ( "OBJECT" , "HTMLObjectElementImpl" ) ; populateElementType ( "OL" , "HTMLOListElementImpl" ) ; populateElementType ( "OPTGROUP" , "HTMLOptGroupElementImpl" ) ; populateElementType ( "OPTION" , "HTMLOptionElementImpl" ) ; populateElementType ( "P" , "HTMLParagraphElementImpl" ) ; populateElementType ( "PARAM" , "HTMLParamElementImpl" ) ; populateElementType ( "PRE" , "HTMLPreElementImpl" ) ; populateElementType ( "Q" , "HTMLQuoteElementImpl" ) ; populateElementType ( "SCRIPT" , "HTMLScriptElementImpl" ) ; populateElementType ( "SELECT" , "HTMLSelectElementImpl" ) ; populateElementType ( "STYLE" , "HTMLStyleElementImpl" ) ; populateElementType ( "TABLE" , "HTMLTableElementImpl" ) ; populateElementType ( "CAPTION" , "HTMLTableCaptionElementImpl" ) ; populateElementType ( "TD" , "HTMLTableCellElementImpl" ) ; populateElementType ( "TH" , "HTMLTableCellElementImpl" ) ; populateElementType ( "COL" , "HTMLTableColElementImpl" ) ; populateElementType ( "COLGROUP" , "HTMLTableColElementImpl" ) ; populateElementType ( "TR" , "HTMLTableRowElementImpl" ) ; populateElementType ( "TBODY" , "HTMLTableSectionElementImpl" ) ; populateElementType ( "THEAD" , "HTMLTableSectionElementImpl" ) ; populateElementType ( "TFOOT" , "HTMLTableSectionElementImpl" ) ; populateElementType ( "TEXTAREA" , "HTMLTextAreaElementImpl" ) ; populateElementType ( "TITLE" , "HTMLTitleElementImpl" ) ; populateElementType ( "UL" , "HTMLUListElementImpl" ) ; } private static void populateElementType ( String tagName , String className ) { try { _elementTypesHTML . put ( tagName , Class . forName ( "org.apache.html.dom." + className ) ) ; } catch ( ClassNotFoundException except ) { new RuntimeException ( "HTM019 OpenXML Error: Could not find class " + className + " implementing HTML element " + tagName + "\n" + className + "\t" + tagName ) ; } } } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Enumeration ; import java . util . Vector ; import org . w3c . dom . * ; public class ElementImpl extends ChildAndParentNode implements Element { static final long serialVersionUID = 3717253516652722278L ; protected String name ; protected AttributeMap attributes ; public ElementImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; needsSyncData ( true ) ; } protected ElementImpl ( ) { } public short getNodeType ( ) { return Node . ELEMENT_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public NamedNodeMap getAttributes ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return attributes ; } public Node cloneNode ( boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } ElementImpl newnode = ( ElementImpl ) super . cloneNode ( deep ) ; if ( attributes != null ) { newnode . attributes = ( AttributeMap ) attributes . cloneMap ( newnode ) ; } return newnode ; } void setOwnerDocument ( DocumentImpl doc ) { super . setOwnerDocument ( doc ) ; if ( attributes != null ) { attributes . setOwnerDocument ( doc ) ; } } public String getAttribute ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return "" ; } Attr attr = ( Attr ) ( attributes . getNamedItem ( name ) ) ; return ( attr == null ) ? "" : attr . getValue ( ) ; } public Attr getAttributeNode ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItem ( name ) ; } public NodeList getElementsByTagName ( String tagname ) { return new DeepNodeListImpl ( this , tagname ) ; } public String getTagName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void normalize ( ) { Node kid , next ; for ( kid = getFirstChild ( ) ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } else if ( kid . getNodeType ( ) == Node . ELEMENT_NODE ) { ( ( Element ) kid ) . normalize ( ) ; } } } public void removeAttribute ( String name ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItem ( name ) ; } public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } return ( Attr ) attributes . removeNamedItem ( oldAttr . getName ( ) ) ; } public void setAttribute ( String name , String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } Attr newAttr = getAttributeNode ( name ) ; if ( newAttr == null ) { newAttr = getOwnerDocument ( ) . createAttribute ( name ) ; if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } attributes . setNamedItem ( newAttr ) ; } newAttr . setNodeValue ( value ) ; } public Attr setAttributeNode ( Attr newAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ownerDocument . errorChecking && newAttr . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return ( Attr ) attributes . setNamedItem ( newAttr ) ; } public String getAttributeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return "" ; } Attr attr = ( Attr ) ( attributes . getNamedItemNS ( namespaceURI , localName ) ) ; return ( attr == null ) ? null : attr . getValue ( ) ; } public void setAttributeNS ( String namespaceURI , String localName , String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } Attr newAttr = getAttributeNodeNS ( namespaceURI , localName ) ; if ( newAttr == null ) { newAttr = getOwnerDocument ( ) . createAttributeNS ( namespaceURI , localName ) ; if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } attributes . setNamedItemNS ( newAttr ) ; } newAttr . setNodeValue ( value ) ; } public void removeAttributeNS ( String namespaceURI , String localName ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItemNS ( namespaceURI , localName ) ; } public Attr getAttributeNodeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItemNS ( namespaceURI , localName ) ; } public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ownerDocument . errorChecking && newAttr . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return ( Attr ) attributes . setNamedItemNS ( newAttr ) ; } public boolean hasAttributes ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return ( attributes != null && attributes . getLength ( ) != 0 ) ; } public boolean hasAttribute ( String name ) { return getAttributeNode ( name ) != null ; } public boolean hasAttributeNS ( String namespaceURI , String localName ) { return getAttributeNodeNS ( namespaceURI , localName ) != null ; } public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { return new DeepNodeListImpl ( this , namespaceURI , localName ) ; } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( attributes != null ) { attributes . setReadOnly ( readOnly , true ) ; } } protected void synchronizeData ( ) { needsSyncData ( false ) ; setupDefaultAttributes ( ) ; } protected void setupDefaultAttributes ( ) { NamedNodeMapImpl defaults = getDefaultAttributes ( ) ; if ( defaults != null ) { attributes = new AttributeMap ( this , defaults ) ; } } protected NamedNodeMapImpl getDefaultAttributes ( ) { DocumentTypeImpl doctype = ( DocumentTypeImpl ) ownerDocument . getDoctype ( ) ; if ( doctype == null ) { return null ; } ElementDefinitionImpl eldef = ( ElementDefinitionImpl ) doctype . getElements ( ) . getNamedItem ( getNodeName ( ) ) ; if ( eldef == null ) { return null ; } return ( NamedNodeMapImpl ) eldef . getAttributes ( ) ; } } 	1
package org . apache . xerces . framework ; import org . xml . sax . Locator ; public interface XMLErrorReporter { public static final int ERRORTYPE_WARNING = 0 ; public static final int ERRORTYPE_RECOVERABLE_ERROR = 1 ; public static final int ERRORTYPE_FATAL_ERROR = 2 ; public Locator getLocator ( ) ; public void reportError ( Locator locator , String errorDomain , int majorCode , int minorCode , Object args [ ] , int errorType ) throws Exception ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class TextImpl extends CharacterDataImpl implements CharacterData , Text { static final long serialVersionUID = - 5294980852957403469L ; public TextImpl ( DocumentImpl ownerDoc , String data ) { super ( ownerDoc , data ) ; } public short getNodeType ( ) { return Node . TEXT_NODE ; } public String getNodeName ( ) { return "#text" ; } public void setIgnorableWhitespace ( boolean ignore ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isIgnorableWhitespace ( ignore ) ; } public boolean isIgnorableWhitespace ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return internalIsIgnorableWhitespace ( ) ; } public Text splitText ( int offset ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( offset < 0 || offset > data . length ( ) - 1 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } Text newText = getOwnerDocument ( ) . createTextNode ( data . substring ( offset ) ) ; setNodeValue ( data . substring ( 0 , offset ) ) ; Node parentNode = getParentNode ( ) ; if ( parentNode != null ) { parentNode . insertBefore ( newText , nextSibling ) ; } return newText ; } } 	1
package org . apache . xerces . validators . schema ; public final class SchemaSymbols { public static final String URI_XSI = "http://www.w3.org/1999/XMLSchema-instance" ; public static final String URI_SCHEMAFORSCHEMA = "http://www.w3.org/1999/XMLSchema" ; public static final String XSI_SCHEMALOCACTION = "schemaLocation" ; public static final String XSI_NONAMESPACESCHEMALOCACTION = "noNamespaceSchemaLocation" ; public static final String XSI_TYPE = "type" ; public static final String ELT_ALL = "all" ; public static final String ELT_ANNOTATION = "annotation" ; public static final String ELT_ANY = "any" ; public static final String ELT_WILDCARD = "any" ; public static final String ELT_ANYATTRIBUTE = "anyAttribute" ; public static final String ELT_ATTRIBUTE = "attribute" ; public static final String ELT_ATTRIBUTEGROUP = "attributeGroup" ; public static final String ELT_CHOICE = "choice" ; public static final String ELT_COMPLEXTYPE = "complexType" ; public static final String ELT_CONTENT = "content" ; public static final String ELT_DURATION = "duration" ; public static final String ELT_ELEMENT = "element" ; public static final String ELT_ENCODING = "encoding" ; public static final String ELT_ENUMERATION = "enumeration" ; public static final String ELT_GROUP = "group" ; public static final String ELT_IMPORT = "import" ; public static final String ELT_INCLUDE = "include" ; public static final String ELT_KEY = "key" ; public static final String ELT_KEYREF = "keyref" ; public static final String ELT_LENGTH = "length" ; public static final String ELT_MAXEXCLUSIVE = "maxExclusive" ; public static final String ELT_MAXINCLUSIVE = "maxInclusive" ; public static final String ELT_MAXLENGTH = "maxLength" ; public static final String ELT_MINEXCLUSIVE = "minExclusive" ; public static final String ELT_MININCLUSIVE = "minInclusive" ; public static final String ELT_MINLENGTH = "minLength" ; public static final String ELT_NOTATION = "notation" ; public static final String ELT_PATTERN = "pattern" ; public static final String ELT_PERIOD = "period" ; public static final String ELT_PRECISION = "precision" ; public static final String ELT_SCALE = "scale" ; public static final String ELT_SCHEMA = "schema" ; public static final String ELT_SELECTOR = "selector" ; public static final String ELT_SEQUENCE = "sequence" ; public static final String ELT_SIMPLETYPE = "simpleType" ; public static final String ELT_UNIQUE = "unique" ; public static final String ATT_ABSTRACT = "abstract" ; public static final String ATT_ATTRIBUTEFORMDEFAULT = "attributeFormDefault" ; public static final String ATT_BASE = "base" ; public static final String ATT_BLOCK = "block" ; public static final String ATT_BLOCKDEFAULT = "blockDefault" ; public static final String ATT_CONTENT = "content" ; public static final String ATT_DEFAULT = "default" ; public static final String ATT_DERIVEDBY = "derivedBy" ; public static final String ATT_ELEMENTFORMDEFAULT = "elementFormDefault" ; public static final String ATT_EQUIVCLASS = "equivClass" ; public static final String ATT_FINAL = "final" ; public static final String ATT_FINALDEFAULT = "finalDefault" ; public static final String ATT_FIXED = "fixed" ; public static final String ATT_FORM = "form" ; public static final String ATT_MAXOCCURS = "maxOccurs" ; public static final String ATT_MINOCCURS = "minOccurs" ; public static final String ATT_NAME = "name" ; public static final String ATT_NAMESPACE = "namespace" ; public static final String ATT_NULLABLE = "nullable" ; public static final String ATT_PROCESSCONTENTS = "processContents" ; public static final String ATT_REF = "ref" ; public static final String ATT_REFER = "refer" ; public static final String ATT_SCHEMALOCATION = "schemaLocation" ; public static final String ATT_SYSTEM = "system" ; public static final String ATT_TARGETNAMESPACE = "targetNamespace" ; public static final String ATT_TYPE = "type" ; public static final String ATT_USE = "use" ; public static final String ATT_VALUE = "value" ; public static final String ATTVAL_TWOPOUNDANY = "##any" ; public static final String ATTVAL_TWOPOUNDLOCAL = "##local" ; public static final String ATTVAL_TWOPOUNDOTHER = "##other" ; public static final String ATTVAL_POUNDALL = "#all" ; public static final String ATTVAL_BASE64 = "base64" ; public static final String ATTVAL_BOOLEAN = "boolean" ; public static final String ATTVAL_DEFAULT = "default" ; public static final String ATTVAL_ELEMENTONLY = "elementOnly" ; public static final String ATTVAL_EMPTY = "empty" ; public static final String ATTVAL_EXTENSION = "extension" ; public static final String ATTVAL_FALSE = "false" ; public static final String ATTVAL_FIXED = "fixed" ; public static final String ATTVAL_HEX = "hex" ; public static final String ATTVAL_ID = "ID" ; public static final String ATTVAL_LAX = "lax" ; public static final String ATTVAL_LIST = "list" ; public static final String ATTVAL_MAXLENGTH = "maxLength" ; public static final String ATTVAL_MINLENGTH = "minLength" ; public static final String ATTVAL_MIXED = "mixed" ; public static final String ATTVAL_NCNAME = "NCName" ; public static final String ATTVAL_OPTIONAL = "optional" ; public static final String ATTVAL_PROHIBITED = "prohibited" ; public static final String ATTVAL_QNAME = "QName" ; public static final String ATTVAL_QUALIFIED = "qualified" ; public static final String ATTVAL_REQUIRED = "required" ; public static final String ATTVAL_RESTRICTION = "restriction" ; public static final String ATTVAL_SKIP = "skip" ; public static final String ATTVAL_STRING = "string" ; public static final String ATTVAL_TEXTONLY = "textOnly" ; public static final String ATTVAL_TIMEDURATION = "timeDuration" ; public static final String ATTVAL_TRUE = "true" ; public static final String ATTVAL_UNQUALIFIED = "unqualified" ; public static final String ATTVAL_URI = "uri" ; public static final String ATTVAL_URIREFERENCE = "uriReference" ; public static final String ATTVAL_EQUIVCLASS = "equivclass" ; public static final int EMPTY_SET = 0 ; public static final int EXTENSION = 1 ; public static final int RESTRICTION = 2 ; public static final int REPRODUCTION = 4 ; public static final int LIST = 8 ; public static final int ENUMERATION = 16 ; public static final int EQUIVCLASS = 32 ; public static final int CHOICE = 0 ; public static final int SEQUENCE = 1 ; public static final int ALL = 2 ; public static final int INFINITY = - 1 ; public static final int NULLABLE = 1 ; public static final int ABSTRACT = 2 ; } 	0
package org . w3c . dom ; public class DOMException extends RuntimeException { public DOMException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short INDEX_SIZE_ERR = 1 ; public static final short DOMSTRING_SIZE_ERR = 2 ; public static final short HIERARCHY_REQUEST_ERR = 3 ; public static final short WRONG_DOCUMENT_ERR = 4 ; public static final short INVALID_CHARACTER_ERR = 5 ; public static final short NO_DATA_ALLOWED_ERR = 6 ; public static final short NO_MODIFICATION_ALLOWED_ERR = 7 ; public static final short NOT_FOUND_ERR = 8 ; public static final short NOT_SUPPORTED_ERR = 9 ; public static final short INUSE_ATTRIBUTE_ERR = 10 ; public static final short INVALID_STATE_ERR = 11 ; public static final short SYNTAX_ERR = 12 ; public static final short INVALID_MODIFICATION_ERR = 13 ; public static final short NAMESPACE_ERR = 14 ; public static final short INVALID_ACCESS_ERR = 15 ; } 	1
package org . w3c . dom . html ; public interface HTMLFontElement extends HTMLElement { public String getColor ( ) ; public void setColor ( String color ) ; public String getFace ( ) ; public void setFace ( String face ) ; public String getSize ( ) ; public void setSize ( String size ) ; } 	0
package org . w3c . dom . events ; public interface EventTarget { public void addEventListener ( String type , EventListener listener , boolean useCapture ) ; public void removeEventListener ( String type , EventListener listener , boolean useCapture ) ; public boolean dispatchEvent ( Event evt ) throws EventException ; } 	1
package org . apache . wml ; public interface WMLTemplateElement extends WMLElement { public void setOnTimer ( String newValue ) ; public String getOnTimer ( ) ; public void setOnEnterBackward ( String newValue ) ; public String getOnEnterBackward ( ) ; public void setOnEnterForward ( String newValue ) ; public String getOnEnterForward ( ) ; } 	0
package org . w3c . dom ; public interface NodeList { public Node item ( int index ) ; public int getLength ( ) ; } 	1
package org . w3c . dom . html ; import org . w3c . dom . DOMException ; public interface HTMLTableRowElement extends HTMLElement { public int getRowIndex ( ) ; public int getSectionRowIndex ( ) ; public HTMLCollection getCells ( ) ; public String getAlign ( ) ; public void setAlign ( String align ) ; public String getBgColor ( ) ; public void setBgColor ( String bgColor ) ; public String getCh ( ) ; public void setCh ( String ch ) ; public String getChOff ( ) ; public void setChOff ( String chOff ) ; public String getVAlign ( ) ; public void setVAlign ( String vAlign ) ; public HTMLElement insertCell ( int index ) throws DOMException ; public void deleteCell ( int index ) throws DOMException ; } 	0
package javax . xml . parsers ; public class ParserConfigurationException extends Exception { public ParserConfigurationException ( ) { super ( ) ; } public ParserConfigurationException ( String msg ) { super ( msg ) ; } } 	1
package org . apache . xerces . validators . schema ; import org . apache . xerces . utils . XMLMessageProvider ; import java . util . ResourceBundle ; import java . util . ListResourceBundle ; import java . util . Locale ; public class SchemaMessageProvider implements XMLMessageProvider { public static final String SCHEMA_DOMAIN = "http://www.w3.org/TR/xml-schema-1" ; public void setLocale ( Locale locale ) { fLocale = locale ; } public Locale getLocale ( ) { return fLocale ; } public String createMessage ( Locale locale , int majorCode , int minorCode , Object args [ ] ) { boolean throwex = false ; if ( fResourceBundle == null || locale != fLocale ) { if ( locale != null ) fResourceBundle = ListResourceBundle . getBundle ( "org.apache.xerces.msg.SchemaMessages" , locale ) ; if ( fResourceBundle == null ) fResourceBundle = ListResourceBundle . getBundle ( "org.apache.xerces.msg.SchemaMessages" ) ; } if ( majorCode < 0 || majorCode >= fgMessageKeys . length ) { majorCode = MSG_BAD_MAJORCODE ; throwex = true ; } String msgKey = fgMessageKeys [ majorCode ] ; String msg = fResourceBundle . getString ( msgKey ) ; if ( args != null ) { try { msg = java . text . MessageFormat . format ( msg , args ) ; } catch ( Exception e ) { msg = fResourceBundle . getString ( fgMessageKeys [ MSG_FORMAT_FAILURE ] ) ; msg += " " + fResourceBundle . getString ( msgKey ) ; } } if ( throwex ) { throw new RuntimeException ( msg ) ; } return msg ; } private Locale fLocale = null ; private ResourceBundle fResourceBundle = null ; public static final int MSG_BAD_MAJORCODE = 0 , MSG_FORMAT_FAILURE = 1 , NoValidatorFor = 2 , IncorrectDatatype = 3 , AttMissingType = 4 , NotADatatype = 5 , TextOnlyContentWithType = 6 , FeatureUnsupported = 7 , NestedOnlyInElemOnly = 8 , EltRefOnlyInMixedElemOnly = 9 , OnlyInEltContent = 10 , OrderIsAll = 11 , DatatypeWithType = 12 , DatatypeQualUnsupported = 13 , GroupContentRestricted = 14 , UnknownBaseDatatype = 15 , OneOfTypeRefArchRef = 16 , NoContentForRef = 17 , IncorrectDefaultType = 18 , IllegalAttContent = 19 , ValueNotInteger = 20 , DatatypeError = 21 , TypeAlreadySet = 22 , GenericError = 23 , UnclassifiedError = 24 , MSG_MAX_CODE = 31 ; public static final int MSG_NONE = 0 ; public static final String [ ] fgMessageKeys = { "BadMajorCode" , "FormatFailed" , "NoValidatorFor" , "IncorrectDatatype" , "AttMissingType" , "NotADatatype" , "TextOnlyContentWithType" , "FeatureUnsupported" , "NestedOnlyInElemOnly" , "EltRefOnlyInMixedElemOnly" , "OnlyInEltContent" , "OrderIsAll" , "DatatypeWithType" , "DatatypeQualUnsupported" , "GroupContentRestricted" , "UnknownBaseDatatype" , "OneOfTypeRefArchRef" , "NoContentForRef" , "IncorrectDefaultType" , "IllegalAttContent" , "ValueNotInteger" , "DatatypeError" , "TypeAlreadySet" , "GenericError" , "UnclassifiedError" , } ; } 	0
package org . apache . xerces . domx ; public abstract class DOMException extends org . w3c . dom . DOMException { public static final short UNSPECIFIED_EVENT_TYPE = 100 ; public static final short UNSUPPORTED_EVENT_TYPE = 101 ; public DOMException ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . xml . serialize ; import java . io . Writer ; import java . io . StringWriter ; import java . io . IOException ; public class Printer { protected final OutputFormat _format ; protected Writer _writer ; protected StringWriter _dtdWriter ; protected Writer _docWriter ; protected IOException _exception ; private static final int BufferSize = 4096 ; private final char [ ] _buffer = new char [ BufferSize ] ; private int _pos = 0 ; public Printer ( Writer writer , OutputFormat format ) { _writer = writer ; _format = format ; _exception = null ; _dtdWriter = null ; _docWriter = null ; _pos = 0 ; } public IOException getException ( ) { return _exception ; } public void enterDTD ( ) { if ( _dtdWriter == null ) { flushLine ( false ) ; _dtdWriter = new StringWriter ( ) ; _docWriter = _writer ; _writer = _dtdWriter ; } } public String leaveDTD ( ) { if ( _writer == _dtdWriter ) { flushLine ( false ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } else return null ; } public void printText ( String text ) { try { int length = text . length ( ) ; for ( int i = 0 ; i < length ; ++ i ) { if ( _pos == BufferSize ) { _writer . write ( _buffer ) ; _pos = 0 ; } _buffer [ _pos ] = text . charAt ( i ) ; ++ _pos ; } } catch ( IOException except ) { if ( _exception == null ) _exception = except ; } } public void printText ( StringBuffer text ) { try { int length = text . length ( ) ; for ( int i = 0 ; i < length ; ++ i ) { if ( _pos == BufferSize ) { _writer . write ( _buffer ) ; _pos = 0 ; } _buffer [ _pos ] = text . charAt ( i ) ; ++ _pos ; } } catch ( IOException except ) { if ( _exception == null ) _exception = except ; } } public void printText ( char [ ] chars , int start , int length ) { try { while ( length -- > 0 ) { if ( _pos == BufferSize ) { _writer . write ( _buffer ) ; _pos = 0 ; } _buffer [ _pos ] = chars [ start ] ; ++ start ; ++ _pos ; } } catch ( IOException except ) { if ( _exception == null ) _exception = except ; } } public void printText ( char ch ) { try { if ( _pos == BufferSize ) { _writer . write ( _buffer ) ; _pos = 0 ; } _buffer [ _pos ] = ch ; ++ _pos ; } catch ( IOException except ) { if ( _exception == null ) _exception = except ; } } public void printSpace ( ) { try { if ( _pos == BufferSize ) { _writer . write ( _buffer ) ; _pos = 0 ; } _buffer [ _pos ] = ' ' ; ++ _pos ; } catch ( IOException except ) { if ( _exception == null ) _exception = except ; } } public void breakLine ( ) { try { if ( _pos == BufferSize ) { _writer . write ( _buffer ) ; _pos = 0 ; } _buffer [ _pos ] = '\n' ; ++ _pos ; } catch ( IOException except ) { if ( _exception == null ) _exception = except ; } } public void breakLine ( boolean preserveSpace ) { breakLine ( ) ; } public void flushLine ( boolean preserveSpace ) { } public void flush ( ) { try { _writer . write ( _buffer , 0 , _pos ) ; _writer . flush ( ) ; } catch ( IOException except ) { if ( _exception == null ) _exception = except ; } _pos = 0 ; } public void indent ( ) { } public void unindent ( ) { } public int getNextIndent ( ) { return 0 ; } public void setNextIndent ( int indent ) { } public void setThisIndent ( int indent ) { } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrNSImpl extends AttrImpl { static final long serialVersionUID = - 781906615369795414L ; protected String namespaceURI ; protected String localName ; protected AttrNSImpl ( DocumentImpl ownerDocument , String namespaceURI , String qualifiedName ) { super ( ownerDocument , qualifiedName ) ; if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = qualifiedName ; } else { prefix = qualifiedName . substring ( 0 , index ) ; localName = qualifiedName . substring ( index + 1 ) ; } if ( ( prefix != null && ( namespaceURI == null || namespaceURI . equals ( "" ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) || ( prefix . equals ( "xmlns" ) && ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) ) || ( qualifiedName . equals ( "xmlns" ) && ( namespaceURI == null || ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } this . namespaceURI = namespaceURI ; } protected AttrNSImpl ( DocumentImpl ownerDocument , String value ) { super ( ownerDocument , value ) ; } public String getNamespaceURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return namespaceURI ; } public String getPrefix ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int index = name . indexOf ( ':' ) ; return index < 0 ? null : name . substring ( 0 , index ) ; } public void setPrefix ( String prefix ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( namespaceURI == null || ( prefix != null && ( ( prefix . equals ( "xmlns" ) && ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } if ( ownerDocument . errorChecking && ! DocumentImpl . isXMLName ( prefix ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } name = prefix + ":" + localName ; } public String getLocalName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return localName ; } } 	1
package org . apache . xerces . msg ; import java . util . ListResourceBundle ; public class DatatypeMessages extends ListResourceBundle { public static final Object CONTENTS [ ] [ ] = { { "BadMajorCode" , "The majorCode parameter to createMessage was out of bounds." } , { "FormatFailed" , "An internal error occurred while formatting the following message:\n  " } , { "NotBoolean" , "{0} is not a boolean." } , { "NotDecimal" , "{0} is not a decimal." } , { "FacetsInconsistent" , "Facets are inconsistent with base type." } , { "IllegalFacetValue" , "Illegal value {0} for facet {1}." } , { "IllegalDecimalFacet" , "Illegal Facet for decimal type." } , { "UnknownFacet" , "Unknown Facet: {0}." } , { "InvalidEnumValue" , "Invalid value for Enum constant: {0}." } , { "OutOfBounds" , "{0} is out of bounds:[ {1} {3} X  {4} {2} ]." } , { "NotAnEnumValue" , "{0} is not one of the specified enum values." } , { "NotInteger" , "{0} is not an integer." } , { "IllegalIntegerFacet" , "Illegal Facet for Integer type." } , { "NotReal" , "{0} is not a double." } , { "IllegalRealFacet" , "Illegal Facet for Real type." } , { "ScaleLargerThanPrecision" , "Scale Facet must be less than or equal to Precision Facet" } , { "PrecisionExceeded" , "{0} has exceeded the precision Facet {1}" } , { "ScaleExceeded" , "{0} has execeed the scale Facet {1}" } , { "NotFloat" , "{0} is not a float." } , } ; public Object [ ] [ ] getContents ( ) { return CONTENTS ; } } 	0
package org . apache . xerces . jaxp ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . xml . sax . SAXException ; public class SAXParserFactoryImpl extends SAXParserFactory { public SAXParserFactoryImpl ( ) { super ( ) ; } public SAXParser newSAXParser ( ) throws ParserConfigurationException { return ( new SAXParserImpl ( this . isNamespaceAware ( ) , this . isValidating ( ) ) ) ; } } 	1
package org . apache . xerces . readers ; import java . util . * ; public class MIME2Java { static private Hashtable s_enchash ; static private Hashtable s_revhash ; static { s_enchash = new Hashtable ( ) ; s_enchash . put ( "UTF-8" , "UTF8" ) ; s_enchash . put ( "US-ASCII" , "8859_1" ) ; s_enchash . put ( "ISO-8859-1" , "8859_1" ) ; s_enchash . put ( "ISO-8859-2" , "8859_2" ) ; s_enchash . put ( "ISO-8859-3" , "8859_3" ) ; s_enchash . put ( "ISO-8859-4" , "8859_4" ) ; s_enchash . put ( "ISO-8859-5" , "8859_5" ) ; s_enchash . put ( "ISO-8859-6" , "8859_6" ) ; s_enchash . put ( "ISO-8859-7" , "8859_7" ) ; s_enchash . put ( "ISO-8859-8" , "8859_8" ) ; s_enchash . put ( "ISO-8859-9" , "8859_9" ) ; s_enchash . put ( "ISO-2022-JP" , "JIS" ) ; s_enchash . put ( "SHIFT_JIS" , "SJIS" ) ; s_enchash . put ( "EUC-JP" , "EUCJIS" ) ; s_enchash . put ( "GB2312" , "GB2312" ) ; s_enchash . put ( "BIG5" , "Big5" ) ; s_enchash . put ( "EUC-KR" , "KSC5601" ) ; s_enchash . put ( "ISO-2022-KR" , "ISO2022KR" ) ; s_enchash . put ( "KOI8-R" , "KOI8_R" ) ; s_enchash . put ( "EBCDIC-CP-US" , "CP037" ) ; s_enchash . put ( "EBCDIC-CP-CA" , "CP037" ) ; s_enchash . put ( "EBCDIC-CP-NL" , "CP037" ) ; s_enchash . put ( "EBCDIC-CP-DK" , "CP277" ) ; s_enchash . put ( "EBCDIC-CP-NO" , "CP277" ) ; s_enchash . put ( "EBCDIC-CP-FI" , "CP278" ) ; s_enchash . put ( "EBCDIC-CP-SE" , "CP278" ) ; s_enchash . put ( "EBCDIC-CP-IT" , "CP280" ) ; s_enchash . put ( "EBCDIC-CP-ES" , "CP284" ) ; s_enchash . put ( "EBCDIC-CP-GB" , "CP285" ) ; s_enchash . put ( "EBCDIC-CP-FR" , "CP297" ) ; s_enchash . put ( "EBCDIC-CP-AR1" , "CP420" ) ; s_enchash . put ( "EBCDIC-CP-HE" , "CP424" ) ; s_enchash . put ( "EBCDIC-CP-CH" , "CP500" ) ; s_enchash . put ( "EBCDIC-CP-ROECE" , "CP870" ) ; s_enchash . put ( "EBCDIC-CP-YU" , "CP870" ) ; s_enchash . put ( "EBCDIC-CP-IS" , "CP871" ) ; s_enchash . put ( "EBCDIC-CP-AR2" , "CP918" ) ; s_revhash = new Hashtable ( ) ; s_revhash . put ( "UTF8" , "UTF-8" ) ; s_revhash . put ( "8859_1" , "ISO-8859-1" ) ; s_revhash . put ( "8859_2" , "ISO-8859-2" ) ; s_revhash . put ( "8859_3" , "ISO-8859-3" ) ; s_revhash . put ( "8859_4" , "ISO-8859-4" ) ; s_revhash . put ( "8859_5" , "ISO-8859-5" ) ; s_revhash . put ( "8859_6" , "ISO-8859-6" ) ; s_revhash . put ( "8859_7" , "ISO-8859-7" ) ; s_revhash . put ( "8859_8" , "ISO-8859-8" ) ; s_revhash . put ( "8859_9" , "ISO-8859-9" ) ; s_revhash . put ( "JIS" , "ISO-2022-JP" ) ; s_revhash . put ( "SJIS" , "Shift_JIS" ) ; s_revhash . put ( "EUCJIS" , "EUC-JP" ) ; s_revhash . put ( "GB2312" , "GB2312" ) ; s_revhash . put ( "BIG5" , "Big5" ) ; s_revhash . put ( "KSC5601" , "EUC-KR" ) ; s_revhash . put ( "ISO2022KR" , "ISO-2022-KR" ) ; s_revhash . put ( "KOI8_R" , "KOI8-R" ) ; s_revhash . put ( "CP037" , "EBCDIC-CP-US" ) ; s_revhash . put ( "CP037" , "EBCDIC-CP-CA" ) ; s_revhash . put ( "CP037" , "EBCDIC-CP-NL" ) ; s_revhash . put ( "CP277" , "EBCDIC-CP-DK" ) ; s_revhash . put ( "CP277" , "EBCDIC-CP-NO" ) ; s_revhash . put ( "CP278" , "EBCDIC-CP-FI" ) ; s_revhash . put ( "CP278" , "EBCDIC-CP-SE" ) ; s_revhash . put ( "CP280" , "EBCDIC-CP-IT" ) ; s_revhash . put ( "CP284" , "EBCDIC-CP-ES" ) ; s_revhash . put ( "CP285" , "EBCDIC-CP-GB" ) ; s_revhash . put ( "CP297" , "EBCDIC-CP-FR" ) ; s_revhash . put ( "CP420" , "EBCDIC-CP-AR1" ) ; s_revhash . put ( "CP424" , "EBCDIC-CP-HE" ) ; s_revhash . put ( "CP500" , "EBCDIC-CP-CH" ) ; s_revhash . put ( "CP870" , "EBCDIC-CP-ROECE" ) ; s_revhash . put ( "CP870" , "EBCDIC-CP-YU" ) ; s_revhash . put ( "CP871" , "EBCDIC-CP-IS" ) ; s_revhash . put ( "CP918" , "EBCDIC-CP-AR2" ) ; } private MIME2Java ( ) { } public static String convert ( String mimeCharsetName ) { return ( String ) s_enchash . get ( mimeCharsetName . toUpperCase ( ) ) ; } public static String reverse ( String encoding ) { return ( String ) s_revhash . get ( encoding . toUpperCase ( ) ) ; } } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public class AttributeMap extends NamedNodeMapImpl { protected AttributeMap ( ElementImpl ownerNode , NamedNodeMapImpl defaults ) { super ( ownerNode ) ; if ( defaults != null ) { cloneContent ( defaults ) ; if ( nodes != null ) { hasDefaults ( true ) ; } } } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } NodeImpl argn = ( NodeImpl ) arg ; if ( argn . isOwned ( ) ) { throw new DOMExceptionImpl ( DOMException . INUSE_ATTRIBUTE_ERR , "DOM009 Attribute already in use" ) ; } argn . ownerNode = ownerNode ; argn . isOwned ( true ) ; int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; previous . ownerNode = ownerNode . ownerDocument ( ) ; previous . isOwned ( false ) ; previous . isSpecified ( true ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { ownerNode . dispatchAggregateEvents ( ( AttrImpl ) arg , previous == null ? null : previous . getNodeValue ( ) ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } NodeImpl argn = ( NodeImpl ) arg ; if ( argn . isOwned ( ) ) { throw new DOMExceptionImpl ( DOMException . INUSE_ATTRIBUTE_ERR , "DOM009 Attribute already in use" ) ; } argn . ownerNode = ownerNode ; argn . isOwned ( true ) ; int i = findNamePoint ( argn . getNamespaceURI ( ) , argn . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; previous . ownerNode = ownerNode . ownerDocument ( ) ; previous . isOwned ( false ) ; previous . isSpecified ( true ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { ownerNode . dispatchAggregateEvents ( ( AttrImpl ) arg , previous == null ? null : previous . getNodeValue ( ) ) ; } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { return internalRemoveNamedItem ( name , true ) ; } Node safeRemoveNamedItem ( String name ) { return internalRemoveNamedItem ( name , false ) ; } final protected Node internalRemoveNamedItem ( String name , boolean raiseEx ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { if ( raiseEx ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } else { return null ; } } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; if ( hasDefaults ( ) ) { NamedNodeMapImpl defaults = ( ( ElementImpl ) ownerNode ) . getDefaultAttributes ( ) ; Node d ; if ( defaults != null && ( d = defaults . getNamedItem ( name ) ) != null && findNamePoint ( name , i + 1 ) < 0 ) { NodeImpl clone = ( NodeImpl ) d . cloneNode ( true ) ; clone . ownerNode = ownerNode ; clone . isOwned ( true ) ; clone . isSpecified ( false ) ; nodes . setElementAt ( clone , i ) ; } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } n . ownerNode = ownerNode . ownerDocument ( ) ; n . isOwned ( false ) ; n . isSpecified ( true ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { return internalRemoveNamedItemNS ( namespaceURI , name , true ) ; } Node safeRemoveNamedItemNS ( String namespaceURI , String name ) { return internalRemoveNamedItemNS ( namespaceURI , name , false ) ; } final protected Node internalRemoveNamedItemNS ( String namespaceURI , String name , boolean raiseEx ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { if ( raiseEx ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } else { return null ; } } LCount lc = null ; String oldvalue = "" ; AttrImpl enclosingAttribute = null ; if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttribute = ( AttrImpl ) ( nodes . elementAt ( i ) ) ; oldvalue = enclosingAttribute . getNodeValue ( ) ; } } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; String nodeName = n . getNodeName ( ) ; if ( hasDefaults ( ) ) { NamedNodeMapImpl defaults = ( ( ElementImpl ) ownerNode ) . getDefaultAttributes ( ) ; Node d ; if ( defaults != null && ( d = defaults . getNamedItem ( nodeName ) ) != null ) { int j = findNamePoint ( nodeName , 0 ) ; if ( j >= 0 && findNamePoint ( nodeName , j + 1 ) < 0 ) { NodeImpl clone = ( NodeImpl ) d . cloneNode ( true ) ; clone . ownerNode = ownerNode ; clone . isOwned ( true ) ; clone . isSpecified ( false ) ; nodes . setElementAt ( clone , i ) ; } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } n . ownerNode = ownerNode . ownerDocument ( ) ; n . isOwned ( false ) ; n . isSpecified ( true ) ; if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_ATTR_MODIFIED , true , false , null , n . getNodeValue ( ) , ( ( ElementImpl ) ownerNode ) . getAttribute ( name ) , name ) ; ownerNode . dispatchEvent ( me ) ; } ownerNode . dispatchAggregateEvents ( null , null ) ; } return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { AttributeMap newmap = new AttributeMap ( ( ElementImpl ) ownerNode , null ) ; newmap . hasDefaults ( hasDefaults ( ) ) ; newmap . cloneContent ( this ) ; return newmap ; } } 	1
package org . xml . sax . helpers ; import org . xml . sax . Locator ; public class LocatorImpl implements Locator { public LocatorImpl ( ) { } public LocatorImpl ( Locator locator ) { setPublicId ( locator . getPublicId ( ) ) ; setSystemId ( locator . getSystemId ( ) ) ; setLineNumber ( locator . getLineNumber ( ) ) ; setColumnNumber ( locator . getColumnNumber ( ) ) ; } public String getPublicId ( ) { return publicId ; } public String getSystemId ( ) { return systemId ; } public int getLineNumber ( ) { return lineNumber ; } public int getColumnNumber ( ) { return columnNumber ; } public void setPublicId ( String publicId ) { this . publicId = publicId ; } public void setSystemId ( String systemId ) { this . systemId = systemId ; } public void setLineNumber ( int lineNumber ) { this . lineNumber = lineNumber ; } public void setColumnNumber ( int columnNumber ) { this . columnNumber = columnNumber ; } private String publicId ; private String systemId ; private int lineNumber ; private int columnNumber ; } 	0
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . w3c . dom . Document ; public abstract class DocumentBuilder { protected DocumentBuilder ( ) { super ( ) ; } public Document parse ( InputStream stream ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( stream ) ) ) ; } public Document parse ( String uri ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( uri ) ) ) ; } public Document parse ( File file ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( file . getName ( ) ) ) ) ; } public abstract Document parse ( InputSource source ) throws SAXException , IOException , IllegalArgumentException ; public abstract Document newDocument ( ) ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; public abstract void setEntityResolver ( EntityResolver er ) ; public abstract void setErrorHandler ( ErrorHandler eh ) ; } 	1
package org . w3c . dom . html ; public interface HTMLMetaElement extends HTMLElement { public String getContent ( ) ; public void setContent ( String content ) ; public String getHttpEquiv ( ) ; public void setHttpEquiv ( String httpEquiv ) ; public String getName ( ) ; public void setName ( String name ) ; public String getScheme ( ) ; public void setScheme ( String scheme ) ; } 	0
package org . apache . xerces . dom . events ; import org . apache . xerces . dom . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; public class MutationEventImpl extends org . apache . xerces . dom . events . EventImpl implements MutationEvent { Node relatedNode = null ; String prevValue = null , newValue = null , attrName = null ; public static final String DOM_SUBTREE_MODIFIED = "DOMSubtreeModified" ; public static final String DOM_NODE_INSERTED = "DOMNodeInserted" ; public static final String DOM_NODE_REMOVED = "DOMNodeRemoved" ; public static final String DOM_NODE_REMOVED_FROM_DOCUMENT = "DOMNodeRemovedFromDocument" ; public static final String DOM_NODE_INSERTED_INTO_DOCUMENT = "DOMNodeInsertedIntoDocument" ; public static final String DOM_ATTR_MODIFIED = "DOMAttrModified" ; public static final String DOM_CHARACTER_DATA_MODIFIED = "DOMCharacterDataModified" ; public String getAttrName ( ) { return attrName ; } public String getNewValue ( ) { return newValue ; } public String getPrevValue ( ) { return prevValue ; } public Node getRelatedNode ( ) { return relatedNode ; } public void initMutationEvent ( String typeArg , boolean canBubbleArg , boolean cancelableArg , Node relatedNodeArg , String prevValueArg , String newValueArg , String attrNameArg ) { relatedNode = relatedNodeArg ; prevValue = prevValueArg ; newValue = newValueArg ; attrName = attrNameArg ; super . initEvent ( typeArg , canBubbleArg , cancelableArg ) ; } } 	1
package org . apache . wml ; public interface WMLIElement extends WMLElement { public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . SymbolCache ; import org . apache . xerces . utils . UTF8DataChunk ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . LocatorImpl ; import java . io . InputStream ; import java . util . Vector ; final class UTF8Reader extends XMLEntityReader { private final static boolean USE_OUT_OF_LINE_LOAD_NEXT_BYTE = false ; private final static boolean USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE = true ; public UTF8Reader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , InputStream dataStream , StringPool stringPool ) throws Exception { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fInputStream = dataStream ; fStringPool = stringPool ; fCharArrayRange = fStringPool . createCharArrayRange ( ) ; fCurrentChunk = UTF8DataChunk . createChunk ( fStringPool , null ) ; fillCurrentChunk ( ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } private int addSymbol ( int offset , int length , int hashcode ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , hashcode ) ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } private int slowLoadNextByte ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; return ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } else { fCurrentChunk = UTF8DataChunk . createChunk ( fStringPool , fCurrentChunk ) ; return fillCurrentChunk ( ) ; } } private int loadNextByte ( ) throws Exception { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; return fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { return slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) return slowLoadNextByte ( ) ; else return ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; fMostRecentData = null ; fMostRecentByte = 0 ; return nextReader ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) throws Exception { int b0 = fMostRecentByte ; if ( b0 != ch ) { if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( ch , skipPastChar ) ; } } if ( ch == 0x0A && b0 == 0x0D ) { if ( skipPastChar ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; b0 = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == 0x0A ) { fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } } return true ; } return false ; } if ( ch == 0x0D ) return false ; if ( skipPastChar ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int b0 = fMostRecentByte ; if ( b0 < 0x80 ) { if ( b0 >= 0x20 || b0 == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } if ( b0 == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } if ( b0 == 0x0D ) { if ( skipPastChar ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; b0 = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == 0x0A ) { fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } } return true ; } if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; } return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { boolean result = false ; if ( ! ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; return true ; } result = true ; } fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } int b3 = loadNextByte ( ) ; boolean result = false ; if ( ( ( b0 & 0xf8 ) == 0xf0 ) && ( ( b1 & 0xc0 ) == 0x80 ) && ( ( b2 & 0xc0 ) == 0x80 ) && ( ( b3 & 0xc0 ) == 0x80 ) ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; return true ; } result = true ; fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentByte ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { if ( ! skipPastChar ) return true ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) return true ; fLinefeedCounter ++ ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return true ; } public void skipToChar ( char ch ) throws Exception { int b0 = fMostRecentByte ; while ( true ) { if ( b0 == ch ) return ; if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( ch ) ; return ; } fCharacterCounter ++ ; } else if ( b0 == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( b0 == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; if ( b0 != 0x0A ) continue ; fLinefeedCounter ++ ; } else if ( b0 < 0x80 ) { fCharacterCounter ++ ; } else { fCharacterCounter ++ ; if ( ( 0xe0 & b0 ) == 0xc0 ) { loadNextByte ( ) ; } else if ( ( 0xf0 & b0 ) == 0xe0 ) { loadNextByte ( ) ; loadNextByte ( ) ; } else { loadNextByte ( ) ; loadNextByte ( ) ; loadNextByte ( ) ; } } b0 = loadNextByte ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentByte ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) continue ; fLinefeedCounter ++ ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } } protected boolean skippedMultiByteCharWithFlag ( int b0 , int flag ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { if ( ( XMLCharacterProperties . fgCharFlags [ ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ] & flag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } if ( ( XMLCharacterProperties . fgCharFlags [ ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ] & flag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } return true ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } public void skipPastName ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ b0 ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_InitialNameCharFlag ) ) return ; } while ( true ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( fastcheck == b0 ) return ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_NameCharFlag ) ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; while ( true ) { if ( fastcheck == b0 ) return ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) return ; } else { if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_NameCharFlag ) ) return ; } fCharacterCounter ++ ; b0 = loadNextByte ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int length = s . length ; byte [ ] data = fMostRecentData ; int index = fCurrentIndex + length ; int sindex = length ; try { while ( sindex -- > 0 ) { if ( data [ -- index ] != s [ sindex ] ) return false ; } fCurrentIndex += length ; } catch ( ArrayIndexOutOfBoundsException ex ) { int i = 0 ; index = fCurrentIndex ; while ( index < UTF8DataChunk . CHUNK_SIZE ) { if ( data [ index ++ ] != s [ i ++ ] ) return false ; } UTF8DataChunk dataChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; int savedIndex = fCurrentIndex ; slowLoadNextByte ( ) ; data = fMostRecentData ; index = 0 ; while ( i < length ) { if ( data [ index ++ ] != s [ i ++ ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; return false ; } } fCurrentIndex = index ; } fCharacterCounter += length ; fCurrentOffset += length ; try { fMostRecentByte = data [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } return true ; } public int scanInvalidChar ( ) throws Exception { int b0 = fMostRecentByte ; int ch = b0 ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; if ( ch != 0x0A ) return 0x0A ; fLinefeedCounter ++ ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } fCharacterCounter ++ ; } else if ( b0 >= 0x80 ) { fCharacterCounter ++ ; int b1 = loadNextByte ( ) ; int b2 = 0 ; if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; } else if ( ( 0xf0 & b0 ) == 0xe0 ) { b2 = loadNextByte ( ) ; ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; } else if ( ( 0xf8 & b0 ) == 0xf0 ) { b2 = loadNextByte ( ) ; int b3 = loadNextByte ( ) ; ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; } } loadNextByte ( ) ; return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentByte ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextByte ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentByte ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextByte ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextByte ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = fCurrentChunk . addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public static final byte fgAsciiAttValueChar [ ] = { 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 2 , 2 , 4 , 4 , 2 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 0 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; int b0 = fMostRecentByte ; while ( true ) { if ( b0 < 0x80 ) { switch ( fgAsciiAttValueChar [ b0 ] ) { case 1 : if ( b0 == qchar ) { int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : ( asSymbol ? fCurrentChunk . addSymbol ( offset , length , 0 ) : fCurrentChunk . addString ( offset , length ) ) ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return result ; } case 0 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 2 : return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; case 3 : return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; case 4 : return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( b0 ) ) return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; b0 = fMostRecentByte ; } } } public static final byte fgAsciiEntityValueChar [ ] = { 7 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 5 , 4 , 4 , 6 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 3 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; int b0 = fMostRecentByte ; while ( true ) { if ( b0 < 0x80 ) { switch ( fgAsciiEntityValueChar [ b0 ] ) { case 1 : if ( b0 == qchar ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : fCurrentChunk . addString ( offset , length ) ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return result ; } case 0 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 5 : fLinefeedCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 6 : fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 != 0x0A ) { continue ; } fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 2 : return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; case 3 : return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; case 7 : if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } case 4 : return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( b0 ) ) return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; b0 = fMostRecentByte ; } } } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int b0 = fMostRecentByte ; int ch = 0 ; int i = 0 ; while ( true ) { if ( b0 < 0x80 ) { ch = b0 ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } } else { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; skipPastNmtoken ( fastcheck ) ; return false ; } } else { int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; skipPastNmtoken ( fastcheck ) ; return false ; } } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } } i ++ ; offset ++ ; fCharacterCounter ++ ; fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentByte ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; int index = fCurrentIndex ; byte [ ] data = fMostRecentData ; int prefixend = - 1 ; while ( true ) { fCharacterCounter ++ ; fCurrentOffset ++ ; index ++ ; try { ch = data [ index ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; index = 0 ; data = fMostRecentData ; } if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; try { ch = data [ index + 1 ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { UTF8DataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; ch = slowLoadNextByte ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; } boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; break ; } } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } } fCurrentIndex = index ; fMostRecentByte = ch ; int length = fCurrentOffset - offset ; qname . rawname = addSymbol ( offset , length ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } private int getMultiByteSymbolChar ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } loadNextByte ( ) ; return ch ; } int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } loadNextByte ( ) ; return ch ; } fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } public int scanName ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; int ch ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ b0 ] == 0 ) { if ( b0 == 0 && atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanName ( fastcheck ) ; } return - 1 ; } ch = b0 ; } else { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } else { int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return scanMatchingName ( ch , b0 , fastcheck ) ; } private int scanMatchingName ( int ch , int b0 , int fastcheck ) throws Exception { SymbolCache cache = fStringPool . getSymbolCache ( ) ; int [ ] [ ] cacheLines = cache . fCacheLines ; char [ ] symbolChars = cache . fSymbolChars ; boolean lengthOfOne = fastcheck == fMostRecentByte ; int startOffset = cache . fSymbolCharsOffset ; int entry = 0 ; int [ ] entries = cacheLines [ entry ] ; int offset = 1 + ( ( entries [ 0 ] - 1 ) * SymbolCache . CACHE_RECORD_SIZE ) ; int totalMisses = 0 ; if ( lengthOfOne ) { while ( offset > 0 ) { if ( entries [ offset + SymbolCache . CHAR_OFFSET ] == ch ) { if ( entries [ offset + SymbolCache . INDEX_OFFSET ] != - 1 ) { int symbolIndex = entries [ offset + SymbolCache . INDEX_OFFSET ] ; if ( totalMisses > 3 ) fStringPool . updateCacheLine ( symbolIndex , totalMisses , 1 ) ; return symbolIndex ; } break ; } offset -= SymbolCache . CACHE_RECORD_SIZE ; totalMisses ++ ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; if ( offset < 0 ) { offset = 1 + ( entries [ 0 ] * SymbolCache . CACHE_RECORD_SIZE ) ; entries [ 0 ] ++ ; try { entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; entries = new int [ newSize ] ; System . arraycopy ( cacheLines [ entry ] , 0 , entries , 0 , offset ) ; cacheLines [ entry ] = entries ; entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } entries [ offset + SymbolCache . NEXT_OFFSET ] = - 1 ; } int result = fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; return result ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; int depth = 1 ; while ( true ) { if ( offset < 0 ) break ; if ( entries [ offset + SymbolCache . CHAR_OFFSET ] != ch ) { offset -= SymbolCache . CACHE_RECORD_SIZE ; totalMisses ++ ; continue ; } if ( b0 >= 0x80 ) { ch = getMultiByteSymbolChar ( b0 ) ; b0 = fMostRecentByte ; } else if ( b0 == fastcheck || XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) { ch = - 1 ; } else { ch = b0 ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } if ( ch == - 1 ) { if ( entries [ offset + SymbolCache . INDEX_OFFSET ] == - 1 ) { return fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; } cache . fSymbolCharsOffset = startOffset ; int symbolIndex = entries [ offset + SymbolCache . INDEX_OFFSET ] ; if ( totalMisses > ( depth * 3 ) ) fStringPool . updateCacheLine ( symbolIndex , totalMisses , depth ) ; return symbolIndex ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; entry = entries [ offset + SymbolCache . NEXT_OFFSET ] ; try { entries = cacheLines [ entry ] ; } catch ( ArrayIndexOutOfBoundsException ex ) { if ( entry == - 1 ) { entry = cache . fCacheLineCount ++ ; entries [ offset + SymbolCache . NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( SymbolCache . INITIAL_CACHE_RECORD_COUNT * SymbolCache . CACHE_RECORD_SIZE ) ] ; try { cacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex2 ) { cacheLines = new int [ entry * 2 ] [ ] ; System . arraycopy ( cache . fCacheLines , 0 , cacheLines , 0 , entry ) ; cache . fCacheLines = cacheLines ; cacheLines [ entry ] = entries ; } } else { entries = cacheLines [ entry ] ; throw new RuntimeException ( "RDR001 untested" ) ; } } offset = 1 + ( ( entries [ 0 ] - 1 ) * SymbolCache . CACHE_RECORD_SIZE ) ; depth ++ ; } if ( offset < 0 ) offset = 1 + ( entries [ 0 ] * SymbolCache . CACHE_RECORD_SIZE ) ; while ( true ) { entries [ 0 ] ++ ; try { entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; entries = new int [ newSize ] ; System . arraycopy ( cacheLines [ entry ] , 0 , entries , 0 , offset ) ; cacheLines [ entry ] = entries ; entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } if ( b0 >= 0x80 ) { ch = getMultiByteSymbolChar ( b0 ) ; b0 = fMostRecentByte ; } else if ( b0 == fastcheck || XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) { ch = - 1 ; } else { ch = b0 ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } if ( ch == - 1 ) { entries [ offset + SymbolCache . NEXT_OFFSET ] = - 1 ; break ; } entry = cache . fCacheLineCount ++ ; entries [ offset + SymbolCache . INDEX_OFFSET ] = - 1 ; entries [ offset + SymbolCache . NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( SymbolCache . INITIAL_CACHE_RECORD_COUNT * SymbolCache . CACHE_RECORD_SIZE ) ] ; try { cacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex ) { cacheLines = new int [ entry * 2 ] [ ] ; System . arraycopy ( cache . fCacheLines , 0 , cacheLines , 0 , entry ) ; cache . fCacheLines = cacheLines ; cacheLines [ entry ] = entries ; } offset = 1 ; try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; } int result = fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; return result ; } private int recognizeMarkup ( int b0 , QName element ) throws Exception { switch ( b0 ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 == '-' ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 == '-' ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( b0 == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } int expectedName = element . rawname ; fStringPool . getCharArrayRange ( expectedName , fCharArrayRange ) ; char [ ] expected = fCharArrayRange . chars ; int offset = fCharArrayRange . offset ; int len = fCharArrayRange . length ; if ( b0 == expected [ offset ++ ] ) { UTF8DataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; for ( int i = 1 ; i < len ; i ++ ) { if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 != expected [ offset ++ ] ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; } } fCharacterCounter += len ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == '>' ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG ; } while ( b0 == 0x20 || b0 == 0x09 || b0 == 0x0A || b0 == 0x0D ) { if ( b0 == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; } else if ( b0 == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; if ( b0 == 0x0A ) { fLinefeedCounter ++ ; b0 = loadNextByte ( ) ; } } else { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; } if ( b0 == '>' ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG ; } } fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; } return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; fCharDataLength = 0 ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentByte ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } break ; case 1 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ! fInCDSect ) { return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; break ; case 2 : fCharacterCounter ++ ; ch = loadNextByte ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; break ; case 3 : fCharacterCounter ++ ; ch = loadNextByte ( ) ; if ( ch != ']' ) { if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) { if ( fSendCharDataAsCharArray ) appendCharData ( 0x0A ) ; if ( ch == 0x20 || ch == 0x09 || ch == 0x0D ) continue ; break ; } fLinefeedCounter ++ ; } else { fCharacterCounter ++ ; } if ( fSendCharDataAsCharArray ) { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A || ch == 0x0D ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 1 : if ( ! fInCDSect ) { if ( fSendCharDataAsCharArray ) { fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = addString ( charDataOffset , fCurrentOffset - charDataOffset ) ; fCharDataHandler . processWhitespace ( stringIndex ) ; } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 2 : if ( ! fInCDSect ) { whitespace ( charDataOffset , fCurrentOffset ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextByte ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; whitespace ( charDataOffset , endOffset ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : whitespace ( charDataOffset , fCurrentOffset ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { whitespace ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { whitespace ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } break ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } } if ( fSendCharDataAsCharArray ) ch = copyAsciiCharData ( ) ; else ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 1 : if ( ! fInCDSect ) { if ( fSendCharDataAsCharArray ) { fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = addString ( charDataOffset , fCurrentOffset - charDataOffset ) ; fCharDataHandler . processCharacters ( stringIndex ) ; } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 2 : if ( ! fInCDSect ) { characters ( charDataOffset , fCurrentOffset ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextByte ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; characters ( charDataOffset , endOffset ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; break ; } if ( ch == 0x0D ) { if ( fSendCharDataAsCharArray ) appendCharData ( 0x0A ) ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; ch = loadNextByte ( ) ; } break ; } characters ( charDataOffset , fCurrentOffset ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { characters ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { characters ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentByte ; } } } private boolean copyMultiByteCharData ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; appendCharData ( ch ) ; loadNextByte ( ) ; return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; appendCharData ( ch ) ; loadNextByte ( ) ; return true ; } int b3 = loadNextByte ( ) ; if ( ( 0xf8 & b0 ) == 0xf0 ) { if ( b0 > 0xF4 || ( b0 == 0xF4 && b1 >= 0x90 ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } int ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; if ( ch < 0x10000 ) { appendCharData ( ch ) ; } else { appendCharData ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; appendCharData ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; } loadNextByte ( ) ; return true ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } private boolean skipMultiByteCharData ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { loadNextByte ( ) ; return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } loadNextByte ( ) ; return true ; } int b3 = loadNextByte ( ) ; if ( b0 > 0xF4 || ( b0 == 0xF4 && b1 >= 0x90 ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } loadNextByte ( ) ; return true ; } private int copyAsciiCharData ( ) throws Exception { int srcIndex = fCurrentIndex ; int offset = fCurrentOffset - srcIndex ; byte [ ] data = fMostRecentData ; int dstIndex = fCharDataLength ; boolean skiplf = false ; while ( true ) { int ch ; try { ch = data [ srcIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { offset += srcIndex ; slowLoadNextByte ( ) ; srcIndex = 0 ; data = fMostRecentData ; ch = data [ srcIndex ] & 0xFF ; } if ( ch >= 0x80 ) { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; skiplf = false ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; if ( skiplf ) { skiplf = false ; srcIndex ++ ; continue ; } fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; skiplf = true ; ch = 0x0A ; } else { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } srcIndex ++ ; try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } } private int skipAsciiCharData ( ) throws Exception { int srcIndex = fCurrentIndex ; int offset = fCurrentOffset - srcIndex ; byte [ ] data = fMostRecentData ; while ( true ) { int ch ; try { ch = data [ srcIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { offset += srcIndex ; slowLoadNextByte ( ) ; srcIndex = 0 ; data = fMostRecentData ; ch = data [ srcIndex ] & 0xFF ; } if ( ch >= 0x80 ) { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } srcIndex ++ ; } } private char [ ] fCharacters = new char [ UTF8DataChunk . CHUNK_SIZE ] ; private int fCharDataLength = 0 ; private void appendCharData ( int ch ) throws Exception { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } private void slowAppendCharData ( int ch ) throws Exception { characters ( 0 , fCharDataLength ) ; fCharDataLength = 0 ; fCharacters [ fCharDataLength ++ ] = ( char ) ch ; } private void characters ( int offset , int endOffset ) throws Exception { if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , endOffset - offset ) ; fCharDataHandler . processCharacters ( stringIndex ) ; return ; } fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } private void whitespace ( int offset , int endOffset ) throws Exception { if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , endOffset - offset ) ; fCharDataHandler . processWhitespace ( stringIndex ) ; return ; } fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool . CharArrayRange fCharArrayRange = null ; private InputStream fInputStream = null ; private StringPool fStringPool = null ; private UTF8DataChunk fCurrentChunk = null ; private int fCurrentIndex = 0 ; private byte [ ] fMostRecentData = null ; private int fMostRecentByte = 0 ; private int fLength = 0 ; private boolean fCalledCharPropInit = false ; private boolean fCallClearPreviousChunk = true ; private int fillCurrentChunk ( ) throws Exception { byte [ ] buf = fCurrentChunk . toByteArray ( ) ; if ( fInputStream == null ) { if ( buf == null ) buf = new byte [ 1 ] ; buf [ 0 ] = 0 ; fMostRecentData = buf ; fCurrentIndex = 0 ; fCurrentChunk . setByteArray ( fMostRecentData ) ; return ( fMostRecentByte = fMostRecentData [ 0 ] & 0xFF ) ; } if ( buf == null ) buf = new byte [ UTF8DataChunk . CHUNK_SIZE ] ; int offset = 0 ; int capacity = UTF8DataChunk . CHUNK_SIZE ; int result = 0 ; do { try { result = fInputStream . read ( buf , offset , capacity ) ; } catch ( java . io . IOException ex ) { result = - 1 ; } if ( result == - 1 ) { fInputStream . close ( ) ; fInputStream = null ; try { buf [ offset ] = 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { } break ; } if ( result > 0 ) { offset += result ; capacity -= result ; } } while ( capacity > 0 ) ; fMostRecentData = buf ; fLength += offset ; fCurrentIndex = 0 ; fCurrentChunk . setByteArray ( fMostRecentData ) ; return ( fMostRecentByte = fMostRecentData [ 0 ] & 0xFF ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLParagraphElementImpl extends HTMLElementImpl implements HTMLParagraphElement { public String getAlign ( ) { return getAttribute ( "align" ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public HTMLParagraphElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . dom . events ; import org . w3c . dom . events . * ; import org . w3c . dom . Node ; public class EventImpl implements Event { public String type = null ; public EventTarget target ; public Node currentNode ; public short eventPhase ; public boolean initialized = false , bubbles = true , cancelable = false ; public boolean stopPropagation = false , preventDefault = false ; protected long timeStamp = System . currentTimeMillis ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) { type = eventTypeArg ; bubbles = canBubbleArg ; cancelable = cancelableArg ; initialized = true ; } public boolean getBubbles ( ) { return bubbles ; } public boolean getCancelable ( ) { return cancelable ; } public Node getCurrentNode ( ) { return currentNode ; } public short getEventPhase ( ) { return eventPhase ; } public EventTarget getTarget ( ) { return target ; } public String getType ( ) { return type ; } public long getTimeStamp ( ) { return timeStamp ; } public void stopPropagation ( ) { stopPropagation = true ; } public void preventDefault ( ) { preventDefault = true ; } } 	1
package org . w3c . dom . range ; public interface DocumentRange { public Range createRange ( ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DOMImplementationImpl implements DOMImplementation { static DOMImplementationImpl singleton = new DOMImplementationImpl ( ) ; public boolean hasFeature ( String feature , String version ) { return ( feature . equalsIgnoreCase ( "XML" ) && ( version == null || version . equals ( "1.0" ) || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "Events" ) && ( version == null || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "MutationEvents" ) && ( version == null || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "Traversal" ) && ( version == null || version . equals ( "2.0" ) ) ) ; } public static DOMImplementation getDOMImplementation ( ) { return singleton ; } public DocumentType createDocumentType ( String qualifiedName , String publicID , String systemID ) { if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; if ( index == 0 || index == qualifiedName . length ( ) - 1 ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } return new DocumentTypeImpl ( null , qualifiedName , publicID , systemID ) ; } public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException { if ( doctype != null && doctype . getOwnerDocument ( ) != null ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } DocumentImpl doc = new DocumentImpl ( doctype ) ; Element e = doc . createElementNS ( namespaceURI , qualifiedName ) ; doc . appendChild ( e ) ; return doc ; } } 	1
package org . xml . sax ; import java . io . IOException ; public interface XMLReader { public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException ; public void setFeature ( String name , boolean value ) throws SAXNotRecognizedException , SAXNotSupportedException ; public Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException ; public void setProperty ( String name , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException ; public void setEntityResolver ( EntityResolver resolver ) ; public EntityResolver getEntityResolver ( ) ; public void setDTDHandler ( DTDHandler handler ) ; public DTDHandler getDTDHandler ( ) ; public void setContentHandler ( ContentHandler handler ) ; public ContentHandler getContentHandler ( ) ; public void setErrorHandler ( ErrorHandler handler ) ; public ErrorHandler getErrorHandler ( ) ; public void parse ( InputSource input ) throws IOException , SAXException ; public void parse ( String systemId ) throws IOException , SAXException ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface DocumentTraversal { public NodeIterator createNodeIterator ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) ; public TreeWalker createTreeWalker ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) throws DOMException ; } 	1
package org . xml . sax . helpers ; import org . xml . sax . Parser ; import org . xml . sax . XMLReader ; import org . xml . sax . SAXException ; final public class XMLReaderFactory { private XMLReaderFactory ( ) { } public static XMLReader createXMLReader ( ) throws SAXException { String className = System . getProperty ( "org.xml.sax.driver" ) ; if ( className == null ) { Parser parser ; try { parser = ParserFactory . makeParser ( ) ; } catch ( Exception e ) { parser = null ; } if ( parser == null ) { throw new SAXException ( "System property org.xml.sax.driver not specified" ) ; } else { return new ParserAdapter ( parser ) ; } } else { return createXMLReader ( className ) ; } } public static XMLReader createXMLReader ( String className ) throws SAXException { try { return ( XMLReader ) ( Class . forName ( className ) . newInstance ( ) ) ; } catch ( ClassNotFoundException e1 ) { throw new SAXException ( "SAX2 driver class " + className + " not found" , e1 ) ; } catch ( IllegalAccessException e2 ) { throw new SAXException ( "SAX2 driver class " + className + " found but cannot be loaded" , e2 ) ; } catch ( InstantiationException e3 ) { throw new SAXException ( "SAX2 driver class " + className + " loaded but cannot be instantiated (no empty public constructor?)" , e3 ) ; } catch ( ClassCastException e4 ) { throw new SAXException ( "SAX2 driver class " + className + " does not implement XMLReader" , e4 ) ; } } } 	0
package org . apache . xerces . readers ; import java . io . FileNotFoundException ; import java . io . UnsupportedEncodingException ; import java . net . MalformedURLException ; import java . util . Stack ; import java . util . Vector ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . URI ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; public class DefaultEntityHandler implements XMLEntityHandler , XMLEntityHandler . DTDHandler { public interface EventHandler { public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void sendEndOfInputNotifications ( int entityName , boolean moreToFollow ) throws Exception ; public void sendReaderChangeNotifications ( XMLEntityHandler . EntityReader reader , int readerId ) throws Exception ; public boolean externalEntityStandaloneCheck ( ) ; public boolean getValidating ( ) ; } private class ReaderState { XMLEntityHandler . EntityReader reader ; InputSource source ; int entityName ; int entityType ; int entityContext ; String publicId ; String systemId ; int readerId ; int depth ; ReaderState nextReaderState ; } private ReaderState fReaderStateFreeList = null ; private StringPool fStringPool = null ; private EventHandler fEventHandler = null ; private XMLEntityHandler . CharDataHandler fCharDataHandler = null ; private XMLErrorReporter fErrorReporter = null ; private EntityResolver fResolver = null ; private EntityPool fEntityPool = null ; private EntityPool fParameterEntityPool = null ; private byte [ ] fEntityTypeStack = null ; private int [ ] fEntityNameStack = null ; private int fEntityStackDepth = 0 ; private Stack fReaderStack = new Stack ( ) ; private XMLEntityHandler . EntityReader fReader = null ; private InputSource fSource = null ; private int fEntityName = - 1 ; private int fEntityType = - 1 ; private int fEntityContext = - 1 ; private String fPublicId = null ; private String fSystemId = null ; private int fReaderId = - 1 ; private int fReaderDepth = - 1 ; private int fNextReaderId = 0 ; private NullReader fNullReader = null ; protected XMLEntityReaderFactory fReaderFactory = null ; private boolean fSendCharDataAsCharArray = false ; public DefaultEntityHandler ( StringPool stringPool , XMLErrorReporter errorReporter ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fReaderFactory = new DefaultReaderFactory ( ) ; fEntityPool = new EntityPool ( fStringPool , fErrorReporter , true ) ; } public void setEventHandler ( EventHandler eventHandler ) { fEventHandler = eventHandler ; } public void setCharDataHandler ( XMLEntityHandler . CharDataHandler charDataHandler ) { fCharDataHandler = charDataHandler ; } public XMLEntityHandler . CharDataHandler getCharDataHandler ( ) { return fCharDataHandler ; } public void setSendCharDataAsCharArray ( boolean flag ) { fSendCharDataAsCharArray = flag ; fReaderFactory . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; } public void setReaderFactory ( XMLEntityReaderFactory readerFactory ) { fReaderFactory = readerFactory ; fReaderFactory . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fEntityPool . reset ( fStringPool ) ; fParameterEntityPool = null ; fReaderStack . removeAllElements ( ) ; fEntityStackDepth = 0 ; fReader = null ; fSource = null ; fEntityName = - 1 ; fEntityType = - 1 ; fEntityContext = - 1 ; fPublicId = null ; fSystemId = null ; fReaderId = - 1 ; fReaderDepth = - 1 ; fNextReaderId = 0 ; } public void setAllowJavaEncodings ( boolean flag ) { fReaderFactory . setAllowJavaEncodingName ( flag ) ; } public boolean getAllowJavaEncodings ( ) { return fReaderFactory . getAllowJavaEncodingName ( ) ; } public int addInternalPEDecl ( int name , int value , boolean isExternal ) throws Exception { if ( fParameterEntityPool == null ) fParameterEntityPool = new EntityPool ( fStringPool , fErrorReporter , false ) ; int entityHandle = fParameterEntityPool . addEntityDecl ( name , value , - 1 , - 1 , - 1 , - 1 , isExternal ) ; return entityHandle ; } public int addExternalPEDecl ( int name , int publicId , int systemId , boolean isExternal ) throws Exception { if ( fParameterEntityPool == null ) fParameterEntityPool = new EntityPool ( fStringPool , fErrorReporter , false ) ; int entityHandle = fParameterEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , - 1 , isExternal ) ; return entityHandle ; } public int addInternalEntityDecl ( int name , int value , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , value , - 1 , - 1 , - 1 , - 1 , isExternal ) ; return entityHandle ; } public int addExternalEntityDecl ( int name , int publicId , int systemId , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , - 1 , isExternal ) ; return entityHandle ; } public int addUnparsedEntityDecl ( int name , int publicId , int systemId , int notationName , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , notationName , isExternal ) ; if ( ! fEntityPool . isNotationDeclared ( notationName ) ) { Object [ ] args = { fStringPool . toString ( name ) , fStringPool . toString ( notationName ) } ; fEntityPool . addRequiredNotation ( notationName , fErrorReporter . getLocator ( ) , XMLMessages . MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL , XMLMessages . VC_NOTATION_DECLARED , args ) ; } return entityHandle ; } public int addNotationDecl ( int notationName , int publicId , int systemId , boolean isExternal ) throws Exception { int notationHandle = fEntityPool . addNotationDecl ( notationName , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , isExternal ) ; return notationHandle ; } public boolean isUnparsedEntity ( int entityName ) { int entityHandle = fEntityPool . lookupEntity ( entityName ) ; return ( entityHandle != - 1 && fEntityPool . isUnparsedEntity ( entityHandle ) ) ; } public boolean isNotationDeclared ( int notationName ) { return fEntityPool . isNotationDeclared ( notationName ) ; } public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { fEntityPool . addRequiredNotation ( notationName , locator , majorCode , minorCode , args ) ; } public void checkRequiredNotations ( ) throws Exception { fEntityPool . checkRequiredNotations ( ) ; } protected int lookupEntity ( int entityNameIndex ) { int entityIndex = fEntityPool . lookupEntity ( entityNameIndex ) ; return entityIndex ; } private void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } public boolean externalReferenceInContent ( int entityHandle ) throws Exception { boolean external = fEntityPool . isExternalEntity ( entityHandle ) ; if ( fEventHandler . externalEntityStandaloneCheck ( ) ) { if ( external ) { reportRecoverableXMLError ( XMLMessages . MSG_EXTERNAL_ENTITY_NOT_PERMITTED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } else if ( fEntityPool . getEntityDeclIsExternal ( entityHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } } return external ; } protected int valueOfReferenceInAttValue ( int entityHandle ) throws Exception { if ( fEventHandler . externalEntityStandaloneCheck ( ) && fEntityPool . getEntityDeclIsExternal ( entityHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } int entityValue = fEntityPool . getEntityValue ( entityHandle ) ; return entityValue ; } protected boolean isExternalEntity ( int entityHandle ) { boolean external = fEntityPool . isExternalEntity ( entityHandle ) ; return external ; } protected int getEntityValue ( int entityHandle ) { int value = fEntityPool . getEntityValue ( entityHandle ) ; return value ; } protected String getPublicIdOfEntity ( int entityHandle ) { int publicId = fEntityPool . getPublicId ( entityHandle ) ; return fStringPool . toString ( publicId ) ; } protected String getSystemIdOfEntity ( int entityHandle ) { int systemId = fEntityPool . getSystemId ( entityHandle ) ; return fStringPool . toString ( systemId ) ; } protected int lookupParameterEntity ( int peName ) throws Exception { int entityHandle = - 1 ; if ( fParameterEntityPool != null ) entityHandle = fParameterEntityPool . lookupEntity ( peName ) ; return entityHandle ; } protected boolean isExternalParameterEntity ( int peIndex ) { boolean external = fParameterEntityPool . isExternalEntity ( peIndex ) ; return external ; } protected int getParameterEntityValue ( int peIndex ) { int value = fParameterEntityPool . getEntityValue ( peIndex ) ; return value ; } protected String getPublicIdOfParameterEntity ( int peIndex ) { int publicId = fParameterEntityPool . getPublicId ( peIndex ) ; return fStringPool . toString ( publicId ) ; } protected String getSystemIdOfParameterEntity ( int peIndex ) { int systemId = fParameterEntityPool . getSystemId ( peIndex ) ; return fStringPool . toString ( systemId ) ; } public XMLEntityHandler . EntityReader getEntityReader ( ) { return fReader ; } public void addRecognizer ( XMLDeclRecognizer recognizer ) { fReaderFactory . addRecognizer ( recognizer ) ; } public void setEntityResolver ( EntityResolver resolver ) { fResolver = resolver ; } public EntityResolver getEntityResolver ( ) { return fResolver ; } public String expandSystemId ( String systemId ) { return expandSystemId ( systemId , fSystemId ) ; } private String expandSystemId ( String systemId , String currentSystemId ) { String id = systemId ; if ( id == null || id . length ( ) == 0 ) { return systemId ; } try { URI uri = new URI ( id ) ; if ( uri != null ) { return systemId ; } } catch ( URI . MalformedURIException e ) { } id = fixURI ( id ) ; URI base = null ; URI uri = null ; try { if ( currentSystemId == null ) { String dir ; try { dir = fixURI ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { dir = "" ; } if ( ! dir . endsWith ( "/" ) ) { dir = dir + "/" ; } base = new URI ( "file" , "" , dir , null , null ) ; } else { base = new URI ( currentSystemId ) ; } uri = new URI ( base , id ) ; } catch ( Exception e ) { } if ( uri == null ) { return systemId ; } return uri . toString ( ) ; } private static String fixURI ( String str ) { str = str . replace ( java . io . File . separatorChar , '/' ) ; if ( str . length ( ) >= 2 ) { char ch1 = str . charAt ( 1 ) ; if ( ch1 == ':' ) { char ch0 = Character . toUpperCase ( str . charAt ( 0 ) ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { str = "/" + str ; } } } return str ; } public boolean startReadingFromDocument ( InputSource source ) throws Exception { pushEntity ( false , - 2 ) ; fSystemId = null ; pushNullReader ( ) ; fEntityName = - 2 ; fEntityType = ENTITYTYPE_DOCUMENT ; fEntityContext = ENTITYREF_DOCUMENT ; fReaderDepth = 0 ; fReaderId = fNextReaderId ++ ; fPublicId = source . getPublicId ( ) ; fSystemId = source . getSystemId ( ) ; fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; fSystemId = expandSystemId ( fSystemId , null ) ; fSource = source ; boolean xmlDecl = true ; try { fReader = fReaderFactory . createReader ( this , fErrorReporter , source , fSystemId , xmlDecl , fStringPool ) ; } catch ( MalformedURLException mu ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( FileNotFoundException fnf ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( UnsupportedEncodingException uee ) { fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; String encoding = uee . getMessage ( ) ; if ( encoding == null ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_REQUIRED , XMLMessages . P81_REQUIRED , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else if ( ! XMLCharacterProperties . validEncName ( encoding ) ) { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_NOT_SUPPORTED , XMLMessages . P81_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; return fReader != null ; } public void startReadingFromExternalSubset ( String publicId , String systemId , int readerDepth ) throws Exception { pushEntity ( true , - 1 ) ; pushReader ( ) ; pushNullReader ( ) ; fEntityName = - 1 ; fEntityType = ENTITYTYPE_EXTERNAL_SUBSET ; fEntityContext = ENTITYREF_EXTERNAL_SUBSET ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; fPublicId = publicId ; fSystemId = systemId ; startReadingFromExternalEntity ( false , - 1 ) ; } public void stopReadingFromExternalSubset ( ) throws Exception { if ( ! ( fReader instanceof NullReader ) ) throw new RuntimeException ( "FWK004 cannot happen 18" + "\n18" ) ; popReader ( ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; } public boolean startReadingFromEntity ( int entityName , int readerDepth , int context ) throws Exception { if ( context > XMLEntityHandler . ENTITYREF_IN_CONTENT ) return startReadingFromParameterEntity ( entityName , readerDepth , context ) ; int entityHandle = lookupEntity ( entityName ) ; if ( entityHandle < 0 ) { int minorCode = XMLMessages . VC_ENTITY_DECLARED ; int errorType = XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ; if ( fEntityContext == ENTITYREF_DOCUMENT || fEntityContext == ENTITYREF_IN_ATTVALUE ) { minorCode = XMLMessages . WFC_ENTITY_DECLARED ; errorType = XMLErrorReporter . ERRORTYPE_FATAL_ERROR ; } else if ( ! fEventHandler . getValidating ( ) ) { return false ; } Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENTITY_NOT_DECLARED , minorCode , args , errorType ) ; return false ; } if ( context == ENTITYREF_IN_CONTENT ) { if ( fEntityPool . isUnparsedEntity ( entityHandle ) ) { Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REFERENCE_TO_UNPARSED_ENTITY , XMLMessages . WFC_PARSED_ENTITY , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } } else { if ( isExternalEntity ( entityHandle ) ) { Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REFERENCE_TO_EXTERNAL_ENTITY , XMLMessages . WFC_NO_EXTERNAL_ENTITY_REFERENCES , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } } if ( ! pushEntity ( false , entityName ) ) { Object [ ] args = { fStringPool . toString ( entityName ) , entityReferencePath ( false , entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_RECURSIVE_REFERENCE , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } pushReader ( ) ; fEntityName = entityName ; fEntityContext = context ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; if ( context != ENTITYREF_IN_CONTENT || ! externalReferenceInContent ( entityHandle ) ) { fEntityType = ENTITYTYPE_INTERNAL ; fPublicId = null ; fSystemId = fSystemId ; int value = - 1 ; if ( context == ENTITYREF_IN_CONTENT || context == ENTITYREF_IN_DEFAULTATTVALUE ) value = getEntityValue ( entityHandle ) ; else value = valueOfReferenceInAttValue ( entityHandle ) ; startReadingFromInternalEntity ( value , false ) ; return false ; } fEntityType = ENTITYTYPE_EXTERNAL ; fPublicId = getPublicIdOfEntity ( entityHandle ) ; fSystemId = getSystemIdOfEntity ( entityHandle ) ; return startReadingFromExternalEntity ( true , entityHandle ) ; } private boolean startReadingFromParameterEntity ( int peName , int readerDepth , int context ) throws Exception { int entityHandle = lookupParameterEntity ( peName ) ; if ( entityHandle == - 1 ) { if ( fEventHandler . getValidating ( ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ENTITY_NOT_DECLARED , XMLMessages . VC_ENTITY_DECLARED , peName ) ; } return false ; } if ( ! pushEntity ( true , peName ) ) { Object [ ] args = { fStringPool . toString ( peName ) , entityReferencePath ( true , peName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_RECURSIVE_PEREFERENCE , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } pushReader ( ) ; fEntityName = peName ; fEntityContext = context ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; if ( ! isExternalParameterEntity ( entityHandle ) ) { fEntityType = ENTITYTYPE_INTERNAL_PE ; fPublicId = null ; fSystemId = fSystemId ; int value = getParameterEntityValue ( entityHandle ) ; startReadingFromInternalEntity ( value , fEntityContext == ENTITYREF_IN_ENTITYVALUE ? false : true ) ; return false ; } fEntityType = ENTITYTYPE_EXTERNAL_PE ; fPublicId = getPublicIdOfParameterEntity ( entityHandle ) ; fSystemId = getSystemIdOfParameterEntity ( entityHandle ) ; return startReadingFromExternalEntity ( true , entityHandle ) ; } private void startReadingFromInternalEntity ( int value , boolean addSpaces ) throws Exception { if ( fEntityContext == ENTITYREF_IN_ENTITYVALUE ) { } fSource = null ; fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; fReader = fReaderFactory . createStringReader ( this , fErrorReporter , fSendCharDataAsCharArray , getLineNumber ( ) , getColumnNumber ( ) , value , fStringPool , addSpaces ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; } private boolean startReadingFromExternalEntity ( boolean checkForTextDecl , int entityHandle ) throws Exception { if ( fEntityContext == ENTITYREF_IN_ENTITYVALUE ) { } if ( fEntityContext == ENTITYREF_IN_DTD_WITHIN_MARKUP ) { } fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; String baseSystemId = null ; if ( entityHandle != - 1 ) { if ( fEntityType == ENTITYTYPE_EXTERNAL_PE ) baseSystemId = fParameterEntityPool . getBaseSystemId ( entityHandle ) ; else baseSystemId = fEntityPool . getBaseSystemId ( entityHandle ) ; } if ( baseSystemId == null ) { ReaderState rs = ( ReaderState ) fReaderStack . peek ( ) ; baseSystemId = rs . systemId ; } fSystemId = expandSystemId ( fSystemId , baseSystemId ) ; fSource = fResolver == null ? null : fResolver . resolveEntity ( fPublicId , fSystemId ) ; if ( fSource == null ) { fSource = new InputSource ( fSystemId ) ; if ( fPublicId != null ) fSource . setPublicId ( fPublicId ) ; } else { if ( fSource . getSystemId ( ) != null ) { fSystemId = expandSystemId ( fSource . getSystemId ( ) , baseSystemId ) ; } if ( fSource . getPublicId ( ) != null ) { fPublicId = fSource . getPublicId ( ) ; } } boolean textDecl = false ; try { fReader = fReaderFactory . createReader ( this , fErrorReporter , fSource , fSystemId , textDecl , fStringPool ) ; } catch ( MalformedURLException mu ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( FileNotFoundException fnf ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( UnsupportedEncodingException uee ) { fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; String encoding = uee . getMessage ( ) ; if ( encoding == null ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_REQUIRED , XMLMessages . P81_REQUIRED , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else if ( ! XMLCharacterProperties . validEncName ( encoding ) ) { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_NOT_SUPPORTED , XMLMessages . P81_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } if ( fReader == null || ! checkForTextDecl ) { fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; return false ; } int readerId = fReaderId ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; boolean parseTextDecl = fReader . lookingAtChar ( '<' , false ) ; if ( readerId != fReaderId ) parseTextDecl = false ; return parseTextDecl ; } private void pushNullReader ( ) { ReaderState rs = fReaderStateFreeList ; if ( rs == null ) rs = new ReaderState ( ) ; else fReaderStateFreeList = rs . nextReaderState ; if ( fNullReader == null ) fNullReader = new NullReader ( ) ; rs . reader = fNullReader ; rs . source = null ; rs . entityName = - 1 ; rs . entityType = - 1 ; rs . entityContext = - 1 ; rs . publicId = "Null Entity" ; rs . systemId = fSystemId ; rs . readerId = fNextReaderId ++ ; rs . depth = - 1 ; rs . nextReaderState = null ; fReaderStack . push ( rs ) ; } private void pushReader ( ) { ReaderState rs = fReaderStateFreeList ; if ( rs == null ) rs = new ReaderState ( ) ; else fReaderStateFreeList = rs . nextReaderState ; rs . reader = fReader ; rs . source = fSource ; rs . entityName = fEntityName ; rs . entityType = fEntityType ; rs . entityContext = fEntityContext ; rs . publicId = fPublicId ; rs . systemId = fSystemId ; rs . readerId = fReaderId ; rs . depth = fReaderDepth ; rs . nextReaderState = null ; fReaderStack . push ( rs ) ; } private void popReader ( ) { if ( fReaderStack . empty ( ) ) throw new RuntimeException ( "FWK004 cannot happen 19" + "\n19" ) ; ReaderState rs = ( ReaderState ) fReaderStack . pop ( ) ; fReader = rs . reader ; fSource = rs . source ; fEntityName = rs . entityName ; fEntityType = rs . entityType ; fEntityContext = rs . entityContext ; fPublicId = rs . publicId ; fSystemId = rs . systemId ; fReaderId = rs . readerId ; fReaderDepth = rs . depth ; rs . nextReaderState = fReaderStateFreeList ; fReaderStateFreeList = rs ; } public boolean startEntityDecl ( boolean isPE , int entityName ) throws Exception { if ( ! pushEntity ( isPE , entityName ) ) { int majorCode = isPE ? XMLMessages . MSG_RECURSIVE_PEREFERENCE : XMLMessages . MSG_RECURSIVE_REFERENCE ; Object [ ] args = { fStringPool . toString ( entityName ) , entityReferencePath ( isPE , entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } return true ; } public void endEntityDecl ( ) throws Exception { popEntity ( ) ; } private boolean pushEntity ( boolean isPE , int entityName ) throws Exception { if ( entityName >= 0 ) { for ( int i = 0 ; i < fEntityStackDepth ; i ++ ) { if ( fEntityNameStack [ i ] == entityName && fEntityTypeStack [ i ] == ( isPE ? 1 : 0 ) ) { return false ; } } } if ( fEntityTypeStack == null ) { fEntityTypeStack = new byte [ 8 ] ; fEntityNameStack = new int [ 8 ] ; } else if ( fEntityStackDepth == fEntityTypeStack . length ) { byte [ ] newTypeStack = new byte [ fEntityStackDepth * 2 ] ; System . arraycopy ( fEntityTypeStack , 0 , newTypeStack , 0 , fEntityStackDepth ) ; fEntityTypeStack = newTypeStack ; int [ ] newNameStack = new int [ fEntityStackDepth * 2 ] ; System . arraycopy ( fEntityNameStack , 0 , newNameStack , 0 , fEntityStackDepth ) ; fEntityNameStack = newNameStack ; } fEntityTypeStack [ fEntityStackDepth ] = ( byte ) ( isPE ? 1 : 0 ) ; fEntityNameStack [ fEntityStackDepth ] = entityName ; fEntityStackDepth ++ ; return true ; } private String entityReferencePath ( boolean isPE , int entityName ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "(top-level)" ) ; for ( int i = 0 ; i < fEntityStackDepth ; i ++ ) { if ( fEntityNameStack [ i ] >= 0 ) { sb . append ( '-' ) ; sb . append ( fEntityTypeStack [ i ] == 1 ? '%' : '&' ) ; sb . append ( fStringPool . toString ( fEntityNameStack [ i ] ) ) ; sb . append ( ';' ) ; } } sb . append ( '-' ) ; sb . append ( isPE ? '%' : '&' ) ; sb . append ( fStringPool . toString ( entityName ) ) ; sb . append ( ';' ) ; return sb . toString ( ) ; } private void popEntity ( ) throws Exception { fEntityStackDepth -- ; } public int getReaderId ( ) { return fReaderId ; } public void setReaderDepth ( int depth ) { fReaderDepth = depth ; } public int getReaderDepth ( ) { return fReaderDepth ; } public String getPublicId ( ) { return fPublicId ; } public String getSystemId ( ) { return fSystemId ; } public int getLineNumber ( ) { return fReader == null ? 0 : fReader . getLineNumber ( ) ; } public int getColumnNumber ( ) { return fReader == null ? 0 : fReader . getColumnNumber ( ) ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { fEventHandler . sendEndOfInputNotifications ( fEntityName , fReaderStack . size ( ) > 1 ) ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; popEntity ( ) ; return fReader ; } private final class NullReader implements XMLEntityHandler . EntityReader { public NullReader ( ) { } public int currentOffset ( ) { return - 1 ; } public int getLineNumber ( ) { return - 1 ; } public int getColumnNumber ( ) { return - 1 ; } public void setInCDSect ( boolean inCDSect ) { } public boolean getInCDSect ( ) { return false ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { } public int addString ( int offset , int length ) { return - 1 ; } public int addSymbol ( int offset , int length ) { return - 1 ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) { return false ; } public boolean lookingAtValidChar ( boolean skipPastChar ) { return false ; } public boolean lookingAtSpace ( boolean skipPastChar ) { return false ; } public void skipToChar ( char ch ) { } public void skipPastSpaces ( ) { } public void skipPastName ( char fastcheck ) { } public void skipPastNmtoken ( char fastcheck ) { } public boolean skippedString ( char [ ] s ) { return false ; } public int scanInvalidChar ( ) { return - 1 ; } public int scanCharRef ( boolean hex ) { return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } public int scanStringLiteral ( ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } public int scanAttValue ( char qchar , boolean asSymbol ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } public int scanEntityValue ( int qchar , boolean createString ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) { return false ; } public void scanQName ( char fastcheck , QName qname ) { qname . clear ( ) ; } public int scanName ( char fastcheck ) { return - 1 ; } public int scanContent ( QName element ) throws Exception { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } static final int CHUNK_SHIFT = 5 ; static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; static final int CHUNK_MASK = CHUNK_SIZE - 1 ; static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; public final class EntityPool { private StringPool fStringPool = null ; private XMLErrorReporter fErrorReporter = null ; private int fEntityCount = 0 ; private int [ ] [ ] fName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fValue = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fPublicId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fSystemId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fBaseSystemId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fNotationName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private byte [ ] [ ] fDeclIsExternal = new byte [ INITIAL_CHUNK_COUNT ] [ ] ; private int fNotationListHead = - 1 ; private boolean fCreateStandardEntities = false ; private Vector fRequiredNotations = null ; public EntityPool ( StringPool stringPool , XMLErrorReporter errorReporter , boolean createStandardEntities ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fCreateStandardEntities = createStandardEntities ; if ( fCreateStandardEntities ) { createInternalEntity ( "lt" , "&#60;" ) ; createInternalEntity ( "gt" , ">" ) ; createInternalEntity ( "amp" , "&#38;" ) ; createInternalEntity ( "apos" , "\'" ) ; createInternalEntity ( "quot" , "\"" ) ; } } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fEntityCount = 0 ; fNotationListHead = - 1 ; if ( fRequiredNotations != null ) fRequiredNotations . removeAllElements ( ) ; if ( fCreateStandardEntities ) { createInternalEntity ( "lt" , "&#60;" ) ; createInternalEntity ( "gt" , ">" ) ; createInternalEntity ( "amp" , "&#38;" ) ; createInternalEntity ( "apos" , "\'" ) ; createInternalEntity ( "quot" , "\"" ) ; } } private void createInternalEntity ( String name , String value ) { int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = fStringPool . addSymbol ( name ) ; fValue [ chunk ] [ index ] = fStringPool . addString ( value ) ; fPublicId [ chunk ] [ index ] = - 1 ; fSystemId [ chunk ] [ index ] = - 1 ; fBaseSystemId [ chunk ] [ index ] = - 1 ; fNotationName [ chunk ] [ index ] = - 1 ; fEntityCount ++ ; } private boolean ensureCapacity ( int chunk ) { try { return fName [ chunk ] [ 0 ] == 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { int [ ] [ ] newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fName , 0 , newIntArray , 0 , chunk ) ; fName = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fValue , 0 , newIntArray , 0 , chunk ) ; fValue = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fPublicId , 0 , newIntArray , 0 , chunk ) ; fPublicId = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fSystemId , 0 , newIntArray , 0 , chunk ) ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fBaseSystemId , 0 , newIntArray , 0 , chunk ) ; fBaseSystemId = newIntArray ; fSystemId = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fNotationName , 0 , newIntArray , 0 , chunk ) ; fNotationName = newIntArray ; byte [ ] [ ] newByteArray = new byte [ chunk * 2 ] [ ] ; System . arraycopy ( fDeclIsExternal , 0 , newByteArray , 0 , chunk ) ; fDeclIsExternal = newByteArray ; } catch ( NullPointerException ex ) { } fName [ chunk ] = new int [ CHUNK_SIZE ] ; fValue [ chunk ] = new int [ CHUNK_SIZE ] ; fPublicId [ chunk ] = new int [ CHUNK_SIZE ] ; fSystemId [ chunk ] = new int [ CHUNK_SIZE ] ; fBaseSystemId [ chunk ] = new int [ CHUNK_SIZE ] ; fNotationName [ chunk ] = new int [ CHUNK_SIZE ] ; fDeclIsExternal [ chunk ] = new byte [ CHUNK_SIZE ] ; return true ; } public int addEntityDecl ( int name , int value , int publicId , int systemId , int baseSystemId , int notationName , boolean isExternal ) { int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = name ; fValue [ chunk ] [ index ] = value ; fPublicId [ chunk ] [ index ] = publicId ; fSystemId [ chunk ] [ index ] = systemId ; fBaseSystemId [ chunk ] [ index ] = baseSystemId ; fNotationName [ chunk ] [ index ] = notationName ; fDeclIsExternal [ chunk ] [ index ] = isExternal ? ( byte ) 0x80 : ( byte ) 0 ; int entityIndex = fEntityCount ++ ; return entityIndex ; } public int addNotationDecl ( int notationName , int publicId , int systemId , int baseSystemId , boolean isExternal ) { int nIndex = fNotationListHead ; while ( nIndex != - 1 ) { int chunk = nIndex > > CHUNK_SHIFT ; int index = nIndex & CHUNK_MASK ; if ( fNotationName [ chunk ] [ index ] == notationName ) return - 1 ; nIndex = fValue [ chunk ] [ index ] ; } int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = - 1 ; fValue [ chunk ] [ index ] = fNotationListHead ; fPublicId [ chunk ] [ index ] = publicId ; fSystemId [ chunk ] [ index ] = systemId ; fBaseSystemId [ chunk ] [ index ] = baseSystemId ; fNotationName [ chunk ] [ index ] = notationName ; fDeclIsExternal [ chunk ] [ index ] = isExternal ? ( byte ) 0x80 : ( byte ) 0 ; fNotationListHead = fEntityCount ++ ; return fNotationListHead ; } public int lookupEntity ( int nameIndex ) { if ( nameIndex == - 1 ) return - 1 ; int chunk = 0 ; int index = 0 ; for ( int entityIndex = 0 ; entityIndex < fEntityCount ; entityIndex ++ ) { if ( fName [ chunk ] [ index ] == nameIndex ) return entityIndex ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } return - 1 ; } public boolean isExternalEntity ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fValue [ chunk ] [ index ] == - 1 ) ; } public boolean isUnparsedEntity ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fNotationName [ chunk ] [ index ] != - 1 ) ; } public boolean getEntityDeclIsExternal ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fDeclIsExternal [ chunk ] [ index ] < 0 ) ; } public int getEntityName ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fName [ chunk ] [ index ] ; } public int getEntityValue ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fValue [ chunk ] [ index ] ; } public int getPublicId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fPublicId [ chunk ] [ index ] ; } public int getSystemId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fSystemId [ chunk ] [ index ] ; } public String getBaseSystemId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; int baseIndex = fBaseSystemId [ chunk ] [ index ] ; if ( baseIndex == - 1 ) { return null ; } else { return fStringPool . toString ( baseIndex ) ; } } public boolean isNotationDeclared ( int nameIndex ) { int nIndex = fNotationListHead ; while ( nIndex != - 1 ) { int chunk = nIndex > > CHUNK_SHIFT ; int index = nIndex & CHUNK_MASK ; if ( fNotationName [ chunk ] [ index ] == nameIndex ) return true ; nIndex = fValue [ chunk ] [ index ] ; } return false ; } public boolean getNotationDeclIsExternal ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fDeclIsExternal [ chunk ] [ index ] < 0 ) ; } public int getNotationName ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fNotationName [ chunk ] [ index ] ; } class RequiredNotation { RequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { fNotationName = notationName ; fLocator = new LocatorImpl ( locator ) ; fMajorCode = majorCode ; fMinorCode = minorCode ; fArgs = args ; } int fNotationName ; LocatorImpl fLocator ; int fMajorCode ; int fMinorCode ; Object [ ] fArgs ; } ; public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { if ( fRequiredNotations == null ) fRequiredNotations = new Vector ( ) ; for ( int index = 0 ; index < fRequiredNotations . size ( ) ; index ++ ) { RequiredNotation rn = ( RequiredNotation ) fRequiredNotations . elementAt ( index ) ; if ( rn . fNotationName == notationName ) return ; } fRequiredNotations . addElement ( new RequiredNotation ( notationName , locator , majorCode , minorCode , args ) ) ; } public void checkRequiredNotations ( ) throws Exception { if ( fRequiredNotations == null ) return ; for ( int index = 0 ; index < fRequiredNotations . size ( ) ; index ++ ) { RequiredNotation rn = ( RequiredNotation ) fRequiredNotations . elementAt ( index ) ; if ( ! isNotationDeclared ( rn . fNotationName ) ) { fErrorReporter . reportError ( rn . fLocator , XMLMessages . XML_DOMAIN , rn . fMajorCode , rn . fMinorCode , rn . fArgs , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } 	1
package org . apache . xerces . utils ; public class QName { public int prefix ; public int localpart ; public int rawname ; public int uri ; public QName ( ) { clear ( ) ; } public QName ( int prefix , int localpart , int rawname ) { setValues ( prefix , localpart , rawname , - 1 ) ; } public QName ( int prefix , int localpart , int rawname , int uri ) { setValues ( prefix , localpart , rawname , uri ) ; } public QName ( QName qname ) { setValues ( qname ) ; } public void setValues ( QName qname ) { prefix = qname . prefix ; localpart = qname . localpart ; rawname = qname . rawname ; uri = qname . uri ; } public void setValues ( int prefix , int localpart , int rawname ) { setValues ( prefix , localpart , rawname , - 1 ) ; } public void setValues ( int prefix , int localpart , int rawname , int uri ) { this . prefix = prefix ; this . localpart = localpart ; this . rawname = rawname ; this . uri = uri ; } public void clear ( ) { prefix = - 1 ; localpart = - 1 ; rawname = - 1 ; uri = - 1 ; } public boolean equals ( Object object ) { if ( object != null && object instanceof QName ) { QName qname = ( QName ) object ; return prefix == qname . prefix && localpart == qname . localpart && rawname == qname . rawname && uri == qname . uri ; } return false ; } public int hashCode ( ) { return ( localpart << 16 ) | uri ; } public String toString ( ) { StringBuffer str = new StringBuffer ( ) ; str . append ( "prefix: " ) ; str . append ( prefix ) ; str . append ( ", " ) ; str . append ( "localpart: " ) ; str . append ( localpart ) ; str . append ( ", " ) ; str . append ( "rawname: " ) ; str . append ( rawname ) ; str . append ( ", " ) ; str . append ( "uri: " ) ; str . append ( uri ) ; return str . toString ( ) ; } } 	0
package org . w3c . dom ; public interface DOMImplementation { public boolean hasFeature ( String feature , String version ) ; public DocumentType createDocumentType ( String qualifiedName , String publicId , String systemId ) throws DOMException ; public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException ; } 	1
package org . apache . xerces . utils . regex ; import java . text . CharacterIterator ; public class RegularExpression implements java . io . Serializable { static final boolean DEBUG = false ; private synchronized void compile ( Token tok ) { if ( this . operations != null ) return ; this . numberOfClosures = 0 ; this . operations = this . compile ( tok , null , false ) ; } private Op compile ( Token tok , Op next , boolean reverse ) { Op ret ; switch ( tok . type ) { case Token . DOT : ret = Op . createDot ( ) ; ret . next = next ; break ; case Token . CHAR : ret = Op . createChar ( tok . getChar ( ) ) ; ret . next = next ; break ; case Token . ANCHOR : ret = Op . createAnchor ( tok . getChar ( ) ) ; ret . next = next ; break ; case Token . RANGE : case Token . NRANGE : ret = Op . createRange ( tok ) ; ret . next = next ; break ; case Token . CONCAT : ret = next ; if ( ! reverse ) { for ( int i = tok . size ( ) - 1 ; i >= 0 ; i -- ) { ret = compile ( tok . getChild ( i ) , ret , false ) ; } } else { for ( int i = 0 ; i < tok . size ( ) ; i ++ ) { ret = compile ( tok . getChild ( i ) , ret , true ) ; } } break ; case Token . UNION : Op . UnionOp uni = Op . createUnion ( tok . size ( ) ) ; for ( int i = 0 ; i < tok . size ( ) ; i ++ ) { uni . addElement ( compile ( tok . getChild ( i ) , next , reverse ) ) ; } ret = uni ; break ; case Token . CLOSURE : case Token . NONGREEDYCLOSURE : Token child = tok . getChild ( 0 ) ; int min = tok . getMin ( ) ; int max = tok . getMax ( ) ; if ( min >= 0 && min == max ) { ret = next ; for ( int i = 0 ; i < min ; i ++ ) { ret = compile ( child , ret , reverse ) ; } break ; } if ( min > 0 && max > 0 ) max -= min ; if ( max > 0 ) { ret = next ; for ( int i = 0 ; i < max ; i ++ ) { Op . ChildOp q = Op . createQuestion ( tok . type == Token . NONGREEDYCLOSURE ) ; q . next = next ; q . setChild ( compile ( child , ret , reverse ) ) ; ret = q ; } } else { Op . ChildOp op ; if ( tok . type == Token . NONGREEDYCLOSURE ) { op = Op . createNonGreedyClosure ( ) ; } else { if ( child . getMinLength ( ) == 0 ) op = Op . createClosure ( this . numberOfClosures ++ ) ; else op = Op . createClosure ( - 1 ) ; } op . next = next ; op . setChild ( compile ( child , op , reverse ) ) ; ret = op ; } if ( min > 0 ) { for ( int i = 0 ; i < min ; i ++ ) { ret = compile ( child , ret , reverse ) ; } } break ; case Token . EMPTY : ret = next ; break ; case Token . STRING : ret = Op . createString ( tok . getString ( ) ) ; ret . next = next ; break ; case Token . BACKREFERENCE : ret = Op . createBackReference ( tok . getReferenceNumber ( ) ) ; ret . next = next ; break ; case Token . PAREN : if ( tok . getParenNumber ( ) == 0 ) { ret = compile ( tok . getChild ( 0 ) , next , reverse ) ; } else if ( reverse ) { next = Op . createCapture ( tok . getParenNumber ( ) , next ) ; next = compile ( tok . getChild ( 0 ) , next , reverse ) ; ret = Op . createCapture ( - tok . getParenNumber ( ) , next ) ; } else { next = Op . createCapture ( - tok . getParenNumber ( ) , next ) ; next = compile ( tok . getChild ( 0 ) , next , reverse ) ; ret = Op . createCapture ( tok . getParenNumber ( ) , next ) ; } break ; case Token . LOOKAHEAD : ret = Op . createLook ( Op . LOOKAHEAD , next , compile ( tok . getChild ( 0 ) , null , false ) ) ; break ; case Token . NEGATIVELOOKAHEAD : ret = Op . createLook ( Op . NEGATIVELOOKAHEAD , next , compile ( tok . getChild ( 0 ) , null , false ) ) ; break ; case Token . LOOKBEHIND : ret = Op . createLook ( Op . LOOKBEHIND , next , compile ( tok . getChild ( 0 ) , null , true ) ) ; break ; case Token . NEGATIVELOOKBEHIND : ret = Op . createLook ( Op . NEGATIVELOOKBEHIND , next , compile ( tok . getChild ( 0 ) , null , true ) ) ; break ; case Token . INDEPENDENT : ret = Op . createIndependent ( next , compile ( tok . getChild ( 0 ) , null , reverse ) ) ; break ; case Token . MODIFIERGROUP : ret = Op . createModifier ( next , compile ( tok . getChild ( 0 ) , null , reverse ) , ( ( Token . ModifierToken ) tok ) . getOptions ( ) , ( ( Token . ModifierToken ) tok ) . getOptionsMask ( ) ) ; break ; case Token . CONDITION : Token . ConditionToken ctok = ( Token . ConditionToken ) tok ; int ref = ctok . refNumber ; Op condition = ctok . condition == null ? null : compile ( ctok . condition , null , reverse ) ; Op yes = compile ( ctok . yes , next , reverse ) ; Op no = ctok . no == null ? null : compile ( ctok . no , next , reverse ) ; ret = Op . createCondition ( next , ref , condition , yes , no ) ; break ; default : throw new RuntimeException ( "Unknown token type: " + tok . type ) ; } return ret ; } public boolean matches ( char [ ] target ) { return this . matches ( target , 0 , target . length , ( Match ) null ) ; } public boolean matches ( char [ ] target , int start , int end ) { return this . matches ( target , start , end , ( Match ) null ) ; } public boolean matches ( char [ ] target , Match match ) { return this . matches ( target , 0 , target . length , match ) ; } public boolean matches ( char [ ] target , int start , int end , Match match ) { synchronized ( this ) { if ( this . operations == null ) this . prepare ( ) ; if ( this . context == null ) this . context = new Context ( ) ; } Context con = null ; synchronized ( this . context ) { con = this . context . inuse ? new Context ( ) : this . context ; con . reset ( target , start , end , this . numberOfClosures ) ; } if ( match != null ) { match . setNumberOfGroups ( this . nofparen ) ; match . setSource ( target ) ; } else if ( this . hasBackReferences ) { match = new Match ( ) ; match . setNumberOfGroups ( this . nofparen ) ; } con . match = match ; if ( this . isSet ( this . options , XMLSCHEMA_MODE ) ) { int matchEnd = this . matchCharArray ( con , this . operations , con . start , 1 , this . options ) ; if ( matchEnd == con . limit ) { if ( con . match != null ) { con . match . setBeginning ( 0 , con . start ) ; con . match . setEnd ( 0 , matchEnd ) ; } con . inuse = false ; return true ; } return false ; } if ( this . fixedStringOnly ) { int o = this . fixedStringTable . matches ( target , con . start , con . limit ) ; if ( o >= 0 ) { if ( con . match != null ) { con . match . setBeginning ( 0 , o ) ; con . match . setEnd ( 0 , o + this . fixedString . length ( ) ) ; } con . inuse = false ; return true ; } con . inuse = false ; return false ; } if ( this . fixedString != null ) { int o = this . fixedStringTable . matches ( target , con . start , con . limit ) ; if ( o < 0 ) { con . inuse = false ; return false ; } } int limit = con . limit - this . minlength ; int matchStart ; int matchEnd = - 1 ; if ( this . operations != null && this . operations . type == Op . CLOSURE && this . operations . getChild ( ) . type == Op . DOT ) { if ( isSet ( this . options , SINGLE_LINE ) ) { matchStart = con . start ; matchEnd = this . matchCharArray ( con , this . operations , con . start , 1 , this . options ) ; } else { boolean previousIsEOL = true ; for ( matchStart = con . start ; matchStart <= limit ; matchStart ++ ) { int ch = target [ matchStart ] ; if ( isEOLChar ( ch ) ) { previousIsEOL = true ; } else { if ( previousIsEOL ) { if ( 0 <= ( matchEnd = this . matchCharArray ( con , this . operations , matchStart , 1 , this . options ) ) ) break ; } previousIsEOL = false ; } } } } else if ( this . firstChar != null ) { RangeToken range = this . firstChar ; if ( this . isSet ( this . options , IGNORE_CASE ) ) { range = this . firstChar . getCaseInsensitiveToken ( ) ; for ( matchStart = con . start ; matchStart <= limit ; matchStart ++ ) { int ch = target [ matchStart ] ; if ( REUtil . isHighSurrogate ( ch ) && matchStart + 1 < con . limit ) { ch = REUtil . composeFromSurrogates ( ch , target [ matchStart + 1 ] ) ; if ( ! range . match ( ch ) ) continue ; } else { if ( ! range . match ( ch ) ) { char ch1 = Character . toUpperCase ( ( char ) ch ) ; if ( ! range . match ( ch1 ) ) if ( ! range . match ( Character . toLowerCase ( ch1 ) ) ) continue ; } } if ( 0 <= ( matchEnd = this . matchCharArray ( con , this . operations , matchStart , 1 , this . options ) ) ) break ; } } else { for ( matchStart = con . start ; matchStart <= limit ; matchStart ++ ) { int ch = target [ matchStart ] ; if ( REUtil . isHighSurrogate ( ch ) && matchStart + 1 < con . limit ) ch = REUtil . composeFromSurrogates ( ch , target [ matchStart + 1 ] ) ; if ( ! range . match ( ch ) ) continue ; if ( 0 <= ( matchEnd = this . matchCharArray ( con , this . operations , matchStart , 1 , this . options ) ) ) break ; } } } else { for ( matchStart = con . start ; matchStart <= limit ; matchStart ++ ) { if ( 0 <= ( matchEnd = this . matchCharArray ( con , this . operations , matchStart , 1 , this . options ) ) ) break ; } } if ( matchEnd >= 0 ) { if ( con . match != null ) { con . match . setBeginning ( 0 , matchStart ) ; con . match . setEnd ( 0 , matchEnd ) ; } con . inuse = false ; return true ; } else { con . inuse = false ; return false ; } } private int matchCharArray ( Context con , Op op , int offset , int dx , int opts ) { char [ ] target = con . charTarget ; while ( true ) { if ( op == null ) return offset ; if ( offset > con . limit || offset < con . start ) return - 1 ; switch ( op . type ) { case Op . CHAR : if ( isSet ( opts , IGNORE_CASE ) ) { int ch = op . getData ( ) ; if ( dx > 0 ) { if ( offset >= con . limit || ! matchIgnoreCase ( ch , target [ offset ] ) ) return - 1 ; offset ++ ; } else { int o1 = offset - 1 ; if ( o1 >= con . limit || o1 < 0 || ! matchIgnoreCase ( ch , target [ o1 ] ) ) return - 1 ; offset = o1 ; } } else { int ch = op . getData ( ) ; if ( dx > 0 ) { if ( offset >= con . limit || ch != target [ offset ] ) return - 1 ; offset ++ ; } else { int o1 = offset - 1 ; if ( o1 >= con . limit || o1 < 0 || ch != target [ o1 ] ) return - 1 ; offset = o1 ; } } op = op . next ; break ; case Op . DOT : if ( dx > 0 ) { if ( offset >= con . limit ) return - 1 ; int ch = target [ offset ] ; if ( isSet ( opts , SINGLE_LINE ) ) { if ( REUtil . isHighSurrogate ( ch ) && offset + 1 < con . limit ) offset ++ ; } else { if ( REUtil . isHighSurrogate ( ch ) && offset + 1 < con . limit ) ch = REUtil . composeFromSurrogates ( ch , target [ ++ offset ] ) ; if ( isEOLChar ( ch ) ) return - 1 ; } offset ++ ; } else { int o1 = offset - 1 ; if ( o1 >= con . limit || o1 < 0 ) return - 1 ; int ch = target [ o1 ] ; if ( isSet ( opts , SINGLE_LINE ) ) { if ( REUtil . isLowSurrogate ( ch ) && o1 - 1 >= 0 ) o1 -- ; } else { if ( REUtil . isLowSurrogate ( ch ) && o1 - 1 >= 0 ) ch = REUtil . composeFromSurrogates ( target [ -- o1 ] , ch ) ; if ( ! isEOLChar ( ch ) ) return - 1 ; } offset = o1 ; } op = op . next ; break ; case Op . RANGE : case Op . NRANGE : if ( dx > 0 ) { if ( offset >= con . limit ) return - 1 ; int ch = target [ offset ] ; if ( REUtil . isHighSurrogate ( ch ) && offset + 1 < con . limit ) ch = REUtil . composeFromSurrogates ( ch , target [ ++ offset ] ) ; RangeToken tok = op . getToken ( ) ; if ( isSet ( opts , IGNORE_CASE ) ) { tok = tok . getCaseInsensitiveToken ( ) ; if ( ! tok . match ( ch ) ) { if ( ch >= 0x10000 ) return - 1 ; char uch ; if ( ! tok . match ( uch = Character . toUpperCase ( ( char ) ch ) ) && ! tok . match ( Character . toLowerCase ( uch ) ) ) return - 1 ; } } else { if ( ! tok . match ( ch ) ) return - 1 ; } offset ++ ; } else { int o1 = offset - 1 ; if ( o1 >= con . limit || o1 < 0 ) return - 1 ; int ch = target [ o1 ] ; if ( REUtil . isLowSurrogate ( ch ) && o1 - 1 >= 0 ) ch = REUtil . composeFromSurrogates ( target [ -- o1 ] , ch ) ; RangeToken tok = op . getToken ( ) ; if ( isSet ( opts , IGNORE_CASE ) ) { tok = tok . getCaseInsensitiveToken ( ) ; if ( ! tok . match ( ch ) ) { if ( ch >= 0x10000 ) return - 1 ; char uch ; if ( ! tok . match ( uch = Character . toUpperCase ( ( char ) ch ) ) && ! tok . match ( Character . toLowerCase ( uch ) ) ) return - 1 ; } } else { if ( ! tok . match ( ch ) ) return - 1 ; } offset = o1 ; } op = op . next ; break ; case Op . ANCHOR : boolean go = false ; switch ( op . getData ( ) ) { case '^' : if ( isSet ( opts , MULTIPLE_LINES ) ) { if ( ! ( offset == con . start || offset > con . start && isEOLChar ( target [ offset - 1 ] ) ) ) return - 1 ; } else { if ( offset != con . start ) return - 1 ; } break ; case '@' : if ( ! ( offset == con . start || offset > con . start && isEOLChar ( target [ offset - 1 ] ) ) ) return - 1 ; break ; case '$' : if ( isSet ( opts , MULTIPLE_LINES ) ) { if ( ! ( offset == con . limit || offset < con . limit && isEOLChar ( target [ offset ] ) ) ) return - 1 ; } else { if ( ! ( offset == con . limit || offset + 1 == con . limit && isEOLChar ( target [ offset ] ) || offset + 2 == con . limit && target [ offset ] == CARRIAGE_RETURN && target [ offset + 1 ] == LINE_FEED ) ) return - 1 ; } break ; case 'A' : if ( offset != con . start ) return - 1 ; break ; case 'Z' : if ( ! ( offset == con . limit || offset + 1 == con . limit && isEOLChar ( target [ offset ] ) || offset + 2 == con . limit && target [ offset ] == CARRIAGE_RETURN && target [ offset + 1 ] == LINE_FEED ) ) return - 1 ; break ; case 'z' : if ( offset != con . limit ) return - 1 ; break ; case 'b' : if ( con . length == 0 ) return - 1 ; { int after = getWordType ( target , con . start , con . limit , offset , opts ) ; if ( after == WT_IGNORE ) return - 1 ; int before = getPreviousWordType ( target , con . start , con . limit , offset , opts ) ; if ( after == before ) return - 1 ; } break ; case 'B' : if ( con . length == 0 ) go = true ; else { int after = getWordType ( target , con . start , con . limit , offset , opts ) ; go = after == WT_IGNORE || after == getPreviousWordType ( target , con . start , con . limit , offset , opts ) ; } if ( ! go ) return - 1 ; break ; case '<' : if ( con . length == 0 || offset == con . limit ) return - 1 ; if ( getWordType ( target , con . start , con . limit , offset , opts ) != WT_LETTER || getPreviousWordType ( target , con . start , con . limit , offset , opts ) != WT_OTHER ) return - 1 ; break ; case '>' : if ( con . length == 0 || offset == con . start ) return - 1 ; if ( getWordType ( target , con . start , con . limit , offset , opts ) != WT_OTHER || getPreviousWordType ( target , con . start , con . limit , offset , opts ) != WT_LETTER ) return - 1 ; break ; } op = op . next ; break ; case Op . BACKREFERENCE : { int refno = op . getData ( ) ; if ( refno <= 0 || refno >= this . nofparen ) throw new RuntimeException ( "Internal Error: Reference number must be more than zero: " + refno ) ; if ( con . match . getBeginning ( refno ) < 0 || con . match . getEnd ( refno ) < 0 ) return - 1 ; int o2 = con . match . getBeginning ( refno ) ; int literallen = con . match . getEnd ( refno ) - o2 ; if ( ! isSet ( opts , IGNORE_CASE ) ) { if ( dx > 0 ) { if ( ! regionMatches ( target , offset , con . limit , o2 , literallen ) ) return - 1 ; offset += literallen ; } else { if ( ! regionMatches ( target , offset - literallen , con . limit , o2 , literallen ) ) return - 1 ; offset -= literallen ; } } else { if ( dx > 0 ) { if ( ! regionMatchesIgnoreCase ( target , offset , con . limit , o2 , literallen ) ) return - 1 ; offset += literallen ; } else { if ( ! regionMatchesIgnoreCase ( target , offset - literallen , con . limit , o2 , literallen ) ) return - 1 ; offset -= literallen ; } } } op = op . next ; break ; case Op . STRING : { String literal = op . getString ( ) ; int literallen = literal . length ( ) ; if ( ! isSet ( opts , IGNORE_CASE ) ) { if ( dx > 0 ) { if ( ! regionMatches ( target , offset , con . limit , literal , literallen ) ) return - 1 ; offset += literallen ; } else { if ( ! regionMatches ( target , offset - literallen , con . limit , literal , literallen ) ) return - 1 ; offset -= literallen ; } } else { if ( dx > 0 ) { if ( ! regionMatchesIgnoreCase ( target , offset , con . limit , literal , literallen ) ) return - 1 ; offset += literallen ; } else { if ( ! regionMatchesIgnoreCase ( target , offset - literallen , con . limit , literal , literallen ) ) return - 1 ; offset -= literallen ; } } } op = op . next ; break ; case Op . CLOSURE : { int id = op . getData ( ) ; if ( id >= 0 ) { int previousOffset = con . offsets [ id ] ; if ( previousOffset < 0 || previousOffset != offset ) { con . offsets [ id ] = offset ; } else { con . offsets [ id ] = - 1 ; op = op . next ; break ; } } int ret = this . matchCharArray ( con , op . getChild ( ) , offset , dx , opts ) ; if ( id >= 0 ) con . offsets [ id ] = - 1 ; if ( ret >= 0 ) return ret ; op = op . next ; } break ; case Op . QUESTION : { int ret = this . matchCharArray ( con , op . getChild ( ) , offset , dx , opts ) ; if ( ret >= 0 ) return ret ; op = op . next ; } break ; case Op . NONGREEDYCLOSURE : case Op . NONGREEDYQUESTION : { int ret = this . matchCharArray ( con , op . next , offset , dx , opts ) ; if ( ret >= 0 ) return ret ; op = op . getChild ( ) ; } break ; case Op . UNION : for ( int i = 0 ; i < op . size ( ) ; i ++ ) { int ret = this . matchCharArray ( con , op . elementAt ( i ) , offset , dx , opts ) ; if ( ret >= 0 ) return ret ; } return - 1 ; case Op . CAPTURE : int refno = op . getData ( ) ; if ( con . match != null && refno > 0 ) { int save = con . match . getBeginning ( refno ) ; con . match . setBeginning ( refno , offset ) ; int ret = this . matchCharArray ( con , op . next , offset , dx , opts ) ; if ( ret < 0 ) con . match . setBeginning ( refno , save ) ; return ret ; } else if ( con . match != null && refno < 0 ) { int index = - refno ; int save = con . match . getEnd ( index ) ; con . match . setEnd ( index , offset ) ; int ret = this . matchCharArray ( con , op . next , offset , dx , opts ) ; if ( ret < 0 ) con . match . setEnd ( index , save ) ; return ret ; } op = op . next ; break ; case Op . LOOKAHEAD : if ( 0 > this . matchCharArray ( con , op . getChild ( ) , offset , 1 , opts ) ) return - 1 ; op = op . next ; break ; case Op . NEGATIVELOOKAHEAD : if ( 0 <= this . matchCharArray ( con , op . getChild ( ) , offset , 1 , opts ) ) return - 1 ; op = op . next ; break ; case Op . LOOKBEHIND : if ( 0 > this . matchCharArray ( con , op . getChild ( ) , offset , - 1 , opts ) ) return - 1 ; op = op . next ; break ; case Op . NEGATIVELOOKBEHIND : if ( 0 <= this . matchCharArray ( con , op . getChild ( ) , offset , - 1 , opts ) ) return - 1 ; op = op . next ; break ; case Op . INDEPENDENT : { int ret = this . matchCharArray ( con , op . getChild ( ) , offset , dx , opts ) ; if ( ret < 0 ) return ret ; offset = ret ; op = op . next ; } break ; case Op . MODIFIER : { int localopts = opts ; localopts |= op . getData ( ) ; localopts &= ~ op . getData2 ( ) ; int ret = this . matchCharArray ( con , op . getChild ( ) , offset , dx , localopts ) ; if ( ret < 0 ) return ret ; offset = ret ; op = op . next ; } break ; case Op . CONDITION : { Op . ConditionOp cop = ( Op . ConditionOp ) op ; boolean matchp = false ; if ( cop . refNumber > 0 ) { if ( cop . refNumber >= this . nofparen ) throw new RuntimeException ( "Internal Error: Reference number must be more than zero: " + cop . refNumber ) ; matchp = con . match . getBeginning ( cop . refNumber ) >= 0 && con . match . getEnd ( cop . refNumber ) >= 0 ; } else { matchp = 0 <= this . matchCharArray ( con , cop . condition , offset , dx , opts ) ; } if ( matchp ) { op = cop . yes ; } else if ( cop . no != null ) { op = cop . no ; } else { op = cop . next ; } } break ; default : throw new RuntimeException ( "Unknown operation type: " + op . type ) ; } } } private static final int getPreviousWordType ( char [ ] target , int begin , int end , int offset , int opts ) { int ret = getWordType ( target , begin , end , -- offset , opts ) ; while ( ret == WT_IGNORE ) ret = getWordType ( target , begin , end , -- offset , opts ) ; return ret ; } private static final int getWordType ( char [ ] target , int begin , int end , int offset , int opts ) { if ( offset < begin || offset >= end ) return WT_OTHER ; return getWordType0 ( target [ offset ] , opts ) ; } private static final boolean regionMatches ( char [ ] target , int offset , int limit , String part , int partlen ) { if ( offset < 0 ) return false ; if ( limit - offset < partlen ) return false ; int i = 0 ; while ( partlen -- > 0 ) { if ( target [ offset ++ ] != part . charAt ( i ++ ) ) return false ; } return true ; } private static final boolean regionMatches ( char [ ] target , int offset , int limit , int offset2 , int partlen ) { if ( offset < 0 ) return false ; if ( limit - offset < partlen ) return false ; int i = offset2 ; while ( partlen -- > 0 ) { if ( target [ offset ++ ] != target [ i ++ ] ) return false ; } return true ; } private static final boolean regionMatchesIgnoreCase ( char [ ] target , int offset , int limit , String part , int partlen ) { if ( offset < 0 ) return false ; if ( limit - offset < partlen ) return false ; int i = 0 ; while ( partlen -- > 0 ) { char ch1 = target [ offset ++ ] ; char ch2 = part . charAt ( i ++ ) ; if ( ch1 == ch2 ) continue ; char uch1 = Character . toUpperCase ( ch1 ) ; char uch2 = Character . toUpperCase ( ch2 ) ; if ( uch1 == uch2 ) continue ; if ( Character . toLowerCase ( uch1 ) != Character . toLowerCase ( uch2 ) ) return false ; } return true ; } private static final boolean regionMatchesIgnoreCase ( char [ ] target , int offset , int limit , int offset2 , int partlen ) { if ( offset < 0 ) return false ; if ( limit - offset < partlen ) return false ; int i = offset2 ; while ( partlen -- > 0 ) { char ch1 = target [ offset ++ ] ; char ch2 = target [ i ++ ] ; if ( ch1 == ch2 ) continue ; char uch1 = Character . toUpperCase ( ch1 ) ; char uch2 = Character . toUpperCase ( ch2 ) ; if ( uch1 == uch2 ) continue ; if ( Character . toLowerCase ( uch1 ) != Character . toLowerCase ( uch2 ) ) return false ; } return true ; } public boolean matches ( String target ) { return this . matches ( target , 0 , target . length ( ) , ( Match ) null ) ; } public boolean matches ( String target , int start , int end ) { return this . matches ( target , start , end , ( Match ) null ) ; } public boolean matches ( String target , Match match ) { return this . matches ( target , 0 , target . length ( ) , match ) ; } public boolean matches ( String target , int start , int end , Match match ) { synchronized ( this ) { if ( this . operations == null ) this . prepare ( ) ; if ( this . context == null ) this . context = new Context ( ) ; } Context con = null ; synchronized ( this . context ) { con = this . context . inuse ? new Context ( ) : this . context ; con . reset ( target , start , end , this . numberOfClosures ) ; } if ( match != null ) { match . setNumberOfGroups ( this . nofparen ) ; match . setSource ( target ) ; } else if ( this . hasBackReferences ) { match = new Match ( ) ; match . setNumberOfGroups ( this . nofparen ) ; } con . match = match ; if ( this . isSet ( this . options , XMLSCHEMA_MODE ) ) { int matchEnd = this . matchString ( con , this . operations , con . start , 1 , this . options ) ; if ( matchEnd == con . limit ) { if ( con . match != null ) { con . match . setBeginning ( 0 , con . start ) ; con . match . setEnd ( 0 , matchEnd ) ; } con . inuse = false ; return true ; } return false ; } if ( this . fixedStringOnly ) { int o = this . fixedStringTable . matches ( target , con . start , con . limit ) ; if ( o >= 0 ) { if ( con . match != null ) { con . match . setBeginning ( 0 , o ) ; con . match . setEnd ( 0 , o + this . fixedString . length ( ) ) ; } con . inuse = false ; return true ; } con . inuse = false ; return false ; } if ( this . fixedString != null ) { int o = this . fixedStringTable . matches ( target , con . start , con . limit ) ; if ( o < 0 ) { con . inuse = false ; return false ; } } int limit = con . limit - this . minlength ; int matchStart ; int matchEnd = - 1 ; if ( this . operations != null && this . operations . type == Op . CLOSURE && this . operations . getChild ( ) . type == Op . DOT ) { if ( isSet ( this . options , SINGLE_LINE ) ) { matchStart = con . start ; matchEnd = this . matchString ( con , this . operations , con . start , 1 , this . options ) ; } else { boolean previousIsEOL = true ; for ( matchStart = con . start ; matchStart <= limit ; matchStart ++ ) { int ch = target . charAt ( matchStart ) ; if ( isEOLChar ( ch ) ) { previousIsEOL = true ; } else { if ( previousIsEOL ) { if ( 0 <= ( matchEnd = this . matchString ( con , this . operations , matchStart , 1 , this . options ) ) ) break ; } previousIsEOL = false ; } } } } else if ( this . firstChar != null ) { RangeToken range = this . firstChar ; if ( this . isSet ( this . options , IGNORE_CASE ) ) { range = this . firstChar . getCaseInsensitiveToken ( ) ; for ( matchStart = con . start ; matchStart <= limit ; matchStart ++ ) { int ch = target . charAt ( matchStart ) ; if ( REUtil . isHighSurrogate ( ch ) && matchStart + 1 < con . limit ) { ch = REUtil . composeFromSurrogates ( ch , target . charAt ( matchStart + 1 ) ) ; if ( ! range . match ( ch ) ) continue ; } else { if ( ! range . match ( ch ) ) { char ch1 = Character . toUpperCase ( ( char ) ch ) ; if ( ! range . match ( ch1 ) ) if ( ! range . match ( Character . toLowerCase ( ch1 ) ) ) continue ; } } if ( 0 <= ( matchEnd = this . matchString ( con , this . operations , matchStart , 1 , this . options ) ) ) break ; } } else { for ( matchStart = con . start ; matchStart <= limit ; matchStart ++ ) { int ch = target . charAt ( matchStart ) ; if ( REUtil . isHighSurrogate ( ch ) && matchStart + 1 < con . limit ) ch = REUtil . composeFromSurrogates ( ch , target . charAt ( matchStart + 1 ) ) ; if ( ! range . match ( ch ) ) continue ; if ( 0 <= ( matchEnd = this . matchString ( con , this . operations , matchStart , 1 , this . options ) ) ) break ; } } } else { for ( matchStart = con . start ; matchStart <= limit ; matchStart ++ ) { if ( 0 <= ( matchEnd = this . matchString ( con , this . operations , matchStart , 1 , this . options ) ) ) break ; } } if ( matchEnd >= 0 ) { if ( con . match != null ) { con . match . setBeginning ( 0 , matchStart ) ; con . match . setEnd ( 0 , matchEnd ) ; } con . inuse = false ; return true ; } else { con . inuse = false ; return false ; } } private int matchString ( Context con , Op op , int offset , int dx , int opts ) { String target = con . strTarget ; while ( true ) { if ( op == null ) return offset ; if ( offset > con . limit || offset < con . start ) return - 1 ; switch ( op . type ) { case Op . CHAR : if ( isSet ( opts , IGNORE_CASE ) ) { int ch = op . getData ( ) ; if ( dx > 0 ) { if ( offset >= con . limit || ! matchIgnoreCase ( ch , target . charAt ( offset ) ) ) return - 1 ; offset ++ ; } else { int o1 = offset - 1 ; if ( o1 >= con . limit || o1 < 0 || ! matchIgnoreCase ( ch , target . charAt ( o1 ) ) ) return - 1 ; offset = o1 ; } } else { int ch = op . getData ( ) ; if ( dx > 0 ) { if ( offset >= con . limit || ch != target . charAt ( offset ) ) return - 1 ; offset ++ ; } else { int o1 = offset - 1 ; if ( o1 >= con . limit || o1 < 0 || ch != target . charAt ( o1 ) ) return - 1 ; offset = o1 ; } } op = op . next ; break ; case Op . DOT : if ( dx > 0 ) { if ( offset >= con . limit ) return - 1 ; int ch = target . charAt ( offset ) ; if ( isSet ( opts , SINGLE_LINE ) ) { if ( REUtil . isHighSurrogate ( ch ) && offset + 1 < con . limit ) offset ++ ; } else { if ( REUtil . isHighSurrogate ( ch ) && offset + 1 < con . limit ) ch = REUtil . composeFromSurrogates ( ch , target . charAt ( ++ offset ) ) ; if ( isEOLChar ( ch ) ) return - 1 ; } offset ++ ; } else { int o1 = offset - 1 ; if ( o1 >= con . limit || o1 < 0 ) return - 1 ; int ch = target . charAt ( o1 ) ; if ( isSet ( opts , SINGLE_LINE ) ) { if ( REUtil . isLowSurrogate ( ch ) && o1 - 1 >= 0 ) o1 -- ; } else { if ( REUtil . isLowSurrogate ( ch ) && o1 - 1 >= 0 ) ch = REUtil . composeFromSurrogates ( target . charAt ( -- o1 ) , ch ) ; if ( ! isEOLChar ( ch ) ) return - 1 ; } offset = o1 ; } op = op . next ; break ; case Op . RANGE : case Op . NRANGE : if ( dx > 0 ) { if ( offset >= con . limit ) return - 1 ; int ch = target . charAt ( offset ) ; if ( REUtil . isHighSurrogate ( ch ) && offset + 1 < con . limit ) ch = REUtil . composeFromSurrogates ( ch , target . charAt ( ++ offset ) ) ; RangeToken tok = op . getToken ( ) ; if ( isSet ( opts , IGNORE_CASE ) ) { tok = tok . getCaseInsensitiveToken ( ) ; if ( ! tok . match ( ch ) ) { if ( ch >= 0x10000 ) return - 1 ; char uch ; if ( ! tok . match ( uch = Character . toUpperCase ( ( char ) ch ) ) && ! tok . match ( Character . toLowerCase ( uch ) ) ) return - 1 ; } } else { if ( ! tok . match ( ch ) ) return - 1 ; } offset ++ ; } else { int o1 = offset - 1 ; if ( o1 >= con . limit || o1 < 0 ) return - 1 ; int ch = target . charAt ( o1 ) ; if ( REUtil . isLowSurrogate ( ch ) && o1 - 1 >= 0 ) ch = REUtil . composeFromSurrogates ( target . charAt ( -- o1 ) , ch ) ; RangeToken tok = op . getToken ( ) ; if ( isSet ( opts , IGNORE_CASE ) ) { tok = tok . getCaseInsensitiveToken ( ) ; if ( ! tok . match ( ch ) ) { if ( ch >= 0x10000 ) return - 1 ; char uch ; if ( ! tok . match ( uch = Character . toUpperCase ( ( char ) ch ) ) && ! tok . match ( Character . toLowerCase ( uch ) ) ) return - 1 ; } } else { if ( ! tok . match ( ch ) ) return - 1 ; } offset = o1 ; } op = op . next ; break ; case Op . ANCHOR : boolean go = false ; switch ( op . getData ( ) ) { case '^' : if ( isSet ( opts , MULTIPLE_LINES ) ) { if ( ! ( offset == con . start || offset > con . start && isEOLChar ( target . charAt ( offset - 1 ) ) ) ) return - 1 ; } else { if ( offset != con . start ) return - 1 ; } break ; case '@' : if ( ! ( offset == con . start || offset > con . start && isEOLChar ( target . charAt ( offset - 1 ) ) ) ) return - 1 ; break ; case '$' : if ( isSet ( opts , MULTIPLE_LINES ) ) { if ( ! ( offset == con . limit || offset < con . limit && isEOLChar ( target . charAt ( offset ) ) ) ) return - 1 ; } else { if ( ! ( offset == con . limit || offset + 1 == con . limit && isEOLChar ( target . charAt ( offset ) ) || offset + 2 == con . limit && target . charAt ( offset ) == CARRIAGE_RETURN && target . charAt ( offset + 1 ) == LINE_FEED ) ) return - 1 ; } break ; case 'A' : if ( offset != con . start ) return - 1 ; break ; case 'Z' : if ( ! ( offset == con . limit || offset + 1 == con . limit && isEOLChar ( target . charAt ( offset ) ) || offset + 2 == con . limit && target . charAt ( offset ) == CARRIAGE_RETURN && target . charAt ( offset + 1 ) == LINE_FEED ) ) return - 1 ; break ; case 'z' : if ( offset != con . limit ) return - 1 ; break ; case 'b' : if ( con . length == 0 ) return - 1 ; { int after = getWordType ( target , con . start , con . limit , offset , opts ) ; if ( after == WT_IGNORE ) return - 1 ; int before = getPreviousWordType ( target , con . start , con . limit , offset , opts ) ; if ( after == before ) return - 1 ; } break ; case 'B' : if ( con . length == 0 ) go = true ; else { int after = getWordType ( target , con . start , con . limit , offset , opts ) ; go = after == WT_IGNORE || after == getPreviousWordType ( target , con . start , con . limit , offset , opts ) ; } if ( ! go ) return - 1 ; break ; case '<' : if ( con . length == 0 || offset == con . limit ) return - 1 ; if ( getWordType ( target , con . start , con . limit , offset , opts ) != WT_LETTER || getPreviousWordType ( target , con . start , con . limit , offset , opts ) != WT_OTHER ) return - 1 ; break ; case '>' : if ( con . length == 0 || offset == con . start ) return - 1 ; if ( getWordType ( target , con . start , con . limit , offset , opts ) != WT_OTHER || getPreviousWordType ( target , con . start , con . limit , offset , opts ) != WT_LETTER ) return - 1 ; break ; } op = op . next ; break ; case Op . BACKREFERENCE : { int refno = op . getData ( ) ; if ( refno <= 0 || refno >= this . nofparen ) throw new RuntimeException ( "Internal Error: Reference number must be more than zero: " + refno ) ; if ( con . match . getBeginning ( refno ) < 0 || con . match . getEnd ( refno ) < 0 ) return - 1 ; int o2 = con . match . getBeginning ( refno ) ; int literallen = con . match . getEnd ( refno ) - o2 ; if ( ! isSet ( opts , IGNORE_CASE ) ) { if ( dx > 0 ) { if ( ! regionMatches ( target , offset , con . limit , o2 , literallen ) ) return - 1 ; offset += literallen ; } else { if ( ! regionMatches ( target , offset - literallen , con . limit , o2 , literallen ) ) return - 1 ; offset -= literallen ; } } else { if ( dx > 0 ) { if ( ! regionMatchesIgnoreCase ( target , offset , con . limit , o2 , literallen ) ) return - 1 ; offset += literallen ; } else { if ( ! regionMatchesIgnoreCase ( target , offset - literallen , con . limit , o2 , literallen ) ) return - 1 ; offset -= literallen ; } } } op = op . next ; break ; case Op . STRING : { String literal = op . getString ( ) ; int literallen = literal . length ( ) ; if ( ! isSet ( opts , IGNORE_CASE ) ) { if ( dx > 0 ) { if ( ! regionMatches ( target , offset , con . limit , literal , literallen ) ) return - 1 ; offset += literallen ; } else { if ( ! regionMatches ( target , offset - literallen , con . limit , literal , literallen ) ) return - 1 ; offset -= literallen ; } } else { if ( dx > 0 ) { if ( ! regionMatchesIgnoreCase ( target , offset , con . limit , literal , literallen ) ) return - 1 ; offset += literallen ; } else { if ( ! regionMatchesIgnoreCase ( target , offset - literallen , con . limit , literal , literallen ) ) return - 1 ; offset -= literallen ; } } } op = op . next ; break ; case Op . CLOSURE : { int id = op . getData ( ) ; if ( id >= 0 ) { int previousOffset = con . offsets [ id ] ; if ( previousOffset < 0 || previousOffset != offset ) { con . offsets [ id ] = offset ; } else { con . offsets [ id ] = - 1 ; op = op . next ; break ; } } int ret = this . matchString ( con , op . getChild ( ) , offset , dx , opts ) ; if ( id >= 0 ) con . offsets [ id ] = - 1 ; if ( ret >= 0 ) return ret ; op = op . next ; } break ; case Op . QUESTION : { int ret = this . matchString ( con , op . getChild ( ) , offset , dx , opts ) ; if ( ret >= 0 ) return ret ; op = op . next ; } break ; case Op . NONGREEDYCLOSURE : case Op . NONGREEDYQUESTION : { int ret = this . matchString ( con , op . next , offset , dx , opts ) ; if ( ret >= 0 ) return ret ; op = op . getChild ( ) ; } break ; case Op . UNION : for ( int i = 0 ; i < op . size ( ) ; i ++ ) { int ret = this . matchString ( con , op . elementAt ( i ) , offset , dx , opts ) ; if ( ret >= 0 ) return ret ; } return - 1 ; case Op . CAPTURE : int refno = op . getData ( ) ; if ( con . match != null && refno > 0 ) { int save = con . match . getBeginning ( refno ) ; con . match . setBeginning ( refno , offset ) ; int ret = this . matchString ( con , op . next , offset , dx , opts ) ; if ( ret < 0 ) con . match . setBeginning ( refno , save ) ; return ret ; } else if ( con . match != null && refno < 0 ) { int index = - refno ; int save = con . match . getEnd ( index ) ; con . match . setEnd ( index , offset ) ; int ret = this . matchString ( con , op . next , offset , dx , opts ) ; if ( ret < 0 ) con . match . setEnd ( index , save ) ; return ret ; } op = op . next ; break ; case Op . LOOKAHEAD : if ( 0 > this . matchString ( con , op . getChild ( ) , offset , 1 , opts ) ) return - 1 ; op = op . next ; break ; case Op . NEGATIVELOOKAHEAD : if ( 0 <= this . matchString ( con , op . getChild ( ) , offset , 1 , opts ) ) return - 1 ; op = op . next ; break ; case Op . LOOKBEHIND : if ( 0 > this . matchString ( con , op . getChild ( ) , offset , - 1 , opts ) ) return - 1 ; op = op . next ; break ; case Op . NEGATIVELOOKBEHIND : if ( 0 <= this . matchString ( con , op . getChild ( ) , offset , - 1 , opts ) ) return - 1 ; op = op . next ; break ; case Op . INDEPENDENT : { int ret = this . matchString ( con , op . getChild ( ) , offset , dx , opts ) ; if ( ret < 0 ) return ret ; offset = ret ; op = op . next ; } break ; case Op . MODIFIER : { int localopts = opts ; localopts |= op . getData ( ) ; localopts &= ~ op . getData2 ( ) ; int ret = this . matchString ( con , op . getChild ( ) , offset , dx , localopts ) ; if ( ret < 0 ) return ret ; offset = ret ; op = op . next ; } break ; case Op . CONDITION : { Op . ConditionOp cop = ( Op . ConditionOp ) op ; boolean matchp = false ; if ( cop . refNumber > 0 ) { if ( cop . refNumber >= this . nofparen ) throw new RuntimeException ( "Internal Error: Reference number must be more than zero: " + cop . refNumber ) ; matchp = con . match . getBeginning ( cop . refNumber ) >= 0 && con . match . getEnd ( cop . refNumber ) >= 0 ; } else { matchp = 0 <= this . matchString ( con , cop . condition , offset , dx , opts ) ; } if ( matchp ) { op = cop . yes ; } else if ( cop . no != null ) { op = cop . no ; } else { op = cop . next ; } } break ; default : throw new RuntimeException ( "Unknown operation type: " + op . type ) ; } } } private static final int getPreviousWordType ( String target , int begin , int end , int offset , int opts ) { int ret = getWordType ( target , begin , end , -- offset , opts ) ; while ( ret == WT_IGNORE ) ret = getWordType ( target , begin , end , -- offset , opts ) ; return ret ; } private static final int getWordType ( String target , int begin , int end , int offset , int opts ) { if ( offset < begin || offset >= end ) return WT_OTHER ; return getWordType0 ( target . charAt ( offset ) , opts ) ; } private static final boolean regionMatches ( String text , int offset , int limit , String part , int partlen ) { if ( limit - offset < partlen ) return false ; return text . regionMatches ( offset , part , 0 , partlen ) ; } private static final boolean regionMatches ( String text , int offset , int limit , int offset2 , int partlen ) { if ( limit - offset < partlen ) return false ; return text . regionMatches ( offset , text , offset2 , partlen ) ; } private static final boolean regionMatchesIgnoreCase ( String text , int offset , int limit , String part , int partlen ) { return text . regionMatches ( true , offset , part , 0 , partlen ) ; } private static final boolean regionMatchesIgnoreCase ( String text , int offset , int limit , int offset2 , int partlen ) { if ( limit - offset < partlen ) return false ; return text . regionMatches ( true , offset , text , offset2 , partlen ) ; } public boolean matches ( CharacterIterator target ) { return this . matches ( target , ( Match ) null ) ; } public boolean matches ( CharacterIterator target , Match match ) { int start = target . getBeginIndex ( ) ; int end = target . getEndIndex ( ) ; synchronized ( this ) { if ( this . operations == null ) this . prepare ( ) ; if ( this . context == null ) this . context = new Context ( ) ; } Context con = null ; synchronized ( this . context ) { con = this . context . inuse ? new Context ( ) : this . context ; con . reset ( target , start , end , this . numberOfClosures ) ; } if ( match != null ) { match . setNumberOfGroups ( this . nofparen ) ; match . setSource ( target ) ; } else if ( this . hasBackReferences ) { match = new Match ( ) ; match . setNumberOfGroups ( this . nofparen ) ; } con . match = match ; if ( this . isSet ( this . options , XMLSCHEMA_MODE ) ) { int matchEnd = this . matchCharacterIterator ( con , this . operations , con . start , 1 , this . options ) ; if ( matchEnd == con . limit ) { if ( con . match != null ) { con . match . setBeginning ( 0 , con . start ) ; con . match . setEnd ( 0 , matchEnd ) ; } con . inuse = false ; return true ; } return false ; } if ( this . fixedStringOnly ) { int o = this . fixedStringTable . matches ( target , con . start , con . limit ) ; if ( o >= 0 ) { if ( con . match != null ) { con . match . setBeginning ( 0 , o ) ; con . match . setEnd ( 0 , o + this . fixedString . length ( ) ) ; } con . inuse = false ; return true ; } con . inuse = false ; return false ; } if ( this . fixedString != null ) { int o = this . fixedStringTable . matches ( target , con . start , con . limit ) ; if ( o < 0 ) { con . inuse = false ; return false ; } } int limit = con . limit - this . minlength ; int matchStart ; int matchEnd = - 1 ; if ( this . operations != null && this . operations . type == Op . CLOSURE && this . operations . getChild ( ) . type == Op . DOT ) { if ( isSet ( this . options , SINGLE_LINE ) ) { matchStart = con . start ; matchEnd = this . matchCharacterIterator ( con , this . operations , con . start , 1 , this . options ) ; } else { boolean previousIsEOL = true ; for ( matchStart = con . start ; matchStart <= limit ; matchStart ++ ) { int ch = target . setIndex ( matchStart ) ; if ( isEOLChar ( ch ) ) { previousIsEOL = true ; } else { if ( previousIsEOL ) { if ( 0 <= ( matchEnd = this . matchCharacterIterator ( con , this . operations , matchStart , 1 , this . options ) ) ) break ; } previousIsEOL = false ; } } } } else if ( this . firstChar != null ) { RangeToken range = this . firstChar ; if ( this . isSet ( this . options , IGNORE_CASE ) ) { range = this . firstChar . getCaseInsensitiveToken ( ) ; for ( matchStart = con . start ; matchStart <= limit ; matchStart ++ ) { int ch = target . setIndex ( matchStart ) ; if ( REUtil . isHighSurrogate ( ch ) && matchStart + 1 < con . limit ) { ch = REUtil . composeFromSurrogates ( ch , target . setIndex ( matchStart + 1 ) ) ; if ( ! range . match ( ch ) ) continue ; } else { if ( ! range . match ( ch ) ) { char ch1 = Character . toUpperCase ( ( char ) ch ) ; if ( ! range . match ( ch1 ) ) if ( ! range . match ( Character . toLowerCase ( ch1 ) ) ) continue ; } } if ( 0 <= ( matchEnd = this . matchCharacterIterator ( con , this . operations , matchStart , 1 , this . options ) ) ) break ; } } else { for ( matchStart = con . start ; matchStart <= limit ; matchStart ++ ) { int ch = target . setIndex ( matchStart ) ; if ( REUtil . isHighSurrogate ( ch ) && matchStart + 1 < con . limit ) ch = REUtil . composeFromSurrogates ( ch , target . setIndex ( matchStart + 1 ) ) ; if ( ! range . match ( ch ) ) continue ; if ( 0 <= ( matchEnd = this . matchCharacterIterator ( con , this . operations , matchStart , 1 , this . options ) ) ) break ; } } } else { for ( matchStart = con . start ; matchStart <= limit ; matchStart ++ ) { if ( 0 <= ( matchEnd = this . matchCharacterIterator ( con , this . operations , matchStart , 1 , this . options ) ) ) break ; } } if ( matchEnd >= 0 ) { if ( con . match != null ) { con . match . setBeginning ( 0 , matchStart ) ; con . match . setEnd ( 0 , matchEnd ) ; } con . inuse = false ; return true ; } else { con . inuse = false ; return false ; } } private int matchCharacterIterator ( Context con , Op op , int offset , int dx , int opts ) { CharacterIterator target = con . ciTarget ; while ( true ) { if ( op == null ) return offset ; if ( offset > con . limit || offset < con . start ) return - 1 ; switch ( op . type ) { case Op . CHAR : if ( isSet ( opts , IGNORE_CASE ) ) { int ch = op . getData ( ) ; if ( dx > 0 ) { if ( offset >= con . limit || ! matchIgnoreCase ( ch , target . setIndex ( offset ) ) ) return - 1 ; offset ++ ; } else { int o1 = offset - 1 ; if ( o1 >= con . limit || o1 < 0 || ! matchIgnoreCase ( ch , target . setIndex ( o1 ) ) ) return - 1 ; offset = o1 ; } } else { int ch = op . getData ( ) ; if ( dx > 0 ) { if ( offset >= con . limit || ch != target . setIndex ( offset ) ) return - 1 ; offset ++ ; } else { int o1 = offset - 1 ; if ( o1 >= con . limit || o1 < 0 || ch != target . setIndex ( o1 ) ) return - 1 ; offset = o1 ; } } op = op . next ; break ; case Op . DOT : if ( dx > 0 ) { if ( offset >= con . limit ) return - 1 ; int ch = target . setIndex ( offset ) ; if ( isSet ( opts , SINGLE_LINE ) ) { if ( REUtil . isHighSurrogate ( ch ) && offset + 1 < con . limit ) offset ++ ; } else { if ( REUtil . isHighSurrogate ( ch ) && offset + 1 < con . limit ) ch = REUtil . composeFromSurrogates ( ch , target . setIndex ( ++ offset ) ) ; if ( isEOLChar ( ch ) ) return - 1 ; } offset ++ ; } else { int o1 = offset - 1 ; if ( o1 >= con . limit || o1 < 0 ) return - 1 ; int ch = target . setIndex ( o1 ) ; if ( isSet ( opts , SINGLE_LINE ) ) { if ( REUtil . isLowSurrogate ( ch ) && o1 - 1 >= 0 ) o1 -- ; } else { if ( REUtil . isLowSurrogate ( ch ) && o1 - 1 >= 0 ) ch = REUtil . composeFromSurrogates ( target . setIndex ( -- o1 ) , ch ) ; if ( ! isEOLChar ( ch ) ) return - 1 ; } offset = o1 ; } op = op . next ; break ; case Op . RANGE : case Op . NRANGE : if ( dx > 0 ) { if ( offset >= con . limit ) return - 1 ; int ch = target . setIndex ( offset ) ; if ( REUtil . isHighSurrogate ( ch ) && offset + 1 < con . limit ) ch = REUtil . composeFromSurrogates ( ch , target . setIndex ( ++ offset ) ) ; RangeToken tok = op . getToken ( ) ; if ( isSet ( opts , IGNORE_CASE ) ) { tok = tok . getCaseInsensitiveToken ( ) ; if ( ! tok . match ( ch ) ) { if ( ch >= 0x10000 ) return - 1 ; char uch ; if ( ! tok . match ( uch = Character . toUpperCase ( ( char ) ch ) ) && ! tok . match ( Character . toLowerCase ( uch ) ) ) return - 1 ; } } else { if ( ! tok . match ( ch ) ) return - 1 ; } offset ++ ; } else { int o1 = offset - 1 ; if ( o1 >= con . limit || o1 < 0 ) return - 1 ; int ch = target . setIndex ( o1 ) ; if ( REUtil . isLowSurrogate ( ch ) && o1 - 1 >= 0 ) ch = REUtil . composeFromSurrogates ( target . setIndex ( -- o1 ) , ch ) ; RangeToken tok = op . getToken ( ) ; if ( isSet ( opts , IGNORE_CASE ) ) { tok = tok . getCaseInsensitiveToken ( ) ; if ( ! tok . match ( ch ) ) { if ( ch >= 0x10000 ) return - 1 ; char uch ; if ( ! tok . match ( uch = Character . toUpperCase ( ( char ) ch ) ) && ! tok . match ( Character . toLowerCase ( uch ) ) ) return - 1 ; } } else { if ( ! tok . match ( ch ) ) return - 1 ; } offset = o1 ; } op = op . next ; break ; case Op . ANCHOR : boolean go = false ; switch ( op . getData ( ) ) { case '^' : if ( isSet ( opts , MULTIPLE_LINES ) ) { if ( ! ( offset == con . start || offset > con . start && isEOLChar ( target . setIndex ( offset - 1 ) ) ) ) return - 1 ; } else { if ( offset != con . start ) return - 1 ; } break ; case '@' : if ( ! ( offset == con . start || offset > con . start && isEOLChar ( target . setIndex ( offset - 1 ) ) ) ) return - 1 ; break ; case '$' : if ( isSet ( opts , MULTIPLE_LINES ) ) { if ( ! ( offset == con . limit || offset < con . limit && isEOLChar ( target . setIndex ( offset ) ) ) ) return - 1 ; } else { if ( ! ( offset == con . limit || offset + 1 == con . limit && isEOLChar ( target . setIndex ( offset ) ) || offset + 2 == con . limit && target . setIndex ( offset ) == CARRIAGE_RETURN && target . setIndex ( offset + 1 ) == LINE_FEED ) ) return - 1 ; } break ; case 'A' : if ( offset != con . start ) return - 1 ; break ; case 'Z' : if ( ! ( offset == con . limit || offset + 1 == con . limit && isEOLChar ( target . setIndex ( offset ) ) || offset + 2 == con . limit && target . setIndex ( offset ) == CARRIAGE_RETURN && target . setIndex ( offset + 1 ) == LINE_FEED ) ) return - 1 ; break ; case 'z' : if ( offset != con . limit ) return - 1 ; break ; case 'b' : if ( con . length == 0 ) return - 1 ; { int after = getWordType ( target , con . start , con . limit , offset , opts ) ; if ( after == WT_IGNORE ) return - 1 ; int before = getPreviousWordType ( target , con . start , con . limit , offset , opts ) ; if ( after == before ) return - 1 ; } break ; case 'B' : if ( con . length == 0 ) go = true ; else { int after = getWordType ( target , con . start , con . limit , offset , opts ) ; go = after == WT_IGNORE || after == getPreviousWordType ( target , con . start , con . limit , offset , opts ) ; } if ( ! go ) return - 1 ; break ; case '<' : if ( con . length == 0 || offset == con . limit ) return - 1 ; if ( getWordType ( target , con . start , con . limit , offset , opts ) != WT_LETTER || getPreviousWordType ( target , con . start , con . limit , offset , opts ) != WT_OTHER ) return - 1 ; break ; case '>' : if ( con . length == 0 || offset == con . start ) return - 1 ; if ( getWordType ( target , con . start , con . limit , offset , opts ) != WT_OTHER || getPreviousWordType ( target , con . start , con . limit , offset , opts ) != WT_LETTER ) return - 1 ; break ; } op = op . next ; break ; case Op . BACKREFERENCE : { int refno = op . getData ( ) ; if ( refno <= 0 || refno >= this . nofparen ) throw new RuntimeException ( "Internal Error: Reference number must be more than zero: " + refno ) ; if ( con . match . getBeginning ( refno ) < 0 || con . match . getEnd ( refno ) < 0 ) return - 1 ; int o2 = con . match . getBeginning ( refno ) ; int literallen = con . match . getEnd ( refno ) - o2 ; if ( ! isSet ( opts , IGNORE_CASE ) ) { if ( dx > 0 ) { if ( ! regionMatches ( target , offset , con . limit , o2 , literallen ) ) return - 1 ; offset += literallen ; } else { if ( ! regionMatches ( target , offset - literallen , con . limit , o2 , literallen ) ) return - 1 ; offset -= literallen ; } } else { if ( dx > 0 ) { if ( ! regionMatchesIgnoreCase ( target , offset , con . limit , o2 , literallen ) ) return - 1 ; offset += literallen ; } else { if ( ! regionMatchesIgnoreCase ( target , offset - literallen , con . limit , o2 , literallen ) ) return - 1 ; offset -= literallen ; } } } op = op . next ; break ; case Op . STRING : { String literal = op . getString ( ) ; int literallen = literal . length ( ) ; if ( ! isSet ( opts , IGNORE_CASE ) ) { if ( dx > 0 ) { if ( ! regionMatches ( target , offset , con . limit , literal , literallen ) ) return - 1 ; offset += literallen ; } else { if ( ! regionMatches ( target , offset - literallen , con . limit , literal , literallen ) ) return - 1 ; offset -= literallen ; } } else { if ( dx > 0 ) { if ( ! regionMatchesIgnoreCase ( target , offset , con . limit , literal , literallen ) ) return - 1 ; offset += literallen ; } else { if ( ! regionMatchesIgnoreCase ( target , offset - literallen , con . limit , literal , literallen ) ) return - 1 ; offset -= literallen ; } } } op = op . next ; break ; case Op . CLOSURE : { int id = op . getData ( ) ; if ( id >= 0 ) { int previousOffset = con . offsets [ id ] ; if ( previousOffset < 0 || previousOffset != offset ) { con . offsets [ id ] = offset ; } else { con . offsets [ id ] = - 1 ; op = op . next ; break ; } } int ret = this . matchCharacterIterator ( con , op . getChild ( ) , offset , dx , opts ) ; if ( id >= 0 ) con . offsets [ id ] = - 1 ; if ( ret >= 0 ) return ret ; op = op . next ; } break ; case Op . QUESTION : { int ret = this . matchCharacterIterator ( con , op . getChild ( ) , offset , dx , opts ) ; if ( ret >= 0 ) return ret ; op = op . next ; } break ; case Op . NONGREEDYCLOSURE : case Op . NONGREEDYQUESTION : { int ret = this . matchCharacterIterator ( con , op . next , offset , dx , opts ) ; if ( ret >= 0 ) return ret ; op = op . getChild ( ) ; } break ; case Op . UNION : for ( int i = 0 ; i < op . size ( ) ; i ++ ) { int ret = this . matchCharacterIterator ( con , op . elementAt ( i ) , offset , dx , opts ) ; if ( ret >= 0 ) return ret ; } return - 1 ; case Op . CAPTURE : int refno = op . getData ( ) ; if ( con . match != null && refno > 0 ) { int save = con . match . getBeginning ( refno ) ; con . match . setBeginning ( refno , offset ) ; int ret = this . matchCharacterIterator ( con , op . next , offset , dx , opts ) ; if ( ret < 0 ) con . match . setBeginning ( refno , save ) ; return ret ; } else if ( con . match != null && refno < 0 ) { int index = - refno ; int save = con . match . getEnd ( index ) ; con . match . setEnd ( index , offset ) ; int ret = this . matchCharacterIterator ( con , op . next , offset , dx , opts ) ; if ( ret < 0 ) con . match . setEnd ( index , save ) ; return ret ; } op = op . next ; break ; case Op . LOOKAHEAD : if ( 0 > this . matchCharacterIterator ( con , op . getChild ( ) , offset , 1 , opts ) ) return - 1 ; op = op . next ; break ; case Op . NEGATIVELOOKAHEAD : if ( 0 <= this . matchCharacterIterator ( con , op . getChild ( ) , offset , 1 , opts ) ) return - 1 ; op = op . next ; break ; case Op . LOOKBEHIND : if ( 0 > this . matchCharacterIterator ( con , op . getChild ( ) , offset , - 1 , opts ) ) return - 1 ; op = op . next ; break ; case Op . NEGATIVELOOKBEHIND : if ( 0 <= this . matchCharacterIterator ( con , op . getChild ( ) , offset , - 1 , opts ) ) return - 1 ; op = op . next ; break ; case Op . INDEPENDENT : { int ret = this . matchCharacterIterator ( con , op . getChild ( ) , offset , dx , opts ) ; if ( ret < 0 ) return ret ; offset = ret ; op = op . next ; } break ; case Op . MODIFIER : { int localopts = opts ; localopts |= op . getData ( ) ; localopts &= ~ op . getData2 ( ) ; int ret = this . matchCharacterIterator ( con , op . getChild ( ) , offset , dx , localopts ) ; if ( ret < 0 ) return ret ; offset = ret ; op = op . next ; } break ; case Op . CONDITION : { Op . ConditionOp cop = ( Op . ConditionOp ) op ; boolean matchp = false ; if ( cop . refNumber > 0 ) { if ( cop . refNumber >= this . nofparen ) throw new RuntimeException ( "Internal Error: Reference number must be more than zero: " + cop . refNumber ) ; matchp = con . match . getBeginning ( cop . refNumber ) >= 0 && con . match . getEnd ( cop . refNumber ) >= 0 ; } else { matchp = 0 <= this . matchCharacterIterator ( con , cop . condition , offset , dx , opts ) ; } if ( matchp ) { op = cop . yes ; } else if ( cop . no != null ) { op = cop . no ; } else { op = cop . next ; } } break ; default : throw new RuntimeException ( "Unknown operation type: " + op . type ) ; } } } private static final int getPreviousWordType ( CharacterIterator target , int begin , int end , int offset , int opts ) { int ret = getWordType ( target , begin , end , -- offset , opts ) ; while ( ret == WT_IGNORE ) ret = getWordType ( target , begin , end , -- offset , opts ) ; return ret ; } private static final int getWordType ( CharacterIterator target , int begin , int end , int offset , int opts ) { if ( offset < begin || offset >= end ) return WT_OTHER ; return getWordType0 ( target . setIndex ( offset ) , opts ) ; } private static final boolean regionMatches ( CharacterIterator target , int offset , int limit , String part , int partlen ) { if ( offset < 0 ) return false ; if ( limit - offset < partlen ) return false ; int i = 0 ; while ( partlen -- > 0 ) { if ( target . setIndex ( offset ++ ) != part . charAt ( i ++ ) ) return false ; } return true ; } private static final boolean regionMatches ( CharacterIterator target , int offset , int limit , int offset2 , int partlen ) { if ( offset < 0 ) return false ; if ( limit - offset < partlen ) return false ; int i = offset2 ; while ( partlen -- > 0 ) { if ( target . setIndex ( offset ++ ) != target . setIndex ( i ++ ) ) return false ; } return true ; } private static final boolean regionMatchesIgnoreCase ( CharacterIterator target , int offset , int limit , String part , int partlen ) { if ( offset < 0 ) return false ; if ( limit - offset < partlen ) return false ; int i = 0 ; while ( partlen -- > 0 ) { char ch1 = target . setIndex ( offset ++ ) ; char ch2 = part . charAt ( i ++ ) ; if ( ch1 == ch2 ) continue ; char uch1 = Character . toUpperCase ( ch1 ) ; char uch2 = Character . toUpperCase ( ch2 ) ; if ( uch1 == uch2 ) continue ; if ( Character . toLowerCase ( uch1 ) != Character . toLowerCase ( uch2 ) ) return false ; } return true ; } private static final boolean regionMatchesIgnoreCase ( CharacterIterator target , int offset , int limit , int offset2 , int partlen ) { if ( offset < 0 ) return false ; if ( limit - offset < partlen ) return false ; int i = offset2 ; while ( partlen -- > 0 ) { char ch1 = target . setIndex ( offset ++ ) ; char ch2 = target . setIndex ( i ++ ) ; if ( ch1 == ch2 ) continue ; char uch1 = Character . toUpperCase ( ch1 ) ; char uch2 = Character . toUpperCase ( ch2 ) ; if ( uch1 == uch2 ) continue ; if ( Character . toLowerCase ( uch1 ) != Character . toLowerCase ( uch2 ) ) return false ; } return true ; } String regex ; int options ; int nofparen ; Token tokentree ; boolean hasBackReferences = false ; transient int minlength ; transient Op operations = null ; transient int numberOfClosures ; transient Context context = null ; transient RangeToken firstChar = null ; transient String fixedString = null ; transient int fixedStringOptions ; transient BMPattern fixedStringTable = null ; transient boolean fixedStringOnly = false ; static final class Context { CharacterIterator ciTarget ; String strTarget ; char [ ] charTarget ; int start ; int limit ; int length ; Match match ; boolean inuse = false ; int [ ] offsets ; Context ( ) { } private void resetCommon ( int nofclosures ) { this . length = this . limit - this . start ; this . inuse = true ; this . match = null ; if ( this . offsets == null || this . offsets . length != nofclosures ) this . offsets = new int [ nofclosures ] ; for ( int i = 0 ; i < nofclosures ; i ++ ) this . offsets [ i ] = - 1 ; } void reset ( CharacterIterator target , int start , int limit , int nofclosures ) { this . ciTarget = target ; this . start = start ; this . limit = limit ; this . resetCommon ( nofclosures ) ; } void reset ( String target , int start , int limit , int nofclosures ) { this . strTarget = target ; this . start = start ; this . limit = limit ; this . resetCommon ( nofclosures ) ; } void reset ( char [ ] target , int start , int limit , int nofclosures ) { this . charTarget = target ; this . start = start ; this . limit = limit ; this . resetCommon ( nofclosures ) ; } } void prepare ( ) { if ( Op . COUNT ) Op . nofinstances = 0 ; this . compile ( this . tokentree ) ; if ( Op . COUNT ) System . err . println ( "DEBUG: The number of operations: " + Op . nofinstances ) ; this . minlength = this . tokentree . getMinLength ( ) ; this . firstChar = null ; if ( ! isSet ( this . options , PROHIBIT_HEAD_CHARACTER_OPTIMIZATION ) && ! isSet ( this . options , XMLSCHEMA_MODE ) ) { RangeToken firstChar = Token . createRange ( ) ; int fresult = this . tokentree . analyzeFirstCharacter ( firstChar , this . options ) ; if ( fresult == Token . FC_TERMINAL ) { firstChar . compactRanges ( ) ; this . firstChar = firstChar ; if ( DEBUG ) System . err . println ( "DEBUG: Use the first character optimization: " + firstChar ) ; } } if ( this . operations != null && ( this . operations . type == Op . STRING || this . operations . type == Op . CHAR ) && this . operations . next == null ) { if ( DEBUG ) System . err . print ( " *** Only fixed string! *** " ) ; this . fixedStringOnly = true ; if ( this . operations . type == Op . STRING ) this . fixedString = this . operations . getString ( ) ; else if ( this . operations . getData ( ) >= 0x10000 ) { this . fixedString = REUtil . decomposeToSurrogates ( this . operations . getData ( ) ) ; } else { char [ ] ac = new char [ 1 ] ; ac [ 0 ] = ( char ) this . operations . getData ( ) ; this . fixedString = new String ( ac ) ; } this . fixedStringOptions = this . options ; this . fixedStringTable = new BMPattern ( this . fixedString , 256 , isSet ( this . fixedStringOptions , IGNORE_CASE ) ) ; } else if ( ! isSet ( this . options , PROHIBIT_FIXED_STRING_OPTIMIZATION ) && ! isSet ( this . options , XMLSCHEMA_MODE ) ) { Token . FixedStringContainer container = new Token . FixedStringContainer ( ) ; this . tokentree . findFixedString ( container , this . options ) ; this . fixedString = container . token == null ? null : container . token . getString ( ) ; this . fixedStringOptions = container . options ; if ( this . fixedString != null && this . fixedString . length ( ) < 2 ) this . fixedString = null ; if ( this . fixedString != null ) { this . fixedStringTable = new BMPattern ( this . fixedString , 256 , isSet ( this . fixedStringOptions , IGNORE_CASE ) ) ; if ( DEBUG ) { System . err . println ( "DEBUG: The longest fixed string: " + this . fixedString . length ( ) + "/" + "/" + REUtil . createOptionString ( this . fixedStringOptions ) ) ; System . err . print ( "String: " ) ; REUtil . dumpString ( this . fixedString ) ; } } } } static final int IGNORE_CASE = 1 << 1 ; static final int SINGLE_LINE = 1 << 2 ; static final int MULTIPLE_LINES = 1 << 3 ; static final int EXTENDED_COMMENT = 1 << 4 ; static final int USE_UNICODE_CATEGORY = 1 << 5 ; static final int UNICODE_WORD_BOUNDARY = 1 << 6 ; static final int PROHIBIT_HEAD_CHARACTER_OPTIMIZATION = 1 << 7 ; static final int PROHIBIT_FIXED_STRING_OPTIMIZATION = 1 << 8 ; static final int XMLSCHEMA_MODE = 1 << 9 ; static final int SPECIAL_COMMA = 1 << 10 ; private static final boolean isSet ( int options , int flag ) { return ( options & flag ) == flag ; } public RegularExpression ( String regex ) throws ParseException { this . setPattern ( regex , null ) ; } public RegularExpression ( String regex , String options ) throws ParseException { this . setPattern ( regex , options ) ; } RegularExpression ( String regex , Token tok , int parens , boolean hasBackReferences , int options ) { this . regex = regex ; this . tokentree = tok ; this . nofparen = parens ; this . options = options ; this . hasBackReferences = hasBackReferences ; } public void setPattern ( String newPattern ) throws ParseException { this . setPattern ( newPattern , this . options ) ; } private void setPattern ( String newPattern , int options ) throws ParseException { this . regex = newPattern ; this . options = options ; RegexParser rp = this . isSet ( this . options , RegularExpression . XMLSCHEMA_MODE ) ? new ParserForXMLSchema ( ) : new RegexParser ( ) ; this . tokentree = rp . parse ( this . regex , this . options ) ; this . nofparen = rp . parennumber ; this . hasBackReferences = rp . hasBackReferences ; this . operations = null ; this . context = null ; } public void setPattern ( String newPattern , String options ) throws ParseException { this . setPattern ( newPattern , REUtil . parseOptions ( options ) ) ; } public String getPattern ( ) { return this . regex ; } public String toString ( ) { return this . tokentree . toString ( this . options ) ; } public String getOptions ( ) { return REUtil . createOptionString ( this . options ) ; } public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( ! ( obj instanceof RegularExpression ) ) return false ; RegularExpression r = ( RegularExpression ) obj ; return this . regex . equals ( r . regex ) && this . options == r . options ; } boolean equals ( String pattern , int options ) { return this . regex . equals ( pattern ) && this . options == options ; } public int hashCode ( ) { return ( this . regex + "/" + this . getOptions ( ) ) . hashCode ( ) ; } public int getNumberOfGroups ( ) { return this . nofparen ; } private static final int WT_IGNORE = 0 ; private static final int WT_LETTER = 1 ; private static final int WT_OTHER = 2 ; transient static Token wordchar = null ; private static final int getWordType0 ( char ch , int opts ) { if ( ! isSet ( opts , UNICODE_WORD_BOUNDARY ) ) { if ( isSet ( opts , USE_UNICODE_CATEGORY ) ) { if ( RegularExpression . wordchar == null ) RegularExpression . wordchar = Token . getRange ( "IsWord" , true ) ; return RegularExpression . wordchar . match ( ch ) ? WT_LETTER : WT_OTHER ; } return isWordChar ( ch ) ? WT_LETTER : WT_OTHER ; } switch ( Character . getType ( ch ) ) { case Character . UPPERCASE_LETTER : case Character . LOWERCASE_LETTER : case Character . TITLECASE_LETTER : case Character . MODIFIER_LETTER : case Character . OTHER_LETTER : case Character . LETTER_NUMBER : case Character . DECIMAL_DIGIT_NUMBER : case Character . OTHER_NUMBER : case Character . COMBINING_SPACING_MARK : return WT_LETTER ; case Character . FORMAT : case Character . NON_SPACING_MARK : case Character . ENCLOSING_MARK : return WT_IGNORE ; case Character . CONTROL : switch ( ch ) { case '\t' : case '\n' : case '' : case '\f' : case '\r' : return WT_OTHER ; default : return WT_IGNORE ; } default : return WT_OTHER ; } } static final int LINE_FEED = 0x000A ; static final int CARRIAGE_RETURN = 0x000D ; static final int LINE_SEPARATOR = 0x2028 ; static final int PARAGRAPH_SEPARATOR = 0x2029 ; private static final boolean isEOLChar ( int ch ) { return ch == LINE_FEED || ch == CARRIAGE_RETURN || ch == LINE_SEPARATOR || ch == PARAGRAPH_SEPARATOR ; } private static final boolean isWordChar ( int ch ) { if ( ch == '_' ) return true ; if ( ch < '0' ) return false ; if ( ch > 'z' ) return false ; if ( ch <= '9' ) return true ; if ( ch < 'A' ) return false ; if ( ch <= 'Z' ) return true ; if ( ch < 'a' ) return false ; return true ; } private static final boolean matchIgnoreCase ( int chardata , int ch ) { if ( chardata == ch ) return true ; if ( chardata > 0xffff || ch > 0xffff ) return false ; char uch1 = Character . toUpperCase ( ( char ) chardata ) ; char uch2 = Character . toUpperCase ( ( char ) ch ) ; if ( uch1 == uch2 ) return true ; return Character . toLowerCase ( uch1 ) == Character . toLowerCase ( uch2 ) ; } } 	0
package org . apache . xerces . utils ; import java . lang . * ; public final class HexBin { static private final int BASELENGTH = 255 ; static private final int LOOKUPLENGTH = 16 ; static private byte [ ] hexNumberTable = new byte [ BASELENGTH ] ; static private byte [ ] lookUpHexAlphabet = new byte [ LOOKUPLENGTH ] ; static { for ( int i = 0 ; i < BASELENGTH ; i ++ ) { hexNumberTable [ i ] = - 1 ; } for ( int i = '9' ; i >= '0' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - '0' ) ; } for ( int i = 'F' ; i >= 'A' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - 'A' + 10 ) ; } for ( int i = 'f' ; i >= 'a' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - 'a' + 10 ) ; } for ( int i = 0 ; i <= 25 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( 'A' + i ) ; for ( int i = 0 ; i < 10 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( '0' + i ) ; for ( int i = 10 ; i <= 15 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( 'A' + i - 10 ) ; } static boolean isHex ( byte octect ) { return ( hexNumberTable [ octect ] != - 1 ) ; } static boolean isArrayByteHex ( byte [ ] arrayOctect ) { int length = arrayOctect . length ; if ( length == 0 ) return false ; for ( int i = 0 ; i < length ; i ++ ) { if ( HexBin . isHex ( arrayOctect [ i ] ) == false ) return false ; } return true ; } public static boolean isHex ( String isValidString ) { return ( isArrayByteHex ( isValidString . getBytes ( ) ) ) ; } static public byte [ ] encode ( byte [ ] binaryData ) { int lengthData = binaryData . length ; int lengthEncode = lengthData ; byte [ ] encodedData = new byte [ lengthData ] ; for ( int i = 0 ; i < lengthData ; i ++ ) { encodedData [ i ] = lookUpHexAlphabet [ binaryData [ i ] ] ; } return encodedData ; } static public byte [ ] decode ( byte [ ] binaryData ) { int lengthData = binaryData . length ; int lengthEncode = lengthData ; byte [ ] decodedData = new byte [ lengthData ] ; for ( int i = 0 ; i < lengthData ; i ++ ) { decodedData [ i ] = hexNumberTable [ binaryData [ i ] ] ; } return decodedData ; } } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import org . apache . xerces . validators . datatype . * ; import org . apache . xerces . validators . schema . SchemaSymbols ; public interface DatatypeValidatorFactory { public DatatypeValidator createDatatypeValidator ( String typeName , DatatypeValidator base , Hashtable facets , boolean list ) throws InvalidDatatypeFacetException ; } 	0
package org . w3c . dom ; public interface EntityReference extends Node { } 	1
package org . apache . wml ; public interface WMLSmallElement extends WMLElement { public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . w3c . dom ; public interface Attr extends Node { public String getName ( ) ; public boolean getSpecified ( ) ; public String getValue ( ) ; public void setValue ( String value ) throws DOMException ; public Element getOwnerElement ( ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLAreaElementImpl extends HTMLElementImpl implements HTMLAreaElement { public String getAccessKey ( ) { String accessKey ; accessKey = getAttribute ( "accesskey" ) ; if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; return accessKey ; } public void setAccessKey ( String accessKey ) { if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; setAttribute ( "accesskey" , accessKey ) ; } public String getAlt ( ) { return getAttribute ( "alt" ) ; } public void setAlt ( String alt ) { setAttribute ( "alt" , alt ) ; } public String getCoords ( ) { return getAttribute ( "coords" ) ; } public void setCoords ( String coords ) { setAttribute ( "coords" , coords ) ; } public String getHref ( ) { return getAttribute ( "href" ) ; } public void setHref ( String href ) { setAttribute ( "href" , href ) ; } public boolean getNoHref ( ) { return getBinary ( "href" ) ; } public void setNoHref ( boolean noHref ) { setAttribute ( "nohref" , noHref ) ; } public String getShape ( ) { return capitalize ( getAttribute ( "shape" ) ) ; } public void setShape ( String shape ) { setAttribute ( "shape" , shape ) ; } public int getTabIndex ( ) { return getInteger ( getAttribute ( "tabindex" ) ) ; } public void setTabIndex ( int tabIndex ) { setAttribute ( "tabindex" , String . valueOf ( tabIndex ) ) ; } public String getTarget ( ) { return getAttribute ( "target" ) ; } public void setTarget ( String target ) { setAttribute ( "target" , target ) ; } public HTMLAreaElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . DOMException ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . CharacterData ; import org . apache . xerces . dom . DOMExceptionImpl ; import org . apache . xerces . dom . DocumentImpl ; import org . w3c . dom . range . * ; import java . util . Vector ; public class RangeImpl implements Range { static final int START = 0 ; static final int AFTER = 1 ; static final int BEFORE = - 1 ; DocumentImpl fDocument ; Node fStartContainer ; Node fEndContainer ; int fStartOffset ; int fEndOffset ; boolean fIsCollapsed ; boolean fDetach = false ; Node fInsertNode = null ; Node fDeleteNode = null ; Node fSplitNode = null ; public RangeImpl ( DocumentImpl document ) { fDocument = document ; fStartContainer = document ; fEndContainer = document ; fStartOffset = 0 ; fEndOffset = 0 ; fDetach = false ; } public Node getStartContainer ( ) { return fStartContainer ; } public int getStartOffset ( ) { return fStartOffset ; } public Node getEndContainer ( ) { return fEndContainer ; } public int getEndOffset ( ) { return fEndOffset ; } public boolean getCollapsed ( ) { return ( fStartContainer == fEndContainer && fStartOffset == fEndOffset ) ; } public Node getCommonAncestorContainer ( ) { Vector startV = new Vector ( ) ; Node node ; for ( node = fStartContainer ; node != null ; node = node . getParentNode ( ) ) { startV . addElement ( node ) ; } Vector endV = new Vector ( ) ; for ( node = fEndContainer ; node != null ; node = node . getParentNode ( ) ) { endV . addElement ( node ) ; } int s = startV . size ( ) - 1 ; int e = endV . size ( ) - 1 ; Object result = null ; while ( s >= 0 && e >= 0 ) { if ( startV . elementAt ( s ) == endV . elementAt ( e ) ) { result = startV . elementAt ( s ) ; } else { break ; } -- s ; -- e ; } return ( Node ) result ; } public void setStart ( Node refNode , int offset ) throws RangeException , DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } checkIndex ( refNode , offset ) ; fStartContainer = refNode ; fStartOffset = offset ; } public void setEnd ( Node refNode , int offset ) throws RangeException , DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } checkIndex ( refNode , offset ) ; fEndContainer = refNode ; fEndOffset = offset ; } public void setStartBefore ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i - 1 ; } public void setStartAfter ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i ; } public void setEndBefore ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fEndContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fEndOffset = i - 1 ; } public void setEndAfter ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fEndContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fEndOffset = i ; } public void collapse ( boolean toStart ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( toStart ) { fEndContainer = fStartContainer ; fEndOffset = fStartOffset ; } else { fStartContainer = fEndContainer ; fStartOffset = fEndOffset ; } } public void selectNode ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } Node parent = refNode . getParentNode ( ) ; if ( parent != null ) { fStartContainer = parent ; fEndContainer = parent ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i - 1 ; fEndOffset = fStartOffset + 1 ; } } public void selectNodeContents ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode ; fEndContainer = refNode ; Node first = refNode . getFirstChild ( ) ; fStartOffset = 0 ; if ( first == null ) { fEndOffset = 0 ; } else { int i = 0 ; for ( Node n = first ; n != null ; n = n . getNextSibling ( ) ) { i ++ ; } fEndOffset = i ; } } public short compareBoundaryPoints ( short how , Range sourceRange ) throws DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Node endPointA ; Node endPointB ; int offsetA ; int offsetB ; if ( how == START_TO_START ) { endPointA = sourceRange . getStartContainer ( ) ; endPointB = fStartContainer ; offsetA = sourceRange . getStartOffset ( ) ; offsetB = fStartOffset ; } else if ( how == START_TO_END ) { endPointA = sourceRange . getStartContainer ( ) ; endPointB = fEndContainer ; offsetA = sourceRange . getStartOffset ( ) ; offsetB = fEndOffset ; } else if ( how == END_TO_START ) { endPointA = sourceRange . getEndContainer ( ) ; endPointB = fStartContainer ; offsetA = sourceRange . getEndOffset ( ) ; offsetB = fStartOffset ; } else { endPointA = sourceRange . getEndContainer ( ) ; endPointB = fEndContainer ; offsetA = sourceRange . getEndOffset ( ) ; offsetB = fEndOffset ; } if ( endPointA == endPointB ) { if ( offsetA < offsetB ) return - 1 ; if ( offsetA == offsetB ) return 0 ; return 1 ; } for ( Node node = endPointA . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { if ( isAncestorOf ( node , endPointB ) ) { int index = indexOf ( node , endPointA ) ; if ( offsetA < index ) return - 1 ; if ( offsetA == index ) return 0 ; return 1 ; } } for ( Node node = endPointB . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { if ( isAncestorOf ( node , endPointA ) ) { int index = indexOf ( node , endPointB ) ; if ( offsetB < index ) return - 1 ; if ( offsetB == index ) return 0 ; return 1 ; } } Node ancestor = getCommonAncestorContainer ( ) ; Node current = ancestor ; do { if ( current == endPointA ) return - 1 ; if ( current == endPointB ) return 1 ; current = nextNode ( current , true ) ; } while ( current != null && current != ancestor ) ; return - 2 ; } public void deleteContents ( ) throws DOMException { Node current = fStartContainer ; Node parent = null ; Node next ; boolean deleteCurrent = false ; Node root = getCommonAncestorContainer ( ) ; if ( fStartContainer == fEndContainer ) { if ( fStartOffset == fEndOffset ) { return ; } if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { String value = fStartContainer . getNodeValue ( ) ; int realStart = fStartOffset ; int realEnd = fEndOffset ; if ( fStartOffset > value . length ( ) ) realStart = value . length ( ) - 1 ; if ( fEndOffset > value . length ( ) ) realEnd = value . length ( ) - 1 ; deleteData ( ( CharacterData ) fStartContainer , realStart , realEnd - realStart ) ; } else { current = fStartContainer . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } for ( i = 0 ; i < fEndOffset - fStartOffset && current != null ; i ++ ) { Node newCurrent = current . getNextSibling ( ) ; removeChild ( fStartContainer , current ) ; current = newCurrent ; } } collapse ( true ) ; return ; } Node partialNode = null ; int partialInt = START ; Node startRoot = null ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { deleteData ( ( CharacterData ) current , fStartOffset , current . getNodeValue ( ) . length ( ) - fStartOffset ) ; } else { current = current . getFirstChild ( ) ; for ( int i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fStartContainer ; } else if ( current != fStartContainer ) { deleteCurrent = true ; } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { if ( startRoot == null ) startRoot = current ; } else { if ( partialNode == null ) { partialNode = parent ; partialInt = AFTER ; } } if ( parent != root ) { next = current . getNextSibling ( ) ; Node nextnext ; while ( next != null ) { nextnext = next . getNextSibling ( ) ; removeChild ( parent , next ) ; next = nextnext ; } } if ( deleteCurrent ) { removeChild ( parent , current ) ; deleteCurrent = false ; } current = parent ; } Node endRoot = null ; current = fEndContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { deleteData ( ( CharacterData ) current , 0 , fEndOffset ) ; } else { if ( fEndOffset == 0 ) { current = fEndContainer ; } else { current = current . getFirstChild ( ) ; for ( int i = 1 ; i < fEndOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fEndContainer . getLastChild ( ) ; } else if ( current != fStartContainer ) { deleteCurrent = true ; } } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { if ( endRoot == null ) endRoot = current ; } else { if ( partialNode == null ) { partialNode = parent ; partialInt = BEFORE ; } } if ( parent != root && parent != null ) { next = current . getPreviousSibling ( ) ; Node nextnext ; while ( next != null ) { nextnext = next . getPreviousSibling ( ) ; removeChild ( parent , next ) ; next = nextnext ; } } if ( deleteCurrent ) { removeChild ( parent , current ) ; deleteCurrent = false ; } current = parent ; } current = endRoot . getPreviousSibling ( ) ; Node prev = null ; while ( current != null && current != startRoot ) { prev = current . getPreviousSibling ( ) ; parent = current . getParentNode ( ) ; if ( parent != null ) { removeChild ( parent , current ) ; } current = prev ; } if ( partialNode == null ) { collapse ( true ) ; } else if ( partialInt == AFTER ) { setStartAfter ( partialNode ) ; setEndAfter ( partialNode ) ; } else if ( partialInt == BEFORE ) { setStartBefore ( partialNode ) ; setEndBefore ( partialNode ) ; } } public DocumentFragment extractContents ( ) throws DOMException { return traverseContents ( EXTRACT_CONTENTS ) ; } public DocumentFragment cloneContents ( ) throws DOMException { return traverseContents ( CLONE_CONTENTS ) ; } public void insertNode ( Node newNode ) throws DOMException , RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } int type = newNode . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_NODE || type == Node . DOCUMENT_FRAGMENT_NODE ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } if ( newNode == null ) return ; Node cloneCurrent ; Node current ; boolean MULTIPLE_MODE = false ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( newNode . getNodeType ( ) != Node . TEXT_NODE ) { cloneCurrent = fStartContainer . cloneNode ( false ) ; ( ( TextImpl ) cloneCurrent ) . setNodeValueInternal ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset ) ) ; ( ( TextImpl ) fStartContainer ) . setNodeValueInternal ( ( fStartContainer . getNodeValue ( ) ) . substring ( 0 , fStartOffset ) ) ; Node next = fStartContainer . getNextSibling ( ) ; if ( next != null ) { Node parent = fStartContainer . getParentNode ( ) ; if ( parent != null ) { parent . insertBefore ( newNode , next ) ; parent . insertBefore ( cloneCurrent , next ) ; } } else { Node parent = fStartContainer . getParentNode ( ) ; if ( parent != null ) { parent . appendChild ( newNode ) ; parent . appendChild ( cloneCurrent ) ; } } signalSplitData ( fStartContainer , cloneCurrent , fStartOffset ) ; } else { String value = fStartContainer . getNodeValue ( ) ; String newValue = newNode . getNodeValue ( ) ; insertData ( ( CharacterData ) fStartContainer , fStartOffset , newValue ) ; } } else { current = fStartContainer . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current != null ) { fStartContainer . insertBefore ( newNode , current ) ; } else { fStartContainer . appendChild ( newNode ) ; } } } public void surroundContents ( Node newParent ) throws DOMException , RangeException { if ( newParent == null ) return ; if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } int type = newParent . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_TYPE_NODE || type == Node . DOCUMENT_NODE || type == Node . DOCUMENT_FRAGMENT_NODE ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } Node root = getCommonAncestorContainer ( ) ; Node realStart = fStartContainer ; Node realEnd = fEndContainer ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { realStart = fStartContainer . getParentNode ( ) ; } if ( fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { realEnd = fEndContainer . getParentNode ( ) ; } if ( realStart != realEnd ) { throw new RangeExceptionImpl ( RangeException . BAD_BOUNDARYPOINTS_ERR , "DOM013 Bad boundary points" ) ; } DocumentFragment frag = extractContents ( ) ; insertNode ( newParent ) ; newParent . appendChild ( frag ) ; selectNode ( newParent ) ; } public Range cloneRange ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Range range = fDocument . createRange ( ) ; range . setStart ( fStartContainer , fStartOffset ) ; range . setEnd ( fEndContainer , fEndOffset ) ; return range ; } public String toString ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Node node = fStartContainer ; StringBuffer sb = new StringBuffer ( ) ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE || fStartContainer . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { if ( fStartContainer == fEndContainer ) { sb . append ( fStartContainer . getNodeValue ( ) . substring ( fStartOffset , fEndOffset ) ) ; return sb . toString ( ) ; } else { sb . append ( fStartContainer . getNodeValue ( ) . substring ( fStartOffset ) ) ; } } while ( node != fEndContainer ) { node = nextNode ( node , true ) ; if ( node == null ) break ; if ( node . getNodeType ( ) == Node . TEXT_NODE || node . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { sb . append ( node . getNodeValue ( ) ) ; } } if ( fEndContainer . getNodeType ( ) == Node . TEXT_NODE || fEndContainer . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { sb . append ( fEndContainer . getNodeValue ( ) . substring ( 0 , fEndOffset ) ) ; } return sb . toString ( ) ; } public void detach ( ) { fDetach = true ; fDocument . removeRange ( this ) ; } void signalSplitData ( Node node , Node newNode , int offset ) { fSplitNode = node ; fDocument . splitData ( node , newNode , offset ) ; fSplitNode = null ; } void receiveSplitData ( Node node , Node newNode , int offset ) { if ( node == null || newNode == null ) return ; if ( fSplitNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fStartOffset > offset ) { fStartOffset = fStartOffset - offset ; fStartContainer = newNode ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fEndOffset > offset ) { fEndOffset = fEndOffset - offset ; fEndContainer = newNode ; } } } void deleteData ( CharacterData node , int offset , int count ) { fDeleteNode = node ; node . deleteData ( offset , count ) ; fDeleteNode = null ; } void receiveDeletedText ( Node node , int offset , int count ) { if ( node == null ) return ; if ( fDeleteNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fStartOffset > offset + count ) { fStartOffset = offset + ( fStartOffset - ( offset + count ) ) ; } else if ( fStartOffset > offset ) { fStartOffset = offset ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fEndOffset > offset + count ) { fEndOffset = offset + ( fEndOffset - ( offset + count ) ) ; } else if ( fEndOffset > offset ) { fEndOffset = offset ; } } } void insertData ( CharacterData node , int index , String insert ) { fInsertNode = node ; node . insertData ( index , insert ) ; fInsertNode = null ; } void receiveInsertedText ( Node node , int index , int len ) { if ( node == null ) return ; if ( fInsertNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( index < fStartOffset ) { fStartOffset = fStartOffset + len ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( index < fEndOffset ) { fEndOffset = fEndOffset + len ; } } } void receiveReplacedText ( Node node ) { if ( node == null ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { fStartOffset = 0 ; } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { fEndOffset = 0 ; } } public void insertedNodeFromDOM ( Node node ) { if ( node == null ) return ; if ( fInsertNode == node ) return ; Node parent = node . getParentNode ( ) ; if ( parent == fStartContainer ) { int index = indexOf ( node , fStartContainer ) ; if ( index < fStartOffset ) { fStartOffset ++ ; } } if ( parent == fEndContainer ) { int index = indexOf ( node , fEndContainer ) ; if ( index < fEndOffset ) { fEndOffset ++ ; } } } Node fRemoveChild = null ; Node removeChild ( Node parent , Node child ) { fRemoveChild = child ; Node n = parent . removeChild ( child ) ; fRemoveChild = null ; return n ; } void removeNode ( Node node ) { if ( node == null ) return ; if ( fRemoveChild == node ) return ; Node parent = node . getParentNode ( ) ; if ( parent == fStartContainer ) { int index = indexOf ( node , fStartContainer ) ; if ( index <= fStartOffset ) { fStartOffset -- ; } } if ( parent == fEndContainer ) { int index = indexOf ( node , fEndContainer ) ; if ( index < fEndOffset ) { fEndOffset -- ; } } if ( parent != fStartContainer && parent != fEndContainer ) { if ( isAncestorOf ( node , fStartContainer ) ) { fStartContainer = parent ; fStartOffset = indexOf ( node , parent ) - 1 ; } if ( isAncestorOf ( node , fEndContainer ) ) { fEndContainer = parent ; fEndOffset = indexOf ( node , parent ) - 1 ; } } } static final int EXTRACT_CONTENTS = 1 ; static final int CLONE_CONTENTS = 2 ; DocumentFragment traverseContents ( int traversalType ) throws DOMException { if ( fStartContainer == null || fEndContainer == null ) { return null ; } DocumentFragment frag = fDocument . createDocumentFragment ( ) ; Node current = fStartContainer ; Node cloneCurrent = null ; Node cloneParent = null ; Node partialNode = null ; int partialInt = START ; Vector d = new Vector ( ) ; if ( fStartContainer == fEndContainer ) { if ( fStartOffset == fEndOffset ) { return frag ; } if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = fStartContainer . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset , fEndOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , fStartOffset , fEndOffset - fStartOffset ) ; } frag . appendChild ( cloneCurrent ) ; } else { current = current . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } int n = fEndOffset - fStartOffset ; for ( i = 0 ; i < n && current != null ; i ++ ) { Node newCurrent = current . getNextSibling ( ) ; if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; frag . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { frag . appendChild ( current ) ; } current = newCurrent ; } } return frag ; } Node root = getCommonAncestorContainer ( ) ; Node parent = null ; current = fStartContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = current . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , fStartOffset , current . getNodeValue ( ) . length ( ) - fStartOffset ) ; } } else { current = current . getFirstChild ( ) ; for ( int i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fStartContainer ; } if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } } Node startRoot = null ; parent = null ; while ( current != root ) { parent = current . getParentNode ( ) ; if ( parent == root ) { cloneParent = frag ; startRoot = current ; } else { if ( parent == null ) System . out . println ( "parent==null: current=" + current ) ; cloneParent = parent . cloneNode ( false ) ; if ( partialNode == null && parent != root ) { partialNode = parent ; partialInt = AFTER ; } } Node next = null ; current = current . getNextSibling ( ) ; cloneParent . appendChild ( cloneCurrent ) ; while ( current != null ) { next = current . getNextSibling ( ) ; if ( current != null && parent != root ) { if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; cloneParent . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneParent . appendChild ( current ) ; } } current = next ; } current = parent ; cloneCurrent = cloneParent ; } Node endRoot = null ; current = fEndContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = current . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( 0 , fEndOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , 0 , fEndOffset ) ; } } else { if ( fEndOffset == 0 ) { current = fEndContainer ; } else { current = current . getFirstChild ( ) ; for ( int i = 1 ; i < fEndOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fEndContainer . getLastChild ( ) ; } } if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { cloneParent = frag ; endRoot = current ; } else { cloneParent = parent . cloneNode ( false ) ; if ( partialNode == null && parent != root ) { partialNode = parent ; partialInt = BEFORE ; } } Node holdCurrent = current ; current = parent . getFirstChild ( ) ; cloneParent . appendChild ( cloneCurrent ) ; Node next = null ; while ( current != holdCurrent && current != null ) { next = current . getNextSibling ( ) ; if ( current != null && parent != root ) { if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; cloneParent . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneParent . appendChild ( current ) ; } } current = next ; } current = parent ; cloneCurrent = cloneParent ; } d . removeAllElements ( ) ; Node clonedPrevious = frag . getLastChild ( ) ; current = endRoot . getPreviousSibling ( ) ; Node prev = null ; while ( current != startRoot && current != null ) { prev = current . getPreviousSibling ( ) ; if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } frag . insertBefore ( cloneCurrent , clonedPrevious ) ; current = prev ; clonedPrevious = cloneCurrent ; } if ( traversalType == EXTRACT_CONTENTS ) { if ( partialNode == null ) { collapse ( true ) ; } else if ( partialInt == AFTER ) { setStartAfter ( partialNode ) ; setEndAfter ( partialNode ) ; } else if ( partialInt == BEFORE ) { setStartBefore ( partialNode ) ; setEndBefore ( partialNode ) ; } } return frag ; } void checkIndex ( Node refNode , int offset ) throws DOMException { if ( offset < 0 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } int type = refNode . getNodeType ( ) ; if ( ( type == Node . TEXT_NODE || type == Node . CDATA_SECTION_NODE || type == Node . COMMENT_NODE || type == Node . PROCESSING_INSTRUCTION_NODE ) && offset > refNode . getNodeValue ( ) . length ( ) ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } Node child = refNode . getFirstChild ( ) ; int i = 1 ; for ( ; child != null ; i ++ ) { child = child . getNextSibling ( ) ; } if ( i > offset ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } boolean isAncestorTypeValid ( Node node ) { for ( Node n = node ; n != null ; n = n . getParentNode ( ) ) { int type = n . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_TYPE_NODE ) return false ; } return true ; } Node nextNode ( Node node , boolean visitChildren ) { if ( node == null ) return null ; Node result ; if ( visitChildren ) { result = node . getFirstChild ( ) ; if ( result != null ) { return result ; } } result = node . getNextSibling ( ) ; if ( result != null ) { return result ; } Node parent = node . getParentNode ( ) ; while ( parent != null && parent != fDocument ) { result = parent . getNextSibling ( ) ; if ( result != null ) { return result ; } else { parent = parent . getParentNode ( ) ; } } return null ; } boolean isAncestorOf ( Node a , Node b ) { for ( Node node = b ; node != null ; node = node . getParentNode ( ) ) { if ( node == a ) return true ; } return false ; } int indexOf ( Node child , Node parent ) { Node node ; int i = 0 ; if ( child . getParentNode ( ) != parent ) return - 1 ; for ( node = child ; node != null ; node = node . getPreviousSibling ( ) ) { i ++ ; } return i ; } } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; public class CMAny extends CMNode { private int fType ; private int fURI ; private int fPosition = - 1 ; public CMAny ( int type , int uri , int position ) throws CMException { super ( type ) ; fType = type ; fURI = uri ; fPosition = position ; } final int getType ( ) { return fType ; } final int getURI ( ) { return fURI ; } final int getPosition ( ) { return fPosition ; } final void setPosition ( int newPosition ) { fPosition = newPosition ; } boolean isNullable ( ) throws CMException { return ( fPosition == - 1 ) ; } String toString ( StringPool stringPool ) { StringBuffer strRet = new StringBuffer ( ) ; strRet . append ( "(" ) ; strRet . append ( "##any:uri=" ) ; strRet . append ( stringPool . toString ( fURI ) ) ; strRet . append ( ')' ) ; if ( fPosition >= 0 ) { strRet . append ( " (Pos:" + new Integer ( fPosition ) . toString ( ) + ")" ) ; } return strRet . toString ( ) ; } protected void calcFirstPos ( CMStateSet toSet ) throws CMException { if ( fPosition == - 1 ) toSet . zeroBits ( ) ; else toSet . setBit ( fPosition ) ; } protected void calcLastPos ( CMStateSet toSet ) throws CMException { if ( fPosition == - 1 ) toSet . zeroBits ( ) ; else toSet . setBit ( fPosition ) ; } } 	0
package org . apache . xerces . jaxp ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xerces . parsers . SAXParser ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public class SAXParserImpl extends javax . xml . parsers . SAXParser { private boolean namespaces = false ; private boolean validation = false ; private Parser parser = null ; private SAXParserImpl ( ) { super ( ) ; } protected SAXParserImpl ( boolean namespaces , boolean validation ) throws ParserConfigurationException { this ( ) ; SAXParser p = new SAXParser ( ) ; try { p . setFeature ( "http://xml.org/sax/features/namespaces" , namespaces ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set namespace " + "awareness to " + namespaces ) ; } try { p . setFeature ( "http://xml.org/sax/features/validation" , validation ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set validation to " + validation ) ; } this . namespaces = namespaces ; this . validation = validation ; this . parser = p ; } public Parser getParser ( ) { return ( this . parser ) ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLRefreshElementImpl extends WMLElementImpl implements WMLRefreshElement { public WMLRefreshElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package javax . xml . parsers ; import org . xml . sax . SAXException ; public abstract class SAXParserFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.SAXParserFactory" ; private static String factory = "org.apache.xerces.jaxp.SAXParserFactoryImpl" ; protected SAXParserFactory ( ) { super ( ) ; } public static SAXParserFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( SAXParserFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "SAXParserFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified SAXParserFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "SAXParserFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"javax.xml.parsers.SAXParserFactory\"" ) ; } } public abstract SAXParser newSAXParser ( ) throws ParserConfigurationException , SAXException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . xerces . framework ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . xml . sax . AttributeList ; import org . xml . sax . Locator ; import org . xml . sax . SAXParseException ; public final class XMLAttrList implements AttributeList { private static final int CHUNK_SHIFT = 5 ; private static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; private static final int CHUNK_MASK = CHUNK_SIZE - 1 ; private static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; private static final int ATTFLAG_SPECIFIED = 1 ; private static final int ATTFLAG_LASTATTR = 2 ; private StringPool fStringPool = null ; private int fCurrentHandle = - 1 ; private int fAttributeListHandle = - 1 ; private int fAttributeListLength = 0 ; private int fAttrCount = 0 ; private int [ ] [ ] fAttPrefix = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fAttLocalpart = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fAttName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fAttURI = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fAttValue = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fAttType = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private byte [ ] [ ] fAttFlags = new byte [ INITIAL_CHUNK_COUNT ] [ ] ; private QName fAttributeQName = new QName ( ) ; public XMLAttrList ( StringPool stringPool ) { fStringPool = stringPool ; } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fCurrentHandle = - 1 ; fAttributeListHandle = - 1 ; fAttributeListLength = 0 ; fAttrCount = 0 ; } public int addAttr ( int attrName , int attValue , int attType , boolean specified , boolean search ) throws Exception { fAttributeQName . setValues ( - 1 , attrName , attrName ) ; return addAttr ( fAttributeQName , attValue , attType , specified , search ) ; } public int addAttr ( QName attribute , int attValue , int attType , boolean specified , boolean search ) throws Exception { int chunk ; int index ; if ( search ) { chunk = fCurrentHandle > > CHUNK_SHIFT ; index = fCurrentHandle & CHUNK_MASK ; for ( int attrIndex = fCurrentHandle ; attrIndex < fAttrCount ; attrIndex ++ ) { if ( fStringPool . equalNames ( fAttName [ chunk ] [ index ] , attribute . rawname ) ) { return - 1 ; } if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } } else { chunk = fAttrCount > > CHUNK_SHIFT ; index = fAttrCount & CHUNK_MASK ; } ensureCapacity ( chunk , index ) ; fAttPrefix [ chunk ] [ index ] = attribute . prefix ; fAttLocalpart [ chunk ] [ index ] = attribute . localpart ; fAttName [ chunk ] [ index ] = attribute . rawname ; fAttURI [ chunk ] [ index ] = attribute . uri ; fAttValue [ chunk ] [ index ] = attValue ; fAttType [ chunk ] [ index ] = attType ; fAttFlags [ chunk ] [ index ] = ( byte ) ( specified ? ATTFLAG_SPECIFIED : 0 ) ; return fAttrCount ++ ; } public int startAttrList ( ) { fCurrentHandle = fAttrCount ; return fCurrentHandle ; } public void endAttrList ( ) { int attrIndex = fAttrCount - 1 ; int chunk = attrIndex > > CHUNK_SHIFT ; int index = attrIndex & CHUNK_MASK ; fAttFlags [ chunk ] [ index ] |= ATTFLAG_LASTATTR ; fCurrentHandle = - 1 ; } public int getAttrPrefix ( int attrIndex ) { if ( attrIndex < 0 || attrIndex >= fAttrCount ) return - 1 ; int chunk = attrIndex > > CHUNK_SHIFT ; int index = attrIndex & CHUNK_MASK ; return fAttPrefix [ chunk ] [ index ] ; } public int getAttrLocalpart ( int attrIndex ) { if ( attrIndex < 0 || attrIndex >= fAttrCount ) return - 1 ; int chunk = attrIndex > > CHUNK_SHIFT ; int index = attrIndex & CHUNK_MASK ; return fAttLocalpart [ chunk ] [ index ] ; } public int getAttrName ( int attrIndex ) { if ( attrIndex < 0 || attrIndex >= fAttrCount ) return - 1 ; int chunk = attrIndex > > CHUNK_SHIFT ; int index = attrIndex & CHUNK_MASK ; return fAttName [ chunk ] [ index ] ; } public void setAttrURI ( int attrIndex , int uri ) { if ( attrIndex < 0 || attrIndex >= fAttrCount ) return ; int chunk = attrIndex > > CHUNK_SHIFT ; int index = attrIndex & CHUNK_MASK ; fAttURI [ chunk ] [ index ] = uri ; } public int getAttrURI ( int attrIndex ) { if ( attrIndex < 0 || attrIndex >= fAttrCount ) return - 1 ; int chunk = attrIndex > > CHUNK_SHIFT ; int index = attrIndex & CHUNK_MASK ; return fAttURI [ chunk ] [ index ] ; } public int getAttValue ( int attrIndex ) { if ( attrIndex < 0 || attrIndex >= fAttrCount ) return - 1 ; int chunk = attrIndex > > CHUNK_SHIFT ; int index = attrIndex & CHUNK_MASK ; return fAttValue [ chunk ] [ index ] ; } public void setAttType ( int attrIndex , int attTypeIndex ) { if ( attrIndex < 0 || attrIndex >= fAttrCount ) return ; int chunk = attrIndex > > CHUNK_SHIFT ; int index = attrIndex & CHUNK_MASK ; fAttType [ chunk ] [ index ] = attTypeIndex ; } public int getAttType ( int attrIndex ) { if ( attrIndex < 0 || attrIndex >= fAttrCount ) return - 1 ; int chunk = attrIndex > > CHUNK_SHIFT ; int index = attrIndex & CHUNK_MASK ; return fAttType [ chunk ] [ index ] ; } public boolean isSpecified ( int attrIndex ) { if ( attrIndex < 0 || attrIndex >= fAttrCount ) return true ; int chunk = attrIndex > > CHUNK_SHIFT ; int index = attrIndex & CHUNK_MASK ; return ( fAttFlags [ chunk ] [ index ] & ATTFLAG_SPECIFIED ) != 0 ; } public void releaseAttrList ( int attrListHandle ) { if ( attrListHandle == - 1 ) return ; int chunk = attrListHandle > > CHUNK_SHIFT ; int index = attrListHandle & CHUNK_MASK ; while ( true ) { boolean last = ( fAttFlags [ chunk ] [ index ] & ATTFLAG_LASTATTR ) != 0 ; fAttPrefix [ chunk ] [ index ] = - 1 ; fAttLocalpart [ chunk ] [ index ] = - 1 ; fAttName [ chunk ] [ index ] = - 1 ; fAttURI [ chunk ] [ index ] = - 1 ; if ( ( fAttFlags [ chunk ] [ index ] & ATTFLAG_SPECIFIED ) != 0 ) fStringPool . releaseString ( fAttValue [ chunk ] [ index ] ) ; fAttValue [ chunk ] [ index ] = - 1 ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } if ( last ) break ; } int lastIndex = ( chunk << CHUNK_SHIFT ) + index ; if ( fAttrCount == lastIndex ) fAttrCount = attrListHandle ; } public int getFirstAttr ( int attrListHandle ) { if ( attrListHandle < 0 || attrListHandle >= fAttrCount ) { return - 1 ; } return attrListHandle ; } public int getNextAttr ( int attrIndex ) { if ( attrIndex < 0 || attrIndex + 1 >= fAttrCount ) { return - 1 ; } int chunk = attrIndex > > CHUNK_SHIFT ; int index = attrIndex & CHUNK_MASK ; if ( ( fAttFlags [ chunk ] [ index ] & ATTFLAG_LASTATTR ) != 0 ) { return - 1 ; } return attrIndex + 1 ; } public AttributeList getAttributeList ( int attrListHandle ) { fAttributeListHandle = attrListHandle ; if ( fAttributeListHandle == - 1 ) fAttributeListLength = 0 ; else { int chunk = fAttributeListHandle > > CHUNK_SHIFT ; int index = fAttributeListHandle & CHUNK_MASK ; fAttributeListLength = 1 ; while ( ( fAttFlags [ chunk ] [ index ] & ATTFLAG_LASTATTR ) == 0 ) { if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } fAttributeListLength ++ ; } } return this ; } public int getLength ( ) { return fAttributeListLength ; } public String getPrefix ( int i ) { if ( i < 0 || i >= fAttributeListLength ) { return null ; } int chunk = ( fAttributeListHandle + i ) > > CHUNK_SHIFT ; int index = ( fAttributeListHandle + i ) & CHUNK_MASK ; return fStringPool . toString ( fAttPrefix [ chunk ] [ index ] ) ; } public String getLocalpart ( int i ) { if ( i < 0 || i >= fAttributeListLength ) { return null ; } int chunk = ( fAttributeListHandle + i ) > > CHUNK_SHIFT ; int index = ( fAttributeListHandle + i ) & CHUNK_MASK ; return fStringPool . toString ( fAttLocalpart [ chunk ] [ index ] ) ; } public String getName ( int i ) { if ( i < 0 || i >= fAttributeListLength ) return null ; int chunk = ( fAttributeListHandle + i ) > > CHUNK_SHIFT ; int index = ( fAttributeListHandle + i ) & CHUNK_MASK ; return fStringPool . toString ( fAttName [ chunk ] [ index ] ) ; } public String getURI ( int i ) { if ( i < 0 || i >= fAttributeListLength ) return null ; int chunk = ( fAttributeListHandle + i ) > > CHUNK_SHIFT ; int index = ( fAttributeListHandle + i ) & CHUNK_MASK ; return fStringPool . toString ( fAttURI [ chunk ] [ index ] ) ; } public String getType ( int i ) { if ( i < 0 || i >= fAttributeListLength ) return null ; int chunk = ( fAttributeListHandle + i ) > > CHUNK_SHIFT ; int index = ( fAttributeListHandle + i ) & CHUNK_MASK ; int attType = fAttType [ chunk ] [ index ] ; if ( attType == fStringPool . addSymbol ( "ENUMERATION" ) ) attType = fStringPool . addSymbol ( "NMTOKEN" ) ; return fStringPool . toString ( attType ) ; } public String getValue ( int i ) { if ( i < 0 || i >= fAttributeListLength ) return null ; int chunk = ( fAttributeListHandle + i ) > > CHUNK_SHIFT ; int index = ( fAttributeListHandle + i ) & CHUNK_MASK ; return fStringPool . toString ( fAttValue [ chunk ] [ index ] ) ; } public String getType ( String name ) { int nameIndex = fStringPool . addSymbol ( name ) ; if ( nameIndex == - 1 ) return null ; int chunk = fAttributeListHandle > > CHUNK_SHIFT ; int index = fAttributeListHandle & CHUNK_MASK ; for ( int i = 0 ; i < fAttributeListLength ; i ++ ) { if ( fStringPool . equalNames ( fAttName [ chunk ] [ index ] , nameIndex ) ) { int attType = fAttType [ chunk ] [ index ] ; if ( attType == fStringPool . addSymbol ( "ENUMERATION" ) ) attType = fStringPool . addSymbol ( "NMTOKEN" ) ; return fStringPool . toString ( attType ) ; } if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } return null ; } public String getValue ( String name ) { int nameIndex = fStringPool . addSymbol ( name ) ; if ( nameIndex == - 1 ) return null ; int chunk = fAttributeListHandle > > CHUNK_SHIFT ; int index = fAttributeListHandle & CHUNK_MASK ; for ( int i = 0 ; i < fAttributeListLength ; i ++ ) { if ( fStringPool . equalNames ( fAttName [ chunk ] [ index ] , nameIndex ) ) return fStringPool . toString ( fAttValue [ chunk ] [ index ] ) ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } return null ; } private boolean ensureCapacity ( int chunk , int index ) { try { return fAttName [ chunk ] [ index ] != 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { int [ ] [ ] newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fAttPrefix , 0 , newIntArray , 0 , chunk ) ; fAttPrefix = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fAttLocalpart , 0 , newIntArray , 0 , chunk ) ; fAttLocalpart = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fAttName , 0 , newIntArray , 0 , chunk ) ; fAttName = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fAttURI , 0 , newIntArray , 0 , chunk ) ; fAttURI = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fAttValue , 0 , newIntArray , 0 , chunk ) ; fAttValue = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fAttType , 0 , newIntArray , 0 , chunk ) ; fAttType = newIntArray ; byte [ ] [ ] newByteArray = new byte [ chunk * 2 ] [ ] ; System . arraycopy ( fAttFlags , 0 , newByteArray , 0 , chunk ) ; fAttFlags = newByteArray ; } catch ( NullPointerException ex ) { } fAttPrefix [ chunk ] = new int [ CHUNK_SIZE ] ; fAttLocalpart [ chunk ] = new int [ CHUNK_SIZE ] ; fAttName [ chunk ] = new int [ CHUNK_SIZE ] ; fAttURI [ chunk ] = new int [ CHUNK_SIZE ] ; fAttValue [ chunk ] = new int [ CHUNK_SIZE ] ; fAttType [ chunk ] = new int [ CHUNK_SIZE ] ; fAttFlags [ chunk ] = new byte [ CHUNK_SIZE ] ; return true ; } } 	0
package org . apache . xerces . framework ; public class Version { public static String fVersion = "Xerces 1.2.0" ; public static void main ( String argv [ ] ) { System . out . println ( fVersion ) ; } } 	1
package org . apache . xerces . dom ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . xerces . utils . StringPool ; import org . w3c . dom . * ; public class DeferredElementNSImpl extends ElementNSImpl implements DeferredNode { static final long serialVersionUID = - 5001885145370927385L ; protected transient int fNodeIndex ; DeferredElementNSImpl ( DeferredDocumentImpl ownerDoc , int nodeIndex ) { super ( ownerDoc , null ) ; fNodeIndex = nodeIndex ; needsSyncChildren ( true ) ; } public final int getNodeIndex ( ) { return fNodeIndex ; } protected final void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; int elementQName = ownerDocument . getNodeName ( fNodeIndex ) ; StringPool pool = ownerDocument . getStringPool ( ) ; name = pool . toString ( elementQName ) ; int index = name . indexOf ( ':' ) ; if ( index < 0 ) { localName = name ; } else { localName = name . substring ( index + 1 ) ; } namespaceURI = pool . toString ( ownerDocument . getNodeURI ( fNodeIndex ) ) ; setupDefaultAttributes ( ) ; int attrIndex = ownerDocument . getNodeValue ( fNodeIndex ) ; if ( attrIndex != - 1 ) { NamedNodeMap attrs = getAttributes ( ) ; do { NodeImpl attr = ( NodeImpl ) ownerDocument . getNodeObject ( attrIndex ) ; attrs . setNamedItem ( attr ) ; attrIndex = ownerDocument . getPrevSibling ( attrIndex ) ; } while ( attrIndex != - 1 ) ; } } protected final void synchronizeChildren ( ) { synchronizeChildren ( fNodeIndex ) ; } } 	0
package org . w3c . dom ; public interface CDATASection extends Text { } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLDivElementImpl extends HTMLElementImpl implements HTMLDivElement { public String getAlign ( ) { return capitalize ( getAttribute ( "align" ) ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public HTMLDivElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . validators . schema . EquivClassComparator ; public class DFAContentModel implements XMLContentModel { private static final int EPSILON = - 2 ; private static final int EOC = - 3 ; private static final boolean DEBUG_VALIDATE_CONTENT = false ; private EquivClassComparator comparator = null ; private QName fElemMap [ ] = null ; private int fElemMapType [ ] = null ; private int fElemMapSize = 0 ; private boolean fDTD ; private int fEOCIndex = 0 ; private int fEOCPos = 0 ; private int fEpsilonIndex = 0 ; private boolean fFinalStateFlags [ ] = null ; private CMStateSet fFollowList [ ] = null ; private CMNode fHeadNode = null ; private int fLeafCount = 0 ; private CMLeaf fLeafList [ ] = null ; private int fLeafListType [ ] = null ; private ContentLeafNameTypeVector fLeafNameTypeVector = null ; private int fTransTable [ ] [ ] = null ; private int fTransTableSize = 0 ; private boolean fEmptyContentIsValid = false ; private QName fQName = new QName ( ) ; public DFAContentModel ( CMNode syntaxTree , int leafCount ) throws CMException { this ( syntaxTree , leafCount , false ) ; } public DFAContentModel ( CMNode syntaxTree , int leafCount , boolean dtd ) throws CMException { fLeafCount = leafCount ; fEpsilonIndex = EPSILON ; fEOCIndex = EOC ; fDTD = dtd ; buildDFA ( syntaxTree ) ; } public int validateContent ( QName children [ ] , int offset , int length ) throws CMException { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "DFAContentModel#validateContent" ) ; if ( length == 0 ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! no children" ) ; System . out . println ( "elemMap=" + fElemMap ) ; for ( int i = 0 ; i < fElemMap . length ; i ++ ) { int uriIndex = fElemMap [ i ] . uri ; int localpartIndex = fElemMap [ i ] . localpart ; } System . out . println ( "EOCIndex=" + fEOCIndex ) ; } return fEmptyContentIsValid ? - 1 : 0 ; } int curState = 0 ; for ( int childIndex = 0 ; childIndex < length ; childIndex ++ ) { final QName curElem = children [ offset + childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { int type = fElemMapType [ elemIndex ] & 0x0f ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fDTD ) { if ( fElemMap [ elemIndex ] . rawname == curElem . rawname ) { break ; } } else { if ( fElemMap [ elemIndex ] . uri == curElem . uri && fElemMap [ elemIndex ] . localpart == curElem . localpart ) break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ elemIndex ] . uri ; if ( uri == - 1 || uri == curElem . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( curElem . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ elemIndex ] . uri != curElem . uri ) { break ; } } } if ( elemIndex == fElemMapSize ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! didn't find it" ) ; System . out . println ( "curElem : " + curElem ) ; for ( int i = 0 ; i < fElemMapSize ; i ++ ) { System . out . println ( "fElemMap[" + i + "] = " + fElemMap [ i ] ) ; System . out . println ( "fElemMapType[" + i + "] = " + fElemMapType [ i ] ) ; } } return childIndex ; } curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "!!! not a legal transition" ) ; return childIndex ; } } if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "curState=" + curState + ", childCount=" + length ) ; if ( ! fFinalStateFlags [ curState ] ) return length ; return - 1 ; } private boolean isEqual ( QName name1 , QName name2 ) { return name1 . localpart == name2 . localpart && name1 . uri == name2 . uri ; } public int validateContentSpecial ( QName children [ ] , int offset , int length ) throws Exception { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "DFAContentModel#validateContentSpecial" ) ; if ( comparator == null ) { return validateContent ( children , offset , length ) ; } if ( length == 0 ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! no children" ) ; System . out . println ( "elemMap=" + fElemMap ) ; for ( int i = 0 ; i < fElemMap . length ; i ++ ) { int uriIndex = fElemMap [ i ] . uri ; int localpartIndex = fElemMap [ i ] . localpart ; } System . out . println ( "EOCIndex=" + fEOCIndex ) ; } return fEmptyContentIsValid ? - 1 : 0 ; } int curState = 0 ; for ( int childIndex = 0 ; childIndex < length ; childIndex ++ ) { final QName curElem = children [ offset + childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { int type = fElemMapType [ elemIndex ] & 0x0f ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( comparator . isEquivalentTo ( curElem , fElemMap [ elemIndex ] ) ) break ; } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ elemIndex ] . uri ; if ( uri == - 1 || uri == curElem . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( curElem . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ elemIndex ] . uri != curElem . uri ) { break ; } } } if ( elemIndex == fElemMapSize ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! didn't find it" ) ; System . out . println ( "curElem : " + curElem ) ; for ( int i = 0 ; i < fElemMapSize ; i ++ ) { System . out . println ( "fElemMap[" + i + "] = " + fElemMap [ i ] ) ; System . out . println ( "fElemMapType[" + i + "] = " + fElemMapType [ i ] ) ; } } return childIndex ; } curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "!!! not a legal transition" ) ; return childIndex ; } } if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "curState=" + curState + ", childCount=" + length ) ; if ( ! fFinalStateFlags [ curState ] ) return length ; return - 1 ; } public void setEquivClassComparator ( EquivClassComparator comparator ) { this . comparator = comparator ; } public int whatCanGoHere ( boolean fullyValid , InsertableElementsInfo info ) throws CMException { int curState = 0 ; for ( int childIndex = 0 ; childIndex < info . insertAt ; childIndex ++ ) { final QName curElem = info . curChildren [ childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { if ( fElemMap [ elemIndex ] . uri == curElem . uri && fElemMap [ elemIndex ] . localpart == curElem . localpart ) break ; } if ( elemIndex == fElemMapSize ) return childIndex ; curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) return childIndex ; } final int insertState = curState ; info . canHoldPCData = false ; info . isValidEOC = fFinalStateFlags [ insertState ] ; info . resultsCount = fElemMapSize ; if ( ( info . results == null ) || ( info . results . length < info . resultsCount ) ) info . results = new boolean [ info . resultsCount ] ; if ( ( info . possibleChildren == null ) || ( info . possibleChildren . length < info . resultsCount ) ) { info . possibleChildren = new QName [ info . resultsCount ] ; for ( int i = 0 ; i < info . possibleChildren . length ; i ++ ) { info . possibleChildren [ i ] = new QName ( ) ; } } for ( int index = 0 ; index < fElemMapSize ; index ++ ) { info . possibleChildren [ index ] . setValues ( fElemMap [ index ] ) ; info . results [ index ] = ( fTransTable [ insertState ] [ index ] != - 1 ) ; } if ( fullyValid ) { for ( int index = 0 ; index < info . resultsCount ; index ++ ) { if ( ! info . results [ index ] ) continue ; info . curChildren [ info . insertAt ] = info . possibleChildren [ index ] ; if ( validateContent ( info . curChildren , 0 , info . childCount ) != - 1 ) info . results [ index ] = false ; } } return - 1 ; } public ContentLeafNameTypeVector getContentLeafNameTypeVector ( ) { return fLeafNameTypeVector ; } private void buildDFA ( CMNode syntaxTree ) throws CMException { fQName . setValues ( - 1 , fEOCIndex , fEOCIndex ) ; CMLeaf nodeEOC = new CMLeaf ( fQName ) ; fHeadNode = new CMBinOp ( XMLContentSpec . CONTENTSPECNODE_SEQ , syntaxTree , nodeEOC ) ; fEOCPos = fLeafCount ; nodeEOC . setPosition ( fLeafCount ++ ) ; fLeafList = new CMLeaf [ fLeafCount ] ; fLeafListType = new int [ fLeafCount ] ; postTreeBuildInit ( fHeadNode , 0 ) ; fFollowList = new CMStateSet [ fLeafCount ] ; for ( int index = 0 ; index < fLeafCount ; index ++ ) fFollowList [ index ] = new CMStateSet ( fLeafCount ) ; calcFollowList ( fHeadNode ) ; fElemMap = new QName [ fLeafCount ] ; fElemMapType = new int [ fLeafCount ] ; fElemMapSize = 0 ; for ( int outIndex = 0 ; outIndex < fLeafCount ; outIndex ++ ) { fElemMap [ outIndex ] = new QName ( ) ; if ( ( fLeafListType [ outIndex ] & 0x0f ) != 0 ) { if ( fLeafNameTypeVector == null ) { fLeafNameTypeVector = new ContentLeafNameTypeVector ( ) ; } } final QName element = fLeafList [ outIndex ] . getElement ( ) ; int inIndex = 0 ; for ( ; inIndex < fElemMapSize ; inIndex ++ ) { if ( fDTD ) { if ( fElemMap [ inIndex ] . rawname == element . rawname ) { break ; } } else { if ( fElemMap [ inIndex ] . uri == element . uri && fElemMap [ inIndex ] . localpart == element . localpart && fElemMapType [ inIndex ] == fLeafListType [ outIndex ] ) break ; } } if ( inIndex == fElemMapSize ) { fElemMap [ fElemMapSize ] . setValues ( element ) ; fElemMapType [ fElemMapSize ] = fLeafListType [ outIndex ] ; fElemMapSize ++ ; } } if ( fLeafNameTypeVector != null ) { fLeafNameTypeVector . setValues ( fElemMap , fElemMapType , fElemMapSize ) ; } int curArraySize = fLeafCount * 4 ; CMStateSet [ ] statesToDo = new CMStateSet [ curArraySize ] ; fFinalStateFlags = new boolean [ curArraySize ] ; fTransTable = new int [ curArraySize ] [ ] ; CMStateSet setT = fHeadNode . firstPos ( ) ; int unmarkedState = 0 ; int curState = 0 ; fTransTable [ curState ] = makeDefStateList ( ) ; statesToDo [ curState ] = setT ; curState ++ ; while ( unmarkedState < curState ) { setT = statesToDo [ unmarkedState ] ; int [ ] transEntry = fTransTable [ unmarkedState ] ; fFinalStateFlags [ unmarkedState ] = setT . getBit ( fEOCPos ) ; unmarkedState ++ ; CMStateSet newSet = null ; for ( int elemIndex = 0 ; elemIndex < fElemMapSize ; elemIndex ++ ) { if ( newSet == null ) newSet = new CMStateSet ( fLeafCount ) ; else newSet . zeroBits ( ) ; for ( int leafIndex = 0 ; leafIndex < fLeafCount ; leafIndex ++ ) { if ( setT . getBit ( leafIndex ) ) { final QName leaf = fLeafList [ leafIndex ] . getElement ( ) ; final QName element = fElemMap [ elemIndex ] ; if ( fDTD ) { if ( leaf . rawname == element . rawname ) { newSet . union ( fFollowList [ leafIndex ] ) ; } } else { if ( leaf . uri == element . uri && leaf . localpart == element . localpart ) newSet . union ( fFollowList [ leafIndex ] ) ; } } } if ( ! newSet . isEmpty ( ) ) { int stateIndex = 0 ; for ( ; stateIndex < curState ; stateIndex ++ ) { if ( statesToDo [ stateIndex ] . isSameSet ( newSet ) ) break ; } if ( stateIndex == curState ) { statesToDo [ curState ] = newSet ; fTransTable [ curState ] = makeDefStateList ( ) ; curState ++ ; newSet = null ; } transEntry [ elemIndex ] = stateIndex ; if ( curState == curArraySize ) { final int newSize = ( int ) ( curArraySize * 1.5 ) ; CMStateSet [ ] newToDo = new CMStateSet [ newSize ] ; boolean [ ] newFinalFlags = new boolean [ newSize ] ; int [ ] [ ] newTransTable = new int [ newSize ] [ ] ; for ( int expIndex = 0 ; expIndex < curArraySize ; expIndex ++ ) { newToDo [ expIndex ] = statesToDo [ expIndex ] ; newFinalFlags [ expIndex ] = fFinalStateFlags [ expIndex ] ; newTransTable [ expIndex ] = fTransTable [ expIndex ] ; } curArraySize = newSize ; statesToDo = newToDo ; fFinalStateFlags = newFinalFlags ; fTransTable = newTransTable ; } } } } fEmptyContentIsValid = ( ( CMBinOp ) fHeadNode ) . getLeft ( ) . isNullable ( ) ; if ( DEBUG_VALIDATE_CONTENT ) dumpTree ( fHeadNode , 0 ) ; fHeadNode = null ; fLeafList = null ; fFollowList = null ; } private void calcFollowList ( CMNode nodeCur ) throws CMException { if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) { calcFollowList ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( CMBinOp ) nodeCur ) . getRight ( ) ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) { calcFollowList ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( CMBinOp ) nodeCur ) . getRight ( ) ) ; final CMStateSet last = ( ( CMBinOp ) nodeCur ) . getLeft ( ) . lastPos ( ) ; final CMStateSet first = ( ( CMBinOp ) nodeCur ) . getRight ( ) . firstPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { calcFollowList ( ( ( CMUniOp ) nodeCur ) . getChild ( ) ) ; final CMStateSet first = nodeCur . firstPos ( ) ; final CMStateSet last = nodeCur . lastPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) || ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) ) { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } } private void dumpTree ( CMNode nodeCur , int level ) throws CMException { for ( int index = 0 ; index < level ; index ++ ) System . out . print ( "   " ) ; int type = nodeCur . type ( ) ; if ( ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( type == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { if ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) System . out . print ( "Choice Node " ) ; else System . out . print ( "Seq Node " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( "Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; dumpTree ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) , level + 1 ) ; dumpTree ( ( ( CMBinOp ) nodeCur ) . getRight ( ) , level + 1 ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { System . out . print ( "Rep Node " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( "Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; dumpTree ( ( ( CMUniOp ) nodeCur ) . getChild ( ) , level + 1 ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { System . out . print ( "Leaf: (pos=" + ( ( CMLeaf ) nodeCur ) . getPosition ( ) + "), " + ( ( CMLeaf ) nodeCur ) . getElement ( ) + "(elemIndex=" + ( ( CMLeaf ) nodeCur ) . getElement ( ) + ") " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( " Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; } else { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } } private int [ ] makeDefStateList ( ) { int [ ] retArray = new int [ fElemMapSize ] ; for ( int index = 0 ; index < fElemMapSize ; index ++ ) retArray [ index ] = - 1 ; return retArray ; } private int postTreeBuildInit ( CMNode nodeCur , int curIndex ) throws CMException { nodeCur . setMaxStates ( fLeafCount ) ; if ( ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY || ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL || ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { QName qname = new QName ( - 1 , - 1 , - 1 , ( ( CMAny ) nodeCur ) . getURI ( ) ) ; fLeafList [ curIndex ] = new CMLeaf ( qname , ( ( CMAny ) nodeCur ) . getPosition ( ) ) ; fLeafListType [ curIndex ] = nodeCur . type ( ) ; curIndex ++ ; } else if ( ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { curIndex = postTreeBuildInit ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) , curIndex ) ; curIndex = postTreeBuildInit ( ( ( CMBinOp ) nodeCur ) . getRight ( ) , curIndex ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { curIndex = postTreeBuildInit ( ( ( CMUniOp ) nodeCur ) . getChild ( ) , curIndex ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { final QName node = ( ( CMLeaf ) nodeCur ) . getElement ( ) ; if ( node . localpart != fEpsilonIndex ) { fLeafList [ curIndex ] = ( CMLeaf ) nodeCur ; fLeafListType [ curIndex ] = XMLContentSpec . CONTENTSPECNODE_LEAF ; curIndex ++ ; } } else { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } return curIndex ; } } 	1
package org . w3c . dom . html ; public interface HTMLFrameElement extends HTMLElement { public String getFrameBorder ( ) ; public void setFrameBorder ( String frameBorder ) ; public String getLongDesc ( ) ; public void setLongDesc ( String longDesc ) ; public String getMarginHeight ( ) ; public void setMarginHeight ( String marginHeight ) ; public String getMarginWidth ( ) ; public void setMarginWidth ( String marginWidth ) ; public String getName ( ) ; public void setName ( String name ) ; public boolean getNoResize ( ) ; public void setNoResize ( boolean noResize ) ; public String getScrolling ( ) ; public void setScrolling ( String scrolling ) ; public String getSrc ( ) ; public void setSrc ( String src ) ; } 	0
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLDocumentScanner ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . readers . DefaultEntityHandler ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . ChunkyCharArray ; import org . apache . xerces . utils . Hash2intTable ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . parsers . DOMParser ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . InputSource ; import org . xml . sax . EntityResolver ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xerces . validators . dtd . DTDGrammar ; import org . apache . xerces . validators . schema . EquivClassComparator ; import org . apache . xerces . validators . schema . SchemaGrammar ; import org . apache . xerces . validators . schema . SchemaMessageProvider ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . schema . TraverseSchema ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . validators . datatype . StateMessageDatatype ; import org . apache . xerces . validators . datatype . IDREFDatatypeValidator ; import org . apache . xerces . validators . datatype . IDDatatypeValidator ; import org . apache . xerces . validators . datatype . ENTITYDatatypeValidator ; public final class XMLValidator implements DefaultEntityHandler . EventHandler , XMLEntityHandler . CharDataHandler , XMLDocumentScanner . EventHandler , NamespacesScope . NamespacesHandler { private static final boolean PRINT_EXCEPTION_STACK_TRACE = false ; private static final boolean DEBUG_PRINT_ATTRIBUTES = false ; private static final boolean DEBUG_PRINT_CONTENT = false ; private static final boolean DEBUG_SCHEMA_VALIDATION = false ; private static final boolean DEBUG_ELEMENT_CHILDREN = false ; private static final int CHUNK_SHIFT = 8 ; private static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; private static final int CHUNK_MASK = CHUNK_SIZE - 1 ; private static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; private Hashtable fIdDefs = null ; private StateMessageDatatype fStoreIDRef = new StateMessageDatatype ( ) { private Hashtable fIdDefs ; public Object getDatatypeObject ( ) { return ( Object ) fIdDefs ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_STORE ; } public void setDatatypeObject ( Object data ) { fIdDefs = ( Hashtable ) data ; } } ; private StateMessageDatatype fResetID = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDDatatypeValidator . ID_CLEAR ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fResetIDRef = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_CLEAR ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fValidateIDRef = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_VALIDATE ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fValidateENTITYMsg = new StateMessageDatatype ( ) { private Object packagedMessage = null ; public Object getDatatypeObject ( ) { return packagedMessage ; } public int getDatatypeState ( ) { return ENTITYDatatypeValidator . ENTITY_INITIALIZE ; } public void setDatatypeObject ( Object data ) { packagedMessage = data ; } } ; private AttributeValidator fAttValidatorNOTATION = new AttValidatorNOTATION ( ) ; private AttributeValidator fAttValidatorENUMERATION = new AttValidatorENUMERATION ( ) ; private AttributeValidator fAttValidatorDATATYPE = null ; StringPool fStringPool = null ; boolean fValidating = false ; boolean fInElementContent = false ; int fStandaloneReader = - 1 ; private boolean fValidationEnabled = false ; private boolean fDynamicValidation = false ; private boolean fSchemaValidation = true ; private boolean fValidationEnabledByDynamic = false ; private boolean fDynamicDisabledByValidation = false ; private boolean fWarningOnDuplicateAttDef = false ; private boolean fWarningOnUndeclaredElements = false ; private boolean fLoadDTDGrammar = true ; private int fDeclaration [ ] ; private XMLErrorReporter fErrorReporter = null ; private DefaultEntityHandler fEntityHandler = null ; private QName fCurrentElement = new QName ( ) ; private ContentLeafNameTypeVector [ ] fContentLeafStack = new ContentLeafNameTypeVector [ 8 ] ; private int [ ] fValidationFlagStack = new int [ 8 ] ; private int [ ] fScopeStack = new int [ 8 ] ; private int [ ] fGrammarNameSpaceIndexStack = new int [ 8 ] ; private int [ ] fElementEntityStack = new int [ 8 ] ; private int [ ] fElementIndexStack = new int [ 8 ] ; private int [ ] fContentSpecTypeStack = new int [ 8 ] ; private static final int sizeQNameParts = 8 ; private QName [ ] fElementQNamePartsStack = new QName [ sizeQNameParts ] ; private QName [ ] fElementChildren = new QName [ 32 ] ; private int fElementChildrenLength = 0 ; private int [ ] fElementChildrenOffsetStack = new int [ 32 ] ; private int fElementDepth = - 1 ; private boolean fNamespacesEnabled = false ; private NamespacesScope fNamespacesScope = null ; private int fNamespacesPrefix = - 1 ; private QName fRootElement = new QName ( ) ; private int fAttrListHandle = - 1 ; private int fCurrentElementEntity = - 1 ; private int fCurrentElementIndex = - 1 ; private int fCurrentContentSpecType = - 1 ; private boolean fSeenDoctypeDecl = false ; private final int TOP_LEVEL_SCOPE = - 1 ; private int fCurrentScope = TOP_LEVEL_SCOPE ; private int fCurrentSchemaURI = - 1 ; private int fEmptyURI = - 1 ; private int fXsiPrefix = - 1 ; private int fXsiURI = - 2 ; private int fXsiTypeAttValue = - 1 ; private DatatypeValidator fXsiTypeValidator = null ; private Grammar fGrammar = null ; private int fGrammarNameSpaceIndex = - 1 ; private GrammarResolver fGrammarResolver = null ; private boolean fScanningDTD = false ; private XMLDocumentScanner fDocumentScanner = null ; private boolean fCalledStartDocument = false ; private XMLDocumentHandler fDocumentHandler = null ; private XMLDocumentHandler . DTDHandler fDTDHandler = null ; private boolean fSeenRootElement = false ; private XMLAttrList fAttrList = null ; private int fXMLLang = - 1 ; private LocatorImpl fAttrNameLocator = null ; private boolean fCheckedForSchema = false ; private boolean fDeclsAreExternal = false ; private StringPool . CharArrayRange fCurrentElementCharArrayRange = null ; private char [ ] fCharRefData = null ; private boolean fSendCharDataAsCharArray = false ; private boolean fBufferDatatype = false ; private StringBuffer fDatatypeBuffer = new StringBuffer ( ) ; private QName fTempQName = new QName ( ) ; private XMLAttributeDecl fTempAttDecl = new XMLAttributeDecl ( ) ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; private boolean fGrammarIsDTDGrammar = false ; private boolean fGrammarIsSchemaGrammar = false ; private boolean fNeedValidationOff = false ; private int fEMPTYSymbol = - 1 ; private int fANYSymbol = - 1 ; private int fMIXEDSymbol = - 1 ; private int fCHILDRENSymbol = - 1 ; private int fCDATASymbol = - 1 ; private int fIDSymbol = - 1 ; private int fIDREFSymbol = - 1 ; private int fIDREFSSymbol = - 1 ; private int fENTITYSymbol = - 1 ; private int fENTITIESSymbol = - 1 ; private int fNMTOKENSymbol = - 1 ; private int fNMTOKENSSymbol = - 1 ; private int fNOTATIONSymbol = - 1 ; private int fENUMERATIONSymbol = - 1 ; private int fREQUIREDSymbol = - 1 ; private int fFIXEDSymbol = - 1 ; private int fDATATYPESymbol = - 1 ; private int fEpsilonIndex = - 1 ; private DatatypeValidatorFactoryImpl fDataTypeReg = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; private DatatypeValidator fValID = this . fDataTypeReg . getDatatypeValidator ( "ID" ) ; private DatatypeValidator fValIDRef = this . fDataTypeReg . getDatatypeValidator ( "IDREF" ) ; private DatatypeValidator fValIDRefs = this . fDataTypeReg . getDatatypeValidator ( "IDREFS" ) ; private DatatypeValidator fValENTITY = this . fDataTypeReg . getDatatypeValidator ( "ENTITY" ) ; private DatatypeValidator fValENTITIES = this . fDataTypeReg . getDatatypeValidator ( "ENTITIES" ) ; private DatatypeValidator fValNMTOKEN = this . fDataTypeReg . getDatatypeValidator ( "NMTOKEN" ) ; private DatatypeValidator fValNMTOKENS = this . fDataTypeReg . getDatatypeValidator ( "NMTOKENS" ) ; private DatatypeValidator fValNOTATION = this . fDataTypeReg . getDatatypeValidator ( "NOTATION" ) ; public XMLValidator ( StringPool stringPool , XMLErrorReporter errorReporter , DefaultEntityHandler entityHandler , XMLDocumentScanner documentScanner ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fEntityHandler = entityHandler ; fDocumentScanner = documentScanner ; fEmptyURI = fStringPool . addSymbol ( "" ) ; fXsiURI = fStringPool . addSymbol ( SchemaSymbols . URI_XSI ) ; fAttrList = new XMLAttrList ( fStringPool ) ; entityHandler . setEventHandler ( this ) ; entityHandler . setCharDataHandler ( this ) ; fDocumentScanner . setEventHandler ( this ) ; for ( int i = 0 ; i < sizeQNameParts ; i ++ ) { fElementQNamePartsStack [ i ] = new QName ( ) ; } init ( ) ; } public void setGrammarResolver ( GrammarResolver grammarResolver ) { fGrammarResolver = grammarResolver ; } public void initHandlers ( boolean sendCharDataAsCharArray , XMLDocumentHandler docHandler , XMLDocumentHandler . DTDHandler dtdHandler ) { fSendCharDataAsCharArray = sendCharDataAsCharArray ; fEntityHandler . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; fDocumentHandler = docHandler ; fDTDHandler = dtdHandler ; } public void resetOrCopy ( StringPool stringPool ) throws Exception { fAttrList = new XMLAttrList ( stringPool ) ; resetCommon ( stringPool ) ; } public void reset ( StringPool stringPool ) throws Exception { fAttrList . reset ( stringPool ) ; resetCommon ( stringPool ) ; } public void setValidationEnabled ( boolean flag ) throws Exception { fValidationEnabled = flag ; fValidationEnabledByDynamic = false ; if ( fValidationEnabled ) { if ( fDynamicDisabledByValidation ) { fDynamicValidation = true ; fDynamicDisabledByValidation = false ; } } else if ( fDynamicValidation ) { fDynamicValidation = false ; fDynamicDisabledByValidation = true ; } fValidating = fValidationEnabled ; } public boolean getValidationEnabled ( ) { return fValidationEnabled ; } public void setSchemaValidationEnabled ( boolean flag ) { fSchemaValidation = flag ; } public boolean getSchemaValidationEnabled ( ) { return fSchemaValidation ; } public void setDynamicValidationEnabled ( boolean flag ) throws Exception { fDynamicValidation = flag ; fDynamicDisabledByValidation = false ; if ( ! fDynamicValidation ) { if ( fValidationEnabledByDynamic ) { fValidationEnabled = false ; fValidationEnabledByDynamic = false ; } } else if ( ! fValidationEnabled ) { fValidationEnabled = true ; fValidationEnabledByDynamic = true ; } fValidating = fValidationEnabled ; } public boolean getDynamicValidationEnabled ( ) { return fDynamicValidation ; } public void setLoadDTDGrammar ( boolean loadDG ) { if ( fValidating ) { fLoadDTDGrammar = true ; } else { fLoadDTDGrammar = loadDG ; } } public boolean getLoadDTDGrammar ( ) { return fLoadDTDGrammar ; } public void setNamespacesEnabled ( boolean flag ) { fNamespacesEnabled = flag ; } public boolean getNamespacesEnabled ( ) { return fNamespacesEnabled ; } public void setWarningOnDuplicateAttDef ( boolean flag ) { fWarningOnDuplicateAttDef = flag ; } public boolean getWarningOnDuplicateAttDef ( ) { return fWarningOnDuplicateAttDef ; } public void setWarningOnUndeclaredElements ( boolean flag ) { fWarningOnUndeclaredElements = flag ; } public boolean getWarningOnUndeclaredElements ( ) { return fWarningOnUndeclaredElements ; } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { fDocumentHandler . startEntityReference ( entityName , entityType , entityContext ) ; } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { fDocumentHandler . endEntityReference ( entityName , entityType , entityContext ) ; } public void sendEndOfInputNotifications ( int entityName , boolean moreToFollow ) throws Exception { fDocumentScanner . endOfInput ( entityName , moreToFollow ) ; } public void sendReaderChangeNotifications ( XMLEntityHandler . EntityReader reader , int readerId ) throws Exception { fDocumentScanner . readerChange ( reader , readerId ) ; } public boolean externalEntityStandaloneCheck ( ) { return ( fStandaloneReader != - 1 && fValidating ) ; } public boolean getValidating ( ) { return fValidating ; } public void processCharacters ( char [ ] chars , int offset , int length ) throws Exception { if ( fValidating ) { if ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } if ( fBufferDatatype ) { fDatatypeBuffer . append ( chars , offset , length ) ; } } fDocumentHandler . characters ( chars , offset , length ) ; } public void processCharacters ( int data ) throws Exception { if ( fValidating ) { if ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } if ( fBufferDatatype ) { fDatatypeBuffer . append ( fStringPool . toString ( data ) ) ; } } fDocumentHandler . characters ( data ) ; } public void processWhitespace ( char [ ] chars , int offset , int length ) throws Exception { if ( fInElementContent ) { if ( fStandaloneReader != - 1 && fValidating && getElementDeclIsExternal ( fCurrentElementIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION ) ; } fDocumentHandler . ignorableWhitespace ( chars , offset , length ) ; } else { if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } fDocumentHandler . characters ( chars , offset , length ) ; } } public void processWhitespace ( int data ) throws Exception { if ( fInElementContent ) { if ( fStandaloneReader != - 1 && fValidating && getElementDeclIsExternal ( fCurrentElementIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION ) ; } fDocumentHandler . ignorableWhitespace ( data ) ; } else { if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } fDocumentHandler . characters ( data ) ; } } public void scanElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( ! fNamespacesEnabled ) { element . clear ( ) ; element . localpart = entityReader . scanName ( fastchar ) ; element . rawname = element . localpart ; } else { entityReader . scanQName ( fastchar , element ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } public boolean scanExpectedElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( fCurrentElementCharArrayRange == null ) { fCurrentElementCharArrayRange = fStringPool . createCharArrayRange ( ) ; } fStringPool . getCharArrayRange ( fCurrentElement . rawname , fCurrentElementCharArrayRange ) ; return entityReader . scanExpectedName ( fastchar , fCurrentElementCharArrayRange ) ; } public void scanAttributeName ( XMLEntityHandler . EntityReader entityReader , QName element , QName attribute ) throws Exception { if ( ! fSeenRootElement ) { fSeenRootElement = true ; rootElementSpecified ( element ) ; fStringPool . resetShuffleCount ( ) ; } if ( ! fNamespacesEnabled ) { attribute . clear ( ) ; attribute . localpart = entityReader . scanName ( '=' ) ; attribute . rawname = attribute . localpart ; } else { entityReader . scanQName ( '=' , attribute ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } public void callStartDocument ( ) throws Exception { if ( ! fCalledStartDocument ) { fDocumentHandler . startDocument ( ) ; fCalledStartDocument = true ; } } public void callEndDocument ( ) throws Exception { if ( fCalledStartDocument ) { fDocumentHandler . endDocument ( ) ; } } public void callXMLDecl ( int version , int encoding , int standalone ) throws Exception { fDocumentHandler . xmlDecl ( version , encoding , standalone ) ; } public void callStandaloneIsYes ( ) throws Exception { fStandaloneReader = fEntityHandler . getReaderId ( ) ; } public void callTextDecl ( int version , int encoding ) throws Exception { fDocumentHandler . textDecl ( version , encoding ) ; } public void element ( QName element ) throws Exception { fAttrListHandle = - 1 ; } public boolean attribute ( QName element , QName attrName , int attrValue ) throws Exception { if ( fAttrListHandle == - 1 ) { fAttrListHandle = fAttrList . startAttrList ( ) ; } return fAttrList . addAttr ( attrName , attrValue , fCDATASymbol , true , true ) == - 1 ; } public void callStartElement ( QName element ) throws Exception { if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "\n=======StartElement : " + fStringPool . toString ( element . localpart ) ) ; if ( ! fSeenRootElement ) { fSeenRootElement = true ; rootElementSpecified ( element ) ; fStringPool . resetShuffleCount ( ) ; } if ( fGrammar != null && fGrammarIsDTDGrammar ) { fAttrListHandle = addDTDDefaultAttributes ( element , fAttrList , fAttrListHandle , fValidating , fStandaloneReader != - 1 ) ; } fCheckedForSchema = true ; if ( fNamespacesEnabled ) { bindNamespacesToElementAndAttributes ( element , fAttrList ) ; } validateElementAndAttributes ( element , fAttrList ) ; if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; } fDocumentHandler . startElement ( element , fAttrList , fAttrListHandle ) ; fAttrListHandle = - 1 ; fElementDepth ++ ; if ( fValidating ) { if ( fElementChildrenOffsetStack . length < fElementDepth ) { int newarray [ ] = new int [ fElementChildrenOffsetStack . length * 2 ] ; System . arraycopy ( fElementChildrenOffsetStack , 0 , newarray , 0 , fElementChildrenOffsetStack . length ) ; fElementChildrenOffsetStack = newarray ; } fElementChildrenOffsetStack [ fElementDepth ] = fElementChildrenLength ; if ( fElementChildren . length <= fElementChildrenLength ) { QName [ ] newarray = new QName [ fElementChildrenLength * 2 ] ; System . arraycopy ( fElementChildren , 0 , newarray , 0 , fElementChildren . length ) ; fElementChildren = newarray ; } QName qname = fElementChildren [ fElementChildrenLength ] ; if ( qname == null ) { for ( int i = fElementChildrenLength ; i < fElementChildren . length ; i ++ ) { fElementChildren [ i ] = new QName ( ) ; } qname = fElementChildren [ fElementChildrenLength ] ; } qname . setValues ( element ) ; fElementChildrenLength ++ ; if ( DEBUG_ELEMENT_CHILDREN ) { printChildren ( ) ; printStack ( ) ; } } ensureStackCapacity ( fElementDepth ) ; fCurrentElement . setValues ( element ) ; fCurrentElementEntity = fEntityHandler . getReaderId ( ) ; fElementQNamePartsStack [ fElementDepth ] . setValues ( fCurrentElement ) ; fElementEntityStack [ fElementDepth ] = fCurrentElementEntity ; fElementIndexStack [ fElementDepth ] = fCurrentElementIndex ; fContentSpecTypeStack [ fElementDepth ] = fCurrentContentSpecType ; if ( fNeedValidationOff ) { fValidating = false ; fNeedValidationOff = false ; } if ( fValidating && fGrammarIsSchemaGrammar ) { pushContentLeafStack ( ) ; } fValidationFlagStack [ fElementDepth ] = fValidating ? 0 : - 1 ; fScopeStack [ fElementDepth ] = fCurrentScope ; fGrammarNameSpaceIndexStack [ fElementDepth ] = fGrammarNameSpaceIndex ; } private void pushContentLeafStack ( ) throws Exception { int contentType = getContentSpecType ( fCurrentElementIndex ) ; if ( contentType == XMLElementDecl . TYPE_CHILDREN ) { XMLContentModel cm = getElementContentModel ( fCurrentElementIndex ) ; ContentLeafNameTypeVector cv = cm . getContentLeafNameTypeVector ( ) ; if ( cm != null ) { fContentLeafStack [ fElementDepth ] = cv ; } } } private void ensureStackCapacity ( int newElementDepth ) { if ( newElementDepth == fElementQNamePartsStack . length ) { int [ ] newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fScopeStack , 0 , newStack , 0 , newElementDepth ) ; fScopeStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fGrammarNameSpaceIndexStack , 0 , newStack , 0 , newElementDepth ) ; fGrammarNameSpaceIndexStack = newStack ; QName [ ] newStackOfQueue = new QName [ newElementDepth * 2 ] ; System . arraycopy ( this . fElementQNamePartsStack , 0 , newStackOfQueue , 0 , newElementDepth ) ; fElementQNamePartsStack = newStackOfQueue ; QName qname = fElementQNamePartsStack [ newElementDepth ] ; if ( qname == null ) { for ( int i = newElementDepth ; i < fElementQNamePartsStack . length ; i ++ ) { fElementQNamePartsStack [ i ] = new QName ( ) ; } } newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fElementEntityStack , 0 , newStack , 0 , newElementDepth ) ; fElementEntityStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fElementIndexStack , 0 , newStack , 0 , newElementDepth ) ; fElementIndexStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fContentSpecTypeStack , 0 , newStack , 0 , newElementDepth ) ; fContentSpecTypeStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fValidationFlagStack , 0 , newStack , 0 , newElementDepth ) ; fValidationFlagStack = newStack ; ContentLeafNameTypeVector [ ] newStackV = new ContentLeafNameTypeVector [ newElementDepth * 2 ] ; System . arraycopy ( fContentLeafStack , 0 , newStackV , 0 , newElementDepth ) ; fContentLeafStack = newStackV ; } } public void callEndElement ( int readerId ) throws Exception { if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "=======EndElement : " + fStringPool . toString ( fCurrentElement . localpart ) + "\n" ) ; int prefixIndex = fCurrentElement . prefix ; int elementType = fCurrentElement . rawname ; if ( fCurrentElementEntity != readerId ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ELEMENT_ENTITY_MISMATCH , XMLMessages . P78_NOT_WELLFORMED , new Object [ ] { fStringPool . toString ( elementType ) } , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } fElementDepth -- ; if ( fValidating ) { int elementIndex = fCurrentElementIndex ; if ( elementIndex != - 1 && fCurrentContentSpecType != - 1 ) { QName children [ ] = fElementChildren ; int childrenOffset = fElementChildrenOffsetStack [ fElementDepth + 1 ] + 1 ; int childrenLength = fElementChildrenLength - childrenOffset ; if ( DEBUG_ELEMENT_CHILDREN ) { System . out . println ( "endElement(" + fStringPool . toString ( fCurrentElement . rawname ) + ')' ) ; System . out . println ( "fCurrentContentSpecType : " + fCurrentContentSpecType ) ; System . out . print ( "offset: " ) ; System . out . print ( childrenOffset ) ; System . out . print ( ", length: " ) ; System . out . print ( childrenLength ) ; System . out . println ( ) ; printChildren ( ) ; printStack ( ) ; } int result = checkContent ( elementIndex , children , childrenOffset , childrenLength ) ; if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "!!!!!!!!In XMLValidator, the return value from checkContent : " + result ) ; if ( result != - 1 ) { int majorCode = result != childrenLength ? XMLMessages . MSG_CONTENT_INVALID : XMLMessages . MSG_CONTENT_INCOMPLETE ; fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; if ( fTempElementDecl . type == XMLElementDecl . TYPE_EMPTY ) { reportRecoverableXMLError ( majorCode , 0 , fStringPool . toString ( elementType ) , "EMPTY" ) ; } else reportRecoverableXMLError ( majorCode , 0 , fStringPool . toString ( elementType ) , XMLContentSpec . toString ( fGrammar , fStringPool , fTempElementDecl . contentSpecIndex ) ) ; } } fElementChildrenLength = fElementChildrenOffsetStack [ fElementDepth + 1 ] + 1 ; } fDocumentHandler . endElement ( fCurrentElement ) ; if ( fNamespacesEnabled ) { fNamespacesScope . decreaseDepth ( ) ; } if ( fElementDepth < - 1 ) { throw new RuntimeException ( "FWK008 Element stack underflow" ) ; } if ( fElementDepth < 0 ) { fCurrentElement . clear ( ) ; fCurrentElementEntity = - 1 ; fCurrentElementIndex = - 1 ; fCurrentContentSpecType = - 1 ; fInElementContent = false ; if ( fValidating ) { try { this . fValIDRef . validate ( null , this . fValidateIDRef ) ; this . fValIDRefs . validate ( null , this . fValidateIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , ex . getMessage ( ) ) ; } } try { this . fValID . validate ( null , this . fResetID ) ; this . fValIDRef . validate ( null , this . fResetIDRef ) ; this . fValIDRefs . validate ( null , this . fResetIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error re-Initializing: ID,IDRef,IDRefs pools" ) ; } return ; } fCurrentElement . prefix = - 1 ; if ( fNamespacesEnabled ) { fCurrentElement . localpart = fElementQNamePartsStack [ fElementDepth ] . localpart ; } else { fCurrentElement . localpart = fElementQNamePartsStack [ fElementDepth ] . rawname ; } fCurrentElement . rawname = fElementQNamePartsStack [ fElementDepth ] . rawname ; fCurrentElement . uri = fElementQNamePartsStack [ fElementDepth ] . uri ; fCurrentElement . prefix = fElementQNamePartsStack [ fElementDepth ] . prefix ; fCurrentElementEntity = fElementEntityStack [ fElementDepth ] ; fCurrentElementIndex = fElementIndexStack [ fElementDepth ] ; fCurrentContentSpecType = fContentSpecTypeStack [ fElementDepth ] ; fValidating = fValidationFlagStack [ fElementDepth ] == 0 ? true : false ; fCurrentScope = fScopeStack [ fElementDepth ] ; if ( fGrammarNameSpaceIndex != fGrammarNameSpaceIndexStack [ fElementDepth ] ) { fGrammarNameSpaceIndex = fGrammarNameSpaceIndexStack [ fElementDepth ] ; if ( fValidating && fGrammarIsSchemaGrammar ) if ( ! switchGrammar ( fGrammarNameSpaceIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fGrammarNameSpaceIndex ) + " , can not found" ) ; } } if ( fValidating ) { fBufferDatatype = false ; } fInElementContent = ( fCurrentContentSpecType == XMLElementDecl . TYPE_CHILDREN ) ; } public void callStartCDATA ( ) throws Exception { fDocumentHandler . startCDATA ( ) ; } public void callEndCDATA ( ) throws Exception { fDocumentHandler . endCDATA ( ) ; } public void callCharacters ( int ch ) throws Exception { if ( fCharRefData == null ) { fCharRefData = new char [ 2 ] ; } int count = ( ch < 0x10000 ) ? 1 : 2 ; if ( count == 1 ) { fCharRefData [ 0 ] = ( char ) ch ; } else { fCharRefData [ 0 ] = ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; fCharRefData [ 1 ] = ( char ) ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; } if ( fValidating && ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) ) { charDataInContent ( ) ; } if ( fSendCharDataAsCharArray ) { fDocumentHandler . characters ( fCharRefData , 0 , count ) ; } else { int index = fStringPool . addString ( new String ( fCharRefData , 0 , count ) ) ; fDocumentHandler . characters ( index ) ; } } public void callProcessingInstruction ( int target , int data ) throws Exception { fDocumentHandler . processingInstruction ( target , data ) ; } public void callComment ( int comment ) throws Exception { fDocumentHandler . comment ( comment ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { fDocumentHandler . startNamespaceDeclScope ( prefix , uri ) ; } public void endNamespaceDeclScope ( int prefix ) throws Exception { fDocumentHandler . endNamespaceDeclScope ( prefix ) ; } public void setRootElementType ( QName rootElement ) { fRootElement . setValues ( rootElement ) ; } private boolean getElementDeclIsExternal ( int elementIndex ) { if ( fGrammarIsDTDGrammar ) { return ( ( DTDGrammar ) fGrammar ) . getElementDeclIsExternal ( elementIndex ) ; } return false ; } public int getContentSpecType ( int elementIndex ) { int contentSpecType = - 1 ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentSpecType = fTempElementDecl . type ; } } return contentSpecType ; } public int getContentSpecHandle ( int elementIndex ) { int contentSpecHandle = - 1 ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentSpecHandle = fTempElementDecl . contentSpecIndex ; } } return contentSpecHandle ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode ) throws Exception { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , null , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 ) throws Exception { Object [ ] args = { string1 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 , int stringIndex2 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) , fStringPool . toString ( stringIndex2 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 ) throws Exception { Object [ ] args = { string1 , string2 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 , String string3 ) throws Exception { Object [ ] args = { string1 , string2 , string3 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected int whatCanGoHere ( int elementIndex , boolean fullyValid , InsertableElementsInfo info ) throws Exception { if ( info . insertAt > info . childCount || info . curChildren == null || info . childCount < 1 || info . childCount > info . curChildren . length ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . VAL_WCGHI , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } int retVal = 0 ; try { final XMLContentModel cmElem = getElementContentModel ( elementIndex ) ; retVal = cmElem . whatCanGoHere ( fullyValid , info ) ; } catch ( CMException excToCatch ) { int majorCode = excToCatch . getErrorCode ( ) ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , majorCode , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; throw excToCatch ; } return retVal ; } protected boolean getAttDefIsExternal ( QName element , QName attribute ) { int attDefIndex = getAttDef ( element , attribute ) ; if ( fGrammarIsDTDGrammar ) { return ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attDefIndex ) ; } return false ; } private boolean usingStandaloneReader ( ) { return fStandaloneReader == - 1 || fEntityHandler . getReaderId ( ) == fStandaloneReader ; } private LocatorImpl getLocatorImpl ( LocatorImpl fillin ) { Locator here = fErrorReporter . getLocator ( ) ; if ( fillin == null ) return new LocatorImpl ( here ) ; fillin . setPublicId ( here . getPublicId ( ) ) ; fillin . setSystemId ( here . getSystemId ( ) ) ; fillin . setLineNumber ( here . getLineNumber ( ) ) ; fillin . setColumnNumber ( here . getColumnNumber ( ) ) ; return fillin ; } private void poolReset ( ) { try { this . fValID . validate ( null , this . fResetID ) ; this . fValIDRef . validate ( null , this . fResetIDRef ) ; this . fValIDRefs . validate ( null , this . fResetIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error re-Initializing: ID,IDRef,IDRefs pools" ) ; } } private void resetCommon ( StringPool stringPool ) throws Exception { fStringPool = stringPool ; fValidating = fValidationEnabled ; fValidationEnabledByDynamic = false ; fDynamicDisabledByValidation = false ; poolReset ( ) ; fCalledStartDocument = false ; fStandaloneReader = - 1 ; fElementChildrenLength = 0 ; fElementDepth = - 1 ; fSeenRootElement = false ; fSeenDoctypeDecl = false ; fNamespacesScope = null ; fNamespacesPrefix = - 1 ; fRootElement . clear ( ) ; fAttrListHandle = - 1 ; fCheckedForSchema = false ; fCurrentScope = TOP_LEVEL_SCOPE ; fCurrentSchemaURI = - 1 ; fEmptyURI = - 1 ; fXsiPrefix = - 1 ; fXsiTypeValidator = null ; fGrammar = null ; fGrammarNameSpaceIndex = - 1 ; if ( fGrammarResolver != null ) { fGrammarResolver . clearGrammarResolver ( ) ; } fGrammarIsDTDGrammar = false ; fGrammarIsSchemaGrammar = false ; init ( ) ; } private void init ( ) { fEmptyURI = fStringPool . addSymbol ( "" ) ; fXsiURI = fStringPool . addSymbol ( SchemaSymbols . URI_XSI ) ; fEMPTYSymbol = fStringPool . addSymbol ( "EMPTY" ) ; fANYSymbol = fStringPool . addSymbol ( "ANY" ) ; fMIXEDSymbol = fStringPool . addSymbol ( "MIXED" ) ; fCHILDRENSymbol = fStringPool . addSymbol ( "CHILDREN" ) ; fCDATASymbol = fStringPool . addSymbol ( "CDATA" ) ; fIDSymbol = fStringPool . addSymbol ( "ID" ) ; fIDREFSymbol = fStringPool . addSymbol ( "IDREF" ) ; fIDREFSSymbol = fStringPool . addSymbol ( "IDREFS" ) ; fENTITYSymbol = fStringPool . addSymbol ( "ENTITY" ) ; fENTITIESSymbol = fStringPool . addSymbol ( "ENTITIES" ) ; fNMTOKENSymbol = fStringPool . addSymbol ( "NMTOKEN" ) ; fNMTOKENSSymbol = fStringPool . addSymbol ( "NMTOKENS" ) ; fNOTATIONSymbol = fStringPool . addSymbol ( "NOTATION" ) ; fENUMERATIONSymbol = fStringPool . addSymbol ( "ENUMERATION" ) ; fREQUIREDSymbol = fStringPool . addSymbol ( "#REQUIRED" ) ; fFIXEDSymbol = fStringPool . addSymbol ( "#FIXED" ) ; fDATATYPESymbol = fStringPool . addSymbol ( "<<datatype>>" ) ; fEpsilonIndex = fStringPool . addSymbol ( "<<CMNODE_EPSILON>>" ) ; fXMLLang = fStringPool . addSymbol ( "xml:lang" ) ; try { Object [ ] packageArgsEntityVal = { ( Object ) this . fEntityHandler , ( Object ) this . fStringPool } ; fValidateENTITYMsg . setDatatypeObject ( ( Object ) packageArgsEntityVal ) ; fValENTITIES . validate ( null , fValidateENTITYMsg ) ; fValENTITY . validate ( null , fValidateENTITYMsg ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } private int addDefaultAttributes ( int elementIndex , XMLAttrList attrList , int attrIndex , boolean validationEnabled , boolean standalone ) throws Exception { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; int elementNameIndex = fTempElementDecl . name . localpart ; int attlistIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int firstCheck = attrIndex ; int lastCheck = - 1 ; while ( attlistIndex != - 1 ) { fGrammar . getAttributeDecl ( attlistIndex , fTempAttDecl ) ; int attPrefix = fTempAttDecl . name . prefix ; int attName = fTempAttDecl . name . localpart ; int attType = attributeTypeName ( fTempAttDecl ) ; int attDefType = fTempAttDecl . defaultType ; int attValue = - 1 ; if ( fTempAttDecl . defaultValue != null ) { attValue = fStringPool . addSymbol ( fTempAttDecl . defaultValue ) ; } boolean specified = false ; boolean required = attDefType == XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; if ( firstCheck != - 1 ) { boolean cdata = attType == fCDATASymbol ; if ( ! cdata || required || attValue != - 1 ) { int i = attrList . getFirstAttr ( firstCheck ) ; while ( i != - 1 && ( lastCheck == - 1 || i <= lastCheck ) ) { if ( ( fGrammarIsDTDGrammar && ( attrList . getAttrName ( i ) == fTempAttDecl . name . rawname ) ) || ( fStringPool . equalNames ( attrList . getAttrLocalpart ( i ) , attName ) && fStringPool . equalNames ( attrList . getAttrURI ( i ) , fTempAttDecl . name . uri ) ) ) { if ( validationEnabled && attDefType == XMLAttributeDecl . DEFAULT_TYPE_FIXED ) { int alistValue = attrList . getAttValue ( i ) ; if ( alistValue != attValue && ! fStringPool . toString ( alistValue ) . equals ( fStringPool . toString ( attValue ) ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) , fStringPool . toString ( alistValue ) , fStringPool . toString ( attValue ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_FIXED_ATTVALUE_INVALID , XMLMessages . VC_FIXED_ATTRIBUTE_DEFAULT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } specified = true ; break ; } i = attrList . getNextAttr ( i ) ; } } } if ( ! specified ) { if ( required ) { if ( validationEnabled ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_REQUIRED_ATTRIBUTE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else if ( attValue != - 1 ) { if ( validationEnabled && standalone ) if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attlistIndex ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( attType == fIDREFSymbol ) { this . fValIDRef . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } else if ( attType == fIDREFSSymbol ) { this . fValIDRefs . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } if ( attrIndex == - 1 ) { attrIndex = attrList . startAttrList ( ) ; } fTempQName . setValues ( attPrefix , attName , attName , fTempAttDecl . name . uri ) ; int newAttr = attrList . addAttr ( fTempQName , attValue , attType , false , false ) ; if ( lastCheck == - 1 ) { lastCheck = newAttr ; } } } attlistIndex = fGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } return attrIndex ; } private int addDTDDefaultAttributes ( QName element , XMLAttrList attrList , int attrIndex , boolean validationEnabled , boolean standalone ) throws Exception { int elementIndex = fGrammar . getElementDeclIndex ( element , - 1 ) ; if ( elementIndex == - 1 ) { return attrIndex ; } fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; int elementNameIndex = fTempElementDecl . name . rawname ; int attlistIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int firstCheck = attrIndex ; int lastCheck = - 1 ; while ( attlistIndex != - 1 ) { fGrammar . getAttributeDecl ( attlistIndex , fTempAttDecl ) ; int attPrefix = fTempAttDecl . name . prefix ; int attName = fTempAttDecl . name . rawname ; int attLocalpart = fTempAttDecl . name . localpart ; int attType = attributeTypeName ( fTempAttDecl ) ; int attDefType = fTempAttDecl . defaultType ; int attValue = - 1 ; if ( fTempAttDecl . defaultValue != null ) { attValue = fStringPool . addSymbol ( fTempAttDecl . defaultValue ) ; } boolean specified = false ; boolean required = attDefType == XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; if ( firstCheck != - 1 ) { boolean cdata = attType == fCDATASymbol ; if ( ! cdata || required || attValue != - 1 ) { int i = attrList . getFirstAttr ( firstCheck ) ; while ( i != - 1 && ( lastCheck == - 1 || i <= lastCheck ) ) { if ( attrList . getAttrName ( i ) == fTempAttDecl . name . rawname ) { if ( validationEnabled && attDefType == XMLAttributeDecl . DEFAULT_TYPE_FIXED ) { int alistValue = attrList . getAttValue ( i ) ; if ( alistValue != attValue && ! fStringPool . toString ( alistValue ) . equals ( fStringPool . toString ( attValue ) ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) , fStringPool . toString ( alistValue ) , fStringPool . toString ( attValue ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_FIXED_ATTVALUE_INVALID , XMLMessages . VC_FIXED_ATTRIBUTE_DEFAULT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } specified = true ; break ; } i = attrList . getNextAttr ( i ) ; } } } if ( ! specified ) { if ( required ) { if ( validationEnabled ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_REQUIRED_ATTRIBUTE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else if ( attValue != - 1 ) { if ( validationEnabled && standalone ) if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attlistIndex ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( attType == fIDREFSymbol ) { this . fValIDRef . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } else if ( attType == fIDREFSSymbol ) { this . fValIDRefs . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } if ( attrIndex == - 1 ) { attrIndex = attrList . startAttrList ( ) ; } fTempQName . setValues ( attPrefix , attLocalpart , attName , fTempAttDecl . name . uri ) ; int newAttr = attrList . addAttr ( fTempQName , attValue , attType , false , false ) ; if ( lastCheck == - 1 ) { lastCheck = newAttr ; } } } attlistIndex = fGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } return attrIndex ; } private XMLContentModel getElementContentModel ( int elementIndex ) throws CMException { XMLContentModel contentModel = null ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentModel = fGrammar . getElementContentModel ( elementIndex ) ; } } return contentModel ; } private int getAttDef ( QName element , QName attribute ) { if ( fGrammar != null ) { int scope = fCurrentScope ; if ( element . uri > - 1 ) { scope = TOP_LEVEL_SCOPE ; } int elementIndex = fGrammar . getElementDeclIndex ( element , scope ) ; if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { fGrammar . getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . name . localpart == attribute . localpart && fTempAttributeDecl . name . uri == attribute . uri ) { return attDefIndex ; } attDefIndex = fGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } return - 1 ; } private int getAttDefByElementIndex ( int elementIndex , QName attribute ) { if ( fGrammar != null && elementIndex > - 1 ) { if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { fGrammar . getAttributeDecl ( attDefIndex , fTempAttDecl ) ; if ( fGrammarIsDTDGrammar ) { if ( fTempAttDecl . name . rawname == attribute . rawname ) return attDefIndex ; } else if ( fTempAttDecl . name . localpart == attribute . localpart && fTempAttDecl . name . uri == attribute . uri ) { return attDefIndex ; } if ( fGrammarIsSchemaGrammar ) { if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return attDefIndex ; } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { if ( attribute . uri == - 1 ) { return attDefIndex ; } } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( attribute . uri != fTempAttDecl . name . uri ) { return attDefIndex ; } } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( fStringPool . stringInList ( fTempAttDecl . enumeration , attribute . uri ) ) { return attDefIndex ; } } } attDefIndex = fGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } return - 1 ; } private void rootElementSpecified ( QName rootElement ) throws Exception { if ( fLoadDTDGrammar ) if ( fGrammar == null ) { fGrammar = fGrammarResolver . getGrammar ( "" ) ; if ( fGrammar == null && DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "Oops! no grammar is found for validation" ) ; } if ( fDynamicValidation && fGrammar == null ) { fValidating = false ; } if ( fGrammar != null ) { if ( fGrammar instanceof DTDGrammar ) { fGrammarIsDTDGrammar = true ; fGrammarIsSchemaGrammar = false ; } else if ( fGrammar instanceof SchemaGrammar ) { fGrammarIsSchemaGrammar = true ; fGrammarIsDTDGrammar = false ; } fGrammarNameSpaceIndex = fEmptyURI ; } } if ( fValidating ) { if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getRootElementQName ( fRootElement ) ) { String root1 = fStringPool . toString ( fRootElement . rawname ) ; String root2 = fStringPool . toString ( rootElement . rawname ) ; if ( ! root1 . equals ( root2 ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ROOT_ELEMENT_TYPE , XMLMessages . VC_ROOT_ELEMENT_TYPE , fRootElement . rawname , rootElement . rawname ) ; } } } if ( fNamespacesEnabled ) { if ( fNamespacesScope == null ) { fNamespacesScope = new NamespacesScope ( this ) ; fNamespacesPrefix = fStringPool . addSymbol ( "xmlns" ) ; fNamespacesScope . setNamespaceForPrefix ( fNamespacesPrefix , - 1 ) ; int xmlSymbol = fStringPool . addSymbol ( "xml" ) ; int xmlNamespace = fStringPool . addSymbol ( "http://www.w3.org/XML/1998/namespace" ) ; fNamespacesScope . setNamespaceForPrefix ( xmlSymbol , xmlNamespace ) ; } } } private boolean switchGrammar ( int newGrammarNameSpaceIndex ) throws Exception { Grammar tempGrammar = fGrammarResolver . getGrammar ( fStringPool . toString ( newGrammarNameSpaceIndex ) ) ; if ( tempGrammar == null ) { tempGrammar = fGrammarResolver . getGrammar ( "" ) ; } if ( tempGrammar == null ) { return false ; } else { fGrammar = tempGrammar ; if ( fGrammar instanceof DTDGrammar ) { fGrammarIsDTDGrammar = true ; fGrammarIsSchemaGrammar = false ; } else if ( fGrammar instanceof SchemaGrammar ) { fGrammarIsSchemaGrammar = true ; fGrammarIsDTDGrammar = false ; } return true ; } } private void bindNamespacesToElementAndAttributes ( QName element , XMLAttrList attrList ) throws Exception { fNamespacesScope . increaseDepth ( ) ; Hashtable locationUriPairs = null ; if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; int attPrefix = attrList . getAttrPrefix ( index ) ; if ( fStringPool . equalNames ( attName , fXMLLang ) ) { } else if ( fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int uri = fStringPool . addSymbol ( attrList . getAttValue ( index ) ) ; fNamespacesScope . setNamespaceForPrefix ( StringPool . EMPTY_STRING , uri ) ; } else { if ( attPrefix == fNamespacesPrefix ) { int nsPrefix = attrList . getAttrLocalpart ( index ) ; int uri = fStringPool . addSymbol ( attrList . getAttValue ( index ) ) ; fNamespacesScope . setNamespaceForPrefix ( nsPrefix , uri ) ; if ( fValidating && fSchemaValidation ) { boolean seeXsi = false ; String attrValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; if ( attrValue . equals ( SchemaSymbols . URI_XSI ) ) { fXsiPrefix = nsPrefix ; seeXsi = true ; } if ( ! seeXsi ) { } } } } index = attrList . getNextAttr ( index ) ; } if ( fValidating && fSchemaValidation ) { fXsiTypeAttValue = - 1 ; index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; int attPrefix = attrList . getAttrPrefix ( index ) ; if ( fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { } else { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "deal with XSI" ) ; System . out . println ( "before find XSI: " + fStringPool . toString ( attPrefix ) + "," + fStringPool . toString ( fXsiPrefix ) ) ; } if ( fXsiPrefix != - 1 && attPrefix == fXsiPrefix ) { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "find XSI: " + fStringPool . toString ( attPrefix ) + "," + fStringPool . toString ( attName ) ) ; } int localpart = attrList . getAttrLocalpart ( index ) ; if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_SCHEMALOCACTION ) ) { if ( locationUriPairs == null ) { locationUriPairs = new Hashtable ( ) ; } parseSchemaLocation ( fStringPool . toString ( attrList . getAttValue ( index ) ) , locationUriPairs ) ; } else if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_NONAMESPACESCHEMALOCACTION ) ) { if ( locationUriPairs == null ) { locationUriPairs = new Hashtable ( ) ; } locationUriPairs . put ( fStringPool . toString ( attrList . getAttValue ( index ) ) , "" ) ; if ( fNamespacesScope != null ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } } else if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_TYPE ) ) { fXsiTypeAttValue = attrList . getAttValue ( index ) ; } } } index = attrList . getNextAttr ( index ) ; } if ( locationUriPairs != null ) { Enumeration locations = locationUriPairs . keys ( ) ; while ( locations . hasMoreElements ( ) ) { String loc = ( String ) locations . nextElement ( ) ; String uri = ( String ) locationUriPairs . get ( loc ) ; resolveSchemaGrammar ( loc , uri ) ; } } } } int prefix = element . prefix != - 1 ? element . prefix : 0 ; int uri = fNamespacesScope . getNamespaceForPrefix ( prefix ) ; if ( element . prefix != - 1 || uri != - 1 ) { element . uri = uri ; if ( element . uri == - 1 ) { Object [ ] args = { fStringPool . toString ( element . prefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; if ( ! fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int attPrefix = attrList . getAttrPrefix ( index ) ; if ( attPrefix != fNamespacesPrefix ) { if ( attPrefix != - 1 ) { int attrUri = fNamespacesScope . getNamespaceForPrefix ( attPrefix ) ; if ( attrUri == - 1 ) { Object [ ] args = { fStringPool . toString ( attPrefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } attrList . setAttrURI ( index , attrUri ) ; } } } index = attrList . getNextAttr ( index ) ; } } } void parseSchemaLocation ( String schemaLocationStr , Hashtable locationUriPairs ) { if ( locationUriPairs != null ) { StringTokenizer tokenizer = new StringTokenizer ( schemaLocationStr , " \n\t\r" , false ) ; int tokenTotal = tokenizer . countTokens ( ) ; if ( tokenTotal % 2 != 0 ) { } else { while ( tokenizer . hasMoreTokens ( ) ) { String uri = tokenizer . nextToken ( ) ; String location = tokenizer . nextToken ( ) ; locationUriPairs . put ( location , uri ) ; } } } else { } } private void resolveSchemaGrammar ( String loc , String uri ) throws Exception { SchemaGrammar grammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uri ) ; if ( grammar == null ) { DOMParser parser = new DOMParser ( ) ; parser . setEntityResolver ( new Resolver ( fEntityHandler ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } InputSource source = null ; EntityResolver currentER = parser . getEntityResolver ( ) ; if ( currentER != null ) { source = currentER . resolveEntity ( "" , loc ) ; } if ( source == null ) { loc = fEntityHandler . expandSystemId ( loc ) ; source = new InputSource ( loc ) ; } try { parser . parse ( source ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , e . getMessage ( ) ) ; } Document document = parser . getDocument ( ) ; TraverseSchema tst = null ; try { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "I am geting the Schema Document" ) ; } Element root = document . getDocumentElement ( ) ; if ( root == null ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Can't get back Schema document's root element :" + loc ) ; } else { if ( uri == null || ! uri . equals ( root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ) ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Schema in " + loc + " has a different target namespace " + "from the one specified in the instance document :" + uri ) ; } grammar = new SchemaGrammar ( ) ; grammar . setGrammarDocument ( document ) ; tst = new TraverseSchema ( root , fStringPool , ( SchemaGrammar ) grammar , fGrammarResolver , fErrorReporter , source . getSystemId ( ) ) ; fGrammarResolver . putGrammar ( document . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) , grammar ) ; } } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } } } private void resolveSchemaGrammar ( String uri ) throws Exception { resolveSchemaGrammar ( uri , uri ) ; } static class Resolver implements EntityResolver { private static final String SYSTEM [ ] = { "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/structures.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/datatypes.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/versionInfo.ent" , } ; private static final String PATH [ ] = { "structures.dtd" , "datatypes.dtd" , "versionInfo.ent" , } ; private DefaultEntityHandler fEntityHandler ; public Resolver ( DefaultEntityHandler handler ) { fEntityHandler = handler ; } public InputSource resolveEntity ( String publicId , String systemId ) throws IOException , SAXException { for ( int i = 0 ; i < SYSTEM . length ; i ++ ) { if ( systemId . equals ( SYSTEM [ i ] ) ) { InputSource source = new InputSource ( getClass ( ) . getResourceAsStream ( PATH [ i ] ) ) ; source . setPublicId ( publicId ) ; source . setSystemId ( systemId ) ; return source ; } } EntityResolver resolver = fEntityHandler . getEntityResolver ( ) ; if ( resolver != null ) { InputSource source = resolver . resolveEntity ( publicId , systemId ) ; if ( source != null ) { return source ; } } return new InputSource ( fEntityHandler . expandSystemId ( systemId ) ) ; } } static class ErrorHandler implements org . xml . sax . ErrorHandler { public void warning ( SAXParseException ex ) { System . err . println ( "[Warning] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { System . err . println ( "[Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) { System . err . println ( "[Fatal Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId_ = ex . getSystemId ( ) ; if ( systemId_ != null ) { int index = systemId_ . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId_ = systemId_ . substring ( index + 1 ) ; str . append ( systemId_ ) ; } str . append ( ':' ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( ':' ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } } private int attributeTypeName ( XMLAttributeDecl attrDecl ) { switch ( attrDecl . type ) { case XMLAttributeDecl . TYPE_ENTITY : { return attrDecl . list ? fENTITIESSymbol : fENTITYSymbol ; } case XMLAttributeDecl . TYPE_ENUMERATION : { String enumeration = fStringPool . stringListAsString ( attrDecl . enumeration ) ; return fStringPool . addString ( enumeration ) ; } case XMLAttributeDecl . TYPE_ID : { return fIDSymbol ; } case XMLAttributeDecl . TYPE_IDREF : { return attrDecl . list ? fIDREFSSymbol : fIDREFSymbol ; } case XMLAttributeDecl . TYPE_NMTOKEN : { return attrDecl . list ? fNMTOKENSSymbol : fNMTOKENSSymbol ; } case XMLAttributeDecl . TYPE_NOTATION : { return fNOTATIONSymbol ; } } return fCDATASymbol ; } private void validateElementAndAttributes ( QName element , XMLAttrList attrList ) throws Exception { if ( ( fElementDepth >= 0 && fValidationFlagStack [ fElementDepth ] != 0 ) || ( fGrammar == null && ! fValidating && ! fNamespacesEnabled ) ) { fCurrentElementIndex = - 1 ; fCurrentContentSpecType = - 1 ; fInElementContent = false ; if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; int index = fAttrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { if ( fStringPool . equalNames ( fAttrList . getAttrName ( index ) , fXMLLang ) ) { fDocumentScanner . checkXMLLangAttributeValue ( fAttrList . getAttValue ( index ) ) ; break ; } index = fAttrList . getNextAttr ( index ) ; } } return ; } int elementIndex = - 1 ; int contentSpecType = - 1 ; boolean skipThisOne = false ; boolean laxThisOne = false ; if ( fGrammarIsSchemaGrammar && fContentLeafStack [ fElementDepth ] != null ) { ContentLeafNameTypeVector cv = fContentLeafStack [ fElementDepth ] ; QName [ ] fElemMap = cv . leafNames ; for ( int i = 0 ; i < cv . leafCount ; i ++ ) { int type = cv . leafTypes [ i ] ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fElemMap [ i ] . uri == element . uri && fElemMap [ i ] . localpart == element . localpart ) break ; } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( element . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ i ] . uri != element . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_SKIP ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_SKIP ) { if ( element . uri == - 1 ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_SKIP ) { if ( fElemMap [ i ] . uri != element . uri ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LAX ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { laxThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_LAX ) { if ( element . uri == - 1 ) { laxThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_LAX ) { if ( fElemMap [ i ] . uri != element . uri ) { laxThisOne = true ; break ; } } } } if ( skipThisOne ) { fNeedValidationOff = true ; } else { if ( fNamespacesEnabled && fValidating && element . uri != fGrammarNameSpaceIndex && element . uri != - 1 ) { fGrammarNameSpaceIndex = element . uri ; boolean success = switchGrammar ( fGrammarNameSpaceIndex ) ; if ( ! success && ! laxThisOne ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fGrammarNameSpaceIndex ) + " , can not found" ) ; } } if ( fGrammar != null ) { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "*******Lookup element: uri: " + fStringPool . toString ( element . uri ) + "localpart: '" + fStringPool . toString ( element . localpart ) + "' and scope : " + fCurrentScope + "\n" ) ; } elementIndex = fGrammar . getElementDeclIndex ( element , fCurrentScope ) ; if ( elementIndex == - 1 ) { elementIndex = fGrammar . getElementDeclIndex ( element , TOP_LEVEL_SCOPE ) ; } if ( elementIndex == - 1 ) { if ( fGrammarIsSchemaGrammar && fCurrentElementIndex != - 1 ) { TraverseSchema . ComplexTypeInfo baseTypeInfo = null ; baseTypeInfo = ( ( SchemaGrammar ) fGrammar ) . getElementComplexTypeInfo ( fCurrentElementIndex ) ; while ( baseTypeInfo != null ) { elementIndex = fGrammar . getElementDeclIndex ( element , baseTypeInfo . scopeDefined ) ; if ( elementIndex > - 1 ) { break ; } baseTypeInfo = baseTypeInfo . baseComplexTypeInfo ; } } if ( elementIndex == - 1 ) { if ( laxThisOne ) { fNeedValidationOff = true ; } else if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "!!! can not find elementDecl in the grammar, " + " the element localpart: " + element . localpart + "[" + fStringPool . toString ( element . localpart ) + "]" + " the element uri: " + element . uri + "[" + fStringPool . toString ( element . uri ) + "]" + " and the current enclosing scope: " + fCurrentScope ) ; } } if ( DEBUG_SCHEMA_VALIDATION ) { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; System . out . println ( "elementIndex: " + elementIndex + " \n and itsName : '" + fStringPool . toString ( fTempElementDecl . name . localpart ) + "' \n its ContentType:" + fTempElementDecl . type + "\n its ContentSpecIndex : " + fTempElementDecl . contentSpecIndex + "\n" + " and the current enclosing scope: " + fCurrentScope ) ; } } contentSpecType = getContentSpecType ( elementIndex ) ; if ( fGrammarIsSchemaGrammar && elementIndex != - 1 ) { if ( fXsiTypeAttValue > - 1 ) { String xsiType = fStringPool . toString ( fXsiTypeAttValue ) ; int colonP = xsiType . indexOf ( ":" ) ; String prefix = "" ; String localpart = xsiType ; if ( colonP > - 1 ) { prefix = xsiType . substring ( 0 , colonP ) ; localpart = xsiType . substring ( colonP + 1 ) ; } String uri = "" ; int uriIndex = - 1 ; if ( fNamespacesScope != null ) { uriIndex = fNamespacesScope . getNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) ) ; if ( uriIndex > - 1 ) { uri = fStringPool . toString ( uriIndex ) ; if ( uriIndex != fGrammarNameSpaceIndex ) { fGrammarNameSpaceIndex = fCurrentSchemaURI = uriIndex ; boolean success = switchGrammar ( fCurrentSchemaURI ) ; if ( ! success && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fCurrentSchemaURI ) + " , can not found" ) ; } } } } Hashtable complexRegistry = ( ( SchemaGrammar ) fGrammar ) . getComplexTypeRegistry ( ) ; DatatypeValidatorFactoryImpl dataTypeReg = ( ( SchemaGrammar ) fGrammar ) . getDatatypeRegistry ( ) ; if ( complexRegistry == null || dataTypeReg == null ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , fErrorReporter . getLocator ( ) . getSystemId ( ) + " line" + fErrorReporter . getLocator ( ) . getLineNumber ( ) + ", canot resolve xsi:type = " + xsiType + "  ---2" ) ; } else { TraverseSchema . ComplexTypeInfo typeInfo = ( TraverseSchema . ComplexTypeInfo ) complexRegistry . get ( uri + "," + localpart ) ; if ( typeInfo == null ) { if ( uri . length ( ) == 0 || uri . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { fXsiTypeValidator = dataTypeReg . getDatatypeValidator ( localpart ) ; } else fXsiTypeValidator = dataTypeReg . getDatatypeValidator ( uri + "," + localpart ) ; if ( fXsiTypeValidator == null ) reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "unresolved type : " + uri + "," + localpart + " found  in xsi:type handling" ) ; } else elementIndex = typeInfo . templateElementIndex ; } fXsiTypeAttValue = - 1 ; } fCurrentScope = ( ( SchemaGrammar ) fGrammar ) . getElementDefinedScope ( elementIndex ) ; String anotherSchemaURI = ( ( SchemaGrammar ) fGrammar ) . getElementFromAnotherSchemaURI ( elementIndex ) ; if ( anotherSchemaURI != null ) { if ( contentSpecType != - 1 && contentSpecType != XMLElementDecl . TYPE_SIMPLE && contentSpecType != XMLElementDecl . TYPE_EMPTY ) { TraverseSchema . ComplexTypeInfo typeInfo = ( ( SchemaGrammar ) fGrammar ) . getElementComplexTypeInfo ( elementIndex ) ; if ( typeInfo != null ) { elementIndex = typeInfo . templateElementIndex ; } } fGrammarNameSpaceIndex = fCurrentSchemaURI = fStringPool . addSymbol ( anotherSchemaURI ) ; boolean success = switchGrammar ( fCurrentSchemaURI ) ; if ( ! success && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fCurrentSchemaURI ) + " , can not found" ) ; } } } if ( contentSpecType == - 1 && fValidating && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_NOT_DECLARED , XMLMessages . VC_ELEMENT_VALID , element . rawname ) ; } if ( fGrammar != null && fGrammarIsSchemaGrammar && elementIndex != - 1 ) { fAttrListHandle = addDefaultAttributes ( elementIndex , attrList , fAttrListHandle , fValidating , fStandaloneReader != - 1 ) ; } if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; } if ( DEBUG_PRINT_ATTRIBUTES ) { String elementStr = fStringPool . toString ( element . rawname ) ; System . out . print ( "startElement: <" + elementStr ) ; if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { System . out . print ( " " + fStringPool . toString ( attrList . getAttrName ( index ) ) + "=\"" + fStringPool . toString ( attrList . getAttValue ( index ) ) + "\"" ) ; index = attrList . getNextAttr ( index ) ; } } System . out . println ( ">" ) ; } if ( fAttrListHandle != - 1 && ! fNeedValidationOff ) { int index = fAttrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attrNameIndex = attrList . getAttrName ( index ) ; if ( fStringPool . equalNames ( attrNameIndex , fXMLLang ) ) { fDocumentScanner . checkXMLLangAttributeValue ( attrList . getAttValue ( index ) ) ; } int _xmlns = fStringPool . addSymbol ( "xmlns" ) ; if ( attrNameIndex != _xmlns && attrList . getAttrPrefix ( index ) != _xmlns ) if ( fGrammar != null ) { fAttrNameLocator = getLocatorImpl ( fAttrNameLocator ) ; fTempQName . setValues ( attrList . getAttrPrefix ( index ) , attrList . getAttrLocalpart ( index ) , attrList . getAttrName ( index ) , attrList . getAttrURI ( index ) ) ; int attDefIndex = getAttDefByElementIndex ( elementIndex , fTempQName ) ; if ( fTempQName . uri != fXsiURI ) if ( attDefIndex == - 1 ) { if ( fValidating ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( attrList . getAttrName ( index ) ) } ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else { fGrammar . getAttributeDecl ( attDefIndex , fTempAttDecl ) ; int attributeType = attributeTypeName ( fTempAttDecl ) ; attrList . setAttType ( index , attributeType ) ; if ( fValidating ) { if ( fGrammarIsDTDGrammar && ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ENTITY || fTempAttDecl . type == XMLAttributeDecl . TYPE_ENUMERATION || fTempAttDecl . type == XMLAttributeDecl . TYPE_ID || fTempAttDecl . type == XMLAttributeDecl . TYPE_IDREF || fTempAttDecl . type == XMLAttributeDecl . TYPE_NMTOKEN || fTempAttDecl . type == XMLAttributeDecl . TYPE_NOTATION ) ) { validateDTDattribute ( element , attrList . getAttValue ( index ) , fTempAttDecl ) ; } else if ( fGrammarIsSchemaGrammar && ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_ANY || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LIST || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) ) { if ( fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_SKIP ) { } else if ( fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_STRICT || fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_LAX ) { boolean reportError = false ; boolean processContentStrict = fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_STRICT ; if ( fTempQName . uri == - 1 ) { if ( processContentStrict ) { reportError = true ; } } else { Grammar aGrammar = fGrammarResolver . getGrammar ( fStringPool . toString ( fTempQName . uri ) ) ; if ( aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { if ( processContentStrict ) { reportError = true ; } } else { SchemaGrammar sGrammar = ( SchemaGrammar ) aGrammar ; Hashtable attRegistry = sGrammar . getAttirubteDeclRegistry ( ) ; if ( attRegistry == null ) { if ( processContentStrict ) { reportError = true ; } } else { XMLAttributeDecl attDecl = ( XMLAttributeDecl ) attRegistry . get ( fStringPool . toString ( fTempQName . localpart ) ) ; if ( attDecl == null ) { if ( processContentStrict ) { reportError = true ; } } else { DatatypeValidator attDV = attDecl . datatypeValidator ; if ( attDV == null ) { if ( processContentStrict ) { reportError = true ; } } else { try { String unTrimValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; String value = unTrimValue . trim ( ) ; if ( attDecl . type == XMLAttributeDecl . TYPE_ID ) { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } if ( attDecl . type == XMLAttributeDecl . TYPE_IDREF ) { attDV . validate ( value , this . fStoreIDRef ) ; } else attDV . validate ( unTrimValue , null ) ; } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } } if ( reportError ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , "ANY---" + fStringPool . toString ( attrList . getAttrName ( index ) ) } ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } else if ( fTempAttDecl . datatypeValidator == null ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( attrList . getAttrName ( index ) ) } ; System . out . println ( "[Error] Datatypevalidator for attribute " + fStringPool . toString ( attrList . getAttrName ( index ) ) + " not found in element type " + fStringPool . toString ( element . rawname ) ) ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } else { try { String unTrimValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; String value = unTrimValue . trim ( ) ; if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ID ) { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_IDREF ) { fTempAttDecl . datatypeValidator . validate ( value , this . fStoreIDRef ) ; } else { fTempAttDecl . datatypeValidator . validate ( unTrimValue , null ) ; } } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } index = fAttrList . getNextAttr ( index ) ; } } } if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; if ( ! fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int attPrefix = attrList . getAttrPrefix ( index ) ; if ( attPrefix != fNamespacesPrefix ) { if ( attPrefix != - 1 ) { int uri = fNamespacesScope . getNamespaceForPrefix ( attPrefix ) ; if ( uri == - 1 ) { Object [ ] args = { fStringPool . toString ( attPrefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } attrList . setAttrURI ( index , uri ) ; } } } index = attrList . getNextAttr ( index ) ; } } fCurrentElementIndex = elementIndex ; fCurrentContentSpecType = contentSpecType ; if ( fValidating && contentSpecType == XMLElementDecl . TYPE_SIMPLE ) { fBufferDatatype = true ; fDatatypeBuffer . setLength ( 0 ) ; } fInElementContent = ( contentSpecType == XMLElementDecl . TYPE_CHILDREN ) ; } private void validateDTDattribute ( QName element , int attValue , XMLAttributeDecl attributeDecl ) throws Exception { AttributeValidator av = null ; switch ( attributeDecl . type ) { case XMLAttributeDecl . TYPE_ENTITY : { boolean isAlistAttribute = attributeDecl . list ; String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValENTITIES . validate ( value , null ) ; } else { fValENTITY . validate ( value , null ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( ex . getMajorCode ( ) != 1 && ex . getMinorCode ( ) != - 1 ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } else { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } } break ; case XMLAttributeDecl . TYPE_ENUMERATION : av = fAttValidatorENUMERATION ; break ; case XMLAttributeDecl . TYPE_ID : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } } break ; case XMLAttributeDecl . TYPE_IDREF : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; boolean isAlistAttribute = attributeDecl . list ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValIDRefs . validate ( value , this . fStoreIDRef ) ; } else { fValIDRef . validate ( value , this . fStoreIDRef ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( ex . getMajorCode ( ) != 1 && ex . getMinorCode ( ) != - 1 ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } else { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } } break ; case XMLAttributeDecl . TYPE_NOTATION : { av = fAttValidatorNOTATION ; } break ; case XMLAttributeDecl . TYPE_NMTOKEN : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; boolean isAlistAttribute = attributeDecl . list ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValNMTOKENS . validate ( value , null ) ; } else { fValNMTOKEN . validate ( value , null ) ; } } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( XMLMessages . MSG_NMTOKEN_INVALID , XMLMessages . VC_NAME_TOKEN , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } } break ; } if ( av != null ) av . normalize ( element , attributeDecl . name , attValue , attributeDecl . type , attributeDecl . enumeration ) ; } private void charDataInContent ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . println ( "charDataInContent()" ) ; } if ( fElementChildren . length <= fElementChildrenLength ) { QName [ ] newarray = new QName [ fElementChildren . length * 2 ] ; System . arraycopy ( fElementChildren , 0 , newarray , 0 , fElementChildren . length ) ; fElementChildren = newarray ; } QName qname = fElementChildren [ fElementChildrenLength ] ; if ( qname == null ) { for ( int i = fElementChildrenLength ; i < fElementChildren . length ; i ++ ) { fElementChildren [ i ] = new QName ( ) ; } qname = fElementChildren [ fElementChildrenLength ] ; } qname . clear ( ) ; fElementChildrenLength ++ ; } private int checkContent ( int elementIndex , QName [ ] children , int childOffset , int childCount ) throws Exception { final int elementType = fCurrentElement . rawname ; if ( DEBUG_PRINT_CONTENT ) { String strTmp = fStringPool . toString ( elementType ) ; System . out . println ( "Name: " + strTmp + ", " + "Count: " + childCount + ", " + "ContentSpecType: " + fCurrentContentSpecType ) ; for ( int index = childOffset ; index < ( childOffset + childCount ) && index < 10 ; index ++ ) { if ( index == 0 ) { System . out . print ( "  (" ) ; } String childName = ( children [ index ] . localpart == - 1 ) ? "#PCDATA" : fStringPool . toString ( children [ index ] . localpart ) ; if ( index + 1 == childCount ) { System . out . println ( childName + ")" ) ; } else if ( index + 1 == 10 ) { System . out . println ( childName + ",...)" ) ; } else { System . out . print ( childName + "," ) ; } } } final int contentType = fCurrentContentSpecType ; if ( contentType == XMLElementDecl . TYPE_EMPTY ) { if ( childCount != 0 ) { return 0 ; } } else if ( contentType == XMLElementDecl . TYPE_ANY ) { } else if ( contentType == XMLElementDecl . TYPE_MIXED || contentType == XMLElementDecl . TYPE_CHILDREN ) { XMLContentModel cmElem = null ; try { cmElem = getElementContentModel ( elementIndex ) ; int result = cmElem . validateContent ( children , childOffset , childCount ) ; if ( result != - 1 && fGrammarIsSchemaGrammar ) { EquivClassComparator comparator = new EquivClassComparator ( fGrammarResolver , fStringPool ) ; cmElem . setEquivClassComparator ( comparator ) ; result = cmElem . validateContentSpecial ( children , childOffset , childCount ) ; } return result ; } catch ( CMException excToCatch ) { int majorCode = excToCatch . getErrorCode ( ) ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , majorCode , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } else if ( contentType == - 1 ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_NOT_DECLARED , XMLMessages . VC_ELEMENT_VALID , elementType ) ; } else if ( contentType == XMLElementDecl . TYPE_SIMPLE ) { XMLContentModel cmElem = null ; if ( childCount > 0 ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { "In element '" + fStringPool . toString ( elementType ) + "' : " + "Can not have element children within a simple type content" } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } else { try { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; DatatypeValidator dv = fTempElementDecl . datatypeValidator ; if ( fXsiTypeValidator != null ) { dv = fXsiTypeValidator ; fXsiTypeValidator = null ; } if ( dv == null ) { System . out . println ( "Internal Error: this element have a simpletype " + "but no datatypevalidator was found, element " + fTempElementDecl . name + ",locapart: " + fStringPool . toString ( fTempElementDecl . name . localpart ) ) ; } else { dv . validate ( fDatatypeBuffer . toString ( ) , null ) ; } } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } else { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . VAL_CST , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } return - 1 ; } private void printChildren ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . print ( '[' ) ; for ( int i = 0 ; i < fElementChildrenLength ; i ++ ) { System . out . print ( ' ' ) ; QName qname = fElementChildren [ i ] ; if ( qname != null ) { System . out . print ( fStringPool . toString ( qname . rawname ) ) ; } else { System . out . print ( "null" ) ; } if ( i < fElementChildrenLength - 1 ) { System . out . print ( ", " ) ; } System . out . flush ( ) ; } System . out . print ( " ]" ) ; System . out . println ( ) ; } } private void printStack ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . print ( '{' ) ; for ( int i = 0 ; i <= fElementDepth ; i ++ ) { System . out . print ( ' ' ) ; System . out . print ( fElementChildrenOffsetStack [ i ] ) ; if ( i < fElementDepth ) { System . out . print ( ", " ) ; } System . out . flush ( ) ; } System . out . print ( " }" ) ; System . out . println ( ) ; } } public interface AttributeValidator { public int normalize ( QName element , QName attribute , int attValue , int attType , int enumHandle ) throws Exception ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } final class AttValidatorNOTATION implements AttributeValidator { public int normalize ( QName element , QName attribute , int attValueHandle , int attType , int enumHandle ) throws Exception { String attValue = fStringPool . toString ( attValueHandle ) ; String newAttValue = attValue . trim ( ) ; if ( fValidating ) { if ( newAttValue != attValue ) { if ( invalidStandaloneAttDef ( element , attribute ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attribute . rawname ) , attValue , newAttValue ) ; } attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } else { attValueHandle = fStringPool . addSymbol ( attValueHandle ) ; } if ( ! fStringPool . stringInList ( enumHandle , attValueHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_NOT_IN_LIST , XMLMessages . VC_NOTATION_ATTRIBUTES , fStringPool . toString ( attribute . rawname ) , newAttValue , fStringPool . stringListAsString ( enumHandle ) ) ; } } else if ( newAttValue != attValue ) { attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } return attValueHandle ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } } final class AttValidatorENUMERATION implements AttributeValidator { public int normalize ( QName element , QName attribute , int attValueHandle , int attType , int enumHandle ) throws Exception { String attValue = fStringPool . toString ( attValueHandle ) ; String newAttValue = attValue . trim ( ) ; if ( fValidating ) { if ( newAttValue != attValue ) { if ( invalidStandaloneAttDef ( element , attribute ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attribute . rawname ) , attValue , newAttValue ) ; } attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } else { attValueHandle = fStringPool . addSymbol ( attValueHandle ) ; } if ( ! fStringPool . stringInList ( enumHandle , attValueHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_NOT_IN_LIST , XMLMessages . VC_ENUMERATION , fStringPool . toString ( attribute . rawname ) , newAttValue , fStringPool . stringListAsString ( enumHandle ) ) ; } } else if ( newAttValue != attValue ) { attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } return attValueHandle ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } } } 	1
package org . apache . xerces . utils . regex ; import java . text . CharacterIterator ; public class Match implements Cloneable { int [ ] beginpos = null ; int [ ] endpos = null ; int nofgroups = 0 ; CharacterIterator ciSource = null ; String strSource = null ; char [ ] charSource = null ; public Match ( ) { } public synchronized Object clone ( ) { Match ma = new Match ( ) ; if ( this . nofgroups > 0 ) { ma . setNumberOfGroups ( this . nofgroups ) ; if ( this . ciSource != null ) ma . setSource ( this . ciSource ) ; if ( this . strSource != null ) ma . setSource ( this . strSource ) ; for ( int i = 0 ; i < this . nofgroups ; i ++ ) { ma . setBeginning ( i , this . getBeginning ( i ) ) ; ma . setEnd ( i , this . getEnd ( i ) ) ; } } return ma ; } protected void setNumberOfGroups ( int n ) { int oldn = this . nofgroups ; this . nofgroups = n ; if ( oldn <= 0 || oldn < n || n * 2 < oldn ) { this . beginpos = new int [ n ] ; this . endpos = new int [ n ] ; } for ( int i = 0 ; i < n ; i ++ ) { this . beginpos [ i ] = - 1 ; this . endpos [ i ] = - 1 ; } } protected void setSource ( CharacterIterator ci ) { this . ciSource = ci ; this . strSource = null ; this . charSource = null ; } protected void setSource ( String str ) { this . ciSource = null ; this . strSource = str ; this . charSource = null ; } protected void setSource ( char [ ] chars ) { this . ciSource = null ; this . strSource = null ; this . charSource = chars ; } protected void setBeginning ( int index , int v ) { this . beginpos [ index ] = v ; } protected void setEnd ( int index , int v ) { this . endpos [ index ] = v ; } public int getNumberOfGroups ( ) { if ( this . nofgroups <= 0 ) throw new IllegalStateException ( "A result is not set." ) ; return this . nofgroups ; } public int getBeginning ( int index ) { if ( this . beginpos == null ) throw new IllegalStateException ( "A result is not set." ) ; if ( index < 0 || this . nofgroups <= index ) throw new IllegalArgumentException ( "The parameter must be less than " + this . nofgroups + ": " + index ) ; return this . beginpos [ index ] ; } public int getEnd ( int index ) { if ( this . endpos == null ) throw new IllegalStateException ( "A result is not set." ) ; if ( index < 0 || this . nofgroups <= index ) throw new IllegalArgumentException ( "The parameter must be less than " + this . nofgroups + ": " + index ) ; return this . endpos [ index ] ; } public String getCapturedText ( int index ) { if ( this . beginpos == null ) throw new IllegalStateException ( "match() has never been called." ) ; if ( index < 0 || this . nofgroups <= index ) throw new IllegalArgumentException ( "The parameter must be less than " + this . nofgroups + ": " + index ) ; String ret ; int begin = this . beginpos [ index ] , end = this . endpos [ index ] ; if ( begin < 0 || end < 0 ) return null ; if ( this . ciSource != null ) { ret = REUtil . substring ( this . ciSource , begin , end ) ; } else if ( this . strSource != null ) { ret = this . strSource . substring ( begin , end ) ; } else { ret = new String ( this . charSource , begin , end - begin ) ; } return ret ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class ElementNSImpl extends ElementImpl { static final long serialVersionUID = - 9142310625494392642L ; protected String namespaceURI ; protected String localName ; protected ElementNSImpl ( DocumentImpl ownerDocument , String namespaceURI , String qualifiedName ) throws DOMException { super ( ownerDocument , qualifiedName ) ; if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = qualifiedName ; } else { prefix = qualifiedName . substring ( 0 , index ) ; localName = qualifiedName . substring ( index + 1 ) ; } if ( prefix != null && ( namespaceURI == null || namespaceURI . equals ( "" ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } this . namespaceURI = namespaceURI ; } protected ElementNSImpl ( DocumentImpl ownerDocument , String value ) { super ( ownerDocument , value ) ; } public String getNamespaceURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return namespaceURI ; } public String getPrefix ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int index = name . indexOf ( ':' ) ; return index < 0 ? null : name . substring ( 0 , index ) ; } public void setPrefix ( String prefix ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( namespaceURI == null || ( prefix != null && prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } if ( ownerDocument . errorChecking && ! DocumentImpl . isXMLName ( prefix ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } name = prefix + ":" + localName ; } public String getLocalName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return localName ; } } 	1
package org . w3c . dom . html ; public interface HTMLQuoteElement extends HTMLElement { public String getCite ( ) ; public void setCite ( String cite ) ; } 	0
package org . w3c . dom ; public interface Document extends Node { public DocumentType getDoctype ( ) ; public DOMImplementation getImplementation ( ) ; public Element getDocumentElement ( ) ; public Element createElement ( String tagName ) throws DOMException ; public DocumentFragment createDocumentFragment ( ) ; public Text createTextNode ( String data ) ; public Comment createComment ( String data ) ; public CDATASection createCDATASection ( String data ) throws DOMException ; public ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException ; public Attr createAttribute ( String name ) throws DOMException ; public EntityReference createEntityReference ( String name ) throws DOMException ; public NodeList getElementsByTagName ( String tagname ) ; public Node importNode ( Node importedNode , boolean deep ) throws DOMException ; public Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException ; public Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public Element getElementById ( String elementId ) ; } 	1
package org . w3c . dom . html ; public interface HTMLLinkElement extends HTMLElement { public boolean getDisabled ( ) ; public void setDisabled ( boolean disabled ) ; public String getCharset ( ) ; public void setCharset ( String charset ) ; public String getHref ( ) ; public void setHref ( String href ) ; public String getHreflang ( ) ; public void setHreflang ( String hreflang ) ; public String getMedia ( ) ; public void setMedia ( String media ) ; public String getRel ( ) ; public void setRel ( String rel ) ; public String getRev ( ) ; public void setRev ( String rev ) ; public String getTarget ( ) ; public void setTarget ( String target ) ; public String getType ( ) ; public void setType ( String type ) ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface NodeIterator { public Node getRoot ( ) ; public int getWhatToShow ( ) ; public NodeFilter getFilter ( ) ; public boolean getExpandEntityReferences ( ) ; public Node nextNode ( ) throws DOMException ; public Node previousNode ( ) throws DOMException ; public void detach ( ) ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLBElementImpl extends WMLElementImpl implements WMLBElement { public WMLBElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom . events ; public class EventException extends RuntimeException { public EventException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short UNSPECIFIED_EVENT_TYPE_ERR = 0 ; } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . utils . ImplementationMessages ; class CMStateSet { CMStateSet ( int bitCount ) throws CMException { fBitCount = bitCount ; if ( fBitCount < 0 ) throw new CMException ( ImplementationMessages . VAL_CMSI ) ; if ( fBitCount > 64 ) { fByteCount = fBitCount / 8 ; if ( fBitCount % 8 != 0 ) fByteCount ++ ; fByteArray = new byte [ fByteCount ] ; } zeroBits ( ) ; } public String toString ( ) { StringBuffer strRet = new StringBuffer ( ) ; try { strRet . append ( "{" ) ; for ( int index = 0 ; index < fBitCount ; index ++ ) { if ( getBit ( index ) ) strRet . append ( " " + index ) ; } strRet . append ( " }" ) ; } catch ( CMException exToCatch ) { } return strRet . toString ( ) ; } final void intersection ( CMStateSet setToAnd ) { if ( fBitCount < 65 ) { fBits1 &= setToAnd . fBits1 ; fBits2 &= setToAnd . fBits2 ; } else { for ( int index = fByteCount - 1 ; index >= 0 ; index -- ) fByteArray [ index ] &= setToAnd . fByteArray [ index ] ; } } final boolean getBit ( int bitToGet ) throws CMException { if ( bitToGet >= fBitCount ) throw new CMException ( ImplementationMessages . VAL_CMSI ) ; if ( fBitCount < 65 ) { final int mask = ( 0x1 << ( bitToGet % 32 ) ) ; if ( bitToGet < 32 ) return ( fBits1 & mask ) != 0 ; else return ( fBits2 & mask ) != 0 ; } else { final byte mask = ( byte ) ( 0x1 << ( bitToGet % 8 ) ) ; final int ofs = bitToGet > > 3 ; return ( ( fByteArray [ ofs ] & mask ) != 0 ) ; } } final boolean isEmpty ( ) { if ( fBitCount < 65 ) { return ( ( fBits1 == 0 ) && ( fBits2 == 0 ) ) ; } else { for ( int index = fByteCount - 1 ; index >= 0 ; index -- ) { if ( fByteArray [ index ] != 0 ) return false ; } } return true ; } final boolean isSameSet ( CMStateSet setToCompare ) { if ( fBitCount != setToCompare . fBitCount ) return false ; if ( fBitCount < 65 ) { return ( ( fBits1 == setToCompare . fBits1 ) && ( fBits2 == setToCompare . fBits2 ) ) ; } for ( int index = fByteCount - 1 ; index >= 0 ; index -- ) { if ( fByteArray [ index ] != setToCompare . fByteArray [ index ] ) return false ; } return true ; } final void union ( CMStateSet setToOr ) { if ( fBitCount < 65 ) { fBits1 |= setToOr . fBits1 ; fBits2 |= setToOr . fBits2 ; } else { for ( int index = fByteCount - 1 ; index >= 0 ; index -- ) fByteArray [ index ] |= setToOr . fByteArray [ index ] ; } } final void setBit ( int bitToSet ) throws CMException { if ( bitToSet >= fBitCount ) throw new CMException ( ImplementationMessages . VAL_CMSI ) ; if ( fBitCount < 65 ) { final int mask = ( 0x1 << ( bitToSet % 32 ) ) ; if ( bitToSet < 32 ) { fBits1 &= ~ mask ; fBits1 |= mask ; } else { fBits2 &= ~ mask ; fBits2 |= mask ; } } else { final byte mask = ( byte ) ( 0x1 << ( bitToSet % 8 ) ) ; final int ofs = bitToSet > > 3 ; fByteArray [ ofs ] &= ~ mask ; fByteArray [ ofs ] |= mask ; } } final void setTo ( CMStateSet srcSet ) throws CMException { if ( fBitCount != srcSet . fBitCount ) throw new CMException ( ImplementationMessages . VAL_CMSI ) ; if ( fBitCount < 65 ) { fBits1 = srcSet . fBits1 ; fBits2 = srcSet . fBits2 ; } else { for ( int index = fByteCount - 1 ; index >= 0 ; index -- ) fByteArray [ index ] = srcSet . fByteArray [ index ] ; } } final void zeroBits ( ) { if ( fBitCount < 65 ) { fBits1 = 0 ; fBits2 = 0 ; } else { for ( int index = fByteCount - 1 ; index >= 0 ; index -- ) fByteArray [ index ] = 0 ; } } int fBitCount ; int fByteCount ; int fBits1 ; int fBits2 ; byte [ ] fByteArray ; } ; 	0
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface DeclHandler { public abstract void elementDecl ( String name , String model ) throws SAXException ; public abstract void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException ; public abstract void internalEntityDecl ( String name , String value ) throws SAXException ; public abstract void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException ; } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Locale ; import java . util . Calendar ; import java . util . GregorianCalendar ; import java . text . ParseException ; import org . apache . xerces . utils . regex . RegularExpression ; import org . apache . xerces . validators . schema . SchemaSymbols ; public class RecurringDurationDatatypeValidator extends AbstractDatatypeValidator { private static final boolean fDbug = false ; private Locale fLocale = null ; DatatypeValidator fBaseValidator = null ; String fPattern = null ; long fMaxInclusive = Long . MAX_VALUE ; long fMaxExclusive = Long . MAX_VALUE - 1 ; long fMinInclusive = 1L ; long fMinExclusive = 0L ; long fDuration = 0L ; long fPeriod = 0L ; long [ ] fEnumrecurringduration = null ; boolean isMaxExclusiveDefined = false ; boolean isMaxInclusiveDefined = false ; boolean isMinExclusiveDefined = false ; boolean isMinInclusiveDefined = false ; boolean isBaseTypeTimePeriod = false ; int fFacetsDefined = 0 ; boolean fDerivedByList = false ; Hashtable fFacets = null ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; public RecurringDurationDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public RecurringDurationDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { fDerivedByList = derivedByList ; if ( base != null ) { setBasetype ( base ) ; fFacets = facets ; } if ( facets != null ) { if ( fDerivedByList == false ) { for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = ( String ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; continue ; } else if ( key . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMaxInclusive = normalizeRecurringDuration ( value . toCharArray ( ) , 0 ) ; } catch ( InvalidDatatypeValueException nfe ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXEXCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMaxExclusive = normalizeRecurringDuration ( value . toCharArray ( ) , 0 ) ; } catch ( InvalidDatatypeValueException nfe ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMinInclusive = normalizeRecurringDuration ( value . toCharArray ( ) , 0 ) ; } catch ( InvalidDatatypeValueException nfe ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMinExclusive = normalizeRecurringDuration ( value . toCharArray ( ) , 0 ) ; } catch ( InvalidDatatypeValueException nfe ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_PERIOD ) ) { fFacetsDefined += DatatypeValidator . FACET_PERIOD ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fPeriod = normalizeRecurringDuration ( value . toCharArray ( ) , 0 ) ; if ( fDbug == true ) { System . out . println ( "value = " + value ) ; System . out . println ( "fPeriod = " + fPeriod ) ; } } catch ( InvalidDatatypeValueException nfe ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_DURATION ) ) { fFacetsDefined += DatatypeValidator . FACET_DURATION ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fDuration = normalizeRecurringDuration ( value . toCharArray ( ) , 0 ) ; if ( fDbug == true ) { System . out . println ( "fDuration = " + fDuration ) ; } } catch ( InvalidDatatypeValueException nfe ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . MSG_FORMAT_FAILURE , DatatypeMessageProvider . MSG_NONE , null ) ) ; } } isMaxExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXEXCLUSIVE ) != 0 ) ? true : false ; isMaxInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXINCLUSIVE ) != 0 ) ? true : false ; isMinExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MINEXCLUSIVE ) != 0 ) ? true : false ; isMinInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MININCLUSIVE ) != 0 ) ? true : false ; if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both maxInclusive and maxExclusive to be specified for the same datatype." ) ; } if ( isMinExclusiveDefined && isMinInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both minInclusive and minExclusive to be specified for the same datatype." ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { Vector v = ( Vector ) facets . get ( SchemaSymbols . ELT_ENUMERATION ) ; if ( v != null ) { fEnumrecurringduration = new long [ v . size ( ) ] ; int i = 0 ; String value = null ; try { for ( ; i < v . size ( ) ; i ++ ) { value = ( String ) v . elementAt ( i ) ; fEnumrecurringduration [ i ] = normalizeRecurringDuration ( value . toCharArray ( ) , 0 ) ; boundsCheck ( fEnumrecurringduration [ i ] ) ; } if ( fDbug == true ) { System . out . println ( "The enumeration vectory is " + value ) ; for ( int enumCounter = 0 ; enumCounter < this . fEnumrecurringduration . length ; enumCounter ++ ) { System . out . println ( "fEnumrecurringduration[" + enumCounter + "]" ) ; } } } catch ( InvalidDatatypeValueException idve ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . InvalidEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { v . elementAt ( i ) } ) ) ; } } } if ( fBaseValidator != null ) { String value = null ; long baseTypePeriod ; try { Hashtable baseValidatorFacet = fBaseValidator . getFacets ( ) ; if ( baseValidatorFacet != null ) { value = ( ( String ) baseValidatorFacet . get ( SchemaSymbols . ELT_PERIOD ) ) ; if ( value != null ) { fPeriod = normalizeRecurringDuration ( value . toCharArray ( ) , 0 ) ; if ( fPeriod == 0 ) { isBaseTypeTimePeriod = true ; } if ( fDbug == true ) { System . out . println ( "value = " + value ) ; System . out . println ( "fPeriod = " + fPeriod ) ; } } } } catch ( InvalidDatatypeValueException nfe ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , SchemaSymbols . ELT_PERIOD } ) ) ; } } } else { } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { long normalizedValue ; if ( fDerivedByList == false ) { if ( fDbug == true ) { System . out . println ( "Write fFacetsDefined = " + fFacetsDefined ) ; if ( ( fFacetsDefined & DatatypeValidator . FACET_DURATION ) != 0 ) { System . out . println ( "Duration = " + this . fDuration ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_PERIOD ) != 0 ) { System . out . println ( "Period = " + this . fPeriod ) ; } System . out . println ( "datatype = " + this . fBaseValidator ) ; } if ( fPattern != null ) { RegularExpression regex = new RegularExpression ( fPattern , "X" ) ; if ( regex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value'" + content + "does not match regular expression facet" + fPattern ) ; } } else { } return null ; } public void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } public void setLocale ( Locale locale ) { } public int compare ( String content1 , String content2 ) { return - 1 ; } public Hashtable getFacets ( ) { return fFacets ; } private static long normalizeRecurringDuration ( char [ ] value , int start ) throws InvalidDatatypeValueException { long normalizedDuration = 0L ; return normalizedDuration ; } public static Calendar normalizeInstant ( char [ ] value , int start , int length ) throws InvalidDatatypeValueException { boolean negative = false ; boolean tznegative = false ; int tzoffset = 0 ; int tzhh = 0 , tzmm = 0 ; int i = start , j = 0 , k = 0 , l = 0 , m = 0 ; final char [ ] ms = { '0' , '0' , '0' } ; final Calendar cal = new GregorianCalendar ( ) ; final int endindex = ( start + length ) - 1 ; try { if ( length < 16 ) throw new ParseException ( "Value is too short." , 0 ) ; cal . clear ( ) ; cal . setLenient ( false ) ; if ( value [ i ] == '-' || value [ i ] == '+' ) { cal . set ( Calendar . ERA , ( value [ i ] == '-' ? GregorianCalendar . BC : GregorianCalendar . AD ) ) ; i ++ ; } j = indexOf ( value , i , '-' , i + 5 ) ; if ( j == - 1 || j > endindex ) throw new ParseException ( "Year separator is missing or misplaced." , i ) ; cal . set ( Calendar . YEAR , parseInt ( value , i , j - i ) ) ; i = j + 1 ; cal . set ( Calendar . MONTH , parseInt ( value , i , 2 ) - 1 ) ; i += 2 ; if ( value [ i ] != '-' ) throw new ParseException ( "Month separator is missing or misplaced." , i ) ; cal . set ( Calendar . DAY_OF_MONTH , parseInt ( value , i + 1 , 2 ) ) ; i += 3 ; if ( value [ i ] != 'T' ) throw new ParseException ( "Time separator is missing or misplaced." , i ) ; cal . set ( Calendar . HOUR_OF_DAY , parseInt ( value , i + 1 , 2 ) ) ; i += 3 ; if ( value [ i ] != ':' ) throw new ParseException ( "Hour separator is missing or misplaced." , i ) ; cal . set ( Calendar . MINUTE , parseInt ( value , i + 1 , 2 ) ) ; i += 3 ; if ( ( endindex - i ) > 1 && ( value [ i ] == ':' ) ) { cal . set ( Calendar . SECOND , parseInt ( value , i + 1 , 2 ) ) ; i += 3 ; if ( i < endindex && value [ i ] == '.' ) { i ++ ; k = 0 ; while ( ( i <= endindex ) && ( k < 3 ) && Character . isDigit ( value [ i ] ) ) ms [ k ++ ] = value [ i ++ ] ; cal . set ( Calendar . MILLISECOND , parseInt ( ms , 0 , 3 ) ) ; } while ( i <= endindex && Character . isDigit ( value [ i ] ) ) i ++ ; } if ( i <= endindex ) { if ( value [ i ] == 'Z' ) { cal . set ( Calendar . ZONE_OFFSET , 0 ) ; } else if ( value [ i ] == '-' || value [ i ] == '+' ) { tznegative = ( value [ i ] == '-' ) ; tzhh = parseInt ( value , i + 1 , 2 ) ; if ( ( endindex - i ) == 5 ) { if ( value [ i + 3 ] != ':' ) throw new ParseException ( "time zone must be 'hh:mm'." , i ) ; tzmm = parseInt ( value , i + 4 , 2 ) ; } tzoffset = ( ( tzhh * 3600000 ) + ( tzmm * 60000 ) ) ; cal . set ( Calendar . ZONE_OFFSET , ( tznegative ? - tzoffset : tzoffset ) ) ; } else throw new ParseException ( "Unrecognized time zone." , i ) ; } return ( cal ) ; } catch ( Exception e ) { if ( fDbug ) { e . printStackTrace ( ) ; return null ; } else { throw new InvalidDatatypeValueException ( "Unable to parse timeInstant " + e . toString ( ) ) ; } } } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } private void boundsCheck ( long f ) throws InvalidDatatypeFacetException { boolean inUpperBound = false ; boolean inLowerBound = false ; if ( isMaxInclusiveDefined ) { inUpperBound = ( f <= fMaxInclusive ) ; } else if ( isMaxExclusiveDefined ) { inUpperBound = ( f < fMaxExclusive ) ; } if ( isMinInclusiveDefined ) { inLowerBound = ( f >= fMinInclusive ) ; } else if ( isMinExclusiveDefined ) { inLowerBound = ( f > fMinExclusive ) ; } if ( inUpperBound == false || inLowerBound == false ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . OutOfBounds , DatatypeMessageProvider . MSG_NONE , new Object [ ] { new Long ( f ) , "" , "" , "" , "" } ) ) ; } } private void enumCheck ( long d ) throws InvalidDatatypeValueException { for ( int i = 0 ; i < this . fEnumrecurringduration . length ; i ++ ) { if ( d == fEnumrecurringduration [ i ] ) return ; } throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotAnEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { new Long ( d ) } ) ) ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } private static final int indexOf ( char [ ] value , int start , char s ) { return ( indexOf ( value , start , s , value . length - 1 ) ) ; } private static final int indexOf ( char [ ] value , int start , char s , int max ) { for ( int i = start ; i <= max ; i ++ ) if ( value [ i ] == s ) return ( i ) ; return ( - 1 ) ; } private static final int indexOneOf ( char [ ] value , int start , String s ) { return ( indexOneOf ( value , start , s , value . length - 1 ) ) ; } private static final int indexOneOf ( char [ ] value , int start , String s , int max ) { for ( int i = start ; i < max ; i ++ ) for ( int j = 0 ; j < s . length ( ) ; j ++ ) if ( value [ i ] == s . charAt ( j ) ) return ( i ) ; return ( - 1 ) ; } private static final int parseInt ( char [ ] s , int start , int length ) throws NumberFormatException { if ( s == null ) throw new NumberFormatException ( "null" ) ; int radix = 10 ; int result = 0 ; boolean negative = false ; int i = start ; int limit ; int multmin ; int digit = 0 ; if ( length <= 0 ) throw new NumberFormatException ( new String ( s , start , length ) ) ; if ( s [ i ] == '-' ) { negative = true ; limit = Integer . MIN_VALUE ; i ++ ; } else if ( s [ i ] == '+' ) { negative = false ; limit = - Integer . MAX_VALUE ; i ++ ; } else { limit = - Integer . MAX_VALUE ; } multmin = limit / radix ; if ( i < ( start + length ) ) { digit = Character . digit ( s [ i ++ ] , radix ) ; if ( digit < 0 ) throw new NumberFormatException ( new String ( s , start , length ) ) ; else result = - digit ; } while ( i < ( start + length ) ) { digit = Character . digit ( s [ i ++ ] , radix ) ; if ( digit < 0 ) throw new NumberFormatException ( new String ( s , start , length ) ) ; if ( result < multmin ) throw new NumberFormatException ( new String ( s , start , length ) ) ; result *= radix ; if ( result < limit + digit ) throw new NumberFormatException ( new String ( s , start , length ) ) ; result -= digit ; } if ( negative ) { if ( i > 1 ) return result ; else throw new NumberFormatException ( new String ( s , start , length ) ) ; } return - result ; } } 	0
package org . apache . xerces . validators . schema ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . validators . common . Grammar ; import org . apache . xerces . validators . common . GrammarResolver ; import org . apache . xerces . validators . common . GrammarResolverImpl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . schema . XUtil ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . utils . StringPool ; import org . w3c . dom . Element ; import org . w3c . dom . * ; import java . util . * ; import java . net . URL ; import java . net . MalformedURLException ; import org . apache . xerces . parsers . DOMParser ; import org . apache . xerces . validators . common . XMLValidator ; import org . apache . xerces . validators . datatype . DatatypeValidator . * ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . parsers . SAXParser ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . framework . XMLDocumentScanner ; import org . xml . sax . InputSource ; import org . xml . sax . SAXParseException ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import java . io . IOException ; import org . w3c . dom . Document ; import org . apache . xml . serialize . OutputFormat ; import org . apache . xml . serialize . XMLSerializer ; import org . apache . xerces . validators . schema . SchemaSymbols ; public class TraverseSchema implements NamespacesScope . NamespacesHandler { private static final int TOP_LEVEL_SCOPE = - 1 ; private static boolean DEBUGGING = false ; private XMLErrorReporter fErrorReporter = null ; private StringPool fStringPool = null ; private GrammarResolver fGrammarResolver = null ; private SchemaGrammar fSchemaGrammar = null ; private Element fSchemaRootElement ; private DatatypeValidatorFactoryImpl fDatatypeRegistry = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; private Hashtable fComplexTypeRegistry = new Hashtable ( ) ; private Hashtable fAttributeDeclRegistry = new Hashtable ( ) ; private Vector fIncludeLocations = new Vector ( ) ; private Vector fImportLocations = new Vector ( ) ; private int fAnonTypeCount = 0 ; private int fScopeCount = 0 ; private int fCurrentScope = TOP_LEVEL_SCOPE ; private int fSimpleTypeAnonCount = 0 ; private Stack fCurrentTypeNameStack = new Stack ( ) ; private Hashtable fElementRecurseComplex = new Hashtable ( ) ; private boolean fElementDefaultQualified = false ; private boolean fAttributeDefaultQualified = false ; private int fTargetNSURI ; private String fTargetNSURIString = "" ; private NamespacesScope fNamespacesScope = null ; private String fCurrentSchemaURL = "" ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; public class ComplexTypeInfo { public String typeName ; public DatatypeValidator baseDataTypeValidator ; public ComplexTypeInfo baseComplexTypeInfo ; public int derivedBy = 0 ; public int blockSet = 0 ; public int finalSet = 0 ; public boolean isAbstract = false ; public int scopeDefined = - 1 ; public int contentType ; public int contentSpecHandle = - 1 ; public int templateElementIndex = - 1 ; public int attlistHead = - 1 ; public DatatypeValidator datatypeValidator ; } public final static String SchemaForSchemaURI = "http://www.w3.org/TR-1/Schema" ; private TraverseSchema ( ) { } public void setGrammarResolver ( GrammarResolver grammarResolver ) { fGrammarResolver = grammarResolver ; } public void startNamespaceDeclScope ( int prefix , int uri ) { } public void endNamespaceDeclScope ( int prefix ) { } private String resolvePrefixToURI ( String prefix ) throws Exception { String uriStr = fStringPool . toString ( fNamespacesScope . getNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) ) ) ; if ( uriStr == null ) { reportGenericSchemaError ( "prefix : [" + prefix + "] can not be resolved to a URI" ) ; return "" ; } if ( prefix . length ( ) == 0 && uriStr . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && fTargetNSURIString . length ( ) == 0 ) { uriStr = "" ; } return uriStr ; } public TraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver , XMLErrorReporter errorReporter , String schemaURL ) throws Exception { fErrorReporter = errorReporter ; fCurrentSchemaURL = schemaURL ; doTraverseSchema ( root , stringPool , schemaGrammar , grammarResolver ) ; } public TraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver ) throws Exception { doTraverseSchema ( root , stringPool , schemaGrammar , grammarResolver ) ; } public void doTraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver ) throws Exception { fNamespacesScope = new NamespacesScope ( this ) ; fSchemaRootElement = root ; fStringPool = stringPool ; fSchemaGrammar = schemaGrammar ; fGrammarResolver = grammarResolver ; if ( root == null ) { return ; } String rootPrefix = root . getPrefix ( ) ; if ( rootPrefix == null || rootPrefix . length ( ) == 0 ) { String xmlns = root . getAttribute ( "xmlns" ) ; if ( xmlns . length ( ) == 0 ) root . setAttribute ( "xmlns" , SchemaSymbols . URI_SCHEMAFORSCHEMA ) ; } fTargetNSURIString = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( fTargetNSURIString == null ) { fTargetNSURIString = "" ; } fTargetNSURI = fStringPool . addSymbol ( fTargetNSURIString ) ; if ( fGrammarResolver == null ) { reportGenericSchemaError ( "Internal error: don't have a GrammarResolver for TraverseSchema" ) ; } else { fSchemaGrammar . setComplexTypeRegistry ( fComplexTypeRegistry ) ; fSchemaGrammar . setDatatypeRegistry ( fDatatypeRegistry ) ; fSchemaGrammar . setAttributeDeclRegistry ( fAttributeDeclRegistry ) ; fSchemaGrammar . setNamespacesScope ( fNamespacesScope ) ; fSchemaGrammar . setTargetNamespaceURI ( fTargetNSURIString ) ; fGrammarResolver . putGrammar ( fTargetNSURIString , fSchemaGrammar ) ; } NamedNodeMap schemaEltAttrs = root . getAttributes ( ) ; int i = 0 ; Attr sattr = null ; boolean seenXMLNS = false ; while ( ( sattr = ( Attr ) schemaEltAttrs . item ( i ++ ) ) != null ) { String attName = sattr . getName ( ) ; if ( attName . startsWith ( "xmlns:" ) ) { String attValue = sattr . getValue ( ) ; String prefix = attName . substring ( attName . indexOf ( ":" ) + 1 ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) , fStringPool . addSymbol ( attValue ) ) ; } if ( attName . equals ( "xmlns" ) ) { String attValue = sattr . getValue ( ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( attValue ) ) ; seenXMLNS = true ; } } if ( ! seenXMLNS && fTargetNSURIString . length ( ) == 0 ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } fElementDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ELEMENTFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; fAttributeDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ATTRIBUTEFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; if ( fTargetNSURI == StringPool . EMPTY_STRING ) { fElementDefaultQualified = true ; } fCurrentScope = - 1 ; checkTopLevelDuplicateNames ( root ) ; extractTopLevel3Components ( root ) ; for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { traverseSimpleTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { traverseComplexTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ELEMENT ) ) { traverseElementDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , null ) ; } else if ( name . equals ( SchemaSymbols . ELT_WILDCARD ) ) { traverseWildcardDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { } else if ( name . equals ( SchemaSymbols . ELT_NOTATION ) ) { ; } else if ( name . equals ( SchemaSymbols . ELT_INCLUDE ) ) { traverseInclude ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_IMPORT ) ) { traverseImport ( child ) ; } } } private void checkTopLevelDuplicateNames ( Element root ) { } private void extractTopLevel3Components ( Element root ) { for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { fSchemaGrammar . topLevelAttrGrpDecls . put ( name , child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { fSchemaGrammar . topLevelAttrDecls . put ( name , child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { fSchemaGrammar . topLevelGroupDecls . put ( name , child ) ; } } } private String expandSystemId ( String systemId , String currentSystemId ) throws Exception { String id = systemId ; if ( id == null || id . length ( ) == 0 ) { return systemId ; } try { URL url = new URL ( id ) ; if ( url != null ) { return systemId ; } } catch ( MalformedURLException e ) { } id = fixURI ( id ) ; URL base = null ; URL url = null ; try { if ( currentSystemId == null ) { String dir ; try { dir = fixURI ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { dir = "" ; } if ( ! dir . endsWith ( "/" ) ) { dir = dir + "/" ; } base = new URL ( "file" , "" , dir ) ; } else { base = new URL ( currentSystemId ) ; } url = new URL ( base , id ) ; } catch ( Exception e ) { } if ( url == null ) { return systemId ; } return url . toString ( ) ; } private static String fixURI ( String str ) { str = str . replace ( java . io . File . separatorChar , '/' ) ; if ( str . length ( ) >= 2 ) { char ch1 = str . charAt ( 1 ) ; if ( ch1 == ':' ) { char ch0 = Character . toUpperCase ( str . charAt ( 0 ) ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { str = "/" + str ; } } } return str ; } private void traverseInclude ( Element includeDecl ) throws Exception { String location = includeDecl . getAttribute ( SchemaSymbols . ATT_SCHEMALOCATION ) ; location = expandSystemId ( location , fCurrentSchemaURL ) ; if ( fIncludeLocations . contains ( ( Object ) location ) ) { return ; } fIncludeLocations . addElement ( ( Object ) location ) ; DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( location ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { } Document document = parser . getDocument ( ) ; Element root = null ; if ( document != null ) { root = document . getDocumentElement ( ) ; } if ( root != null ) { String targetNSURI = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( targetNSURI . length ( ) > 0 && ! targetNSURI . equals ( fTargetNSURIString ) ) { reportGenericSchemaError ( "included schema '" + location + "' has a different targetNameSpace '" + targetNSURI + "'" ) ; } else { boolean saveElementDefaultQualified = fElementDefaultQualified ; boolean saveAttributeDefaultQualified = fAttributeDefaultQualified ; int saveScope = fCurrentScope ; String savedSchemaURL = fCurrentSchemaURL ; Element saveRoot = fSchemaRootElement ; fSchemaRootElement = root ; fCurrentSchemaURL = location ; traverseIncludedSchema ( root ) ; fCurrentSchemaURL = savedSchemaURL ; fCurrentScope = saveScope ; fElementDefaultQualified = saveElementDefaultQualified ; fAttributeDefaultQualified = saveAttributeDefaultQualified ; fSchemaRootElement = saveRoot ; } } } private void traverseIncludedSchema ( Element root ) throws Exception { NamedNodeMap schemaEltAttrs = root . getAttributes ( ) ; int i = 0 ; Attr sattr = null ; boolean seenXMLNS = false ; while ( ( sattr = ( Attr ) schemaEltAttrs . item ( i ++ ) ) != null ) { String attName = sattr . getName ( ) ; if ( attName . startsWith ( "xmlns:" ) ) { String attValue = sattr . getValue ( ) ; String prefix = attName . substring ( attName . indexOf ( ":" ) + 1 ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) , fStringPool . addSymbol ( attValue ) ) ; } if ( attName . equals ( "xmlns" ) ) { String attValue = sattr . getValue ( ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( attValue ) ) ; seenXMLNS = true ; } } if ( ! seenXMLNS && fTargetNSURIString . length ( ) == 0 ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } fElementDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ELEMENTFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; fAttributeDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ATTRIBUTEFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; if ( fTargetNSURI == StringPool . EMPTY_STRING ) { fElementDefaultQualified = true ; } fCurrentScope = - 1 ; checkTopLevelDuplicateNames ( root ) ; extractTopLevel3Components ( root ) ; for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { traverseSimpleTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { traverseComplexTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ELEMENT ) ) { traverseElementDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , null ) ; } else if ( name . equals ( SchemaSymbols . ELT_WILDCARD ) ) { traverseWildcardDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { } else if ( name . equals ( SchemaSymbols . ELT_NOTATION ) ) { ; } else if ( name . equals ( SchemaSymbols . ELT_INCLUDE ) ) { traverseInclude ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_IMPORT ) ) { traverseImport ( child ) ; } } } private void traverseImport ( Element importDecl ) throws Exception { String location = importDecl . getAttribute ( SchemaSymbols . ATT_SCHEMALOCATION ) ; location = expandSystemId ( location , fCurrentSchemaURL ) ; String namespaceString = importDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) ; SchemaGrammar importedGrammar = new SchemaGrammar ( ) ; if ( fGrammarResolver . getGrammar ( namespaceString ) != null ) { importedGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( namespaceString ) ; } if ( fImportLocations . contains ( ( Object ) location ) ) { return ; } fImportLocations . addElement ( ( Object ) location ) ; DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( location ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } Document document = parser . getDocument ( ) ; Element root = null ; if ( document != null ) { root = document . getDocumentElement ( ) ; } if ( root != null ) { String targetNSURI = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( ! targetNSURI . equals ( namespaceString ) ) { reportGenericSchemaError ( "imported schema '" + location + "' has a different targetNameSpace '" + targetNSURI + "' from what is declared '" + namespaceString + "'." ) ; } else new TraverseSchema ( root , fStringPool , importedGrammar , fGrammarResolver , fErrorReporter , location ) ; } else { reportGenericSchemaError ( "Could not get the doc root for imported Schema file: " + location ) ; } } private void traverseAnnotationDecl ( Element comment ) { return ; } private int traverseSimpleTypeDecl ( Element simpleTypeDecl ) throws Exception { String varietyProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_DERIVEDBY ) ; if ( varietyProperty . length ( ) == 0 ) { varietyProperty = SchemaSymbols . ATTVAL_RESTRICTION ; } String nameProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; String baseTypeQNameProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) ; String abstractProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) ; int newSimpleTypeName = - 1 ; if ( nameProperty . equals ( "" ) ) { newSimpleTypeName = fStringPool . addSymbol ( "#S#" + fSimpleTypeAnonCount ++ ) ; } else newSimpleTypeName = fStringPool . addSymbol ( nameProperty ) ; int basetype ; DatatypeValidator baseValidator = null ; if ( baseTypeQNameProperty != null ) { basetype = fStringPool . addSymbol ( baseTypeQNameProperty ) ; String prefix = "" ; String localpart = baseTypeQNameProperty ; int colonptr = baseTypeQNameProperty . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = baseTypeQNameProperty . substring ( 0 , colonptr ) ; localpart = baseTypeQNameProperty . substring ( colonptr + 1 ) ; } String uri = resolvePrefixToURI ( prefix ) ; baseValidator = getDatatypeValidator ( uri , localpart ) ; if ( baseValidator == null ) { Element baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( baseTypeNode != null ) { traverseSimpleTypeDecl ( baseTypeNode ) ; baseValidator = getDatatypeValidator ( uri , localpart ) ; if ( baseValidator == null ) { reportSchemaError ( SchemaMessageProvider . UnknownBaseDatatype , new Object [ ] { simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) , simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) } ) ; return - 1 ; } } else { reportSchemaError ( SchemaMessageProvider . UnknownBaseDatatype , new Object [ ] { simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) , simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) } ) ; return - 1 ; } } } Element content = XUtil . getFirstChildElement ( simpleTypeDecl ) ; int numFacets = 0 ; Hashtable facetData = null ; if ( content != null ) { if ( content . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content ) ; content = XUtil . getNextSiblingElement ( content ) ; } int numEnumerationLiterals = 0 ; facetData = new Hashtable ( ) ; Vector enumData = new Vector ( ) ; while ( content != null ) { if ( content . getNodeType ( ) == Node . ELEMENT_NODE ) { Element facetElt = ( Element ) content ; numFacets ++ ; if ( facetElt . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { numEnumerationLiterals ++ ; String enumVal = facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ; enumData . addElement ( enumVal ) ; Element enumContent = XUtil . getFirstChildElement ( facetElt ) ; if ( enumContent != null && enumContent != null && enumContent . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content ) ; } } else { facetData . put ( facetElt . getNodeName ( ) , facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; } } content = XUtil . getNextSiblingElement ( content ) ; } if ( numEnumerationLiterals > 0 ) { facetData . put ( SchemaSymbols . ELT_ENUMERATION , enumData ) ; } } String nameOfType = fStringPool . toString ( newSimpleTypeName ) ; if ( fTargetNSURIString . length ( ) != 0 ) { nameOfType = fTargetNSURIString + "," + nameOfType ; } try { DatatypeValidator newValidator = fDatatypeRegistry . getDatatypeValidator ( nameOfType ) ; if ( newValidator == null ) { boolean derivedByList = varietyProperty . equals ( SchemaSymbols . ATTVAL_LIST ) ? true : false ; fDatatypeRegistry . createDatatypeValidator ( nameOfType , baseValidator , facetData , derivedByList ) ; } } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . DatatypeError , new Object [ ] { e . getMessage ( ) } ) ; } return fStringPool . addSymbol ( nameOfType ) ; } private int traverseAny ( Element child ) throws Exception { int anyIndex = - 1 ; String namespace = child . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) . trim ( ) ; String processContents = child . getAttribute ( "processContents" ) . trim ( ) ; int processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY ; int processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ; int processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ; if ( processContents . length ( ) > 0 && ! processContents . equals ( "strict" ) ) { if ( processContents . equals ( "lax" ) ) { processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY_LAX ; processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_LAX ; processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_LAX ; } else if ( processContents . equals ( "skip" ) ) { processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY_SKIP ; processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_SKIP ; processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_SKIP ; } } if ( namespace . length ( ) == 0 || namespace . equals ( "##any" ) ) { anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , - 1 , false ) ; } else if ( namespace . equals ( "##other" ) ) { String uri = child . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; int uriIndex = fStringPool . addSymbol ( uri ) ; anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAnyOther , - 1 , uriIndex , false ) ; } else if ( namespace . equals ( "##local" ) ) { anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAnyLocal , - 1 , - 1 , false ) ; } else if ( namespace . length ( ) > 0 ) { StringTokenizer tokenizer = new StringTokenizer ( namespace ) ; Vector tokens = new Vector ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( "##targetNamespace" ) ) { token = child . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; } tokens . addElement ( token ) ; } String uri = ( String ) tokens . elementAt ( 0 ) ; int uriIndex = fStringPool . addSymbol ( uri ) ; int leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; int valueIndex = leafIndex ; int count = tokens . size ( ) ; if ( count > 1 ) { uri = ( String ) tokens . elementAt ( 1 ) ; uriIndex = fStringPool . addSymbol ( uri ) ; leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; int otherValueIndex = leafIndex ; int choiceIndex = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , valueIndex , otherValueIndex , false ) ; for ( int i = 2 ; i < count ; i ++ ) { uri = ( String ) tokens . elementAt ( i ) ; uriIndex = fStringPool . addSymbol ( uri ) ; leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; otherValueIndex = leafIndex ; choiceIndex = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , choiceIndex , otherValueIndex , false ) ; } anyIndex = choiceIndex ; } else { anyIndex = leafIndex ; } } else { reportGenericSchemaError ( "Empty namespace attribute for any element" ) ; } return anyIndex ; } public DatatypeValidator getDatatypeValidator ( String uri , String localpart ) { DatatypeValidator dv = null ; if ( uri . length ( ) == 0 || uri . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { dv = fDatatypeRegistry . getDatatypeValidator ( localpart ) ; } else { dv = fDatatypeRegistry . getDatatypeValidator ( uri + "," + localpart ) ; } return dv ; } private XMLAttributeDecl traverseAnyAttribute ( Element anyAttributeDecl ) throws Exception { XMLAttributeDecl anyAttDecl = new XMLAttributeDecl ( ) ; String processContents = anyAttributeDecl . getAttribute ( SchemaSymbols . ATT_PROCESSCONTENTS ) . trim ( ) ; String namespace = anyAttributeDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) . trim ( ) ; String curTargetUri = anyAttributeDecl . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; if ( namespace . length ( ) == 0 || namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDANY ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_ANY ; } else if ( namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDOTHER ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_OTHER ; anyAttDecl . name . uri = fStringPool . addSymbol ( curTargetUri ) ; } else if ( namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDLOCAL ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_LOCAL ; } else if ( namespace . length ( ) > 0 ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_LIST ; StringTokenizer tokenizer = new StringTokenizer ( namespace ) ; int aStringList = fStringPool . startStringList ( ) ; Vector tokens = new Vector ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( "##targetNamespace" ) ) { token = curTargetUri ; } if ( ! fStringPool . addStringToList ( aStringList , fStringPool . addSymbol ( token ) ) ) { reportGenericSchemaError ( "Internal StringPool error when reading the " + "namespace attribute for anyattribute declaration" ) ; } } fStringPool . finishStringList ( aStringList ) ; anyAttDecl . enumeration = aStringList ; } else { reportGenericSchemaError ( "Empty namespace attribute for anyattribute declaration" ) ; } anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_STRICT ; if ( processContents . equals ( SchemaSymbols . ATTVAL_SKIP ) ) { anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_SKIP ; } else if ( processContents . equals ( SchemaSymbols . ATTVAL_LAX ) ) { anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_LAX ; } return anyAttDecl ; } private XMLAttributeDecl mergeTwoAnyAttribute ( XMLAttributeDecl oneAny , XMLAttributeDecl anotherAny ) { if ( oneAny . type == - 1 ) { return oneAny ; } if ( anotherAny . type == - 1 ) { return anotherAny ; } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return anotherAny ; } if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return oneAny ; } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( anotherAny . name . uri == oneAny . name . uri ) { return oneAny ; } else { oneAny . type = - 1 ; return oneAny ; } } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { return anotherAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( ! fStringPool . stringInList ( anotherAny . enumeration , oneAny . name . uri ) ) { return anotherAny ; } else { int [ ] anotherAnyURIs = fStringPool . stringListAsIntArray ( anotherAny . enumeration ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < anotherAnyURIs . length ; i ++ ) { if ( anotherAnyURIs [ i ] != oneAny . name . uri ) { fStringPool . addStringToList ( newList , anotherAnyURIs [ i ] ) ; } } fStringPool . finishStringList ( newList ) ; anotherAny . enumeration = newList ; return anotherAny ; } } } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER || anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { return oneAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { oneAny . type = - 1 ; return oneAny ; } } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( ! fStringPool . stringInList ( oneAny . enumeration , anotherAny . name . uri ) ) { return oneAny ; } else { int [ ] oneAnyURIs = fStringPool . stringListAsIntArray ( oneAny . enumeration ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < oneAnyURIs . length ; i ++ ) { if ( oneAnyURIs [ i ] != anotherAny . name . uri ) { fStringPool . addStringToList ( newList , oneAnyURIs [ i ] ) ; } } fStringPool . finishStringList ( newList ) ; oneAny . enumeration = newList ; return oneAny ; } } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { oneAny . type = - 1 ; return oneAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { int [ ] result = intersect2sets ( fStringPool . stringListAsIntArray ( oneAny . enumeration ) , fStringPool . stringListAsIntArray ( anotherAny . enumeration ) ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < result . length ; i ++ ) { fStringPool . addStringToList ( newList , result [ i ] ) ; } fStringPool . finishStringList ( newList ) ; oneAny . enumeration = newList ; return oneAny ; } } return oneAny ; } int [ ] intersect2sets ( int [ ] one , int [ ] theOther ) { int [ ] result = new int [ ( one . length > theOther . length ? one . length : theOther . length ) ] ; int count = 0 ; for ( int i = 0 ; i < one . length ; i ++ ) { for ( int j = 0 ; j < theOther . length ; j ++ ) { if ( one [ i ] == theOther [ j ] ) { result [ count ++ ] = one [ i ] ; } } } int [ ] result2 = new int [ count ] ; System . arraycopy ( result , 0 , result2 , 0 , count ) ; return result2 ; } private int traverseComplexTypeDecl ( Element complexTypeDecl ) throws Exception { String isAbstract = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) ; String base = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) ; String blockSet = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ; String content = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_CONTENT ) ; String derivedBy = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_DERIVEDBY ) ; String finalSet = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ; String typeId = complexTypeDecl . getAttribute ( SchemaSymbols . ATTVAL_ID ) ; String typeName = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; boolean isNamedType = false ; if ( DEBUGGING ) System . out . println ( "traversing complex Type : " + typeName + "," + base + "," + content + "." ) ; if ( typeName . equals ( "" ) ) { typeName = "#" + fAnonTypeCount ++ ; } else { fCurrentTypeNameStack . push ( typeName ) ; isNamedType = true ; } if ( isTopLevel ( complexTypeDecl ) ) { String fullName = fTargetNSURIString + "," + typeName ; ComplexTypeInfo temp = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fullName ) ; if ( temp != null ) { return fStringPool . addSymbol ( fullName ) ; } } int scopeDefined = fScopeCount ++ ; int previousScope = fCurrentScope ; fCurrentScope = scopeDefined ; Element child = null ; int contentSpecType = - 1 ; int csnType = 0 ; int left = - 2 ; int right = - 2 ; ComplexTypeInfo baseTypeInfo = null ; DatatypeValidator baseTypeValidator = null ; DatatypeValidator simpleTypeValidator = null ; int baseTypeSymbol = - 1 ; String fullBaseName = "" ; boolean baseIsSimpleSimple = false ; boolean baseIsComplexSimple = false ; boolean derivedByRestriction = true ; boolean derivedByExtension = false ; int baseContentSpecHandle = - 1 ; Element baseTypeNode = null ; if ( base . length ( ) > 0 ) { if ( derivedBy . length ( ) == 0 ) { reportGenericSchemaError ( "derivedBy must be present when base is present in " + SchemaSymbols . ELT_COMPLEXTYPE + " " + typeName ) ; } else { if ( derivedBy . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { derivedByRestriction = false ; } String prefix = "" ; String localpart = base ; int colonptr = base . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = base . substring ( 0 , colonptr ) ; localpart = base . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String typeURI = resolvePrefixToURI ( prefix ) ; if ( ! typeURI . equals ( fTargetNSURIString ) && ! typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && typeURI . length ( ) != 0 ) { baseTypeInfo = getTypeInfoFromNS ( typeURI , localpart ) ; if ( baseTypeInfo == null ) { baseTypeValidator = getTypeValidatorFromNS ( typeURI , localpart ) ; if ( baseTypeValidator == null ) { System . out . println ( "Could not find base type " + localpart + " in schema " + typeURI ) ; } else { baseIsSimpleSimple = true ; } } } else { fullBaseName = typeURI + "," + localpart ; baseTypeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fullBaseName ) ; if ( baseTypeInfo == null ) { baseTypeValidator = getDatatypeValidator ( typeURI , localpart ) ; if ( baseTypeValidator == null ) { baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_COMPLEXTYPE , localpart ) ; if ( baseTypeNode != null ) { baseTypeSymbol = traverseComplexTypeDecl ( baseTypeNode ) ; baseTypeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( baseTypeSymbol ) ) ; } else { baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( baseTypeNode != null ) { baseTypeSymbol = traverseSimpleTypeDecl ( baseTypeNode ) ; simpleTypeValidator = baseTypeValidator = getDatatypeValidator ( typeURI , localpart ) ; if ( simpleTypeValidator == null ) { } baseIsSimpleSimple = true ; } else { reportGenericSchemaError ( "Base type could not be found : " + base ) ; } } } else { simpleTypeValidator = baseTypeValidator ; baseIsSimpleSimple = true ; } } } if ( baseIsSimpleSimple && derivedByRestriction ) { reportGenericSchemaError ( "base is a simpledType, can't derive by restriction in " + typeName ) ; } if ( baseTypeInfo != null ) { if ( derivedByRestriction ) { } else { } if ( baseTypeInfo . contentSpecHandle > - 1 ) { if ( derivedByRestriction ) { checkParticleDerivationOK ( complexTypeDecl , baseTypeNode ) ; } baseContentSpecHandle = baseTypeInfo . contentSpecHandle ; } else if ( baseTypeInfo . datatypeValidator != null ) { baseTypeValidator = baseTypeInfo . datatypeValidator ; baseIsComplexSimple = true ; } } if ( baseIsComplexSimple && ! derivedByRestriction ) { reportGenericSchemaError ( "base is ComplexSimple, can't derive by extension in " + typeName ) ; } } } child = null ; if ( baseIsComplexSimple ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; int numEnumerationLiterals = 0 ; int numFacets = 0 ; Hashtable facetData = new Hashtable ( ) ; Vector enumData = new Vector ( ) ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null && ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MININCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PRECISION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SCALE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_LENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MINLENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXLENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENCODING ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PERIOD ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_DURATION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PATTERN ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { Element facetElt = ( Element ) child ; numFacets ++ ; if ( facetElt . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { numEnumerationLiterals ++ ; enumData . addElement ( facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; Element enumContent = XUtil . getFirstChildElement ( facetElt ) ; if ( enumContent != null && enumContent . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } } else { facetData . put ( facetElt . getNodeName ( ) , facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; } } } if ( numEnumerationLiterals > 0 ) { facetData . put ( SchemaSymbols . ELT_ENUMERATION , enumData ) ; } if ( numFacets > 0 ) { simpleTypeValidator = fDatatypeRegistry . createDatatypeValidator ( typeName , baseTypeValidator , facetData , false ) ; } else simpleTypeValidator = baseTypeValidator ; if ( child != null ) { reportGenericSchemaError ( "Invalid child '" + child . getNodeName ( ) + "' in complexType : '" + typeName + "', because it restricts another complexSimpleType" ) ; } } if ( content . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { if ( base . length ( ) == 0 ) { simpleTypeValidator = baseTypeValidator = getDatatypeValidator ( "" , SchemaSymbols . ATTVAL_STRING ) ; } else if ( baseTypeValidator == null && baseTypeInfo != null && baseTypeInfo . datatypeValidator == null ) reportSchemaError ( SchemaMessageProvider . NotADatatype , new Object [ ] { base } ) ; contentSpecType = XMLElementDecl . TYPE_SIMPLE ; } else { if ( ! baseIsComplexSimple ) { contentSpecType = XMLElementDecl . TYPE_CHILDREN ; } csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; boolean mixedContent = false ; boolean elementContent = true ; boolean textContent = false ; boolean emptyContent = false ; left = - 2 ; right = - 2 ; boolean hadContent = false ; if ( content . equals ( SchemaSymbols . ATTVAL_EMPTY ) ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; emptyContent = true ; elementContent = false ; left = - 1 ; } else if ( content . equals ( SchemaSymbols . ATTVAL_MIXED ) ) { contentSpecType = XMLElementDecl . TYPE_MIXED ; mixedContent = true ; elementContent = false ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; } else if ( content . equals ( SchemaSymbols . ATTVAL_ELEMENTONLY ) || content . equals ( "" ) ) { elementContent = true ; } else if ( content . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { textContent = true ; elementContent = false ; } if ( mixedContent ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , - 1 , - 1 , false ) ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; } boolean seeParticle = false ; boolean seeOtherParticle = false ; boolean seeAll = false ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { if ( mixedContent || elementContent ) { if ( DEBUGGING ) System . out . println ( " child element name " + child . getAttribute ( SchemaSymbols . ATT_NAME ) ) ; QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; seeOtherParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . EltRefOnlyInMixedElemOnly , null ) ; } } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeParticle = true ; seeAll = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTE ) || childName . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { break ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } else if ( childName . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { break ; } else { if ( ! baseIsComplexSimple ) if ( base . equals ( "" ) ) reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "unrecogized child '" + childName + "' in compelx type " + typeName } ) ; else reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "unrecogized child '" + childName + "' in compelx type '" + typeName + "' with base " + base } ) ; } if ( baseIsComplexSimple && seeParticle ) { reportGenericSchemaError ( "In complexType " + typeName + ", base type is complextype with simpleType content, can't have any particle children at all" ) ; hadContent = false ; left = index = - 2 ; contentSpecType = XMLElementDecl . TYPE_SIMPLE ; break ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( seeAll && seeOtherParticle ) { reportGenericSchemaError ( " 'All' group needs to be the only child in Complextype : " + typeName ) ; } if ( seeAll ) { } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( ! ( seeOtherParticle || seeAll ) && ( elementContent || mixedContent ) && ( base . length ( ) == 0 || ( base . length ( ) > 0 && derivedByRestriction && ! baseIsComplexSimple ) ) ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; simpleTypeValidator = getDatatypeValidator ( "" , SchemaSymbols . ATTVAL_STRING ) ; reportGenericSchemaError ( " complexType '" + typeName + "' with a elementOnly or mixed content " + "need to have at least one particle child" ) ; } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; if ( mixedContent && hadContent ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , left , - 1 , false ) ; } } if ( ! derivedByRestriction && baseContentSpecHandle > - 1 ) { if ( left == - 2 ) { left = baseContentSpecHandle ; } else left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , baseContentSpecHandle , left , false ) ; } if ( content . length ( ) == 0 && base . length ( ) == 0 && left == - 2 ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } if ( content . length ( ) == 0 && simpleTypeValidator == null && left == - 2 ) { if ( base . length ( ) > 0 && baseTypeInfo != null && baseTypeInfo . contentType == XMLElementDecl . TYPE_EMPTY ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; } } if ( DEBUGGING ) System . out . println ( "!!!!!>>>>>" + typeName + ", " + baseTypeInfo + ", " + baseContentSpecHandle + ", " + left + ", " + scopeDefined ) ; ComplexTypeInfo typeInfo = new ComplexTypeInfo ( ) ; typeInfo . baseComplexTypeInfo = baseTypeInfo ; typeInfo . baseDataTypeValidator = baseTypeValidator ; int derivedByInt = - 1 ; if ( derivedBy . length ( ) > 0 ) { derivedByInt = parseComplexDerivedBy ( derivedBy ) ; } typeInfo . derivedBy = derivedByInt ; typeInfo . scopeDefined = scopeDefined ; typeInfo . contentSpecHandle = left ; typeInfo . contentType = contentSpecType ; typeInfo . datatypeValidator = simpleTypeValidator ; typeInfo . blockSet = parseBlockSet ( complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ) ; typeInfo . finalSet = parseFinalSet ( complexTypeDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ) ; typeInfo . isAbstract = isAbstract . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; int typeNameIndex = fStringPool . addSymbol ( typeName ) ; int templateElementNameIndex = fStringPool . addSymbol ( "$" + typeName ) ; typeInfo . templateElementIndex = fSchemaGrammar . addElementDecl ( new QName ( - 1 , templateElementNameIndex , typeNameIndex , fTargetNSURI ) , ( fTargetNSURI == - 1 ) ? - 1 : fCurrentScope , scopeDefined , contentSpecType , left , - 1 , simpleTypeValidator ) ; typeInfo . attlistHead = fSchemaGrammar . getFirstAttributeDeclIndex ( typeInfo . templateElementIndex ) ; XMLAttributeDecl attWildcard = null ; Vector anyAttDecls = new Vector ( ) ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { if ( ( baseIsComplexSimple || baseIsSimpleSimple ) && derivedByRestriction ) { reportGenericSchemaError ( "In complexType " + typeName + ", base type has simpleType " + "content and derivation method is" + " 'restriction', can't have any " + "attribute children at all" ) ; break ; } traverseAttributeDecl ( child , typeInfo ) ; } else if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { if ( ( baseIsComplexSimple || baseIsSimpleSimple ) && derivedByRestriction ) { reportGenericSchemaError ( "In complexType " + typeName + ", base " + "type has simpleType content and " + "derivation method is 'restriction'," + " can't have any attribute children at all" ) ; break ; } traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( childName . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { attWildcard = traverseAnyAttribute ( child ) ; } } if ( attWildcard != null ) { XMLAttributeDecl fromGroup = null ; final int count = anyAttDecls . size ( ) ; if ( count > 0 ) { fromGroup = ( XMLAttributeDecl ) anyAttDecls . elementAt ( 0 ) ; for ( int i = 1 ; i < count ; i ++ ) { fromGroup = mergeTwoAnyAttribute ( fromGroup , ( XMLAttributeDecl ) anyAttDecls . elementAt ( i ) ) ; } } if ( fromGroup != null ) { int saveProcessContents = attWildcard . defaultType ; attWildcard = mergeTwoAnyAttribute ( attWildcard , fromGroup ) ; attWildcard . defaultType = saveProcessContents ; } } else { } XMLAttributeDecl baseAttWildcard = null ; if ( baseTypeInfo != null && baseTypeInfo . attlistHead > - 1 ) { int attDefIndex = baseTypeInfo . attlistHead ; while ( attDefIndex > - 1 ) { fTempAttributeDecl . clear ( ) ; fSchemaGrammar . getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_ANY || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_LIST || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( attWildcard == null ) { baseAttWildcard = fTempAttributeDecl ; } attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; continue ; } int temp = fSchemaGrammar . getAttributeDeclIndex ( typeInfo . templateElementIndex , fTempAttributeDecl . name ) ; if ( temp > - 1 ) { if ( derivedByRestriction ) { attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; continue ; } } fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , fTempAttributeDecl . name , fTempAttributeDecl . type , fTempAttributeDecl . enumeration , fTempAttributeDecl . defaultType , fTempAttributeDecl . defaultValue , fTempAttributeDecl . datatypeValidator , fTempAttributeDecl . list ) ; attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } if ( attWildcard != null ) { if ( attWildcard . type != - 1 ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , attWildcard . name , attWildcard . type , attWildcard . enumeration , attWildcard . defaultType , attWildcard . defaultValue , attWildcard . datatypeValidator , attWildcard . list ) ; } else { } } else if ( baseAttWildcard != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , baseAttWildcard . name , baseAttWildcard . type , baseAttWildcard . enumeration , baseAttWildcard . defaultType , baseAttWildcard . defaultValue , baseAttWildcard . datatypeValidator , baseAttWildcard . list ) ; } typeInfo . attlistHead = fSchemaGrammar . getFirstAttributeDeclIndex ( typeInfo . templateElementIndex ) ; if ( ! typeName . startsWith ( "#" ) ) { typeName = fTargetNSURIString + "," + typeName ; } typeInfo . typeName = new String ( typeName ) ; if ( DEBUGGING ) System . out . println ( "add complex Type to Registry: " + typeName + "," + content + "." ) ; fComplexTypeRegistry . put ( typeName , typeInfo ) ; fCurrentScope = previousScope ; if ( isNamedType ) { fCurrentTypeNameStack . pop ( ) ; checkRecursingComplexType ( ) ; } fSchemaGrammar . setElementComplexTypeInfo ( typeInfo . templateElementIndex , typeInfo ) ; typeNameIndex = fStringPool . addSymbol ( typeName ) ; return typeNameIndex ; } private void checkRecursingComplexType ( ) throws Exception { if ( fCurrentTypeNameStack . empty ( ) ) { if ( ! fElementRecurseComplex . isEmpty ( ) ) { Enumeration e = fElementRecurseComplex . keys ( ) ; while ( e . hasMoreElements ( ) ) { QName nameThenScope = ( QName ) e . nextElement ( ) ; String typeName = ( String ) fElementRecurseComplex . get ( nameThenScope ) ; int eltUriIndex = nameThenScope . uri ; int eltNameIndex = nameThenScope . localpart ; int enclosingScope = nameThenScope . prefix ; ComplexTypeInfo typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fTargetNSURIString + "," + typeName ) ; if ( typeInfo == null ) { throw new Exception ( "Internal Error in void checkRecursingComplexType(). " ) ; } else { int elementIndex = fSchemaGrammar . addElementDecl ( new QName ( - 1 , eltNameIndex , eltNameIndex , eltUriIndex ) , enclosingScope , typeInfo . scopeDefined , typeInfo . contentType , typeInfo . contentSpecHandle , typeInfo . attlistHead , typeInfo . datatypeValidator ) ; fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } } fElementRecurseComplex . clear ( ) ; } } } private void checkParticleDerivationOK ( Element derivedTypeNode , Element baseTypeNode ) { } private int expandContentModel ( int index , Element particle ) throws Exception { String minOccurs = particle . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ; String maxOccurs = particle . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ; int min = 1 , max = 1 ; if ( minOccurs . equals ( "" ) ) { minOccurs = "1" ; } if ( maxOccurs . equals ( "" ) ) { if ( minOccurs . equals ( "0" ) ) { maxOccurs = "1" ; } else { maxOccurs = minOccurs ; } } int leafIndex = index ; if ( minOccurs . equals ( "1" ) && maxOccurs . equals ( "1" ) ) { } else if ( minOccurs . equals ( "0" ) && maxOccurs . equals ( "1" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , index , - 1 , false ) ; } else if ( minOccurs . equals ( "0" ) && maxOccurs . equals ( "unbounded" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , index , - 1 , false ) ; } else if ( minOccurs . equals ( "1" ) && maxOccurs . equals ( "unbounded" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , index , - 1 , false ) ; } else if ( maxOccurs . equals ( "unbounded" ) ) { try { min = Integer . parseInt ( minOccurs ) ; } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "illegal value for minOccurs : '" + e . getMessage ( ) + "' " } ) ; } if ( min < 2 ) { } index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , index , - 1 , false ) ; for ( int i = 0 ; i < ( min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , leafIndex , index , false ) ; } } else { try { min = Integer . parseInt ( minOccurs ) ; max = Integer . parseInt ( maxOccurs ) ; } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "illegal value for minOccurs or maxOccurs : '" + e . getMessage ( ) + "' " } ) ; } if ( min == 0 ) { int optional = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , leafIndex , - 1 , false ) ; index = optional ; for ( int i = 0 ; i < ( max - min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , optional , false ) ; } } else { for ( int i = 0 ; i < ( min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , leafIndex , false ) ; } int optional = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , leafIndex , - 1 , false ) ; for ( int i = 0 ; i < ( max - min ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , optional , false ) ; } } } return index ; } private int traverseAttributeDecl ( Element attrDecl , ComplexTypeInfo typeInfo ) throws Exception { String attNameStr = attrDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; int attName = fStringPool . addSymbol ( attNameStr ) ; String isQName = attrDecl . getAttribute ( SchemaSymbols . ATT_FORM ) ; DatatypeValidator dv = null ; int attType = - 1 ; boolean attIsList = false ; int dataTypeSymbol = - 1 ; String ref = attrDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; String datatype = attrDecl . getAttribute ( SchemaSymbols . ATT_TYPE ) ; String localpart = null ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( attrDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { addAttributeDeclFromAnotherSchema ( localpart , uriStr , typeInfo ) ; return - 1 ; } Element referredAttribute = getTopLevelComponentByName ( SchemaSymbols . ELT_ATTRIBUTE , localpart ) ; if ( referredAttribute != null ) { traverseAttributeDecl ( referredAttribute , typeInfo ) ; } else { reportGenericSchemaError ( "Couldn't find top level attribute " + ref ) ; } return - 1 ; } if ( datatype . equals ( "" ) ) { Element child = XUtil . getFirstChildElement ( attrDecl ) ; while ( child != null && ! child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) child = XUtil . getNextSiblingElement ( child ) ; if ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { attType = XMLAttributeDecl . TYPE_SIMPLE ; dataTypeSymbol = traverseSimpleTypeDecl ( child ) ; localpart = fStringPool . toString ( dataTypeSymbol ) ; } else { attType = XMLAttributeDecl . TYPE_SIMPLE ; localpart = "string" ; dataTypeSymbol = fStringPool . addSymbol ( localpart ) ; } localpart = fStringPool . toString ( dataTypeSymbol ) ; dv = fDatatypeRegistry . getDatatypeValidator ( localpart ) ; } else { String prefix = "" ; localpart = datatype ; dataTypeSymbol = fStringPool . addSymbol ( localpart ) ; int colonptr = datatype . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = datatype . substring ( 0 , colonptr ) ; localpart = datatype . substring ( colonptr + 1 ) ; } String typeURI = resolvePrefixToURI ( prefix ) ; if ( typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) || typeURI . length ( ) == 0 ) { dv = getDatatypeValidator ( "" , localpart ) ; if ( localpart . equals ( "ID" ) ) { attType = XMLAttributeDecl . TYPE_ID ; } else if ( localpart . equals ( "IDREF" ) ) { attType = XMLAttributeDecl . TYPE_IDREF ; } else if ( localpart . equals ( "IDREFS" ) ) { attType = XMLAttributeDecl . TYPE_IDREF ; attIsList = true ; } else if ( localpart . equals ( "ENTITY" ) ) { attType = XMLAttributeDecl . TYPE_ENTITY ; } else if ( localpart . equals ( "ENTITIES" ) ) { attType = XMLAttributeDecl . TYPE_ENTITY ; attIsList = true ; } else if ( localpart . equals ( "NMTOKEN" ) ) { attType = XMLAttributeDecl . TYPE_NMTOKEN ; } else if ( localpart . equals ( "NMTOKENS" ) ) { attType = XMLAttributeDecl . TYPE_NMTOKEN ; attIsList = true ; } else if ( localpart . equals ( SchemaSymbols . ELT_NOTATION ) ) { attType = XMLAttributeDecl . TYPE_NOTATION ; } else { attType = XMLAttributeDecl . TYPE_SIMPLE ; if ( dv == null && typeURI . length ( ) == 0 ) { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { reportGenericSchemaError ( "simpleType not found : " + localpart ) ; } } } } else { dv = getDatatypeValidator ( typeURI , localpart ) ; if ( dv == null && typeURI . equals ( fTargetNSURIString ) ) { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { reportGenericSchemaError ( "simpleType not found : " + localpart ) ; } } attType = XMLAttributeDecl . TYPE_SIMPLE ; } } int attDefaultType = - 1 ; int attDefaultValue = - 1 ; String use = attrDecl . getAttribute ( SchemaSymbols . ATT_USE ) ; boolean required = use . equals ( SchemaSymbols . ATTVAL_REQUIRED ) ; if ( dv == null ) { reportGenericSchemaError ( "could not resolve the type or get a null validator for datatype : " + fStringPool . toString ( dataTypeSymbol ) ) ; } if ( required ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; } else { if ( use . equals ( SchemaSymbols . ATTVAL_FIXED ) ) { String fixed = attrDecl . getAttribute ( SchemaSymbols . ATT_VALUE ) ; if ( ! fixed . equals ( "" ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_FIXED ; attDefaultValue = fStringPool . addString ( fixed ) ; } } else if ( use . equals ( SchemaSymbols . ATTVAL_DEFAULT ) ) { String defaultValue = attrDecl . getAttribute ( SchemaSymbols . ATT_VALUE ) ; if ( ! defaultValue . equals ( "" ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_DEFAULT ; attDefaultValue = fStringPool . addString ( defaultValue ) ; } } else if ( use . equals ( SchemaSymbols . ATTVAL_PROHIBITED ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } else { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } if ( attType == XMLAttributeDecl . TYPE_SIMPLE && attDefaultValue != - 1 ) { try { if ( dv != null ) dv . validate ( fStringPool . toString ( attDefaultValue ) , null ) ; else reportSchemaError ( SchemaMessageProvider . NoValidatorFor , new Object [ ] { datatype } ) ; } catch ( InvalidDatatypeValueException idve ) { reportSchemaError ( SchemaMessageProvider . IncorrectDefaultType , new Object [ ] { attrDecl . getAttribute ( SchemaSymbols . ATT_NAME ) , idve . getMessage ( ) } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . out . println ( "Internal error in attribute datatype validation" ) ; } } } int uriIndex = - 1 ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fAttributeDefaultQualified || isTopLevel ( attrDecl ) ) { uriIndex = fTargetNSURI ; } QName attQName = new QName ( - 1 , attName , attName , uriIndex ) ; if ( DEBUGGING ) System . out . println ( " the dataType Validator for " + fStringPool . toString ( attName ) + " is " + dv ) ; if ( isTopLevel ( attrDecl ) ) { fTempAttributeDecl . datatypeValidator = dv ; fTempAttributeDecl . name . setValues ( attQName ) ; fTempAttributeDecl . type = attType ; fTempAttributeDecl . defaultType = attDefaultType ; fTempAttributeDecl . list = attIsList ; if ( attDefaultValue != - 1 ) { fTempAttributeDecl . defaultValue = new String ( fStringPool . toString ( attDefaultValue ) ) ; } fAttributeDeclRegistry . put ( attNameStr , new XMLAttributeDecl ( fTempAttributeDecl ) ) ; } if ( typeInfo != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , attQName , attType , dataTypeSymbol , attDefaultType , fStringPool . toString ( attDefaultValue ) , dv , attIsList ) ; } return - 1 ; } private int addAttributeDeclFromAnotherSchema ( String name , String uriStr , ComplexTypeInfo typeInfo ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #addAttributeDeclFromAnotherSchema, schema uri : " + uriStr ) ; return - 1 ; } Hashtable attrRegistry = aGrammar . getAttirubteDeclRegistry ( ) ; if ( attrRegistry == null ) { reportGenericSchemaError ( "no attribute was defined in schema : " + uriStr ) ; return - 1 ; } XMLAttributeDecl tempAttrDecl = ( XMLAttributeDecl ) attrRegistry . get ( name ) ; if ( tempAttrDecl == null ) { reportGenericSchemaError ( "no attribute named \"" + name + "\" was defined in schema : " + uriStr ) ; return - 1 ; } if ( typeInfo != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , tempAttrDecl . name , tempAttrDecl . type , - 1 , tempAttrDecl . defaultType , tempAttrDecl . defaultValue , tempAttrDecl . datatypeValidator , tempAttrDecl . list ) ; } return 0 ; } private int traverseAttributeGroupDecl ( Element attrGrpDecl , ComplexTypeInfo typeInfo , Vector anyAttDecls ) throws Exception { int attGrpName = fStringPool . addSymbol ( attrGrpDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ) ; String ref = attrGrpDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; int attType = - 1 ; int enumeration = - 1 ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( attrGrpDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { traverseAttributeGroupDeclFromAnotherSchema ( localpart , uriStr , typeInfo , anyAttDecls ) ; return - 1 ; } Element referredAttrGrp = getTopLevelComponentByName ( SchemaSymbols . ELT_ATTRIBUTEGROUP , localpart ) ; if ( referredAttrGrp != null ) { traverseAttributeGroupDecl ( referredAttrGrp , typeInfo , anyAttDecls ) ; } else { reportGenericSchemaError ( "Couldn't find top level attributegroup " + ref ) ; } return - 1 ; } for ( Element child = XUtil . getFirstChildElement ( attrGrpDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , typeInfo ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { anyAttDecls . addElement ( traverseAnyAttribute ( child ) ) ; break ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } } return - 1 ; } private int traverseAttributeGroupDeclFromAnotherSchema ( String attGrpName , String uriStr , ComplexTypeInfo typeInfo , Vector anyAttDecls ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #traverseAttributeGroupDeclFromAnotherSchema, schema uri : " + uriStr ) ; return - 1 ; } Element attGrpDecl = ( Element ) aGrammar . topLevelAttrGrpDecls . get ( ( Object ) attGrpName ) ; if ( attGrpDecl == null ) { reportGenericSchemaError ( "no attribute group named \"" + attGrpName + "\" was defined in schema : " + uriStr ) ; return - 1 ; } NamespacesScope saveNSMapping = fNamespacesScope ; int saveTargetNSUri = fTargetNSURI ; fTargetNSURI = fStringPool . addSymbol ( aGrammar . getTargetNamespaceURI ( ) ) ; fNamespacesScope = aGrammar . getNamespacesScope ( ) ; int attType = - 1 ; int enumeration = - 1 ; for ( Element child = XUtil . getFirstChildElement ( attGrpDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { String childAttName = child . getAttribute ( SchemaSymbols . ATT_NAME ) ; if ( childAttName . length ( ) > 0 ) { Hashtable attDeclRegistry = aGrammar . getAttirubteDeclRegistry ( ) ; if ( attDeclRegistry != null ) { if ( attDeclRegistry . get ( ( Object ) childAttName ) != null ) { addAttributeDeclFromAnotherSchema ( childAttName , uriStr , typeInfo ) ; return - 1 ; } } } else traverseAttributeDecl ( child , typeInfo ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { anyAttDecls . addElement ( traverseAnyAttribute ( child ) ) ; break ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } } fNamespacesScope = saveNSMapping ; fTargetNSURI = saveTargetNSUri ; return - 1 ; } private QName traverseElementDecl ( Element elementDecl ) throws Exception { int contentSpecType = - 1 ; int contentSpecNodeIndex = - 1 ; int typeNameIndex = - 1 ; int scopeDefined = - 2 ; DatatypeValidator dv = null ; String name = elementDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; if ( DEBUGGING ) System . out . println ( "traversing element decl : " + name ) ; String ref = elementDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; String type = elementDecl . getAttribute ( SchemaSymbols . ATT_TYPE ) ; String minOccurs = elementDecl . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ; String maxOccurs = elementDecl . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ; String dflt = elementDecl . getAttribute ( SchemaSymbols . ATT_DEFAULT ) ; String fixed = elementDecl . getAttribute ( SchemaSymbols . ATT_FIXED ) ; String equivClass = elementDecl . getAttribute ( SchemaSymbols . ATT_EQUIVCLASS ) ; String isQName = elementDecl . getAttribute ( SchemaSymbols . ATT_FORM ) ; String fromAnotherSchema = null ; if ( isTopLevel ( elementDecl ) ) { int nameIndex = fStringPool . addSymbol ( name ) ; int eltKey = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , nameIndex , TOP_LEVEL_SCOPE ) ; if ( eltKey > - 1 ) { return new QName ( - 1 , nameIndex , nameIndex , fTargetNSURI ) ; } } int blockSet = parseBlockSet ( elementDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ) ; int finalSet = parseFinalSet ( elementDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ) ; boolean isNullable = elementDecl . getAttribute ( SchemaSymbols . ATT_NULLABLE ) . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; boolean isAbstract = elementDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; int elementMiscFlags = 0 ; if ( isNullable ) { elementMiscFlags += SchemaSymbols . NULLABLE ; } if ( isAbstract ) { elementMiscFlags += SchemaSymbols . ABSTRACT ; } int attrCount = 0 ; if ( ! ref . equals ( "" ) ) attrCount ++ ; if ( ! type . equals ( "" ) ) attrCount ++ ; if ( attrCount > 1 ) reportSchemaError ( SchemaMessageProvider . OneOfTypeRefArchRef , null ) ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( elementDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String uriString = resolvePrefixToURI ( prefix ) ; QName eltName = new QName ( prefix != null ? fStringPool . addSymbol ( prefix ) : - 1 , localpartIndex , fStringPool . addSymbol ( ref ) , uriString != null ? fStringPool . addSymbol ( uriString ) : - 1 ) ; if ( ! uriString . equals ( fTargetNSURIString ) ) { return eltName ; } int elementIndex = fSchemaGrammar . getElementDeclIndex ( eltName , TOP_LEVEL_SCOPE ) ; if ( elementIndex == - 1 ) { Element targetElement = getTopLevelComponentByName ( SchemaSymbols . ELT_ELEMENT , localpart ) ; if ( targetElement == null ) { reportGenericSchemaError ( "Element " + localpart + " not found in the Schema" ) ; return eltName ; } else { } } return eltName ; } Element equivClassElementDecl = null ; int equivClassElementDeclIndex = - 1 ; boolean noErrorSoFar = true ; String equivClassUri = null ; String equivClassLocalpart = null ; String equivClassFullName = null ; ComplexTypeInfo equivClassEltTypeInfo = null ; DatatypeValidator equivClassEltDV = null ; if ( equivClass . length ( ) > 0 ) { equivClassUri = resolvePrefixToURI ( getPrefix ( equivClass ) ) ; equivClassLocalpart = getLocalPart ( equivClass ) ; equivClassFullName = equivClassUri + "," + equivClassLocalpart ; if ( ! equivClassUri . equals ( fTargetNSURIString ) ) { equivClassEltTypeInfo = getElementDeclTypeInfoFromNS ( equivClassUri , equivClassLocalpart ) ; if ( equivClassEltTypeInfo == null ) { equivClassEltDV = getElementDeclTypeValidatorFromNS ( equivClassUri , equivClassLocalpart ) ; if ( equivClassEltDV == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type for element '" + equivClassLocalpart + "' in schema '" + equivClassUri + "'" ) ; } } } else { equivClassElementDecl = getTopLevelComponentByName ( SchemaSymbols . ELT_ELEMENT , equivClassLocalpart ) ; if ( equivClassElementDecl == null ) { equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; if ( equivClassElementDeclIndex == - 1 ) { noErrorSoFar = false ; reportGenericSchemaError ( "Equivclass affiliation element " + equivClass + " in element declaration " + name ) ; } } else { equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; if ( equivClassElementDeclIndex == - 1 ) { traverseElementDecl ( equivClassElementDecl ) ; equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; } } if ( equivClassElementDeclIndex != - 1 ) { equivClassEltTypeInfo = fSchemaGrammar . getElementComplexTypeInfo ( equivClassElementDeclIndex ) ; if ( equivClassEltTypeInfo == null ) { fSchemaGrammar . getElementDecl ( equivClassElementDeclIndex , fTempElementDecl ) ; equivClassEltDV = fTempElementDecl . datatypeValidator ; if ( equivClassEltDV == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type for element '" + equivClassLocalpart + "' in schema '" + equivClassUri + "'" ) ; } } } } } ComplexTypeInfo typeInfo = null ; Element child = XUtil . getFirstChildElement ( elementDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; boolean haveAnonType = false ; if ( child != null ) { String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . length ( ) > 0 ) { noErrorSoFar = false ; reportGenericSchemaError ( "anonymous complexType in element '" + name + "' has a name attribute" ) ; } else typeNameIndex = traverseComplexTypeDecl ( child ) ; if ( typeNameIndex != - 1 ) { typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( typeNameIndex ) ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "traverse complexType error in element '" + name + "'" ) ; } haveAnonType = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . length ( ) > 0 ) { noErrorSoFar = false ; reportGenericSchemaError ( "anonymous simpleType in element '" + name + "' has a name attribute" ) ; } else typeNameIndex = traverseSimpleTypeDecl ( child ) ; if ( typeNameIndex != - 1 ) { dv = fDatatypeRegistry . getDatatypeValidator ( fStringPool . toString ( typeNameIndex ) ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "traverse simpleType error in element '" + name + "'" ) ; } contentSpecType = XMLElementDecl . TYPE_SIMPLE ; haveAnonType = true ; } else if ( type . equals ( "" ) ) { contentSpecType = XMLElementDecl . TYPE_ANY ; contentSpecNodeIndex = - 1 ; } else { System . out . println ( "unhandled case in TraverseElementDecl" ) ; } } if ( haveAnonType && ( type . length ( ) > 0 ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "Element '" + name + "' have both a type attribute and a annoymous type child" ) ; } else if ( ! type . equals ( "" ) ) { if ( equivClassElementDecl != null ) { checkEquivClassOK ( elementDecl , equivClassElementDecl ) ; } String prefix = "" ; String localpart = type ; int colonptr = type . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = type . substring ( 0 , colonptr ) ; localpart = type . substring ( colonptr + 1 ) ; } String typeURI = resolvePrefixToURI ( prefix ) ; if ( ! typeURI . equals ( fTargetNSURIString ) && ! typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && typeURI . length ( ) != 0 ) { fromAnotherSchema = typeURI ; typeInfo = getTypeInfoFromNS ( typeURI , localpart ) ; if ( typeInfo == null ) { dv = getTypeValidatorFromNS ( typeURI , localpart ) ; if ( dv == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type " + localpart + " in schema " + typeURI ) ; } } } else { typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( typeURI + "," + localpart ) ; if ( typeInfo == null ) { dv = getDatatypeValidator ( typeURI , localpart ) ; if ( dv == null ) if ( typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && ! fTargetNSURIString . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "type not found : " + typeURI + ":" + localpart ) ; } else { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_COMPLEXTYPE , localpart ) ; if ( topleveltype != null ) { if ( fCurrentTypeNameStack . search ( ( Object ) localpart ) > - 1 ) { int uriInd = - 1 ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fElementDefaultQualified ) { uriInd = fTargetNSURI ; } int nameIndex = fStringPool . addSymbol ( name ) ; QName tempQName = new QName ( fCurrentScope , nameIndex , nameIndex , uriInd ) ; fElementRecurseComplex . put ( tempQName , localpart ) ; return new QName ( - 1 , nameIndex , nameIndex , uriInd ) ; } else { typeNameIndex = traverseComplexTypeDecl ( topleveltype ) ; typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( typeNameIndex ) ) ; } } else { topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { typeNameIndex = traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "type not found : " + typeURI + ":" + localpart ) ; } } } } } } else if ( haveAnonType ) { if ( equivClassElementDecl != null ) { checkEquivClassOK ( elementDecl , equivClassElementDecl ) ; } } else { if ( typeInfo == null && dv == null ) typeInfo = equivClassEltTypeInfo ; if ( typeInfo == null && dv == null ) dv = equivClassEltDV ; } if ( typeInfo == null && dv == null ) { if ( noErrorSoFar ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "untyped element : " + name ) ; } } if ( typeInfo != null ) { contentSpecNodeIndex = typeInfo . contentSpecHandle ; contentSpecType = typeInfo . contentType ; scopeDefined = typeInfo . scopeDefined ; dv = typeInfo . datatypeValidator ; } if ( dv != null ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; } child = XUtil . getFirstChildElement ( elementDecl ) ; Vector idConstraints = null ; while ( child != null ) { String childName = child . getNodeName ( ) ; child = XUtil . getNextSiblingElement ( child ) ; } int elementNameIndex = fStringPool . addSymbol ( name ) ; int localpartIndex = elementNameIndex ; int uriIndex = - 1 ; int enclosingScope = fCurrentScope ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fElementDefaultQualified ) { uriIndex = fTargetNSURI ; } if ( isTopLevel ( elementDecl ) ) { uriIndex = fTargetNSURI ; enclosingScope = TOP_LEVEL_SCOPE ; } int existSuchElementIndex = fSchemaGrammar . getElementDeclIndex ( uriIndex , localpartIndex , enclosingScope ) ; if ( existSuchElementIndex > - 1 ) { fSchemaGrammar . getElementDecl ( existSuchElementIndex , fTempElementDecl ) ; DatatypeValidator edv = fTempElementDecl . datatypeValidator ; ComplexTypeInfo eTypeInfo = fSchemaGrammar . getElementComplexTypeInfo ( existSuchElementIndex ) ; if ( ( ( eTypeInfo != null ) && ( eTypeInfo != typeInfo ) ) || ( ( edv != null ) && ( edv != dv ) ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "duplicate element decl in the same scope : " + fStringPool . toString ( localpartIndex ) ) ; } } QName eltQName = new QName ( - 1 , localpartIndex , elementNameIndex , uriIndex ) ; int attrListHead = - 1 ; if ( typeInfo != null ) { attrListHead = typeInfo . attlistHead ; } int elementIndex = fSchemaGrammar . addElementDecl ( eltQName , enclosingScope , scopeDefined , contentSpecType , contentSpecNodeIndex , attrListHead , dv ) ; if ( DEBUGGING ) { System . out . println ( "########elementIndex:" + elementIndex + " (" + fStringPool . toString ( eltQName . uri ) + "," + fStringPool . toString ( eltQName . localpart ) + ")" + " eltType:" + type + " contentSpecType:" + contentSpecType + " SpecNodeIndex:" + contentSpecNodeIndex + " enclosingScope: " + enclosingScope + " scopeDefined: " + scopeDefined + "\n" ) ; } if ( typeInfo != null ) { fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } else { fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } fSchemaGrammar . setElementFromAnotherSchemaURI ( elementIndex , fromAnotherSchema ) ; fSchemaGrammar . setElementDeclBlockSet ( elementIndex , blockSet ) ; fSchemaGrammar . setElementDeclFinalSet ( elementIndex , finalSet ) ; fSchemaGrammar . setElementDeclMiscFlags ( elementIndex , elementMiscFlags ) ; fSchemaGrammar . setElementDeclEquivClassElementFullName ( elementIndex , equivClassFullName ) ; return eltQName ; } int getLocalPartIndex ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String localpart = fullName ; if ( colonAt > - 1 ) { localpart = fullName . substring ( colonAt + 1 ) ; } return fStringPool . addSymbol ( localpart ) ; } String getLocalPart ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String localpart = fullName ; if ( colonAt > - 1 ) { localpart = fullName . substring ( colonAt + 1 ) ; } return localpart ; } int getPrefixIndex ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String prefix = "" ; if ( colonAt > - 1 ) { prefix = fullName . substring ( 0 , colonAt ) ; } return fStringPool . addSymbol ( prefix ) ; } String getPrefix ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String prefix = "" ; if ( colonAt > - 1 ) { prefix = fullName . substring ( 0 , colonAt ) ; } return prefix ; } private void checkEquivClassOK ( Element elementDecl , Element equivClassElementDecl ) { } private Element getTopLevelComponentByName ( String componentCategory , String name ) throws Exception { Element child = XUtil . getFirstChildElement ( fSchemaRootElement ) ; if ( child == null ) { return null ; } while ( child != null ) { if ( child . getNodeName ( ) . equals ( componentCategory ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . equals ( name ) ) { return child ; } } child = XUtil . getNextSiblingElement ( child ) ; } return null ; } private boolean isTopLevel ( Element component ) { if ( component . getParentNode ( ) . getNodeName ( ) . endsWith ( SchemaSymbols . ELT_SCHEMA ) ) { return true ; } return false ; } DatatypeValidator getTypeValidatorFromNS ( String newSchemaURI , String localpart ) throws Exception { return getDatatypeValidator ( newSchemaURI , localpart ) ; } ComplexTypeInfo getTypeInfoFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; ComplexTypeInfo typeInfo = ( ComplexTypeInfo ) sGrammar . getComplexTypeRegistry ( ) . get ( newSchemaURI + "," + localpart ) ; return typeInfo ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getTypeInfoFromNS" ) ; } return null ; } DatatypeValidator getElementDeclTypeValidatorFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; int eltIndex = sGrammar . getElementDeclIndex ( fStringPool . addSymbol ( newSchemaURI ) , fStringPool . addSymbol ( localpart ) , TOP_LEVEL_SCOPE ) ; DatatypeValidator dv = null ; if ( eltIndex > - 1 ) { sGrammar . getElementDecl ( eltIndex , fTempElementDecl ) ; dv = fTempElementDecl . datatypeValidator ; } else { reportGenericSchemaError ( "could not find global element : '" + localpart + " in the SchemaGrammar " + newSchemaURI ) ; } return dv ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getELementDeclTypeValidatorFromNS" ) ; } return null ; } ComplexTypeInfo getElementDeclTypeInfoFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; int eltIndex = sGrammar . getElementDeclIndex ( fStringPool . addSymbol ( newSchemaURI ) , fStringPool . addSymbol ( localpart ) , TOP_LEVEL_SCOPE ) ; ComplexTypeInfo typeInfo = null ; if ( eltIndex > - 1 ) { typeInfo = sGrammar . getElementComplexTypeInfo ( eltIndex ) ; } else { reportGenericSchemaError ( "could not find global element : '" + localpart + " in the SchemaGrammar " + newSchemaURI ) ; } return typeInfo ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getElementDeclTypeInfoFromNS" ) ; } return null ; } private int traverseGroupDecl ( Element groupDecl ) throws Exception { String groupName = groupDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; String ref = groupDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( groupDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { return traverseGroupDeclFromAnotherSchema ( localpart , uriStr ) ; } int contentSpecIndex = - 1 ; Element referredGroup = getTopLevelComponentByName ( SchemaSymbols . ELT_GROUP , localpart ) ; if ( referredGroup == null ) { reportGenericSchemaError ( "Group " + localpart + " not found in the Schema" ) ; throw new Exception ( "Group " + localpart + " not found in the Schema" ) ; } else { contentSpecIndex = traverseGroupDecl ( referredGroup ) ; } return contentSpecIndex ; } boolean traverseElt = true ; if ( fCurrentScope == TOP_LEVEL_SCOPE ) { traverseElt = false ; } Element child = XUtil . getFirstChildElement ( groupDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; int allChildren [ ] = null ; int allChildCount = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; boolean seeAll = false ; boolean seeParticle = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean illegalChild = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeAll = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { illegalChild = true ; reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( ! illegalChild ) { index = expandContentModel ( index , child ) ; } if ( seeParticle && seeAll ) { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "'all' needs to be 'the' only Child" , childName } ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } private int traverseGroupDeclFromAnotherSchema ( String groupName , String uriStr ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #traverseGroupDeclFromAnotherSchema, " + "schema uri: " + uriStr + ", groupName: " + groupName ) ; return - 1 ; } Element groupDecl = ( Element ) aGrammar . topLevelGroupDecls . get ( ( Object ) groupName ) ; if ( groupDecl == null ) { reportGenericSchemaError ( "no group named \"" + groupName + "\" was defined in schema : " + uriStr ) ; return - 1 ; } NamespacesScope saveNSMapping = fNamespacesScope ; int saveTargetNSUri = fTargetNSURI ; fTargetNSURI = fStringPool . addSymbol ( aGrammar . getTargetNamespaceURI ( ) ) ; fNamespacesScope = aGrammar . getNamespacesScope ( ) ; boolean traverseElt = true ; if ( fCurrentScope == TOP_LEVEL_SCOPE ) { traverseElt = false ; } Element child = XUtil . getFirstChildElement ( groupDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; int allChildren [ ] = null ; int allChildCount = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; int childNameIndex = fStringPool . addSymbol ( childName ) ; String formAttrVal = child . getAttribute ( SchemaSymbols . ATT_FORM ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; fNamespacesScope = saveNSMapping ; fTargetNSURI = saveTargetNSUri ; return left ; } int traverseSequence ( Element sequenceDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( sequenceDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } int traverseChoice ( Element choiceDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( choiceDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } int traverseAll ( Element allDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( allDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int allChildren [ ] = null ; int allChildCount = 0 ; int left = - 2 ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } try { allChildren [ allChildCount ] = index ; } catch ( NullPointerException ne ) { allChildren = new int [ 32 ] ; allChildren [ allChildCount ] = index ; } catch ( ArrayIndexOutOfBoundsException ae ) { int [ ] newArray = new int [ allChildren . length * 2 ] ; System . arraycopy ( allChildren , 0 , newArray , 0 , allChildren . length ) ; allChildren [ allChildCount ] = index ; } allChildCount ++ ; } left = buildAllModel ( allChildren , allChildCount ) ; return left ; } private int buildAllModel ( int children [ ] , int count ) throws Exception { if ( count > 1 ) { XMLContentSpec choice = new XMLContentSpec ( ) ; choice . type = XMLContentSpec . CONTENTSPECNODE_CHOICE ; choice . value = - 1 ; choice . otherValue = - 1 ; int [ ] exactChildren = new int [ count ] ; System . arraycopy ( children , 0 , exactChildren , 0 , count ) ; sort ( exactChildren , 0 , count ) ; int index = buildAllModel ( exactChildren , 0 , choice ) ; return index ; } if ( count > 0 ) { return children [ 0 ] ; } return - 1 ; } private int buildAllModel ( int src [ ] , int offset , XMLContentSpec choice ) throws Exception { if ( src . length - offset == 2 ) { int seqIndex = createSeq ( src ) ; if ( choice . value == - 1 ) { choice . value = seqIndex ; } else { if ( choice . otherValue != - 1 ) { choice . value = fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } choice . otherValue = seqIndex ; } swap ( src , offset , offset + 1 ) ; seqIndex = createSeq ( src ) ; if ( choice . value == - 1 ) { choice . value = seqIndex ; } else { if ( choice . otherValue != - 1 ) { choice . value = fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } choice . otherValue = seqIndex ; } return fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } for ( int i = offset ; i < src . length - 1 ; i ++ ) { choice . value = buildAllModel ( src , offset + 1 , choice ) ; choice . otherValue = - 1 ; sort ( src , offset , src . length - offset ) ; shift ( src , offset , i + 1 ) ; } int choiceIndex = buildAllModel ( src , offset + 1 , choice ) ; sort ( src , offset , src . length - offset ) ; return choiceIndex ; } private int createSeq ( int src [ ] ) throws Exception { int left = src [ 0 ] ; int right = src [ 1 ] ; for ( int i = 2 ; i < src . length ; i ++ ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , left , right , false ) ; right = src [ i ] ; } return fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , left , right , false ) ; } private void shift ( int src [ ] , int pos , int offset ) { int temp = src [ offset ] ; for ( int i = offset ; i > pos ; i -- ) { src [ i ] = src [ i - 1 ] ; } src [ pos ] = temp ; } private void sort ( int src [ ] , final int offset , final int length ) { for ( int i = offset ; i < offset + length - 1 ; i ++ ) { int lowest = i ; for ( int j = i + 1 ; j < offset + length ; j ++ ) { if ( src [ j ] < src [ lowest ] ) { lowest = j ; } } if ( lowest != i ) { int temp = src [ i ] ; src [ i ] = src [ lowest ] ; src [ lowest ] = temp ; } } } private void swap ( int src [ ] , int i , int j ) { int temp = src [ i ] ; src [ i ] = src [ j ] ; src [ j ] = temp ; } private int traverseWildcardDecl ( Element wildcardDecl ) throws Exception { int wildcardID = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATTVAL_ID ) ) ; int wildcardMaxOccurs = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ) ; int wildcardMinOccurs = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ) ; int wildcardNamespace = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) ) ; int wildcardProcessContents = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_PROCESSCONTENTS ) ) ; int wildcardContent = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_CONTENT ) ) ; return - 1 ; } private int parseInt ( String intString ) throws Exception { if ( intString . equals ( "*" ) ) { return SchemaSymbols . INFINITY ; } else { return Integer . parseInt ( intString ) ; } } private int parseSimpleDerivedBy ( String derivedByString ) throws Exception { if ( derivedByString . equals ( SchemaSymbols . ATTVAL_LIST ) ) { return SchemaSymbols . LIST ; } else if ( derivedByString . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { return SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "SimpleType: Invalid value for 'derivedBy'" ) ; return - 1 ; } } private int parseComplexDerivedBy ( String derivedByString ) throws Exception { if ( derivedByString . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { return SchemaSymbols . EXTENSION ; } else if ( derivedByString . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { return SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "ComplexType: Invalid value for 'derivedBy'" ) ; return - 1 ; } } private int parseSimpleFinal ( String finalString ) throws Exception { if ( finalString . equals ( SchemaSymbols . ATTVAL_POUNDALL ) ) { return SchemaSymbols . ENUMERATION + SchemaSymbols . RESTRICTION + SchemaSymbols . LIST + SchemaSymbols . REPRODUCTION ; } else { int enumerate = 0 ; int restrict = 0 ; int list = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction in set twice" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( list == 0 ) { list = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "list in set twice" ) ; } } else { reportGenericSchemaError ( "Invalid value (" + finalString + ")" ) ; } } return enumerate + restrict + list + reproduce ; } } private int parseComplexContent ( String contentString ) throws Exception { if ( contentString . equals ( SchemaSymbols . ATTVAL_EMPTY ) ) { return XMLElementDecl . TYPE_EMPTY ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_ELEMENTONLY ) ) { return XMLElementDecl . TYPE_CHILDREN ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { return XMLElementDecl . TYPE_SIMPLE ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_MIXED ) ) { return XMLElementDecl . TYPE_MIXED ; } else { reportGenericSchemaError ( "Invalid value for content" ) ; return - 1 ; } } private int parseDerivationSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EXTENSION + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private int parseBlockSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EQUIVCLASS + SchemaSymbols . EXTENSION + SchemaSymbols . LIST + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EQUIVCLASS ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EQUIVCLASS ; } else { reportGenericSchemaError ( "'equivClass' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( extend == 0 ) { extend = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "'list' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private int parseFinalSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EQUIVCLASS + SchemaSymbols . EXTENSION + SchemaSymbols . LIST + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EQUIVCLASS ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EQUIVCLASS ; } else { reportGenericSchemaError ( "'equivClass' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( extend == 0 ) { extend = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "'list' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private void reportGenericSchemaError ( String error ) throws Exception { if ( fErrorReporter == null ) { System . err . println ( "__TraverseSchemaError__ : " + error ) ; } else { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { error } ) ; } } private void reportSchemaError ( int major , Object args [ ] ) throws Exception { if ( fErrorReporter == null ) { System . out . println ( "__TraverseSchemaError__ : " + SchemaMessageProvider . fgMessageKeys [ major ] ) ; for ( int i = 0 ; i < args . length ; i ++ ) { System . out . println ( ( String ) args [ i ] ) ; } } else { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , major , SchemaMessageProvider . MSG_NONE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } public static void main ( String args [ ] ) { if ( args . length != 1 ) { System . out . println ( "Error: Usage java TraverseSchema yourFile.xsd" ) ; System . exit ( 0 ) ; } DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( args [ 0 ] ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } Document document = parser . getDocument ( ) ; OutputFormat format = new OutputFormat ( document ) ; java . io . StringWriter outWriter = new java . io . StringWriter ( ) ; XMLSerializer serial = new XMLSerializer ( outWriter , format ) ; TraverseSchema tst = null ; try { Element root = document . getDocumentElement ( ) ; tst = new TraverseSchema ( root , new StringPool ( ) , new SchemaGrammar ( ) , ( GrammarResolver ) new GrammarResolverImpl ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } parser . getDocument ( ) ; } static class Resolver implements EntityResolver { private static final String SYSTEM [ ] = { "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/structures.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/datatypes.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/versionInfo.ent" , } ; private static final String PATH [ ] = { "structures.dtd" , "datatypes.dtd" , "versionInfo.ent" , } ; public InputSource resolveEntity ( String publicId , String systemId ) throws IOException { for ( int i = 0 ; i < SYSTEM . length ; i ++ ) { if ( systemId . equals ( SYSTEM [ i ] ) ) { InputSource source = new InputSource ( getClass ( ) . getResourceAsStream ( PATH [ i ] ) ) ; source . setPublicId ( publicId ) ; source . setSystemId ( systemId ) ; return source ; } } return null ; } } static class ErrorHandler implements org . xml . sax . ErrorHandler { public void warning ( SAXParseException ex ) { System . err . println ( "[Warning] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { System . err . println ( "[Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) throws SAXException { System . err . println ( "[Fatal Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; throw ex ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId_ = ex . getSystemId ( ) ; if ( systemId_ != null ) { int index = systemId_ . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId_ = systemId_ . substring ( index + 1 ) ; str . append ( systemId_ ) ; } str . append ( ':' ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( ':' ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } } } 	1
package org . xml . sax ; public class SAXNotSupportedException extends SAXException { public SAXNotSupportedException ( String message ) { super ( message ) ; } } 	0
package org . w3c . dom ; public interface Node { public static final short ELEMENT_NODE = 1 ; public static final short ATTRIBUTE_NODE = 2 ; public static final short TEXT_NODE = 3 ; public static final short CDATA_SECTION_NODE = 4 ; public static final short ENTITY_REFERENCE_NODE = 5 ; public static final short ENTITY_NODE = 6 ; public static final short PROCESSING_INSTRUCTION_NODE = 7 ; public static final short COMMENT_NODE = 8 ; public static final short DOCUMENT_NODE = 9 ; public static final short DOCUMENT_TYPE_NODE = 10 ; public static final short DOCUMENT_FRAGMENT_NODE = 11 ; public static final short NOTATION_NODE = 12 ; public String getNodeName ( ) ; public String getNodeValue ( ) throws DOMException ; public void setNodeValue ( String nodeValue ) throws DOMException ; public short getNodeType ( ) ; public Node getParentNode ( ) ; public NodeList getChildNodes ( ) ; public Node getFirstChild ( ) ; public Node getLastChild ( ) ; public Node getPreviousSibling ( ) ; public Node getNextSibling ( ) ; public NamedNodeMap getAttributes ( ) ; public Document getOwnerDocument ( ) ; public Node insertBefore ( Node newChild , Node refChild ) throws DOMException ; public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException ; public Node removeChild ( Node oldChild ) throws DOMException ; public Node appendChild ( Node newChild ) throws DOMException ; public boolean hasChildNodes ( ) ; public Node cloneNode ( boolean deep ) ; public void normalize ( ) ; public boolean supports ( String feature , String version ) ; public String getNamespaceURI ( ) ; public String getPrefix ( ) ; public void setPrefix ( String prefix ) throws DOMException ; public String getLocalName ( ) ; public boolean hasAttributes ( ) ; } 	1
package org . w3c . dom . html ; public interface HTMLObjectElement extends HTMLElement { public HTMLFormElement getForm ( ) ; public String getCode ( ) ; public void setCode ( String code ) ; public String getAlign ( ) ; public void setAlign ( String align ) ; public String getArchive ( ) ; public void setArchive ( String archive ) ; public String getBorder ( ) ; public void setBorder ( String border ) ; public String getCodeBase ( ) ; public void setCodeBase ( String codeBase ) ; public String getCodeType ( ) ; public void setCodeType ( String codeType ) ; public String getData ( ) ; public void setData ( String data ) ; public boolean getDeclare ( ) ; public void setDeclare ( boolean declare ) ; public String getHeight ( ) ; public void setHeight ( String height ) ; public String getHspace ( ) ; public void setHspace ( String hspace ) ; public String getName ( ) ; public void setName ( String name ) ; public String getStandby ( ) ; public void setStandby ( String standby ) ; public int getTabIndex ( ) ; public void setTabIndex ( int tabIndex ) ; public String getType ( ) ; public void setType ( String type ) ; public String getUseMap ( ) ; public void setUseMap ( String useMap ) ; public String getVspace ( ) ; public void setVspace ( String vspace ) ; public String getWidth ( ) ; public void setWidth ( String width ) ; } 	0
package org . w3c . dom ; public interface Entity extends Node { public String getPublicId ( ) ; public String getSystemId ( ) ; public String getNotationName ( ) ; } 	1
package org . w3c . dom . html ; import org . w3c . dom . Document ; import org . w3c . dom . NodeList ; public interface HTMLDocument extends Document { public String getTitle ( ) ; public void setTitle ( String title ) ; public String getReferrer ( ) ; public String getDomain ( ) ; public String getURL ( ) ; public HTMLElement getBody ( ) ; public void setBody ( HTMLElement body ) ; public HTMLCollection getImages ( ) ; public HTMLCollection getApplets ( ) ; public HTMLCollection getLinks ( ) ; public HTMLCollection getForms ( ) ; public HTMLCollection getAnchors ( ) ; public String getCookie ( ) ; public void setCookie ( String cookie ) ; public void open ( ) ; public void close ( ) ; public void write ( String text ) ; public void writeln ( String text ) ; public NodeList getElementsByName ( String elementName ) ; } 	0
package org . w3c . dom ; public interface Text extends CharacterData { public Text splitText ( int offset ) throws DOMException ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLDoElementImpl extends WMLElementImpl implements WMLDoElement { public WMLDoElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setOptional ( String newValue ) { setAttribute ( "optional" , newValue ) ; } public String getOptional ( ) { return getAttribute ( "optional" ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setLabel ( String newValue ) { setAttribute ( "label" , newValue ) ; } public String getLabel ( ) { return getAttribute ( "label" ) ; } public void setType ( String newValue ) { setAttribute ( "type" , newValue ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } public void setName ( String newValue ) { setAttribute ( "name" , newValue ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . Node ; public interface NodeFilter { public static final short FILTER_ACCEPT = 1 ; public static final short FILTER_REJECT = 2 ; public static final short FILTER_SKIP = 3 ; public static final int SHOW_ALL = 0xFFFFFFFF ; public static final int SHOW_ELEMENT = 0x00000001 ; public static final int SHOW_ATTRIBUTE = 0x00000002 ; public static final int SHOW_TEXT = 0x00000004 ; public static final int SHOW_CDATA_SECTION = 0x00000008 ; public static final int SHOW_ENTITY_REFERENCE = 0x00000010 ; public static final int SHOW_ENTITY = 0x00000020 ; public static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040 ; public static final int SHOW_COMMENT = 0x00000080 ; public static final int SHOW_DOCUMENT = 0x00000100 ; public static final int SHOW_DOCUMENT_TYPE = 0x00000200 ; public static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400 ; public static final int SHOW_NOTATION = 0x00000800 ; public short acceptNode ( Node n ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLAppletElementImpl extends HTMLElementImpl implements HTMLAppletElement { public String getAlign ( ) { return getAttribute ( "align" ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public String getAlt ( ) { return getAttribute ( "alt" ) ; } public void setAlt ( String alt ) { setAttribute ( "alt" , alt ) ; } public String getArchive ( ) { return getAttribute ( "archive" ) ; } public void setArchive ( String archive ) { setAttribute ( "archive" , archive ) ; } public String getCode ( ) { return getAttribute ( "code" ) ; } public void setCode ( String code ) { setAttribute ( "code" , code ) ; } public String getCodeBase ( ) { return getAttribute ( "codebase" ) ; } public void setCodeBase ( String codeBase ) { setAttribute ( "codebase" , codeBase ) ; } public String getHeight ( ) { return getAttribute ( "height" ) ; } public void setHeight ( String height ) { setAttribute ( "height" , height ) ; } public String getHspace ( ) { return getAttribute ( "height" ) ; } public void setHspace ( String height ) { setAttribute ( "height" , height ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public String getObject ( ) { return getAttribute ( "object" ) ; } public void setObject ( String object ) { setAttribute ( "object" , object ) ; } public String getVspace ( ) { return getAttribute ( "vspace" ) ; } public void setVspace ( String vspace ) { setAttribute ( "vspace" , vspace ) ; } public String getWidth ( ) { return getAttribute ( "width" ) ; } public void setWidth ( String width ) { setAttribute ( "width" , width ) ; } public HTMLAppletElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom ; public interface Notation extends Node { public String getPublicId ( ) ; public String getSystemId ( ) ; } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Locale ; import java . text . ParseException ; import java . text . Collator ; import java . util . StringTokenizer ; import java . util . NoSuchElementException ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; public class QNameDatatypeValidator extends AbstractDatatypeValidator { private Locale fLocale = null ; private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; private int fLength = 0 ; private int fMaxLength = Integer . MAX_VALUE ; private int fMinLength = 0 ; private String fPattern = null ; private Vector fEnumeration = null ; private String fMaxInclusive = null ; private String fMaxExclusive = null ; private String fMinInclusive = null ; private String fMinExclusive = null ; private int fFacetsDefined = 0 ; private boolean isMaxExclusiveDefined = false ; private boolean isMaxInclusiveDefined = false ; private boolean isMinExclusiveDefined = false ; private boolean isMinInclusiveDefined = false ; private RegularExpression fRegex = null ; public QNameDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public QNameDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { if ( fDerivedByList == false ) { for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . equals ( SchemaSymbols . ELT_LENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_LENGTH ; String lengthValue = ( String ) facets . get ( key ) ; try { fLength = Integer . parseInt ( lengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "' is invalid." ) ; } if ( fLength < 0 ) throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "'  must be a nonNegativeInteger." ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MINLENGTH ; String minLengthValue = ( String ) facets . get ( key ) ; try { fMinLength = Integer . parseInt ( minLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + minLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MAXLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXLENGTH ; String maxLengthValue = ( String ) facets . get ( key ) ; try { fMaxLength = Integer . parseInt ( maxLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + maxLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = ( String ) facets . get ( key ) ; fRegex = new RegularExpression ( fPattern , "X" ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; fEnumeration = ( Vector ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; fMaxInclusive = ( String ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXEXCLUSIVE ; fMaxExclusive = ( String ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; fMinInclusive = ( String ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MINEXCLUSIVE ; fMinExclusive = ( String ) facets . get ( key ) ; } else { throw new InvalidDatatypeFacetException ( ) ; } } if ( ( ( fFacetsDefined & DatatypeValidator . FACET_LENGTH ) != 0 ) ) { if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MAXLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and maxLength to be members of facets." ) ; } else if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MINLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and minLength to be members of facets." ) ; } } if ( ( ( fFacetsDefined & ( DatatypeValidator . FACET_MINLENGTH | DatatypeValidator . FACET_MAXLENGTH ) ) != 0 ) ) { if ( fMinLength > fMaxLength ) { throw new InvalidDatatypeFacetException ( "Value of maxLength = " + fMaxLength + "must be greater that the value of minLength" + fMinLength ) ; } } isMaxExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXEXCLUSIVE ) != 0 ) ? true : false ; isMaxInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXINCLUSIVE ) != 0 ) ? true : false ; isMinExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MINEXCLUSIVE ) != 0 ) ? true : false ; isMinInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MININCLUSIVE ) != 0 ) ? true : false ; if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both maxInclusive and maxExclusive to be specified for the same datatype." ) ; } if ( isMinExclusiveDefined && isMinInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both minInclusive and minExclusive to be specified for the same datatype." ) ; } } else { for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . equals ( SchemaSymbols . ELT_LENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_LENGTH ; String lengthValue = ( String ) facets . get ( key ) ; try { fLength = Integer . parseInt ( lengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "' is invalid." ) ; } if ( fLength < 0 ) throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "'  must be a nonNegativeInteger." ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MINLENGTH ; String minLengthValue = ( String ) facets . get ( key ) ; try { fMinLength = Integer . parseInt ( minLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + minLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MAXLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXLENGTH ; String maxLengthValue = ( String ) facets . get ( key ) ; try { fMaxLength = Integer . parseInt ( maxLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + maxLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; fEnumeration = ( Vector ) facets . get ( key ) ; } else { throw new InvalidDatatypeFacetException ( ) ; } } if ( ( ( fFacetsDefined & DatatypeValidator . FACET_LENGTH ) != 0 ) ) { if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MAXLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and maxLength to be members of facets." ) ; } else if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MINLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and minLength to be members of facets." ) ; } } if ( ( ( fFacetsDefined & ( DatatypeValidator . FACET_MINLENGTH | DatatypeValidator . FACET_MAXLENGTH ) ) != 0 ) ) { if ( fMinLength < fMaxLength ) { throw new InvalidDatatypeFacetException ( "Value of minLength = " + fMinLength + "must be greater that the value of maxLength" + fMaxLength ) ; } } } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { StringTokenizer parsedList = null ; if ( fDerivedByList == true ) { parsedList = new StringTokenizer ( content ) ; try { while ( parsedList . hasMoreTokens ( ) ) { checkContentList ( parsedList . nextToken ( ) ) ; } } catch ( NoSuchElementException e ) { e . printStackTrace ( ) ; } } else { checkContent ( content ) ; } return null ; } public void setLocale ( Locale locale ) { fLocale = locale ; } private void checkContent ( String content ) throws InvalidDatatypeValueException { if ( ( fFacetsDefined & DatatypeValidator . FACET_MAXLENGTH ) != 0 ) { if ( content . length ( ) > fMaxLength ) { throw new InvalidDatatypeValueException ( "Value '" + content + "' with length '" + content . length ( ) + "' exceeds maximum length of " + fMaxLength + "." ) ; } } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { if ( fEnumeration . contains ( content ) == false ) throw new InvalidDatatypeValueException ( "Value '" + content + "' must be one of " + fEnumeration ) ; } if ( isMaxExclusiveDefined == true ) { int comparisonResult ; comparisonResult = compare ( content , fMaxExclusive ) ; if ( comparisonResult >= 0 ) { throw new InvalidDatatypeValueException ( "Value '" + content + "'  must be " + "lexicographically less than '" + fMaxExclusive + "'." ) ; } } if ( isMaxInclusiveDefined == true ) { int comparisonResult ; comparisonResult = compare ( content , fMaxInclusive ) ; if ( comparisonResult > 0 ) throw new InvalidDatatypeValueException ( "Value '" + content + "' must be " + "lexicographically less or equal than '" + fMaxInclusive + "'." ) ; } if ( isMinExclusiveDefined == true ) { int comparisonResult ; comparisonResult = compare ( content , fMinExclusive ) ; if ( comparisonResult <= 0 ) throw new InvalidDatatypeValueException ( "Value '" + content + "' must be " + "lexicographically greater than '" + fMinExclusive + "'." ) ; } if ( isMinInclusiveDefined == true ) { int comparisonResult ; comparisonResult = compare ( content , fMinInclusive ) ; if ( comparisonResult < 0 ) throw new InvalidDatatypeValueException ( "Value '" + content + "' must be " + "lexicographically greater or equal than '" + fMinInclusive + "'." ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_PATTERN ) != 0 ) { if ( fRegex == null || fRegex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value '" + content + "' does not match regular expression facet '" + fPattern + "'." ) ; } } public Hashtable getFacets ( ) { return null ; } public int compare ( String content , String facetValue ) { Locale loc = Locale . getDefault ( ) ; Collator collator = Collator . getInstance ( loc ) ; return collator . compare ( content , facetValue ) ; } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } private void checkContentList ( String content ) throws InvalidDatatypeValueException { } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public abstract class CharacterDataImpl extends ChildNode { static final long serialVersionUID = 7931170150428474230L ; protected String data ; private static transient NodeList singletonNodeList = new NodeList ( ) { public Node item ( int index ) { return null ; } public int getLength ( ) { return 0 ; } } ; protected CharacterDataImpl ( DocumentImpl ownerDocument , String data ) { super ( ownerDocument ) ; this . data = data ; } public NodeList getChildNodes ( ) { return singletonNodeList ; } public String getNodeValue ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } void setNodeValueInternal ( String value ) { setValueCalled ( true ) ; setNodeValue ( value ) ; setValueCalled ( false ) ; } public void setNodeValue ( String value ) { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; if ( needsSyncData ( ) ) { synchronizeData ( ) ; } String oldvalue = value ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } this . data = value ; if ( ! setValueCalled ( ) ) { ownerDocument ( ) . replacedText ( this ) ; } if ( MUTATIONEVENTS ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_CHARACTER_DATA_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_CHARACTER_DATA_MODIFIED , true , false , null , oldvalue , value , null ) ; dispatchEvent ( me ) ; } dispatchAggregateEvents ( enclosingAttr ) ; } } public String getData ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } public int getLength ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data . length ( ) ; } public void appendData ( String data ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } setNodeValue ( this . data + data ) ; } public void deleteData ( int offset , int count ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( count < 0 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int tailLength = Math . max ( data . length ( ) - count - offset , 0 ) ; try { setNodeValueInternal ( data . substring ( 0 , offset ) + ( tailLength > 0 ? data . substring ( offset + count , offset + count + tailLength ) : "" ) ) ; ownerDocument ( ) . deletedText ( this , offset , count ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } public void insertData ( int offset , String data ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } try { setNodeValueInternal ( new StringBuffer ( this . data ) . insert ( offset , data ) . toString ( ) ) ; ownerDocument ( ) . insertedText ( this , offset , data . length ( ) ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } public void replaceData ( int offset , int count , String data ) throws DOMException { deleteData ( offset , count ) ; insertData ( offset , data ) ; } public void setData ( String value ) throws DOMException { setNodeValue ( value ) ; } public String substringData ( int offset , int count ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int length = data . length ( ) ; if ( count < 0 || offset < 0 || offset > length - 1 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } int tailIndex = Math . min ( offset + count , length ) ; return data . substring ( offset , tailIndex ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLModElement extends HTMLElement { public String getCite ( ) ; public void setCite ( String cite ) ; public String getDateTime ( ) ; public void setDateTime ( String dateTime ) ; } 	0
package org . apache . xerces . jaxp ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . xml . sax . SAXException ; public class DocumentBuilderFactoryImpl extends DocumentBuilderFactory { public DocumentBuilderFactoryImpl ( ) { super ( ) ; } public DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException { return ( new DocumentBuilderImpl ( this . isNamespaceAware ( ) , this . isValidating ( ) ) ) ; } } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import org . apache . xerces . validators . datatype . DatatypeValidator ; public abstract class AbstractDatatypeValidator implements DatatypeValidator , Cloneable { private Hashtable fFacets ; abstract public Object validate ( String content , Object state ) throws InvalidDatatypeValueException ; abstract public Object clone ( ) throws CloneNotSupportedException ; public Hashtable getFacets ( ) { return null ; } public int compare ( String value1 , String valu2 ) { return 0 ; } } 	0
package org . apache . xerces . parsers ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . xml . sax . Attributes ; import org . xml . sax . AttributeList ; import org . xml . sax . ContentHandler ; import org . xml . sax . DocumentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . Parser ; import org . xml . sax . XMLReader ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . AttributesImpl ; public class SAXParser extends XMLParser implements XMLDocumentHandler , XMLDocumentHandler . DTDHandler , Parser , XMLReader { private static final String RECOGNIZED_FEATURES [ ] = { "http://xml.org/sax/features/namespace-prefixes" , "http://xml.org/sax/features/string-interning" , } ; private static final String RECOGNIZED_PROPERTIES [ ] = { "http://xml.org/sax/properties/lexical-handler" , "http://xml.org/sax/properties/declaration-handler" , "http://xml.org/sax/properties/dom-node" , } ; private static final boolean DEBUG_CALLBACKS = false ; private DocumentHandler fDocumentHandler ; private org . xml . sax . DTDHandler fDTDHandler ; private ContentHandler fContentHandler ; private DeclHandler fDeclHandler ; private LexicalHandler fLexicalHandler ; private boolean fNamespacePrefixes = false ; private transient AttributesImpl fAttributes = new AttributesImpl ( ) ; public SAXParser ( ) { initHandlers ( true , this , this ) ; } public String [ ] getFeaturesRecognized ( ) { String superRecognized [ ] = super . getFeaturesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_FEATURES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } public String [ ] getPropertiesRecognized ( ) { String superRecognized [ ] = super . getPropertiesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_PROPERTIES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } protected void setDeclHandler ( DeclHandler handler ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR011 Feature: http://xml.org/sax/properties/declaration-handler" + " is not supported during parse." + "\nhttp://xml.org/sax/properties/declaration-handler" ) ; } fDeclHandler = handler ; } protected DeclHandler getDeclHandler ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fDeclHandler ; } protected void setLexicalHandler ( LexicalHandler handler ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR011 Feature: http://xml.org/sax/properties/lexical-handler" + " is not supported during parse." + "\nhttp://xml.org/sax/properties/lexical-handler" ) ; } fLexicalHandler = handler ; } protected LexicalHandler getLexicalHandler ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fLexicalHandler ; } public void setDocumentHandler ( DocumentHandler handler ) { fDocumentHandler = handler ; } public void setDTDHandler ( org . xml . sax . DTDHandler handler ) { fDTDHandler = handler ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return fDTDHandler ; } protected void setNamespacePrefixes ( boolean process ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR004 Cannot setFeature(http://xml.org/sax/features/namespace-prefixes): parse is in progress.\n" + "http://xml.org/sax/features/namespace-prefixes" ) ; } fNamespacePrefixes = process ; } protected boolean getNamespacePrefixes ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fNamespacePrefixes ; } public void setFeature ( String featureId , boolean state ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "namespace-prefixes" ) ) { setNamespacePrefixes ( state ) ; return ; } if ( feature . equals ( "string-interning" ) ) { if ( state ) { throw new SAXNotSupportedException ( "PAR018 " + state + " state for feature \"" + featureId + "\" is not supported.\n" + state + '\t' + featureId ) ; } return ; } } super . setFeature ( featureId , state ) ; } public boolean getFeature ( String featureId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "namespace-prefixes" ) ) { return getNamespacePrefixes ( ) ; } if ( feature . equals ( "string-interning" ) ) { return false ; } } return super . getFeature ( featureId ) ; } public void setProperty ( String propertyId , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "lexical-handler" ) ) { try { setLexicalHandler ( ( LexicalHandler ) value ) ; } catch ( ClassCastException e ) { throw new SAXNotSupportedException ( "PAR012 For propertyID \"" + propertyId + "\", the value \"" + value + "\" cannot be cast to LexicalHandler." + '\n' + propertyId + '\t' + value + "\tLexicalHandler" ) ; } return ; } if ( property . equals ( "declaration-handler" ) ) { try { setDeclHandler ( ( DeclHandler ) value ) ; } catch ( ClassCastException e ) { throw new SAXNotSupportedException ( "PAR012 For propertyID \"" + propertyId + "\", the value \"" + value + "\" cannot be cast to DeclHandler." + '\n' + propertyId + '\t' + value + "\tDeclHandler" ) ; } return ; } if ( property . equals ( "dom-node" ) ) { throw new SAXNotSupportedException ( "PAR013 Property \"" + propertyId + "\" is read only." + '\n' + propertyId ) ; } } super . setProperty ( propertyId , value ) ; } public Object getProperty ( String propertyId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "lexical-handler" ) ) { return getLexicalHandler ( ) ; } if ( property . equals ( "declaration-handler" ) ) { return getDeclHandler ( ) ; } if ( property . equals ( "dom-node" ) ) { throw new SAXNotSupportedException ( "PAR014 Cannot getProperty(\"" + propertyId + "\". No DOM Tree exists.\n" + propertyId ) ; } } return super . getProperty ( propertyId ) ; } public void setContentHandler ( ContentHandler handler ) { if ( handler == null ) { throw new NullPointerException ( ) ; } fContentHandler = handler ; } public ContentHandler getContentHandler ( ) { return fContentHandler ; } public void startDTD ( QName rootElement , int publicId , int systemId ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( rootElement . rawname ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "startDTD(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startDTD ( name , pubid , sysid ) ; } } } public void endDTD ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endDTD()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endDTD ( ) ; } } public void elementDecl ( QName elementDecl , int contentSpecType , int contentSpecIndex , XMLContentSpec . Provider contentSpecProvider ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( elementDecl . rawname ) ; String contentModel ; if ( contentSpecType == XMLElementDecl . TYPE_ANY ) { contentModel = "ANY" ; } else if ( contentSpecType == XMLElementDecl . TYPE_EMPTY ) { contentModel = "EMPTY" ; } else { contentModel = XMLContentSpec . toString ( contentSpecProvider , fStringPool , contentSpecIndex ) ; } if ( DEBUG_CALLBACKS ) { System . err . println ( "elementDecl(" + name + ", " + contentModel + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . elementDecl ( name , contentModel ) ; } } } public void attlistDecl ( QName elementDecl , QName attributeDecl , int attType , boolean attList , String enumString , int attDefaultType , int attDefaultValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String eName = fStringPool . toString ( elementDecl . rawname ) ; String aName = fStringPool . toString ( attributeDecl . rawname ) ; String aType = enumString ; if ( attType != XMLAttributeDecl . TYPE_ENUMERATION ) { switch ( attType ) { case XMLAttributeDecl . TYPE_CDATA : { aType = "CDATA" ; break ; } case XMLAttributeDecl . TYPE_ENTITY : { aType = attList ? "ENTITIES" : "ENTITY" ; break ; } case XMLAttributeDecl . TYPE_ID : { aType = "ID" ; break ; } case XMLAttributeDecl . TYPE_IDREF : { aType = attList ? "IDREFS" : "IDREF" ; break ; } case XMLAttributeDecl . TYPE_NMTOKEN : { aType = attList ? "NMTOKENS" : "NMTOKEN" ; break ; } case XMLAttributeDecl . TYPE_NOTATION : { aType = "NOTATION" ; break ; } } } String aDefaultType = "" ; switch ( attDefaultType ) { case XMLAttributeDecl . DEFAULT_TYPE_FIXED : { aDefaultType = "#FIXED" ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_IMPLIED : { aDefaultType = "#IMPLIED" ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_REQUIRED : { aDefaultType = "#REQUIRED" ; break ; } } String aDefaultValue = fStringPool . toString ( attDefaultValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "attributeDecl(" + eName + ", " + aName + ", " + aType + ", " + aDefaultType + ", " + aDefaultValue + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . attributeDecl ( eName , aName , aType , aDefaultType , aDefaultValue ) ; } } } public void internalPEDecl ( int entityName , int entityValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = "%" + fStringPool . toString ( entityName ) ; String value = fStringPool . toString ( entityValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "internalEntityDecl(" + name + ", " + value + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , value ) ; } } } public void externalPEDecl ( int entityName , int publicId , int systemId ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = "%" + fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "externalEntityDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . externalEntityDecl ( name , pubid , sysid ) ; } } } public void internalEntityDecl ( int entityName , int entityValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String value = fStringPool . toString ( entityValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "internalEntityDecl(" + name + ", " + value + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , value ) ; } } } public void externalEntityDecl ( int entityName , int publicId , int systemId ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "externalEntityDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . externalEntityDecl ( name , pubid , sysid ) ; } } } public void unparsedEntityDecl ( int entityName , int publicId , int systemId , int notationName ) throws Exception { if ( fDTDHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; String notation = fStringPool . toString ( notationName ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "unparsedEntityDecl(" + name + ", " + pubid + ", " + sysid + ", " + notation + ")" ) ; } if ( fDTDHandler != null ) { fDTDHandler . unparsedEntityDecl ( name , pubid , sysid , notation ) ; } } } public void notationDecl ( int notationName , int publicId , int systemId ) throws Exception { if ( fDTDHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( notationName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "notationDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDTDHandler != null ) { fDTDHandler . notationDecl ( name , pubid , sysid ) ; } } } public void startDocument ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "setDocumentLocator(<locator>)" ) ; System . err . println ( "startDocument()" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . setDocumentLocator ( getLocator ( ) ) ; fDocumentHandler . startDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . setDocumentLocator ( getLocator ( ) ) ; fContentHandler . startDocument ( ) ; } } public void endDocument ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endDocument()" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . endDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . endDocument ( ) ; } } public void xmlDecl ( int versionIndex , int encodingIndex , int standaloneIndex ) throws Exception { if ( DEBUG_CALLBACKS ) { String notes = "" ; if ( versionIndex != - 1 ) notes += " version='" + fStringPool . toString ( versionIndex ) + "'" ; if ( encodingIndex != - 1 ) notes += " encoding='" + fStringPool . toString ( encodingIndex ) + "'" ; if ( standaloneIndex != - 1 ) notes += " standalone='" + fStringPool . toString ( standaloneIndex ) + "'" ; System . err . println ( "xmlDecl(<?xml" + notes + "?>)" ) ; } fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; fStringPool . releaseString ( standaloneIndex ) ; } public void textDecl ( int versionIndex , int encodingIndex ) throws Exception { if ( DEBUG_CALLBACKS ) { String notes = "" ; if ( versionIndex != - 1 ) notes += " version='" + fStringPool . toString ( versionIndex ) + "'" ; if ( encodingIndex != - 1 ) notes += " encoding='" + fStringPool . toString ( encodingIndex ) + "'" ; System . err . println ( "textDecl(<?xml" + notes + "?>)" ) ; } fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { if ( fContentHandler != null || DEBUG_CALLBACKS ) { String p = fStringPool . toString ( prefix ) ; String ns = fStringPool . toString ( uri ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "startNamespaceDeclScope(" + p + ", " + ns + ")" ) ; } if ( fContentHandler != null ) { fContentHandler . startPrefixMapping ( p , ns ) ; } } } public void endNamespaceDeclScope ( int prefix ) throws Exception { if ( fContentHandler != null || DEBUG_CALLBACKS ) { String p = fStringPool . toString ( prefix ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "endNamespaceDeclScope(" + p + ")" ) ; } if ( fContentHandler != null ) { fContentHandler . endPrefixMapping ( p ) ; } } } public void internalSubset ( int internalSubset ) { } public void startElement ( QName element , XMLAttrList attrList , int attrListIndex ) throws Exception { String name = fStringPool . toString ( element . rawname ) ; AttributeList attrs = attrList . getAttributeList ( attrListIndex ) ; if ( DEBUG_CALLBACKS ) { String atts = attrs . getLength ( ) > 0 ? "" : " " ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { atts += " " + attrs . getName ( i ) + "='" + attrs . getValue ( i ) + "'" ; } System . err . println ( "startElement(" + name + "," + atts + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . startElement ( name , attrs ) ; } if ( fContentHandler != null ) { boolean namespaces = getNamespaces ( ) ; int uriIndex = element . uri ; String uri = uriIndex != - 1 && namespaces ? fStringPool . toString ( uriIndex ) : "" ; int localIndex = element . localpart ; String local = localIndex != - 1 && namespaces ? fStringPool . toString ( localIndex ) : "" ; String raw = name ; fAttributes . clear ( ) ; for ( int attrIndex = attrList . getFirstAttr ( attrListIndex ) ; attrIndex != - 1 ; attrIndex = attrList . getNextAttr ( attrIndex ) ) { int attrNameIndex = attrList . getAttrName ( attrIndex ) ; int attrUriIndex = attrList . getAttrURI ( attrIndex ) ; String attrUri = attrUriIndex != - 1 && namespaces ? fStringPool . toString ( attrUriIndex ) : "" ; int attrLocalIndex = attrList . getAttrLocalpart ( attrIndex ) ; String attrLocal = attrLocalIndex != - 1 && namespaces ? fStringPool . toString ( attrLocalIndex ) : "" ; String attrRaw = fStringPool . toString ( attrNameIndex ) ; String attrType = fStringPool . toString ( attrList . getAttType ( attrIndex ) ) ; String attrValue = fStringPool . toString ( attrList . getAttValue ( attrIndex ) ) ; int attrPrefix = attrList . getAttrPrefix ( attrIndex ) ; boolean namespacePrefixes = getNamespacePrefixes ( ) ; if ( ! namespaces || namespacePrefixes || ( attrPrefix != fStringPool . addSymbol ( "xmlns" ) && attrLocalIndex != fStringPool . addSymbol ( "xmlns" ) ) ) fAttributes . addAttribute ( attrUri , attrLocal , attrRaw , attrType , attrValue ) ; } fContentHandler . startElement ( uri , local , raw , fAttributes ) ; } attrList . releaseAttrList ( attrListIndex ) ; } public void endElement ( QName element ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endElement(" + fStringPool . toString ( element . rawname ) + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . endElement ( fStringPool . toString ( element . rawname ) ) ; } if ( fContentHandler != null ) { boolean namespaces = getNamespaces ( ) ; int uriIndex = element . uri ; String uri = uriIndex != - 1 && namespaces ? fStringPool . toString ( uriIndex ) : "" ; int localIndex = element . localpart ; String local = localIndex != - 1 && namespaces ? fStringPool . toString ( localIndex ) : "" ; String raw = fStringPool . toString ( element . rawname ) ; fContentHandler . endElement ( uri , local , raw ) ; } } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { switch ( entityType ) { case XMLEntityHandler . ENTITYTYPE_INTERNAL_PE : case XMLEntityHandler . ENTITYTYPE_EXTERNAL_PE : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(%" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( "%" + fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_INTERNAL : case XMLEntityHandler . ENTITYTYPE_EXTERNAL : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_UNPARSED : throw new RuntimeException ( "PAR015 startEntityReference(): ENTITYTYPE_UNPARSED" ) ; case XMLEntityHandler . ENTITYTYPE_DOCUMENT : break ; case XMLEntityHandler . ENTITYTYPE_EXTERNAL_SUBSET : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(\"[dtd]\")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( "[dtd]" ) ; } break ; } } } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { switch ( entityType ) { case XMLEntityHandler . ENTITYTYPE_INTERNAL_PE : case XMLEntityHandler . ENTITYTYPE_EXTERNAL_PE : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(%" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( "%" + fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_INTERNAL : case XMLEntityHandler . ENTITYTYPE_EXTERNAL : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_UNPARSED : throw new RuntimeException ( "PAR016 endEntityReference(): ENTITYTYPE_UNPARSED" ) ; case XMLEntityHandler . ENTITYTYPE_DOCUMENT : break ; case XMLEntityHandler . ENTITYTYPE_EXTERNAL_SUBSET : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(\"[dtd]\")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( "[dtd]" ) ; } break ; } } } public void startCDATA ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "startCDATA()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endCDATA()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endCDATA ( ) ; } } public void characters ( int dataIndex ) throws Exception { throw new RuntimeException ( "PAR017 cannot happen 5\n5" ) ; } public void ignorableWhitespace ( int dataIndex ) throws Exception { throw new RuntimeException ( "PAR017 cannot happen 6\n6" ) ; } public void processingInstruction ( int piTarget , int piData ) throws Exception { if ( fDocumentHandler != null || fContentHandler != null || DEBUG_CALLBACKS ) { String target = fStringPool . orphanString ( piTarget ) ; String data = piData == - 1 ? "" : fStringPool . orphanString ( piData ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "processingInstruction(" + target + ", " + data + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . processingInstruction ( target , data ) ; } if ( fContentHandler != null ) { fContentHandler . processingInstruction ( target , data ) ; } } else { fStringPool . releaseString ( piTarget ) ; fStringPool . releaseString ( piData ) ; } } public void comment ( int dataIndex ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { String data = fStringPool . orphanString ( dataIndex ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "comment(" + data + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } else { fStringPool . releaseString ( dataIndex ) ; } } public void characters ( char ch [ ] , int start , int length ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "characters(<char-data>) length " + length ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . characters ( ch , start , length ) ; } if ( fContentHandler != null ) { fContentHandler . characters ( ch , start , length ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "ignorableWhitespace(<white-space>)" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . ignorableWhitespace ( ch , start , length ) ; } if ( fContentHandler != null ) { fContentHandler . ignorableWhitespace ( ch , start , length ) ; } } } 	1
package org . apache . xerces . utils . regex ; import java . util . Vector ; class Op { static final int DOT = 0 ; static final int CHAR = 1 ; static final int RANGE = 3 ; static final int NRANGE = 4 ; static final int ANCHOR = 5 ; static final int STRING = 6 ; static final int CLOSURE = 7 ; static final int NONGREEDYCLOSURE = 8 ; static final int QUESTION = 9 ; static final int NONGREEDYQUESTION = 10 ; static final int UNION = 11 ; static final int CAPTURE = 15 ; static final int BACKREFERENCE = 16 ; static final int LOOKAHEAD = 20 ; static final int NEGATIVELOOKAHEAD = 21 ; static final int LOOKBEHIND = 22 ; static final int NEGATIVELOOKBEHIND = 23 ; static final int INDEPENDENT = 24 ; static final int MODIFIER = 25 ; static final int CONDITION = 26 ; static int nofinstances = 0 ; static final boolean COUNT = false ; static Op createDot ( ) { if ( Op . COUNT ) Op . nofinstances ++ ; return new Op ( Op . DOT ) ; } static CharOp createChar ( int data ) { if ( Op . COUNT ) Op . nofinstances ++ ; return new CharOp ( Op . CHAR , data ) ; } static CharOp createAnchor ( int data ) { if ( Op . COUNT ) Op . nofinstances ++ ; return new CharOp ( Op . ANCHOR , data ) ; } static CharOp createCapture ( int number , Op next ) { if ( Op . COUNT ) Op . nofinstances ++ ; CharOp op = new CharOp ( Op . CAPTURE , number ) ; op . next = next ; return op ; } static UnionOp createUnion ( int size ) { if ( Op . COUNT ) Op . nofinstances ++ ; return new UnionOp ( Op . UNION , size ) ; } static ChildOp createClosure ( int id ) { if ( Op . COUNT ) Op . nofinstances ++ ; return new ModifierOp ( Op . CLOSURE , id , - 1 ) ; } static ChildOp createNonGreedyClosure ( ) { if ( Op . COUNT ) Op . nofinstances ++ ; return new ChildOp ( Op . NONGREEDYCLOSURE ) ; } static ChildOp createQuestion ( boolean nongreedy ) { if ( Op . COUNT ) Op . nofinstances ++ ; return new ChildOp ( nongreedy ? Op . NONGREEDYQUESTION : Op . QUESTION ) ; } static RangeOp createRange ( Token tok ) { if ( Op . COUNT ) Op . nofinstances ++ ; return new RangeOp ( Op . RANGE , tok ) ; } static ChildOp createLook ( int type , Op next , Op branch ) { if ( Op . COUNT ) Op . nofinstances ++ ; ChildOp op = new ChildOp ( type ) ; op . setChild ( branch ) ; op . next = next ; return op ; } static CharOp createBackReference ( int refno ) { if ( Op . COUNT ) Op . nofinstances ++ ; return new CharOp ( Op . BACKREFERENCE , refno ) ; } static StringOp createString ( String literal ) { if ( Op . COUNT ) Op . nofinstances ++ ; return new StringOp ( Op . STRING , literal ) ; } static ChildOp createIndependent ( Op next , Op branch ) { if ( Op . COUNT ) Op . nofinstances ++ ; ChildOp op = new ChildOp ( Op . INDEPENDENT ) ; op . setChild ( branch ) ; op . next = next ; return op ; } static ModifierOp createModifier ( Op next , Op branch , int add , int mask ) { if ( Op . COUNT ) Op . nofinstances ++ ; ModifierOp op = new ModifierOp ( Op . MODIFIER , add , mask ) ; op . setChild ( branch ) ; op . next = next ; return op ; } static ConditionOp createCondition ( Op next , int ref , Op conditionflow , Op yesflow , Op noflow ) { if ( Op . COUNT ) Op . nofinstances ++ ; ConditionOp op = new ConditionOp ( Op . CONDITION , ref , conditionflow , yesflow , noflow ) ; op . next = next ; return op ; } int type ; Op next = null ; protected Op ( int type ) { this . type = type ; } int size ( ) { return 0 ; } Op elementAt ( int index ) { throw new RuntimeException ( "Internal Error: type=" + this . type ) ; } Op getChild ( ) { throw new RuntimeException ( "Internal Error: type=" + this . type ) ; } int getData ( ) { throw new RuntimeException ( "Internal Error: type=" + this . type ) ; } int getData2 ( ) { throw new RuntimeException ( "Internal Error: type=" + this . type ) ; } RangeToken getToken ( ) { throw new RuntimeException ( "Internal Error: type=" + this . type ) ; } String getString ( ) { throw new RuntimeException ( "Internal Error: type=" + this . type ) ; } static class CharOp extends Op { int charData ; CharOp ( int type , int data ) { super ( type ) ; this . charData = data ; } int getData ( ) { return this . charData ; } } static class UnionOp extends Op { Vector branches ; UnionOp ( int type , int size ) { super ( type ) ; this . branches = new Vector ( size ) ; } void addElement ( Op op ) { this . branches . addElement ( op ) ; } int size ( ) { return this . branches . size ( ) ; } Op elementAt ( int index ) { return ( Op ) this . branches . elementAt ( index ) ; } } static class ChildOp extends Op { Op child ; ChildOp ( int type ) { super ( type ) ; } void setChild ( Op child ) { this . child = child ; } Op getChild ( ) { return this . child ; } } static class ModifierOp extends ChildOp { int v1 ; int v2 ; ModifierOp ( int type , int v1 , int v2 ) { super ( type ) ; this . v1 = v1 ; this . v2 = v2 ; } int getData ( ) { return this . v1 ; } int getData2 ( ) { return this . v2 ; } } static class RangeOp extends Op { Token tok ; RangeOp ( int type , Token tok ) { super ( type ) ; this . tok = tok ; } RangeToken getToken ( ) { return ( RangeToken ) this . tok ; } } static class StringOp extends Op { String string ; StringOp ( int type , String literal ) { super ( type ) ; this . string = literal ; } String getString ( ) { return this . string ; } } static class ConditionOp extends Op { int refNumber ; Op condition ; Op yes ; Op no ; ConditionOp ( int type , int refno , Op conditionflow , Op yesflow , Op noflow ) { super ( type ) ; this . refNumber = refno ; this . condition = conditionflow ; this . yes = yesflow ; this . no = noflow ; } } } 	0
package org . w3c . dom ; public interface DocumentType extends Node { public String getName ( ) ; public NamedNodeMap getEntities ( ) ; public NamedNodeMap getNotations ( ) ; public String getPublicId ( ) ; public String getSystemId ( ) ; public String getInternalSubset ( ) ; } 	1
package org . xml . sax ; import java . io . Reader ; import java . io . InputStream ; public class InputSource { public InputSource ( ) { } public InputSource ( String systemId ) { setSystemId ( systemId ) ; } public InputSource ( InputStream byteStream ) { setByteStream ( byteStream ) ; } public InputSource ( Reader characterStream ) { setCharacterStream ( characterStream ) ; } public void setPublicId ( String publicId ) { this . publicId = publicId ; } public String getPublicId ( ) { return publicId ; } public void setSystemId ( String systemId ) { this . systemId = systemId ; } public String getSystemId ( ) { return systemId ; } public void setByteStream ( InputStream byteStream ) { this . byteStream = byteStream ; } public InputStream getByteStream ( ) { return byteStream ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setCharacterStream ( Reader characterStream ) { this . characterStream = characterStream ; } public Reader getCharacterStream ( ) { return characterStream ; } private String publicId ; private String systemId ; private InputStream byteStream ; private String encoding ; private Reader characterStream ; } 	0
package org . apache . xerces . dom ; import org . apache . xerces . domx . DOMException ; public class DOMExceptionImpl extends DOMException { public DOMExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLFieldsetElementImpl extends WMLElementImpl implements WMLFieldsetElement { public WMLFieldsetElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setTitle ( String newValue ) { setAttribute ( "title" , newValue ) ; } public String getTitle ( ) { return getAttribute ( "title" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom ; public interface Comment extends CharacterData { } 	1
package org . apache . xerces . validators . common ; import java . util . * ; import org . apache . xerces . validators . common . Grammar ; import org . apache . xerces . validators . common . GrammarResolver ; public class GrammarResolverImpl implements GrammarResolver { private Hashtable fGrammarRegistry = new Hashtable ( ) ; public GrammarResolverImpl ( ) { } public Grammar getGrammar ( String nameSpaceKey ) { return ( Grammar ) ( fGrammarRegistry . get ( nameSpaceKey ) ) ; } public String [ ] getNSKeysInPool ( ) { int numberOfNSKeysInPool = fGrammarRegistry . size ( ) ; String [ ] NSArray = new String [ numberOfNSKeysInPool ] ; Enumeration enumOfKeys = nameSpaceKeys ( ) ; for ( int i = 0 ; i < numberOfNSKeysInPool ; i ++ ) { NSArray [ i ] = ( String ) ( enumOfKeys . nextElement ( ) ) ; } return NSArray ; } public void putGrammar ( String nameSpaceKey , Grammar grammar ) { fGrammarRegistry . put ( nameSpaceKey , grammar ) ; } public int size ( ) { return fGrammarRegistry . size ( ) ; } public Enumeration nameSpaceKeys ( ) { return fGrammarRegistry . keys ( ) ; } public Grammar removeGrammar ( String nameSpaceKey ) { if ( containsNameSpace ( nameSpaceKey ) == true ) fGrammarRegistry . remove ( nameSpaceKey ) ; return null ; } public boolean contains ( Grammar grammar ) { return fGrammarRegistry . contains ( grammar ) ; } public boolean containsNameSpace ( String nameSpaceKey ) { return fGrammarRegistry . containsKey ( nameSpaceKey ) ; } public void clearGrammarResolver ( ) { fGrammarRegistry . clear ( ) ; } } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface TreeWalker { public Node getRoot ( ) ; public int getWhatToShow ( ) ; public NodeFilter getFilter ( ) ; public boolean getExpandEntityReferences ( ) ; public Node getCurrentNode ( ) ; public void setCurrentNode ( Node currentNode ) throws DOMException ; public Node parentNode ( ) ; public Node firstChild ( ) ; public Node lastChild ( ) ; public Node previousSibling ( ) ; public Node nextSibling ( ) ; public Node previousNode ( ) ; public Node nextNode ( ) ; } 	1
package org . xml . sax ; public class HandlerBase implements EntityResolver , DTDHandler , DocumentHandler , ErrorHandler { public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException { return null ; } public void notationDecl ( String name , String publicId , String systemId ) { } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) { } public void setDocumentLocator ( Locator locator ) { } public void startDocument ( ) throws SAXException { } public void endDocument ( ) throws SAXException { } public void startElement ( String name , AttributeList attributes ) throws SAXException { } public void endElement ( String name ) throws SAXException { } public void characters ( char ch [ ] , int start , int length ) throws SAXException { } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { } public void processingInstruction ( String target , String data ) throws SAXException { } public void warning ( SAXParseException e ) throws SAXException { } public void error ( SAXParseException e ) throws SAXException { } public void fatalError ( SAXParseException e ) throws SAXException { throw e ; } } 	0
package org . w3c . dom ; public interface ProcessingInstruction extends Node { public String getTarget ( ) ; public String getData ( ) ; public void setData ( String data ) throws DOMException ; } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; import java . util . Vector ; public class DeepNodeListImpl implements NodeList { protected NodeImpl rootNode ; protected String tagName ; protected int changes = 0 ; protected Vector nodes ; protected String nsName ; protected boolean enableNS = false ; public DeepNodeListImpl ( NodeImpl rootNode , String tagName ) { this . rootNode = rootNode ; this . tagName = tagName ; nodes = new Vector ( ) ; } public DeepNodeListImpl ( NodeImpl rootNode , String nsName , String tagName ) { this ( rootNode , tagName ) ; this . nsName = ( nsName != null && ! nsName . equals ( "" ) ) ? nsName : null ; enableNS = true ; } public int getLength ( ) { item ( java . lang . Integer . MAX_VALUE ) ; return nodes . size ( ) ; } public Node item ( int index ) { Node thisNode ; if ( rootNode . changes ( ) != changes ) { nodes = new Vector ( ) ; changes = rootNode . changes ( ) ; } if ( index < nodes . size ( ) ) return ( Node ) nodes . elementAt ( index ) ; else { if ( nodes . size ( ) == 0 ) thisNode = rootNode ; else thisNode = ( NodeImpl ) ( nodes . lastElement ( ) ) ; while ( thisNode != null && index >= nodes . size ( ) ) { thisNode = nextMatchingElementAfter ( thisNode ) ; if ( thisNode != null ) nodes . addElement ( thisNode ) ; } return thisNode ; } } protected Node nextMatchingElementAfter ( Node current ) { Node next ; while ( current != null ) { if ( current . hasChildNodes ( ) ) { current = ( current . getFirstChild ( ) ) ; } else if ( current != rootNode && null != ( next = current . getNextSibling ( ) ) ) { current = next ; } else { next = null ; for ( ; current != rootNode ; current = current . getParentNode ( ) ) { next = current . getNextSibling ( ) ; if ( next != null ) break ; } current = next ; } if ( current != rootNode && current != null && current . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( ! enableNS ) { if ( tagName . equals ( "*" ) || ( ( ElementImpl ) current ) . getTagName ( ) . equals ( tagName ) ) { return current ; } } else { if ( tagName . equals ( "*" ) ) { if ( nsName != null && nsName . equals ( "*" ) ) { return current ; } else { ElementImpl el = ( ElementImpl ) current ; if ( ( nsName == null && el . getNamespaceURI ( ) == null ) || ( nsName != null && nsName . equals ( el . getNamespaceURI ( ) ) ) ) { return current ; } } } else { ElementImpl el = ( ElementImpl ) current ; if ( el . getLocalName ( ) != null && el . getLocalName ( ) . equals ( tagName ) ) { if ( nsName != null && nsName . equals ( "*" ) ) { return current ; } else { if ( ( nsName == null && el . getNamespaceURI ( ) == null ) || ( nsName != null && nsName . equals ( el . getNamespaceURI ( ) ) ) ) { return current ; } } } } } } } return null ; } } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . EventImpl ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public abstract class NodeImpl implements Node , NodeList , EventTarget , Cloneable , Serializable { static final long serialVersionUID = - 6316591992167219696L ; public static final short ELEMENT_DEFINITION_NODE = - 1 ; protected NodeImpl ownerNode ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short SYNCDATA = 0x1 << 1 ; protected final static short SYNCCHILDREN = 0x1 << 2 ; protected final static short OWNED = 0x1 << 3 ; protected final static short FIRSTCHILD = 0x1 << 4 ; protected final static short SPECIFIED = 0x1 << 5 ; protected final static short IGNORABLEWS = 0x1 << 6 ; protected final static short SETVALUE = 0x1 << 7 ; protected NodeImpl ( DocumentImpl ownerDocument ) { ownerNode = ownerDocument ; } public NodeImpl ( ) { } public abstract short getNodeType ( ) ; public abstract String getNodeName ( ) ; public String getNodeValue ( ) { return null ; } public void setNodeValue ( String x ) throws DOMException { } public Node appendChild ( Node newChild ) throws DOMException { return insertBefore ( newChild , null ) ; } public Node cloneNode ( boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } NodeImpl newnode ; try { newnode = ( NodeImpl ) clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } newnode . ownerNode = ownerDocument ( ) ; newnode . isOwned ( false ) ; newnode . isReadOnly ( false ) ; return newnode ; } public Document getOwnerDocument ( ) { if ( isOwned ( ) ) { return ownerNode . ownerDocument ( ) ; } else { return ( Document ) ownerNode ; } } DocumentImpl ownerDocument ( ) { if ( isOwned ( ) ) { return ownerNode . ownerDocument ( ) ; } else { return ( DocumentImpl ) ownerNode ; } } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ! isOwned ( ) ) { ownerNode = doc ; } } public Node getParentNode ( ) { return null ; } NodeImpl parentNode ( ) { return null ; } public Node getNextSibling ( ) { return null ; } public Node getPreviousSibling ( ) { return null ; } ChildNode previousSibling ( ) { return null ; } public NamedNodeMap getAttributes ( ) { return null ; } public boolean hasAttributes ( ) { return false ; } public boolean hasChildNodes ( ) { return false ; } public NodeList getChildNodes ( ) { return this ; } public Node getFirstChild ( ) { return null ; } public Node getLastChild ( ) { return null ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } public Node removeChild ( Node oldChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } public int getLength ( ) { return 0 ; } public Node item ( int index ) { return null ; } public void normalize ( ) { } public boolean supports ( String feature , String version ) { return ownerDocument ( ) . getImplementation ( ) . hasFeature ( feature , version ) ; } public String getNamespaceURI ( ) { return null ; } public String getPrefix ( ) { return null ; } public void setPrefix ( String prefix ) throws DOMException { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } public String getLocalName ( ) { return null ; } protected final static boolean MUTATIONEVENTS = true ; protected final static int MUTATION_NONE = 0x00 ; protected final static int MUTATION_LOCAL = 0x01 ; protected final static int MUTATION_AGGREGATE = 0x02 ; protected final static int MUTATION_ALL = 0xffff ; class LEntry { String type ; EventListener listener ; boolean useCapture ; LEntry ( String type , EventListener listener , boolean useCapture ) { this . type = type ; this . listener = listener ; this . useCapture = useCapture ; } } ; public void addEventListener ( String type , EventListener listener , boolean useCapture ) { if ( type == null || type . equals ( "" ) || listener == null ) return ; removeEventListener ( type , listener , useCapture ) ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null ) { nodeListeners = new Vector ( ) ; ownerDocument ( ) . setEventListeners ( this , nodeListeners ) ; } nodeListeners . addElement ( new LEntry ( type , listener , useCapture ) ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) ++ lc . captures ; else ++ lc . bubbles ; } public void removeEventListener ( String type , EventListener listener , boolean useCapture ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null || type == null || type . equals ( "" ) || listener == null ) return ; for ( int i = nodeListeners . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nodeListeners . elementAt ( i ) ) ; if ( le . useCapture == useCapture && le . listener == listener && le . type . equals ( type ) ) { nodeListeners . removeElementAt ( i ) ; if ( nodeListeners . size ( ) == 0 ) ownerDocument ( ) . setEventListeners ( this , null ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) -- lc . captures ; else -- lc . bubbles ; break ; } } } public boolean dispatchEvent ( Event event ) { if ( event == null ) return false ; EventImpl evt = ( EventImpl ) event ; if ( ! evt . initialized || evt . type == null || evt . type . equals ( "" ) ) throw new DOMExceptionImpl ( DOMExceptionImpl . UNSPECIFIED_EVENT_TYPE , "DOM010 Unspecified event type" ) ; LCount lc = LCount . lookup ( evt . getType ( ) ) ; if ( lc . captures + lc . bubbles + lc . defaults == 0 ) return evt . preventDefault ; evt . target = this ; evt . stopPropagation = false ; evt . preventDefault = false ; Vector pv = new Vector ( 10 , 10 ) ; Node p = this , n = p . getParentNode ( ) ; while ( n != null ) { pv . addElement ( n ) ; p = n ; n = n . getParentNode ( ) ; } if ( lc . captures > 0 ) { evt . eventPhase = Event . CAPTURING_PHASE ; for ( int j = pv . size ( ) - 1 ; j >= 0 ; -- j ) { if ( evt . stopPropagation ) break ; NodeImpl nn = ( NodeImpl ) pv . elementAt ( j ) ; evt . currentNode = nn ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( nn ) ; if ( nodeListeners != null ) { Vector nl = ( Vector ) ( nodeListeners . clone ( ) ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nl . elementAt ( i ) ) ; if ( le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } } } if ( lc . bubbles > 0 ) { evt . eventPhase = Event . AT_TARGET ; evt . currentNode = this ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( ! evt . stopPropagation && nodeListeners != null ) { Vector nl = ( Vector ) nodeListeners . clone ( ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) nl . elementAt ( i ) ; if ( le != null && ! le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } if ( evt . bubbles ) { evt . eventPhase = Event . BUBBLING_PHASE ; for ( int j = 0 ; j < pv . size ( ) ; ++ j ) { if ( evt . stopPropagation ) break ; NodeImpl nn = ( NodeImpl ) pv . elementAt ( j ) ; evt . currentNode = nn ; nodeListeners = ownerDocument ( ) . getEventListeners ( nn ) ; if ( nodeListeners != null ) { Vector nl = ( Vector ) ( nodeListeners . clone ( ) ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nl . elementAt ( i ) ) ; if ( ! le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } } } } if ( lc . defaults > 0 && ( ! evt . cancelable || ! evt . preventDefault ) ) { } return evt . preventDefault ; } void dispatchEventToSubtree ( Node n , Event e ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null || n == null ) return ; ( ( NodeImpl ) n ) . dispatchEvent ( e ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap a = n . getAttributes ( ) ; for ( int i = a . getLength ( ) - 1 ; i >= 0 ; -- i ) dispatchEventToSubtree ( a . item ( i ) , e ) ; } dispatchEventToSubtree ( n . getFirstChild ( ) , e ) ; dispatchEventToSubtree ( n . getNextSibling ( ) , e ) ; } } class EnclosingAttr { AttrImpl node ; String oldvalue ; } EnclosingAttr getEnclosingAttr ( ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { NodeImpl eventAncestor = this ; while ( true ) { if ( eventAncestor == null ) return null ; int type = eventAncestor . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE ) { EnclosingAttr retval = new EnclosingAttr ( ) ; retval . node = ( AttrImpl ) eventAncestor ; retval . oldvalue = retval . node . getNodeValue ( ) ; return retval ; } else if ( type == Node . ENTITY_REFERENCE_NODE ) eventAncestor = eventAncestor . parentNode ( ) ; else return null ; } } return null ; } void dispatchAggregateEvents ( EnclosingAttr ea ) { if ( ea != null ) dispatchAggregateEvents ( ea . node , ea . oldvalue ) ; else dispatchAggregateEvents ( null , null ) ; } void dispatchAggregateEvents ( AttrImpl enclosingAttr , String oldvalue ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null ) return ; NodeImpl owner = null ; if ( enclosingAttr != null ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { owner = ( ( NodeImpl ) ( enclosingAttr . getOwnerElement ( ) ) ) ; if ( owner != null ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_ATTR_MODIFIED , true , false , null , oldvalue , enclosingAttr . getNodeValue ( ) , enclosingAttr . getNodeName ( ) ) ; owner . dispatchEvent ( me ) ; } } } LCount lc = LCount . lookup ( MutationEventImpl . DOM_SUBTREE_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_SUBTREE_MODIFIED , true , false , null , null , null , null ) ; if ( enclosingAttr != null ) { enclosingAttr . dispatchEvent ( me ) ; if ( owner != null ) owner . dispatchEvent ( me ) ; } else dispatchEvent ( me ) ; } } } public void setReadOnly ( boolean readOnly , boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isReadOnly ( readOnly ) ; } public boolean getReadOnly ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isReadOnly ( ) ; } public void setUserData ( Object data ) { ownerDocument ( ) . setUserData ( this , data ) ; } public Object getUserData ( ) { return ownerDocument ( ) . getUserData ( this ) ; } protected void changed ( ) { ownerDocument ( ) . changed ( ) ; } protected int changes ( ) { return ownerDocument ( ) . changes ( ) ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean needsSyncData ( ) { return ( flags & SYNCDATA ) != 0 ; } final void needsSyncData ( boolean value ) { flags = ( short ) ( value ? flags | SYNCDATA : flags & ~ SYNCDATA ) ; } final boolean needsSyncChildren ( ) { return ( flags & SYNCCHILDREN ) != 0 ; } final void needsSyncChildren ( boolean value ) { flags = ( short ) ( value ? flags | SYNCCHILDREN : flags & ~ SYNCCHILDREN ) ; } final boolean isOwned ( ) { return ( flags & OWNED ) != 0 ; } final void isOwned ( boolean value ) { flags = ( short ) ( value ? flags | OWNED : flags & ~ OWNED ) ; } final boolean isFirstChild ( ) { return ( flags & FIRSTCHILD ) != 0 ; } final void isFirstChild ( boolean value ) { flags = ( short ) ( value ? flags | FIRSTCHILD : flags & ~ FIRSTCHILD ) ; } final boolean isSpecified ( ) { return ( flags & SPECIFIED ) != 0 ; } final void isSpecified ( boolean value ) { flags = ( short ) ( value ? flags | SPECIFIED : flags & ~ SPECIFIED ) ; } final boolean internalIsIgnorableWhitespace ( ) { return ( flags & IGNORABLEWS ) != 0 ; } final void isIgnorableWhitespace ( boolean value ) { flags = ( short ) ( value ? flags | IGNORABLEWS : flags & ~ IGNORABLEWS ) ; } final boolean setValueCalled ( ) { return ( flags & SETVALUE ) != 0 ; } final void setValueCalled ( boolean value ) { flags = ( short ) ( value ? flags | SETVALUE : flags & ~ SETVALUE ) ; } public String toString ( ) { return "[" + getNodeName ( ) + ": " + getNodeValue ( ) + "]" ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } out . defaultWriteObject ( ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . DOMException ; import org . w3c . dom . html . * ; import org . apache . xerces . dom . DOMImplementationImpl ; public class HTMLDOMImplementationImpl extends DOMImplementationImpl implements HTMLDOMImplementation { private static HTMLDOMImplementation _instance = new HTMLDOMImplementationImpl ( ) ; private HTMLDOMImplementationImpl ( ) { } public final HTMLDocument createHTMLDocument ( String title ) throws DOMException { HTMLDocument doc ; if ( title == null ) throw new NullPointerException ( "HTM014 Argument 'title' is null." ) ; doc = new HTMLDocumentImpl ( ) ; doc . setTitle ( title ) ; return doc ; } public static HTMLDOMImplementation getHTMLDOMImplementation ( ) { return _instance ; } } 	0
package org . apache . xerces . validators . datatype ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import java . io . IOException ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; public class DecimalDatatypeValidator extends AbstractDatatypeValidator { private Locale fLocale = null ; private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; private BigDecimal [ ] fEnumDecimal = null ; private String fPattern = null ; private BigDecimal fMaxInclusive = null ; private BigDecimal fMaxExclusive = null ; private BigDecimal fMinInclusive = null ; private BigDecimal fMinExclusive = null ; private int fFacetsDefined = 0 ; private int fScale = 0 ; private int fPrecision = 0 ; private boolean isMaxExclusiveDefined = false ; private boolean isMaxInclusiveDefined = false ; private boolean isMinExclusiveDefined = false ; private boolean isMinInclusiveDefined = false ; private boolean isScaleDefined = false ; private boolean isPrecisionDefined = false ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; private RegularExpression fRegex = null ; private Hashtable fFacets = null ; public DecimalDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public DecimalDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { fFacets = checkForFacetConsistency ( facets , base . getFacets ( ) ) ; fFacets = facets ; if ( fDerivedByList == false ) { Vector enumeration = null ; String value = null ; for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; try { if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = value ; if ( fPattern != null ) fRegex = new RegularExpression ( fPattern , "X" ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; enumeration = ( Vector ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; fMaxInclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MAXEXCLUSIVE ; fMaxExclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; fMinInclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MINEXCLUSIVE ; fMinExclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_PRECISION ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_PRECISSION ; isPrecisionDefined = true ; fPrecision = Integer . parseInt ( value ) ; } else if ( key . equals ( SchemaSymbols . ELT_SCALE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_SCALE ; isScaleDefined = true ; fScale = Integer . parseInt ( value ) ; } else { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . MSG_FORMAT_FAILURE , DatatypeMessageProvider . MSG_NONE , null ) ) ; } } catch ( Exception ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } isMaxExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXEXCLUSIVE ) != 0 ) ? true : false ; isMaxInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXINCLUSIVE ) != 0 ) ? true : false ; isMinExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MINEXCLUSIVE ) != 0 ) ? true : false ; isMinInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MININCLUSIVE ) != 0 ) ? true : false ; if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both maxInclusive and maxExclusive to be specified for the same datatype." ) ; } if ( isMinExclusiveDefined && isMinInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both minInclusive and minExclusive to be specified for the same datatype." ) ; } if ( isMaxExclusiveDefined && isMinExclusiveDefined ) { int compareTo = this . fMaxExclusive . compareTo ( this . fMinExclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxExclusive value ='" + this . fMaxExclusive + "'must be > than minExclusive value ='" + this . fMinExclusive + "'. " ) ; } if ( isMaxInclusiveDefined && isMinInclusiveDefined ) { int compareTo = this . fMaxInclusive . compareTo ( this . fMinInclusive ) ; if ( compareTo == - 1 ) throw new InvalidDatatypeFacetException ( "maxInclusive value ='" + this . fMaxInclusive + "'must be >= than minInclusive value ='" + this . fMinInclusive + "'. " ) ; } if ( isMaxExclusiveDefined && isMinInclusiveDefined ) { int compareTo = this . fMaxExclusive . compareTo ( this . fMinInclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxExclusive value ='" + this . fMaxExclusive + "'must be > than minInclusive value ='" + this . fMinInclusive + "'. " ) ; } if ( isMaxInclusiveDefined && isMinExclusiveDefined ) { int compareTo = this . fMaxInclusive . compareTo ( this . fMinExclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxInclusive value ='" + this . fMaxInclusive + "'must be > than minExclusive value ='" + this . fMinExclusive + "'. " ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { if ( enumeration != null ) { fEnumDecimal = new BigDecimal [ enumeration . size ( ) ] ; int i = 0 ; try { for ( ; i < enumeration . size ( ) ; i ++ ) { fEnumDecimal [ i ] = new BigDecimal ( stripPlusIfPresent ( ( ( String ) enumeration . elementAt ( i ) ) ) ) ; boundsCheck ( fEnumDecimal [ i ] ) ; } } catch ( Exception idve ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . InvalidEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { enumeration . elementAt ( i ) } ) ) ; } } } } else { } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { if ( fDerivedByList == false ) { if ( this . fBaseValidator != null ) { this . fBaseValidator . validate ( content , state ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_PATTERN ) != 0 ) { if ( fRegex == null || fRegex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value'" + content + "' does not match regular expression facet " + fRegex . getPattern ( ) ) ; } BigDecimal d = null ; try { d = new BigDecimal ( stripPlusIfPresent ( content ) ) ; } catch ( Exception nfe ) { throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotDecimal , DatatypeMessageProvider . MSG_NONE , new Object [ ] { "'" + content + "'" } ) ) ; } if ( isScaleDefined == true ) { if ( d . scale ( ) > fScale ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . ScaleExceeded , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } if ( isPrecisionDefined == true ) { int precision = d . movePointRight ( d . scale ( ) ) . toString ( ) . length ( ) - ( ( d . signum ( ) < 0 ) ? 1 : 0 ) ; if ( precision > fPrecision ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . PrecisionExceeded , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } boundsCheck ( d ) ; if ( fEnumDecimal != null ) enumCheck ( d ) ; } else { } return null ; } public void boundsCheck ( BigDecimal d ) throws InvalidDatatypeValueException { boolean minOk = false ; boolean maxOk = false ; String upperBound = ( fMaxExclusive != null ) ? ( fMaxExclusive . toString ( ) ) : ( ( fMaxInclusive != null ) ? fMaxInclusive . toString ( ) : "" ) ; String lowerBound = ( fMinExclusive != null ) ? ( fMinExclusive . toString ( ) ) : ( ( fMinInclusive != null ) ? fMinInclusive . toString ( ) : "" ) ; String lowerBoundIndicator = "" ; String upperBoundIndicator = "" ; if ( isMaxInclusiveDefined ) { maxOk = ( d . compareTo ( fMaxInclusive ) <= 0 ) ; upperBound = fMaxInclusive . toString ( ) ; if ( upperBound != null ) { upperBoundIndicator = "<=" ; } else { upperBound = "" ; } } else if ( isMaxExclusiveDefined ) { maxOk = ( d . compareTo ( fMaxExclusive ) < 0 ) ; upperBound = fMaxExclusive . toString ( ) ; if ( upperBound != null ) { upperBoundIndicator = "<" ; } else { upperBound = "" ; } } else { maxOk = ( ! isMaxInclusiveDefined && ! isMaxExclusiveDefined ) ; } if ( isMinInclusiveDefined ) { minOk = ( d . compareTo ( fMinInclusive ) >= 0 ) ; lowerBound = fMinInclusive . toString ( ) ; if ( lowerBound != null ) { lowerBoundIndicator = "<=" ; } else { lowerBound = "" ; } } else if ( isMinExclusiveDefined ) { minOk = ( d . compareTo ( fMinExclusive ) > 0 ) ; lowerBound = fMinExclusive . toString ( ) ; if ( lowerBound != null ) { lowerBoundIndicator = "<" ; } else { lowerBound = "" ; } } else { minOk = ( ! isMinInclusiveDefined && ! isMinExclusiveDefined ) ; } if ( ! ( minOk && maxOk ) ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . OutOfBounds , DatatypeMessageProvider . MSG_NONE , new Object [ ] { d . toString ( ) , lowerBound , upperBound , lowerBoundIndicator , upperBoundIndicator } ) ) ; } private void enumCheck ( BigDecimal v ) throws InvalidDatatypeValueException { for ( int i = 0 ; i < fEnumDecimal . length ; i ++ ) { if ( v . equals ( fEnumDecimal [ i ] ) ) { return ; } } throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotAnEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { v } ) ) ; } public void setLocale ( Locale locale ) { fLocale = locale ; } public Hashtable getFacets ( ) { return fFacets ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } public int compare ( String content1 , String content2 ) { return 0 ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } static private String stripPlusIfPresent ( String value ) { String strippedPlus = value ; if ( value . length ( ) >= 2 && value . charAt ( 0 ) == '+' && value . charAt ( 1 ) != '-' ) { strippedPlus = value . substring ( 1 ) ; } return strippedPlus ; } private Hashtable checkForFacetConsistency ( Hashtable thisTypeFacets , Hashtable baseTypeFacets ) throws InvalidDatatypeFacetException { String thisTypeFacetValue ; String baseValue ; if ( baseTypeFacets != null ) { Enumeration setOfBaseKeys = baseTypeFacets . keys ( ) ; String keyInBase ; BigDecimal valueOfThisType = null ; BigDecimal valueOfBase = null ; while ( setOfBaseKeys . hasMoreElements ( ) ) { keyInBase = ( String ) setOfBaseKeys . nextElement ( ) ; baseValue = ( String ) baseTypeFacets . get ( keyInBase ) ; thisTypeFacetValue = ( String ) thisTypeFacets . get ( keyInBase ) ; if ( thisTypeFacetValue == null ) { String strThisType = null ; thisTypeFacets . put ( keyInBase , baseValue ) ; if ( keyInBase . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MAXINCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == - 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MAXINCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == - 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MININCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MININCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MININCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MININCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MINEXCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MINEXCLUSIVE ) ; } } } else { if ( keyInBase . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } } } } return thisTypeFacets ; } } 	1
package org . w3c . dom . html ; public interface HTMLBaseFontElement extends HTMLElement { public String getColor ( ) ; public void setColor ( String color ) ; public String getFace ( ) ; public void setFace ( String face ) ; public String getSize ( ) ; public void setSize ( String size ) ; } 	0
package javax . xml . parsers ; public class FactoryConfigurationError extends Error { private Exception exception = null ; public FactoryConfigurationError ( ) { this ( null , null ) ; } public FactoryConfigurationError ( String msg ) { this ( null , msg ) ; } public FactoryConfigurationError ( Exception e ) { this ( e , null ) ; } public FactoryConfigurationError ( Exception e , String msg ) { super ( msg ) ; this . exception = e ; } public Exception getException ( ) { return ( this . exception ) ; } } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . parsers . SAXParser ; import org . apache . xerces . utils . StringPool ; import org . xml . sax . AttributeList ; import org . xml . sax . DocumentHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; public class XCatalog extends XMLCatalogHandler { public static final String XCATALOG_DTD_PUBLICID = "-//DTD XCatalog//EN" ; static final String DTD = "xcatalog.dtd" ; static final String XCATALOG = "XCatalog" ; static final String MAP = "Map" ; static final String PUBLICID = "PublicID" ; static final String HREF = "HRef" ; static final String DELEGATE = "Delegate" ; static final String EXTEND = "Extend" ; static final String BASE = "Base" ; static final String REMAP = "Remap" ; static final String SYSTEMID = "SystemID" ; private static final boolean DEBUG = false ; private Hashtable delegate = new Hashtable ( ) ; private Vector delegateOrder = new Vector ( ) ; public XCatalog ( ) { } public void loadCatalog ( InputSource source ) throws SAXException , IOException { new Parser ( source ) ; } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( DEBUG ) { System . out . println ( "resolveEntity(\"" + publicId + "\", \"" + systemId + "\")" ) ; } if ( publicId != null ) { String value = getPublicMapping ( publicId ) ; if ( DEBUG ) { System . out . println ( "  map: \"" + publicId + "\" -> \"" + value + "\"" ) ; } if ( value != null ) { InputSource source = resolveEntity ( null , value ) ; if ( source == null ) { source = new InputSource ( value ) ; } source . setPublicId ( publicId ) ; return source ; } Enumeration delegates = getDelegateCatalogKeys ( ) ; while ( delegates . hasMoreElements ( ) ) { String key = ( String ) delegates . nextElement ( ) ; if ( DEBUG ) { System . out . println ( "  delegate: \"" + key + "\"" ) ; } if ( publicId . startsWith ( key ) ) { XMLCatalogHandler catalog = getDelegateCatalog ( key ) ; InputSource source = catalog . resolveEntity ( publicId , systemId ) ; if ( source != null ) { return source ; } } } } String value = getSystemMapping ( systemId ) ; if ( value != null ) { if ( DEBUG ) { System . out . println ( "  remap: \"" + systemId + "\" -> \"" + value + "\"" ) ; } InputSource source = new InputSource ( value ) ; source . setPublicId ( publicId ) ; return source ; } if ( DEBUG ) { System . out . println ( "  returning null!" ) ; } return null ; } public void addDelegateCatalog ( String prefix , XCatalog catalog ) { synchronized ( delegate ) { if ( ! delegate . containsKey ( prefix ) ) { int size = delegateOrder . size ( ) ; boolean found = false ; for ( int i = 0 ; i < size ; i ++ ) { String element = ( String ) delegateOrder . elementAt ( i ) ; if ( prefix . startsWith ( element ) || prefix . compareTo ( element ) < 0 ) { delegateOrder . insertElementAt ( prefix , i ) ; found = true ; break ; } } if ( ! found ) { delegateOrder . addElement ( prefix ) ; } } delegate . put ( prefix , catalog ) ; } } public void removeDelegateCatalog ( String prefix ) { synchronized ( delegate ) { delegate . remove ( prefix ) ; delegateOrder . removeElement ( prefix ) ; } } public Enumeration getDelegateCatalogKeys ( ) { return delegateOrder . elements ( ) ; } public XCatalog getDelegateCatalog ( String prefix ) { return ( XCatalog ) delegate . get ( prefix ) ; } boolean isURL ( String str ) { try { new java . net . URL ( str ) ; return true ; } catch ( java . net . MalformedURLException e ) { } return false ; } class Parser extends SAXParser implements DocumentHandler { private String base ; public Parser ( InputSource source ) throws SAXException , IOException { setEntityResolver ( new Resolver ( ) ) ; setDocumentHandler ( ( DocumentHandler ) this ) ; setBase ( source . getSystemId ( ) ) ; parse ( source ) ; } protected void setBase ( String systemId ) throws SAXException { if ( systemId == null ) { systemId = "" ; } systemId = fEntityHandler . expandSystemId ( systemId ) ; int index = systemId . lastIndexOf ( '/' ) ; if ( index != - 1 ) { systemId = systemId . substring ( 0 , index + 1 ) ; } base = systemId ; } public void processingInstruction ( String target , String data ) { } public void setDocumentLocator ( org . xml . sax . Locator locator ) { } public void startDocument ( ) { } public void endElement ( String elementName ) { } public void endDocument ( ) { } public void characters ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void startElement ( String elementName , AttributeList attrList ) throws SAXException { try { if ( elementName . equals ( XCATALOG ) ) { return ; } if ( elementName . equals ( MAP ) ) { String publicId = attrList . getValue ( PUBLICID ) ; String href = attrList . getValue ( HREF ) ; if ( DEBUG ) { System . out . println ( "MAP \"" + publicId + "\" \"" + href + "\"" ) ; } if ( ! isURL ( href ) ) { href = base + href ; } addPublicMapping ( publicId , href ) ; } else if ( elementName . equals ( DELEGATE ) ) { String publicId = attrList . getValue ( PUBLICID ) ; String href = attrList . getValue ( HREF ) ; if ( DEBUG ) { System . out . println ( "DELEGATE \"" + publicId + "\" \"" + href + "\"" ) ; } if ( ! isURL ( href ) ) { href = base + href ; } String systemId = fEntityHandler . expandSystemId ( href ) ; XCatalog catalog = new XCatalog ( ) ; catalog . loadCatalog ( new InputSource ( systemId ) ) ; addDelegateCatalog ( publicId , catalog ) ; } else if ( elementName . equals ( EXTEND ) ) { String href = attrList . getValue ( HREF ) ; if ( DEBUG ) { System . out . println ( "EXTEND \"" + href + "\"" ) ; } if ( ! isURL ( href ) ) { href = base + href ; } String systemId = fEntityHandler . expandSystemId ( href ) ; XCatalog . this . loadCatalog ( new InputSource ( systemId ) ) ; } else if ( elementName . equals ( BASE ) ) { String href = attrList . getValue ( HREF ) ; setBase ( href ) ; if ( DEBUG ) { System . out . println ( "BASE \"" + href + "\" -> \"" + base + "\"" ) ; } } else if ( elementName . equals ( REMAP ) ) { String systemId = attrList . getValue ( SYSTEMID ) ; String href = attrList . getValue ( HREF ) ; if ( DEBUG ) { System . out . println ( "REMAP \"" + systemId + "\" \"" + href + "\"" ) ; } if ( ! isURL ( href ) ) { href = base + href ; } addSystemMapping ( systemId , href ) ; } } catch ( Exception e ) { throw new SAXException ( e ) ; } } class Resolver implements EntityResolver { public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( publicId != null && publicId . equals ( XCATALOG_DTD_PUBLICID ) ) { InputSource src = new InputSource ( ) ; src . setPublicId ( publicId ) ; InputStream is = getClass ( ) . getResourceAsStream ( DTD ) ; src . setByteStream ( is ) ; src . setCharacterStream ( new InputStreamReader ( is ) ) ; return src ; } return null ; } } } } 	0
package org . w3c . dom ; public interface DocumentFragment extends Node { } 	1
package org . apache . wml ; public interface WMLTrElement extends WMLElement { } 	0
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface MutationEvent extends Event { public Node getRelatedNode ( ) ; public String getPrevValue ( ) ; public String getNewValue ( ) ; public String getAttrName ( ) ; public void initMutationEvent ( String typeArg , boolean canBubbleArg , boolean cancelableArg , Node relatedNodeArg , String prevValueArg , String newValueArg , String attrNameArg ) ; } 	1
package org . w3c . dom . html ; public interface HTMLDivElement extends HTMLElement { public String getAlign ( ) ; public void setAlign ( String align ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . w3c . dom . traversal . * ; import org . apache . xerces . dom . DocumentImpl ; import org . apache . xerces . dom . DOMExceptionImpl ; public class NodeIteratorImpl implements NodeIterator { private DocumentImpl fDocument ; private Node fRoot ; private int fWhatToShow = NodeFilter . SHOW_ALL ; private NodeFilter fNodeFilter ; private boolean fDetach = false ; private Node fCurrentNode ; private boolean fForward = true ; private boolean fEntityReferenceExpansion ; public NodeIteratorImpl ( DocumentImpl document , Node root , int whatToShow , NodeFilter nodeFilter , boolean entityReferenceExpansion ) { fDocument = document ; fRoot = root ; fCurrentNode = null ; fWhatToShow = whatToShow ; fNodeFilter = nodeFilter ; fEntityReferenceExpansion = entityReferenceExpansion ; } public Node getRoot ( ) { return fRoot ; } public int getWhatToShow ( ) { return fWhatToShow ; } public NodeFilter getFilter ( ) { return fNodeFilter ; } public boolean getExpandEntityReferences ( ) { return fEntityReferenceExpansion ; } public Node nextNode ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMExceptionImpl . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( fRoot == null ) return null ; Node nextNode = fCurrentNode ; boolean accepted = false ; accepted_loop : while ( ! accepted ) { if ( ! fForward && nextNode != null ) { nextNode = fCurrentNode ; } else { if ( ! fEntityReferenceExpansion && nextNode != null && nextNode . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) { nextNode = nextNode ( nextNode , false ) ; } else { nextNode = nextNode ( nextNode , true ) ; } } fForward = true ; if ( nextNode == null ) return null ; accepted = acceptNode ( nextNode ) ; if ( accepted ) { fCurrentNode = nextNode ; return fCurrentNode ; } else continue accepted_loop ; } return null ; } public Node previousNode ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMExceptionImpl . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( fRoot == null || fCurrentNode == null ) return null ; Node previousNode = fCurrentNode ; boolean accepted = false ; accepted_loop : while ( ! accepted ) { if ( fForward && previousNode != null ) { previousNode = fCurrentNode ; } else { previousNode = previousNode ( previousNode ) ; } fForward = false ; if ( previousNode == null ) return null ; accepted = acceptNode ( previousNode ) ; if ( accepted ) { fCurrentNode = previousNode ; return fCurrentNode ; } else continue accepted_loop ; } return null ; } boolean acceptNode ( Node node ) { if ( fNodeFilter == null ) { return ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ; } else { return ( ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ) && fNodeFilter . acceptNode ( node ) == NodeFilter . FILTER_ACCEPT ; } } Node matchNodeOrParent ( Node node ) { for ( Node n = node ; n != fRoot ; n = n . getParentNode ( ) ) { if ( node == n ) return n ; } return null ; } Node nextNode ( Node node , boolean visitChildren ) { if ( node == null ) return fRoot ; Node result ; if ( visitChildren ) { if ( node . hasChildNodes ( ) ) { result = node . getFirstChild ( ) ; return result ; } } result = node . getNextSibling ( ) ; if ( result != null ) return result ; Node parent = node . getParentNode ( ) ; while ( parent != null && parent != fRoot ) { result = parent . getNextSibling ( ) ; if ( result != null ) { return result ; } else { parent = parent . getParentNode ( ) ; } } return null ; } Node previousNode ( Node node ) { Node result ; if ( node == fRoot ) return null ; result = node . getPreviousSibling ( ) ; if ( result == null ) { result = node . getParentNode ( ) ; return result ; } if ( result . hasChildNodes ( ) && ! ( ! fEntityReferenceExpansion && result != null && result . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) ) { while ( result . hasChildNodes ( ) ) { result = result . getLastChild ( ) ; } } return result ; } public void removeNode ( Node node ) { if ( node == null ) return ; Node deleted = matchNodeOrParent ( node ) ; if ( deleted == null ) return ; if ( fForward ) { fCurrentNode = previousNode ( deleted ) ; } else { Node next = nextNode ( deleted , false ) ; if ( next != null ) { fCurrentNode = next ; } else { fCurrentNode = previousNode ( deleted ) ; fForward = true ; } } } public void detach ( ) { fDetach = true ; fDocument . removeNodeIterator ( this ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; final class HTMLCollectionImpl implements HTMLCollection { static final short ANCHOR = 1 ; static final short FORM = 2 ; static final short IMAGE = 3 ; static final short APPLET = 4 ; static final short LINK = 5 ; static final short OPTION = 6 ; static final short ROW = 7 ; static final short ELEMENT = 8 ; static final short AREA = - 1 ; static final short TBODY = - 2 ; static final short CELL = - 3 ; private short _lookingFor ; private Element _topLevel ; HTMLCollectionImpl ( HTMLElement topLevel , short lookingFor ) { if ( topLevel == null ) throw new NullPointerException ( "HTM011 Argument 'topLevel' is null." ) ; _topLevel = topLevel ; _lookingFor = lookingFor ; } public final int getLength ( ) { return getLength ( _topLevel ) ; } public final Node item ( int index ) { if ( index < 0 ) throw new IllegalArgumentException ( "HTM012 Argument 'index' is negative." ) ; return item ( _topLevel , new CollectionIndex ( index ) ) ; } public final Node namedItem ( String name ) { if ( name == null ) throw new NullPointerException ( "HTM013 Argument 'name' is null." ) ; return namedItem ( _topLevel , name ) ; } private int getLength ( Element topLevel ) { int length ; Node node ; synchronized ( topLevel ) { length = 0 ; node = topLevel . getFirstChild ( ) ; while ( node != null ) { if ( node instanceof Element ) { if ( collectionMatch ( ( Element ) node , null ) ) ++ length ; else if ( recurse ( ) ) length += getLength ( ( Element ) node ) ; } node = node . getNextSibling ( ) ; } } return length ; } private Node item ( Element topLevel , CollectionIndex index ) { Node node ; Node result ; synchronized ( topLevel ) { node = topLevel . getFirstChild ( ) ; while ( node != null ) { if ( node instanceof Element ) { if ( collectionMatch ( ( Element ) node , null ) ) { if ( index . isZero ( ) ) return node ; index . decrement ( ) ; } else if ( recurse ( ) ) { result = item ( ( Element ) node , index ) ; if ( result != null ) return result ; } } node = node . getNextSibling ( ) ; } } return null ; } private Node namedItem ( Element topLevel , String name ) { Node node ; Node result ; synchronized ( topLevel ) { node = topLevel . getFirstChild ( ) ; while ( node != null ) { if ( node instanceof Element ) { if ( collectionMatch ( ( Element ) node , name ) ) return node ; else if ( recurse ( ) ) { result = namedItem ( ( Element ) node , name ) ; if ( result != null ) return result ; } } node = node . getNextSibling ( ) ; } return node ; } } protected boolean recurse ( ) { return _lookingFor > 0 ; } protected boolean collectionMatch ( Element elem , String name ) { boolean match ; synchronized ( elem ) { match = false ; switch ( _lookingFor ) { case ANCHOR : match = ( elem instanceof HTMLAnchorElement ) && elem . getAttribute ( "name" ) . length ( ) > 0 ; break ; case FORM : match = ( elem instanceof HTMLFormElement ) ; break ; case IMAGE : match = ( elem instanceof HTMLImageElement ) ; break ; case APPLET : match = ( elem instanceof HTMLAppletElement ) || ( elem instanceof HTMLObjectElement && ( "application/java" . equals ( elem . getAttribute ( "codetype" ) ) || elem . getAttribute ( "classid" ) . startsWith ( "java:" ) ) ) ; break ; case ELEMENT : match = ( elem instanceof HTMLFormControl ) ; break ; case LINK : match = ( ( elem instanceof HTMLAnchorElement || elem instanceof HTMLAreaElement ) && elem . getAttribute ( "href" ) . length ( ) > 0 ) ; break ; case AREA : match = ( elem instanceof HTMLAreaElement ) ; break ; case OPTION : match = ( elem instanceof HTMLOptionElement ) ; break ; case ROW : match = ( elem instanceof HTMLTableRowElement ) ; break ; case TBODY : match = ( elem instanceof HTMLTableSectionElement && elem . getTagName ( ) . equals ( "tbody" ) ) ; break ; case CELL : match = ( elem instanceof HTMLTableCellElement ) ; break ; } if ( match && name != null ) { if ( elem instanceof HTMLAnchorElement && name . equals ( elem . getAttribute ( "name" ) ) ) return true ; match = name . equals ( elem . getAttribute ( "id" ) ) ; } } return match ; } } class CollectionIndex { int getIndex ( ) { return _index ; } void decrement ( ) { -- _index ; } boolean isZero ( ) { return _index <= 0 ; } CollectionIndex ( int index ) { _index = index ; } private int _index ; } 	0
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . CharDataChunk ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringHasher ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . ImplementationMessages ; import org . xml . sax . SAXParseException ; import java . util . Vector ; abstract class AbstractCharReader extends XMLEntityReader { protected AbstractCharReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , StringPool stringPool ) { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fStringPool = stringPool ; fCurrentChunk = CharDataChunk . createChunk ( fStringPool , null ) ; } protected CharDataChunk fCurrentChunk = null ; protected int fCurrentIndex = 0 ; protected char [ ] fMostRecentData = null ; protected int fMostRecentChar = 0 ; protected int fLength = 0 ; protected abstract int fillCurrentChunk ( ) throws Exception ; protected void deferException ( int errorCode , Object [ ] args , int offset ) { if ( fDeferredErrors == null ) fDeferredErrors = new Vector ( ) ; DeferredError de = new DeferredError ( errorCode , args , offset ) ; fDeferredErrors . addElement ( de ) ; } protected XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; return nextReader ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } public boolean lookingAtChar ( char chr , boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch != chr ) { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( chr , skipPastChar ) ; } } return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ; } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0xD800 ) { if ( ch >= 0x20 || ch == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } if ( ch == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } return true ; } if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } if ( ch > 0xFFFD ) { return false ; } if ( ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; boolean valid = ( ch >= 0xDC00 && ch < 0xE000 ) ; if ( ! valid || ! skipPastChar ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return valid ; } } else if ( ch < 0xE000 ) { return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ; return true ; } public void skipToChar ( char chr ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == chr ) return ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( chr ) ; return ; } fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch >= 0xD800 && ch < 0xDC00 ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) continue ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } ch = loadNextChar ( ) ; } } public void skipPastName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return ; } while ( true ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int length = s . length ; char [ ] data = fMostRecentData ; int index = fCurrentIndex ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { for ( int i = 0 ; i < length ; i ++ ) { if ( data [ index ++ ] != s [ i ] ) return false ; } fCharacterCounter += length ; fCurrentOffset += length ; fCurrentIndex = index ; if ( index == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = data [ index ] & 0xFFFF ; return true ; } CharDataChunk dataChunk = fCurrentChunk ; int offset = fCurrentOffset ; int savedIndex = index ; int i = 0 ; while ( index < CharDataChunk . CHUNK_SIZE ) { if ( data [ index ++ ] != s [ i ++ ] ) return false ; } slowLoadNextChar ( ) ; data = fMostRecentData ; index = 0 ; while ( i < length ) { if ( data [ index ++ ] != s [ i ++ ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } fCharacterCounter += length ; fCurrentOffset += length ; fCurrentIndex = index ; if ( index == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = data [ index ] & 0xFFFF ; return true ; } public int scanInvalidChar ( ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } if ( fDeferredErrors != null ) { for ( int i = 0 ; i < fDeferredErrors . size ( ) ; i ++ ) { DeferredError de = ( DeferredError ) fDeferredErrors . elementAt ( i ) ; if ( de . offset == fCurrentIndex ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , de . errorCode , 0 , de . args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; fDeferredErrors . removeElementAt ( i ) ; fCharacterCounter ++ ; loadNextChar ( ) ; return - 1 ; } } } fCharacterCounter ++ ; loadNextChar ( ) ; } else { fCharacterCounter ++ ; if ( ch >= 0xD800 && ch < 0xDC00 ) { int ch2 = loadNextChar ( ) ; if ( ch2 >= 0xDC00 && ch2 < 0xE000 ) { ch = ( ( ch - 0xD800 ) << 10 ) + ( ch2 - 0xDC00 ) + 0x10000 ; loadNextChar ( ) ; } } else loadNextChar ( ) ; } return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextChar ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentChar ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextChar ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextChar ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( lookingAtChar ( qchar , false ) ) { break ; } if ( lookingAtChar ( ' ' , true ) ) { continue ; } if ( lookingAtSpace ( false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '<' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } int result = asSymbol ? addSymbol ( offset , fCurrentOffset - offset ) : addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return result ; } public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } if ( qchar != - 1 && lookingAtChar ( ( char ) qchar , false ) ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; break ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; } if ( lookingAtChar ( '%' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } int result = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( ( char ) qchar , true ) ; return result ; } public int scanName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return - 1 ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return - 1 ; } int offset = fCurrentOffset ; int index = fCurrentIndex ; char [ ] data = fMostRecentData ; if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; int hashcode = 0 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = data [ index ] & 0xFFFF ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; } fCurrentIndex = index ; fMostRecentChar = ch ; hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; int nameIndex = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; return nameIndex ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int ch = fMostRecentChar ; for ( int i = 0 ; i < len ; i ++ ) { if ( ch != expected [ offset ++ ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } fCharacterCounter ++ ; fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) ch = slowLoadNextChar ( ) ; else ch = ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; int index = fCurrentIndex ; char [ ] data = fMostRecentData ; if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; int hashcode = 0 ; int prefixend = - 1 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = data [ index ] & 0xFFFF ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; if ( index + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; ch = slowLoadNextChar ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; } else ch = data [ index + 1 ] & 0xFFFF ; boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; break ; } } } else { if ( fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; } fCurrentIndex = index ; fMostRecentChar = ch ; hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; qname . rawname = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentChar ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeMarkup ( ch ) ; } break ; case 2 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } break ; case 3 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch != ']' ) break ; if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) break ; fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , true ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } break ; } } else if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , false ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextChar ( ) ; break ; } callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentChar ; } } } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool fStringPool = null ; private boolean fCalledCharPropInit = false ; private boolean fCallClearPreviousChunk = true ; private Vector fDeferredErrors = null ; private class DeferredError { int errorCode ; Object [ ] args ; int offset ; DeferredError ( int ec , Object [ ] a , int o ) { errorCode = ec ; args = a ; offset = o ; } } private int recognizeMarkup ( int ch ) throws Exception { switch ( ch ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( ch == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } private boolean skipMultiByteCharData ( int ch ) throws Exception { if ( ch < 0xD800 ) { loadNextChar ( ) ; return true ; } if ( ch > 0xFFFD ) return false ; if ( ch >= 0xDC00 && ch < 0xE000 ) return false ; if ( ch >= 0xD800 && ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } loadNextChar ( ) ; return true ; } private int skipAsciiCharData ( ) throws Exception { int index = fCurrentIndex ; int offset = fCurrentOffset - index ; while ( true ) { char [ ] data = fMostRecentData ; while ( index < CharDataChunk . CHUNK_SIZE ) { int ch = data [ index ] & 0xFFFF ; if ( ch >= 0x80 ) { fCurrentOffset = offset + index ; fCurrentIndex = index ; fMostRecentChar = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { fCurrentOffset = offset + index ; fCurrentIndex = index ; fMostRecentChar = ch ; return ch ; } index ++ ; } offset += index ; slowLoadNextChar ( ) ; index = 0 ; } } private void callCharDataHandler ( int offset , int endOffset , boolean isWhitespace ) throws Exception { int length = endOffset - offset ; if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , length ) ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( stringIndex ) ; else fCharDataHandler . processCharacters ( stringIndex ) ; return ; } CharDataChunk dataChunk = fCurrentChunk . chunkFor ( offset ) ; int index = offset & CharDataChunk . CHUNK_MASK ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { if ( length != 0 ) { if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , length ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , length ) ; } return ; } int count = length ; int nbytes = CharDataChunk . CHUNK_SIZE - index ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , nbytes ) ; count -= nbytes ; do { dataChunk = dataChunk . nextChunk ( ) ; if ( dataChunk == null ) { throw new RuntimeException ( new ImplementationMessages ( ) . createMessage ( null , ImplementationMessages . INT_DCN , 0 , null ) ) ; } nbytes = count <= CharDataChunk . CHUNK_SIZE ? count : CharDataChunk . CHUNK_SIZE ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; count -= nbytes ; } while ( count > 0 ) ; } private int slowLoadNextChar ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toCharArray ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } else { fCurrentChunk = CharDataChunk . createChunk ( fStringPool , fCurrentChunk ) ; return fillCurrentChunk ( ) ; } } private int loadNextChar ( ) throws Exception { fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) return slowLoadNextChar ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } } 	1
package org . apache . xerces . framework ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . readers . DefaultEntityHandler ; import org . apache . xerces . utils . ChunkyCharArray ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . apache . xerces . validators . common . GrammarResolver ; import org . xml . sax . Locator ; import org . xml . sax . SAXParseException ; public final class XMLDocumentScanner { static final char [ ] cdata_string = { '[' , 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; static final char [ ] xml_string = { 'x' , 'm' , 'l' } ; private static final char [ ] version_string = { 'v' , 'e' , 'r' , 's' , 'i' , 'o' , 'n' } ; static final char [ ] doctype_string = { 'D' , 'O' , 'C' , 'T' , 'Y' , 'P' , 'E' } ; private static final char [ ] standalone_string = { 's' , 't' , 'a' , 'n' , 'd' , 'a' , 'l' , 'o' , 'n' , 'e' } ; private static final char [ ] encoding_string = { 'e' , 'n' , 'c' , 'o' , 'd' , 'i' , 'n' , 'g' } ; public static final int RESULT_SUCCESS = 0 , RESULT_FAILURE = - 1 , RESULT_DUPLICATE_ATTR = - 2 ; static final int SCANNER_STATE_XML_DECL = 0 , SCANNER_STATE_START_OF_MARKUP = 1 , SCANNER_STATE_COMMENT = 2 , SCANNER_STATE_PI = 3 , SCANNER_STATE_DOCTYPE = 4 , SCANNER_STATE_PROLOG = 5 , SCANNER_STATE_ROOT_ELEMENT = 6 , SCANNER_STATE_CONTENT = 7 , SCANNER_STATE_REFERENCE = 8 , SCANNER_STATE_ATTRIBUTE_LIST = 9 , SCANNER_STATE_ATTRIBUTE_NAME = 10 , SCANNER_STATE_ATTRIBUTE_VALUE = 11 , SCANNER_STATE_TRAILING_MISC = 12 , SCANNER_STATE_END_OF_INPUT = 13 , SCANNER_STATE_TERMINATED = 14 ; private StringPool . CharArrayRange fCurrentElementCharArrayRange = null ; int fAttrListHandle = - 1 ; XMLAttrList fAttrList = null ; GrammarResolver fGrammarResolver = null ; XMLDTDScanner fDTDScanner = null ; boolean fNamespacesEnabled = false ; boolean fValidationEnabled = false ; QName fElementQName = new QName ( ) ; QName fAttributeQName = new QName ( ) ; QName fCurrentElementQName = new QName ( ) ; ScannerDispatcher fDispatcher = null ; EventHandler fEventHandler = null ; XMLDocumentHandler . DTDHandler fDTDHandler = null ; StringPool fStringPool = null ; XMLErrorReporter fErrorReporter = null ; XMLEntityHandler fEntityHandler = null ; XMLEntityHandler . EntityReader fEntityReader = null ; XMLEntityHandler . CharBuffer fLiteralData = null ; boolean fSeenRootElement = false ; boolean fSeenDoctypeDecl = false ; boolean fStandalone = false ; boolean fParseTextDecl = false ; boolean fScanningDTD = false ; int fScannerState = SCANNER_STATE_XML_DECL ; int fReaderId = - 1 ; int fAttValueReader = - 1 ; int fAttValueElementType = - 1 ; int fAttValueAttrName = - 1 ; int fAttValueOffset = - 1 ; int fAttValueMark = - 1 ; int fScannerMarkupDepth = 0 ; public interface EventHandler { public void callStandaloneIsYes ( ) throws Exception ; public void callStartDocument ( ) throws Exception ; public void callEndDocument ( ) throws Exception ; public void callXMLDecl ( int version , int encoding , int standalone ) throws Exception ; public void callTextDecl ( int version , int encoding ) throws Exception ; public void callStartElement ( QName element ) throws Exception ; public void element ( QName element ) throws Exception ; public boolean attribute ( QName element , QName attrName , int attrValue ) throws Exception ; public void callEndElement ( int readerId ) throws Exception ; public void callStartCDATA ( ) throws Exception ; public void callEndCDATA ( ) throws Exception ; public void callCharacters ( int ch ) throws Exception ; public void callProcessingInstruction ( int piTarget , int piData ) throws Exception ; public void callComment ( int data ) throws Exception ; } public XMLDocumentScanner ( StringPool stringPool , XMLErrorReporter errorReporter , XMLEntityHandler entityHandler , XMLEntityHandler . CharBuffer literalData ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fEntityHandler = entityHandler ; fLiteralData = literalData ; fDispatcher = new XMLDeclDispatcher ( ) ; fAttrList = new XMLAttrList ( fStringPool ) ; } public void setEventHandler ( XMLDocumentScanner . EventHandler eventHandler ) { fEventHandler = eventHandler ; } public void setDTDHandler ( XMLDocumentHandler . DTDHandler dtdHandler ) { fDTDHandler = dtdHandler ; } public void setGrammarResolver ( GrammarResolver resolver ) { fGrammarResolver = resolver ; } public void reset ( StringPool stringPool , XMLEntityHandler . CharBuffer literalData ) { fStringPool = stringPool ; fLiteralData = literalData ; fParseTextDecl = false ; fSeenRootElement = false ; fSeenDoctypeDecl = false ; fStandalone = false ; fScanningDTD = false ; fDispatcher = new XMLDeclDispatcher ( ) ; fScannerState = SCANNER_STATE_XML_DECL ; fScannerMarkupDepth = 0 ; fAttrList = new XMLAttrList ( fStringPool ) ; } public boolean parseSome ( boolean doItAll ) throws Exception { do { if ( ! fDispatcher . dispatch ( doItAll ) ) return false ; } while ( doItAll ) ; return true ; } public void readerChange ( XMLEntityHandler . EntityReader nextReader , int nextReaderId ) throws Exception { fEntityReader = nextReader ; fReaderId = nextReaderId ; if ( fScannerState == SCANNER_STATE_ATTRIBUTE_VALUE ) { fAttValueOffset = fEntityReader . currentOffset ( ) ; fAttValueMark = fAttValueOffset ; } if ( fDTDScanner != null && fScanningDTD ) fDTDScanner . readerChange ( nextReader , nextReaderId ) ; } public void endOfInput ( int entityName , boolean moreToFollow ) throws Exception { if ( fDTDScanner != null && fScanningDTD ) { fDTDScanner . endOfInput ( entityName , moreToFollow ) ; } fDispatcher . endOfInput ( entityName , moreToFollow ) ; } public boolean atEndOfInput ( ) { return fScannerState == SCANNER_STATE_END_OF_INPUT ; } public int scanAttValue ( QName element , QName attribute , boolean asSymbol ) throws Exception { boolean single ; if ( ! ( single = fEntityReader . lookingAtChar ( '\'' , true ) ) && ! fEntityReader . lookingAtChar ( '\"' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_QUOTE_REQUIRED_IN_ATTVALUE , XMLMessages . P10_QUOTE_REQUIRED , element . rawname , attribute . rawname ) ; return - 1 ; } char qchar = single ? '\'' : '\"' ; fAttValueMark = fEntityReader . currentOffset ( ) ; int attValue = fEntityReader . scanAttValue ( qchar , asSymbol ) ; if ( attValue >= 0 ) return attValue ; int previousState = setScannerState ( SCANNER_STATE_ATTRIBUTE_VALUE ) ; fAttValueReader = fReaderId ; fAttValueElementType = element . rawname ; fAttValueAttrName = attribute . rawname ; fAttValueOffset = fEntityReader . currentOffset ( ) ; int dataOffset = fLiteralData . length ( ) ; if ( fAttValueOffset - fAttValueMark > 0 ) fEntityReader . append ( fLiteralData , fAttValueMark , fAttValueOffset - fAttValueMark ) ; fAttValueMark = fAttValueOffset ; boolean setMark = false ; boolean skippedCR ; while ( true ) { if ( fEntityReader . lookingAtChar ( qchar , true ) ) { if ( fReaderId == fAttValueReader ) break ; } else if ( fEntityReader . lookingAtChar ( ' ' , true ) ) { } else if ( ( skippedCR = fEntityReader . lookingAtChar ( ( char ) 0x0D , true ) ) || fEntityReader . lookingAtSpace ( true ) ) { if ( fAttValueOffset - fAttValueMark > 0 ) fEntityReader . append ( fLiteralData , fAttValueMark , fAttValueOffset - fAttValueMark ) ; setMark = true ; fLiteralData . append ( ' ' ) ; if ( skippedCR ) { } } else if ( fEntityReader . lookingAtChar ( '&' , true ) ) { if ( fAttValueOffset - fAttValueMark > 0 ) fEntityReader . append ( fLiteralData , fAttValueMark , fAttValueOffset - fAttValueMark ) ; setMark = true ; if ( fEntityReader . lookingAtChar ( '#' , true ) ) { int ch = scanCharRef ( ) ; if ( ch != - 1 ) { if ( ch < 0x10000 ) fLiteralData . append ( ( char ) ch ) ; else { fLiteralData . append ( ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ) ; fLiteralData . append ( ( char ) ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ) ; } } } else { int nameOffset = fEntityReader . currentOffset ( ) ; fEntityReader . skipPastName ( ';' ) ; int nameLength = fEntityReader . currentOffset ( ) - nameOffset ; if ( nameLength == 0 ) { reportFatalXMLError ( XMLMessages . MSG_NAME_REQUIRED_IN_REFERENCE , XMLMessages . P68_NAME_REQUIRED ) ; } else if ( ! fEntityReader . lookingAtChar ( ';' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_SEMICOLON_REQUIRED_IN_REFERENCE , XMLMessages . P68_SEMICOLON_REQUIRED , fEntityReader . addString ( nameOffset , nameLength ) ) ; } else { int entityName = fEntityReader . addSymbol ( nameOffset , nameLength ) ; fEntityHandler . startReadingFromEntity ( entityName , fScannerMarkupDepth , XMLEntityHandler . ENTITYREF_IN_ATTVALUE ) ; } } } else if ( fEntityReader . lookingAtChar ( '<' , true ) ) { if ( fAttValueOffset - fAttValueMark > 0 ) fEntityReader . append ( fLiteralData , fAttValueMark , fAttValueOffset - fAttValueMark ) ; setMark = true ; reportFatalXMLError ( XMLMessages . MSG_LESSTHAN_IN_ATTVALUE , XMLMessages . WFC_NO_LESSTHAN_IN_ATTVALUE , element . rawname , attribute . rawname ) ; } else if ( ! fEntityReader . lookingAtValidChar ( true ) ) { if ( fAttValueOffset - fAttValueMark > 0 ) fEntityReader . append ( fLiteralData , fAttValueMark , fAttValueOffset - fAttValueMark ) ; setMark = true ; int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState == SCANNER_STATE_END_OF_INPUT ) return - 1 ; if ( invChar >= 0 ) { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_ATTVALUE , XMLMessages . P10_INVALID_CHARACTER , fStringPool . toString ( element . rawname ) , fStringPool . toString ( attribute . rawname ) , Integer . toHexString ( invChar ) ) ; } } fAttValueOffset = fEntityReader . currentOffset ( ) ; if ( setMark ) { fAttValueMark = fAttValueOffset ; setMark = false ; } } restoreScannerState ( previousState ) ; int dataLength = fLiteralData . length ( ) - dataOffset ; if ( dataLength == 0 ) { return fEntityReader . addString ( fAttValueMark , fAttValueOffset - fAttValueMark ) ; } if ( fAttValueOffset - fAttValueMark > 0 ) { fEntityReader . append ( fLiteralData , fAttValueMark , fAttValueOffset - fAttValueMark ) ; dataLength = fLiteralData . length ( ) - dataOffset ; } int value = fLiteralData . addString ( dataOffset , dataLength ) ; return value ; } public void checkXMLLangAttributeValue ( int langValue ) throws Exception { String lang = fStringPool . toString ( langValue ) ; int offset = - 1 ; if ( lang . length ( ) >= 2 ) { char ch0 = lang . charAt ( 0 ) ; if ( lang . charAt ( 1 ) == '-' ) { if ( ch0 == 'i' || ch0 == 'I' || ch0 == 'x' || ch0 == 'X' ) { offset = 1 ; } } else { char ch1 = lang . charAt ( 1 ) ; if ( ( ( ch0 >= 'a' && ch0 <= 'z' ) || ( ch0 >= 'A' && ch0 <= 'Z' ) ) && ( ( ch1 >= 'a' && ch1 <= 'z' ) || ( ch1 >= 'A' && ch1 <= 'Z' ) ) ) { offset = 2 ; } } } if ( offset > 0 && lang . length ( ) > offset ) { char ch = lang . charAt ( offset ++ ) ; if ( ch != '-' ) { offset = - 1 ; } else { while ( true ) { if ( ch == '-' ) { if ( lang . length ( ) == offset ) { offset = - 1 ; break ; } ch = lang . charAt ( offset ++ ) ; if ( ( ch < 'a' || ch > 'z' ) && ( ch < 'A' || ch > 'Z' ) ) { offset = - 1 ; break ; } if ( lang . length ( ) == offset ) break ; } else if ( ( ch < 'a' || ch > 'z' ) && ( ch < 'A' || ch > 'Z' ) ) { offset = - 1 ; break ; } else if ( lang . length ( ) == offset ) break ; ch = lang . charAt ( offset ++ ) ; } } } if ( offset == - 1 ) { reportFatalXMLError ( XMLMessages . MSG_XML_LANG_INVALID , XMLMessages . P33_INVALID , lang ) ; } } void reportFatalXMLError ( int majorCode , int minorCode ) throws Exception { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } void reportFatalXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } void reportFatalXMLError ( int majorCode , int minorCode , String string1 ) throws Exception { Object [ ] args = { string1 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } void reportFatalXMLError ( int majorCode , int minorCode , int stringIndex1 , int stringIndex2 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) , fStringPool . toString ( stringIndex2 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } void reportFatalXMLError ( int majorCode , int minorCode , String string1 , String string2 ) throws Exception { Object [ ] args = { string1 , string2 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } void reportFatalXMLError ( int majorCode , int minorCode , String string1 , String string2 , String string3 ) throws Exception { Object [ ] args = { string1 , string2 , string3 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } void abortMarkup ( int majorCode , int minorCode ) throws Exception { reportFatalXMLError ( majorCode , minorCode ) ; skipPastEndOfCurrentMarkup ( ) ; } void abortMarkup ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { reportFatalXMLError ( majorCode , minorCode , stringIndex1 ) ; skipPastEndOfCurrentMarkup ( ) ; } void abortMarkup ( int majorCode , int minorCode , String string1 ) throws Exception { reportFatalXMLError ( majorCode , minorCode , string1 ) ; skipPastEndOfCurrentMarkup ( ) ; } void abortMarkup ( int majorCode , int minorCode , int stringIndex1 , int stringIndex2 ) throws Exception { reportFatalXMLError ( majorCode , minorCode , stringIndex1 , stringIndex2 ) ; skipPastEndOfCurrentMarkup ( ) ; } void skipPastEndOfCurrentMarkup ( ) throws Exception { fEntityReader . skipToChar ( '>' ) ; if ( fEntityReader . lookingAtChar ( '>' , true ) ) fScannerMarkupDepth -- ; } int setScannerState ( int state ) { int oldState = fScannerState ; fScannerState = state ; return oldState ; } void restoreScannerState ( int state ) { if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) fScannerState = state ; } interface ScannerDispatcher { boolean dispatch ( boolean keepgoing ) throws Exception ; void endOfInput ( int entityName , boolean moreToFollow ) throws Exception ; } final class XMLDeclDispatcher implements ScannerDispatcher { public boolean dispatch ( boolean keepgoing ) throws Exception { fEventHandler . callStartDocument ( ) ; if ( fEntityReader . lookingAtChar ( '<' , true ) ) { fScannerMarkupDepth ++ ; setScannerState ( SCANNER_STATE_START_OF_MARKUP ) ; if ( fEntityReader . lookingAtChar ( '?' , true ) ) { int piTarget = fEntityReader . scanName ( ' ' ) ; if ( piTarget == - 1 ) { abortMarkup ( XMLMessages . MSG_PITARGET_REQUIRED , XMLMessages . P16_PITARGET_REQUIRED ) ; } else if ( "xml" . equals ( fStringPool . toString ( piTarget ) ) ) { if ( fEntityReader . lookingAtSpace ( true ) ) { scanXMLDeclOrTextDecl ( false ) ; } else { abortMarkup ( XMLMessages . MSG_RESERVED_PITARGET , XMLMessages . P17_RESERVED_PITARGET ) ; } } else { scanPI ( piTarget ) ; } fDispatcher = new PrologDispatcher ( ) ; restoreScannerState ( SCANNER_STATE_PROLOG ) ; return true ; } if ( fEntityReader . lookingAtChar ( '!' , true ) ) { if ( fEntityReader . lookingAtChar ( '-' , true ) ) { if ( fEntityReader . lookingAtChar ( '-' , true ) ) { scanComment ( ) ; } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG , XMLMessages . P22_NOT_RECOGNIZED ) ; } } else { if ( fEntityReader . skippedString ( doctype_string ) ) { setScannerState ( SCANNER_STATE_DOCTYPE ) ; fSeenDoctypeDecl = true ; scanDoctypeDecl ( fStandalone ) ; fScannerMarkupDepth -- ; fDispatcher = new PrologDispatcher ( ) ; restoreScannerState ( SCANNER_STATE_PROLOG ) ; return true ; } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG , XMLMessages . P22_NOT_RECOGNIZED ) ; } } } else { fDispatcher = new ContentDispatcher ( ) ; restoreScannerState ( SCANNER_STATE_ROOT_ELEMENT ) ; return true ; } } else { if ( fEntityReader . lookingAtSpace ( true ) ) { fEntityReader . skipPastSpaces ( ) ; } else if ( ! fEntityReader . lookingAtValidChar ( false ) ) { int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { if ( invChar >= 0 ) { String arg = Integer . toHexString ( invChar ) ; reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_PROLOG , XMLMessages . P22_INVALID_CHARACTER , arg ) ; } } } else { reportFatalXMLError ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG , XMLMessages . P22_NOT_RECOGNIZED ) ; fEntityReader . lookingAtValidChar ( true ) ; } } fDispatcher = new PrologDispatcher ( ) ; restoreScannerState ( SCANNER_STATE_PROLOG ) ; return true ; } public void endOfInput ( int entityName , boolean moreToFollow ) throws Exception { switch ( fScannerState ) { case SCANNER_STATE_XML_DECL : case SCANNER_STATE_START_OF_MARKUP : case SCANNER_STATE_DOCTYPE : break ; case SCANNER_STATE_COMMENT : if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_COMMENT_UNTERMINATED , XMLMessages . P15_UNTERMINATED ) ; } else { reportFatalXMLError ( XMLMessages . MSG_COMMENT_NOT_IN_ONE_ENTITY , XMLMessages . P78_NOT_WELLFORMED ) ; } break ; case SCANNER_STATE_PI : if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_PI_UNTERMINATED , XMLMessages . P16_UNTERMINATED ) ; } else { reportFatalXMLError ( XMLMessages . MSG_PI_NOT_IN_ONE_ENTITY , XMLMessages . P78_NOT_WELLFORMED ) ; } break ; default : throw new RuntimeException ( "FWK001 1] ScannerState=" + fScannerState + "\n" + "1\t" + fScannerState ) ; } if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_ROOT_ELEMENT_REQUIRED , XMLMessages . P1_ELEMENT_REQUIRED ) ; fDispatcher = new EndOfInputDispatcher ( ) ; setScannerState ( SCANNER_STATE_END_OF_INPUT ) ; } } } final class PrologDispatcher implements ScannerDispatcher { public boolean dispatch ( boolean keepgoing ) throws Exception { do { if ( fEntityReader . lookingAtChar ( '<' , true ) ) { fScannerMarkupDepth ++ ; setScannerState ( SCANNER_STATE_START_OF_MARKUP ) ; if ( fEntityReader . lookingAtChar ( '?' , true ) ) { int piTarget = fEntityReader . scanName ( ' ' ) ; if ( piTarget == - 1 ) { abortMarkup ( XMLMessages . MSG_PITARGET_REQUIRED , XMLMessages . P16_PITARGET_REQUIRED ) ; } else if ( "xml" . equals ( fStringPool . toString ( piTarget ) ) ) { if ( fEntityReader . lookingAtSpace ( true ) ) { abortMarkup ( XMLMessages . MSG_XMLDECL_MUST_BE_FIRST , XMLMessages . P22_XMLDECL_MUST_BE_FIRST ) ; } else { abortMarkup ( XMLMessages . MSG_RESERVED_PITARGET , XMLMessages . P17_RESERVED_PITARGET ) ; } } else { scanPI ( piTarget ) ; } } else if ( fEntityReader . lookingAtChar ( '!' , true ) ) { if ( fEntityReader . lookingAtChar ( '-' , true ) ) { if ( fEntityReader . lookingAtChar ( '-' , true ) ) { scanComment ( ) ; } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG , XMLMessages . P22_NOT_RECOGNIZED ) ; } } else { if ( ! fSeenDoctypeDecl && fEntityReader . skippedString ( doctype_string ) ) { setScannerState ( SCANNER_STATE_DOCTYPE ) ; fSeenDoctypeDecl = true ; scanDoctypeDecl ( fStandalone ) ; fScannerMarkupDepth -- ; } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG , XMLMessages . P22_NOT_RECOGNIZED ) ; } } } else { fDispatcher = new ContentDispatcher ( ) ; restoreScannerState ( SCANNER_STATE_ROOT_ELEMENT ) ; return true ; } restoreScannerState ( SCANNER_STATE_PROLOG ) ; } else if ( fEntityReader . lookingAtSpace ( true ) ) { fEntityReader . skipPastSpaces ( ) ; } else if ( ! fEntityReader . lookingAtValidChar ( false ) ) { int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { if ( invChar >= 0 ) { String arg = Integer . toHexString ( invChar ) ; reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_PROLOG , XMLMessages . P22_INVALID_CHARACTER , arg ) ; } } } else { reportFatalXMLError ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG , XMLMessages . P22_NOT_RECOGNIZED ) ; fEntityReader . lookingAtValidChar ( true ) ; } } while ( fScannerState != SCANNER_STATE_END_OF_INPUT && keepgoing ) ; return true ; } public void endOfInput ( int entityName , boolean moreToFollow ) throws Exception { switch ( fScannerState ) { case SCANNER_STATE_PROLOG : case SCANNER_STATE_START_OF_MARKUP : case SCANNER_STATE_DOCTYPE : break ; case SCANNER_STATE_COMMENT : if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_COMMENT_UNTERMINATED , XMLMessages . P15_UNTERMINATED ) ; } else { reportFatalXMLError ( XMLMessages . MSG_COMMENT_NOT_IN_ONE_ENTITY , XMLMessages . P78_NOT_WELLFORMED ) ; } break ; case SCANNER_STATE_PI : if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_PI_UNTERMINATED , XMLMessages . P16_UNTERMINATED ) ; } else { reportFatalXMLError ( XMLMessages . MSG_PI_NOT_IN_ONE_ENTITY , XMLMessages . P78_NOT_WELLFORMED ) ; } break ; default : throw new RuntimeException ( "FWK001 2] ScannerState=" + fScannerState + "\n" + "2\t" + fScannerState ) ; } if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_ROOT_ELEMENT_REQUIRED , XMLMessages . P1_ELEMENT_REQUIRED ) ; fDispatcher = new EndOfInputDispatcher ( ) ; setScannerState ( SCANNER_STATE_END_OF_INPUT ) ; } } } int fCurrentElementType = - 1 ; public int getCurrentElementType ( ) { return fCurrentElementType ; } final class ContentDispatcher implements ScannerDispatcher { private int fContentReader = - 1 ; private int fElementDepth = 0 ; private int [ ] fElementTypeStack = new int [ 8 ] ; void popElementType ( ) { if ( fElementDepth -- == 0 ) { throw new RuntimeException ( "FWK002 popElementType: fElementDepth-- == 0." ) ; } if ( fElementDepth == 0 ) { fCurrentElementType = - 1 ; } else { fCurrentElementType = fElementTypeStack [ fElementDepth - 1 ] ; } } public boolean dispatch ( boolean keepgoing ) throws Exception { do { switch ( fScannerState ) { case SCANNER_STATE_ROOT_ELEMENT : { scanElementType ( fEntityReader , '>' , fElementQName ) ; if ( fElementQName . rawname != - 1 ) { fContentReader = fReaderId ; fSeenRootElement = true ; if ( fEntityReader . lookingAtChar ( '>' , true ) ) { fEventHandler . callStartElement ( fElementQName ) ; fScannerMarkupDepth -- ; if ( fElementDepth == fElementTypeStack . length ) { int [ ] newStack = new int [ fElementDepth * 2 ] ; System . arraycopy ( fElementTypeStack , 0 , newStack , 0 , fElementDepth ) ; fElementTypeStack = newStack ; } fCurrentElementType = fElementQName . rawname ; fElementTypeStack [ fElementDepth ] = fElementQName . rawname ; fElementDepth ++ ; restoreScannerState ( SCANNER_STATE_CONTENT ) ; } else if ( scanElement ( fElementQName ) ) { if ( fElementDepth == fElementTypeStack . length ) { int [ ] newStack = new int [ fElementDepth * 2 ] ; System . arraycopy ( fElementTypeStack , 0 , newStack , 0 , fElementDepth ) ; fElementTypeStack = newStack ; } fCurrentElementType = fElementQName . rawname ; fElementTypeStack [ fElementDepth ] = fElementQName . rawname ; fElementDepth ++ ; restoreScannerState ( SCANNER_STATE_CONTENT ) ; } else { fDispatcher = new TrailingMiscDispatcher ( ) ; restoreScannerState ( SCANNER_STATE_TRAILING_MISC ) ; return true ; } } else { reportFatalXMLError ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_PROLOG , XMLMessages . P22_NOT_RECOGNIZED ) ; fDispatcher = new PrologDispatcher ( ) ; restoreScannerState ( SCANNER_STATE_PROLOG ) ; return true ; } break ; } case SCANNER_STATE_START_OF_MARKUP : if ( fEntityReader . lookingAtChar ( '?' , true ) ) { int piTarget = fEntityReader . scanName ( ' ' ) ; if ( piTarget == - 1 ) { abortMarkup ( XMLMessages . MSG_PITARGET_REQUIRED , XMLMessages . P16_PITARGET_REQUIRED ) ; } else if ( "xml" . equals ( fStringPool . toString ( piTarget ) ) ) { if ( fEntityReader . lookingAtSpace ( true ) ) { if ( fParseTextDecl ) { scanXMLDeclOrTextDecl ( true ) ; fParseTextDecl = false ; } else { abortMarkup ( XMLMessages . MSG_TEXTDECL_MUST_BE_FIRST , XMLMessages . P30_TEXTDECL_MUST_BE_FIRST ) ; } } else { abortMarkup ( XMLMessages . MSG_RESERVED_PITARGET , XMLMessages . P17_RESERVED_PITARGET ) ; } } else { scanPI ( piTarget ) ; } restoreScannerState ( SCANNER_STATE_CONTENT ) ; } else if ( fEntityReader . lookingAtChar ( '!' , true ) ) { if ( fEntityReader . lookingAtChar ( '-' , true ) ) { if ( fEntityReader . lookingAtChar ( '-' , true ) ) { scanComment ( ) ; } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT , XMLMessages . P43_NOT_RECOGNIZED ) ; } } else { if ( fEntityReader . skippedString ( cdata_string ) ) { fEntityReader . setInCDSect ( true ) ; fEventHandler . callStartCDATA ( ) ; } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT , XMLMessages . P43_NOT_RECOGNIZED ) ; } } } else { if ( fEntityReader . lookingAtChar ( '/' , true ) ) { if ( ! scanExpectedElementType ( fEntityReader , '>' , fCurrentElementType ) ) { abortMarkup ( XMLMessages . MSG_ETAG_REQUIRED , XMLMessages . P39_UNTERMINATED , fCurrentElementType ) ; } else { if ( ! fEntityReader . lookingAtChar ( '>' , true ) ) { fEntityReader . skipPastSpaces ( ) ; if ( ! fEntityReader . lookingAtChar ( '>' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_ETAG_UNTERMINATED , XMLMessages . P42_UNTERMINATED , fCurrentElementType ) ; } } fScannerMarkupDepth -- ; fEventHandler . callEndElement ( fReaderId ) ; if ( fElementDepth -- == 0 ) { throw new RuntimeException ( "FWK002 popElementType: fElementDepth-- == 0." ) ; } if ( fElementDepth == 0 ) { fCurrentElementType = - 1 ; fDispatcher = new TrailingMiscDispatcher ( ) ; restoreScannerState ( SCANNER_STATE_TRAILING_MISC ) ; return true ; } else { fCurrentElementType = fElementTypeStack [ fElementDepth - 1 ] ; } } } else { scanElementType ( fEntityReader , '>' , fElementQName ) ; if ( fElementQName . rawname != - 1 ) { if ( fEntityReader . lookingAtChar ( '>' , true ) ) { fEventHandler . callStartElement ( fElementQName ) ; fScannerMarkupDepth -- ; if ( fElementDepth == fElementTypeStack . length ) { int [ ] newStack = new int [ fElementDepth * 2 ] ; System . arraycopy ( fElementTypeStack , 0 , newStack , 0 , fElementDepth ) ; fElementTypeStack = newStack ; } fCurrentElementType = fElementQName . rawname ; fElementTypeStack [ fElementDepth ] = fElementQName . rawname ; fElementDepth ++ ; } else { if ( scanElement ( fElementQName ) ) { if ( fElementDepth == fElementTypeStack . length ) { int [ ] newStack = new int [ fElementDepth * 2 ] ; System . arraycopy ( fElementTypeStack , 0 , newStack , 0 , fElementDepth ) ; fElementTypeStack = newStack ; } fCurrentElementType = fElementQName . rawname ; fElementTypeStack [ fElementDepth ] = fElementQName . rawname ; fElementDepth ++ ; } } } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT , XMLMessages . P43_NOT_RECOGNIZED ) ; } } } restoreScannerState ( SCANNER_STATE_CONTENT ) ; break ; case SCANNER_STATE_CONTENT : if ( fParseTextDecl && fEntityReader . lookingAtChar ( '<' , true ) ) { fScannerMarkupDepth ++ ; setScannerState ( SCANNER_STATE_START_OF_MARKUP ) ; continue ; } fCurrentElementQName . setValues ( - 1 , - 1 , fCurrentElementType ) ; switch ( fEntityReader . scanContent ( fCurrentElementQName ) ) { case XMLEntityHandler . CONTENT_RESULT_START_OF_PI : fScannerMarkupDepth ++ ; int piTarget = fEntityReader . scanName ( ' ' ) ; if ( piTarget == - 1 ) { abortMarkup ( XMLMessages . MSG_PITARGET_REQUIRED , XMLMessages . P16_PITARGET_REQUIRED ) ; } else if ( "xml" . equals ( fStringPool . toString ( piTarget ) ) ) { if ( fEntityReader . lookingAtSpace ( true ) ) { if ( fReaderId == fContentReader ) { abortMarkup ( XMLMessages . MSG_XMLDECL_MUST_BE_FIRST , XMLMessages . P22_XMLDECL_MUST_BE_FIRST ) ; } else { abortMarkup ( XMLMessages . MSG_TEXTDECL_MUST_BE_FIRST , XMLMessages . P30_TEXTDECL_MUST_BE_FIRST ) ; } } else { abortMarkup ( XMLMessages . MSG_RESERVED_PITARGET , XMLMessages . P17_RESERVED_PITARGET ) ; } } else { scanPI ( piTarget ) ; } break ; case XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT : fScannerMarkupDepth ++ ; fParseTextDecl = false ; scanComment ( ) ; break ; case XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT : fScannerMarkupDepth ++ ; fParseTextDecl = false ; fEntityReader . setInCDSect ( true ) ; fEventHandler . callStartCDATA ( ) ; break ; case XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG : fScannerMarkupDepth ++ ; fParseTextDecl = false ; if ( ! scanExpectedElementType ( fEntityReader , '>' , fCurrentElementType ) ) { abortMarkup ( XMLMessages . MSG_ETAG_REQUIRED , XMLMessages . P39_UNTERMINATED , fCurrentElementType ) ; } else { if ( ! fEntityReader . lookingAtChar ( '>' , true ) ) { fEntityReader . skipPastSpaces ( ) ; if ( ! fEntityReader . lookingAtChar ( '>' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_ETAG_UNTERMINATED , XMLMessages . P42_UNTERMINATED , fCurrentElementType ) ; } } fScannerMarkupDepth -- ; fEventHandler . callEndElement ( fReaderId ) ; if ( fElementDepth -- == 0 ) { throw new RuntimeException ( "FWK002 popElementType: fElementDepth-- == 0." ) ; } if ( fElementDepth == 0 ) { fCurrentElementType = - 1 ; fDispatcher = new TrailingMiscDispatcher ( ) ; restoreScannerState ( SCANNER_STATE_TRAILING_MISC ) ; return true ; } else { fCurrentElementType = fElementTypeStack [ fElementDepth - 1 ] ; } } restoreScannerState ( SCANNER_STATE_CONTENT ) ; break ; case XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT : { fScannerMarkupDepth ++ ; fParseTextDecl = false ; scanElementType ( fEntityReader , '>' , fElementQName ) ; if ( fElementQName . rawname != - 1 ) { if ( fEntityReader . lookingAtChar ( '>' , true ) ) { fEventHandler . callStartElement ( fElementQName ) ; fScannerMarkupDepth -- ; if ( fElementDepth == fElementTypeStack . length ) { int [ ] newStack = new int [ fElementDepth * 2 ] ; System . arraycopy ( fElementTypeStack , 0 , newStack , 0 , fElementDepth ) ; fElementTypeStack = newStack ; } fCurrentElementType = fElementQName . rawname ; fElementTypeStack [ fElementDepth ] = fElementQName . rawname ; fElementDepth ++ ; } else { if ( scanElement ( fElementQName ) ) { if ( fElementDepth == fElementTypeStack . length ) { int [ ] newStack = new int [ fElementDepth * 2 ] ; System . arraycopy ( fElementTypeStack , 0 , newStack , 0 , fElementDepth ) ; fElementTypeStack = newStack ; } fCurrentElementType = fElementQName . rawname ; fElementTypeStack [ fElementDepth ] = fElementQName . rawname ; fElementDepth ++ ; } } } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT , XMLMessages . P43_NOT_RECOGNIZED ) ; } if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) fScannerState = SCANNER_STATE_CONTENT ; break ; } case XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG : { fParseTextDecl = false ; fEventHandler . callEndElement ( fReaderId ) ; if ( fElementDepth -- == 0 ) { throw new RuntimeException ( "FWK002 popElementType: fElementDepth-- == 0." ) ; } if ( fElementDepth == 0 ) { fCurrentElementType = - 1 ; if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { fDispatcher = new TrailingMiscDispatcher ( ) ; fScannerState = SCANNER_STATE_TRAILING_MISC ; } return true ; } else { fCurrentElementType = fElementTypeStack [ fElementDepth - 1 ] ; } if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) fScannerState = SCANNER_STATE_CONTENT ; break ; } case XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF : fParseTextDecl = false ; setScannerState ( SCANNER_STATE_REFERENCE ) ; int num = scanCharRef ( ) ; if ( num != - 1 ) fEventHandler . callCharacters ( num ) ; restoreScannerState ( SCANNER_STATE_CONTENT ) ; break ; case XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT : case XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF : fParseTextDecl = false ; setScannerState ( SCANNER_STATE_REFERENCE ) ; int nameOffset = fEntityReader . currentOffset ( ) ; fEntityReader . skipPastName ( ';' ) ; int nameLength = fEntityReader . currentOffset ( ) - nameOffset ; if ( nameLength == 0 ) { reportFatalXMLError ( XMLMessages . MSG_NAME_REQUIRED_IN_REFERENCE , XMLMessages . P68_NAME_REQUIRED ) ; restoreScannerState ( SCANNER_STATE_CONTENT ) ; } else if ( ! fEntityReader . lookingAtChar ( ';' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_SEMICOLON_REQUIRED_IN_REFERENCE , XMLMessages . P68_SEMICOLON_REQUIRED , fEntityReader . addString ( nameOffset , nameLength ) ) ; restoreScannerState ( SCANNER_STATE_CONTENT ) ; } else { restoreScannerState ( SCANNER_STATE_CONTENT ) ; int entityName = fEntityReader . addSymbol ( nameOffset , nameLength ) ; fParseTextDecl = fEntityHandler . startReadingFromEntity ( entityName , fElementDepth , XMLEntityHandler . ENTITYREF_IN_CONTENT ) ; } break ; case XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT : fParseTextDecl = false ; if ( fEntityReader . getInCDSect ( ) ) { fEntityReader . setInCDSect ( false ) ; fEventHandler . callEndCDATA ( ) ; fScannerMarkupDepth -- ; } else { reportFatalXMLError ( XMLMessages . MSG_CDEND_IN_CONTENT , XMLMessages . P14_INVALID ) ; } restoreScannerState ( SCANNER_STATE_CONTENT ) ; break ; case XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR : fParseTextDecl = false ; if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { if ( ! fEntityReader . lookingAtValidChar ( false ) ) { int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { if ( invChar >= 0 ) { if ( fEntityReader . getInCDSect ( ) ) { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_CDSECT , XMLMessages . P20_INVALID_CHARACTER , Integer . toHexString ( invChar ) ) ; } else { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_CONTENT , XMLMessages . P43_INVALID_CHARACTER , Integer . toHexString ( invChar ) ) ; } } } } restoreScannerState ( SCANNER_STATE_CONTENT ) ; } break ; case XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED : fParseTextDecl = false ; abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_CONTENT , XMLMessages . P43_NOT_RECOGNIZED ) ; break ; case XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT : fScannerMarkupDepth ++ ; fParseTextDecl = false ; fScannerState = SCANNER_STATE_START_OF_MARKUP ; break ; default : throw new RuntimeException ( "FWK001 3] ScannerState=" + fScannerState + "\n" + "3\t" + fScannerState ) ; } break ; default : throw new RuntimeException ( "FWK001 4] ScannerState=" + fScannerState + "\n" + "4\t" + fScannerState ) ; } } while ( fScannerState != SCANNER_STATE_END_OF_INPUT && keepgoing ) ; return true ; } public void endOfInput ( int entityName , boolean moreToFollow ) throws Exception { switch ( fScannerState ) { case SCANNER_STATE_ROOT_ELEMENT : case SCANNER_STATE_START_OF_MARKUP : break ; case SCANNER_STATE_CONTENT : if ( fEntityReader . getInCDSect ( ) ) { reportFatalXMLError ( XMLMessages . MSG_CDSECT_UNTERMINATED , XMLMessages . P18_UNTERMINATED ) ; } break ; case SCANNER_STATE_ATTRIBUTE_LIST : if ( ! moreToFollow ) { } else { } break ; case SCANNER_STATE_ATTRIBUTE_NAME : if ( ! moreToFollow ) { } else { } break ; case SCANNER_STATE_ATTRIBUTE_VALUE : if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_UNTERMINATED , XMLMessages . P10_UNTERMINATED , fAttValueElementType , fAttValueAttrName ) ; } else if ( fReaderId == fAttValueReader ) { } else { fEntityReader . append ( fLiteralData , fAttValueMark , fAttValueOffset - fAttValueMark ) ; } break ; case SCANNER_STATE_COMMENT : if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_COMMENT_UNTERMINATED , XMLMessages . P15_UNTERMINATED ) ; } else { reportFatalXMLError ( XMLMessages . MSG_COMMENT_NOT_IN_ONE_ENTITY , XMLMessages . P78_NOT_WELLFORMED ) ; } break ; case SCANNER_STATE_PI : if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_PI_UNTERMINATED , XMLMessages . P16_UNTERMINATED ) ; } else { reportFatalXMLError ( XMLMessages . MSG_PI_NOT_IN_ONE_ENTITY , XMLMessages . P78_NOT_WELLFORMED ) ; } break ; case SCANNER_STATE_REFERENCE : if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_REFERENCE_UNTERMINATED , XMLMessages . P67_UNTERMINATED ) ; } else { reportFatalXMLError ( XMLMessages . MSG_REFERENCE_NOT_IN_ONE_ENTITY , XMLMessages . P78_NOT_WELLFORMED ) ; } break ; default : throw new RuntimeException ( "FWK001 5] ScannerState=" + fScannerState + "\n" + "5\t" + fScannerState ) ; } if ( ! moreToFollow ) { if ( fElementDepth > 0 ) reportFatalXMLError ( XMLMessages . MSG_ETAG_REQUIRED , XMLMessages . P39_UNTERMINATED , fCurrentElementType ) ; fDispatcher = new EndOfInputDispatcher ( ) ; setScannerState ( SCANNER_STATE_END_OF_INPUT ) ; } } } final class TrailingMiscDispatcher implements ScannerDispatcher { public boolean dispatch ( boolean keepgoing ) throws Exception { do { if ( fEntityReader . lookingAtChar ( '<' , true ) ) { fScannerMarkupDepth ++ ; setScannerState ( SCANNER_STATE_START_OF_MARKUP ) ; if ( fEntityReader . lookingAtChar ( '?' , true ) ) { int piTarget = fEntityReader . scanName ( ' ' ) ; if ( piTarget == - 1 ) { abortMarkup ( XMLMessages . MSG_PITARGET_REQUIRED , XMLMessages . P16_PITARGET_REQUIRED ) ; } else if ( "xml" . equals ( fStringPool . toString ( piTarget ) ) ) { if ( fEntityReader . lookingAtSpace ( true ) ) { abortMarkup ( XMLMessages . MSG_XMLDECL_MUST_BE_FIRST , XMLMessages . P22_XMLDECL_MUST_BE_FIRST ) ; } else { abortMarkup ( XMLMessages . MSG_RESERVED_PITARGET , XMLMessages . P17_RESERVED_PITARGET ) ; } } else { scanPI ( piTarget ) ; } } else if ( fEntityReader . lookingAtChar ( '!' , true ) ) { if ( fEntityReader . lookingAtChar ( '-' , true ) && fEntityReader . lookingAtChar ( '-' , true ) ) { scanComment ( ) ; } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_MISC , XMLMessages . P27_NOT_RECOGNIZED ) ; } } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_MISC , XMLMessages . P27_NOT_RECOGNIZED ) ; } restoreScannerState ( SCANNER_STATE_TRAILING_MISC ) ; } else if ( fEntityReader . lookingAtSpace ( true ) ) { fEntityReader . skipPastSpaces ( ) ; } else if ( ! fEntityReader . lookingAtValidChar ( false ) ) { int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { if ( invChar >= 0 ) { String arg = Integer . toHexString ( invChar ) ; reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_MISC , XMLMessages . P27_INVALID_CHARACTER , arg ) ; } } } else { reportFatalXMLError ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_MISC , XMLMessages . P27_NOT_RECOGNIZED ) ; fEntityReader . lookingAtValidChar ( true ) ; } } while ( fScannerState != SCANNER_STATE_END_OF_INPUT && keepgoing ) ; return true ; } public void endOfInput ( int entityName , boolean moreToFollow ) throws Exception { if ( moreToFollow ) throw new RuntimeException ( "FWK003 TrailingMiscDispatcher.endOfInput moreToFollow" ) ; switch ( fScannerState ) { case SCANNER_STATE_TRAILING_MISC : case SCANNER_STATE_START_OF_MARKUP : break ; case SCANNER_STATE_COMMENT : reportFatalXMLError ( XMLMessages . MSG_COMMENT_UNTERMINATED , XMLMessages . P15_UNTERMINATED ) ; break ; case SCANNER_STATE_PI : reportFatalXMLError ( XMLMessages . MSG_PI_UNTERMINATED , XMLMessages . P16_UNTERMINATED ) ; break ; default : throw new RuntimeException ( "FWK001 6] ScannerState=" + fScannerState + "\n" + "6\t" + fScannerState ) ; } fDispatcher = new EndOfInputDispatcher ( ) ; setScannerState ( SCANNER_STATE_END_OF_INPUT ) ; } } final class EndOfInputDispatcher implements ScannerDispatcher { public boolean dispatch ( boolean keepgoing ) throws Exception { if ( fScannerState != SCANNER_STATE_TERMINATED ) fEventHandler . callEndDocument ( ) ; setScannerState ( SCANNER_STATE_TERMINATED ) ; return false ; } public void endOfInput ( int entityName , boolean moreToFollow ) throws Exception { throw new RuntimeException ( "FWK001 7] ScannerState=" + fScannerState + "\n" + "7\t" + fScannerState ) ; } } void scanXMLDeclOrTextDecl ( boolean scanningTextDecl ) throws Exception { int version = - 1 ; int encoding = - 1 ; int standalone = - 1 ; final int XMLDECL_START = 0 ; final int XMLDECL_VERSION = 1 ; final int XMLDECL_ENCODING = 2 ; final int XMLDECL_STANDALONE = 3 ; final int XMLDECL_FINISHED = 4 ; int state = XMLDECL_START ; do { fEntityReader . skipPastSpaces ( ) ; int offset = fEntityReader . currentOffset ( ) ; if ( scanningTextDecl ) { if ( state == XMLDECL_START && fEntityReader . skippedString ( version_string ) ) { state = XMLDECL_VERSION ; } else if ( fEntityReader . skippedString ( encoding_string ) ) { state = XMLDECL_ENCODING ; } else { abortMarkup ( XMLMessages . MSG_ENCODINGDECL_REQUIRED , XMLMessages . P77_ENCODINGDECL_REQUIRED ) ; return ; } } else { if ( state == XMLDECL_START ) { if ( ! fEntityReader . skippedString ( version_string ) ) { abortMarkup ( XMLMessages . MSG_VERSIONINFO_REQUIRED , XMLMessages . P23_VERSIONINFO_REQUIRED ) ; return ; } state = XMLDECL_VERSION ; } else { if ( state == XMLDECL_VERSION ) { if ( fEntityReader . skippedString ( encoding_string ) ) state = XMLDECL_ENCODING ; else state = XMLDECL_STANDALONE ; } else state = XMLDECL_STANDALONE ; if ( state == XMLDECL_STANDALONE && ! fEntityReader . skippedString ( standalone_string ) ) break ; } } int length = fEntityReader . currentOffset ( ) - offset ; fEntityReader . skipPastSpaces ( ) ; if ( ! fEntityReader . lookingAtChar ( '=' , true ) ) { int majorCode = scanningTextDecl ? XMLMessages . MSG_EQ_REQUIRED_IN_TEXTDECL : XMLMessages . MSG_EQ_REQUIRED_IN_XMLDECL ; int minorCode = state == XMLDECL_VERSION ? XMLMessages . P24_EQ_REQUIRED : ( state == XMLDECL_ENCODING ? XMLMessages . P80_EQ_REQUIRED : XMLMessages . P32_EQ_REQUIRED ) ; abortMarkup ( majorCode , minorCode , fEntityReader . addString ( offset , length ) ) ; return ; } fEntityReader . skipPastSpaces ( ) ; int result = fEntityReader . scanStringLiteral ( ) ; switch ( result ) { case XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED : { int majorCode = scanningTextDecl ? XMLMessages . MSG_QUOTE_REQUIRED_IN_TEXTDECL : XMLMessages . MSG_QUOTE_REQUIRED_IN_XMLDECL ; int minorCode = state == XMLDECL_VERSION ? XMLMessages . P24_QUOTE_REQUIRED : ( state == XMLDECL_ENCODING ? XMLMessages . P80_QUOTE_REQUIRED : XMLMessages . P32_QUOTE_REQUIRED ) ; abortMarkup ( majorCode , minorCode , fEntityReader . addString ( offset , length ) ) ; return ; } case XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR : int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { if ( invChar >= 0 ) { int majorCode = scanningTextDecl ? XMLMessages . MSG_INVALID_CHAR_IN_TEXTDECL : XMLMessages . MSG_INVALID_CHAR_IN_XMLDECL ; int minorCode = state == XMLDECL_VERSION ? XMLMessages . P26_INVALID_CHARACTER : ( state == XMLDECL_ENCODING ? XMLMessages . P81_INVALID_CHARACTER : XMLMessages . P32_INVALID_CHARACTER ) ; reportFatalXMLError ( majorCode , minorCode , Integer . toHexString ( invChar ) ) ; } skipPastEndOfCurrentMarkup ( ) ; } return ; default : break ; } switch ( state ) { case XMLDECL_VERSION : version = result ; String versionString = fStringPool . toString ( version ) ; if ( ! "1.0" . equals ( versionString ) ) { if ( ! validVersionNum ( versionString ) ) { abortMarkup ( XMLMessages . MSG_VERSIONINFO_INVALID , XMLMessages . P26_INVALID_VALUE , versionString ) ; return ; } Object [ ] args = { versionString } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_VERSION_NOT_SUPPORTED , XMLMessages . P26_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( ! fEntityReader . lookingAtSpace ( true ) ) { if ( scanningTextDecl ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_IN_TEXTDECL , XMLMessages . P80_WHITESPACE_REQUIRED ) ; return ; } state = XMLDECL_FINISHED ; } break ; case XMLDECL_ENCODING : encoding = result ; String encodingString = fStringPool . toString ( encoding ) ; if ( ! validEncName ( encodingString ) ) { abortMarkup ( XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , encodingString ) ; return ; } if ( ! fEntityReader . lookingAtSpace ( true ) ) { state = XMLDECL_FINISHED ; } else if ( scanningTextDecl ) { fEntityReader . skipPastSpaces ( ) ; state = XMLDECL_FINISHED ; } break ; case XMLDECL_STANDALONE : standalone = result ; String standaloneString = fStringPool . toString ( standalone ) ; boolean yes = "yes" . equals ( standaloneString ) ; if ( ! yes && ! "no" . equals ( standaloneString ) ) { abortMarkup ( XMLMessages . MSG_SDDECL_INVALID , XMLMessages . P32_INVALID_VALUE , standaloneString ) ; return ; } fStandalone = yes ; fEntityReader . skipPastSpaces ( ) ; state = XMLDECL_FINISHED ; break ; } } while ( state != XMLDECL_FINISHED ) ; if ( ! fEntityReader . lookingAtChar ( '?' , true ) || ! fEntityReader . lookingAtChar ( '>' , true ) ) { int majorCode , minorCode ; if ( scanningTextDecl ) { majorCode = XMLMessages . MSG_TEXTDECL_UNTERMINATED ; minorCode = XMLMessages . P77_UNTERMINATED ; } else { majorCode = XMLMessages . MSG_XMLDECL_UNTERMINATED ; minorCode = XMLMessages . P23_UNTERMINATED ; } abortMarkup ( majorCode , minorCode ) ; return ; } fScannerMarkupDepth -- ; if ( scanningTextDecl ) { fEventHandler . callTextDecl ( version , encoding ) ; } else { fEventHandler . callXMLDecl ( version , encoding , standalone ) ; if ( fStandalone ) { fEventHandler . callStandaloneIsYes ( ) ; } } } boolean scanElement ( QName element ) throws Exception { boolean greater = false ; boolean slash = false ; if ( greater = fEntityReader . lookingAtChar ( '>' , true ) ) { } else if ( fEntityReader . lookingAtSpace ( true ) ) { int previousState = setScannerState ( SCANNER_STATE_ATTRIBUTE_LIST ) ; while ( true ) { fEntityReader . skipPastSpaces ( ) ; if ( ( greater = fEntityReader . lookingAtChar ( '>' , true ) ) || ( slash = fEntityReader . lookingAtChar ( '/' , true ) ) ) break ; setScannerState ( SCANNER_STATE_ATTRIBUTE_NAME ) ; scanAttributeName ( fEntityReader , element , fAttributeQName ) ; if ( fAttributeQName . rawname == - 1 ) { break ; } fEntityReader . skipPastSpaces ( ) ; if ( ! fEntityReader . lookingAtChar ( '=' , true ) ) { if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { abortMarkup ( XMLMessages . MSG_EQ_REQUIRED_IN_ATTRIBUTE , XMLMessages . P41_EQ_REQUIRED , element . rawname , fAttributeQName . rawname ) ; restoreScannerState ( previousState ) ; } return false ; } fEntityReader . skipPastSpaces ( ) ; int result = scanAttValue ( element , fAttributeQName , false ) ; if ( result == RESULT_FAILURE ) { if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { skipPastEndOfCurrentMarkup ( ) ; restoreScannerState ( previousState ) ; } return false ; } else if ( result == RESULT_DUPLICATE_ATTR ) { reportFatalXMLError ( XMLMessages . MSG_ATTRIBUTE_NOT_UNIQUE , XMLMessages . WFC_UNIQUE_ATT_SPEC , element . rawname , fAttributeQName . rawname ) ; } if ( fEventHandler . attribute ( element , fAttributeQName , result ) ) { reportFatalXMLError ( XMLMessages . MSG_ATTRIBUTE_NOT_UNIQUE , XMLMessages . WFC_UNIQUE_ATT_SPEC , element . rawname , fAttributeQName . rawname ) ; } restoreScannerState ( SCANNER_STATE_ATTRIBUTE_LIST ) ; if ( ! fEntityReader . lookingAtSpace ( true ) ) { if ( ! ( greater = fEntityReader . lookingAtChar ( '>' , true ) ) ) slash = fEntityReader . lookingAtChar ( '/' , true ) ; break ; } } restoreScannerState ( previousState ) ; } else { slash = fEntityReader . lookingAtChar ( '/' , true ) ; } if ( ! greater && ( ! slash || ! fEntityReader . lookingAtChar ( '>' , true ) ) ) { if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { abortMarkup ( XMLMessages . MSG_ELEMENT_UNTERMINATED , XMLMessages . P40_UNTERMINATED , element . rawname ) ; } return false ; } fEventHandler . callStartElement ( element ) ; fScannerMarkupDepth -- ; if ( slash ) { fEventHandler . callEndElement ( fReaderId ) ; return false ; } else { return true ; } } int scanCharRef ( ) throws Exception { int valueOffset = fEntityReader . currentOffset ( ) ; boolean hex = fEntityReader . lookingAtChar ( 'x' , true ) ; int num = fEntityReader . scanCharRef ( hex ) ; if ( num < 0 ) { switch ( num ) { case XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED : reportFatalXMLError ( XMLMessages . MSG_SEMICOLON_REQUIRED_IN_CHARREF , XMLMessages . P66_SEMICOLON_REQUIRED ) ; return - 1 ; case XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR : int majorCode = hex ? XMLMessages . MSG_HEXDIGIT_REQUIRED_IN_CHARREF : XMLMessages . MSG_DIGIT_REQUIRED_IN_CHARREF ; int minorCode = hex ? XMLMessages . P66_HEXDIGIT_REQUIRED : XMLMessages . P66_DIGIT_REQUIRED ; reportFatalXMLError ( majorCode , minorCode ) ; return - 1 ; case XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE : num = 0x110000 ; break ; } } if ( num < 0x20 ) { if ( num == 0x09 || num == 0x0A || num == 0x0D ) { return num ; } } else if ( num <= 0xD7FF || ( num >= 0xE000 && ( num <= 0xFFFD || ( num >= 0x10000 && num <= 0x10FFFF ) ) ) ) { return num ; } int valueLength = fEntityReader . currentOffset ( ) - valueOffset ; reportFatalXMLError ( XMLMessages . MSG_INVALID_CHARREF , XMLMessages . WFC_LEGAL_CHARACTER , fEntityReader . addString ( valueOffset , valueLength ) ) ; return - 1 ; } void scanComment ( ) throws Exception { int commentOffset = fEntityReader . currentOffset ( ) ; boolean sawDashDash = false ; int previousState = setScannerState ( SCANNER_STATE_COMMENT ) ; while ( fScannerState == SCANNER_STATE_COMMENT ) { if ( fEntityReader . lookingAtChar ( '-' , false ) ) { int nextEndOffset = fEntityReader . currentOffset ( ) ; int endOffset = 0 ; fEntityReader . lookingAtChar ( '-' , true ) ; int offset = fEntityReader . currentOffset ( ) ; int count = 1 ; while ( fEntityReader . lookingAtChar ( '-' , true ) ) { count ++ ; endOffset = nextEndOffset ; nextEndOffset = offset ; offset = fEntityReader . currentOffset ( ) ; } if ( count > 1 ) { if ( fEntityReader . lookingAtChar ( '>' , true ) ) { if ( ! sawDashDash && count > 2 ) { reportFatalXMLError ( XMLMessages . MSG_DASH_DASH_IN_COMMENT , XMLMessages . P15_DASH_DASH ) ; sawDashDash = true ; } fScannerMarkupDepth -- ; fEventHandler . callComment ( fEntityReader . addString ( commentOffset , endOffset - commentOffset ) ) ; restoreScannerState ( previousState ) ; return ; } else if ( ! sawDashDash ) { reportFatalXMLError ( XMLMessages . MSG_DASH_DASH_IN_COMMENT , XMLMessages . P15_DASH_DASH ) ; sawDashDash = true ; } } } else { if ( ! fEntityReader . lookingAtValidChar ( true ) ) { int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { if ( invChar >= 0 ) { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_COMMENT , XMLMessages . P15_INVALID_CHARACTER , Integer . toHexString ( invChar ) ) ; } } } } } restoreScannerState ( previousState ) ; } void scanPI ( int piTarget ) throws Exception { String piTargetString = fStringPool . toString ( piTarget ) ; if ( piTargetString . length ( ) == 3 && ( piTargetString . charAt ( 0 ) == 'X' || piTargetString . charAt ( 0 ) == 'x' ) && ( piTargetString . charAt ( 1 ) == 'M' || piTargetString . charAt ( 1 ) == 'm' ) && ( piTargetString . charAt ( 2 ) == 'L' || piTargetString . charAt ( 2 ) == 'l' ) ) { abortMarkup ( XMLMessages . MSG_RESERVED_PITARGET , XMLMessages . P17_RESERVED_PITARGET ) ; return ; } int prevState = setScannerState ( SCANNER_STATE_PI ) ; int piDataOffset = - 1 ; int piDataLength = - 1 ; if ( ! fEntityReader . lookingAtSpace ( true ) ) { if ( ! fEntityReader . lookingAtChar ( '?' , true ) || ! fEntityReader . lookingAtChar ( '>' , true ) ) { if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_IN_PI , XMLMessages . P16_WHITESPACE_REQUIRED ) ; restoreScannerState ( prevState ) ; } return ; } piDataLength = 0 ; } else { fEntityReader . skipPastSpaces ( ) ; piDataOffset = fEntityReader . currentOffset ( ) ; while ( fScannerState == SCANNER_STATE_PI ) { while ( fEntityReader . lookingAtChar ( '?' , false ) ) { int offset = fEntityReader . currentOffset ( ) ; fEntityReader . lookingAtChar ( '?' , true ) ; if ( fEntityReader . lookingAtChar ( '>' , true ) ) { piDataLength = offset - piDataOffset ; break ; } } if ( piDataLength >= 0 ) break ; if ( ! fEntityReader . lookingAtValidChar ( true ) ) { int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { if ( invChar >= 0 ) { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_PI , XMLMessages . P16_INVALID_CHARACTER , Integer . toHexString ( invChar ) ) ; } skipPastEndOfCurrentMarkup ( ) ; restoreScannerState ( prevState ) ; } return ; } } } fScannerMarkupDepth -- ; restoreScannerState ( prevState ) ; int piData = piDataLength == 0 ? StringPool . EMPTY_STRING : fEntityReader . addString ( piDataOffset , piDataLength ) ; fEventHandler . callProcessingInstruction ( piTarget , piData ) ; } public void setNamespacesEnabled ( boolean enabled ) { fNamespacesEnabled = enabled ; } public boolean getNamespacesEnabled ( ) { return fNamespacesEnabled ; } public void setValidationEnabled ( boolean enabled ) { fValidationEnabled = enabled ; if ( fDTDScanner != null ) { fDTDScanner . setValidationEnabled ( enabled ) ; } } public boolean getValidationEnabled ( ) { return fValidationEnabled ; } private void scanElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( ! fNamespacesEnabled ) { element . clear ( ) ; element . localpart = entityReader . scanName ( fastchar ) ; element . rawname = element . localpart ; } else { entityReader . scanQName ( fastchar , element ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } fEventHandler . element ( element ) ; } private boolean scanExpectedElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , int elementType ) throws Exception { if ( fCurrentElementCharArrayRange == null ) { fCurrentElementCharArrayRange = fStringPool . createCharArrayRange ( ) ; } fStringPool . getCharArrayRange ( elementType , fCurrentElementCharArrayRange ) ; return entityReader . scanExpectedName ( fastchar , fCurrentElementCharArrayRange ) ; } private void scanAttributeName ( XMLEntityHandler . EntityReader entityReader , QName element , QName attribute ) throws Exception { if ( ! fNamespacesEnabled ) { attribute . clear ( ) ; attribute . localpart = entityReader . scanName ( '=' ) ; attribute . rawname = attribute . localpart ; } else { entityReader . scanQName ( '=' , attribute ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } private void scanDoctypeDecl ( boolean standalone ) throws Exception { fScanningDTD = true ; fSeenDoctypeDecl = true ; if ( fDTDScanner == null ) { fDTDScanner = new XMLDTDScanner ( fStringPool , fErrorReporter , fEntityHandler , new ChunkyCharArray ( fStringPool ) ) ; fDTDScanner . setValidationEnabled ( fValidationEnabled ) ; fDTDScanner . setNamespacesEnabled ( fNamespacesEnabled ) ; } else { fDTDScanner . reset ( fStringPool , new ChunkyCharArray ( fStringPool ) ) ; } fDTDScanner . setDTDHandler ( fDTDHandler ) ; fDTDScanner . setGrammarResolver ( fGrammarResolver ) ; if ( fDTDScanner . scanDoctypeDecl ( ) ) { if ( fDTDScanner . getReadingExternalEntity ( ) ) { fDTDScanner . scanDecls ( true ) ; } } if ( fValidationEnabled ) { ( ( DefaultEntityHandler ) fEntityHandler ) . checkRequiredNotations ( ) ; } fScanningDTD = false ; } private int scanAttValue ( QName element , QName attribute ) throws Exception { int attValue = scanAttValue ( element , attribute , fValidationEnabled ) ; if ( attValue == - 1 ) { return XMLDocumentScanner . RESULT_FAILURE ; } return XMLDocumentScanner . RESULT_SUCCESS ; } private boolean validVersionNum ( String version ) { return XMLCharacterProperties . validVersionNum ( version ) ; } private boolean validEncName ( String encoding ) { return XMLCharacterProperties . validEncName ( encoding ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . range . * ; public class RangeExceptionImpl extends RangeException { public RangeExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . xerces . dom ; import org . w3c . dom . Node ; public interface DeferredNode extends Node { public int getNodeIndex ( ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ChildAndParentNode extends ChildNode { static final long serialVersionUID = 0 ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ChildAndParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ChildAndParentNode ( ) { } public Node cloneNode ( boolean deep ) { ChildAndParentNode newnode = ( ChildAndParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLBaseElementImpl extends HTMLElementImpl implements HTMLBaseElement { public String getHref ( ) { return getAttribute ( "href" ) ; } public void setHref ( String href ) { setAttribute ( "href" , href ) ; } public String getTarget ( ) { return getAttribute ( "target" ) ; } public void setTarget ( String target ) { setAttribute ( "target" , target ) ; } public HTMLBaseElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom . events ; import org . w3c . dom . DOMException ; public interface DocumentEvent { public Event createEvent ( String eventType ) throws DOMException ; } 	1
package org . apache . wml ; public interface WMLTableElement extends WMLElement { public void setTitle ( String newValue ) ; public String getTitle ( ) ; public void setAlign ( String newValue ) ; public String getAlign ( ) ; public void setColumns ( int newValue ) ; public int getColumns ( ) ; public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ParentNode extends NodeImpl { static final long serialVersionUID = 2815829867152120872L ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ParentNode ( ) { } public Node cloneNode ( boolean deep ) { ParentNode newnode = ( ParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLAccessElementImpl extends WMLElementImpl implements WMLAccessElement { public WMLAccessElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setDomain ( String newValue ) { setAttribute ( "domain" , newValue ) ; } public String getDomain ( ) { return getAttribute ( "domain" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setPath ( String newValue ) { setAttribute ( "path" , newValue ) ; } public String getPath ( ) { return getAttribute ( "path" ) ; } } 	0
package javax . xml . parsers ; public abstract class DocumentBuilderFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.DocumentBuilderFactory" ; private static String factory = "org.apache.xerces.jaxp.DocumentBuilderFactoryImpl" ; protected DocumentBuilderFactory ( ) { super ( ) ; } public static DocumentBuilderFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( DocumentBuilderFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"" + "javax.xml.parsers.DocumentBuilderFactory\"" ) ; } } public abstract DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . xerces . dom ; import java . util . Vector ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . utils . StringPool ; import org . w3c . dom . * ; public class DeferredDocumentImpl extends DocumentImpl implements DeferredNode { static final long serialVersionUID = 5186323580749626857L ; private static final boolean DEBUG_PRINT_REF_COUNTS = false ; private static final boolean DEBUG_PRINT_TABLES = false ; private static final boolean DEBUG_IDS = false ; protected static final int CHUNK_SHIFT = 11 ; protected static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; protected static final int CHUNK_MASK = CHUNK_SIZE - 1 ; protected static final int INITIAL_CHUNK_COUNT = ( 1 << ( 16 - CHUNK_SHIFT ) ) ; protected transient int fNodeCount = 0 ; protected transient int fNodeType [ ] [ ] ; protected transient int fNodeName [ ] [ ] ; protected transient int fNodeValue [ ] [ ] ; protected transient int fNodeParent [ ] [ ] ; protected transient int fNodeLastChild [ ] [ ] ; protected transient int fNodePrevSib [ ] [ ] ; protected transient int fNodeURI [ ] [ ] ; protected transient int fIdCount ; protected transient int fIdName [ ] ; protected transient int fIdElement [ ] ; protected transient StringPool fStringPool ; protected boolean fNamespacesEnabled = false ; public DeferredDocumentImpl ( StringPool stringPool ) { this ( stringPool , false ) ; } public DeferredDocumentImpl ( StringPool stringPool , boolean namespacesEnabled ) { this ( stringPool , namespacesEnabled , false ) ; } public DeferredDocumentImpl ( StringPool stringPool , boolean namespaces , boolean grammarAccess ) { super ( grammarAccess ) ; fStringPool = stringPool ; needsSyncData ( true ) ; needsSyncChildren ( true ) ; fNamespacesEnabled = namespaces ; } boolean getNamespacesEnabled ( ) { return fNamespacesEnabled ; } public int createDocument ( ) { int nodeIndex = createNode ( Node . DOCUMENT_NODE ) ; return nodeIndex ; } public int createDocumentType ( int rootElementNameIndex , int publicId , int systemId ) { int nodeIndex = createNode ( Node . DOCUMENT_TYPE_NODE ) ; int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; int extraDataIndex = createNode ( ( short ) 0 ) ; int echunk = extraDataIndex > > CHUNK_SHIFT ; int eindex = extraDataIndex & CHUNK_MASK ; setChunkIndex ( fNodeName , rootElementNameIndex , chunk , index ) ; setChunkIndex ( fNodeValue , extraDataIndex , chunk , index ) ; setChunkIndex ( fNodeName , publicId , echunk , eindex ) ; setChunkIndex ( fNodeValue , systemId , echunk , eindex ) ; return nodeIndex ; } public void setInternalSubset ( int doctypeIndex , int subsetIndex ) { int chunk = doctypeIndex > > CHUNK_SHIFT ; int index = doctypeIndex & CHUNK_MASK ; int extraDataIndex = fNodeValue [ chunk ] [ index ] ; int echunk = extraDataIndex > > CHUNK_SHIFT ; int eindex = extraDataIndex & CHUNK_MASK ; fNodeLastChild [ echunk ] [ eindex ] = subsetIndex ; } public int createNotation ( int notationName , int publicId , int systemId ) throws Exception { int nodeIndex = createNode ( Node . NOTATION_NODE ) ; int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; int extraDataIndex = createNode ( ( short ) 0 ) ; int echunk = extraDataIndex > > CHUNK_SHIFT ; int eindex = extraDataIndex & CHUNK_MASK ; setChunkIndex ( fNodeName , notationName , chunk , index ) ; setChunkIndex ( fNodeValue , extraDataIndex , chunk , index ) ; setChunkIndex ( fNodeName , publicId , echunk , eindex ) ; setChunkIndex ( fNodeValue , systemId , echunk , eindex ) ; return nodeIndex ; } public int createEntity ( int entityName , int publicId , int systemId , int notationName ) throws Exception { int nodeIndex = createNode ( Node . ENTITY_NODE ) ; int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; int extraDataIndex = createNode ( ( short ) 0 ) ; int echunk = extraDataIndex > > CHUNK_SHIFT ; int eindex = extraDataIndex & CHUNK_MASK ; setChunkIndex ( fNodeName , entityName , chunk , index ) ; setChunkIndex ( fNodeValue , extraDataIndex , chunk , index ) ; setChunkIndex ( fNodeName , publicId , echunk , eindex ) ; setChunkIndex ( fNodeValue , systemId , echunk , eindex ) ; setChunkIndex ( fNodeLastChild , notationName , echunk , eindex ) ; return nodeIndex ; } public int createEntityReference ( int nameIndex ) throws Exception { int nodeIndex = createNode ( Node . ENTITY_REFERENCE_NODE ) ; int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; setChunkIndex ( fNodeName , nameIndex , chunk , index ) ; return nodeIndex ; } public int createElement ( int elementNameIndex , XMLAttrList attrList , int attrListIndex ) { return createElement ( elementNameIndex , - 1 , attrList , attrListIndex ) ; } public int createElement ( int elementNameIndex , int elementURIIndex , XMLAttrList attrList , int attrListIndex ) { int elementNodeIndex = createNode ( Node . ELEMENT_NODE ) ; int elementChunk = elementNodeIndex > > CHUNK_SHIFT ; int elementIndex = elementNodeIndex & CHUNK_MASK ; setChunkIndex ( fNodeName , elementNameIndex , elementChunk , elementIndex ) ; setChunkIndex ( fNodeURI , elementURIIndex , elementChunk , elementIndex ) ; if ( attrListIndex != - 1 ) { int first = attrList . getFirstAttr ( attrListIndex ) ; int lastAttrNodeIndex = - 1 ; int lastAttrChunk = - 1 ; int lastAttrIndex = - 1 ; for ( int index = first ; index != - 1 ; index = attrList . getNextAttr ( index ) ) { int attrNodeIndex = createAttribute ( attrList . getAttrName ( index ) , attrList . getAttrURI ( index ) , attrList . getAttValue ( index ) , attrList . isSpecified ( index ) ) ; int attrChunk = attrNodeIndex > > CHUNK_SHIFT ; int attrIndex = attrNodeIndex & CHUNK_MASK ; setChunkIndex ( fNodeParent , elementNodeIndex , attrChunk , attrIndex ) ; if ( index == first ) { setChunkIndex ( fNodeValue , attrNodeIndex , elementChunk , elementIndex ) ; } else { setChunkIndex ( fNodePrevSib , attrNodeIndex , lastAttrChunk , lastAttrIndex ) ; } lastAttrNodeIndex = attrNodeIndex ; lastAttrChunk = attrChunk ; lastAttrIndex = attrIndex ; } } return elementNodeIndex ; } public int createAttribute ( int attrNameIndex , int attrValueIndex , boolean specified ) { return createAttribute ( attrNameIndex , - 1 , attrValueIndex , specified ) ; } public int createAttribute ( int attrNameIndex , int attrURIIndex , int attrValueIndex , boolean specified ) { int nodeIndex = createNode ( NodeImpl . ATTRIBUTE_NODE ) ; int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; setChunkIndex ( fNodeName , attrNameIndex , chunk , index ) ; setChunkIndex ( fNodeURI , attrURIIndex , chunk , index ) ; setChunkIndex ( fNodeValue , specified ? 1 : 0 , chunk , index ) ; int textNodeIndex = createTextNode ( attrValueIndex , false ) ; appendChild ( nodeIndex , textNodeIndex ) ; return nodeIndex ; } public int createElementDefinition ( int elementNameIndex ) { int nodeIndex = createNode ( NodeImpl . ELEMENT_DEFINITION_NODE ) ; int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; setChunkIndex ( fNodeName , elementNameIndex , chunk , index ) ; return nodeIndex ; } public int createTextNode ( int dataIndex , boolean ignorableWhitespace ) { int nodeIndex = createNode ( Node . TEXT_NODE ) ; int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; setChunkIndex ( fNodeValue , dataIndex , chunk , index ) ; setChunkIndex ( fNodeLastChild , ignorableWhitespace ? 1 : 0 , chunk , index ) ; return nodeIndex ; } public int createCDATASection ( int dataIndex , boolean ignorableWhitespace ) { int nodeIndex = createNode ( Node . CDATA_SECTION_NODE ) ; int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; setChunkIndex ( fNodeValue , dataIndex , chunk , index ) ; setChunkIndex ( fNodeLastChild , ignorableWhitespace ? 1 : 0 , chunk , index ) ; return nodeIndex ; } public int createProcessingInstruction ( int targetIndex , int dataIndex ) { int nodeIndex = createNode ( Node . PROCESSING_INSTRUCTION_NODE ) ; int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; setChunkIndex ( fNodeName , targetIndex , chunk , index ) ; setChunkIndex ( fNodeValue , dataIndex , chunk , index ) ; return nodeIndex ; } public int createComment ( int dataIndex ) { int nodeIndex = createNode ( Node . COMMENT_NODE ) ; int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; setChunkIndex ( fNodeValue , dataIndex , chunk , index ) ; return nodeIndex ; } public void appendChild ( int parentIndex , int childIndex ) { int pchunk = parentIndex > > CHUNK_SHIFT ; int pindex = parentIndex & CHUNK_MASK ; int cchunk = childIndex > > CHUNK_SHIFT ; int cindex = childIndex & CHUNK_MASK ; setChunkIndex ( fNodeParent , parentIndex , cchunk , cindex ) ; int olast = getChunkIndex ( fNodeLastChild , pchunk , pindex ) ; setChunkIndex ( fNodePrevSib , olast , cchunk , cindex ) ; setChunkIndex ( fNodeLastChild , childIndex , pchunk , pindex ) ; } public int setAttributeNode ( int elemIndex , int attrIndex ) { int echunk = elemIndex > > CHUNK_SHIFT ; int eindex = elemIndex & CHUNK_MASK ; int achunk = attrIndex > > CHUNK_SHIFT ; int aindex = attrIndex & CHUNK_MASK ; String attrName = fStringPool . toString ( getChunkIndex ( fNodeName , achunk , aindex ) ) ; int oldAttrIndex = getChunkIndex ( fNodeValue , echunk , eindex ) ; int nextIndex = - 1 ; int oachunk = - 1 ; int oaindex = - 1 ; while ( oldAttrIndex != - 1 ) { oachunk = oldAttrIndex > > CHUNK_SHIFT ; oaindex = oldAttrIndex & CHUNK_MASK ; String oldAttrName = fStringPool . toString ( getChunkIndex ( fNodeName , oachunk , oaindex ) ) ; if ( oldAttrName . equals ( attrName ) ) { break ; } nextIndex = oldAttrIndex ; oldAttrIndex = getChunkIndex ( fNodePrevSib , oachunk , oaindex ) ; } if ( oldAttrIndex != - 1 ) { int prevIndex = getChunkIndex ( fNodePrevSib , oachunk , oaindex ) ; if ( nextIndex == - 1 ) { setChunkIndex ( fNodeValue , prevIndex , echunk , eindex ) ; } else { int pchunk = nextIndex > > CHUNK_SHIFT ; int pindex = nextIndex & CHUNK_MASK ; setChunkIndex ( fNodePrevSib , prevIndex , pchunk , pindex ) ; } clearChunkIndex ( fNodeType , oachunk , oaindex ) ; clearChunkIndex ( fNodeName , oachunk , oaindex ) ; clearChunkIndex ( fNodeValue , oachunk , oaindex ) ; clearChunkIndex ( fNodeParent , oachunk , oaindex ) ; clearChunkIndex ( fNodePrevSib , oachunk , oaindex ) ; int attrTextIndex = clearChunkIndex ( fNodeLastChild , oachunk , oaindex ) ; int atchunk = attrTextIndex > > CHUNK_SHIFT ; int atindex = attrTextIndex & CHUNK_MASK ; clearChunkIndex ( fNodeType , atchunk , atindex ) ; clearChunkIndex ( fNodeValue , atchunk , atindex ) ; clearChunkIndex ( fNodeParent , atchunk , atindex ) ; clearChunkIndex ( fNodeLastChild , atchunk , atindex ) ; } int prevIndex = getChunkIndex ( fNodeValue , echunk , eindex ) ; setChunkIndex ( fNodeValue , attrIndex , echunk , eindex ) ; setChunkIndex ( fNodePrevSib , prevIndex , achunk , aindex ) ; return oldAttrIndex ; } public int insertBefore ( int parentIndex , int newChildIndex , int refChildIndex ) { if ( refChildIndex == - 1 ) { appendChild ( parentIndex , newChildIndex ) ; return newChildIndex ; } int nchunk = newChildIndex > > CHUNK_SHIFT ; int nindex = newChildIndex & CHUNK_MASK ; int rchunk = refChildIndex > > CHUNK_SHIFT ; int rindex = refChildIndex & CHUNK_MASK ; int previousIndex = getChunkIndex ( fNodePrevSib , rchunk , rindex ) ; setChunkIndex ( fNodePrevSib , newChildIndex , rchunk , rindex ) ; setChunkIndex ( fNodePrevSib , previousIndex , nchunk , nindex ) ; return newChildIndex ; } public void setAsLastChild ( int parentIndex , int childIndex ) { int pchunk = parentIndex > > CHUNK_SHIFT ; int pindex = parentIndex & CHUNK_MASK ; int chunk = childIndex > > CHUNK_SHIFT ; int index = childIndex & CHUNK_MASK ; setChunkIndex ( fNodeLastChild , childIndex , pchunk , pindex ) ; } public int getParentNode ( int nodeIndex ) { return getParentNode ( nodeIndex , false ) ; } public int getParentNode ( int nodeIndex , boolean free ) { if ( nodeIndex == - 1 ) { return - 1 ; } int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; return free ? clearChunkIndex ( fNodeParent , chunk , index ) : getChunkIndex ( fNodeParent , chunk , index ) ; } public int getLastChild ( int nodeIndex ) { return getLastChild ( nodeIndex , true ) ; } public int getLastChild ( int nodeIndex , boolean free ) { if ( nodeIndex == - 1 ) { return - 1 ; } int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; return free ? clearChunkIndex ( fNodeLastChild , chunk , index ) : getChunkIndex ( fNodeLastChild , chunk , index ) ; } public int getPrevSibling ( int nodeIndex ) { return getPrevSibling ( nodeIndex , true ) ; } public int getPrevSibling ( int nodeIndex , boolean free ) { if ( nodeIndex == - 1 ) { return - 1 ; } int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; int type = getChunkIndex ( fNodeType , chunk , index ) ; if ( type == Node . TEXT_NODE ) { do { nodeIndex = getChunkIndex ( fNodePrevSib , chunk , index ) ; if ( nodeIndex == - 1 ) { break ; } chunk = nodeIndex > > CHUNK_SHIFT ; index = nodeIndex & CHUNK_MASK ; type = getChunkIndex ( fNodeType , chunk , index ) ; } while ( type == Node . TEXT_NODE ) ; } else { nodeIndex = getChunkIndex ( fNodePrevSib , chunk , index ) ; } return nodeIndex ; } public int getRealPrevSibling ( int nodeIndex ) { return getRealPrevSibling ( nodeIndex , true ) ; } public int getRealPrevSibling ( int nodeIndex , boolean free ) { if ( nodeIndex == - 1 ) { return - 1 ; } int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; return free ? clearChunkIndex ( fNodePrevSib , chunk , index ) : getChunkIndex ( fNodePrevSib , chunk , index ) ; } public int lookupElementDefinition ( int elementNameIndex ) { if ( fNodeCount > 1 ) { int docTypeIndex = - 1 ; int nchunk = 0 ; int nindex = 0 ; for ( int index = getChunkIndex ( fNodeLastChild , nchunk , nindex ) ; index != - 1 ; index = getChunkIndex ( fNodePrevSib , nchunk , nindex ) ) { nchunk = index > > CHUNK_SHIFT ; nindex = index & CHUNK_MASK ; if ( getChunkIndex ( fNodeType , nchunk , nindex ) == Node . DOCUMENT_TYPE_NODE ) { docTypeIndex = index ; break ; } } if ( docTypeIndex == - 1 ) { return - 1 ; } nchunk = docTypeIndex > > CHUNK_SHIFT ; nindex = docTypeIndex & CHUNK_MASK ; for ( int index = getChunkIndex ( fNodeLastChild , nchunk , nindex ) ; index != - 1 ; index = getChunkIndex ( fNodePrevSib , nchunk , nindex ) ) { nchunk = index > > CHUNK_SHIFT ; nindex = index & CHUNK_MASK ; if ( getChunkIndex ( fNodeName , nchunk , nindex ) == elementNameIndex ) { return index ; } } } return - 1 ; } public DeferredNode getNodeObject ( int nodeIndex ) { if ( nodeIndex == - 1 ) { return null ; } int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; int type = getChunkIndex ( fNodeType , chunk , index ) ; if ( type != Node . TEXT_NODE ) { clearChunkIndex ( fNodeType , chunk , index ) ; } DeferredNode node = null ; switch ( type ) { case Node . ATTRIBUTE_NODE : { if ( fNamespacesEnabled ) { node = new DeferredAttrNSImpl ( this , nodeIndex ) ; } else { node = new DeferredAttrImpl ( this , nodeIndex ) ; } break ; } case Node . CDATA_SECTION_NODE : { node = new DeferredCDATASectionImpl ( this , nodeIndex ) ; break ; } case Node . COMMENT_NODE : { node = new DeferredCommentImpl ( this , nodeIndex ) ; break ; } case Node . DOCUMENT_NODE : { node = this ; break ; } case Node . DOCUMENT_TYPE_NODE : { node = new DeferredDocumentTypeImpl ( this , nodeIndex ) ; docType = ( DocumentTypeImpl ) node ; break ; } case Node . ELEMENT_NODE : { if ( DEBUG_IDS ) { System . out . println ( "getNodeObject(ELEMENT_NODE): " + nodeIndex ) ; } if ( fNamespacesEnabled ) { node = new DeferredElementNSImpl ( this , nodeIndex ) ; } else { node = new DeferredElementImpl ( this , nodeIndex ) ; } if ( docElement == null ) { docElement = ( ElementImpl ) node ; } if ( fIdElement != null ) { int idIndex = DeferredDocumentImpl . binarySearch ( fIdElement , 0 , fIdCount - 1 , nodeIndex ) ; while ( idIndex != - 1 ) { if ( DEBUG_IDS ) { System . out . println ( "  id index: " + idIndex ) ; System . out . println ( "  fIdName[" + idIndex + "]: " + fIdName [ idIndex ] ) ; } int nameIndex = fIdName [ idIndex ] ; if ( nameIndex != - 1 ) { String name = fStringPool . toString ( nameIndex ) ; if ( DEBUG_IDS ) { System . out . println ( "  name: " + name ) ; System . out . print ( "getNodeObject()#" ) ; } putIdentifier0 ( name , ( Element ) node ) ; fIdName [ idIndex ] = - 1 ; } if ( idIndex + 1 < fIdCount && fIdElement [ idIndex + 1 ] == nodeIndex ) { idIndex ++ ; } else { idIndex = - 1 ; } } } break ; } case Node . ENTITY_NODE : { node = new DeferredEntityImpl ( this , nodeIndex ) ; break ; } case Node . ENTITY_REFERENCE_NODE : { node = new DeferredEntityReferenceImpl ( this , nodeIndex ) ; break ; } case Node . NOTATION_NODE : { node = new DeferredNotationImpl ( this , nodeIndex ) ; break ; } case Node . PROCESSING_INSTRUCTION_NODE : { node = new DeferredProcessingInstructionImpl ( this , nodeIndex ) ; break ; } case Node . TEXT_NODE : { node = new DeferredTextImpl ( this , nodeIndex ) ; break ; } case NodeImpl . ELEMENT_DEFINITION_NODE : { node = new DeferredElementDefinitionImpl ( this , nodeIndex ) ; break ; } default : { throw new IllegalArgumentException ( "type: " + type ) ; } } if ( node != null ) { return node ; } throw new IllegalArgumentException ( ) ; } public String getNodeNameString ( int nodeIndex ) { return getNodeNameString ( nodeIndex , true ) ; } public String getNodeNameString ( int nodeIndex , boolean free ) { if ( nodeIndex == - 1 ) { return null ; } int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; int nameIndex = free ? clearChunkIndex ( fNodeName , chunk , index ) : getChunkIndex ( fNodeName , chunk , index ) ; if ( nameIndex == - 1 ) { return null ; } return fStringPool . toString ( nameIndex ) ; } public String getNodeValueString ( int nodeIndex ) { return getNodeValueString ( nodeIndex , true ) ; } public String getNodeValueString ( int nodeIndex , boolean free ) { if ( nodeIndex == - 1 ) { return null ; } int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; int valueIndex = free ? clearChunkIndex ( fNodeValue , chunk , index ) : getChunkIndex ( fNodeValue , chunk , index ) ; if ( valueIndex == - 1 ) { return null ; } int type = getChunkIndex ( fNodeType , chunk , index ) ; if ( type == Node . TEXT_NODE ) { int prevSib = getRealPrevSibling ( nodeIndex ) ; if ( prevSib != - 1 && getNodeType ( prevSib , false ) == Node . TEXT_NODE ) { StringBuffer str = new StringBuffer ( ) ; str . append ( fStringPool . toString ( valueIndex ) ) ; do { chunk = prevSib > > CHUNK_SHIFT ; index = prevSib & CHUNK_MASK ; valueIndex = getChunkIndex ( fNodeValue , chunk , index ) ; str . insert ( 0 , fStringPool . toString ( valueIndex ) ) ; prevSib = getChunkIndex ( fNodePrevSib , chunk , index ) ; if ( prevSib == - 1 ) { break ; } } while ( getNodeType ( prevSib , false ) == Node . TEXT_NODE ) ; return str . toString ( ) ; } } return fStringPool . toString ( valueIndex ) ; } public int getNodeName ( int nodeIndex ) { return getNodeName ( nodeIndex , true ) ; } public int getNodeName ( int nodeIndex , boolean free ) { if ( nodeIndex == - 1 ) { return - 1 ; } int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; return free ? clearChunkIndex ( fNodeName , chunk , index ) : getChunkIndex ( fNodeName , chunk , index ) ; } public int getNodeValue ( int nodeIndex ) { return getNodeValue ( nodeIndex , true ) ; } public int getNodeValue ( int nodeIndex , boolean free ) { if ( nodeIndex == - 1 ) { return - 1 ; } int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; return free ? clearChunkIndex ( fNodeValue , chunk , index ) : getChunkIndex ( fNodeValue , chunk , index ) ; } public short getNodeType ( int nodeIndex ) { return getNodeType ( nodeIndex , true ) ; } public short getNodeType ( int nodeIndex , boolean free ) { if ( nodeIndex == - 1 ) { return - 1 ; } int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; if ( free ) { return ( short ) clearChunkIndex ( fNodeType , chunk , index ) ; } return ( short ) getChunkIndex ( fNodeType , chunk , index ) ; } public int getAttribute ( int elemIndex , int nameIndex ) { if ( elemIndex == - 1 || nameIndex == - 1 ) { return - 1 ; } int echunk = elemIndex > > CHUNK_SHIFT ; int eindex = elemIndex & CHUNK_MASK ; int attrIndex = getChunkIndex ( fNodeValue , echunk , eindex ) ; while ( attrIndex != - 1 ) { int achunk = attrIndex > > CHUNK_SHIFT ; int aindex = attrIndex & CHUNK_MASK ; if ( getChunkIndex ( fNodeName , achunk , aindex ) == nameIndex ) { return getChunkIndex ( fNodeValue , achunk , aindex ) ; } attrIndex = getChunkIndex ( fNodePrevSib , achunk , aindex ) ; } return - 1 ; } public short getNodeURI ( int nodeIndex ) { return getNodeURI ( nodeIndex , true ) ; } public short getNodeURI ( int nodeIndex , boolean free ) { if ( nodeIndex == - 1 ) { return - 1 ; } int chunk = nodeIndex > > CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; if ( free ) { return ( short ) clearChunkIndex ( fNodeURI , chunk , index ) ; } return ( short ) getChunkIndex ( fNodeURI , chunk , index ) ; } public void putIdentifier ( int nameIndex , int elementNodeIndex ) { if ( DEBUG_IDS ) { System . out . println ( "putIdentifier(" + nameIndex + ", " + elementNodeIndex + ')' + " // " + fStringPool . toString ( nameIndex ) + ", " + fStringPool . toString ( getChunkIndex ( fNodeName , elementNodeIndex > > CHUNK_SHIFT , elementNodeIndex & CHUNK_MASK ) ) ) ; } if ( fIdName == null ) { fIdName = new int [ 64 ] ; fIdElement = new int [ 64 ] ; } if ( fIdCount == fIdName . length ) { int idName [ ] = new int [ fIdCount * 2 ] ; System . arraycopy ( fIdName , 0 , idName , 0 , fIdCount ) ; fIdName = idName ; int idElement [ ] = new int [ idName . length ] ; System . arraycopy ( fIdElement , 0 , idElement , 0 , fIdCount ) ; fIdElement = idElement ; } fIdName [ fIdCount ] = nameIndex ; fIdElement [ fIdCount ] = elementNodeIndex ; fIdCount ++ ; } public void print ( ) { if ( DEBUG_PRINT_REF_COUNTS ) { System . out . print ( "num\t" ) ; System . out . print ( "type\t" ) ; System . out . print ( "name\t" ) ; System . out . print ( "val\t" ) ; System . out . print ( "par\t" ) ; System . out . print ( "fch\t" ) ; System . out . print ( "nsib" ) ; System . out . println ( ) ; for ( int i = 0 ; i < fNodeType . length ; i ++ ) { if ( fNodeType [ i ] != null ) { System . out . print ( "--------" ) ; System . out . print ( "--------" ) ; System . out . print ( "--------" ) ; System . out . print ( "--------" ) ; System . out . print ( "--------" ) ; System . out . print ( "--------" ) ; System . out . print ( "--------" ) ; System . out . println ( ) ; System . out . print ( i ) ; System . out . print ( '\t' ) ; System . out . print ( fNodeType [ i ] [ CHUNK_SIZE ] ) ; System . out . print ( '\t' ) ; System . out . print ( fNodeName [ i ] [ CHUNK_SIZE ] ) ; System . out . print ( '\t' ) ; System . out . print ( fNodeValue [ i ] [ CHUNK_SIZE ] ) ; System . out . print ( '\t' ) ; System . out . print ( fNodeParent [ i ] [ CHUNK_SIZE ] ) ; System . out . print ( '\t' ) ; System . out . print ( fNodeLastChild [ i ] [ CHUNK_SIZE ] ) ; System . out . print ( '\t' ) ; System . out . print ( fNodePrevSib [ i ] [ CHUNK_SIZE ] ) ; System . out . println ( ) ; System . out . print ( i ) ; System . out . print ( '\t' ) ; System . out . print ( fNodeType [ i ] [ CHUNK_SIZE + 1 ] ) ; System . out . print ( '\t' ) ; System . out . print ( fNodeName [ i ] [ CHUNK_SIZE + 1 ] ) ; System . out . print ( '\t' ) ; System . out . print ( fNodeValue [ i ] [ CHUNK_SIZE + 1 ] ) ; System . out . print ( '\t' ) ; System . out . print ( fNodeParent [ i ] [ CHUNK_SIZE + 1 ] ) ; System . out . print ( '\t' ) ; System . out . print ( fNodeLastChild [ i ] [ CHUNK_SIZE + 1 ] ) ; System . out . print ( '\t' ) ; System . out . print ( fNodePrevSib [ i ] [ CHUNK_SIZE + 1 ] ) ; System . out . println ( ) ; } } } if ( DEBUG_PRINT_TABLES ) { System . out . println ( "# start table" ) ; for ( int i = 0 ; i < fNodeCount ; i ++ ) { int chunk = i > > CHUNK_SHIFT ; int index = i & CHUNK_MASK ; if ( i % 10 == 0 ) { System . out . print ( "num\t" ) ; System . out . print ( "type\t" ) ; System . out . print ( "name\t" ) ; System . out . print ( "val\t" ) ; System . out . print ( "par\t" ) ; System . out . print ( "fch\t" ) ; System . out . print ( "nsib" ) ; System . out . println ( ) ; } System . out . print ( i ) ; System . out . print ( '\t' ) ; System . out . print ( getChunkIndex ( fNodeType , chunk , index ) ) ; System . out . print ( '\t' ) ; System . out . print ( getChunkIndex ( fNodeName , chunk , index ) ) ; System . out . print ( '\t' ) ; System . out . print ( getChunkIndex ( fNodeValue , chunk , index ) ) ; System . out . print ( '\t' ) ; System . out . print ( getChunkIndex ( fNodeParent , chunk , index ) ) ; System . out . print ( '\t' ) ; System . out . print ( getChunkIndex ( fNodeLastChild , chunk , index ) ) ; System . out . print ( '\t' ) ; System . out . print ( getChunkIndex ( fNodePrevSib , chunk , index ) ) ; System . out . println ( ) ; } System . out . println ( "# end table" ) ; } } public int getNodeIndex ( ) { return 0 ; } protected StringPool getStringPool ( ) { return fStringPool ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; if ( fIdElement != null ) { IntVector path = new IntVector ( ) ; for ( int i = 0 ; i < fIdCount ; i ++ ) { int elementNodeIndex = fIdElement [ i ] ; int idNameIndex = fIdName [ i ] ; if ( idNameIndex == - 1 ) { continue ; } path . removeAllElements ( ) ; int index = elementNodeIndex ; do { path . addElement ( index ) ; int pchunk = index > > CHUNK_SHIFT ; int pindex = index & CHUNK_MASK ; index = getChunkIndex ( fNodeParent , pchunk , pindex ) ; } while ( index != - 1 ) ; Node place = this ; for ( int j = path . size ( ) - 2 ; j >= 0 ; j -- ) { index = path . elementAt ( j ) ; Node child = place . getLastChild ( ) ; while ( child != null ) { if ( child instanceof DeferredNode ) { int nodeIndex = ( ( DeferredNode ) child ) . getNodeIndex ( ) ; if ( nodeIndex == index ) { place = child ; break ; } } child = child . getPreviousSibling ( ) ; } } Element element = ( Element ) place ; String name = fStringPool . toString ( idNameIndex ) ; putIdentifier0 ( name , element ) ; fIdName [ i ] = - 1 ; while ( fIdElement [ i + 1 ] == elementNodeIndex ) { name = fStringPool . toString ( fIdName [ ++ i ] ) ; putIdentifier0 ( name , element ) ; } } } } protected void synchronizeChildren ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; if ( ! needsSyncChildren ( ) ) { return ; } } boolean orig = mutationEvents ; mutationEvents = false ; needsSyncChildren ( false ) ; getNodeType ( 0 ) ; ChildNode first = null ; ChildNode last = null ; for ( int index = getLastChild ( 0 ) ; index != - 1 ; index = getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; int type = node . getNodeType ( ) ; if ( type == Node . ELEMENT_NODE ) { docElement = ( ElementImpl ) node ; } else if ( type == Node . DOCUMENT_TYPE_NODE ) { docType = ( DocumentTypeImpl ) node ; } } if ( first != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } mutationEvents = orig ; } protected boolean ensureCapacity ( int chunk , int index ) { if ( fNodeType == null ) { fNodeType = new int [ INITIAL_CHUNK_COUNT ] [ ] ; fNodeName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; fNodeValue = new int [ INITIAL_CHUNK_COUNT ] [ ] ; fNodeParent = new int [ INITIAL_CHUNK_COUNT ] [ ] ; fNodeLastChild = new int [ INITIAL_CHUNK_COUNT ] [ ] ; fNodePrevSib = new int [ INITIAL_CHUNK_COUNT ] [ ] ; fNodeURI = new int [ INITIAL_CHUNK_COUNT ] [ ] ; } try { return fNodeType [ chunk ] [ index ] != 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newsize = chunk * 2 ; int [ ] [ ] newArray = new int [ newsize ] [ ] ; System . arraycopy ( fNodeType , 0 , newArray , 0 , chunk ) ; fNodeType = newArray ; newArray = new int [ newsize ] [ ] ; System . arraycopy ( fNodeName , 0 , newArray , 0 , chunk ) ; fNodeName = newArray ; newArray = new int [ newsize ] [ ] ; System . arraycopy ( fNodeValue , 0 , newArray , 0 , chunk ) ; fNodeValue = newArray ; newArray = new int [ newsize ] [ ] ; System . arraycopy ( fNodeParent , 0 , newArray , 0 , chunk ) ; fNodeParent = newArray ; newArray = new int [ newsize ] [ ] ; System . arraycopy ( fNodeLastChild , 0 , newArray , 0 , chunk ) ; fNodeLastChild = newArray ; newArray = new int [ newsize ] [ ] ; System . arraycopy ( fNodePrevSib , 0 , newArray , 0 , chunk ) ; fNodePrevSib = newArray ; newArray = new int [ newsize ] [ ] ; System . arraycopy ( fNodeURI , 0 , newArray , 0 , chunk ) ; fNodeURI = newArray ; } catch ( NullPointerException ex ) { } createChunk ( fNodeType , chunk ) ; createChunk ( fNodeName , chunk ) ; createChunk ( fNodeValue , chunk ) ; createChunk ( fNodeParent , chunk ) ; createChunk ( fNodeLastChild , chunk ) ; createChunk ( fNodePrevSib , chunk ) ; createChunk ( fNodeURI , chunk ) ; return true ; } protected int createNode ( short nodeType ) { int chunk = fNodeCount > > CHUNK_SHIFT ; int index = fNodeCount & CHUNK_MASK ; ensureCapacity ( chunk , index ) ; setChunkIndex ( fNodeType , nodeType , chunk , index ) ; return fNodeCount ++ ; } protected static int binarySearch ( final int values [ ] , int start , int end , int target ) { if ( DEBUG_IDS ) { System . out . println ( "binarySearch(), target: " + target ) ; } while ( start <= end ) { int middle = ( start + end ) / 2 ; int value = values [ middle ] ; if ( DEBUG_IDS ) { System . out . print ( "  value: " + value + ", target: " + target + " // " ) ; print ( values , start , end , middle , target ) ; } if ( value == target ) { while ( middle > 0 && values [ middle - 1 ] == target ) { middle -- ; } if ( DEBUG_IDS ) { System . out . println ( "FOUND AT " + middle ) ; } return middle ; } if ( value > target ) { end = middle - 1 ; } else { start = middle + 1 ; } } if ( DEBUG_IDS ) { System . out . println ( "NOT FOUND!" ) ; } return - 1 ; } private final void createChunk ( int data [ ] [ ] , int chunk ) { data [ chunk ] = new int [ CHUNK_SIZE + 2 ] ; for ( int i = 0 ; i < CHUNK_SIZE ; i ++ ) { data [ chunk ] [ i ] = - 1 ; } } private final int setChunkIndex ( int data [ ] [ ] , int value , int chunk , int index ) { if ( value == - 1 ) { return clearChunkIndex ( data , chunk , index ) ; } int ovalue = data [ chunk ] [ index ] ; if ( ovalue == - 1 ) { data [ chunk ] [ CHUNK_SIZE ] ++ ; } data [ chunk ] [ index ] = value ; return ovalue ; } private final int getChunkIndex ( int data [ ] [ ] , int chunk , int index ) { return data [ chunk ] != null ? data [ chunk ] [ index ] : - 1 ; } private final int clearChunkIndex ( int data [ ] [ ] , int chunk , int index ) { int value = data [ chunk ] != null ? data [ chunk ] [ index ] : - 1 ; if ( value != - 1 ) { data [ chunk ] [ CHUNK_SIZE + 1 ] ++ ; data [ chunk ] [ index ] = - 1 ; if ( data [ chunk ] [ CHUNK_SIZE ] == data [ chunk ] [ CHUNK_SIZE + 1 ] ) { data [ chunk ] = null ; } } return value ; } private final void putIdentifier0 ( String idName , Element element ) { if ( DEBUG_IDS ) { System . out . println ( "putIdentifier0(" + idName + ", " + element + ')' ) ; } if ( identifiers == null ) { identifiers = new java . util . Hashtable ( ) ; } identifiers . put ( idName , element ) ; } private static void print ( int values [ ] , int start , int end , int middle , int target ) { if ( DEBUG_IDS ) { System . out . print ( start ) ; System . out . print ( " [" ) ; for ( int i = start ; i < end ; i ++ ) { if ( middle == i ) { System . out . print ( "!" ) ; } System . out . print ( values [ i ] ) ; if ( values [ i ] == target ) { System . out . print ( "*" ) ; } if ( i < end - 1 ) { System . out . print ( " " ) ; } } System . out . println ( "] " + end ) ; } } static class IntVector { private int data [ ] ; private int size ; public int size ( ) { return size ; } public int elementAt ( int index ) { return data [ index ] ; } public void addElement ( int element ) { ensureCapacity ( size + 1 ) ; data [ size ++ ] = element ; } public void removeAllElements ( ) { size = 0 ; } private void ensureCapacity ( int newsize ) { if ( data == null ) { data = new int [ newsize + 15 ] ; } else if ( newsize > data . length ) { int newdata [ ] = new int [ newsize + 15 ] ; System . arraycopy ( data , 0 , newdata , 0 , data . length ) ; data = newdata ; } } } } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; public class NamedNodeMapImpl implements NamedNodeMap , Serializable { static final long serialVersionUID = - 7039242451046758020L ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short CHANGED = 0x1 << 1 ; protected final static short HASDEFAULTS = 0x1 << 2 ; protected Vector nodes ; protected NodeImpl ownerNode ; protected NamedNodeMapImpl ( NodeImpl ownerNode ) { this . ownerNode = ownerNode ; } public int getLength ( ) { return ( nodes != null ) ? nodes . size ( ) : 0 ; } public Node item ( int index ) { return ( nodes != null && index < nodes . size ( ) ) ? ( Node ) ( nodes . elementAt ( index ) ) : null ; } public Node getNamedItem ( String name ) { int i = findNamePoint ( name , 0 ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node getNamedItemNS ( String namespaceURI , String localName ) { int i = findNamePoint ( namespaceURI , localName ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNamespaceURI ( ) , arg . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { NamedNodeMapImpl newmap = new NamedNodeMapImpl ( ownerNode ) ; newmap . cloneContent ( this ) ; return newmap ; } protected void cloneContent ( NamedNodeMapImpl srcmap ) { if ( srcmap . nodes != null ) { nodes = new Vector ( srcmap . nodes . size ( ) ) ; for ( int i = 0 ; i < srcmap . nodes . size ( ) ; ++ i ) { NodeImpl n = ( NodeImpl ) srcmap . nodes . elementAt ( i ) ; NodeImpl clone = ( NodeImpl ) n . cloneNode ( true ) ; clone . isSpecified ( n . isSpecified ( ) ) ; nodes . insertElementAt ( clone , i ) ; } } } void setReadOnly ( boolean readOnly , boolean deep ) { isReadOnly ( readOnly ) ; if ( deep && nodes != null ) { Enumeration e = nodes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( NodeImpl ) e . nextElement ( ) ) . setReadOnly ( readOnly , deep ) ; } } } boolean getReadOnly ( ) { return isReadOnly ( ) ; } void setOwnerDocument ( DocumentImpl doc ) { if ( nodes != null ) { for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { ( ( NodeImpl ) item ( i ) ) . setOwnerDocument ( doc ) ; } } } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean changed ( ) { return ( flags & CHANGED ) != 0 ; } final void changed ( boolean value ) { flags = ( short ) ( value ? flags | CHANGED : flags & ~ CHANGED ) ; } final boolean hasDefaults ( ) { return ( flags & HASDEFAULTS ) != 0 ; } final void hasDefaults ( boolean value ) { flags = ( short ) ( value ? flags | HASDEFAULTS : flags & ~ HASDEFAULTS ) ; } protected int findNamePoint ( String name , int start ) { int i = 0 ; if ( nodes != null ) { int first = start ; int last = nodes . size ( ) - 1 ; while ( first <= last ) { i = ( first + last ) / 2 ; int test = name . compareTo ( ( ( Node ) ( nodes . elementAt ( i ) ) ) . getNodeName ( ) ) ; if ( test == 0 ) { return i ; } else if ( test < 0 ) { last = i - 1 ; } else { first = i + 1 ; } } if ( first > i ) { i = first ; } } return - 1 - i ; } protected int findNamePoint ( String namespaceURI , String name ) { if ( nodes == null ) return - 1 ; if ( namespaceURI == null ) return - 1 ; if ( name == null ) return - 1 ; for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { NodeImpl a = ( NodeImpl ) nodes . elementAt ( i ) ; if ( namespaceURI . equals ( a . getNamespaceURI ( ) ) && name . equals ( a . getLocalName ( ) ) ) { return i ; } } return - 1 ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLBRElementImpl extends HTMLElementImpl implements HTMLBRElement { public String getClear ( ) { return capitalize ( getAttribute ( "clear" ) ) ; } public void setClear ( String clear ) { setAttribute ( "clear" , clear ) ; } public HTMLBRElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom ; public interface NamedNodeMap { public Node getNamedItem ( String name ) ; public Node setNamedItem ( Node arg ) throws DOMException ; public Node removeNamedItem ( String name ) throws DOMException ; public Node item ( int index ) ; public int getLength ( ) ; public Node getNamedItemNS ( String namespaceURI , String localName ) ; public Node setNamedItemNS ( Node arg ) throws DOMException ; public Node removeNamedItemNS ( String namespaceURI , String localName ) throws DOMException ; } 	1
package org . w3c . dom . html ; import org . w3c . dom . DOMException ; public interface HTMLSelectElement extends HTMLElement { public String getType ( ) ; public int getSelectedIndex ( ) ; public void setSelectedIndex ( int selectedIndex ) ; public String getValue ( ) ; public void setValue ( String value ) ; public int getLength ( ) ; public HTMLFormElement getForm ( ) ; public HTMLCollection getOptions ( ) ; public boolean getDisabled ( ) ; public void setDisabled ( boolean disabled ) ; public boolean getMultiple ( ) ; public void setMultiple ( boolean multiple ) ; public String getName ( ) ; public void setName ( String name ) ; public int getSize ( ) ; public void setSize ( int size ) ; public int getTabIndex ( ) ; public void setTabIndex ( int tabIndex ) ; public void add ( HTMLElement element , HTMLElement before ) throws DOMException ; public void remove ( int index ) ; public void blur ( ) ; public void focus ( ) ; } 	0
package org . apache . xml . serialize ; import java . util . Hashtable ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Node ; import org . w3c . dom . html . HTMLDocument ; public class OutputFormat { public static class DTD { public static final String HTMLPublicId = "-//W3C//DTD HTML 4.0//EN" ; public static final String HTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; public static final String XHTMLPublicId = "-//W3C//DTD XHTML 1.0 Strict//EN" ; public static final String XHTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; } public static class Defaults { public static final int Indent = 4 ; public static final String Encoding = "UTF-8" ; public static final int LineWidth = 72 ; } private String _method ; private String _version ; private int _indent = 0 ; private String _encoding = Defaults . Encoding ; private String _mediaType ; private String _doctypeSystem ; private String _doctypePublic ; private boolean _omitXmlDeclaration = false ; private boolean _omitDoctype = false ; private boolean _omitComments = false ; private boolean _stripComments = false ; private boolean _standalone = false ; private String [ ] _cdataElements ; private String [ ] _nonEscapingElements ; private String _lineSeparator = LineSeparator . Web ; private int _lineWidth = Defaults . LineWidth ; private boolean _preserve = false ; public OutputFormat ( ) { } public OutputFormat ( String method , String encoding , boolean indenting ) { setMethod ( method ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public OutputFormat ( Document doc ) { setMethod ( whichMethod ( doc ) ) ; setDoctype ( whichDoctypePublic ( doc ) , whichDoctypeSystem ( doc ) ) ; setMediaType ( whichMediaType ( getMethod ( ) ) ) ; } public OutputFormat ( Document doc , String encoding , boolean indenting ) { this ( doc ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public String getMethod ( ) { return _method ; } public void setMethod ( String method ) { _method = method ; } public String getVersion ( ) { return _version ; } public void setVersion ( String version ) { _version = version ; } public int getIndent ( ) { return _indent ; } public boolean getIndenting ( ) { return ( _indent > 0 ) ; } public void setIndent ( int indent ) { if ( indent < 0 ) _indent = 0 ; else _indent = indent ; } public void setIndenting ( boolean on ) { if ( on ) { _indent = Defaults . Indent ; _lineWidth = Defaults . LineWidth ; } else { _indent = 0 ; _lineWidth = 0 ; } } public String getEncoding ( ) { return _encoding ; } public void setEncoding ( String encoding ) { _encoding = encoding ; } public String getMediaType ( ) { return _mediaType ; } public void setMediaType ( String mediaType ) { _mediaType = mediaType ; } public void setDoctype ( String publicId , String systemId ) { _doctypePublic = publicId ; _doctypeSystem = systemId ; } public String getDoctypePublic ( ) { return _doctypePublic ; } public String getDoctypeSystem ( ) { return _doctypeSystem ; } public boolean getOmitComments ( ) { return _omitComments ; } public void setOmitComments ( boolean omit ) { _omitComments = omit ; } public boolean getOmitDocumentType ( ) { return _omitDoctype ; } public void setOmitDocumentType ( boolean omit ) { _omitDoctype = omit ; } public boolean getOmitXMLDeclaration ( ) { return _omitXmlDeclaration ; } public void setOmitXMLDeclaration ( boolean omit ) { _omitXmlDeclaration = omit ; } public boolean getStandalone ( ) { return _standalone ; } public void setStandalone ( boolean standalone ) { _standalone = standalone ; } public String [ ] getCDataElements ( ) { return _cdataElements ; } public boolean isCDataElement ( String tagName ) { int i ; if ( _cdataElements == null ) return false ; for ( i = 0 ; i < _cdataElements . length ; ++ i ) if ( _cdataElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setCDataElements ( String [ ] cdataElements ) { _cdataElements = cdataElements ; } public String [ ] getNonEscapingElements ( ) { return _nonEscapingElements ; } public boolean isNonEscapingElement ( String tagName ) { int i ; if ( _nonEscapingElements == null ) return false ; for ( i = 0 ; i < _nonEscapingElements . length ; ++ i ) if ( _nonEscapingElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setNonEscapingElements ( String [ ] nonEscapingElements ) { _nonEscapingElements = nonEscapingElements ; } public String getLineSeparator ( ) { return _lineSeparator ; } public void setLineSeparator ( String lineSeparator ) { if ( lineSeparator == null ) _lineSeparator = LineSeparator . Web ; else _lineSeparator = lineSeparator ; } public boolean getPreserveSpace ( ) { return _preserve ; } public void setPreserveSpace ( boolean preserve ) { _preserve = preserve ; } public int getLineWidth ( ) { return _lineWidth ; } public void setLineWidth ( int lineWidth ) { if ( lineWidth <= 0 ) _lineWidth = 0 ; else _lineWidth = lineWidth ; } public char getLastPrintable ( ) { if ( getEncoding ( ) != null && ( getEncoding ( ) . equalsIgnoreCase ( "ASCII" ) ) ) return 0xFF ; else return 0xFFFF ; } public static String whichMethod ( Document doc ) { Node node ; String value ; int i ; if ( doc instanceof HTMLDocument ) return Method . HTML ; node = doc . getFirstChild ( ) ; while ( node != null ) { if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( node . getNodeName ( ) . equalsIgnoreCase ( "html" ) ) { return Method . HTML ; } else if ( node . getNodeName ( ) . equalsIgnoreCase ( "root" ) ) { return Method . FOP ; } else { return Method . XML ; } } else if ( node . getNodeType ( ) == Node . TEXT_NODE ) { value = node . getNodeValue ( ) ; for ( i = 0 ; i < value . length ( ) ; ++ i ) if ( value . charAt ( i ) != 0x20 && value . charAt ( i ) != 0x0A && value . charAt ( i ) != 0x09 && value . charAt ( i ) != 0x0D ) return Method . XML ; } node = node . getNextSibling ( ) ; } return Method . XML ; } public static String whichDoctypePublic ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLPublicId ; return null ; } public static String whichDoctypeSystem ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLSystemId ; return null ; } public static String whichMediaType ( String method ) { if ( method . equalsIgnoreCase ( Method . XML ) ) return "text/xml" ; if ( method . equalsIgnoreCase ( Method . HTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . XHTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . TEXT ) ) return "text/plain" ; if ( method . equalsIgnoreCase ( Method . FOP ) ) return "application/pdf" ; return null ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLIElementImpl extends WMLElementImpl implements WMLIElement { public WMLIElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public abstract class SAXParser { protected SAXParser ( ) { super ( ) ; } public void parse ( InputStream stream , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( stream ) , base ) ; } public void parse ( String uri , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( uri ) , base ) ; } public void parse ( File file , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; String path = file . getAbsolutePath ( ) ; if ( File . separatorChar != '/' ) { path = path . replace ( File . separatorChar , '/' ) ; } if ( ! path . startsWith ( "/" ) ) { path = "/" + path ; } if ( ! path . endsWith ( "/" ) && file . isDirectory ( ) ) { path = path + "/" ; } java . net . URL url = new java . net . URL ( "file" , "" , path ) ; this . parse ( new InputSource ( url . toString ( ) ) , base ) ; } public void parse ( InputSource source , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( source == null ) throw new IllegalArgumentException ( ) ; Parser p = this . getParser ( ) ; if ( base != null ) { p . setDocumentHandler ( base ) ; p . setDTDHandler ( base ) ; p . setEntityResolver ( base ) ; p . setErrorHandler ( base ) ; } p . parse ( source ) ; } public abstract Parser getParser ( ) throws SAXException ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLPElementImpl extends WMLElementImpl implements WMLPElement { public WMLPElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setMode ( String newValue ) { setAttribute ( "mode" , newValue ) ; } public String getMode ( ) { return getAttribute ( "mode" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setAlign ( String newValue ) { setAttribute ( "align" , newValue ) ; } public String getAlign ( ) { return getAttribute ( "align" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom ; public interface Element extends Node { public String getTagName ( ) ; public String getAttribute ( String name ) ; public void setAttribute ( String name , String value ) throws DOMException ; public void removeAttribute ( String name ) throws DOMException ; public Attr getAttributeNode ( String name ) ; public Attr setAttributeNode ( Attr newAttr ) throws DOMException ; public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException ; public NodeList getElementsByTagName ( String name ) ; public String getAttributeNS ( String namespaceURI , String localName ) ; public void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException ; public void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException ; public Attr getAttributeNodeNS ( String namespaceURI , String localName ) ; public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public boolean hasAttribute ( String name ) ; public boolean hasAttributeNS ( String namespaceURI , String localName ) ; } 	1
package org . apache . xml . serialize ; import java . io . OutputStream ; import java . io . Writer ; import java . io . UnsupportedEncodingException ; public final class XHTMLSerializer extends HTMLSerializer { public XHTMLSerializer ( ) { super ( true , new OutputFormat ( Method . XHTML , null , false ) ) ; } public XHTMLSerializer ( OutputFormat format ) { super ( true , format != null ? format : new OutputFormat ( Method . XHTML , null , false ) ) ; } public XHTMLSerializer ( Writer writer , OutputFormat format ) { super ( true , format != null ? format : new OutputFormat ( Method . XHTML , null , false ) ) ; setOutputCharStream ( writer ) ; } public XHTMLSerializer ( OutputStream output , OutputFormat format ) { super ( true , format != null ? format : new OutputFormat ( Method . XHTML , null , false ) ) ; setOutputByteStream ( output ) ; } public void setOutputFormat ( OutputFormat format ) { super . setOutputFormat ( format != null ? format : new OutputFormat ( Method . XHTML , null , false ) ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class NotationImpl extends NodeImpl implements Notation { static final long serialVersionUID = - 764632195890658402L ; protected String name ; protected String publicId ; protected String systemId ; public NotationImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; } public short getNodeType ( ) { return Node . NOTATION_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public String getPublicId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return publicId ; } public String getSystemId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return systemId ; } public void setPublicId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } publicId = id ; } public void setSystemId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } systemId = id ; } } 	1
package org . apache . xerces . utils ; public final class Hash2intTable { private static final int INITIAL_BUCKET_SIZE = 4 ; private static final int HASHTABLE_SIZE = 256 ; private int [ ] [ ] fHashTable = new int [ HASHTABLE_SIZE ] [ ] ; public void put ( int key1 , int key2 , int key3 , int value ) { int hash = ( key1 + key2 + key3 + 2 ) % HASHTABLE_SIZE ; int [ ] bucket = fHashTable [ hash ] ; if ( bucket == null ) { bucket = new int [ 1 + 4 * INITIAL_BUCKET_SIZE ] ; bucket [ 0 ] = 1 ; bucket [ 1 ] = key1 ; bucket [ 2 ] = key2 ; bucket [ 3 ] = key3 ; bucket [ 4 ] = value ; fHashTable [ hash ] = bucket ; } else { int count = bucket [ 0 ] ; int offset = 1 + 4 * count ; if ( offset == bucket . length ) { int newSize = count + INITIAL_BUCKET_SIZE ; int [ ] newBucket = new int [ 1 + 4 * newSize ] ; System . arraycopy ( bucket , 0 , newBucket , 0 , offset ) ; bucket = newBucket ; fHashTable [ hash ] = bucket ; } boolean found = false ; int j = 1 ; for ( int i = 0 ; i < count ; i ++ ) { if ( bucket [ j ] == key1 && bucket [ j + 1 ] == key2 && bucket [ j + 2 ] == key3 ) { bucket [ j + 3 ] = value ; found = true ; break ; } j += 4 ; } if ( ! found ) { bucket [ offset ++ ] = key1 ; bucket [ offset ++ ] = key2 ; bucket [ offset ++ ] = key3 ; bucket [ offset ] = value ; bucket [ 0 ] = ++ count ; } } } public int get ( int key1 , int key2 , int key3 ) { int hash = ( key1 + key2 + key3 + 2 ) % HASHTABLE_SIZE ; int [ ] bucket = fHashTable [ hash ] ; if ( bucket == null ) { return - 1 ; } int count = bucket [ 0 ] ; int j = 1 ; for ( int i = 0 ; i < count ; i ++ ) { if ( bucket [ j ] == key1 && bucket [ j + 1 ] == key2 && bucket [ j + 2 ] == key3 ) { return bucket [ j + 3 ] ; } j += 4 ; } return - 1 ; } } 	0
package org . w3c . dom . events ; public interface EventListener { public void handleEvent ( Event evt ) ; } 	1
package org . apache . xerces . framework ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . readers . DefaultEntityHandler ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . apache . xerces . validators . common . Grammar ; import org . apache . xerces . validators . common . GrammarResolver ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . apache . xerces . validators . dtd . DTDGrammar ; import org . xml . sax . Locator ; import org . xml . sax . SAXParseException ; import java . util . StringTokenizer ; public final class XMLDTDScanner { private static final char [ ] version_string = { 'v' , 'e' , 'r' , 's' , 'i' , 'o' , 'n' } ; private static final char [ ] element_string = { 'E' , 'L' , 'E' , 'M' , 'E' , 'N' , 'T' } ; private static final char [ ] empty_string = { 'E' , 'M' , 'P' , 'T' , 'Y' } ; private static final char [ ] any_string = { 'A' , 'N' , 'Y' } ; private static final char [ ] pcdata_string = { '#' , 'P' , 'C' , 'D' , 'A' , 'T' , 'A' } ; private static final char [ ] attlist_string = { 'A' , 'T' , 'T' , 'L' , 'I' , 'S' , 'T' } ; private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' } ; private static final char [ ] id_string = { 'I' , 'D' } ; private static final char [ ] ref_string = { 'R' , 'E' , 'F' } ; private static final char [ ] entit_string = { 'E' , 'N' , 'T' , 'I' , 'T' } ; private static final char [ ] ies_string = { 'I' , 'E' , 'S' } ; private static final char [ ] nmtoken_string = { 'N' , 'M' , 'T' , 'O' , 'K' , 'E' , 'N' } ; private static final char [ ] notation_string = { 'N' , 'O' , 'T' , 'A' , 'T' , 'I' , 'O' , 'N' } ; private static final char [ ] required_string = { '#' , 'R' , 'E' , 'Q' , 'U' , 'I' , 'R' , 'E' , 'D' } ; private static final char [ ] implied_string = { '#' , 'I' , 'M' , 'P' , 'L' , 'I' , 'E' , 'D' } ; private static final char [ ] fixed_string = { '#' , 'F' , 'I' , 'X' , 'E' , 'D' } ; private static final char [ ] include_string = { 'I' , 'N' , 'C' , 'L' , 'U' , 'D' , 'E' } ; private static final char [ ] ignore_string = { 'I' , 'G' , 'N' , 'O' , 'R' , 'E' } ; private static final char [ ] entity_string = { 'E' , 'N' , 'T' , 'I' , 'T' , 'Y' } ; private static final char [ ] system_string = { 'S' , 'Y' , 'S' , 'T' , 'E' , 'M' } ; private static final char [ ] public_string = { 'P' , 'U' , 'B' , 'L' , 'I' , 'C' } ; private static final char [ ] ndata_string = { 'N' , 'D' , 'A' , 'T' , 'A' } ; private static final char [ ] encoding_string = { 'e' , 'n' , 'c' , 'o' , 'd' , 'i' , 'n' , 'g' } ; private DTDGrammar fDTDGrammar = null ; private GrammarResolver fGrammarResolver = null ; private boolean fNamespacesEnabled = false ; private boolean fValidationEnabled = false ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private QName fElementQName = new QName ( ) ; private QName fAttributeQName = new QName ( ) ; private QName fElementRefQName = new QName ( ) ; private EventHandler fEventHandler = null ; private XMLDocumentHandler . DTDHandler fDTDHandler = null ; private StringPool fStringPool = null ; private XMLErrorReporter fErrorReporter = null ; private XMLEntityHandler fEntityHandler = null ; private XMLEntityHandler . EntityReader fEntityReader = null ; private XMLEntityHandler . CharBuffer fLiteralData = null ; private int fReaderId = - 1 ; private int fSystemLiteral = - 1 ; private int fPubidLiteral = - 1 ; private int [ ] fOpStack = null ; private int [ ] fNodeIndexStack = null ; private int [ ] fPrevNodeIndexStack = null ; private int fScannerState = SCANNER_STATE_INVALID ; private int fIncludeSectDepth = 0 ; private int fDoctypeReader = - 1 ; private int fExternalSubsetReader = - 1 ; private int fDefaultAttValueReader = - 1 ; private int fDefaultAttValueElementType = - 1 ; private int fDefaultAttValueAttrName = - 1 ; private int fDefaultAttValueOffset = - 1 ; private int fDefaultAttValueMark = - 1 ; private int fEntityValueReader = - 1 ; private int fEntityValueMark = - 1 ; private int fXMLSymbol = - 1 ; private int fXMLNamespace = - 1 ; private int fXMLSpace = - 1 ; private int fDefault = - 1 ; private int fPreserve = - 1 ; private int fScannerMarkupDepth = 0 ; private int fScannerParenDepth = 0 ; public XMLDTDScanner ( StringPool stringPool , XMLErrorReporter errorReporter , XMLEntityHandler entityHandler , XMLEntityHandler . CharBuffer literalData ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fEntityHandler = entityHandler ; fLiteralData = literalData ; init ( ) ; } public void setEventHandler ( XMLDTDScanner . EventHandler eventHandler ) { fEventHandler = eventHandler ; } public void setDTDHandler ( XMLDocumentHandler . DTDHandler dtdHandler ) { fDTDHandler = dtdHandler ; } public void setGrammarResolver ( GrammarResolver resolver ) { fGrammarResolver = resolver ; } public void setNamespacesEnabled ( boolean enabled ) { fNamespacesEnabled = enabled ; } public void setValidationEnabled ( boolean enabled ) { fValidationEnabled = enabled ; } public boolean getReadingExternalEntity ( ) { return fReaderId != fDoctypeReader ; } public boolean getReadingContentSpec ( ) { return getScannerState ( ) == SCANNER_STATE_CONTENTSPEC ; } public int markupDepth ( ) { return fScannerMarkupDepth ; } private int increaseMarkupDepth ( ) { return fScannerMarkupDepth ++ ; } private int decreaseMarkupDepth ( ) { return fScannerMarkupDepth -- ; } public int parenDepth ( ) { return fScannerParenDepth ; } private void setParenDepth ( int parenDepth ) { fScannerParenDepth = parenDepth ; } private void increaseParenDepth ( ) { fScannerParenDepth ++ ; } private void decreaseParenDepth ( ) { fScannerParenDepth -- ; } public void reset ( StringPool stringPool , XMLEntityHandler . CharBuffer literalData ) throws Exception { fStringPool = stringPool ; fLiteralData = literalData ; fEntityReader = null ; fReaderId = - 1 ; fSystemLiteral = - 1 ; fPubidLiteral = - 1 ; fOpStack = null ; fNodeIndexStack = null ; fPrevNodeIndexStack = null ; fScannerState = SCANNER_STATE_INVALID ; fIncludeSectDepth = 0 ; fDoctypeReader = - 1 ; fExternalSubsetReader = - 1 ; fDefaultAttValueReader = - 1 ; fDefaultAttValueElementType = - 1 ; fDefaultAttValueAttrName = - 1 ; fDefaultAttValueOffset = - 1 ; fDefaultAttValueMark = - 1 ; fEntityValueReader = - 1 ; fEntityValueMark = - 1 ; fScannerMarkupDepth = 0 ; fScannerParenDepth = 0 ; init ( ) ; } private void init ( ) { fXMLSymbol = fStringPool . addSymbol ( "xml" ) ; fXMLNamespace = fStringPool . addSymbol ( "http://www.w3.org/XML/1998/namespace" ) ; fXMLSpace = fStringPool . addSymbol ( "xml:space" ) ; fDefault = fStringPool . addSymbol ( "default" ) ; fPreserve = fStringPool . addSymbol ( "preserve" ) ; } public interface EventHandler { public void callStartDTD ( ) throws Exception ; public void callEndDTD ( ) throws Exception ; public void callTextDecl ( int version , int encoding ) throws Exception ; public void doctypeDecl ( QName rootElement , int publicId , int systemId ) throws Exception ; public void startReadingFromExternalSubset ( int publicId , int systemId ) throws Exception ; public void stopReadingFromExternalSubset ( ) throws Exception ; public int addElementDecl ( QName elementDecl ) throws Exception ; public int addElementDecl ( QName elementDecl , int contentSpecType , int contentSpec , boolean isExternal ) throws Exception ; public int addAttDef ( QName elementDecl , QName attributeDecl , int attType , boolean attList , int enumeration , int attDefaultType , int attDefaultValue , boolean isExternal ) throws Exception ; public int addUniqueLeafNode ( int nameIndex ) throws Exception ; public int addContentSpecNode ( int nodeType , int nodeValue ) throws Exception ; public int addContentSpecNode ( int nodeType , int leftNodeIndex , int rightNodeIndex ) throws Exception ; public String getContentSpecNodeAsString ( int nodeIndex ) throws Exception ; public boolean startEntityDecl ( boolean isPE , int entityName ) throws Exception ; public void endEntityDecl ( ) throws Exception ; public int addInternalPEDecl ( int name , int value ) throws Exception ; public int addExternalPEDecl ( int name , int publicId , int systemId ) throws Exception ; public int addInternalEntityDecl ( int name , int value ) throws Exception ; public int addExternalEntityDecl ( int name , int publicId , int systemId ) throws Exception ; public int addUnparsedEntityDecl ( int name , int publicId , int systemId , int notationName ) throws Exception ; public int startEnumeration ( ) throws Exception ; public void addNameToEnumeration ( int enumIndex , int elementType , int attrName , int nameIndex , boolean isNotationType ) throws Exception ; public void endEnumeration ( int enumIndex ) throws Exception ; public int addNotationDecl ( int notationName , int publicId , int systemId ) throws Exception ; public void callComment ( int data ) throws Exception ; public void callProcessingInstruction ( int piTarget , int piData ) throws Exception ; public void internalSubset ( int internalSubset ) throws Exception ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 ) throws Exception { Object [ ] args = { string1 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 ) throws Exception { Object [ ] args = { string1 , string2 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } private void reportFatalXMLError ( int majorCode , int minorCode ) throws Exception { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } private void reportFatalXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } private void reportFatalXMLError ( int majorCode , int minorCode , String string1 ) throws Exception { Object [ ] args = { string1 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } private void reportFatalXMLError ( int majorCode , int minorCode , int stringIndex1 , int stringIndex2 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) , fStringPool . toString ( stringIndex2 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } private void reportFatalXMLError ( int majorCode , int minorCode , String string1 , String string2 ) throws Exception { Object [ ] args = { string1 , string2 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } private void reportFatalXMLError ( int majorCode , int minorCode , String string1 , String string2 , String string3 ) throws Exception { Object [ ] args = { string1 , string2 , string3 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } private void abortMarkup ( int majorCode , int minorCode ) throws Exception { reportFatalXMLError ( majorCode , minorCode ) ; skipPastEndOfCurrentMarkup ( ) ; } private void abortMarkup ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { reportFatalXMLError ( majorCode , minorCode , stringIndex1 ) ; skipPastEndOfCurrentMarkup ( ) ; } private void abortMarkup ( int majorCode , int minorCode , String string1 ) throws Exception { reportFatalXMLError ( majorCode , minorCode , string1 ) ; skipPastEndOfCurrentMarkup ( ) ; } private void abortMarkup ( int majorCode , int minorCode , int stringIndex1 , int stringIndex2 ) throws Exception { reportFatalXMLError ( majorCode , minorCode , stringIndex1 , stringIndex2 ) ; skipPastEndOfCurrentMarkup ( ) ; } private void skipPastEndOfCurrentMarkup ( ) throws Exception { fEntityReader . skipToChar ( '>' ) ; if ( fEntityReader . lookingAtChar ( '>' , true ) ) decreaseMarkupDepth ( ) ; } static private final int SCANNER_STATE_INVALID = - 1 ; static private final int SCANNER_STATE_END_OF_INPUT = 0 ; static private final int SCANNER_STATE_DOCTYPEDECL = 50 ; static private final int SCANNER_STATE_MARKUP_DECL = 51 ; static private final int SCANNER_STATE_TEXTDECL = 53 ; static private final int SCANNER_STATE_COMMENT = 54 ; static private final int SCANNER_STATE_PI = 55 ; static private final int SCANNER_STATE_DEFAULT_ATTRIBUTE_VALUE = 56 ; static private final int SCANNER_STATE_CONTENTSPEC = 57 ; static private final int SCANNER_STATE_ENTITY_VALUE = 58 ; static private final int SCANNER_STATE_SYSTEMLITERAL = 59 ; static private final int SCANNER_STATE_PUBIDLITERAL = 60 ; private int setScannerState ( int scannerState ) { int prevState = fScannerState ; fScannerState = scannerState ; return prevState ; } private int getScannerState ( ) { return fScannerState ; } private void restoreScannerState ( int scannerState ) { if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) fScannerState = scannerState ; } public void readerChange ( XMLEntityHandler . EntityReader nextReader , int nextReaderId ) throws Exception { fEntityReader = nextReader ; fReaderId = nextReaderId ; if ( fScannerState == SCANNER_STATE_DEFAULT_ATTRIBUTE_VALUE ) { fDefaultAttValueOffset = fEntityReader . currentOffset ( ) ; fDefaultAttValueMark = fDefaultAttValueOffset ; } else if ( fScannerState == SCANNER_STATE_ENTITY_VALUE ) { fEntityValueMark = fEntityReader . currentOffset ( ) ; } } public void endOfInput ( int entityNameIndex , boolean moreToFollow ) throws Exception { if ( fValidationEnabled ) { int readerDepth = fEntityHandler . getReaderDepth ( ) ; if ( getReadingContentSpec ( ) ) { int parenDepth = parenDepth ( ) ; if ( readerDepth != parenDepth ) { reportRecoverableXMLError ( XMLMessages . MSG_IMPROPER_GROUP_NESTING , XMLMessages . VC_PROPER_GROUP_PE_NESTING , entityNameIndex ) ; } } else { int markupDepth = markupDepth ( ) ; if ( readerDepth != markupDepth ) { reportRecoverableXMLError ( XMLMessages . MSG_IMPROPER_DECLARATION_NESTING , XMLMessages . VC_PROPER_DECLARATION_PE_NESTING , entityNameIndex ) ; } } } moreToFollow = fReaderId != fExternalSubsetReader ; switch ( fScannerState ) { case SCANNER_STATE_INVALID : throw new RuntimeException ( "FWK004 XMLDTDScanner.endOfInput: cannot happen: 2" + "\n2" ) ; case SCANNER_STATE_END_OF_INPUT : break ; case SCANNER_STATE_MARKUP_DECL : if ( ! moreToFollow && fIncludeSectDepth > 0 ) { reportFatalXMLError ( XMLMessages . MSG_INCLUDESECT_UNTERMINATED , XMLMessages . P62_UNTERMINATED ) ; } break ; case SCANNER_STATE_DOCTYPEDECL : throw new RuntimeException ( "FWK004 XMLDTDScanner.endOfInput: cannot happen: 2.5" + "\n2.5" ) ; case SCANNER_STATE_TEXTDECL : break ; case SCANNER_STATE_SYSTEMLITERAL : if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_SYSTEMID_UNTERMINATED , XMLMessages . P11_UNTERMINATED ) ; } else { } break ; case SCANNER_STATE_PUBIDLITERAL : if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_PUBLICID_UNTERMINATED , XMLMessages . P12_UNTERMINATED ) ; } else { } break ; case SCANNER_STATE_COMMENT : if ( ! moreToFollow && ! getReadingExternalEntity ( ) ) { reportFatalXMLError ( XMLMessages . MSG_COMMENT_UNTERMINATED , XMLMessages . P15_UNTERMINATED ) ; } else { } break ; case SCANNER_STATE_PI : if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_PI_UNTERMINATED , XMLMessages . P16_UNTERMINATED ) ; } else { reportFatalXMLError ( XMLMessages . MSG_PI_NOT_IN_ONE_ENTITY , XMLMessages . P78_NOT_WELLFORMED ) ; } break ; case SCANNER_STATE_DEFAULT_ATTRIBUTE_VALUE : if ( ! moreToFollow ) { reportFatalXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_UNTERMINATED , XMLMessages . P10_UNTERMINATED , fDefaultAttValueElementType , fDefaultAttValueAttrName ) ; } else if ( fReaderId == fDefaultAttValueReader ) { } else { fEntityReader . append ( fLiteralData , fDefaultAttValueMark , fDefaultAttValueOffset - fDefaultAttValueMark ) ; } break ; case SCANNER_STATE_CONTENTSPEC : break ; case SCANNER_STATE_ENTITY_VALUE : if ( fReaderId == fEntityValueReader ) { } else { fEntityReader . append ( fLiteralData , fEntityValueMark , fEntityReader . currentOffset ( ) - fEntityValueMark ) ; } break ; default : throw new RuntimeException ( "FWK004 XMLDTDScanner.endOfInput: cannot happen: 3" + "\n3" ) ; } if ( ! moreToFollow ) { setScannerState ( SCANNER_STATE_END_OF_INPUT ) ; } } private int scanCharRef ( ) throws Exception { int valueOffset = fEntityReader . currentOffset ( ) ; boolean hex = fEntityReader . lookingAtChar ( 'x' , true ) ; int num = fEntityReader . scanCharRef ( hex ) ; if ( num < 0 ) { switch ( num ) { case XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED : reportFatalXMLError ( XMLMessages . MSG_SEMICOLON_REQUIRED_IN_CHARREF , XMLMessages . P66_SEMICOLON_REQUIRED ) ; return - 1 ; case XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR : int majorCode = hex ? XMLMessages . MSG_HEXDIGIT_REQUIRED_IN_CHARREF : XMLMessages . MSG_DIGIT_REQUIRED_IN_CHARREF ; int minorCode = hex ? XMLMessages . P66_HEXDIGIT_REQUIRED : XMLMessages . P66_DIGIT_REQUIRED ; reportFatalXMLError ( majorCode , minorCode ) ; return - 1 ; case XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE : num = 0x110000 ; break ; } } if ( num < 0x20 ) { if ( num == 0x09 || num == 0x0A || num == 0x0D ) { return num ; } } else if ( num <= 0xD7FF || ( num >= 0xE000 && ( num <= 0xFFFD || ( num >= 0x10000 && num <= 0x10FFFF ) ) ) ) { return num ; } int valueLength = fEntityReader . currentOffset ( ) - valueOffset ; reportFatalXMLError ( XMLMessages . MSG_INVALID_CHARREF , XMLMessages . WFC_LEGAL_CHARACTER , fEntityReader . addString ( valueOffset , valueLength ) ) ; return - 1 ; } private void scanComment ( ) throws Exception { int commentOffset = fEntityReader . currentOffset ( ) ; boolean sawDashDash = false ; int previousState = setScannerState ( SCANNER_STATE_COMMENT ) ; while ( fScannerState == SCANNER_STATE_COMMENT ) { if ( fEntityReader . lookingAtChar ( '-' , false ) ) { int nextEndOffset = fEntityReader . currentOffset ( ) ; int endOffset = 0 ; fEntityReader . lookingAtChar ( '-' , true ) ; int offset = fEntityReader . currentOffset ( ) ; int count = 1 ; while ( fEntityReader . lookingAtChar ( '-' , true ) ) { count ++ ; endOffset = nextEndOffset ; nextEndOffset = offset ; offset = fEntityReader . currentOffset ( ) ; } if ( count > 1 ) { if ( fEntityReader . lookingAtChar ( '>' , true ) ) { if ( ! sawDashDash && count > 2 ) { reportFatalXMLError ( XMLMessages . MSG_DASH_DASH_IN_COMMENT , XMLMessages . P15_DASH_DASH ) ; sawDashDash = true ; } decreaseMarkupDepth ( ) ; int comment = fEntityReader . addString ( commentOffset , endOffset - commentOffset ) ; fDTDGrammar . callComment ( comment ) ; if ( fDTDHandler != null ) { fDTDHandler . comment ( comment ) ; } restoreScannerState ( previousState ) ; return ; } else if ( ! sawDashDash ) { reportFatalXMLError ( XMLMessages . MSG_DASH_DASH_IN_COMMENT , XMLMessages . P15_DASH_DASH ) ; sawDashDash = true ; } } } else { if ( ! fEntityReader . lookingAtValidChar ( true ) ) { int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { if ( invChar >= 0 ) { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_COMMENT , XMLMessages . P15_INVALID_CHARACTER , Integer . toHexString ( invChar ) ) ; } } } } } restoreScannerState ( previousState ) ; } private void scanPI ( int piTarget ) throws Exception { String piTargetString = fStringPool . toString ( piTarget ) ; if ( piTargetString . length ( ) == 3 && ( piTargetString . charAt ( 0 ) == 'X' || piTargetString . charAt ( 0 ) == 'x' ) && ( piTargetString . charAt ( 1 ) == 'M' || piTargetString . charAt ( 1 ) == 'm' ) && ( piTargetString . charAt ( 2 ) == 'L' || piTargetString . charAt ( 2 ) == 'l' ) ) { abortMarkup ( XMLMessages . MSG_RESERVED_PITARGET , XMLMessages . P17_RESERVED_PITARGET ) ; return ; } int prevState = setScannerState ( SCANNER_STATE_PI ) ; int piDataOffset = - 1 ; int piDataLength = 0 ; if ( ! fEntityReader . lookingAtSpace ( true ) ) { if ( ! fEntityReader . lookingAtChar ( '?' , true ) || ! fEntityReader . lookingAtChar ( '>' , true ) ) { if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_IN_PI , XMLMessages . P16_WHITESPACE_REQUIRED ) ; restoreScannerState ( prevState ) ; } return ; } decreaseMarkupDepth ( ) ; restoreScannerState ( prevState ) ; } else { fEntityReader . skipPastSpaces ( ) ; piDataOffset = fEntityReader . currentOffset ( ) ; while ( fScannerState == SCANNER_STATE_PI ) { while ( fEntityReader . lookingAtChar ( '?' , false ) ) { int offset = fEntityReader . currentOffset ( ) ; fEntityReader . lookingAtChar ( '?' , true ) ; if ( fEntityReader . lookingAtChar ( '>' , true ) ) { piDataLength = offset - piDataOffset ; decreaseMarkupDepth ( ) ; restoreScannerState ( prevState ) ; break ; } } if ( fScannerState != SCANNER_STATE_PI ) break ; if ( ! fEntityReader . lookingAtValidChar ( true ) ) { int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { if ( invChar >= 0 ) { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_PI , XMLMessages . P16_INVALID_CHARACTER , Integer . toHexString ( invChar ) ) ; } skipPastEndOfCurrentMarkup ( ) ; restoreScannerState ( prevState ) ; } return ; } } } int piData = piDataLength == 0 ? StringPool . EMPTY_STRING : fEntityReader . addString ( piDataOffset , piDataLength ) ; fDTDGrammar . callProcessingInstruction ( piTarget , piData ) ; if ( fDTDHandler != null ) { fDTDHandler . processingInstruction ( piTarget , piData ) ; } } public boolean scanDoctypeDecl ( ) throws Exception { fDTDGrammar = new DTDGrammar ( fStringPool ) ; fDTDGrammar . callStartDTD ( ) ; increaseMarkupDepth ( ) ; fEntityReader = fEntityHandler . getEntityReader ( ) ; fReaderId = fEntityHandler . getReaderId ( ) ; fDoctypeReader = fReaderId ; setScannerState ( SCANNER_STATE_DOCTYPEDECL ) ; if ( ! fEntityReader . lookingAtSpace ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL , XMLMessages . P28_SPACE_REQUIRED ) ; return false ; } fEntityReader . skipPastSpaces ( ) ; scanElementType ( fEntityReader , ' ' , fElementQName ) ; if ( fElementQName . rawname == - 1 ) { abortMarkup ( XMLMessages . MSG_ROOT_ELEMENT_TYPE_REQUIRED , XMLMessages . P28_ROOT_ELEMENT_TYPE_REQUIRED ) ; return false ; } boolean lbrkt ; boolean scanExternalSubset = false ; int publicId = - 1 ; int systemId = - 1 ; if ( fEntityReader . lookingAtSpace ( true ) ) { fEntityReader . skipPastSpaces ( ) ; if ( ! ( lbrkt = fEntityReader . lookingAtChar ( '[' , true ) ) && ! fEntityReader . lookingAtChar ( '>' , false ) ) { if ( ! scanExternalID ( false ) ) { skipPastEndOfCurrentMarkup ( ) ; return false ; } scanExternalSubset = true ; publicId = fPubidLiteral ; systemId = fSystemLiteral ; fEntityReader . skipPastSpaces ( ) ; lbrkt = fEntityReader . lookingAtChar ( '[' , true ) ; } } else lbrkt = fEntityReader . lookingAtChar ( '[' , true ) ; fDTDGrammar . doctypeDecl ( fElementQName , publicId , systemId ) ; if ( fDTDHandler != null ) { fDTDHandler . startDTD ( fElementQName , publicId , systemId ) ; } if ( lbrkt ) { scanDecls ( false ) ; fEntityReader . skipPastSpaces ( ) ; } if ( ! fEntityReader . lookingAtChar ( '>' , true ) ) { if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { abortMarkup ( XMLMessages . MSG_DOCTYPEDECL_UNTERMINATED , XMLMessages . P28_UNTERMINATED , fElementQName . rawname ) ; } return false ; } decreaseMarkupDepth ( ) ; if ( scanExternalSubset ) { ( ( DefaultEntityHandler ) fEntityHandler ) . startReadingFromExternalSubset ( fStringPool . toString ( publicId ) , fStringPool . toString ( systemId ) , markupDepth ( ) ) ; fDTDGrammar . startReadingFromExternalSubset ( publicId , systemId ) ; } else { fDTDGrammar . callEndDTD ( ) ; if ( fDTDHandler != null ) { fDTDHandler . endDTD ( ) ; } } fGrammarResolver . putGrammar ( "" , fDTDGrammar ) ; return true ; } private boolean scanExternalID ( boolean scanPublicID ) throws Exception { fSystemLiteral = - 1 ; fPubidLiteral = - 1 ; int offset = fEntityReader . currentOffset ( ) ; if ( fEntityReader . skippedString ( system_string ) ) { if ( ! fEntityReader . lookingAtSpace ( true ) ) { reportFatalXMLError ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_SYSTEMLITERAL_IN_EXTERNALID , XMLMessages . P75_SPACE_REQUIRED ) ; return false ; } fEntityReader . skipPastSpaces ( ) ; if ( getReadingExternalEntity ( ) == true ) { checkForPEReference ( false ) ; } return scanSystemLiteral ( ) ; } if ( fEntityReader . skippedString ( public_string ) ) { if ( ! fEntityReader . lookingAtSpace ( true ) ) { reportFatalXMLError ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_PUBIDLITERAL_IN_EXTERNALID , XMLMessages . P75_SPACE_REQUIRED ) ; return false ; } fEntityReader . skipPastSpaces ( ) ; if ( ! scanPubidLiteral ( ) ) return false ; if ( scanPublicID ) { if ( ! fEntityReader . lookingAtSpace ( true ) ) return true ; fEntityReader . skipPastSpaces ( ) ; if ( fEntityReader . lookingAtChar ( '>' , false ) ) return true ; } else { if ( ! fEntityReader . lookingAtSpace ( true ) ) { reportFatalXMLError ( XMLMessages . MSG_SPACE_REQUIRED_AFTER_PUBIDLITERAL_IN_EXTERNALID , XMLMessages . P75_SPACE_REQUIRED ) ; return false ; } fEntityReader . skipPastSpaces ( ) ; } return scanSystemLiteral ( ) ; } reportFatalXMLError ( XMLMessages . MSG_EXTERNALID_REQUIRED , XMLMessages . P75_INVALID ) ; return false ; } private boolean scanSystemLiteral ( ) throws Exception { boolean single ; if ( ! ( single = fEntityReader . lookingAtChar ( '\'' , true ) ) && ! fEntityReader . lookingAtChar ( '\"' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_QUOTE_REQUIRED_IN_SYSTEMID , XMLMessages . P11_QUOTE_REQUIRED ) ; return false ; } int prevState = setScannerState ( SCANNER_STATE_SYSTEMLITERAL ) ; int offset = fEntityReader . currentOffset ( ) ; char qchar = single ? '\'' : '\"' ; boolean dataok = true ; boolean fragment = false ; while ( ! fEntityReader . lookingAtChar ( qchar , false ) ) { if ( fEntityReader . lookingAtChar ( '#' , true ) ) { fragment = true ; } else if ( ! fEntityReader . lookingAtValidChar ( true ) ) { dataok = false ; int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState == SCANNER_STATE_END_OF_INPUT ) return false ; if ( invChar >= 0 ) { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_SYSTEMID , XMLMessages . P11_INVALID_CHARACTER , Integer . toHexString ( invChar ) ) ; } } } if ( dataok ) { fSystemLiteral = fEntityReader . addString ( offset , fEntityReader . currentOffset ( ) - offset ) ; if ( fragment ) { Object [ ] args = { fStringPool . toString ( fSystemLiteral ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_URI_FRAGMENT_IN_SYSTEMID , XMLMessages . P11_URI_FRAGMENT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } fEntityReader . lookingAtChar ( qchar , true ) ; restoreScannerState ( prevState ) ; return dataok ; } private boolean scanPubidLiteral ( ) throws Exception { boolean single ; if ( ! ( single = fEntityReader . lookingAtChar ( '\'' , true ) ) && ! fEntityReader . lookingAtChar ( '\"' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_QUOTE_REQUIRED_IN_PUBLICID , XMLMessages . P12_QUOTE_REQUIRED ) ; return false ; } char qchar = single ? '\'' : '\"' ; int prevState = setScannerState ( SCANNER_STATE_PUBIDLITERAL ) ; boolean dataok = true ; while ( true ) { if ( fEntityReader . lookingAtChar ( ( char ) 0x09 , true ) ) { dataok = false ; reportFatalXMLError ( XMLMessages . MSG_PUBIDCHAR_ILLEGAL , XMLMessages . P12_INVALID_CHARACTER , "9" ) ; } if ( ! fEntityReader . lookingAtSpace ( true ) ) break ; } int offset = fEntityReader . currentOffset ( ) ; int dataOffset = fLiteralData . length ( ) ; int toCopy = offset ; while ( true ) { if ( fEntityReader . lookingAtChar ( qchar , true ) ) { if ( dataok && offset - toCopy > 0 ) fEntityReader . append ( fLiteralData , toCopy , offset - toCopy ) ; break ; } if ( fEntityReader . lookingAtChar ( ( char ) 0x09 , true ) ) { dataok = false ; reportFatalXMLError ( XMLMessages . MSG_PUBIDCHAR_ILLEGAL , XMLMessages . P12_INVALID_CHARACTER , "9" ) ; continue ; } if ( fEntityReader . lookingAtSpace ( true ) ) { if ( dataok && offset - toCopy > 0 ) fEntityReader . append ( fLiteralData , toCopy , offset - toCopy ) ; while ( true ) { if ( fEntityReader . lookingAtChar ( ( char ) 0x09 , true ) ) { dataok = false ; reportFatalXMLError ( XMLMessages . MSG_PUBIDCHAR_ILLEGAL , XMLMessages . P12_INVALID_CHARACTER , "9" ) ; break ; } else if ( ! fEntityReader . lookingAtSpace ( true ) ) { break ; } } if ( fEntityReader . lookingAtChar ( qchar , true ) ) break ; if ( dataok ) { fLiteralData . append ( ' ' ) ; offset = fEntityReader . currentOffset ( ) ; toCopy = offset ; } continue ; } if ( ! fEntityReader . lookingAtValidChar ( true ) ) { int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState == SCANNER_STATE_END_OF_INPUT ) return false ; dataok = false ; if ( invChar >= 0 ) { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_PUBLICID , XMLMessages . P12_INVALID_CHARACTER , Integer . toHexString ( invChar ) ) ; } } if ( dataok ) offset = fEntityReader . currentOffset ( ) ; } if ( dataok ) { int dataLength = fLiteralData . length ( ) - dataOffset ; fPubidLiteral = fLiteralData . addString ( dataOffset , dataLength ) ; String publicId = fStringPool . toString ( fPubidLiteral ) ; int invCharIndex = validPublicId ( publicId ) ; if ( invCharIndex >= 0 ) { reportFatalXMLError ( XMLMessages . MSG_PUBIDCHAR_ILLEGAL , XMLMessages . P12_INVALID_CHARACTER , Integer . toHexString ( publicId . charAt ( invCharIndex ) ) ) ; return false ; } } restoreScannerState ( prevState ) ; return dataok ; } public void scanDecls ( boolean extSubset ) throws Exception { int subsetOffset = fEntityReader . currentOffset ( ) ; if ( extSubset ) fExternalSubsetReader = fReaderId ; fIncludeSectDepth = 0 ; boolean parseTextDecl = extSubset ; int prevState = setScannerState ( SCANNER_STATE_MARKUP_DECL ) ; while ( fScannerState == SCANNER_STATE_MARKUP_DECL ) { boolean newParseTextDecl = false ; if ( ! extSubset && fEntityReader . lookingAtChar ( ']' , false ) ) { int subsetLength = fEntityReader . currentOffset ( ) - subsetOffset ; int internalSubset = fEntityReader . addString ( subsetOffset , subsetLength ) ; fDTDGrammar . internalSubset ( internalSubset ) ; if ( fDTDHandler != null ) { fDTDHandler . internalSubset ( internalSubset ) ; } fEntityReader . lookingAtChar ( ']' , true ) ; restoreScannerState ( prevState ) ; return ; } if ( fEntityReader . lookingAtChar ( '<' , true ) ) { int olddepth = markupDepth ( ) ; increaseMarkupDepth ( ) ; if ( fEntityReader . lookingAtChar ( '!' , true ) ) { if ( fEntityReader . lookingAtChar ( '-' , true ) ) { if ( fEntityReader . lookingAtChar ( '-' , true ) ) { scanComment ( ) ; } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_DTD , XMLMessages . P29_NOT_RECOGNIZED ) ; } } else if ( fEntityReader . lookingAtChar ( '[' , true ) && getReadingExternalEntity ( ) ) { checkForPEReference ( false ) ; if ( fEntityReader . skippedString ( include_string ) ) { checkForPEReference ( false ) ; if ( ! fEntityReader . lookingAtChar ( '[' , true ) ) { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_DTD , XMLMessages . P29_NOT_RECOGNIZED ) ; } else { fIncludeSectDepth ++ ; } } else if ( fEntityReader . skippedString ( ignore_string ) ) { checkForPEReference ( false ) ; if ( ! fEntityReader . lookingAtChar ( '[' , true ) ) { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_DTD , XMLMessages . P29_NOT_RECOGNIZED ) ; } else scanIgnoreSectContents ( ) ; } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_DTD , XMLMessages . P29_NOT_RECOGNIZED ) ; } } else if ( fEntityReader . skippedString ( element_string ) ) { scanElementDecl ( ) ; } else if ( fEntityReader . skippedString ( attlist_string ) ) scanAttlistDecl ( ) ; else if ( fEntityReader . skippedString ( entity_string ) ) scanEntityDecl ( ) ; else if ( fEntityReader . skippedString ( notation_string ) ) scanNotationDecl ( ) ; else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_DTD , XMLMessages . P29_NOT_RECOGNIZED ) ; } } else if ( fEntityReader . lookingAtChar ( '?' , true ) ) { int piTarget = fEntityReader . scanName ( ' ' ) ; if ( piTarget == - 1 ) { abortMarkup ( XMLMessages . MSG_PITARGET_REQUIRED , XMLMessages . P16_REQUIRED ) ; } else if ( "xml" . equals ( fStringPool . toString ( piTarget ) ) ) { if ( fEntityReader . lookingAtSpace ( true ) ) { if ( parseTextDecl ) { scanTextDecl ( ) ; } else { abortMarkup ( XMLMessages . MSG_TEXTDECL_MUST_BE_FIRST , XMLMessages . P30_TEXTDECL_MUST_BE_FIRST ) ; } } else { abortMarkup ( XMLMessages . MSG_RESERVED_PITARGET , XMLMessages . P17_RESERVED_PITARGET ) ; } } else scanPI ( piTarget ) ; } else { abortMarkup ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_DTD , XMLMessages . P29_NOT_RECOGNIZED ) ; } } else if ( fEntityReader . lookingAtSpace ( true ) ) { fEntityReader . skipPastSpaces ( ) ; } else if ( fEntityReader . lookingAtChar ( '%' , true ) ) { int nameOffset = fEntityReader . currentOffset ( ) ; fEntityReader . skipPastName ( ';' ) ; int nameLength = fEntityReader . currentOffset ( ) - nameOffset ; if ( nameLength == 0 ) { reportFatalXMLError ( XMLMessages . MSG_NAME_REQUIRED_IN_PEREFERENCE , XMLMessages . P69_NAME_REQUIRED ) ; } else if ( ! fEntityReader . lookingAtChar ( ';' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_SEMICOLON_REQUIRED_IN_PEREFERENCE , XMLMessages . P69_SEMICOLON_REQUIRED , fEntityReader . addString ( nameOffset , nameLength ) ) ; } else { int peNameIndex = fEntityReader . addSymbol ( nameOffset , nameLength ) ; newParseTextDecl = fEntityHandler . startReadingFromEntity ( peNameIndex , markupDepth ( ) , XMLEntityHandler . ENTITYREF_IN_DTD_AS_MARKUP ) ; } } else if ( fIncludeSectDepth > 0 && fEntityReader . lookingAtChar ( ']' , true ) ) { if ( ! fEntityReader . lookingAtChar ( ']' , true ) || ! fEntityReader . lookingAtChar ( '>' , true ) ) { abortMarkup ( XMLMessages . MSG_INCLUDESECT_UNTERMINATED , XMLMessages . P62_UNTERMINATED ) ; } else decreaseMarkupDepth ( ) ; fIncludeSectDepth -- ; } else { if ( ! fEntityReader . lookingAtValidChar ( false ) ) { int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState == SCANNER_STATE_END_OF_INPUT ) break ; if ( invChar >= 0 ) { if ( ! extSubset ) { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_INTERNAL_SUBSET , XMLMessages . P28_INVALID_CHARACTER , Integer . toHexString ( invChar ) ) ; } else { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_EXTERNAL_SUBSET , XMLMessages . P30_INVALID_CHARACTER , Integer . toHexString ( invChar ) ) ; } } } else { reportFatalXMLError ( XMLMessages . MSG_MARKUP_NOT_RECOGNIZED_IN_DTD , XMLMessages . P29_NOT_RECOGNIZED ) ; fEntityReader . lookingAtValidChar ( true ) ; } } parseTextDecl = newParseTextDecl ; } if ( extSubset ) { ( ( DefaultEntityHandler ) fEntityHandler ) . stopReadingFromExternalSubset ( ) ; fDTDGrammar . stopReadingFromExternalSubset ( ) ; fDTDGrammar . callEndDTD ( ) ; if ( fDTDHandler != null ) { fDTDHandler . endDTD ( ) ; } fGrammarResolver . putGrammar ( "" , fDTDGrammar ) ; } } private void scanIgnoreSectContents ( ) throws Exception { int initialDepth = ++ fIncludeSectDepth ; while ( true ) { if ( fEntityReader . lookingAtChar ( '<' , true ) ) { if ( fEntityReader . lookingAtChar ( '!' , true ) && fEntityReader . lookingAtChar ( '[' , true ) ) fIncludeSectDepth ++ ; } else if ( fEntityReader . lookingAtChar ( ']' , true ) ) { if ( fEntityReader . lookingAtChar ( ']' , true ) ) { while ( fEntityReader . lookingAtChar ( ']' , true ) ) { } if ( fEntityReader . lookingAtChar ( '>' , true ) ) { if ( fIncludeSectDepth -- == initialDepth ) { decreaseMarkupDepth ( ) ; return ; } } } } else if ( ! fEntityReader . lookingAtValidChar ( true ) ) { int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState == SCANNER_STATE_END_OF_INPUT ) return ; if ( invChar >= 0 ) { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_IGNORESECT , XMLMessages . P65_INVALID_CHARACTER , Integer . toHexString ( invChar ) ) ; } } } } private void scanTextDecl ( ) throws Exception { int version = - 1 ; int encoding = - 1 ; final int TEXTDECL_START = 0 ; final int TEXTDECL_VERSION = 1 ; final int TEXTDECL_ENCODING = 2 ; final int TEXTDECL_FINISHED = 3 ; int prevState = setScannerState ( SCANNER_STATE_TEXTDECL ) ; int state = TEXTDECL_START ; do { fEntityReader . skipPastSpaces ( ) ; int offset = fEntityReader . currentOffset ( ) ; if ( state == TEXTDECL_START && fEntityReader . skippedString ( version_string ) ) { state = TEXTDECL_VERSION ; } else if ( fEntityReader . skippedString ( encoding_string ) ) { state = TEXTDECL_ENCODING ; } else { abortMarkup ( XMLMessages . MSG_ENCODINGDECL_REQUIRED , XMLMessages . P77_ENCODINGDECL_REQUIRED ) ; restoreScannerState ( prevState ) ; return ; } int length = fEntityReader . currentOffset ( ) - offset ; fEntityReader . skipPastSpaces ( ) ; if ( ! fEntityReader . lookingAtChar ( '=' , true ) ) { int minorCode = state == TEXTDECL_VERSION ? XMLMessages . P24_EQ_REQUIRED : XMLMessages . P80_EQ_REQUIRED ; abortMarkup ( XMLMessages . MSG_EQ_REQUIRED_IN_TEXTDECL , minorCode , fEntityReader . addString ( offset , length ) ) ; restoreScannerState ( prevState ) ; return ; } fEntityReader . skipPastSpaces ( ) ; int result = fEntityReader . scanStringLiteral ( ) ; switch ( result ) { case XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED : { int minorCode = state == TEXTDECL_VERSION ? XMLMessages . P24_QUOTE_REQUIRED : XMLMessages . P80_QUOTE_REQUIRED ; abortMarkup ( XMLMessages . MSG_QUOTE_REQUIRED_IN_TEXTDECL , minorCode , fEntityReader . addString ( offset , length ) ) ; restoreScannerState ( prevState ) ; return ; } case XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR : int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState != SCANNER_STATE_END_OF_INPUT ) { if ( invChar >= 0 ) { int minorCode = state == TEXTDECL_VERSION ? XMLMessages . P26_INVALID_CHARACTER : XMLMessages . P81_INVALID_CHARACTER ; reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_TEXTDECL , minorCode , Integer . toHexString ( invChar ) ) ; } skipPastEndOfCurrentMarkup ( ) ; restoreScannerState ( prevState ) ; } return ; default : break ; } switch ( state ) { case TEXTDECL_VERSION : version = result ; String versionString = fStringPool . toString ( version ) ; if ( ! "1.0" . equals ( versionString ) ) { if ( ! validVersionNum ( versionString ) ) { abortMarkup ( XMLMessages . MSG_VERSIONINFO_INVALID , XMLMessages . P26_INVALID_VALUE , versionString ) ; restoreScannerState ( prevState ) ; return ; } Object [ ] args = { versionString } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_VERSION_NOT_SUPPORTED , XMLMessages . P26_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( ! fEntityReader . lookingAtSpace ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_IN_TEXTDECL , XMLMessages . P80_WHITESPACE_REQUIRED ) ; restoreScannerState ( prevState ) ; return ; } break ; case TEXTDECL_ENCODING : encoding = result ; String encodingString = fStringPool . toString ( encoding ) ; if ( ! validEncName ( encodingString ) ) { abortMarkup ( XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , encodingString ) ; restoreScannerState ( prevState ) ; return ; } fEntityReader . skipPastSpaces ( ) ; state = TEXTDECL_FINISHED ; break ; } } while ( state != TEXTDECL_FINISHED ) ; if ( ! fEntityReader . lookingAtChar ( '?' , true ) || ! fEntityReader . lookingAtChar ( '>' , true ) ) { abortMarkup ( XMLMessages . MSG_TEXTDECL_UNTERMINATED , XMLMessages . P77_UNTERMINATED ) ; restoreScannerState ( prevState ) ; return ; } decreaseMarkupDepth ( ) ; fDTDGrammar . callTextDecl ( version , encoding ) ; if ( fDTDHandler != null ) { fDTDHandler . textDecl ( version , encoding ) ; } restoreScannerState ( prevState ) ; } private QName fElementDeclQName = new QName ( ) ; private void scanElementDecl ( ) throws Exception { if ( ! checkForPEReference ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL , XMLMessages . P45_SPACE_REQUIRED ) ; return ; } checkForElementTypeWithPEReference ( fEntityReader , ' ' , fElementQName ) ; if ( fElementQName . rawname == - 1 ) { abortMarkup ( XMLMessages . MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL , XMLMessages . P45_ELEMENT_TYPE_REQUIRED ) ; return ; } if ( fDTDHandler != null ) { fElementDeclQName . setValues ( fElementQName ) ; } if ( ! checkForPEReference ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL , XMLMessages . P45_SPACE_REQUIRED , fElementQName . rawname ) ; return ; } int contentSpecType = - 1 ; int contentSpec = - 1 ; if ( fEntityReader . skippedString ( empty_string ) ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; } else if ( fEntityReader . skippedString ( any_string ) ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } else if ( ! fEntityReader . lookingAtChar ( '(' , true ) ) { abortMarkup ( XMLMessages . MSG_CONTENTSPEC_REQUIRED_IN_ELEMENTDECL , XMLMessages . P45_CONTENTSPEC_REQUIRED , fElementQName . rawname ) ; return ; } else { int contentSpecReader = fReaderId ; int contentSpecReaderDepth = fEntityHandler . getReaderDepth ( ) ; int prevState = setScannerState ( SCANNER_STATE_CONTENTSPEC ) ; int oldDepth = parenDepth ( ) ; fEntityHandler . setReaderDepth ( oldDepth ) ; increaseParenDepth ( ) ; checkForPEReference ( false ) ; boolean skippedPCDATA = fEntityReader . skippedString ( pcdata_string ) ; if ( skippedPCDATA ) { contentSpecType = XMLElementDecl . TYPE_MIXED ; contentSpec = scanMixed ( fElementQName ) ; } else { contentSpecType = XMLElementDecl . TYPE_CHILDREN ; contentSpec = scanChildren ( fElementQName ) ; } boolean success = contentSpec != - 1 ; restoreScannerState ( prevState ) ; fEntityHandler . setReaderDepth ( contentSpecReaderDepth ) ; if ( ! success ) { setParenDepth ( oldDepth ) ; skipPastEndOfCurrentMarkup ( ) ; return ; } else { if ( parenDepth ( ) != oldDepth ) ; } } checkForPEReference ( false ) ; if ( ! fEntityReader . lookingAtChar ( '>' , true ) ) { abortMarkup ( XMLMessages . MSG_ELEMENTDECL_UNTERMINATED , XMLMessages . P45_UNTERMINATED , fElementQName . rawname ) ; return ; } decreaseMarkupDepth ( ) ; int elementIndex = fDTDGrammar . getElementDeclIndex ( fElementQName , - 1 ) ; boolean elementDeclIsExternal = getReadingExternalEntity ( ) ; if ( elementIndex == - 1 ) { elementIndex = fDTDGrammar . addElementDecl ( fElementQName , contentSpecType , contentSpec , elementDeclIsExternal ) ; } else { fDTDGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; if ( fTempElementDecl . type == - 1 ) { fTempElementDecl . type = contentSpecType ; fTempElementDecl . contentSpecIndex = contentSpec ; fDTDGrammar . setElementDeclDTD ( elementIndex , fTempElementDecl ) ; fDTDGrammar . setElementDeclIsExternal ( elementIndex , elementDeclIsExternal ) ; } else { if ( fValidationEnabled ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_ALREADY_DECLARED , XMLMessages . VC_UNIQUE_ELEMENT_TYPE_DECLARATION , fStringPool . toString ( fElementQName . rawname ) ) ; } } } if ( fDTDHandler != null ) { fDTDGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; fDTDHandler . elementDecl ( fElementDeclQName , contentSpecType , contentSpec , fDTDGrammar ) ; } } private int scanMixed ( QName element ) throws Exception { int valueIndex = - 1 ; int prevNodeIndex = - 1 ; boolean starRequired = false ; int [ ] valueSeen = new int [ 32 ] ; int valueCount = 0 ; boolean dupAttrType = false ; int nodeIndex = - 1 ; while ( true ) { if ( fValidationEnabled ) { for ( int i = 0 ; i < valueCount ; i ++ ) { if ( valueSeen [ i ] == valueIndex ) { dupAttrType = true ; break ; } } } if ( dupAttrType && fValidationEnabled ) { reportRecoverableXMLError ( XMLMessages . MSG_DUPLICATE_TYPE_IN_MIXED_CONTENT , XMLMessages . VC_NO_DUPLICATE_TYPES , valueIndex ) ; dupAttrType = false ; } else { try { valueSeen [ valueCount ] = valueIndex ; } catch ( ArrayIndexOutOfBoundsException ae ) { int [ ] newArray = new int [ valueSeen . length * 2 ] ; System . arraycopy ( valueSeen , 0 , newArray , 0 , valueSeen . length ) ; valueSeen = newArray ; valueSeen [ valueCount ] = valueIndex ; } valueCount ++ ; nodeIndex = fDTDGrammar . addUniqueLeafNode ( valueIndex ) ; } checkForPEReference ( false ) ; if ( ! fEntityReader . lookingAtChar ( '|' , true ) ) { if ( ! fEntityReader . lookingAtChar ( ')' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_CLOSE_PAREN_REQUIRED_IN_MIXED , XMLMessages . P51_CLOSE_PAREN_REQUIRED , element . rawname ) ; return - 1 ; } decreaseParenDepth ( ) ; if ( nodeIndex == - 1 ) { nodeIndex = prevNodeIndex ; } else if ( prevNodeIndex != - 1 ) { nodeIndex = fDTDGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , prevNodeIndex , nodeIndex ) ; } if ( fEntityReader . lookingAtChar ( '*' , true ) ) { nodeIndex = fDTDGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , nodeIndex ) ; } else if ( starRequired ) { reportFatalXMLError ( XMLMessages . MSG_MIXED_CONTENT_UNTERMINATED , XMLMessages . P51_UNTERMINATED , fStringPool . toString ( element . rawname ) , fDTDGrammar . getContentSpecNodeAsString ( nodeIndex ) ) ; return - 1 ; } return nodeIndex ; } if ( nodeIndex != - 1 ) { if ( prevNodeIndex != - 1 ) { nodeIndex = fDTDGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , prevNodeIndex , nodeIndex ) ; } prevNodeIndex = nodeIndex ; } starRequired = true ; checkForPEReference ( false ) ; checkForElementTypeWithPEReference ( fEntityReader , ')' , fElementRefQName ) ; valueIndex = fElementRefQName . rawname ; if ( valueIndex == - 1 ) { reportFatalXMLError ( XMLMessages . MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT , XMLMessages . P51_ELEMENT_TYPE_REQUIRED , element . rawname ) ; return - 1 ; } } } private int scanChildren ( QName element ) throws Exception { int depth = 1 ; initializeContentModelStack ( depth ) ; while ( true ) { if ( fEntityReader . lookingAtChar ( '(' , true ) ) { increaseParenDepth ( ) ; checkForPEReference ( false ) ; depth ++ ; initializeContentModelStack ( depth ) ; continue ; } checkForElementTypeWithPEReference ( fEntityReader , ')' , fElementRefQName ) ; int valueIndex = fElementRefQName . rawname ; if ( valueIndex == - 1 ) { reportFatalXMLError ( XMLMessages . MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN , XMLMessages . P47_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED , element . rawname ) ; return - 1 ; } fNodeIndexStack [ depth ] = fDTDGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , valueIndex ) ; if ( fEntityReader . lookingAtChar ( '?' , true ) ) { fNodeIndexStack [ depth ] = fDTDGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , fNodeIndexStack [ depth ] ) ; } else if ( fEntityReader . lookingAtChar ( '*' , true ) ) { fNodeIndexStack [ depth ] = fDTDGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , fNodeIndexStack [ depth ] ) ; } else if ( fEntityReader . lookingAtChar ( '+' , true ) ) { fNodeIndexStack [ depth ] = fDTDGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , fNodeIndexStack [ depth ] ) ; } while ( true ) { checkForPEReference ( false ) ; if ( fOpStack [ depth ] != XMLContentSpec . CONTENTSPECNODE_SEQ && fEntityReader . lookingAtChar ( '|' , true ) ) { if ( fPrevNodeIndexStack [ depth ] != - 1 ) { fNodeIndexStack [ depth ] = fDTDGrammar . addContentSpecNode ( fOpStack [ depth ] , fPrevNodeIndexStack [ depth ] , fNodeIndexStack [ depth ] ) ; } fPrevNodeIndexStack [ depth ] = fNodeIndexStack [ depth ] ; fOpStack [ depth ] = XMLContentSpec . CONTENTSPECNODE_CHOICE ; break ; } else if ( fOpStack [ depth ] != XMLContentSpec . CONTENTSPECNODE_CHOICE && fEntityReader . lookingAtChar ( ',' , true ) ) { if ( fPrevNodeIndexStack [ depth ] != - 1 ) { fNodeIndexStack [ depth ] = fDTDGrammar . addContentSpecNode ( fOpStack [ depth ] , fPrevNodeIndexStack [ depth ] , fNodeIndexStack [ depth ] ) ; } fPrevNodeIndexStack [ depth ] = fNodeIndexStack [ depth ] ; fOpStack [ depth ] = XMLContentSpec . CONTENTSPECNODE_SEQ ; break ; } else { if ( ! fEntityReader . lookingAtChar ( ')' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN , XMLMessages . P47_CLOSE_PAREN_REQUIRED , element . rawname ) ; } decreaseParenDepth ( ) ; if ( fPrevNodeIndexStack [ depth ] != - 1 ) { fNodeIndexStack [ depth ] = fDTDGrammar . addContentSpecNode ( fOpStack [ depth ] , fPrevNodeIndexStack [ depth ] , fNodeIndexStack [ depth ] ) ; } int nodeIndex = fNodeIndexStack [ depth -- ] ; fNodeIndexStack [ depth ] = nodeIndex ; if ( fEntityReader . lookingAtChar ( '?' , true ) ) { fNodeIndexStack [ depth ] = fDTDGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , fNodeIndexStack [ depth ] ) ; } else if ( fEntityReader . lookingAtChar ( '*' , true ) ) { fNodeIndexStack [ depth ] = fDTDGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , fNodeIndexStack [ depth ] ) ; } else if ( fEntityReader . lookingAtChar ( '+' , true ) ) { fNodeIndexStack [ depth ] = fDTDGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , fNodeIndexStack [ depth ] ) ; } if ( depth == 0 ) { return fNodeIndexStack [ 0 ] ; } } } checkForPEReference ( false ) ; } } private void scanAttlistDecl ( ) throws Exception { if ( ! checkForPEReference ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL , XMLMessages . P52_SPACE_REQUIRED ) ; return ; } checkForElementTypeWithPEReference ( fEntityReader , ' ' , fElementQName ) ; int elementTypeIndex = fElementQName . rawname ; if ( elementTypeIndex == - 1 ) { abortMarkup ( XMLMessages . MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL , XMLMessages . P52_ELEMENT_TYPE_REQUIRED ) ; return ; } int elementIndex = fDTDGrammar . getElementDeclIndex ( fElementQName , - 1 ) ; if ( elementIndex == - 1 ) { elementIndex = fDTDGrammar . addElementDecl ( fElementQName ) ; } boolean sawSpace = checkForPEReference ( true ) ; if ( fEntityReader . lookingAtChar ( '>' , true ) ) { decreaseMarkupDepth ( ) ; return ; } if ( ! sawSpace ) { if ( fEntityReader . lookingAtSpace ( true ) ) { fEntityReader . skipPastSpaces ( ) ; } else reportFatalXMLError ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF , XMLMessages . P53_SPACE_REQUIRED ) ; } else { if ( fEntityReader . lookingAtSpace ( true ) ) { fEntityReader . skipPastSpaces ( ) ; } } if ( fEntityReader . lookingAtChar ( '>' , true ) ) { decreaseMarkupDepth ( ) ; return ; } while ( true ) { checkForAttributeNameWithPEReference ( fEntityReader , ' ' , fAttributeQName ) ; int attDefName = fAttributeQName . rawname ; if ( attDefName == - 1 ) { abortMarkup ( XMLMessages . MSG_ATTRIBUTE_NAME_REQUIRED_IN_ATTDEF , XMLMessages . P53_NAME_REQUIRED , fElementQName . rawname ) ; return ; } if ( ! checkForPEReference ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF , XMLMessages . P53_SPACE_REQUIRED ) ; return ; } int attDefType = - 1 ; boolean attDefList = false ; int attDefEnumeration = - 1 ; if ( fEntityReader . skippedString ( cdata_string ) ) { attDefType = XMLAttributeDecl . TYPE_CDATA ; } else if ( fEntityReader . skippedString ( id_string ) ) { if ( ! fEntityReader . skippedString ( ref_string ) ) { attDefType = XMLAttributeDecl . TYPE_ID ; } else if ( ! fEntityReader . lookingAtChar ( 'S' , true ) ) { attDefType = XMLAttributeDecl . TYPE_IDREF ; } else { attDefType = XMLAttributeDecl . TYPE_IDREF ; attDefList = true ; } } else if ( fEntityReader . skippedString ( entit_string ) ) { if ( fEntityReader . lookingAtChar ( 'Y' , true ) ) { attDefType = XMLAttributeDecl . TYPE_ENTITY ; } else if ( fEntityReader . skippedString ( ies_string ) ) { attDefType = XMLAttributeDecl . TYPE_ENTITY ; attDefList = true ; } else { abortMarkup ( XMLMessages . MSG_ATTTYPE_REQUIRED_IN_ATTDEF , XMLMessages . P53_ATTTYPE_REQUIRED , elementTypeIndex , attDefName ) ; return ; } } else if ( fEntityReader . skippedString ( nmtoken_string ) ) { if ( fEntityReader . lookingAtChar ( 'S' , true ) ) { attDefType = XMLAttributeDecl . TYPE_NMTOKEN ; attDefList = true ; } else { attDefType = XMLAttributeDecl . TYPE_NMTOKEN ; } } else if ( fEntityReader . skippedString ( notation_string ) ) { if ( ! checkForPEReference ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE , XMLMessages . P58_SPACE_REQUIRED , elementTypeIndex , attDefName ) ; return ; } if ( ! fEntityReader . lookingAtChar ( '(' , true ) ) { abortMarkup ( XMLMessages . MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE , XMLMessages . P58_OPEN_PAREN_REQUIRED , elementTypeIndex , attDefName ) ; return ; } increaseParenDepth ( ) ; attDefType = XMLAttributeDecl . TYPE_NOTATION ; attDefEnumeration = scanEnumeration ( elementTypeIndex , attDefName , true ) ; if ( attDefEnumeration == - 1 ) { skipPastEndOfCurrentMarkup ( ) ; return ; } } else if ( fEntityReader . lookingAtChar ( '(' , true ) ) { increaseParenDepth ( ) ; attDefType = XMLAttributeDecl . TYPE_ENUMERATION ; attDefEnumeration = scanEnumeration ( elementTypeIndex , attDefName , false ) ; if ( attDefEnumeration == - 1 ) { skipPastEndOfCurrentMarkup ( ) ; return ; } } else { abortMarkup ( XMLMessages . MSG_ATTTYPE_REQUIRED_IN_ATTDEF , XMLMessages . P53_ATTTYPE_REQUIRED , elementTypeIndex , attDefName ) ; return ; } if ( ! checkForPEReference ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF , XMLMessages . P53_SPACE_REQUIRED , elementTypeIndex , attDefName ) ; return ; } int attDefDefaultType = - 1 ; int attDefDefaultValue = - 1 ; if ( fEntityReader . skippedString ( required_string ) ) { attDefDefaultType = XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; } else if ( fEntityReader . skippedString ( implied_string ) ) { attDefDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } else { if ( fEntityReader . skippedString ( fixed_string ) ) { if ( ! fEntityReader . lookingAtSpace ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL , XMLMessages . P60_SPACE_REQUIRED , elementTypeIndex , attDefName ) ; return ; } fEntityReader . skipPastSpaces ( ) ; attDefDefaultType = XMLAttributeDecl . DEFAULT_TYPE_FIXED ; } else attDefDefaultType = XMLAttributeDecl . DEFAULT_TYPE_DEFAULT ; attDefDefaultValue = scanDefaultAttValue ( fElementQName , fAttributeQName , attDefType , attDefEnumeration ) ; if ( attDefDefaultValue != - 1 && attDefType != XMLAttributeDecl . TYPE_CDATA ) { attDefDefaultValue = normalizeDefaultAttValue ( fAttributeQName , attDefDefaultValue , attDefType , attDefEnumeration , attDefList ) ; } if ( attDefDefaultValue == - 1 ) { skipPastEndOfCurrentMarkup ( ) ; return ; } } if ( attDefName == fXMLSpace ) { boolean ok = false ; if ( attDefType == XMLAttributeDecl . TYPE_ENUMERATION ) { int index = attDefEnumeration ; if ( index != - 1 ) { ok = ( fStringPool . stringListLength ( index ) == 1 && ( fStringPool . stringInList ( index , fDefault ) || fStringPool . stringInList ( index , fPreserve ) ) ) || ( fStringPool . stringListLength ( index ) == 2 && fStringPool . stringInList ( index , fDefault ) && fStringPool . stringInList ( index , fPreserve ) ) ; } } if ( ! ok ) { reportFatalXMLError ( XMLMessages . MSG_XML_SPACE_DECLARATION_ILLEGAL , XMLMessages . S2_10_DECLARATION_ILLEGAL , elementTypeIndex ) ; } } sawSpace = checkForPEReference ( true ) ; if ( fAttributeQName . prefix == fXMLSymbol ) { fAttributeQName . uri = fXMLNamespace ; } if ( fEntityReader . lookingAtChar ( '>' , true ) ) { int attDefIndex = addAttDef ( fElementQName , fAttributeQName , attDefType , attDefList , attDefEnumeration , attDefDefaultType , attDefDefaultValue , getReadingExternalEntity ( ) ) ; decreaseMarkupDepth ( ) ; return ; } if ( ! sawSpace ) { if ( fEntityReader . lookingAtSpace ( true ) ) { fEntityReader . skipPastSpaces ( ) ; } else reportFatalXMLError ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF , XMLMessages . P53_SPACE_REQUIRED ) ; } else { if ( fEntityReader . lookingAtSpace ( true ) ) { fEntityReader . skipPastSpaces ( ) ; } } if ( fEntityReader . lookingAtChar ( '>' , true ) ) { int attDefIndex = addAttDef ( fElementQName , fAttributeQName , attDefType , attDefList , attDefEnumeration , attDefDefaultType , attDefDefaultValue , getReadingExternalEntity ( ) ) ; decreaseMarkupDepth ( ) ; return ; } int attDefIndex = addAttDef ( fElementQName , fAttributeQName , attDefType , attDefList , attDefEnumeration , attDefDefaultType , attDefDefaultValue , getReadingExternalEntity ( ) ) ; } } private int addAttDef ( QName element , QName attribute , int attDefType , boolean attDefList , int attDefEnumeration , int attDefDefaultType , int attDefDefaultValue , boolean isExternal ) throws Exception { if ( fDTDHandler != null ) { String enumString = attDefEnumeration != - 1 ? fStringPool . stringListAsString ( attDefEnumeration ) : null ; fDTDHandler . attlistDecl ( element , attribute , attDefType , attDefList , enumString , attDefDefaultType , attDefDefaultValue ) ; } int elementIndex = fDTDGrammar . getElementDeclIndex ( element , - 1 ) ; if ( elementIndex == - 1 ) { } else { int attlistIndex = fDTDGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int dupID = - 1 ; int dupNotation = - 1 ; while ( attlistIndex != - 1 ) { fDTDGrammar . getAttributeDecl ( attlistIndex , fTempAttributeDecl ) ; if ( fStringPool . equalNames ( fTempAttributeDecl . name . rawname , attribute . rawname ) ) { return - 1 ; } if ( fValidationEnabled ) { if ( attDefType == XMLAttributeDecl . TYPE_ID && fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ID ) { dupID = fTempAttributeDecl . name . rawname ; } if ( attDefType == XMLAttributeDecl . TYPE_NOTATION && fTempAttributeDecl . type == XMLAttributeDecl . TYPE_NOTATION ) { dupNotation = fTempAttributeDecl . name . rawname ; } } attlistIndex = fDTDGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } if ( fValidationEnabled ) { if ( dupID != - 1 ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( dupID ) , fStringPool . toString ( attribute . rawname ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_MORE_THAN_ONE_ID_ATTRIBUTE , XMLMessages . VC_ONE_ID_PER_ELEMENT_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; return - 1 ; } if ( dupNotation != - 1 ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( dupNotation ) , fStringPool . toString ( attribute . rawname ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_MORE_THAN_ONE_NOTATION_ATTRIBUTE , XMLMessages . VC_ONE_NOTATION_PER_ELEMENT_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; return - 1 ; } } } return fDTDGrammar . addAttDef ( element , attribute , attDefType , attDefList , attDefEnumeration , attDefDefaultType , attDefDefaultValue , isExternal ) ; } private int scanEnumeration ( int elementType , int attrName , boolean isNotationType ) throws Exception { int enumIndex = fDTDGrammar . startEnumeration ( ) ; while ( true ) { checkForPEReference ( false ) ; int nameIndex = isNotationType ? checkForNameWithPEReference ( fEntityReader , ')' ) : checkForNmtokenWithPEReference ( fEntityReader , ')' ) ; if ( nameIndex == - 1 ) { if ( isNotationType ) { reportFatalXMLError ( XMLMessages . MSG_NAME_REQUIRED_IN_NOTATIONTYPE , XMLMessages . P58_NAME_REQUIRED , elementType , attrName ) ; } else { reportFatalXMLError ( XMLMessages . MSG_NMTOKEN_REQUIRED_IN_ENUMERATION , XMLMessages . P59_NMTOKEN_REQUIRED , elementType , attrName ) ; } fDTDGrammar . endEnumeration ( enumIndex ) ; return - 1 ; } fDTDGrammar . addNameToEnumeration ( enumIndex , elementType , attrName , nameIndex , isNotationType ) ; if ( isNotationType && ! ( ( DefaultEntityHandler ) fEntityHandler ) . isNotationDeclared ( nameIndex ) ) { Object [ ] args = { fStringPool . toString ( elementType ) , fStringPool . toString ( attrName ) , fStringPool . toString ( nameIndex ) } ; ( ( DefaultEntityHandler ) fEntityHandler ) . addRequiredNotation ( nameIndex , fErrorReporter . getLocator ( ) , XMLMessages . MSG_NOTATION_NOT_DECLARED_FOR_NOTATIONTYPE_ATTRIBUTE , XMLMessages . VC_NOTATION_DECLARED , args ) ; } checkForPEReference ( false ) ; if ( ! fEntityReader . lookingAtChar ( '|' , true ) ) { fDTDGrammar . endEnumeration ( enumIndex ) ; if ( ! fEntityReader . lookingAtChar ( ')' , true ) ) { if ( isNotationType ) { reportFatalXMLError ( XMLMessages . MSG_NOTATIONTYPE_UNTERMINATED , XMLMessages . P58_UNTERMINATED , elementType , attrName ) ; } else { reportFatalXMLError ( XMLMessages . MSG_ENUMERATION_UNTERMINATED , XMLMessages . P59_UNTERMINATED , elementType , attrName ) ; } return - 1 ; } decreaseParenDepth ( ) ; return enumIndex ; } } } public int scanDefaultAttValue ( QName element , QName attribute ) throws Exception { boolean single ; if ( ! ( single = fEntityReader . lookingAtChar ( '\'' , true ) ) && ! fEntityReader . lookingAtChar ( '\"' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_QUOTE_REQUIRED_IN_ATTVALUE , XMLMessages . P10_QUOTE_REQUIRED , element . rawname , attribute . rawname ) ; return - 1 ; } int previousState = setScannerState ( SCANNER_STATE_DEFAULT_ATTRIBUTE_VALUE ) ; char qchar = single ? '\'' : '\"' ; fDefaultAttValueReader = fReaderId ; fDefaultAttValueElementType = element . rawname ; fDefaultAttValueAttrName = attribute . rawname ; boolean setMark = true ; int dataOffset = fLiteralData . length ( ) ; while ( true ) { fDefaultAttValueOffset = fEntityReader . currentOffset ( ) ; if ( setMark ) { fDefaultAttValueMark = fDefaultAttValueOffset ; setMark = false ; } if ( fEntityReader . lookingAtChar ( qchar , true ) ) { if ( fReaderId == fDefaultAttValueReader ) break ; continue ; } if ( fEntityReader . lookingAtChar ( ' ' , true ) ) { continue ; } boolean skippedCR ; if ( ( skippedCR = fEntityReader . lookingAtChar ( ( char ) 0x0D , true ) ) || fEntityReader . lookingAtSpace ( true ) ) { if ( fDefaultAttValueOffset - fDefaultAttValueMark > 0 ) fEntityReader . append ( fLiteralData , fDefaultAttValueMark , fDefaultAttValueOffset - fDefaultAttValueMark ) ; setMark = true ; fLiteralData . append ( ' ' ) ; if ( skippedCR ) fEntityReader . lookingAtChar ( ( char ) 0x0A , true ) ; continue ; } if ( fEntityReader . lookingAtChar ( '&' , true ) ) { if ( fDefaultAttValueOffset - fDefaultAttValueMark > 0 ) fEntityReader . append ( fLiteralData , fDefaultAttValueMark , fDefaultAttValueOffset - fDefaultAttValueMark ) ; setMark = true ; if ( fEntityReader . lookingAtChar ( '#' , true ) ) { int ch = scanCharRef ( ) ; if ( ch != - 1 ) { if ( ch < 0x10000 ) fLiteralData . append ( ( char ) ch ) ; else { fLiteralData . append ( ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ) ; fLiteralData . append ( ( char ) ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ) ; } } } else { int nameOffset = fEntityReader . currentOffset ( ) ; fEntityReader . skipPastName ( ';' ) ; int nameLength = fEntityReader . currentOffset ( ) - nameOffset ; if ( nameLength == 0 ) { reportFatalXMLError ( XMLMessages . MSG_NAME_REQUIRED_IN_REFERENCE , XMLMessages . P68_NAME_REQUIRED ) ; } else if ( ! fEntityReader . lookingAtChar ( ';' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_SEMICOLON_REQUIRED_IN_REFERENCE , XMLMessages . P68_SEMICOLON_REQUIRED , fEntityReader . addString ( nameOffset , nameLength ) ) ; } else { int entityNameIndex = fEntityReader . addSymbol ( nameOffset , nameLength ) ; fEntityHandler . startReadingFromEntity ( entityNameIndex , markupDepth ( ) , XMLEntityHandler . ENTITYREF_IN_DEFAULTATTVALUE ) ; } } continue ; } if ( fEntityReader . lookingAtChar ( '<' , true ) ) { if ( fDefaultAttValueOffset - fDefaultAttValueMark > 0 ) fEntityReader . append ( fLiteralData , fDefaultAttValueMark , fDefaultAttValueOffset - fDefaultAttValueMark ) ; setMark = true ; reportFatalXMLError ( XMLMessages . MSG_LESSTHAN_IN_ATTVALUE , XMLMessages . WFC_NO_LESSTHAN_IN_ATTVALUE , element . rawname , attribute . rawname ) ; continue ; } if ( ! getReadingExternalEntity ( ) && fEntityReader . lookingAtChar ( '%' , true ) ) { int nameOffset = fEntityReader . currentOffset ( ) ; fEntityReader . skipPastName ( ';' ) ; int nameLength = fEntityReader . currentOffset ( ) - nameOffset ; if ( nameLength != 0 && fEntityReader . lookingAtChar ( ';' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_PEREFERENCE_WITHIN_MARKUP , XMLMessages . WFC_PES_IN_INTERNAL_SUBSET , fEntityReader . addString ( nameOffset , nameLength ) ) ; } } if ( ! fEntityReader . lookingAtValidChar ( true ) ) { if ( fDefaultAttValueOffset - fDefaultAttValueMark > 0 ) fEntityReader . append ( fLiteralData , fDefaultAttValueMark , fDefaultAttValueOffset - fDefaultAttValueMark ) ; setMark = true ; int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState == SCANNER_STATE_END_OF_INPUT ) return - 1 ; if ( invChar >= 0 ) { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_ATTVALUE , XMLMessages . P10_INVALID_CHARACTER , fStringPool . toString ( element . rawname ) , fStringPool . toString ( attribute . rawname ) , Integer . toHexString ( invChar ) ) ; } continue ; } } restoreScannerState ( previousState ) ; int dataLength = fLiteralData . length ( ) - dataOffset ; if ( dataLength == 0 ) { return fEntityReader . addString ( fDefaultAttValueMark , fDefaultAttValueOffset - fDefaultAttValueMark ) ; } if ( fDefaultAttValueOffset - fDefaultAttValueMark > 0 ) { fEntityReader . append ( fLiteralData , fDefaultAttValueMark , fDefaultAttValueOffset - fDefaultAttValueMark ) ; dataLength = fLiteralData . length ( ) - dataOffset ; } return fLiteralData . addString ( dataOffset , dataLength ) ; } private void scanNotationDecl ( ) throws Exception { if ( ! checkForPEReference ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL , XMLMessages . P82_SPACE_REQUIRED ) ; return ; } int notationName = checkForNameWithPEReference ( fEntityReader , ' ' ) ; if ( notationName == - 1 ) { abortMarkup ( XMLMessages . MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL , XMLMessages . P82_NAME_REQUIRED ) ; return ; } if ( ! checkForPEReference ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL , XMLMessages . P82_SPACE_REQUIRED , notationName ) ; return ; } if ( ! scanExternalID ( true ) ) { skipPastEndOfCurrentMarkup ( ) ; return ; } checkForPEReference ( false ) ; if ( ! fEntityReader . lookingAtChar ( '>' , true ) ) { abortMarkup ( XMLMessages . MSG_NOTATIONDECL_UNTERMINATED , XMLMessages . P82_UNTERMINATED , notationName ) ; return ; } decreaseMarkupDepth ( ) ; int notationIndex = ( ( DefaultEntityHandler ) fEntityHandler ) . addNotationDecl ( notationName , fPubidLiteral , fSystemLiteral , getReadingExternalEntity ( ) ) ; fDTDGrammar . addNotationDecl ( notationName , fPubidLiteral , fSystemLiteral ) ; if ( fDTDHandler != null ) { fDTDHandler . notationDecl ( notationName , fPubidLiteral , fSystemLiteral ) ; } } private void scanEntityDecl ( ) throws Exception { boolean isPEDecl = false ; boolean sawPERef = false ; if ( fEntityReader . lookingAtSpace ( true ) ) { fEntityReader . skipPastSpaces ( ) ; if ( ! fEntityReader . lookingAtChar ( '%' , true ) ) { isPEDecl = false ; } else if ( fEntityReader . lookingAtSpace ( true ) ) { checkForPEReference ( false ) ; isPEDecl = true ; } else if ( ! getReadingExternalEntity ( ) ) { reportFatalXMLError ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL , XMLMessages . P72_SPACE ) ; isPEDecl = true ; } else if ( fEntityReader . lookingAtChar ( '%' , false ) ) { checkForPEReference ( false ) ; isPEDecl = true ; } else { sawPERef = true ; } } else if ( ! getReadingExternalEntity ( ) || ! fEntityReader . lookingAtChar ( '%' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL , XMLMessages . P70_SPACE ) ; isPEDecl = false ; } else if ( fEntityReader . lookingAtSpace ( false ) ) { reportFatalXMLError ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL , XMLMessages . P72_SPACE ) ; isPEDecl = false ; } else { sawPERef = true ; } if ( sawPERef ) { while ( true ) { int nameOffset = fEntityReader . currentOffset ( ) ; fEntityReader . skipPastName ( ';' ) ; int nameLength = fEntityReader . currentOffset ( ) - nameOffset ; if ( nameLength == 0 ) { reportFatalXMLError ( XMLMessages . MSG_NAME_REQUIRED_IN_PEREFERENCE , XMLMessages . P69_NAME_REQUIRED ) ; } else if ( ! fEntityReader . lookingAtChar ( ';' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_SEMICOLON_REQUIRED_IN_PEREFERENCE , XMLMessages . P69_SEMICOLON_REQUIRED , fEntityReader . addString ( nameOffset , nameLength ) ) ; } else { int peNameIndex = fEntityReader . addSymbol ( nameOffset , nameLength ) ; int readerDepth = ( fScannerState == SCANNER_STATE_CONTENTSPEC ) ? parenDepth ( ) : markupDepth ( ) ; fEntityHandler . startReadingFromEntity ( peNameIndex , readerDepth , XMLEntityHandler . ENTITYREF_IN_DTD_WITHIN_MARKUP ) ; } fEntityReader . skipPastSpaces ( ) ; if ( ! fEntityReader . lookingAtChar ( '%' , true ) ) break ; if ( ! isPEDecl ) { if ( fEntityReader . lookingAtSpace ( true ) ) { checkForPEReference ( false ) ; isPEDecl = true ; break ; } isPEDecl = fEntityReader . lookingAtChar ( '%' , true ) ; } } } int entityName = checkForNameWithPEReference ( fEntityReader , ' ' ) ; if ( entityName == - 1 ) { abortMarkup ( XMLMessages . MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL , XMLMessages . P70_REQUIRED_NAME ) ; return ; } if ( ! fDTDGrammar . startEntityDecl ( isPEDecl , entityName ) ) { skipPastEndOfCurrentMarkup ( ) ; return ; } if ( ! checkForPEReference ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL , XMLMessages . P70_REQUIRED_SPACE , entityName ) ; fDTDGrammar . endEntityDecl ( ) ; return ; } if ( isPEDecl ) { boolean single ; if ( ( single = fEntityReader . lookingAtChar ( '\'' , true ) ) || fEntityReader . lookingAtChar ( '\"' , true ) ) { int value = scanEntityValue ( single ) ; if ( value == - 1 ) { skipPastEndOfCurrentMarkup ( ) ; fDTDGrammar . endEntityDecl ( ) ; return ; } checkForPEReference ( false ) ; if ( ! fEntityReader . lookingAtChar ( '>' , true ) ) { abortMarkup ( XMLMessages . MSG_ENTITYDECL_UNTERMINATED , XMLMessages . P72_UNTERMINATED , entityName ) ; fDTDGrammar . endEntityDecl ( ) ; return ; } decreaseMarkupDepth ( ) ; fDTDGrammar . endEntityDecl ( ) ; fDTDGrammar . addInternalPEDecl ( entityName , value ) ; if ( fDTDHandler != null ) { fDTDHandler . internalPEDecl ( entityName , value ) ; } int entityIndex = ( ( DefaultEntityHandler ) fEntityHandler ) . addInternalPEDecl ( entityName , value , getReadingExternalEntity ( ) ) ; } else { if ( ! scanExternalID ( false ) ) { skipPastEndOfCurrentMarkup ( ) ; fDTDGrammar . endEntityDecl ( ) ; return ; } checkForPEReference ( false ) ; if ( ! fEntityReader . lookingAtChar ( '>' , true ) ) { abortMarkup ( XMLMessages . MSG_ENTITYDECL_UNTERMINATED , XMLMessages . P72_UNTERMINATED , entityName ) ; fDTDGrammar . endEntityDecl ( ) ; return ; } decreaseMarkupDepth ( ) ; fDTDGrammar . endEntityDecl ( ) ; fDTDGrammar . addExternalPEDecl ( entityName , fPubidLiteral , fSystemLiteral ) ; if ( fDTDHandler != null ) { fDTDHandler . externalPEDecl ( entityName , fPubidLiteral , fSystemLiteral ) ; } int entityIndex = ( ( DefaultEntityHandler ) fEntityHandler ) . addExternalPEDecl ( entityName , fPubidLiteral , fSystemLiteral , getReadingExternalEntity ( ) ) ; } } else { boolean single ; if ( ( single = fEntityReader . lookingAtChar ( '\'' , true ) ) || fEntityReader . lookingAtChar ( '\"' , true ) ) { int value = scanEntityValue ( single ) ; if ( value == - 1 ) { skipPastEndOfCurrentMarkup ( ) ; fDTDGrammar . endEntityDecl ( ) ; return ; } checkForPEReference ( false ) ; if ( ! fEntityReader . lookingAtChar ( '>' , true ) ) { abortMarkup ( XMLMessages . MSG_ENTITYDECL_UNTERMINATED , XMLMessages . P71_UNTERMINATED , entityName ) ; fDTDGrammar . endEntityDecl ( ) ; return ; } decreaseMarkupDepth ( ) ; fDTDGrammar . endEntityDecl ( ) ; fDTDGrammar . addInternalEntityDecl ( entityName , value ) ; if ( fDTDHandler != null ) { fDTDHandler . internalEntityDecl ( entityName , value ) ; } int entityIndex = ( ( DefaultEntityHandler ) fEntityHandler ) . addInternalEntityDecl ( entityName , value , getReadingExternalEntity ( ) ) ; } else { if ( ! scanExternalID ( false ) ) { skipPastEndOfCurrentMarkup ( ) ; fDTDGrammar . endEntityDecl ( ) ; return ; } boolean unparsed = false ; if ( fEntityReader . lookingAtSpace ( true ) ) { fEntityReader . skipPastSpaces ( ) ; unparsed = fEntityReader . skippedString ( ndata_string ) ; } if ( ! unparsed ) { checkForPEReference ( false ) ; if ( ! fEntityReader . lookingAtChar ( '>' , true ) ) { abortMarkup ( XMLMessages . MSG_ENTITYDECL_UNTERMINATED , XMLMessages . P72_UNTERMINATED , entityName ) ; fDTDGrammar . endEntityDecl ( ) ; return ; } decreaseMarkupDepth ( ) ; fDTDGrammar . endEntityDecl ( ) ; fDTDGrammar . addExternalEntityDecl ( entityName , fPubidLiteral , fSystemLiteral ) ; if ( fDTDHandler != null ) { fDTDHandler . externalEntityDecl ( entityName , fPubidLiteral , fSystemLiteral ) ; } int entityIndex = ( ( DefaultEntityHandler ) fEntityHandler ) . addExternalEntityDecl ( entityName , fPubidLiteral , fSystemLiteral , getReadingExternalEntity ( ) ) ; } else { if ( ! fEntityReader . lookingAtSpace ( true ) ) { abortMarkup ( XMLMessages . MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL , XMLMessages . P76_SPACE_REQUIRED , entityName ) ; fDTDGrammar . endEntityDecl ( ) ; return ; } fEntityReader . skipPastSpaces ( ) ; int ndataOffset = fEntityReader . currentOffset ( ) ; fEntityReader . skipPastName ( '>' ) ; int ndataLength = fEntityReader . currentOffset ( ) - ndataOffset ; if ( ndataLength == 0 ) { abortMarkup ( XMLMessages . MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL , XMLMessages . P76_REQUIRED , entityName ) ; fDTDGrammar . endEntityDecl ( ) ; return ; } int notationName = fEntityReader . addSymbol ( ndataOffset , ndataLength ) ; checkForPEReference ( false ) ; if ( ! fEntityReader . lookingAtChar ( '>' , true ) ) { abortMarkup ( XMLMessages . MSG_ENTITYDECL_UNTERMINATED , XMLMessages . P72_UNTERMINATED , entityName ) ; fDTDGrammar . endEntityDecl ( ) ; return ; } decreaseMarkupDepth ( ) ; fDTDGrammar . endEntityDecl ( ) ; fDTDGrammar . addUnparsedEntityDecl ( entityName , fPubidLiteral , fSystemLiteral , notationName ) ; if ( fDTDHandler != null ) { fDTDHandler . unparsedEntityDecl ( entityName , fPubidLiteral , fSystemLiteral , notationName ) ; } int entityIndex = ( ( DefaultEntityHandler ) fEntityHandler ) . addUnparsedEntityDecl ( entityName , fPubidLiteral , fSystemLiteral , notationName , getReadingExternalEntity ( ) ) ; } } } } private int scanEntityValue ( boolean single ) throws Exception { char qchar = single ? '\'' : '\"' ; fEntityValueMark = fEntityReader . currentOffset ( ) ; int entityValue = fEntityReader . scanEntityValue ( qchar , true ) ; if ( entityValue < 0 ) entityValue = scanComplexEntityValue ( qchar , entityValue ) ; return entityValue ; } private int scanComplexEntityValue ( char qchar , int result ) throws Exception { int previousState = setScannerState ( SCANNER_STATE_ENTITY_VALUE ) ; fEntityValueReader = fReaderId ; int dataOffset = fLiteralData . length ( ) ; while ( true ) { switch ( result ) { case XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED : { int offset = fEntityReader . currentOffset ( ) ; fEntityReader . lookingAtChar ( qchar , true ) ; restoreScannerState ( previousState ) ; int dataLength = fLiteralData . length ( ) - dataOffset ; if ( dataLength == 0 ) { return fEntityReader . addString ( fEntityValueMark , offset - fEntityValueMark ) ; } if ( offset - fEntityValueMark > 0 ) { fEntityReader . append ( fLiteralData , fEntityValueMark , offset - fEntityValueMark ) ; dataLength = fLiteralData . length ( ) - dataOffset ; } return fLiteralData . addString ( dataOffset , dataLength ) ; } case XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE : { int offset = fEntityReader . currentOffset ( ) ; if ( offset - fEntityValueMark > 0 ) fEntityReader . append ( fLiteralData , fEntityValueMark , offset - fEntityValueMark ) ; fEntityReader . lookingAtChar ( '&' , true ) ; if ( fEntityReader . lookingAtChar ( '#' , true ) ) { int ch = scanCharRef ( ) ; if ( ch != - 1 ) { if ( ch < 0x10000 ) fLiteralData . append ( ( char ) ch ) ; else { fLiteralData . append ( ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ) ; fLiteralData . append ( ( char ) ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ) ; } } fEntityValueMark = fEntityReader . currentOffset ( ) ; } else { int nameOffset = fEntityReader . currentOffset ( ) ; fEntityReader . skipPastName ( ';' ) ; int nameLength = fEntityReader . currentOffset ( ) - nameOffset ; if ( nameLength == 0 ) { reportFatalXMLError ( XMLMessages . MSG_NAME_REQUIRED_IN_REFERENCE , XMLMessages . P68_NAME_REQUIRED ) ; fEntityValueMark = fEntityReader . currentOffset ( ) ; } else if ( ! fEntityReader . lookingAtChar ( ';' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_SEMICOLON_REQUIRED_IN_REFERENCE , XMLMessages . P68_SEMICOLON_REQUIRED , fEntityReader . addString ( nameOffset , nameLength ) ) ; fEntityValueMark = fEntityReader . currentOffset ( ) ; } else { fEntityValueMark = offset ; } } break ; } case XMLEntityHandler . ENTITYVALUE_RESULT_PEREF : { int offset = fEntityReader . currentOffset ( ) ; if ( offset - fEntityValueMark > 0 ) fEntityReader . append ( fLiteralData , fEntityValueMark , offset - fEntityValueMark ) ; fEntityReader . lookingAtChar ( '%' , true ) ; int nameOffset = fEntityReader . currentOffset ( ) ; fEntityReader . skipPastName ( ';' ) ; int nameLength = fEntityReader . currentOffset ( ) - nameOffset ; if ( nameLength == 0 ) { reportFatalXMLError ( XMLMessages . MSG_NAME_REQUIRED_IN_PEREFERENCE , XMLMessages . P69_NAME_REQUIRED ) ; } else if ( ! fEntityReader . lookingAtChar ( ';' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_SEMICOLON_REQUIRED_IN_PEREFERENCE , XMLMessages . P69_SEMICOLON_REQUIRED , fEntityReader . addString ( nameOffset , nameLength ) ) ; } else if ( ! getReadingExternalEntity ( ) ) { reportFatalXMLError ( XMLMessages . MSG_PEREFERENCE_WITHIN_MARKUP , XMLMessages . WFC_PES_IN_INTERNAL_SUBSET , fEntityReader . addString ( nameOffset , nameLength ) ) ; } else { int peNameIndex = fEntityReader . addSymbol ( nameOffset , nameLength ) ; fEntityHandler . startReadingFromEntity ( peNameIndex , markupDepth ( ) , XMLEntityHandler . ENTITYREF_IN_ENTITYVALUE ) ; } fEntityValueMark = fEntityReader . currentOffset ( ) ; break ; } case XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR : { int offset = fEntityReader . currentOffset ( ) ; if ( offset - fEntityValueMark > 0 ) fEntityReader . append ( fLiteralData , fEntityValueMark , offset - fEntityValueMark ) ; int invChar = fEntityReader . scanInvalidChar ( ) ; if ( fScannerState == SCANNER_STATE_END_OF_INPUT ) return - 1 ; if ( invChar >= 0 ) { reportFatalXMLError ( XMLMessages . MSG_INVALID_CHAR_IN_ENTITYVALUE , XMLMessages . P9_INVALID_CHARACTER , Integer . toHexString ( invChar ) ) ; } fEntityValueMark = fEntityReader . currentOffset ( ) ; break ; } case XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT : break ; default : break ; } result = fEntityReader . scanEntityValue ( fReaderId == fEntityValueReader ? qchar : - 1 , false ) ; } } private boolean checkForPEReference ( boolean spaceRequired ) throws Exception { boolean sawSpace = true ; if ( spaceRequired ) sawSpace = fEntityReader . lookingAtSpace ( true ) ; fEntityReader . skipPastSpaces ( ) ; if ( ! getReadingExternalEntity ( ) ) return sawSpace ; if ( ! fEntityReader . lookingAtChar ( '%' , true ) ) return sawSpace ; while ( true ) { int nameOffset = fEntityReader . currentOffset ( ) ; fEntityReader . skipPastName ( ';' ) ; int nameLength = fEntityReader . currentOffset ( ) - nameOffset ; if ( nameLength == 0 ) { reportFatalXMLError ( XMLMessages . MSG_NAME_REQUIRED_IN_PEREFERENCE , XMLMessages . P69_NAME_REQUIRED ) ; } else if ( ! fEntityReader . lookingAtChar ( ';' , true ) ) { reportFatalXMLError ( XMLMessages . MSG_SEMICOLON_REQUIRED_IN_PEREFERENCE , XMLMessages . P69_SEMICOLON_REQUIRED , fEntityReader . addString ( nameOffset , nameLength ) ) ; } else { int peNameIndex = fEntityReader . addSymbol ( nameOffset , nameLength ) ; int readerDepth = ( fScannerState == SCANNER_STATE_CONTENTSPEC ) ? parenDepth ( ) : markupDepth ( ) ; fEntityHandler . startReadingFromEntity ( peNameIndex , readerDepth , XMLEntityHandler . ENTITYREF_IN_DTD_WITHIN_MARKUP ) ; } fEntityReader . skipPastSpaces ( ) ; if ( ! fEntityReader . lookingAtChar ( '%' , true ) ) return true ; } } private void initializeContentModelStack ( int depth ) { if ( fOpStack == null ) { fOpStack = new int [ 8 ] ; fNodeIndexStack = new int [ 8 ] ; fPrevNodeIndexStack = new int [ 8 ] ; } else if ( depth == fOpStack . length ) { int [ ] newStack = new int [ depth * 2 ] ; System . arraycopy ( fOpStack , 0 , newStack , 0 , depth ) ; fOpStack = newStack ; newStack = new int [ depth * 2 ] ; System . arraycopy ( fNodeIndexStack , 0 , newStack , 0 , depth ) ; fNodeIndexStack = newStack ; newStack = new int [ depth * 2 ] ; System . arraycopy ( fPrevNodeIndexStack , 0 , newStack , 0 , depth ) ; fPrevNodeIndexStack = newStack ; } fOpStack [ depth ] = - 1 ; fNodeIndexStack [ depth ] = - 1 ; fPrevNodeIndexStack [ depth ] = - 1 ; } private boolean validVersionNum ( String version ) { return XMLCharacterProperties . validVersionNum ( version ) ; } private boolean validEncName ( String encoding ) { return XMLCharacterProperties . validEncName ( encoding ) ; } private int validPublicId ( String publicId ) { return XMLCharacterProperties . validPublicId ( publicId ) ; } private void scanElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( ! fNamespacesEnabled ) { element . clear ( ) ; element . localpart = entityReader . scanName ( fastchar ) ; element . rawname = element . localpart ; return ; } entityReader . scanQName ( fastchar , element ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } public void checkForElementTypeWithPEReference ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( ! fNamespacesEnabled ) { element . clear ( ) ; element . localpart = entityReader . scanName ( fastchar ) ; element . rawname = element . localpart ; return ; } entityReader . scanQName ( fastchar , element ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } public void checkForAttributeNameWithPEReference ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName attribute ) throws Exception { if ( ! fNamespacesEnabled ) { attribute . clear ( ) ; attribute . localpart = entityReader . scanName ( fastchar ) ; attribute . rawname = attribute . localpart ; return ; } entityReader . scanQName ( fastchar , attribute ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } public int checkForNameWithPEReference ( XMLEntityHandler . EntityReader entityReader , char fastcheck ) throws Exception { int valueIndex = entityReader . scanName ( fastcheck ) ; return valueIndex ; } public int checkForNmtokenWithPEReference ( XMLEntityHandler . EntityReader entityReader , char fastcheck ) throws Exception { int nameOffset = entityReader . currentOffset ( ) ; entityReader . skipPastNmtoken ( fastcheck ) ; int nameLength = entityReader . currentOffset ( ) - nameOffset ; if ( nameLength == 0 ) return - 1 ; int valueIndex = entityReader . addSymbol ( nameOffset , nameLength ) ; return valueIndex ; } public int scanDefaultAttValue ( QName element , QName attribute , int attType , int enumeration ) throws Exception { if ( fValidationEnabled && attType == XMLAttributeDecl . TYPE_ID ) { reportRecoverableXMLError ( XMLMessages . MSG_ID_DEFAULT_TYPE_INVALID , XMLMessages . VC_ID_ATTRIBUTE_DEFAULT , fStringPool . toString ( attribute . rawname ) ) ; } int defaultAttValue = scanDefaultAttValue ( element , attribute ) ; if ( defaultAttValue == - 1 ) return - 1 ; return defaultAttValue ; } public int normalizeDefaultAttValue ( QName attribute , int defaultAttValue , int attType , int enumeration , boolean list ) throws Exception { String attValue = fStringPool . toString ( defaultAttValue ) ; if ( list ) { StringTokenizer tokenizer = new StringTokenizer ( attValue ) ; StringBuffer sb = new StringBuffer ( attValue . length ( ) ) ; boolean ok = true ; if ( tokenizer . hasMoreTokens ( ) ) { while ( true ) { String nmtoken = tokenizer . nextToken ( ) ; if ( attType == XMLAttributeDecl . TYPE_NMTOKEN ) { if ( fValidationEnabled && ! XMLCharacterProperties . validNmtoken ( nmtoken ) ) { ok = false ; } } else if ( attType == XMLAttributeDecl . TYPE_IDREF || attType == XMLAttributeDecl . TYPE_ENTITY ) { if ( fValidationEnabled && ! XMLCharacterProperties . validName ( nmtoken ) ) { ok = false ; } if ( fValidationEnabled && attType == XMLAttributeDecl . TYPE_ENTITY ) if ( ! ( ( DefaultEntityHandler ) fEntityHandler ) . isUnparsedEntity ( defaultAttValue ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ENTITY_INVALID , XMLMessages . VC_ENTITY_NAME , fStringPool . toString ( attribute . rawname ) , nmtoken ) ; } } sb . append ( nmtoken ) ; if ( ! tokenizer . hasMoreTokens ( ) ) { break ; } sb . append ( ' ' ) ; } } String newAttValue = sb . toString ( ) ; if ( fValidationEnabled && ( ! ok || newAttValue . length ( ) == 0 ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATT_DEFAULT_INVALID , XMLMessages . VC_ATTRIBUTE_DEFAULT_LEGAL , fStringPool . toString ( attribute . rawname ) , newAttValue ) ; } if ( ! newAttValue . equals ( attValue ) ) { defaultAttValue = fStringPool . addString ( newAttValue ) ; } return defaultAttValue ; } else { String newAttValue = attValue . trim ( ) ; if ( fValidationEnabled ) { if ( newAttValue != attValue ) { defaultAttValue = fStringPool . addSymbol ( newAttValue ) ; } else { defaultAttValue = fStringPool . addSymbol ( defaultAttValue ) ; } if ( attType == XMLAttributeDecl . TYPE_ENTITY || attType == XMLAttributeDecl . TYPE_ID || attType == XMLAttributeDecl . TYPE_IDREF || attType == XMLAttributeDecl . TYPE_NOTATION ) { if ( attType == XMLAttributeDecl . TYPE_ENTITY ) if ( ! ( ( DefaultEntityHandler ) fEntityHandler ) . isUnparsedEntity ( defaultAttValue ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ENTITY_INVALID , XMLMessages . VC_ENTITY_NAME , fStringPool . toString ( attribute . rawname ) , newAttValue ) ; } if ( ! XMLCharacterProperties . validName ( newAttValue ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATT_DEFAULT_INVALID , XMLMessages . VC_ATTRIBUTE_DEFAULT_LEGAL , fStringPool . toString ( attribute . rawname ) , newAttValue ) ; } } else if ( attType == XMLAttributeDecl . TYPE_NMTOKEN || attType == XMLAttributeDecl . TYPE_ENUMERATION ) { if ( ! XMLCharacterProperties . validNmtoken ( newAttValue ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATT_DEFAULT_INVALID , XMLMessages . VC_ATTRIBUTE_DEFAULT_LEGAL , fStringPool . toString ( attribute . rawname ) , newAttValue ) ; } } if ( attType == XMLAttributeDecl . TYPE_NOTATION || attType == XMLAttributeDecl . TYPE_ENUMERATION ) { if ( ! fStringPool . stringInList ( enumeration , defaultAttValue ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATT_DEFAULT_INVALID , XMLMessages . VC_ATTRIBUTE_DEFAULT_LEGAL , fStringPool . toString ( attribute . rawname ) , newAttValue ) ; } } } else if ( newAttValue != attValue ) { defaultAttValue = fStringPool . addSymbol ( newAttValue ) ; } } return defaultAttValue ; } } 	0
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface LexicalHandler { public abstract void startDTD ( String name , String publicId , String systemId ) throws SAXException ; public abstract void endDTD ( ) throws SAXException ; public abstract void startEntity ( String name ) throws SAXException ; public abstract void endEntity ( String name ) throws SAXException ; public abstract void startCDATA ( ) throws SAXException ; public abstract void endCDATA ( ) throws SAXException ; public abstract void comment ( char ch [ ] , int start , int length ) throws SAXException ; } 	1
package org . w3c . dom . html ; public interface HTMLIFrameElement extends HTMLElement { public String getAlign ( ) ; public void setAlign ( String align ) ; public String getFrameBorder ( ) ; public void setFrameBorder ( String frameBorder ) ; public String getHeight ( ) ; public void setHeight ( String height ) ; public String getLongDesc ( ) ; public void setLongDesc ( String longDesc ) ; public String getMarginHeight ( ) ; public void setMarginHeight ( String marginHeight ) ; public String getMarginWidth ( ) ; public void setMarginWidth ( String marginWidth ) ; public String getName ( ) ; public void setName ( String name ) ; public String getScrolling ( ) ; public void setScrolling ( String scrolling ) ; public String getSrc ( ) ; public void setSrc ( String src ) ; public String getWidth ( ) ; public void setWidth ( String width ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrImpl extends ParentNode implements Attr { static final long serialVersionUID = 7277707688218972102L ; protected String name ; protected AttrImpl ( DocumentImpl ownerDocument , String name ) { super ( ownerDocument ) ; this . name = name ; isSpecified ( true ) ; } protected AttrImpl ( ) { } public Node cloneNode ( boolean deep ) { AttrImpl clone = ( AttrImpl ) super . cloneNode ( deep ) ; clone . isSpecified ( true ) ; return clone ; } public short getNodeType ( ) { return Node . ATTRIBUTE_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setNodeValue ( String value ) throws DOMException { setValue ( value ) ; } public String getNodeValue ( ) { return getValue ( ) ; } public String getName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setValue ( String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } LCount lc = null ; String oldvalue = "" ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 && ownerNode != null ) { oldvalue = getValue ( ) ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } while ( firstChild != null ) internalRemoveChild ( firstChild , MUTATION_LOCAL ) ; } else { if ( firstChild != null ) { firstChild . previousSibling = null ; firstChild . isFirstChild ( false ) ; firstChild = null ; } needsSyncChildren ( false ) ; } isSpecified ( true ) ; if ( value != null ) { internalInsertBefore ( ownerDocument . createTextNode ( value ) , null , MUTATION_LOCAL ) ; } changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( this , oldvalue ) ; } } public String getValue ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( firstChild == null ) { return "" ; } ChildNode node = firstChild . nextSibling ; if ( node == null ) { return firstChild . getNodeValue ( ) ; } StringBuffer value = new StringBuffer ( firstChild . getNodeValue ( ) ) ; while ( node != null ) { value . append ( node . getNodeValue ( ) ) ; node = node . nextSibling ; } return value . toString ( ) ; } public boolean getSpecified ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isSpecified ( ) ; } public Element getElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public Element getOwnerElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public void normalize ( ) { Node kid , next ; for ( kid = firstChild ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } } } public void setSpecified ( boolean arg ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isSpecified ( arg ) ; } public String toString ( ) { return getName ( ) + "=" + "\"" + getValue ( ) + "\"" ; } } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . ChunkyByteArray ; import org . apache . xerces . utils . StringPool ; import java . util . Stack ; public abstract class XMLDeclRecognizer { public static void registerDefaultRecognizers ( Stack recognizerStack ) { recognizerStack . push ( new EBCDICRecognizer ( ) ) ; recognizerStack . push ( new UCSRecognizer ( ) ) ; recognizerStack . push ( new UTF8Recognizer ( ) ) ; } public abstract XMLEntityHandler . EntityReader recognize ( XMLEntityReaderFactory readerFactory , XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , StringPool stringPool , ChunkyByteArray data , boolean xmlDecl , boolean allowJavaEncodingName ) throws Exception ; protected int prescanXMLDeclOrTextDecl ( XMLEntityHandler . EntityReader entityReader , boolean xmlDecl ) throws Exception { if ( ! entityReader . lookingAtChar ( '<' , true ) ) { return - 1 ; } if ( ! entityReader . lookingAtChar ( '?' , true ) ) { return - 1 ; } if ( ! entityReader . skippedString ( xml_string ) ) { return - 1 ; } entityReader . skipPastSpaces ( ) ; boolean single ; char qchar ; if ( entityReader . skippedString ( version_string ) ) { entityReader . skipPastSpaces ( ) ; if ( ! entityReader . lookingAtChar ( '=' , true ) ) { return - 1 ; } entityReader . skipPastSpaces ( ) ; int versionIndex = entityReader . scanStringLiteral ( ) ; if ( versionIndex < 0 ) { return - 1 ; } if ( ! entityReader . lookingAtSpace ( true ) ) { return - 1 ; } entityReader . skipPastSpaces ( ) ; } else if ( xmlDecl ) { return - 1 ; } if ( ! entityReader . skippedString ( encoding_string ) ) { return - 1 ; } entityReader . skipPastSpaces ( ) ; if ( ! entityReader . lookingAtChar ( '=' , true ) ) { return - 1 ; } entityReader . skipPastSpaces ( ) ; int encodingIndex = entityReader . scanStringLiteral ( ) ; return encodingIndex ; } private static final char [ ] xml_string = { 'x' , 'm' , 'l' } ; private static final char [ ] version_string = { 'v' , 'e' , 'r' , 's' , 'i' , 'o' , 'n' } ; private static final char [ ] encoding_string = { 'e' , 'n' , 'c' , 'o' , 'd' , 'i' , 'n' , 'g' } ; } 	0
package org . w3c . dom ; public interface CharacterData extends Node { public String getData ( ) throws DOMException ; public void setData ( String data ) throws DOMException ; public int getLength ( ) ; public String substringData ( int offset , int count ) throws DOMException ; public void appendData ( String arg ) throws DOMException ; public void insertData ( int offset , String arg ) throws DOMException ; public void deleteData ( int offset , int count ) throws DOMException ; public void replaceData ( int offset , int count , String arg ) throws DOMException ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLBigElementImpl extends WMLElementImpl implements WMLBigElement { public WMLBigElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface Event { public static final short CAPTURING_PHASE = 1 ; public static final short AT_TARGET = 2 ; public static final short BUBBLING_PHASE = 3 ; public String getType ( ) ; public EventTarget getTarget ( ) ; public Node getCurrentNode ( ) ; public short getEventPhase ( ) ; public boolean getBubbles ( ) ; public boolean getCancelable ( ) ; public long getTimeStamp ( ) ; public void stopPropagation ( ) ; public void preventDefault ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) ; } 	1
package org . w3c . dom . html ; public interface HTMLMapElement extends HTMLElement { public HTMLCollection getAreas ( ) ; public String getName ( ) ; public void setName ( String name ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Enumeration ; import java . util . Vector ; import org . w3c . dom . * ; public class ElementImpl extends ChildAndParentNode implements Element { static final long serialVersionUID = 3717253516652722278L ; protected String name ; protected AttributeMap attributes ; public ElementImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; needsSyncData ( true ) ; } protected ElementImpl ( ) { } public short getNodeType ( ) { return Node . ELEMENT_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public NamedNodeMap getAttributes ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return attributes ; } public Node cloneNode ( boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } ElementImpl newnode = ( ElementImpl ) super . cloneNode ( deep ) ; if ( attributes != null ) { newnode . attributes = ( AttributeMap ) attributes . cloneMap ( newnode ) ; } return newnode ; } void setOwnerDocument ( DocumentImpl doc ) { super . setOwnerDocument ( doc ) ; if ( attributes != null ) { attributes . setOwnerDocument ( doc ) ; } } public String getAttribute ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return "" ; } Attr attr = ( Attr ) ( attributes . getNamedItem ( name ) ) ; return ( attr == null ) ? "" : attr . getValue ( ) ; } public Attr getAttributeNode ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItem ( name ) ; } public NodeList getElementsByTagName ( String tagname ) { return new DeepNodeListImpl ( this , tagname ) ; } public String getTagName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void normalize ( ) { Node kid , next ; for ( kid = getFirstChild ( ) ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } else if ( kid . getNodeType ( ) == Node . ELEMENT_NODE ) { ( ( Element ) kid ) . normalize ( ) ; } } } public void removeAttribute ( String name ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItem ( name ) ; } public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } return ( Attr ) attributes . removeNamedItem ( oldAttr . getName ( ) ) ; } public void setAttribute ( String name , String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } Attr newAttr = getAttributeNode ( name ) ; if ( newAttr == null ) { newAttr = getOwnerDocument ( ) . createAttribute ( name ) ; if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } attributes . setNamedItem ( newAttr ) ; } newAttr . setNodeValue ( value ) ; } public Attr setAttributeNode ( Attr newAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ownerDocument . errorChecking && newAttr . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return ( Attr ) attributes . setNamedItem ( newAttr ) ; } public String getAttributeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return "" ; } Attr attr = ( Attr ) ( attributes . getNamedItemNS ( namespaceURI , localName ) ) ; return ( attr == null ) ? null : attr . getValue ( ) ; } public void setAttributeNS ( String namespaceURI , String localName , String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } Attr newAttr = getAttributeNodeNS ( namespaceURI , localName ) ; if ( newAttr == null ) { newAttr = getOwnerDocument ( ) . createAttributeNS ( namespaceURI , localName ) ; if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } attributes . setNamedItemNS ( newAttr ) ; } newAttr . setNodeValue ( value ) ; } public void removeAttributeNS ( String namespaceURI , String localName ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItemNS ( namespaceURI , localName ) ; } public Attr getAttributeNodeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItemNS ( namespaceURI , localName ) ; } public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ownerDocument . errorChecking && newAttr . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return ( Attr ) attributes . setNamedItemNS ( newAttr ) ; } public boolean hasAttributes ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return ( attributes != null && attributes . getLength ( ) != 0 ) ; } public boolean hasAttribute ( String name ) { return getAttributeNode ( name ) != null ; } public boolean hasAttributeNS ( String namespaceURI , String localName ) { return getAttributeNodeNS ( namespaceURI , localName ) != null ; } public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { return new DeepNodeListImpl ( this , namespaceURI , localName ) ; } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( attributes != null ) { attributes . setReadOnly ( readOnly , true ) ; } } protected void synchronizeData ( ) { needsSyncData ( false ) ; setupDefaultAttributes ( ) ; } protected void setupDefaultAttributes ( ) { NamedNodeMapImpl defaults = getDefaultAttributes ( ) ; if ( defaults != null ) { attributes = new AttributeMap ( this , defaults ) ; } } protected NamedNodeMapImpl getDefaultAttributes ( ) { DocumentTypeImpl doctype = ( DocumentTypeImpl ) ownerDocument . getDoctype ( ) ; if ( doctype == null ) { return null ; } ElementDefinitionImpl eldef = ( ElementDefinitionImpl ) doctype . getElements ( ) . getNamedItem ( getNodeName ( ) ) ; if ( eldef == null ) { return null ; } return ( NamedNodeMapImpl ) eldef . getAttributes ( ) ; } } 	1
package org . xml . sax . helpers ; import org . xml . sax . AttributeList ; import java . util . Vector ; public class AttributeListImpl implements AttributeList { public AttributeListImpl ( ) { } public AttributeListImpl ( AttributeList atts ) { setAttributeList ( atts ) ; } public void setAttributeList ( AttributeList atts ) { int count = atts . getLength ( ) ; clear ( ) ; for ( int i = 0 ; i < count ; i ++ ) { addAttribute ( atts . getName ( i ) , atts . getType ( i ) , atts . getValue ( i ) ) ; } } public void addAttribute ( String name , String type , String value ) { names . addElement ( name ) ; types . addElement ( type ) ; values . addElement ( value ) ; } public void removeAttribute ( String name ) { int i = names . indexOf ( name ) ; if ( i >= 0 ) { names . removeElementAt ( i ) ; types . removeElementAt ( i ) ; values . removeElementAt ( i ) ; } } public void clear ( ) { names . removeAllElements ( ) ; types . removeAllElements ( ) ; values . removeAllElements ( ) ; } public int getLength ( ) { return names . size ( ) ; } public String getName ( int i ) { if ( i < 0 ) { return null ; } try { return ( String ) names . elementAt ( i ) ; } catch ( ArrayIndexOutOfBoundsException e ) { return null ; } } public String getType ( int i ) { if ( i < 0 ) { return null ; } try { return ( String ) types . elementAt ( i ) ; } catch ( ArrayIndexOutOfBoundsException e ) { return null ; } } public String getValue ( int i ) { if ( i < 0 ) { return null ; } try { return ( String ) values . elementAt ( i ) ; } catch ( ArrayIndexOutOfBoundsException e ) { return null ; } } public String getType ( String name ) { return getType ( names . indexOf ( name ) ) ; } public String getValue ( String name ) { return getValue ( names . indexOf ( name ) ) ; } Vector names = new Vector ( ) ; Vector types = new Vector ( ) ; Vector values = new Vector ( ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class TextImpl extends CharacterDataImpl implements CharacterData , Text { static final long serialVersionUID = - 5294980852957403469L ; public TextImpl ( DocumentImpl ownerDoc , String data ) { super ( ownerDoc , data ) ; } public short getNodeType ( ) { return Node . TEXT_NODE ; } public String getNodeName ( ) { return "#text" ; } public void setIgnorableWhitespace ( boolean ignore ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isIgnorableWhitespace ( ignore ) ; } public boolean isIgnorableWhitespace ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return internalIsIgnorableWhitespace ( ) ; } public Text splitText ( int offset ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( offset < 0 || offset > data . length ( ) - 1 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } Text newText = getOwnerDocument ( ) . createTextNode ( data . substring ( offset ) ) ; setNodeValue ( data . substring ( 0 , offset ) ) ; Node parentNode = getParentNode ( ) ; if ( parentNode != null ) { parentNode . insertBefore ( newText , nextSibling ) ; } return newText ; } } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DeferredElementDefinitionImpl extends ElementDefinitionImpl implements DeferredNode { static final long serialVersionUID = 6703238199538041591L ; protected transient int fNodeIndex ; DeferredElementDefinitionImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; needsSyncChildren ( true ) ; } public int getNodeIndex ( ) { return fNodeIndex ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; name = ownerDocument . getNodeNameString ( fNodeIndex ) ; } protected void synchronizeChildren ( ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; attributes = new NamedNodeMapImpl ( ownerDocument ) ; for ( int nodeIndex = ownerDocument . getLastChild ( fNodeIndex ) ; nodeIndex != - 1 ; nodeIndex = ownerDocument . getPrevSibling ( nodeIndex ) ) { Node attr = ownerDocument . getNodeObject ( nodeIndex ) ; attributes . setNamedItem ( attr ) ; } ownerDocument . mutationEvents = orig ; } } 	0
package org . w3c . dom ; public class DOMException extends RuntimeException { public DOMException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short INDEX_SIZE_ERR = 1 ; public static final short DOMSTRING_SIZE_ERR = 2 ; public static final short HIERARCHY_REQUEST_ERR = 3 ; public static final short WRONG_DOCUMENT_ERR = 4 ; public static final short INVALID_CHARACTER_ERR = 5 ; public static final short NO_DATA_ALLOWED_ERR = 6 ; public static final short NO_MODIFICATION_ALLOWED_ERR = 7 ; public static final short NOT_FOUND_ERR = 8 ; public static final short NOT_SUPPORTED_ERR = 9 ; public static final short INUSE_ATTRIBUTE_ERR = 10 ; public static final short INVALID_STATE_ERR = 11 ; public static final short SYNTAX_ERR = 12 ; public static final short INVALID_MODIFICATION_ERR = 13 ; public static final short NAMESPACE_ERR = 14 ; public static final short INVALID_ACCESS_ERR = 15 ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLTdElementImpl extends WMLElementImpl implements WMLTdElement { public WMLTdElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom . events ; public interface EventTarget { public void addEventListener ( String type , EventListener listener , boolean useCapture ) ; public void removeEventListener ( String type , EventListener listener , boolean useCapture ) ; public boolean dispatchEvent ( Event evt ) throws EventException ; } 	1
package org . apache . xml . serialize ; import java . io . Writer ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . UnsupportedEncodingException ; class Encodings { static final int DefaultLastPrintable = 0x7F ; static Writer getWriter ( OutputStream output , String encoding ) throws UnsupportedEncodingException { for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equals ( encoding ) ) return new OutputStreamWriter ( output , _encodings [ i ] . javaName ) ; } return new OutputStreamWriter ( output , encoding ) ; } static int getLastPrintable ( String encoding ) { for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) return _encodings [ i ] . lastPrintable ; } return DefaultLastPrintable ; } static int getLastPrintable ( ) { return DefaultLastPrintable ; } static final class EncodingInfo { final String name ; final String javaName ; final int lastPrintable ; EncodingInfo ( String name , String javaName , int lastPrintable ) { this . name = name ; this . javaName = javaName ; this . lastPrintable = lastPrintable ; } } private static final EncodingInfo [ ] _encodings = new EncodingInfo [ ] { new EncodingInfo ( "ASCII" , "ASCII" , 0x7F ) , new EncodingInfo ( "ISO-Latin-1" , "ASCII" , 0xFF ) , new EncodingInfo ( "ISO-8859-1" , "ISO8859_1" , 0xFF ) , new EncodingInfo ( "ISO-8859-2" , "ISO8859_2" , 0xFF ) , new EncodingInfo ( "ISO-8859-3" , "ISO8859_3" , 0xFF ) , new EncodingInfo ( "ISO-8859-4" , "ISO8859_4" , 0xFF ) , new EncodingInfo ( "ISO-8859-5" , "ISO8859_5" , 0xFF ) , new EncodingInfo ( "ISO-8859-6" , "ISO8859_6" , 0xFF ) , new EncodingInfo ( "ISO-8859-7" , "ISO8859_7" , 0xFF ) , new EncodingInfo ( "ISO-8859-8" , "ISO8859_8" , 0xFF ) , new EncodingInfo ( "ISO-8859-9" , "ISO8859_9" , 0xFF ) , new EncodingInfo ( "UTF-8" , "UTF8" , 0xFFFF ) , new EncodingInfo ( "UNICODE" , "Unicode" , 0xFFFF ) } ; } 	0
package org . w3c . dom ; public interface NodeList { public Node item ( int index ) ; public int getLength ( ) ; } 	1
package org . apache . xerces . utils ; public class NamespacesScope { public interface NamespacesHandler { public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception ; public void endNamespaceDeclScope ( int prefix ) throws Exception ; } public NamespacesScope ( NamespacesHandler handler ) { fHandler = handler ; fNamespaceMappings [ 0 ] = new int [ 9 ] ; fNamespaceMappings [ 0 ] [ 0 ] = 1 ; } public void setNamespaceForPrefix ( int prefix , int namespace ) throws Exception { int offset = fNamespaceMappings [ fElementDepth ] [ 0 ] ; if ( offset == fNamespaceMappings [ fElementDepth ] . length ) { int [ ] newMappings = new int [ offset + 8 ] ; System . arraycopy ( fNamespaceMappings [ fElementDepth ] , 0 , newMappings , 0 , offset ) ; fNamespaceMappings [ fElementDepth ] = newMappings ; } fNamespaceMappings [ fElementDepth ] [ offset ++ ] = prefix ; fNamespaceMappings [ fElementDepth ] [ offset ++ ] = namespace ; fNamespaceMappings [ fElementDepth ] [ 0 ] = offset ; if ( fElementDepth > 0 ) fHandler . startNamespaceDeclScope ( prefix , namespace ) ; } public int getNamespaceForPrefix ( int prefix ) { for ( int depth = fElementDepth ; depth >= 0 ; depth -- ) { int offset = fNamespaceMappings [ depth ] [ 0 ] ; for ( int i = 1 ; i < offset ; i += 2 ) { if ( prefix == fNamespaceMappings [ depth ] [ i ] ) { return fNamespaceMappings [ depth ] [ i + 1 ] ; } } } return - 1 ; } public void increaseDepth ( ) throws Exception { fElementDepth ++ ; if ( fElementDepth == fNamespaceMappings . length ) { int [ ] [ ] newMappings = new int [ fElementDepth + 8 ] [ ] ; System . arraycopy ( fNamespaceMappings , 0 , newMappings , 0 , fElementDepth ) ; fNamespaceMappings = newMappings ; } if ( fNamespaceMappings [ fElementDepth ] == null ) fNamespaceMappings [ fElementDepth ] = new int [ 9 ] ; fNamespaceMappings [ fElementDepth ] [ 0 ] = 1 ; } public void decreaseDepth ( ) throws Exception { if ( fElementDepth > 0 ) { int offset = fNamespaceMappings [ fElementDepth ] [ 0 ] ; while ( offset > 1 ) { offset -= 2 ; fHandler . endNamespaceDeclScope ( fNamespaceMappings [ fElementDepth ] [ offset ] ) ; } } fElementDepth -- ; } private NamespacesHandler fHandler = null ; private int fElementDepth = 0 ; private int [ ] [ ] fNamespaceMappings = new int [ 8 ] [ ] ; } 	0
package javax . xml . parsers ; public class ParserConfigurationException extends Exception { public ParserConfigurationException ( ) { super ( ) ; } public ParserConfigurationException ( String msg ) { super ( msg ) ; } } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Locale ; import java . text . Collator ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . NoSuchElementException ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; public class StringDatatypeValidator extends AbstractDatatypeValidator { private Locale fLocale = null ; DatatypeValidator fBaseValidator = null ; private int fLength = 0 ; private int fMaxLength = Integer . MAX_VALUE ; private int fMinLength = 0 ; private String fPattern = null ; private Vector fEnumeration = null ; private String fMaxInclusive = null ; private String fMaxExclusive = null ; private String fMinInclusive = null ; private String fMinExclusive = null ; private int fFacetsDefined = 0 ; private boolean fDerivedByList = false ; private boolean isMaxExclusiveDefined = false ; private boolean isMaxInclusiveDefined = false ; private boolean isMinExclusiveDefined = false ; private boolean isMinInclusiveDefined = false ; private RegularExpression fRegex = null ; public StringDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public StringDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { if ( fDerivedByList == false ) { for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . equals ( SchemaSymbols . ELT_LENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_LENGTH ; String lengthValue = ( String ) facets . get ( key ) ; try { fLength = Integer . parseInt ( lengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "' is invalid." ) ; } if ( fLength < 0 ) throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "'  must be a nonNegativeInteger." ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MINLENGTH ; String minLengthValue = ( String ) facets . get ( key ) ; try { fMinLength = Integer . parseInt ( minLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "minLength value '" + minLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MAXLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXLENGTH ; String maxLengthValue = ( String ) facets . get ( key ) ; try { fMaxLength = Integer . parseInt ( maxLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + maxLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = ( String ) facets . get ( key ) ; fRegex = new RegularExpression ( fPattern , "X" ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; fEnumeration = ( Vector ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; fMaxInclusive = ( String ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXEXCLUSIVE ; fMaxExclusive = ( String ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; fMinInclusive = ( String ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MINEXCLUSIVE ; fMinExclusive = ( String ) facets . get ( key ) ; } else { throw new InvalidDatatypeFacetException ( "invalid facet tag : " + key ) ; } } if ( ( ( fFacetsDefined & DatatypeValidator . FACET_LENGTH ) != 0 ) ) { if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MAXLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and maxLength to be members of facets." ) ; } else if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MINLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and minLength to be members of facets." ) ; } } if ( ( ( fFacetsDefined & ( DatatypeValidator . FACET_MINLENGTH | DatatypeValidator . FACET_MAXLENGTH ) ) != 0 ) ) { if ( fMinLength > fMaxLength ) { throw new InvalidDatatypeFacetException ( "Value of minLength = '" + fMinLength + "'must be less than the value of maxLength = '" + fMaxLength + "'." ) ; } } isMaxExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXEXCLUSIVE ) != 0 ) ? true : false ; isMaxInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXINCLUSIVE ) != 0 ) ? true : false ; isMinExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MINEXCLUSIVE ) != 0 ) ? true : false ; isMinInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MININCLUSIVE ) != 0 ) ? true : false ; if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both maxInclusive and maxExclusive to be specified for the same datatype." ) ; } if ( isMinExclusiveDefined && isMinInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both minInclusive and minExclusive to be specified for the same datatype." ) ; } } else { for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . equals ( SchemaSymbols . ELT_LENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_LENGTH ; String lengthValue = ( String ) facets . get ( key ) ; try { fLength = Integer . parseInt ( lengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "' is invalid." ) ; } if ( fLength < 0 ) throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "'  must be a nonNegativeInteger." ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MINLENGTH ; String minLengthValue = ( String ) facets . get ( key ) ; try { fMinLength = Integer . parseInt ( minLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + minLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MAXLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXLENGTH ; String maxLengthValue = ( String ) facets . get ( key ) ; try { fMaxLength = Integer . parseInt ( maxLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + maxLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; fEnumeration = ( Vector ) facets . get ( key ) ; } else { throw new InvalidDatatypeFacetException ( "invalid facet tag : " + key ) ; } } if ( ( ( fFacetsDefined & DatatypeValidator . FACET_LENGTH ) != 0 ) ) { if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MAXLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and maxLength to be members of facets." ) ; } else if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MINLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and minLength to be members of facets." ) ; } } if ( ( ( fFacetsDefined & ( DatatypeValidator . FACET_MINLENGTH | DatatypeValidator . FACET_MAXLENGTH ) ) != 0 ) ) { if ( fMinLength > fMaxLength ) { throw new InvalidDatatypeFacetException ( "Value of minLength = " + fMinLength + "must be greater that the value of maxLength" + fMaxLength ) ; } } } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { if ( fDerivedByList == false ) { if ( fFacetsDefined != 0 ) checkContent ( content , state ) ; } else { checkContentList ( content , state ) ; } return null ; } public void setLocale ( Locale locale ) { fLocale = locale ; } public Hashtable getFacets ( ) { return null ; } private void checkContent ( String content , Object state ) throws InvalidDatatypeValueException { if ( this . fBaseValidator != null ) { this . fBaseValidator . validate ( content , state ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_MAXLENGTH ) != 0 ) { if ( content . length ( ) > fMaxLength ) { throw new InvalidDatatypeValueException ( "Value '" + content + "' with length '" + content . length ( ) + "' exceeds maximum length facet of '" + fMaxLength + "'." ) ; } } if ( ( fFacetsDefined & DatatypeValidator . FACET_MINLENGTH ) != 0 ) { if ( content . length ( ) < fMinLength ) { throw new InvalidDatatypeValueException ( "Value '" + content + "' with length '" + content . length ( ) + "' is less than minimum length facet of '" + fMinLength + "'." ) ; } } if ( ( fFacetsDefined & DatatypeValidator . FACET_LENGTH ) != 0 ) { if ( content . length ( ) != fLength ) { throw new InvalidDatatypeValueException ( "Value '" + content + "' with length '" + content . length ( ) + "' is not equal to length facet '" + fLength + "'." ) ; } } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { if ( fEnumeration . contains ( content ) == false ) throw new InvalidDatatypeValueException ( "Value '" + content + "' must be one of " + fEnumeration ) ; } if ( isMaxExclusiveDefined == true ) { int comparisonResult ; comparisonResult = compare ( content , fMaxExclusive ) ; if ( comparisonResult >= 0 ) { throw new InvalidDatatypeValueException ( "MaxExclusive:Value '" + content + "'  must be " + "lexicographically less than" + fMaxExclusive ) ; } } if ( isMaxInclusiveDefined == true ) { int comparisonResult ; comparisonResult = compare ( content , fMaxInclusive ) ; if ( comparisonResult > 0 ) throw new InvalidDatatypeValueException ( "MaxInclusive:Value '" + content + "' must be " + "lexicographically less or equal than" + fMaxInclusive ) ; } if ( isMinExclusiveDefined == true ) { int comparisonResult ; comparisonResult = compare ( content , fMinExclusive ) ; if ( comparisonResult <= 0 ) throw new InvalidDatatypeValueException ( "MinExclusive:Value '" + content + "' must be " + "lexicographically greater than" + fMinExclusive ) ; } if ( isMinInclusiveDefined == true ) { int comparisonResult ; comparisonResult = compare ( content , fMinInclusive ) ; if ( comparisonResult < 0 ) throw new InvalidDatatypeValueException ( "MinInclusive:Value '" + content + "' must be " + "lexicographically greater or equal than '" + fMinInclusive + "'." ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_PATTERN ) != 0 ) { if ( fRegex == null || fRegex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value '" + content + "' does not match regular expression facet '" + fPattern + "'." ) ; } } public int compare ( String content , String facetValue ) { Locale loc = Locale . getDefault ( ) ; Collator collator = Collator . getInstance ( loc ) ; return collator . compare ( content , facetValue ) ; } public Object clone ( ) throws CloneNotSupportedException { StringDatatypeValidator newObj = null ; try { newObj = new StringDatatypeValidator ( ) ; newObj . fLocale = this . fLocale ; newObj . fBaseValidator = this . fBaseValidator ; newObj . fLength = this . fLength ; newObj . fMaxLength = this . fMaxLength ; newObj . fMinLength = this . fMinLength ; newObj . fPattern = this . fPattern ; newObj . fEnumeration = this . fEnumeration ; newObj . fMaxInclusive = this . fMaxInclusive ; newObj . fMaxExclusive = this . fMaxExclusive ; newObj . fMinInclusive = this . fMinInclusive ; newObj . fMinExclusive = this . fMinExclusive ; newObj . fFacetsDefined = this . fFacetsDefined ; newObj . fDerivedByList = this . fDerivedByList ; newObj . isMaxExclusiveDefined = this . isMaxExclusiveDefined ; newObj . isMaxInclusiveDefined = this . isMaxInclusiveDefined ; newObj . isMinExclusiveDefined = this . isMinExclusiveDefined ; newObj . isMinInclusiveDefined = this . isMinInclusiveDefined ; } catch ( InvalidDatatypeFacetException ex ) { ex . printStackTrace ( ) ; } return newObj ; } private void checkContentList ( String content , Object state ) throws InvalidDatatypeValueException { StringTokenizer parsedList = new StringTokenizer ( content ) ; try { int numberOfTokens = parsedList . countTokens ( ) ; if ( ( fFacetsDefined & DatatypeValidator . FACET_MAXLENGTH ) != 0 ) { if ( numberOfTokens > fMaxLength ) { throw new InvalidDatatypeValueException ( "Value '" + content + "' with length ='" + numberOfTokens + "'tokens" + "' exceeds maximum length facet with  '" + fMaxLength + "' tokens." ) ; } } if ( ( fFacetsDefined & DatatypeValidator . FACET_MINLENGTH ) != 0 ) { if ( numberOfTokens < fMinLength ) { throw new InvalidDatatypeValueException ( "Value '" + content + "' with length ='" + numberOfTokens + "'tokens" + "' is less than minimum length facet with '" + fMinLength + "' tokens." ) ; } } if ( ( fFacetsDefined & DatatypeValidator . FACET_LENGTH ) != 0 ) { if ( numberOfTokens != fLength ) { throw new InvalidDatatypeValueException ( "Value '" + content + "' with length ='" + numberOfTokens + "'tokens" + "' is not equal to length facet with '" + fLength + "'. tokens" ) ; } } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { if ( fEnumeration . contains ( content ) == false ) throw new InvalidDatatypeValueException ( "Value '" + content + "' must be one of " + fEnumeration ) ; } while ( parsedList . hasMoreTokens ( ) ) { if ( this . fBaseValidator != null ) { this . fBaseValidator . validate ( parsedList . nextToken ( ) , state ) ; } } } catch ( NoSuchElementException e ) { e . printStackTrace ( ) ; } } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } } 	0
package org . apache . xerces . domx ; public abstract class DOMException extends org . w3c . dom . DOMException { public static final short UNSPECIFIED_EVENT_TYPE = 100 ; public static final short UNSUPPORTED_EVENT_TYPE = 101 ; public DOMException ( short code , String message ) { super ( code , message ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLFormElement extends HTMLElement { public HTMLCollection getElements ( ) ; public int getLength ( ) ; public String getName ( ) ; public void setName ( String name ) ; public String getAcceptCharset ( ) ; public void setAcceptCharset ( String acceptCharset ) ; public String getAction ( ) ; public void setAction ( String action ) ; public String getEnctype ( ) ; public void setEnctype ( String enctype ) ; public String getMethod ( ) ; public void setMethod ( String method ) ; public String getTarget ( ) ; public void setTarget ( String target ) ; public void submit ( ) ; public void reset ( ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrNSImpl extends AttrImpl { static final long serialVersionUID = - 781906615369795414L ; protected String namespaceURI ; protected String localName ; protected AttrNSImpl ( DocumentImpl ownerDocument , String namespaceURI , String qualifiedName ) { super ( ownerDocument , qualifiedName ) ; if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = qualifiedName ; } else { prefix = qualifiedName . substring ( 0 , index ) ; localName = qualifiedName . substring ( index + 1 ) ; } if ( ( prefix != null && ( namespaceURI == null || namespaceURI . equals ( "" ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) || ( prefix . equals ( "xmlns" ) && ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) ) || ( qualifiedName . equals ( "xmlns" ) && ( namespaceURI == null || ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } this . namespaceURI = namespaceURI ; } protected AttrNSImpl ( DocumentImpl ownerDocument , String value ) { super ( ownerDocument , value ) ; } public String getNamespaceURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return namespaceURI ; } public String getPrefix ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int index = name . indexOf ( ':' ) ; return index < 0 ? null : name . substring ( 0 , index ) ; } public void setPrefix ( String prefix ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( namespaceURI == null || ( prefix != null && ( ( prefix . equals ( "xmlns" ) && ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } if ( ownerDocument . errorChecking && ! DocumentImpl . isXMLName ( prefix ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } name = prefix + ":" + localName ; } public String getLocalName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return localName ; } } 	1
package org . apache . wml ; public interface WMLNoopElement extends WMLElement { } 	0
package org . apache . xerces . jaxp ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . xml . sax . SAXException ; public class SAXParserFactoryImpl extends SAXParserFactory { public SAXParserFactoryImpl ( ) { super ( ) ; } public SAXParser newSAXParser ( ) throws ParserConfigurationException { return ( new SAXParserImpl ( this . isNamespaceAware ( ) , this . isValidating ( ) ) ) ; } } 	1
package org . xml . sax ; public class SAXNotRecognizedException extends SAXException { public SAXNotRecognizedException ( String message ) { super ( message ) ; } } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public class AttributeMap extends NamedNodeMapImpl { protected AttributeMap ( ElementImpl ownerNode , NamedNodeMapImpl defaults ) { super ( ownerNode ) ; if ( defaults != null ) { cloneContent ( defaults ) ; if ( nodes != null ) { hasDefaults ( true ) ; } } } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } NodeImpl argn = ( NodeImpl ) arg ; if ( argn . isOwned ( ) ) { throw new DOMExceptionImpl ( DOMException . INUSE_ATTRIBUTE_ERR , "DOM009 Attribute already in use" ) ; } argn . ownerNode = ownerNode ; argn . isOwned ( true ) ; int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; previous . ownerNode = ownerNode . ownerDocument ( ) ; previous . isOwned ( false ) ; previous . isSpecified ( true ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { ownerNode . dispatchAggregateEvents ( ( AttrImpl ) arg , previous == null ? null : previous . getNodeValue ( ) ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } NodeImpl argn = ( NodeImpl ) arg ; if ( argn . isOwned ( ) ) { throw new DOMExceptionImpl ( DOMException . INUSE_ATTRIBUTE_ERR , "DOM009 Attribute already in use" ) ; } argn . ownerNode = ownerNode ; argn . isOwned ( true ) ; int i = findNamePoint ( argn . getNamespaceURI ( ) , argn . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; previous . ownerNode = ownerNode . ownerDocument ( ) ; previous . isOwned ( false ) ; previous . isSpecified ( true ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { ownerNode . dispatchAggregateEvents ( ( AttrImpl ) arg , previous == null ? null : previous . getNodeValue ( ) ) ; } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { return internalRemoveNamedItem ( name , true ) ; } Node safeRemoveNamedItem ( String name ) { return internalRemoveNamedItem ( name , false ) ; } final protected Node internalRemoveNamedItem ( String name , boolean raiseEx ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { if ( raiseEx ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } else { return null ; } } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; if ( hasDefaults ( ) ) { NamedNodeMapImpl defaults = ( ( ElementImpl ) ownerNode ) . getDefaultAttributes ( ) ; Node d ; if ( defaults != null && ( d = defaults . getNamedItem ( name ) ) != null && findNamePoint ( name , i + 1 ) < 0 ) { NodeImpl clone = ( NodeImpl ) d . cloneNode ( true ) ; clone . ownerNode = ownerNode ; clone . isOwned ( true ) ; clone . isSpecified ( false ) ; nodes . setElementAt ( clone , i ) ; } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } n . ownerNode = ownerNode . ownerDocument ( ) ; n . isOwned ( false ) ; n . isSpecified ( true ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { return internalRemoveNamedItemNS ( namespaceURI , name , true ) ; } Node safeRemoveNamedItemNS ( String namespaceURI , String name ) { return internalRemoveNamedItemNS ( namespaceURI , name , false ) ; } final protected Node internalRemoveNamedItemNS ( String namespaceURI , String name , boolean raiseEx ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { if ( raiseEx ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } else { return null ; } } LCount lc = null ; String oldvalue = "" ; AttrImpl enclosingAttribute = null ; if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttribute = ( AttrImpl ) ( nodes . elementAt ( i ) ) ; oldvalue = enclosingAttribute . getNodeValue ( ) ; } } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; String nodeName = n . getNodeName ( ) ; if ( hasDefaults ( ) ) { NamedNodeMapImpl defaults = ( ( ElementImpl ) ownerNode ) . getDefaultAttributes ( ) ; Node d ; if ( defaults != null && ( d = defaults . getNamedItem ( nodeName ) ) != null ) { int j = findNamePoint ( nodeName , 0 ) ; if ( j >= 0 && findNamePoint ( nodeName , j + 1 ) < 0 ) { NodeImpl clone = ( NodeImpl ) d . cloneNode ( true ) ; clone . ownerNode = ownerNode ; clone . isOwned ( true ) ; clone . isSpecified ( false ) ; nodes . setElementAt ( clone , i ) ; } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } n . ownerNode = ownerNode . ownerDocument ( ) ; n . isOwned ( false ) ; n . isSpecified ( true ) ; if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_ATTR_MODIFIED , true , false , null , n . getNodeValue ( ) , ( ( ElementImpl ) ownerNode ) . getAttribute ( name ) , name ) ; ownerNode . dispatchEvent ( me ) ; } ownerNode . dispatchAggregateEvents ( null , null ) ; } return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { AttributeMap newmap = new AttributeMap ( ( ElementImpl ) ownerNode , null ) ; newmap . hasDefaults ( hasDefaults ( ) ) ; newmap . cloneContent ( this ) ; return newmap ; } } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . utils . StringPool ; public final class DeferredAttrNSImpl extends AttrNSImpl implements DeferredNode { static final long serialVersionUID = 6074924934945957154L ; protected transient int fNodeIndex ; DeferredAttrNSImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; needsSyncChildren ( true ) ; } public int getNodeIndex ( ) { return fNodeIndex ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; int attrQName = ownerDocument . getNodeName ( fNodeIndex ) ; StringPool pool = ownerDocument . getStringPool ( ) ; name = pool . toString ( attrQName ) ; int index = name . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = name ; } else { prefix = name . substring ( 0 , index ) ; localName = name . substring ( index + 1 ) ; } isSpecified ( ownerDocument . getNodeValue ( fNodeIndex ) == 1 ) ; namespaceURI = pool . toString ( ownerDocument . getNodeURI ( fNodeIndex ) ) ; if ( namespaceURI == null ) { if ( prefix != null ) { if ( prefix . equals ( "xmlns" ) ) { namespaceURI = "http://www.w3.org/2000/xmlns/" ; } } else if ( name . equals ( "xmlns" ) ) { namespaceURI = "http://www.w3.org/2000/xmlns/" ; } } } protected void synchronizeChildren ( ) { synchronizeChildren ( fNodeIndex ) ; } } 	0
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . w3c . dom . Document ; public abstract class DocumentBuilder { protected DocumentBuilder ( ) { super ( ) ; } public Document parse ( InputStream stream ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( stream ) ) ) ; } public Document parse ( String uri ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( uri ) ) ) ; } public Document parse ( File file ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( file . getName ( ) ) ) ) ; } public abstract Document parse ( InputSource source ) throws SAXException , IOException , IllegalArgumentException ; public abstract Document newDocument ( ) ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; public abstract void setEntityResolver ( EntityResolver er ) ; public abstract void setErrorHandler ( ErrorHandler eh ) ; } 	1
package org . apache . xerces . framework ; import org . apache . xerces . utils . StringPool ; public class XMLContentSpec { public static final int CONTENTSPECNODE_LEAF = 0 ; public static final int CONTENTSPECNODE_ZERO_OR_ONE = 1 ; public static final int CONTENTSPECNODE_ZERO_OR_MORE = 2 ; public static final int CONTENTSPECNODE_ONE_OR_MORE = 3 ; public static final int CONTENTSPECNODE_CHOICE = 4 ; public static final int CONTENTSPECNODE_SEQ = 5 ; public static final int CONTENTSPECNODE_ANY = 6 ; public static final int CONTENTSPECNODE_ANY_OTHER = 7 ; public static final int CONTENTSPECNODE_ANY_LOCAL = 8 ; public static final int CONTENTSPECNODE_ANY_LAX = 22 ; public static final int CONTENTSPECNODE_ANY_OTHER_LAX = 23 ; public static final int CONTENTSPECNODE_ANY_LOCAL_LAX = 24 ; public static final int CONTENTSPECNODE_ANY_SKIP = 38 ; public static final int CONTENTSPECNODE_ANY_OTHER_SKIP = 39 ; public static final int CONTENTSPECNODE_ANY_LOCAL_SKIP = 40 ; public int type ; public int value ; public int otherValue ; public XMLContentSpec ( ) { clear ( ) ; } public XMLContentSpec ( int type , int value , int otherValue ) { setValues ( type , value , otherValue ) ; } public XMLContentSpec ( XMLContentSpec contentSpec ) { setValues ( contentSpec ) ; } public XMLContentSpec ( XMLContentSpec . Provider provider , int contentSpecIndex ) { setValues ( provider , contentSpecIndex ) ; } public void clear ( ) { type = - 1 ; value = - 1 ; otherValue = - 1 ; } public void setValues ( int type , int value , int otherValue ) { this . type = type ; this . value = value ; this . otherValue = otherValue ; } public void setValues ( XMLContentSpec contentSpec ) { type = contentSpec . type ; value = contentSpec . value ; otherValue = contentSpec . otherValue ; } public void setValues ( XMLContentSpec . Provider provider , int contentSpecIndex ) { if ( ! provider . getContentSpec ( contentSpecIndex , this ) ) { clear ( ) ; } } public static String toString ( XMLContentSpec . Provider provider , StringPool stringPool , int contentSpecIndex ) { XMLContentSpec contentSpec = new XMLContentSpec ( ) ; if ( provider . getContentSpec ( contentSpecIndex , contentSpec ) ) { StringBuffer str = new StringBuffer ( ) ; int parentContentSpecType = contentSpec . type & 0x0f ; int nextContentSpec ; switch ( parentContentSpecType ) { case XMLContentSpec . CONTENTSPECNODE_LEAF : { str . append ( '(' ) ; if ( contentSpec . value == - 1 && contentSpec . otherValue == - 1 ) { str . append ( "#PCDATA" ) ; } else if ( contentSpec . otherValue != - 1 ) { str . append ( "##any:uri=" + stringPool . toString ( contentSpec . otherValue ) ) ; } else if ( contentSpec . value == - 1 ) { str . append ( "##any" ) ; } else { str . append ( stringPool . toString ( contentSpec . value ) ) ; } str . append ( ')' ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE : { provider . getContentSpec ( contentSpec . value , contentSpec ) ; nextContentSpec = contentSpec . type ; if ( nextContentSpec == XMLContentSpec . CONTENTSPECNODE_LEAF ) { str . append ( '(' ) ; str . append ( stringPool . toString ( contentSpec . value ) ) ; str . append ( ')' ) ; } else if ( nextContentSpec == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE || nextContentSpec == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE || nextContentSpec == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) { str . append ( '(' ) ; appendContentSpec ( provider , stringPool , contentSpec , str , true , parentContentSpecType ) ; str . append ( ')' ) ; } else { appendContentSpec ( provider , stringPool , contentSpec , str , true , parentContentSpecType ) ; } str . append ( '?' ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE : { provider . getContentSpec ( contentSpec . value , contentSpec ) ; nextContentSpec = contentSpec . type ; if ( nextContentSpec == XMLContentSpec . CONTENTSPECNODE_LEAF ) { str . append ( '(' ) ; if ( contentSpec . value == - 1 && contentSpec . otherValue == - 1 ) { str . append ( "#PCDATA" ) ; } else if ( contentSpec . otherValue != - 1 ) { str . append ( "##any:uri=" + stringPool . toString ( contentSpec . otherValue ) ) ; } else if ( contentSpec . value == - 1 ) { str . append ( "##any" ) ; } else { appendContentSpec ( provider , stringPool , contentSpec , str , true , parentContentSpecType ) ; } str . append ( ')' ) ; } else if ( nextContentSpec == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE || nextContentSpec == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE || nextContentSpec == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) { str . append ( '(' ) ; appendContentSpec ( provider , stringPool , contentSpec , str , true , parentContentSpecType ) ; str . append ( ')' ) ; } else { appendContentSpec ( provider , stringPool , contentSpec , str , true , parentContentSpecType ) ; } str . append ( '*' ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE : { provider . getContentSpec ( contentSpec . value , contentSpec ) ; nextContentSpec = contentSpec . type ; if ( nextContentSpec == XMLContentSpec . CONTENTSPECNODE_LEAF ) { str . append ( '(' ) ; if ( contentSpec . value == - 1 && contentSpec . otherValue == - 1 ) { str . append ( "#PCDATA" ) ; } else if ( contentSpec . otherValue != - 1 ) { str . append ( "##any:uri=" + stringPool . toString ( contentSpec . otherValue ) ) ; } else if ( contentSpec . value == - 1 ) { str . append ( "##any" ) ; } else { str . append ( stringPool . toString ( contentSpec . value ) ) ; } str . append ( ')' ) ; } else if ( nextContentSpec == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE || nextContentSpec == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE || nextContentSpec == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) { str . append ( '(' ) ; appendContentSpec ( provider , stringPool , contentSpec , str , true , parentContentSpecType ) ; str . append ( ')' ) ; } else { appendContentSpec ( provider , stringPool , contentSpec , str , true , parentContentSpecType ) ; } str . append ( '+' ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_CHOICE : case XMLContentSpec . CONTENTSPECNODE_SEQ : { appendContentSpec ( provider , stringPool , contentSpec , str , true , parentContentSpecType ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_ANY : { str . append ( "##any" ) ; if ( contentSpec . otherValue != - 1 ) { str . append ( ":uri=" ) ; str . append ( stringPool . toString ( contentSpec . otherValue ) ) ; } break ; } case XMLContentSpec . CONTENTSPECNODE_ANY_OTHER : { str . append ( "##other:uri=" ) ; str . append ( stringPool . toString ( contentSpec . otherValue ) ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL : { str . append ( "##local" ) ; break ; } default : { str . append ( "???" ) ; } } return str . toString ( ) ; } return null ; } public int hashCode ( ) { return type << 16 | value << 8 | otherValue ; } public boolean equals ( Object object ) { if ( object != null && object instanceof XMLContentSpec ) { XMLContentSpec contentSpec = ( XMLContentSpec ) object ; return type == contentSpec . type && value == contentSpec . value && otherValue == contentSpec . otherValue ; } return false ; } private static void appendContentSpec ( XMLContentSpec . Provider provider , StringPool stringPool , XMLContentSpec contentSpec , StringBuffer str , boolean parens , int parentContentSpecType ) { int thisContentSpec = contentSpec . type & 0x0f ; switch ( thisContentSpec ) { case XMLContentSpec . CONTENTSPECNODE_LEAF : { if ( contentSpec . value == - 1 && contentSpec . otherValue == - 1 ) { str . append ( "#PCDATA" ) ; } else if ( contentSpec . value == - 1 && contentSpec . otherValue != - 1 ) { str . append ( "##any:uri=" + stringPool . toString ( contentSpec . otherValue ) ) ; } else if ( contentSpec . value == - 1 ) { str . append ( "##any" ) ; } else { str . append ( stringPool . toString ( contentSpec . value ) ) ; } break ; } case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE : { if ( parentContentSpecType == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE || parentContentSpecType == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE || parentContentSpecType == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) { provider . getContentSpec ( contentSpec . value , contentSpec ) ; str . append ( '(' ) ; appendContentSpec ( provider , stringPool , contentSpec , str , true , thisContentSpec ) ; str . append ( ')' ) ; } else { provider . getContentSpec ( contentSpec . value , contentSpec ) ; appendContentSpec ( provider , stringPool , contentSpec , str , true , thisContentSpec ) ; } str . append ( '?' ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE : { if ( parentContentSpecType == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE || parentContentSpecType == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE || parentContentSpecType == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) { provider . getContentSpec ( contentSpec . value , contentSpec ) ; str . append ( '(' ) ; appendContentSpec ( provider , stringPool , contentSpec , str , true , thisContentSpec ) ; str . append ( ')' ) ; } else { provider . getContentSpec ( contentSpec . value , contentSpec ) ; appendContentSpec ( provider , stringPool , contentSpec , str , true , thisContentSpec ) ; } str . append ( '*' ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE : { if ( parentContentSpecType == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE || parentContentSpecType == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE || parentContentSpecType == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) { str . append ( '(' ) ; provider . getContentSpec ( contentSpec . value , contentSpec ) ; appendContentSpec ( provider , stringPool , contentSpec , str , true , thisContentSpec ) ; str . append ( ')' ) ; } else { provider . getContentSpec ( contentSpec . value , contentSpec ) ; appendContentSpec ( provider , stringPool , contentSpec , str , true , thisContentSpec ) ; } str . append ( '+' ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_CHOICE : case XMLContentSpec . CONTENTSPECNODE_SEQ : { if ( parens ) { str . append ( '(' ) ; } int type = contentSpec . type ; int otherValue = contentSpec . otherValue ; provider . getContentSpec ( contentSpec . value , contentSpec ) ; appendContentSpec ( provider , stringPool , contentSpec , str , contentSpec . type != type , thisContentSpec ) ; if ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) { str . append ( '|' ) ; } else { str . append ( ',' ) ; } provider . getContentSpec ( otherValue , contentSpec ) ; appendContentSpec ( provider , stringPool , contentSpec , str , true , thisContentSpec ) ; if ( parens ) { str . append ( ')' ) ; } break ; } case XMLContentSpec . CONTENTSPECNODE_ANY : { str . append ( "##any" ) ; if ( contentSpec . otherValue != - 1 ) { str . append ( ":uri=" ) ; str . append ( stringPool . toString ( contentSpec . otherValue ) ) ; } break ; } case XMLContentSpec . CONTENTSPECNODE_ANY_OTHER : { str . append ( "##other:uri=" ) ; str . append ( stringPool . toString ( contentSpec . otherValue ) ) ; break ; } case XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL : { str . append ( "##local" ) ; break ; } default : { str . append ( "???" ) ; break ; } } } public interface Provider { public boolean getContentSpec ( int contentSpecIndex , XMLContentSpec contentSpec ) ; } } 	0
package org . apache . xerces . dom . events ; import org . apache . xerces . dom . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; public class MutationEventImpl extends org . apache . xerces . dom . events . EventImpl implements MutationEvent { Node relatedNode = null ; String prevValue = null , newValue = null , attrName = null ; public static final String DOM_SUBTREE_MODIFIED = "DOMSubtreeModified" ; public static final String DOM_NODE_INSERTED = "DOMNodeInserted" ; public static final String DOM_NODE_REMOVED = "DOMNodeRemoved" ; public static final String DOM_NODE_REMOVED_FROM_DOCUMENT = "DOMNodeRemovedFromDocument" ; public static final String DOM_NODE_INSERTED_INTO_DOCUMENT = "DOMNodeInsertedIntoDocument" ; public static final String DOM_ATTR_MODIFIED = "DOMAttrModified" ; public static final String DOM_CHARACTER_DATA_MODIFIED = "DOMCharacterDataModified" ; public String getAttrName ( ) { return attrName ; } public String getNewValue ( ) { return newValue ; } public String getPrevValue ( ) { return prevValue ; } public Node getRelatedNode ( ) { return relatedNode ; } public void initMutationEvent ( String typeArg , boolean canBubbleArg , boolean cancelableArg , Node relatedNodeArg , String prevValueArg , String newValueArg , String attrNameArg ) { relatedNode = relatedNodeArg ; prevValue = prevValueArg ; newValue = newValueArg ; attrName = attrNameArg ; super . initEvent ( typeArg , canBubbleArg , cancelableArg ) ; } } 	1
package org . apache . xerces . msg ; public class ImplementationMessages extends java . util . ListResourceBundle { public static final Object CONTENTS [ ] [ ] = { { "BadMajorCode" , "The majorCode parameter to createMessage was out of bounds." } , { "FormatFailed" , "An internal error occurred while formatting the following message:\n  " } , { "ENC4" , "Invalid UTF-8 code. (byte: 0x{0})" } , { "ENC5" , "Invalid UTF-8 code. (bytes: 0x{0} 0x{1})" } , { "ENC6" , "Invalid UTF-8 code. (bytes: 0x{0} 0x{1} 0x{2})" } , { "ENC7" , "Invalid UTF-8 code. (bytes: 0x{0} 0x{1} 0x{2} 0x{3})" } , { "FileNotFound" , "File \"{0}\" not found." } , { "VAL_BST" , "Invalid ContentSpecNode.NODE_XXX value for binary op CMNode" } , { "VAL_CMSI" , "Invalid CMStateSet bit index" } , { "VAL_CST" , "Unknown ContentSpecNode.NODE_XXX value" } , { "VAL_LST" , "Invalid ContentSpecNode.NODE_XXX value for leaf CMNode" } , { "VAL_NIICM" , "Only * unary ops should be in the internal content model tree" } , { "VAL_NPCD" , "PCData node found in non-mixed model content" } , { "VAL_UST" , "Invalid ContentSpecNode.NODE_XXX value for unary op CMNode" } , { "VAL_WCGHI" , "The input to whatCanGoHere() is inconsistent" } , { "INT_DCN" , "Internal Error: dataChunk == NULL" } , { "INT_PCN" , "Internal Error: fPreviousChunk == NULL" } , { "FatalError" , "Stopping after fatal error: {0}" } , } ; public Object [ ] [ ] getContents ( ) { return CONTENTS ; } } 	0
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . SymbolCache ; import org . apache . xerces . utils . UTF8DataChunk ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . LocatorImpl ; import java . io . InputStream ; import java . util . Vector ; final class UTF8Reader extends XMLEntityReader { private final static boolean USE_OUT_OF_LINE_LOAD_NEXT_BYTE = false ; private final static boolean USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE = true ; public UTF8Reader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , InputStream dataStream , StringPool stringPool ) throws Exception { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fInputStream = dataStream ; fStringPool = stringPool ; fCharArrayRange = fStringPool . createCharArrayRange ( ) ; fCurrentChunk = UTF8DataChunk . createChunk ( fStringPool , null ) ; fillCurrentChunk ( ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } private int addSymbol ( int offset , int length , int hashcode ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , hashcode ) ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } private int slowLoadNextByte ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; return ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } else { fCurrentChunk = UTF8DataChunk . createChunk ( fStringPool , fCurrentChunk ) ; return fillCurrentChunk ( ) ; } } private int loadNextByte ( ) throws Exception { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; return fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { return slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) return slowLoadNextByte ( ) ; else return ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; fMostRecentData = null ; fMostRecentByte = 0 ; return nextReader ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) throws Exception { int b0 = fMostRecentByte ; if ( b0 != ch ) { if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( ch , skipPastChar ) ; } } if ( ch == 0x0A && b0 == 0x0D ) { if ( skipPastChar ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; b0 = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == 0x0A ) { fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } } return true ; } return false ; } if ( ch == 0x0D ) return false ; if ( skipPastChar ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int b0 = fMostRecentByte ; if ( b0 < 0x80 ) { if ( b0 >= 0x20 || b0 == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } if ( b0 == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } if ( b0 == 0x0D ) { if ( skipPastChar ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; b0 = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == 0x0A ) { fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } } return true ; } if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; } return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { boolean result = false ; if ( ! ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; return true ; } result = true ; } fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } int b3 = loadNextByte ( ) ; boolean result = false ; if ( ( ( b0 & 0xf8 ) == 0xf0 ) && ( ( b1 & 0xc0 ) == 0x80 ) && ( ( b2 & 0xc0 ) == 0x80 ) && ( ( b3 & 0xc0 ) == 0x80 ) ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; return true ; } result = true ; fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentByte ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { if ( ! skipPastChar ) return true ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) return true ; fLinefeedCounter ++ ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return true ; } public void skipToChar ( char ch ) throws Exception { int b0 = fMostRecentByte ; while ( true ) { if ( b0 == ch ) return ; if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( ch ) ; return ; } fCharacterCounter ++ ; } else if ( b0 == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( b0 == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; if ( b0 != 0x0A ) continue ; fLinefeedCounter ++ ; } else if ( b0 < 0x80 ) { fCharacterCounter ++ ; } else { fCharacterCounter ++ ; if ( ( 0xe0 & b0 ) == 0xc0 ) { loadNextByte ( ) ; } else if ( ( 0xf0 & b0 ) == 0xe0 ) { loadNextByte ( ) ; loadNextByte ( ) ; } else { loadNextByte ( ) ; loadNextByte ( ) ; loadNextByte ( ) ; } } b0 = loadNextByte ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentByte ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) continue ; fLinefeedCounter ++ ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } } protected boolean skippedMultiByteCharWithFlag ( int b0 , int flag ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { if ( ( XMLCharacterProperties . fgCharFlags [ ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ] & flag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } if ( ( XMLCharacterProperties . fgCharFlags [ ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ] & flag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } return true ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } public void skipPastName ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ b0 ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_InitialNameCharFlag ) ) return ; } while ( true ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( fastcheck == b0 ) return ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_NameCharFlag ) ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; while ( true ) { if ( fastcheck == b0 ) return ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) return ; } else { if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_NameCharFlag ) ) return ; } fCharacterCounter ++ ; b0 = loadNextByte ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int length = s . length ; byte [ ] data = fMostRecentData ; int index = fCurrentIndex + length ; int sindex = length ; try { while ( sindex -- > 0 ) { if ( data [ -- index ] != s [ sindex ] ) return false ; } fCurrentIndex += length ; } catch ( ArrayIndexOutOfBoundsException ex ) { int i = 0 ; index = fCurrentIndex ; while ( index < UTF8DataChunk . CHUNK_SIZE ) { if ( data [ index ++ ] != s [ i ++ ] ) return false ; } UTF8DataChunk dataChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; int savedIndex = fCurrentIndex ; slowLoadNextByte ( ) ; data = fMostRecentData ; index = 0 ; while ( i < length ) { if ( data [ index ++ ] != s [ i ++ ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; return false ; } } fCurrentIndex = index ; } fCharacterCounter += length ; fCurrentOffset += length ; try { fMostRecentByte = data [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } return true ; } public int scanInvalidChar ( ) throws Exception { int b0 = fMostRecentByte ; int ch = b0 ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; if ( ch != 0x0A ) return 0x0A ; fLinefeedCounter ++ ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } fCharacterCounter ++ ; } else if ( b0 >= 0x80 ) { fCharacterCounter ++ ; int b1 = loadNextByte ( ) ; int b2 = 0 ; if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; } else if ( ( 0xf0 & b0 ) == 0xe0 ) { b2 = loadNextByte ( ) ; ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; } else if ( ( 0xf8 & b0 ) == 0xf0 ) { b2 = loadNextByte ( ) ; int b3 = loadNextByte ( ) ; ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; } } loadNextByte ( ) ; return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentByte ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextByte ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentByte ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextByte ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextByte ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = fCurrentChunk . addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public static final byte fgAsciiAttValueChar [ ] = { 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 2 , 2 , 4 , 4 , 2 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 0 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; int b0 = fMostRecentByte ; while ( true ) { if ( b0 < 0x80 ) { switch ( fgAsciiAttValueChar [ b0 ] ) { case 1 : if ( b0 == qchar ) { int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : ( asSymbol ? fCurrentChunk . addSymbol ( offset , length , 0 ) : fCurrentChunk . addString ( offset , length ) ) ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return result ; } case 0 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 2 : return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; case 3 : return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; case 4 : return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( b0 ) ) return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; b0 = fMostRecentByte ; } } } public static final byte fgAsciiEntityValueChar [ ] = { 7 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 5 , 4 , 4 , 6 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 3 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; int b0 = fMostRecentByte ; while ( true ) { if ( b0 < 0x80 ) { switch ( fgAsciiEntityValueChar [ b0 ] ) { case 1 : if ( b0 == qchar ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : fCurrentChunk . addString ( offset , length ) ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return result ; } case 0 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 5 : fLinefeedCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 6 : fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 != 0x0A ) { continue ; } fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 2 : return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; case 3 : return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; case 7 : if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } case 4 : return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( b0 ) ) return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; b0 = fMostRecentByte ; } } } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int b0 = fMostRecentByte ; int ch = 0 ; int i = 0 ; while ( true ) { if ( b0 < 0x80 ) { ch = b0 ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } } else { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; skipPastNmtoken ( fastcheck ) ; return false ; } } else { int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; skipPastNmtoken ( fastcheck ) ; return false ; } } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } } i ++ ; offset ++ ; fCharacterCounter ++ ; fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentByte ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; int index = fCurrentIndex ; byte [ ] data = fMostRecentData ; int prefixend = - 1 ; while ( true ) { fCharacterCounter ++ ; fCurrentOffset ++ ; index ++ ; try { ch = data [ index ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; index = 0 ; data = fMostRecentData ; } if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; try { ch = data [ index + 1 ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { UTF8DataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; ch = slowLoadNextByte ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; } boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; break ; } } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } } fCurrentIndex = index ; fMostRecentByte = ch ; int length = fCurrentOffset - offset ; qname . rawname = addSymbol ( offset , length ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } private int getMultiByteSymbolChar ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } loadNextByte ( ) ; return ch ; } int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } loadNextByte ( ) ; return ch ; } fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } public int scanName ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; int ch ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ b0 ] == 0 ) { if ( b0 == 0 && atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanName ( fastcheck ) ; } return - 1 ; } ch = b0 ; } else { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } else { int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return scanMatchingName ( ch , b0 , fastcheck ) ; } private int scanMatchingName ( int ch , int b0 , int fastcheck ) throws Exception { SymbolCache cache = fStringPool . getSymbolCache ( ) ; int [ ] [ ] cacheLines = cache . fCacheLines ; char [ ] symbolChars = cache . fSymbolChars ; boolean lengthOfOne = fastcheck == fMostRecentByte ; int startOffset = cache . fSymbolCharsOffset ; int entry = 0 ; int [ ] entries = cacheLines [ entry ] ; int offset = 1 + ( ( entries [ 0 ] - 1 ) * SymbolCache . CACHE_RECORD_SIZE ) ; int totalMisses = 0 ; if ( lengthOfOne ) { while ( offset > 0 ) { if ( entries [ offset + SymbolCache . CHAR_OFFSET ] == ch ) { if ( entries [ offset + SymbolCache . INDEX_OFFSET ] != - 1 ) { int symbolIndex = entries [ offset + SymbolCache . INDEX_OFFSET ] ; if ( totalMisses > 3 ) fStringPool . updateCacheLine ( symbolIndex , totalMisses , 1 ) ; return symbolIndex ; } break ; } offset -= SymbolCache . CACHE_RECORD_SIZE ; totalMisses ++ ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; if ( offset < 0 ) { offset = 1 + ( entries [ 0 ] * SymbolCache . CACHE_RECORD_SIZE ) ; entries [ 0 ] ++ ; try { entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; entries = new int [ newSize ] ; System . arraycopy ( cacheLines [ entry ] , 0 , entries , 0 , offset ) ; cacheLines [ entry ] = entries ; entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } entries [ offset + SymbolCache . NEXT_OFFSET ] = - 1 ; } int result = fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; return result ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; int depth = 1 ; while ( true ) { if ( offset < 0 ) break ; if ( entries [ offset + SymbolCache . CHAR_OFFSET ] != ch ) { offset -= SymbolCache . CACHE_RECORD_SIZE ; totalMisses ++ ; continue ; } if ( b0 >= 0x80 ) { ch = getMultiByteSymbolChar ( b0 ) ; b0 = fMostRecentByte ; } else if ( b0 == fastcheck || XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) { ch = - 1 ; } else { ch = b0 ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } if ( ch == - 1 ) { if ( entries [ offset + SymbolCache . INDEX_OFFSET ] == - 1 ) { return fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; } cache . fSymbolCharsOffset = startOffset ; int symbolIndex = entries [ offset + SymbolCache . INDEX_OFFSET ] ; if ( totalMisses > ( depth * 3 ) ) fStringPool . updateCacheLine ( symbolIndex , totalMisses , depth ) ; return symbolIndex ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; entry = entries [ offset + SymbolCache . NEXT_OFFSET ] ; try { entries = cacheLines [ entry ] ; } catch ( ArrayIndexOutOfBoundsException ex ) { if ( entry == - 1 ) { entry = cache . fCacheLineCount ++ ; entries [ offset + SymbolCache . NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( SymbolCache . INITIAL_CACHE_RECORD_COUNT * SymbolCache . CACHE_RECORD_SIZE ) ] ; try { cacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex2 ) { cacheLines = new int [ entry * 2 ] [ ] ; System . arraycopy ( cache . fCacheLines , 0 , cacheLines , 0 , entry ) ; cache . fCacheLines = cacheLines ; cacheLines [ entry ] = entries ; } } else { entries = cacheLines [ entry ] ; throw new RuntimeException ( "RDR001 untested" ) ; } } offset = 1 + ( ( entries [ 0 ] - 1 ) * SymbolCache . CACHE_RECORD_SIZE ) ; depth ++ ; } if ( offset < 0 ) offset = 1 + ( entries [ 0 ] * SymbolCache . CACHE_RECORD_SIZE ) ; while ( true ) { entries [ 0 ] ++ ; try { entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; entries = new int [ newSize ] ; System . arraycopy ( cacheLines [ entry ] , 0 , entries , 0 , offset ) ; cacheLines [ entry ] = entries ; entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } if ( b0 >= 0x80 ) { ch = getMultiByteSymbolChar ( b0 ) ; b0 = fMostRecentByte ; } else if ( b0 == fastcheck || XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) { ch = - 1 ; } else { ch = b0 ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } if ( ch == - 1 ) { entries [ offset + SymbolCache . NEXT_OFFSET ] = - 1 ; break ; } entry = cache . fCacheLineCount ++ ; entries [ offset + SymbolCache . INDEX_OFFSET ] = - 1 ; entries [ offset + SymbolCache . NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( SymbolCache . INITIAL_CACHE_RECORD_COUNT * SymbolCache . CACHE_RECORD_SIZE ) ] ; try { cacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex ) { cacheLines = new int [ entry * 2 ] [ ] ; System . arraycopy ( cache . fCacheLines , 0 , cacheLines , 0 , entry ) ; cache . fCacheLines = cacheLines ; cacheLines [ entry ] = entries ; } offset = 1 ; try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; } int result = fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; return result ; } private int recognizeMarkup ( int b0 , QName element ) throws Exception { switch ( b0 ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 == '-' ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 == '-' ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( b0 == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } int expectedName = element . rawname ; fStringPool . getCharArrayRange ( expectedName , fCharArrayRange ) ; char [ ] expected = fCharArrayRange . chars ; int offset = fCharArrayRange . offset ; int len = fCharArrayRange . length ; if ( b0 == expected [ offset ++ ] ) { UTF8DataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; for ( int i = 1 ; i < len ; i ++ ) { if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 != expected [ offset ++ ] ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; } } fCharacterCounter += len ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == '>' ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG ; } while ( b0 == 0x20 || b0 == 0x09 || b0 == 0x0A || b0 == 0x0D ) { if ( b0 == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; } else if ( b0 == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; if ( b0 == 0x0A ) { fLinefeedCounter ++ ; b0 = loadNextByte ( ) ; } } else { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; } if ( b0 == '>' ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG ; } } fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; } return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; fCharDataLength = 0 ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentByte ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } break ; case 1 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ! fInCDSect ) { return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; break ; case 2 : fCharacterCounter ++ ; ch = loadNextByte ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; break ; case 3 : fCharacterCounter ++ ; ch = loadNextByte ( ) ; if ( ch != ']' ) { if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) { if ( fSendCharDataAsCharArray ) appendCharData ( 0x0A ) ; if ( ch == 0x20 || ch == 0x09 || ch == 0x0D ) continue ; break ; } fLinefeedCounter ++ ; } else { fCharacterCounter ++ ; } if ( fSendCharDataAsCharArray ) { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A || ch == 0x0D ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 1 : if ( ! fInCDSect ) { if ( fSendCharDataAsCharArray ) { fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = addString ( charDataOffset , fCurrentOffset - charDataOffset ) ; fCharDataHandler . processWhitespace ( stringIndex ) ; } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 2 : if ( ! fInCDSect ) { whitespace ( charDataOffset , fCurrentOffset ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextByte ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; whitespace ( charDataOffset , endOffset ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : whitespace ( charDataOffset , fCurrentOffset ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { whitespace ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { whitespace ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } break ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } } if ( fSendCharDataAsCharArray ) ch = copyAsciiCharData ( ) ; else ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 1 : if ( ! fInCDSect ) { if ( fSendCharDataAsCharArray ) { fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = addString ( charDataOffset , fCurrentOffset - charDataOffset ) ; fCharDataHandler . processCharacters ( stringIndex ) ; } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 2 : if ( ! fInCDSect ) { characters ( charDataOffset , fCurrentOffset ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextByte ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; characters ( charDataOffset , endOffset ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; break ; } if ( ch == 0x0D ) { if ( fSendCharDataAsCharArray ) appendCharData ( 0x0A ) ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; ch = loadNextByte ( ) ; } break ; } characters ( charDataOffset , fCurrentOffset ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { characters ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { characters ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentByte ; } } } private boolean copyMultiByteCharData ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; appendCharData ( ch ) ; loadNextByte ( ) ; return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; appendCharData ( ch ) ; loadNextByte ( ) ; return true ; } int b3 = loadNextByte ( ) ; if ( ( 0xf8 & b0 ) == 0xf0 ) { if ( b0 > 0xF4 || ( b0 == 0xF4 && b1 >= 0x90 ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } int ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; if ( ch < 0x10000 ) { appendCharData ( ch ) ; } else { appendCharData ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; appendCharData ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; } loadNextByte ( ) ; return true ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } private boolean skipMultiByteCharData ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { loadNextByte ( ) ; return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } loadNextByte ( ) ; return true ; } int b3 = loadNextByte ( ) ; if ( b0 > 0xF4 || ( b0 == 0xF4 && b1 >= 0x90 ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } loadNextByte ( ) ; return true ; } private int copyAsciiCharData ( ) throws Exception { int srcIndex = fCurrentIndex ; int offset = fCurrentOffset - srcIndex ; byte [ ] data = fMostRecentData ; int dstIndex = fCharDataLength ; boolean skiplf = false ; while ( true ) { int ch ; try { ch = data [ srcIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { offset += srcIndex ; slowLoadNextByte ( ) ; srcIndex = 0 ; data = fMostRecentData ; ch = data [ srcIndex ] & 0xFF ; } if ( ch >= 0x80 ) { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; skiplf = false ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; if ( skiplf ) { skiplf = false ; srcIndex ++ ; continue ; } fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; skiplf = true ; ch = 0x0A ; } else { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } srcIndex ++ ; try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } } private int skipAsciiCharData ( ) throws Exception { int srcIndex = fCurrentIndex ; int offset = fCurrentOffset - srcIndex ; byte [ ] data = fMostRecentData ; while ( true ) { int ch ; try { ch = data [ srcIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { offset += srcIndex ; slowLoadNextByte ( ) ; srcIndex = 0 ; data = fMostRecentData ; ch = data [ srcIndex ] & 0xFF ; } if ( ch >= 0x80 ) { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } srcIndex ++ ; } } private char [ ] fCharacters = new char [ UTF8DataChunk . CHUNK_SIZE ] ; private int fCharDataLength = 0 ; private void appendCharData ( int ch ) throws Exception { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } private void slowAppendCharData ( int ch ) throws Exception { characters ( 0 , fCharDataLength ) ; fCharDataLength = 0 ; fCharacters [ fCharDataLength ++ ] = ( char ) ch ; } private void characters ( int offset , int endOffset ) throws Exception { if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , endOffset - offset ) ; fCharDataHandler . processCharacters ( stringIndex ) ; return ; } fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } private void whitespace ( int offset , int endOffset ) throws Exception { if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , endOffset - offset ) ; fCharDataHandler . processWhitespace ( stringIndex ) ; return ; } fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool . CharArrayRange fCharArrayRange = null ; private InputStream fInputStream = null ; private StringPool fStringPool = null ; private UTF8DataChunk fCurrentChunk = null ; private int fCurrentIndex = 0 ; private byte [ ] fMostRecentData = null ; private int fMostRecentByte = 0 ; private int fLength = 0 ; private boolean fCalledCharPropInit = false ; private boolean fCallClearPreviousChunk = true ; private int fillCurrentChunk ( ) throws Exception { byte [ ] buf = fCurrentChunk . toByteArray ( ) ; if ( fInputStream == null ) { if ( buf == null ) buf = new byte [ 1 ] ; buf [ 0 ] = 0 ; fMostRecentData = buf ; fCurrentIndex = 0 ; fCurrentChunk . setByteArray ( fMostRecentData ) ; return ( fMostRecentByte = fMostRecentData [ 0 ] & 0xFF ) ; } if ( buf == null ) buf = new byte [ UTF8DataChunk . CHUNK_SIZE ] ; int offset = 0 ; int capacity = UTF8DataChunk . CHUNK_SIZE ; int result = 0 ; do { try { result = fInputStream . read ( buf , offset , capacity ) ; } catch ( java . io . IOException ex ) { result = - 1 ; } if ( result == - 1 ) { fInputStream . close ( ) ; fInputStream = null ; try { buf [ offset ] = 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { } break ; } if ( result > 0 ) { offset += result ; capacity -= result ; } } while ( capacity > 0 ) ; fMostRecentData = buf ; fLength += offset ; fCurrentIndex = 0 ; fCurrentChunk . setByteArray ( fMostRecentData ) ; return ( fMostRecentByte = fMostRecentData [ 0 ] & 0xFF ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLHeadingElement extends HTMLElement { public String getAlign ( ) ; public void setAlign ( String align ) ; } 	0
package org . apache . xerces . dom . events ; import org . w3c . dom . events . * ; import org . w3c . dom . Node ; public class EventImpl implements Event { public String type = null ; public EventTarget target ; public Node currentNode ; public short eventPhase ; public boolean initialized = false , bubbles = true , cancelable = false ; public boolean stopPropagation = false , preventDefault = false ; protected long timeStamp = System . currentTimeMillis ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) { type = eventTypeArg ; bubbles = canBubbleArg ; cancelable = cancelableArg ; initialized = true ; } public boolean getBubbles ( ) { return bubbles ; } public boolean getCancelable ( ) { return cancelable ; } public Node getCurrentNode ( ) { return currentNode ; } public short getEventPhase ( ) { return eventPhase ; } public EventTarget getTarget ( ) { return target ; } public String getType ( ) { return type ; } public long getTimeStamp ( ) { return timeStamp ; } public void stopPropagation ( ) { stopPropagation = true ; } public void preventDefault ( ) { preventDefault = true ; } } 	1
package org . apache . xerces . utils . regex ; public class ParseException extends RuntimeException { int location ; public ParseException ( String mes , int location ) { super ( mes ) ; this . location = location ; } public int getLocation ( ) { return this . location ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DOMImplementationImpl implements DOMImplementation { static DOMImplementationImpl singleton = new DOMImplementationImpl ( ) ; public boolean hasFeature ( String feature , String version ) { return ( feature . equalsIgnoreCase ( "XML" ) && ( version == null || version . equals ( "1.0" ) || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "Events" ) && ( version == null || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "MutationEvents" ) && ( version == null || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "Traversal" ) && ( version == null || version . equals ( "2.0" ) ) ) ; } public static DOMImplementation getDOMImplementation ( ) { return singleton ; } public DocumentType createDocumentType ( String qualifiedName , String publicID , String systemID ) { if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; if ( index == 0 || index == qualifiedName . length ( ) - 1 ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } return new DocumentTypeImpl ( null , qualifiedName , publicID , systemID ) ; } public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException { if ( doctype != null && doctype . getOwnerDocument ( ) != null ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } DocumentImpl doc = new DocumentImpl ( doctype ) ; Element e = doc . createElementNS ( namespaceURI , qualifiedName ) ; doc . appendChild ( e ) ; return doc ; } } 	1
package org . apache . xml . serialize ; import java . util . Hashtable ; class ElementState { String rawName ; String localName ; String namespaceURI ; boolean preserveSpace ; boolean empty ; boolean afterElement ; boolean doCData ; boolean unescaped ; boolean inCData ; Hashtable prefixes ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface DocumentTraversal { public NodeIterator createNodeIterator ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) ; public TreeWalker createTreeWalker ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) throws DOMException ; } 	1
package org . apache . xerces . validators . datatype ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . ResourceBundle ; import org . apache . xerces . utils . XMLMessageProvider ; public class DatatypeMessageProvider implements XMLMessageProvider { public static final String DATATYPE_DOMAIN = "http://www.w3.org/TR/xml-schema-2" ; public void setLocale ( Locale locale ) { fLocale = locale ; } public Locale getLocale ( ) { return fLocale ; } public String createMessage ( Locale locale , int majorCode , int minorCode , Object args [ ] ) { boolean throwex = false ; if ( fResourceBundle == null || locale != fLocale ) { if ( locale != null ) fResourceBundle = ListResourceBundle . getBundle ( "org.apache.xerces.msg.DatatypeMessages" , locale ) ; if ( fResourceBundle == null ) fResourceBundle = ListResourceBundle . getBundle ( "org.apache.xerces.msg.DatatypeMessages" ) ; } if ( majorCode < 0 || majorCode >= fgMessageKeys . length ) { majorCode = MSG_BAD_MAJORCODE ; throwex = true ; } String msgKey = fgMessageKeys [ majorCode ] ; String msg = fResourceBundle . getString ( msgKey ) ; if ( args != null ) { try { msg = java . text . MessageFormat . format ( msg , args ) ; } catch ( Exception e ) { msg = fResourceBundle . getString ( fgMessageKeys [ MSG_FORMAT_FAILURE ] ) ; msg += " " + fResourceBundle . getString ( msgKey ) ; } } if ( throwex ) { throw new RuntimeException ( msg ) ; } return msg ; } private Locale fLocale = null ; private ResourceBundle fResourceBundle = null ; public static final int MSG_BAD_MAJORCODE = 0 , MSG_FORMAT_FAILURE = 1 , NotBoolean = 2 , NotDecimal = 3 , FacetsInconsistent = 4 , IllegalFacetValue = 5 , IllegalDecimalFacet = 6 , UnknownFacet = 7 , InvalidEnumValue = 8 , OutOfBounds = 9 , NotAnEnumValue = 10 , NotInteger = 11 , IllegalIntegerFacet = 12 , NotReal = 13 , IllegalRealFacet = 14 , ScaleLargerThanPrecision = 15 , PrecisionExceeded = 16 , ScaleExceeded = 17 , NotFloat = 18 , MSG_MAX_CODE = 19 ; public static final int MSG_NONE = 0 ; public static final String [ ] fgMessageKeys = { "BadMajorCode" , "FormatFailed" , "NotBoolean" , "NotDecimal" , "FacetsInconsistent" , "IllegalFacetValue" , "IllegalDecimalFacet" , "UnknownFacet" , "InvalidEnumValue" , "OutOfBounds" , "NotAnEnumValue" , "NotInteger" , "IllegalIntegerFacet" , "NotReal" , "IllegalRealFacet" , "ScaleLargerThanPrecision" , "PrecisionExceeded" , "ScaleExceeded" , "NotFloat" } ; } 	0
package org . apache . xerces . readers ; import java . io . FileNotFoundException ; import java . io . UnsupportedEncodingException ; import java . net . MalformedURLException ; import java . util . Stack ; import java . util . Vector ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . URI ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; public class DefaultEntityHandler implements XMLEntityHandler , XMLEntityHandler . DTDHandler { public interface EventHandler { public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void sendEndOfInputNotifications ( int entityName , boolean moreToFollow ) throws Exception ; public void sendReaderChangeNotifications ( XMLEntityHandler . EntityReader reader , int readerId ) throws Exception ; public boolean externalEntityStandaloneCheck ( ) ; public boolean getValidating ( ) ; } private class ReaderState { XMLEntityHandler . EntityReader reader ; InputSource source ; int entityName ; int entityType ; int entityContext ; String publicId ; String systemId ; int readerId ; int depth ; ReaderState nextReaderState ; } private ReaderState fReaderStateFreeList = null ; private StringPool fStringPool = null ; private EventHandler fEventHandler = null ; private XMLEntityHandler . CharDataHandler fCharDataHandler = null ; private XMLErrorReporter fErrorReporter = null ; private EntityResolver fResolver = null ; private EntityPool fEntityPool = null ; private EntityPool fParameterEntityPool = null ; private byte [ ] fEntityTypeStack = null ; private int [ ] fEntityNameStack = null ; private int fEntityStackDepth = 0 ; private Stack fReaderStack = new Stack ( ) ; private XMLEntityHandler . EntityReader fReader = null ; private InputSource fSource = null ; private int fEntityName = - 1 ; private int fEntityType = - 1 ; private int fEntityContext = - 1 ; private String fPublicId = null ; private String fSystemId = null ; private int fReaderId = - 1 ; private int fReaderDepth = - 1 ; private int fNextReaderId = 0 ; private NullReader fNullReader = null ; protected XMLEntityReaderFactory fReaderFactory = null ; private boolean fSendCharDataAsCharArray = false ; public DefaultEntityHandler ( StringPool stringPool , XMLErrorReporter errorReporter ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fReaderFactory = new DefaultReaderFactory ( ) ; fEntityPool = new EntityPool ( fStringPool , fErrorReporter , true ) ; } public void setEventHandler ( EventHandler eventHandler ) { fEventHandler = eventHandler ; } public void setCharDataHandler ( XMLEntityHandler . CharDataHandler charDataHandler ) { fCharDataHandler = charDataHandler ; } public XMLEntityHandler . CharDataHandler getCharDataHandler ( ) { return fCharDataHandler ; } public void setSendCharDataAsCharArray ( boolean flag ) { fSendCharDataAsCharArray = flag ; fReaderFactory . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; } public void setReaderFactory ( XMLEntityReaderFactory readerFactory ) { fReaderFactory = readerFactory ; fReaderFactory . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fEntityPool . reset ( fStringPool ) ; fParameterEntityPool = null ; fReaderStack . removeAllElements ( ) ; fEntityStackDepth = 0 ; fReader = null ; fSource = null ; fEntityName = - 1 ; fEntityType = - 1 ; fEntityContext = - 1 ; fPublicId = null ; fSystemId = null ; fReaderId = - 1 ; fReaderDepth = - 1 ; fNextReaderId = 0 ; } public void setAllowJavaEncodings ( boolean flag ) { fReaderFactory . setAllowJavaEncodingName ( flag ) ; } public boolean getAllowJavaEncodings ( ) { return fReaderFactory . getAllowJavaEncodingName ( ) ; } public int addInternalPEDecl ( int name , int value , boolean isExternal ) throws Exception { if ( fParameterEntityPool == null ) fParameterEntityPool = new EntityPool ( fStringPool , fErrorReporter , false ) ; int entityHandle = fParameterEntityPool . addEntityDecl ( name , value , - 1 , - 1 , - 1 , - 1 , isExternal ) ; return entityHandle ; } public int addExternalPEDecl ( int name , int publicId , int systemId , boolean isExternal ) throws Exception { if ( fParameterEntityPool == null ) fParameterEntityPool = new EntityPool ( fStringPool , fErrorReporter , false ) ; int entityHandle = fParameterEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , - 1 , isExternal ) ; return entityHandle ; } public int addInternalEntityDecl ( int name , int value , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , value , - 1 , - 1 , - 1 , - 1 , isExternal ) ; return entityHandle ; } public int addExternalEntityDecl ( int name , int publicId , int systemId , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , - 1 , isExternal ) ; return entityHandle ; } public int addUnparsedEntityDecl ( int name , int publicId , int systemId , int notationName , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , notationName , isExternal ) ; if ( ! fEntityPool . isNotationDeclared ( notationName ) ) { Object [ ] args = { fStringPool . toString ( name ) , fStringPool . toString ( notationName ) } ; fEntityPool . addRequiredNotation ( notationName , fErrorReporter . getLocator ( ) , XMLMessages . MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL , XMLMessages . VC_NOTATION_DECLARED , args ) ; } return entityHandle ; } public int addNotationDecl ( int notationName , int publicId , int systemId , boolean isExternal ) throws Exception { int notationHandle = fEntityPool . addNotationDecl ( notationName , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , isExternal ) ; return notationHandle ; } public boolean isUnparsedEntity ( int entityName ) { int entityHandle = fEntityPool . lookupEntity ( entityName ) ; return ( entityHandle != - 1 && fEntityPool . isUnparsedEntity ( entityHandle ) ) ; } public boolean isNotationDeclared ( int notationName ) { return fEntityPool . isNotationDeclared ( notationName ) ; } public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { fEntityPool . addRequiredNotation ( notationName , locator , majorCode , minorCode , args ) ; } public void checkRequiredNotations ( ) throws Exception { fEntityPool . checkRequiredNotations ( ) ; } protected int lookupEntity ( int entityNameIndex ) { int entityIndex = fEntityPool . lookupEntity ( entityNameIndex ) ; return entityIndex ; } private void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } public boolean externalReferenceInContent ( int entityHandle ) throws Exception { boolean external = fEntityPool . isExternalEntity ( entityHandle ) ; if ( fEventHandler . externalEntityStandaloneCheck ( ) ) { if ( external ) { reportRecoverableXMLError ( XMLMessages . MSG_EXTERNAL_ENTITY_NOT_PERMITTED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } else if ( fEntityPool . getEntityDeclIsExternal ( entityHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } } return external ; } protected int valueOfReferenceInAttValue ( int entityHandle ) throws Exception { if ( fEventHandler . externalEntityStandaloneCheck ( ) && fEntityPool . getEntityDeclIsExternal ( entityHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } int entityValue = fEntityPool . getEntityValue ( entityHandle ) ; return entityValue ; } protected boolean isExternalEntity ( int entityHandle ) { boolean external = fEntityPool . isExternalEntity ( entityHandle ) ; return external ; } protected int getEntityValue ( int entityHandle ) { int value = fEntityPool . getEntityValue ( entityHandle ) ; return value ; } protected String getPublicIdOfEntity ( int entityHandle ) { int publicId = fEntityPool . getPublicId ( entityHandle ) ; return fStringPool . toString ( publicId ) ; } protected String getSystemIdOfEntity ( int entityHandle ) { int systemId = fEntityPool . getSystemId ( entityHandle ) ; return fStringPool . toString ( systemId ) ; } protected int lookupParameterEntity ( int peName ) throws Exception { int entityHandle = - 1 ; if ( fParameterEntityPool != null ) entityHandle = fParameterEntityPool . lookupEntity ( peName ) ; return entityHandle ; } protected boolean isExternalParameterEntity ( int peIndex ) { boolean external = fParameterEntityPool . isExternalEntity ( peIndex ) ; return external ; } protected int getParameterEntityValue ( int peIndex ) { int value = fParameterEntityPool . getEntityValue ( peIndex ) ; return value ; } protected String getPublicIdOfParameterEntity ( int peIndex ) { int publicId = fParameterEntityPool . getPublicId ( peIndex ) ; return fStringPool . toString ( publicId ) ; } protected String getSystemIdOfParameterEntity ( int peIndex ) { int systemId = fParameterEntityPool . getSystemId ( peIndex ) ; return fStringPool . toString ( systemId ) ; } public XMLEntityHandler . EntityReader getEntityReader ( ) { return fReader ; } public void addRecognizer ( XMLDeclRecognizer recognizer ) { fReaderFactory . addRecognizer ( recognizer ) ; } public void setEntityResolver ( EntityResolver resolver ) { fResolver = resolver ; } public EntityResolver getEntityResolver ( ) { return fResolver ; } public String expandSystemId ( String systemId ) { return expandSystemId ( systemId , fSystemId ) ; } private String expandSystemId ( String systemId , String currentSystemId ) { String id = systemId ; if ( id == null || id . length ( ) == 0 ) { return systemId ; } try { URI uri = new URI ( id ) ; if ( uri != null ) { return systemId ; } } catch ( URI . MalformedURIException e ) { } id = fixURI ( id ) ; URI base = null ; URI uri = null ; try { if ( currentSystemId == null ) { String dir ; try { dir = fixURI ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { dir = "" ; } if ( ! dir . endsWith ( "/" ) ) { dir = dir + "/" ; } base = new URI ( "file" , "" , dir , null , null ) ; } else { base = new URI ( currentSystemId ) ; } uri = new URI ( base , id ) ; } catch ( Exception e ) { } if ( uri == null ) { return systemId ; } return uri . toString ( ) ; } private static String fixURI ( String str ) { str = str . replace ( java . io . File . separatorChar , '/' ) ; if ( str . length ( ) >= 2 ) { char ch1 = str . charAt ( 1 ) ; if ( ch1 == ':' ) { char ch0 = Character . toUpperCase ( str . charAt ( 0 ) ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { str = "/" + str ; } } } return str ; } public boolean startReadingFromDocument ( InputSource source ) throws Exception { pushEntity ( false , - 2 ) ; fSystemId = null ; pushNullReader ( ) ; fEntityName = - 2 ; fEntityType = ENTITYTYPE_DOCUMENT ; fEntityContext = ENTITYREF_DOCUMENT ; fReaderDepth = 0 ; fReaderId = fNextReaderId ++ ; fPublicId = source . getPublicId ( ) ; fSystemId = source . getSystemId ( ) ; fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; fSystemId = expandSystemId ( fSystemId , null ) ; fSource = source ; boolean xmlDecl = true ; try { fReader = fReaderFactory . createReader ( this , fErrorReporter , source , fSystemId , xmlDecl , fStringPool ) ; } catch ( MalformedURLException mu ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( FileNotFoundException fnf ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( UnsupportedEncodingException uee ) { fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; String encoding = uee . getMessage ( ) ; if ( encoding == null ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_REQUIRED , XMLMessages . P81_REQUIRED , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else if ( ! XMLCharacterProperties . validEncName ( encoding ) ) { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_NOT_SUPPORTED , XMLMessages . P81_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; return fReader != null ; } public void startReadingFromExternalSubset ( String publicId , String systemId , int readerDepth ) throws Exception { pushEntity ( true , - 1 ) ; pushReader ( ) ; pushNullReader ( ) ; fEntityName = - 1 ; fEntityType = ENTITYTYPE_EXTERNAL_SUBSET ; fEntityContext = ENTITYREF_EXTERNAL_SUBSET ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; fPublicId = publicId ; fSystemId = systemId ; startReadingFromExternalEntity ( false , - 1 ) ; } public void stopReadingFromExternalSubset ( ) throws Exception { if ( ! ( fReader instanceof NullReader ) ) throw new RuntimeException ( "FWK004 cannot happen 18" + "\n18" ) ; popReader ( ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; } public boolean startReadingFromEntity ( int entityName , int readerDepth , int context ) throws Exception { if ( context > XMLEntityHandler . ENTITYREF_IN_CONTENT ) return startReadingFromParameterEntity ( entityName , readerDepth , context ) ; int entityHandle = lookupEntity ( entityName ) ; if ( entityHandle < 0 ) { int minorCode = XMLMessages . VC_ENTITY_DECLARED ; int errorType = XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ; if ( fEntityContext == ENTITYREF_DOCUMENT || fEntityContext == ENTITYREF_IN_ATTVALUE ) { minorCode = XMLMessages . WFC_ENTITY_DECLARED ; errorType = XMLErrorReporter . ERRORTYPE_FATAL_ERROR ; } else if ( ! fEventHandler . getValidating ( ) ) { return false ; } Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENTITY_NOT_DECLARED , minorCode , args , errorType ) ; return false ; } if ( context == ENTITYREF_IN_CONTENT ) { if ( fEntityPool . isUnparsedEntity ( entityHandle ) ) { Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REFERENCE_TO_UNPARSED_ENTITY , XMLMessages . WFC_PARSED_ENTITY , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } } else { if ( isExternalEntity ( entityHandle ) ) { Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REFERENCE_TO_EXTERNAL_ENTITY , XMLMessages . WFC_NO_EXTERNAL_ENTITY_REFERENCES , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } } if ( ! pushEntity ( false , entityName ) ) { Object [ ] args = { fStringPool . toString ( entityName ) , entityReferencePath ( false , entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_RECURSIVE_REFERENCE , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } pushReader ( ) ; fEntityName = entityName ; fEntityContext = context ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; if ( context != ENTITYREF_IN_CONTENT || ! externalReferenceInContent ( entityHandle ) ) { fEntityType = ENTITYTYPE_INTERNAL ; fPublicId = null ; fSystemId = fSystemId ; int value = - 1 ; if ( context == ENTITYREF_IN_CONTENT || context == ENTITYREF_IN_DEFAULTATTVALUE ) value = getEntityValue ( entityHandle ) ; else value = valueOfReferenceInAttValue ( entityHandle ) ; startReadingFromInternalEntity ( value , false ) ; return false ; } fEntityType = ENTITYTYPE_EXTERNAL ; fPublicId = getPublicIdOfEntity ( entityHandle ) ; fSystemId = getSystemIdOfEntity ( entityHandle ) ; return startReadingFromExternalEntity ( true , entityHandle ) ; } private boolean startReadingFromParameterEntity ( int peName , int readerDepth , int context ) throws Exception { int entityHandle = lookupParameterEntity ( peName ) ; if ( entityHandle == - 1 ) { if ( fEventHandler . getValidating ( ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ENTITY_NOT_DECLARED , XMLMessages . VC_ENTITY_DECLARED , peName ) ; } return false ; } if ( ! pushEntity ( true , peName ) ) { Object [ ] args = { fStringPool . toString ( peName ) , entityReferencePath ( true , peName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_RECURSIVE_PEREFERENCE , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } pushReader ( ) ; fEntityName = peName ; fEntityContext = context ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; if ( ! isExternalParameterEntity ( entityHandle ) ) { fEntityType = ENTITYTYPE_INTERNAL_PE ; fPublicId = null ; fSystemId = fSystemId ; int value = getParameterEntityValue ( entityHandle ) ; startReadingFromInternalEntity ( value , fEntityContext == ENTITYREF_IN_ENTITYVALUE ? false : true ) ; return false ; } fEntityType = ENTITYTYPE_EXTERNAL_PE ; fPublicId = getPublicIdOfParameterEntity ( entityHandle ) ; fSystemId = getSystemIdOfParameterEntity ( entityHandle ) ; return startReadingFromExternalEntity ( true , entityHandle ) ; } private void startReadingFromInternalEntity ( int value , boolean addSpaces ) throws Exception { if ( fEntityContext == ENTITYREF_IN_ENTITYVALUE ) { } fSource = null ; fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; fReader = fReaderFactory . createStringReader ( this , fErrorReporter , fSendCharDataAsCharArray , getLineNumber ( ) , getColumnNumber ( ) , value , fStringPool , addSpaces ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; } private boolean startReadingFromExternalEntity ( boolean checkForTextDecl , int entityHandle ) throws Exception { if ( fEntityContext == ENTITYREF_IN_ENTITYVALUE ) { } if ( fEntityContext == ENTITYREF_IN_DTD_WITHIN_MARKUP ) { } fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; String baseSystemId = null ; if ( entityHandle != - 1 ) { if ( fEntityType == ENTITYTYPE_EXTERNAL_PE ) baseSystemId = fParameterEntityPool . getBaseSystemId ( entityHandle ) ; else baseSystemId = fEntityPool . getBaseSystemId ( entityHandle ) ; } if ( baseSystemId == null ) { ReaderState rs = ( ReaderState ) fReaderStack . peek ( ) ; baseSystemId = rs . systemId ; } fSystemId = expandSystemId ( fSystemId , baseSystemId ) ; fSource = fResolver == null ? null : fResolver . resolveEntity ( fPublicId , fSystemId ) ; if ( fSource == null ) { fSource = new InputSource ( fSystemId ) ; if ( fPublicId != null ) fSource . setPublicId ( fPublicId ) ; } else { if ( fSource . getSystemId ( ) != null ) { fSystemId = expandSystemId ( fSource . getSystemId ( ) , baseSystemId ) ; } if ( fSource . getPublicId ( ) != null ) { fPublicId = fSource . getPublicId ( ) ; } } boolean textDecl = false ; try { fReader = fReaderFactory . createReader ( this , fErrorReporter , fSource , fSystemId , textDecl , fStringPool ) ; } catch ( MalformedURLException mu ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( FileNotFoundException fnf ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( UnsupportedEncodingException uee ) { fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; String encoding = uee . getMessage ( ) ; if ( encoding == null ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_REQUIRED , XMLMessages . P81_REQUIRED , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else if ( ! XMLCharacterProperties . validEncName ( encoding ) ) { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_NOT_SUPPORTED , XMLMessages . P81_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } if ( fReader == null || ! checkForTextDecl ) { fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; return false ; } int readerId = fReaderId ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; boolean parseTextDecl = fReader . lookingAtChar ( '<' , false ) ; if ( readerId != fReaderId ) parseTextDecl = false ; return parseTextDecl ; } private void pushNullReader ( ) { ReaderState rs = fReaderStateFreeList ; if ( rs == null ) rs = new ReaderState ( ) ; else fReaderStateFreeList = rs . nextReaderState ; if ( fNullReader == null ) fNullReader = new NullReader ( ) ; rs . reader = fNullReader ; rs . source = null ; rs . entityName = - 1 ; rs . entityType = - 1 ; rs . entityContext = - 1 ; rs . publicId = "Null Entity" ; rs . systemId = fSystemId ; rs . readerId = fNextReaderId ++ ; rs . depth = - 1 ; rs . nextReaderState = null ; fReaderStack . push ( rs ) ; } private void pushReader ( ) { ReaderState rs = fReaderStateFreeList ; if ( rs == null ) rs = new ReaderState ( ) ; else fReaderStateFreeList = rs . nextReaderState ; rs . reader = fReader ; rs . source = fSource ; rs . entityName = fEntityName ; rs . entityType = fEntityType ; rs . entityContext = fEntityContext ; rs . publicId = fPublicId ; rs . systemId = fSystemId ; rs . readerId = fReaderId ; rs . depth = fReaderDepth ; rs . nextReaderState = null ; fReaderStack . push ( rs ) ; } private void popReader ( ) { if ( fReaderStack . empty ( ) ) throw new RuntimeException ( "FWK004 cannot happen 19" + "\n19" ) ; ReaderState rs = ( ReaderState ) fReaderStack . pop ( ) ; fReader = rs . reader ; fSource = rs . source ; fEntityName = rs . entityName ; fEntityType = rs . entityType ; fEntityContext = rs . entityContext ; fPublicId = rs . publicId ; fSystemId = rs . systemId ; fReaderId = rs . readerId ; fReaderDepth = rs . depth ; rs . nextReaderState = fReaderStateFreeList ; fReaderStateFreeList = rs ; } public boolean startEntityDecl ( boolean isPE , int entityName ) throws Exception { if ( ! pushEntity ( isPE , entityName ) ) { int majorCode = isPE ? XMLMessages . MSG_RECURSIVE_PEREFERENCE : XMLMessages . MSG_RECURSIVE_REFERENCE ; Object [ ] args = { fStringPool . toString ( entityName ) , entityReferencePath ( isPE , entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } return true ; } public void endEntityDecl ( ) throws Exception { popEntity ( ) ; } private boolean pushEntity ( boolean isPE , int entityName ) throws Exception { if ( entityName >= 0 ) { for ( int i = 0 ; i < fEntityStackDepth ; i ++ ) { if ( fEntityNameStack [ i ] == entityName && fEntityTypeStack [ i ] == ( isPE ? 1 : 0 ) ) { return false ; } } } if ( fEntityTypeStack == null ) { fEntityTypeStack = new byte [ 8 ] ; fEntityNameStack = new int [ 8 ] ; } else if ( fEntityStackDepth == fEntityTypeStack . length ) { byte [ ] newTypeStack = new byte [ fEntityStackDepth * 2 ] ; System . arraycopy ( fEntityTypeStack , 0 , newTypeStack , 0 , fEntityStackDepth ) ; fEntityTypeStack = newTypeStack ; int [ ] newNameStack = new int [ fEntityStackDepth * 2 ] ; System . arraycopy ( fEntityNameStack , 0 , newNameStack , 0 , fEntityStackDepth ) ; fEntityNameStack = newNameStack ; } fEntityTypeStack [ fEntityStackDepth ] = ( byte ) ( isPE ? 1 : 0 ) ; fEntityNameStack [ fEntityStackDepth ] = entityName ; fEntityStackDepth ++ ; return true ; } private String entityReferencePath ( boolean isPE , int entityName ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "(top-level)" ) ; for ( int i = 0 ; i < fEntityStackDepth ; i ++ ) { if ( fEntityNameStack [ i ] >= 0 ) { sb . append ( '-' ) ; sb . append ( fEntityTypeStack [ i ] == 1 ? '%' : '&' ) ; sb . append ( fStringPool . toString ( fEntityNameStack [ i ] ) ) ; sb . append ( ';' ) ; } } sb . append ( '-' ) ; sb . append ( isPE ? '%' : '&' ) ; sb . append ( fStringPool . toString ( entityName ) ) ; sb . append ( ';' ) ; return sb . toString ( ) ; } private void popEntity ( ) throws Exception { fEntityStackDepth -- ; } public int getReaderId ( ) { return fReaderId ; } public void setReaderDepth ( int depth ) { fReaderDepth = depth ; } public int getReaderDepth ( ) { return fReaderDepth ; } public String getPublicId ( ) { return fPublicId ; } public String getSystemId ( ) { return fSystemId ; } public int getLineNumber ( ) { return fReader == null ? 0 : fReader . getLineNumber ( ) ; } public int getColumnNumber ( ) { return fReader == null ? 0 : fReader . getColumnNumber ( ) ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { fEventHandler . sendEndOfInputNotifications ( fEntityName , fReaderStack . size ( ) > 1 ) ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; popEntity ( ) ; return fReader ; } private final class NullReader implements XMLEntityHandler . EntityReader { public NullReader ( ) { } public int currentOffset ( ) { return - 1 ; } public int getLineNumber ( ) { return - 1 ; } public int getColumnNumber ( ) { return - 1 ; } public void setInCDSect ( boolean inCDSect ) { } public boolean getInCDSect ( ) { return false ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { } public int addString ( int offset , int length ) { return - 1 ; } public int addSymbol ( int offset , int length ) { return - 1 ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) { return false ; } public boolean lookingAtValidChar ( boolean skipPastChar ) { return false ; } public boolean lookingAtSpace ( boolean skipPastChar ) { return false ; } public void skipToChar ( char ch ) { } public void skipPastSpaces ( ) { } public void skipPastName ( char fastcheck ) { } public void skipPastNmtoken ( char fastcheck ) { } public boolean skippedString ( char [ ] s ) { return false ; } public int scanInvalidChar ( ) { return - 1 ; } public int scanCharRef ( boolean hex ) { return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } public int scanStringLiteral ( ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } public int scanAttValue ( char qchar , boolean asSymbol ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } public int scanEntityValue ( int qchar , boolean createString ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) { return false ; } public void scanQName ( char fastcheck , QName qname ) { qname . clear ( ) ; } public int scanName ( char fastcheck ) { return - 1 ; } public int scanContent ( QName element ) throws Exception { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } static final int CHUNK_SHIFT = 5 ; static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; static final int CHUNK_MASK = CHUNK_SIZE - 1 ; static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; public final class EntityPool { private StringPool fStringPool = null ; private XMLErrorReporter fErrorReporter = null ; private int fEntityCount = 0 ; private int [ ] [ ] fName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fValue = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fPublicId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fSystemId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fBaseSystemId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fNotationName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private byte [ ] [ ] fDeclIsExternal = new byte [ INITIAL_CHUNK_COUNT ] [ ] ; private int fNotationListHead = - 1 ; private boolean fCreateStandardEntities = false ; private Vector fRequiredNotations = null ; public EntityPool ( StringPool stringPool , XMLErrorReporter errorReporter , boolean createStandardEntities ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fCreateStandardEntities = createStandardEntities ; if ( fCreateStandardEntities ) { createInternalEntity ( "lt" , "&#60;" ) ; createInternalEntity ( "gt" , ">" ) ; createInternalEntity ( "amp" , "&#38;" ) ; createInternalEntity ( "apos" , "\'" ) ; createInternalEntity ( "quot" , "\"" ) ; } } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fEntityCount = 0 ; fNotationListHead = - 1 ; if ( fRequiredNotations != null ) fRequiredNotations . removeAllElements ( ) ; if ( fCreateStandardEntities ) { createInternalEntity ( "lt" , "&#60;" ) ; createInternalEntity ( "gt" , ">" ) ; createInternalEntity ( "amp" , "&#38;" ) ; createInternalEntity ( "apos" , "\'" ) ; createInternalEntity ( "quot" , "\"" ) ; } } private void createInternalEntity ( String name , String value ) { int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = fStringPool . addSymbol ( name ) ; fValue [ chunk ] [ index ] = fStringPool . addString ( value ) ; fPublicId [ chunk ] [ index ] = - 1 ; fSystemId [ chunk ] [ index ] = - 1 ; fBaseSystemId [ chunk ] [ index ] = - 1 ; fNotationName [ chunk ] [ index ] = - 1 ; fEntityCount ++ ; } private boolean ensureCapacity ( int chunk ) { try { return fName [ chunk ] [ 0 ] == 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { int [ ] [ ] newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fName , 0 , newIntArray , 0 , chunk ) ; fName = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fValue , 0 , newIntArray , 0 , chunk ) ; fValue = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fPublicId , 0 , newIntArray , 0 , chunk ) ; fPublicId = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fSystemId , 0 , newIntArray , 0 , chunk ) ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fBaseSystemId , 0 , newIntArray , 0 , chunk ) ; fBaseSystemId = newIntArray ; fSystemId = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fNotationName , 0 , newIntArray , 0 , chunk ) ; fNotationName = newIntArray ; byte [ ] [ ] newByteArray = new byte [ chunk * 2 ] [ ] ; System . arraycopy ( fDeclIsExternal , 0 , newByteArray , 0 , chunk ) ; fDeclIsExternal = newByteArray ; } catch ( NullPointerException ex ) { } fName [ chunk ] = new int [ CHUNK_SIZE ] ; fValue [ chunk ] = new int [ CHUNK_SIZE ] ; fPublicId [ chunk ] = new int [ CHUNK_SIZE ] ; fSystemId [ chunk ] = new int [ CHUNK_SIZE ] ; fBaseSystemId [ chunk ] = new int [ CHUNK_SIZE ] ; fNotationName [ chunk ] = new int [ CHUNK_SIZE ] ; fDeclIsExternal [ chunk ] = new byte [ CHUNK_SIZE ] ; return true ; } public int addEntityDecl ( int name , int value , int publicId , int systemId , int baseSystemId , int notationName , boolean isExternal ) { int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = name ; fValue [ chunk ] [ index ] = value ; fPublicId [ chunk ] [ index ] = publicId ; fSystemId [ chunk ] [ index ] = systemId ; fBaseSystemId [ chunk ] [ index ] = baseSystemId ; fNotationName [ chunk ] [ index ] = notationName ; fDeclIsExternal [ chunk ] [ index ] = isExternal ? ( byte ) 0x80 : ( byte ) 0 ; int entityIndex = fEntityCount ++ ; return entityIndex ; } public int addNotationDecl ( int notationName , int publicId , int systemId , int baseSystemId , boolean isExternal ) { int nIndex = fNotationListHead ; while ( nIndex != - 1 ) { int chunk = nIndex > > CHUNK_SHIFT ; int index = nIndex & CHUNK_MASK ; if ( fNotationName [ chunk ] [ index ] == notationName ) return - 1 ; nIndex = fValue [ chunk ] [ index ] ; } int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = - 1 ; fValue [ chunk ] [ index ] = fNotationListHead ; fPublicId [ chunk ] [ index ] = publicId ; fSystemId [ chunk ] [ index ] = systemId ; fBaseSystemId [ chunk ] [ index ] = baseSystemId ; fNotationName [ chunk ] [ index ] = notationName ; fDeclIsExternal [ chunk ] [ index ] = isExternal ? ( byte ) 0x80 : ( byte ) 0 ; fNotationListHead = fEntityCount ++ ; return fNotationListHead ; } public int lookupEntity ( int nameIndex ) { if ( nameIndex == - 1 ) return - 1 ; int chunk = 0 ; int index = 0 ; for ( int entityIndex = 0 ; entityIndex < fEntityCount ; entityIndex ++ ) { if ( fName [ chunk ] [ index ] == nameIndex ) return entityIndex ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } return - 1 ; } public boolean isExternalEntity ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fValue [ chunk ] [ index ] == - 1 ) ; } public boolean isUnparsedEntity ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fNotationName [ chunk ] [ index ] != - 1 ) ; } public boolean getEntityDeclIsExternal ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fDeclIsExternal [ chunk ] [ index ] < 0 ) ; } public int getEntityName ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fName [ chunk ] [ index ] ; } public int getEntityValue ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fValue [ chunk ] [ index ] ; } public int getPublicId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fPublicId [ chunk ] [ index ] ; } public int getSystemId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fSystemId [ chunk ] [ index ] ; } public String getBaseSystemId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; int baseIndex = fBaseSystemId [ chunk ] [ index ] ; if ( baseIndex == - 1 ) { return null ; } else { return fStringPool . toString ( baseIndex ) ; } } public boolean isNotationDeclared ( int nameIndex ) { int nIndex = fNotationListHead ; while ( nIndex != - 1 ) { int chunk = nIndex > > CHUNK_SHIFT ; int index = nIndex & CHUNK_MASK ; if ( fNotationName [ chunk ] [ index ] == nameIndex ) return true ; nIndex = fValue [ chunk ] [ index ] ; } return false ; } public boolean getNotationDeclIsExternal ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fDeclIsExternal [ chunk ] [ index ] < 0 ) ; } public int getNotationName ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fNotationName [ chunk ] [ index ] ; } class RequiredNotation { RequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { fNotationName = notationName ; fLocator = new LocatorImpl ( locator ) ; fMajorCode = majorCode ; fMinorCode = minorCode ; fArgs = args ; } int fNotationName ; LocatorImpl fLocator ; int fMajorCode ; int fMinorCode ; Object [ ] fArgs ; } ; public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { if ( fRequiredNotations == null ) fRequiredNotations = new Vector ( ) ; for ( int index = 0 ; index < fRequiredNotations . size ( ) ; index ++ ) { RequiredNotation rn = ( RequiredNotation ) fRequiredNotations . elementAt ( index ) ; if ( rn . fNotationName == notationName ) return ; } fRequiredNotations . addElement ( new RequiredNotation ( notationName , locator , majorCode , minorCode , args ) ) ; } public void checkRequiredNotations ( ) throws Exception { if ( fRequiredNotations == null ) return ; for ( int index = 0 ; index < fRequiredNotations . size ( ) ; index ++ ) { RequiredNotation rn = ( RequiredNotation ) fRequiredNotations . elementAt ( index ) ; if ( ! isNotationDeclared ( rn . fNotationName ) ) { fErrorReporter . reportError ( rn . fLocator , XMLMessages . XML_DOMAIN , rn . fMajorCode , rn . fMinorCode , rn . fArgs , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } 	1
package org . w3c . dom . html ; public interface HTMLImageElement extends HTMLElement { public String getLowSrc ( ) ; public void setLowSrc ( String lowSrc ) ; public String getName ( ) ; public void setName ( String name ) ; public String getAlign ( ) ; public void setAlign ( String align ) ; public String getAlt ( ) ; public void setAlt ( String alt ) ; public String getBorder ( ) ; public void setBorder ( String border ) ; public String getHeight ( ) ; public void setHeight ( String height ) ; public String getHspace ( ) ; public void setHspace ( String hspace ) ; public boolean getIsMap ( ) ; public void setIsMap ( boolean isMap ) ; public String getLongDesc ( ) ; public void setLongDesc ( String longDesc ) ; public String getSrc ( ) ; public void setSrc ( String src ) ; public String getUseMap ( ) ; public void setUseMap ( String useMap ) ; public String getVspace ( ) ; public void setVspace ( String vspace ) ; public String getWidth ( ) ; public void setWidth ( String width ) ; } 	0
package org . w3c . dom ; public interface DOMImplementation { public boolean hasFeature ( String feature , String version ) ; public DocumentType createDocumentType ( String qualifiedName , String publicId , String systemId ) throws DOMException ; public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLSetvarElementImpl extends WMLElementImpl implements WMLSetvarElement { public WMLSetvarElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setValue ( String newValue ) { setAttribute ( "value" , newValue ) ; } public String getValue ( ) { return getAttribute ( "value" ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setName ( String newValue ) { setAttribute ( "name" , newValue ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } } 	0
package org . apache . xerces . utils ; import java . lang . * ; public final class HexBin { static private final int BASELENGTH = 255 ; static private final int LOOKUPLENGTH = 16 ; static private byte [ ] hexNumberTable = new byte [ BASELENGTH ] ; static private byte [ ] lookUpHexAlphabet = new byte [ LOOKUPLENGTH ] ; static { for ( int i = 0 ; i < BASELENGTH ; i ++ ) { hexNumberTable [ i ] = - 1 ; } for ( int i = '9' ; i >= '0' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - '0' ) ; } for ( int i = 'F' ; i >= 'A' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - 'A' + 10 ) ; } for ( int i = 'f' ; i >= 'a' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - 'a' + 10 ) ; } for ( int i = 0 ; i <= 25 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( 'A' + i ) ; for ( int i = 0 ; i < 10 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( '0' + i ) ; for ( int i = 10 ; i <= 15 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( 'A' + i - 10 ) ; } static boolean isHex ( byte octect ) { return ( hexNumberTable [ octect ] != - 1 ) ; } static boolean isArrayByteHex ( byte [ ] arrayOctect ) { int length = arrayOctect . length ; if ( length == 0 ) return false ; for ( int i = 0 ; i < length ; i ++ ) { if ( HexBin . isHex ( arrayOctect [ i ] ) == false ) return false ; } return true ; } public static boolean isHex ( String isValidString ) { return ( isArrayByteHex ( isValidString . getBytes ( ) ) ) ; } static public byte [ ] encode ( byte [ ] binaryData ) { int lengthData = binaryData . length ; int lengthEncode = lengthData ; byte [ ] encodedData = new byte [ lengthData ] ; for ( int i = 0 ; i < lengthData ; i ++ ) { encodedData [ i ] = lookUpHexAlphabet [ binaryData [ i ] ] ; } return encodedData ; } static public byte [ ] decode ( byte [ ] binaryData ) { int lengthData = binaryData . length ; int lengthEncode = lengthData ; byte [ ] decodedData = new byte [ lengthData ] ; for ( int i = 0 ; i < lengthData ; i ++ ) { decodedData [ i ] = hexNumberTable [ binaryData [ i ] ] ; } return decodedData ; } } 	1
package org . apache . wml ; public interface WMLAnchorElement extends WMLElement { public void setTitle ( String newValue ) ; public String getTitle ( ) ; public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . w3c . dom ; public interface EntityReference extends Node { } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . validators . schema . EquivClassComparator ; public class SimpleContentModel implements XMLContentModel { private QName fFirstChild = new QName ( ) ; private QName fSecondChild = new QName ( ) ; private int fOp ; private boolean fDTD ; private EquivClassComparator comparator = null ; public SimpleContentModel ( QName firstChild , QName secondChild , int cmOp ) { this ( firstChild , secondChild , cmOp , false ) ; } public SimpleContentModel ( QName firstChild , QName secondChild , int cmOp , boolean dtd ) { fFirstChild . setValues ( firstChild ) ; if ( secondChild != null ) { fSecondChild . setValues ( secondChild ) ; } else { fSecondChild . clear ( ) ; } fOp = cmOp ; fDTD = dtd ; } public int validateContent ( QName children [ ] , int offset , int length ) throws Exception { switch ( fOp ) { case XMLContentSpec . CONTENTSPECNODE_LEAF : if ( length == 0 ) return 0 ; if ( fDTD ) { if ( children [ offset ] . rawname != fFirstChild . rawname ) { return 0 ; } } else { if ( children [ offset ] . uri != fFirstChild . uri || children [ offset ] . localpart != fFirstChild . localpart ) return 0 ; } if ( length > 1 ) return 1 ; break ; case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE : if ( length == 1 ) { if ( fDTD ) { if ( children [ offset ] . rawname != fFirstChild . rawname ) { return 0 ; } } else { if ( children [ offset ] . uri != fFirstChild . uri || children [ offset ] . localpart != fFirstChild . localpart ) return 0 ; } } if ( length > 1 ) return 1 ; break ; case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE : if ( length > 0 ) { if ( fDTD ) { for ( int index = 0 ; index < length ; index ++ ) { if ( children [ offset + index ] . rawname != fFirstChild . rawname ) { return index ; } } } else { for ( int index = 0 ; index < length ; index ++ ) { if ( children [ offset + index ] . uri != fFirstChild . uri || children [ offset + index ] . localpart != fFirstChild . localpart ) return index ; } } } break ; case XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE : if ( length == 0 ) return 0 ; if ( fDTD ) { for ( int index = 0 ; index < length ; index ++ ) { if ( children [ offset + index ] . rawname != fFirstChild . rawname ) { return index ; } } } else { for ( int index = 0 ; index < length ; index ++ ) { if ( children [ offset + index ] . uri != fFirstChild . uri || children [ offset + index ] . localpart != fFirstChild . localpart ) return index ; } } break ; case XMLContentSpec . CONTENTSPECNODE_CHOICE : if ( length == 0 ) return 0 ; if ( fDTD ) { if ( ( children [ offset ] . rawname != fFirstChild . rawname ) && ( children [ offset ] . rawname != fSecondChild . rawname ) ) { return 0 ; } } else { if ( ( children [ offset ] . uri != fFirstChild . uri || children [ offset ] . localpart != fFirstChild . localpart ) && ( children [ offset ] . uri != fSecondChild . uri || children [ offset ] . localpart != fSecondChild . localpart ) ) return 0 ; } if ( length > 1 ) return 1 ; break ; case XMLContentSpec . CONTENTSPECNODE_SEQ : if ( length == 2 ) { if ( fDTD ) { if ( children [ offset ] . rawname != fFirstChild . rawname ) { return 0 ; } if ( children [ offset + 1 ] . rawname != fSecondChild . rawname ) { return 1 ; } } else { if ( children [ offset ] . uri != fFirstChild . uri || children [ offset ] . localpart != fFirstChild . localpart ) return 0 ; if ( children [ offset + 1 ] . uri != fSecondChild . uri || children [ offset + 1 ] . localpart != fSecondChild . localpart ) return 1 ; } } else { if ( length > 2 ) { return 2 ; } return length ; } break ; default : throw new CMException ( ImplementationMessages . VAL_CST ) ; } return - 1 ; } public int validateContentSpecial ( QName children [ ] , int offset , int length ) throws Exception { if ( comparator == null ) { return validateContent ( children , offset , length ) ; } switch ( fOp ) { case XMLContentSpec . CONTENTSPECNODE_LEAF : if ( length == 0 ) return 0 ; if ( children [ offset ] . uri != fFirstChild . uri || children [ offset ] . localpart != fFirstChild . localpart ) if ( ! comparator . isEquivalentTo ( children [ offset ] , fFirstChild ) ) return 0 ; if ( length > 1 ) return 1 ; break ; case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE : if ( length == 1 && ( children [ offset ] . uri != fFirstChild . uri || children [ offset ] . localpart != fFirstChild . localpart ) ) if ( ! comparator . isEquivalentTo ( children [ offset ] , fFirstChild ) ) return 0 ; if ( length > 1 ) return 1 ; break ; case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE : if ( length > 0 ) { for ( int index = 0 ; index < length ; index ++ ) { if ( children [ offset + index ] . uri != fFirstChild . uri || children [ offset + index ] . localpart != fFirstChild . localpart ) if ( ! comparator . isEquivalentTo ( children [ offset + index ] , fFirstChild ) ) return index ; } } break ; case XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE : if ( length == 0 ) return 0 ; for ( int index = 0 ; index < length ; index ++ ) { if ( children [ offset + index ] . uri != fFirstChild . uri || children [ offset + index ] . localpart != fFirstChild . localpart ) if ( ! comparator . isEquivalentTo ( children [ offset + index ] , fFirstChild ) ) return index ; } break ; case XMLContentSpec . CONTENTSPECNODE_CHOICE : if ( length == 0 ) return 0 ; if ( ( children [ offset ] . uri != fFirstChild . uri || children [ offset ] . localpart != fFirstChild . localpart ) && ( children [ offset ] . uri != fSecondChild . uri || children [ offset ] . localpart != fSecondChild . localpart ) ) if ( ! comparator . isEquivalentTo ( children [ offset ] , fFirstChild ) && ! comparator . isEquivalentTo ( children [ offset ] , fSecondChild ) ) return 0 ; if ( length > 1 ) return 1 ; break ; case XMLContentSpec . CONTENTSPECNODE_SEQ : if ( length == 2 ) { if ( children [ offset ] . uri != fFirstChild . uri || children [ offset ] . localpart != fFirstChild . localpart ) if ( ! comparator . isEquivalentTo ( children [ offset ] , fFirstChild ) ) return 0 ; if ( children [ offset + 1 ] . uri != fSecondChild . uri || children [ offset + 1 ] . localpart != fSecondChild . localpart ) if ( ! comparator . isEquivalentTo ( children [ offset + 1 ] , fSecondChild ) ) return 1 ; } else { if ( length > 2 ) { return 2 ; } return length ; } break ; default : throw new CMException ( ImplementationMessages . VAL_CST ) ; } return - 1 ; } public void setEquivClassComparator ( EquivClassComparator comparator ) { this . comparator = comparator ; } public int whatCanGoHere ( boolean fullyValid , InsertableElementsInfo info ) throws Exception { for ( int index = info . insertAt ; index < info . childCount ; index ++ ) { info . curChildren [ index ] . setValues ( info . curChildren [ index + 1 ] ) ; } info . childCount -- ; final int failedIndex = validateContent ( info . curChildren , 0 , info . childCount ) ; if ( ( failedIndex != - 1 ) && ( failedIndex < info . insertAt ) ) return failedIndex ; info . canHoldPCData = false ; if ( ( fOp == XMLContentSpec . CONTENTSPECNODE_LEAF ) || ( fOp == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) || ( fOp == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) || ( fOp == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) ) { info . resultsCount = 1 ; } else if ( ( fOp == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( fOp == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { info . resultsCount = 2 ; } else { throw new CMException ( ImplementationMessages . VAL_CST ) ; } if ( ( info . results == null ) || ( info . results . length < info . resultsCount ) ) info . results = new boolean [ info . resultsCount ] ; if ( ( info . possibleChildren == null ) || ( info . possibleChildren . length < info . resultsCount ) ) { info . possibleChildren = new QName [ info . resultsCount ] ; for ( int i = 0 ; i < info . possibleChildren . length ; i ++ ) { info . possibleChildren [ i ] = new QName ( ) ; } } info . possibleChildren [ 0 ] . setValues ( fFirstChild ) ; info . results [ 0 ] = false ; if ( info . resultsCount == 2 ) { info . possibleChildren [ 1 ] . setValues ( fSecondChild ) ; info . results [ 1 ] = false ; } info . isValidEOC = false ; switch ( fOp ) { case XMLContentSpec . CONTENTSPECNODE_LEAF : case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE : if ( info . childCount == 0 ) { info . results [ 0 ] = true ; } else if ( info . childCount > 0 ) { if ( ! fullyValid && ( info . insertAt == 0 ) ) info . results [ 0 ] = true ; } if ( fOp == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( info . insertAt == 0 ) info . isValidEOC = true ; } else { info . isValidEOC = true ; } break ; case XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE : case XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE : info . results [ 0 ] = true ; if ( ( fOp == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) || ( info . insertAt > 0 ) ) { info . isValidEOC = true ; } break ; case XMLContentSpec . CONTENTSPECNODE_CHOICE : if ( info . insertAt == 0 ) { if ( ! fullyValid && ( info . childCount == 0 ) ) { info . results [ 0 ] = true ; info . results [ 1 ] = true ; } } if ( info . insertAt == 1 ) info . isValidEOC = true ; break ; case XMLContentSpec . CONTENTSPECNODE_SEQ : if ( info . insertAt == 0 ) { if ( fullyValid ) { if ( info . childCount == 1 ) info . results [ 0 ] = info . curChildren [ 0 ] . uri == fSecondChild . uri && info . curChildren [ 0 ] . localpart == fSecondChild . localpart ; } else { info . results [ 0 ] = true ; } } else if ( info . insertAt == 1 ) { if ( ! fullyValid || ( info . childCount == 1 ) ) info . results [ 1 ] = true ; } if ( info . insertAt == 2 ) info . isValidEOC = true ; break ; default : throw new CMException ( ImplementationMessages . VAL_CST ) ; } return - 1 ; } public ContentLeafNameTypeVector getContentLeafNameTypeVector ( ) { return null ; } } 	0
package org . w3c . dom ; public interface Attr extends Node { public String getName ( ) ; public boolean getSpecified ( ) ; public String getValue ( ) ; public void setValue ( String value ) throws DOMException ; public Element getOwnerElement ( ) ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLWmlElementImpl extends WMLElementImpl implements WMLWmlElement { public WMLWmlElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . DOMException ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . CharacterData ; import org . apache . xerces . dom . DOMExceptionImpl ; import org . apache . xerces . dom . DocumentImpl ; import org . w3c . dom . range . * ; import java . util . Vector ; public class RangeImpl implements Range { static final int START = 0 ; static final int AFTER = 1 ; static final int BEFORE = - 1 ; DocumentImpl fDocument ; Node fStartContainer ; Node fEndContainer ; int fStartOffset ; int fEndOffset ; boolean fIsCollapsed ; boolean fDetach = false ; Node fInsertNode = null ; Node fDeleteNode = null ; Node fSplitNode = null ; public RangeImpl ( DocumentImpl document ) { fDocument = document ; fStartContainer = document ; fEndContainer = document ; fStartOffset = 0 ; fEndOffset = 0 ; fDetach = false ; } public Node getStartContainer ( ) { return fStartContainer ; } public int getStartOffset ( ) { return fStartOffset ; } public Node getEndContainer ( ) { return fEndContainer ; } public int getEndOffset ( ) { return fEndOffset ; } public boolean getCollapsed ( ) { return ( fStartContainer == fEndContainer && fStartOffset == fEndOffset ) ; } public Node getCommonAncestorContainer ( ) { Vector startV = new Vector ( ) ; Node node ; for ( node = fStartContainer ; node != null ; node = node . getParentNode ( ) ) { startV . addElement ( node ) ; } Vector endV = new Vector ( ) ; for ( node = fEndContainer ; node != null ; node = node . getParentNode ( ) ) { endV . addElement ( node ) ; } int s = startV . size ( ) - 1 ; int e = endV . size ( ) - 1 ; Object result = null ; while ( s >= 0 && e >= 0 ) { if ( startV . elementAt ( s ) == endV . elementAt ( e ) ) { result = startV . elementAt ( s ) ; } else { break ; } -- s ; -- e ; } return ( Node ) result ; } public void setStart ( Node refNode , int offset ) throws RangeException , DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } checkIndex ( refNode , offset ) ; fStartContainer = refNode ; fStartOffset = offset ; } public void setEnd ( Node refNode , int offset ) throws RangeException , DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } checkIndex ( refNode , offset ) ; fEndContainer = refNode ; fEndOffset = offset ; } public void setStartBefore ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i - 1 ; } public void setStartAfter ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i ; } public void setEndBefore ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fEndContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fEndOffset = i - 1 ; } public void setEndAfter ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fEndContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fEndOffset = i ; } public void collapse ( boolean toStart ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( toStart ) { fEndContainer = fStartContainer ; fEndOffset = fStartOffset ; } else { fStartContainer = fEndContainer ; fStartOffset = fEndOffset ; } } public void selectNode ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } Node parent = refNode . getParentNode ( ) ; if ( parent != null ) { fStartContainer = parent ; fEndContainer = parent ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i - 1 ; fEndOffset = fStartOffset + 1 ; } } public void selectNodeContents ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode ; fEndContainer = refNode ; Node first = refNode . getFirstChild ( ) ; fStartOffset = 0 ; if ( first == null ) { fEndOffset = 0 ; } else { int i = 0 ; for ( Node n = first ; n != null ; n = n . getNextSibling ( ) ) { i ++ ; } fEndOffset = i ; } } public short compareBoundaryPoints ( short how , Range sourceRange ) throws DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Node endPointA ; Node endPointB ; int offsetA ; int offsetB ; if ( how == START_TO_START ) { endPointA = sourceRange . getStartContainer ( ) ; endPointB = fStartContainer ; offsetA = sourceRange . getStartOffset ( ) ; offsetB = fStartOffset ; } else if ( how == START_TO_END ) { endPointA = sourceRange . getStartContainer ( ) ; endPointB = fEndContainer ; offsetA = sourceRange . getStartOffset ( ) ; offsetB = fEndOffset ; } else if ( how == END_TO_START ) { endPointA = sourceRange . getEndContainer ( ) ; endPointB = fStartContainer ; offsetA = sourceRange . getEndOffset ( ) ; offsetB = fStartOffset ; } else { endPointA = sourceRange . getEndContainer ( ) ; endPointB = fEndContainer ; offsetA = sourceRange . getEndOffset ( ) ; offsetB = fEndOffset ; } if ( endPointA == endPointB ) { if ( offsetA < offsetB ) return - 1 ; if ( offsetA == offsetB ) return 0 ; return 1 ; } for ( Node node = endPointA . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { if ( isAncestorOf ( node , endPointB ) ) { int index = indexOf ( node , endPointA ) ; if ( offsetA < index ) return - 1 ; if ( offsetA == index ) return 0 ; return 1 ; } } for ( Node node = endPointB . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { if ( isAncestorOf ( node , endPointA ) ) { int index = indexOf ( node , endPointB ) ; if ( offsetB < index ) return - 1 ; if ( offsetB == index ) return 0 ; return 1 ; } } Node ancestor = getCommonAncestorContainer ( ) ; Node current = ancestor ; do { if ( current == endPointA ) return - 1 ; if ( current == endPointB ) return 1 ; current = nextNode ( current , true ) ; } while ( current != null && current != ancestor ) ; return - 2 ; } public void deleteContents ( ) throws DOMException { Node current = fStartContainer ; Node parent = null ; Node next ; boolean deleteCurrent = false ; Node root = getCommonAncestorContainer ( ) ; if ( fStartContainer == fEndContainer ) { if ( fStartOffset == fEndOffset ) { return ; } if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { String value = fStartContainer . getNodeValue ( ) ; int realStart = fStartOffset ; int realEnd = fEndOffset ; if ( fStartOffset > value . length ( ) ) realStart = value . length ( ) - 1 ; if ( fEndOffset > value . length ( ) ) realEnd = value . length ( ) - 1 ; deleteData ( ( CharacterData ) fStartContainer , realStart , realEnd - realStart ) ; } else { current = fStartContainer . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } for ( i = 0 ; i < fEndOffset - fStartOffset && current != null ; i ++ ) { Node newCurrent = current . getNextSibling ( ) ; removeChild ( fStartContainer , current ) ; current = newCurrent ; } } collapse ( true ) ; return ; } Node partialNode = null ; int partialInt = START ; Node startRoot = null ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { deleteData ( ( CharacterData ) current , fStartOffset , current . getNodeValue ( ) . length ( ) - fStartOffset ) ; } else { current = current . getFirstChild ( ) ; for ( int i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fStartContainer ; } else if ( current != fStartContainer ) { deleteCurrent = true ; } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { if ( startRoot == null ) startRoot = current ; } else { if ( partialNode == null ) { partialNode = parent ; partialInt = AFTER ; } } if ( parent != root ) { next = current . getNextSibling ( ) ; Node nextnext ; while ( next != null ) { nextnext = next . getNextSibling ( ) ; removeChild ( parent , next ) ; next = nextnext ; } } if ( deleteCurrent ) { removeChild ( parent , current ) ; deleteCurrent = false ; } current = parent ; } Node endRoot = null ; current = fEndContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { deleteData ( ( CharacterData ) current , 0 , fEndOffset ) ; } else { if ( fEndOffset == 0 ) { current = fEndContainer ; } else { current = current . getFirstChild ( ) ; for ( int i = 1 ; i < fEndOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fEndContainer . getLastChild ( ) ; } else if ( current != fStartContainer ) { deleteCurrent = true ; } } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { if ( endRoot == null ) endRoot = current ; } else { if ( partialNode == null ) { partialNode = parent ; partialInt = BEFORE ; } } if ( parent != root && parent != null ) { next = current . getPreviousSibling ( ) ; Node nextnext ; while ( next != null ) { nextnext = next . getPreviousSibling ( ) ; removeChild ( parent , next ) ; next = nextnext ; } } if ( deleteCurrent ) { removeChild ( parent , current ) ; deleteCurrent = false ; } current = parent ; } current = endRoot . getPreviousSibling ( ) ; Node prev = null ; while ( current != null && current != startRoot ) { prev = current . getPreviousSibling ( ) ; parent = current . getParentNode ( ) ; if ( parent != null ) { removeChild ( parent , current ) ; } current = prev ; } if ( partialNode == null ) { collapse ( true ) ; } else if ( partialInt == AFTER ) { setStartAfter ( partialNode ) ; setEndAfter ( partialNode ) ; } else if ( partialInt == BEFORE ) { setStartBefore ( partialNode ) ; setEndBefore ( partialNode ) ; } } public DocumentFragment extractContents ( ) throws DOMException { return traverseContents ( EXTRACT_CONTENTS ) ; } public DocumentFragment cloneContents ( ) throws DOMException { return traverseContents ( CLONE_CONTENTS ) ; } public void insertNode ( Node newNode ) throws DOMException , RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } int type = newNode . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_NODE || type == Node . DOCUMENT_FRAGMENT_NODE ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } if ( newNode == null ) return ; Node cloneCurrent ; Node current ; boolean MULTIPLE_MODE = false ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( newNode . getNodeType ( ) != Node . TEXT_NODE ) { cloneCurrent = fStartContainer . cloneNode ( false ) ; ( ( TextImpl ) cloneCurrent ) . setNodeValueInternal ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset ) ) ; ( ( TextImpl ) fStartContainer ) . setNodeValueInternal ( ( fStartContainer . getNodeValue ( ) ) . substring ( 0 , fStartOffset ) ) ; Node next = fStartContainer . getNextSibling ( ) ; if ( next != null ) { Node parent = fStartContainer . getParentNode ( ) ; if ( parent != null ) { parent . insertBefore ( newNode , next ) ; parent . insertBefore ( cloneCurrent , next ) ; } } else { Node parent = fStartContainer . getParentNode ( ) ; if ( parent != null ) { parent . appendChild ( newNode ) ; parent . appendChild ( cloneCurrent ) ; } } signalSplitData ( fStartContainer , cloneCurrent , fStartOffset ) ; } else { String value = fStartContainer . getNodeValue ( ) ; String newValue = newNode . getNodeValue ( ) ; insertData ( ( CharacterData ) fStartContainer , fStartOffset , newValue ) ; } } else { current = fStartContainer . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current != null ) { fStartContainer . insertBefore ( newNode , current ) ; } else { fStartContainer . appendChild ( newNode ) ; } } } public void surroundContents ( Node newParent ) throws DOMException , RangeException { if ( newParent == null ) return ; if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } int type = newParent . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_TYPE_NODE || type == Node . DOCUMENT_NODE || type == Node . DOCUMENT_FRAGMENT_NODE ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } Node root = getCommonAncestorContainer ( ) ; Node realStart = fStartContainer ; Node realEnd = fEndContainer ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { realStart = fStartContainer . getParentNode ( ) ; } if ( fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { realEnd = fEndContainer . getParentNode ( ) ; } if ( realStart != realEnd ) { throw new RangeExceptionImpl ( RangeException . BAD_BOUNDARYPOINTS_ERR , "DOM013 Bad boundary points" ) ; } DocumentFragment frag = extractContents ( ) ; insertNode ( newParent ) ; newParent . appendChild ( frag ) ; selectNode ( newParent ) ; } public Range cloneRange ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Range range = fDocument . createRange ( ) ; range . setStart ( fStartContainer , fStartOffset ) ; range . setEnd ( fEndContainer , fEndOffset ) ; return range ; } public String toString ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Node node = fStartContainer ; StringBuffer sb = new StringBuffer ( ) ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE || fStartContainer . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { if ( fStartContainer == fEndContainer ) { sb . append ( fStartContainer . getNodeValue ( ) . substring ( fStartOffset , fEndOffset ) ) ; return sb . toString ( ) ; } else { sb . append ( fStartContainer . getNodeValue ( ) . substring ( fStartOffset ) ) ; } } while ( node != fEndContainer ) { node = nextNode ( node , true ) ; if ( node == null ) break ; if ( node . getNodeType ( ) == Node . TEXT_NODE || node . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { sb . append ( node . getNodeValue ( ) ) ; } } if ( fEndContainer . getNodeType ( ) == Node . TEXT_NODE || fEndContainer . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { sb . append ( fEndContainer . getNodeValue ( ) . substring ( 0 , fEndOffset ) ) ; } return sb . toString ( ) ; } public void detach ( ) { fDetach = true ; fDocument . removeRange ( this ) ; } void signalSplitData ( Node node , Node newNode , int offset ) { fSplitNode = node ; fDocument . splitData ( node , newNode , offset ) ; fSplitNode = null ; } void receiveSplitData ( Node node , Node newNode , int offset ) { if ( node == null || newNode == null ) return ; if ( fSplitNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fStartOffset > offset ) { fStartOffset = fStartOffset - offset ; fStartContainer = newNode ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fEndOffset > offset ) { fEndOffset = fEndOffset - offset ; fEndContainer = newNode ; } } } void deleteData ( CharacterData node , int offset , int count ) { fDeleteNode = node ; node . deleteData ( offset , count ) ; fDeleteNode = null ; } void receiveDeletedText ( Node node , int offset , int count ) { if ( node == null ) return ; if ( fDeleteNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fStartOffset > offset + count ) { fStartOffset = offset + ( fStartOffset - ( offset + count ) ) ; } else if ( fStartOffset > offset ) { fStartOffset = offset ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fEndOffset > offset + count ) { fEndOffset = offset + ( fEndOffset - ( offset + count ) ) ; } else if ( fEndOffset > offset ) { fEndOffset = offset ; } } } void insertData ( CharacterData node , int index , String insert ) { fInsertNode = node ; node . insertData ( index , insert ) ; fInsertNode = null ; } void receiveInsertedText ( Node node , int index , int len ) { if ( node == null ) return ; if ( fInsertNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( index < fStartOffset ) { fStartOffset = fStartOffset + len ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( index < fEndOffset ) { fEndOffset = fEndOffset + len ; } } } void receiveReplacedText ( Node node ) { if ( node == null ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { fStartOffset = 0 ; } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { fEndOffset = 0 ; } } public void insertedNodeFromDOM ( Node node ) { if ( node == null ) return ; if ( fInsertNode == node ) return ; Node parent = node . getParentNode ( ) ; if ( parent == fStartContainer ) { int index = indexOf ( node , fStartContainer ) ; if ( index < fStartOffset ) { fStartOffset ++ ; } } if ( parent == fEndContainer ) { int index = indexOf ( node , fEndContainer ) ; if ( index < fEndOffset ) { fEndOffset ++ ; } } } Node fRemoveChild = null ; Node removeChild ( Node parent , Node child ) { fRemoveChild = child ; Node n = parent . removeChild ( child ) ; fRemoveChild = null ; return n ; } void removeNode ( Node node ) { if ( node == null ) return ; if ( fRemoveChild == node ) return ; Node parent = node . getParentNode ( ) ; if ( parent == fStartContainer ) { int index = indexOf ( node , fStartContainer ) ; if ( index <= fStartOffset ) { fStartOffset -- ; } } if ( parent == fEndContainer ) { int index = indexOf ( node , fEndContainer ) ; if ( index < fEndOffset ) { fEndOffset -- ; } } if ( parent != fStartContainer && parent != fEndContainer ) { if ( isAncestorOf ( node , fStartContainer ) ) { fStartContainer = parent ; fStartOffset = indexOf ( node , parent ) - 1 ; } if ( isAncestorOf ( node , fEndContainer ) ) { fEndContainer = parent ; fEndOffset = indexOf ( node , parent ) - 1 ; } } } static final int EXTRACT_CONTENTS = 1 ; static final int CLONE_CONTENTS = 2 ; DocumentFragment traverseContents ( int traversalType ) throws DOMException { if ( fStartContainer == null || fEndContainer == null ) { return null ; } DocumentFragment frag = fDocument . createDocumentFragment ( ) ; Node current = fStartContainer ; Node cloneCurrent = null ; Node cloneParent = null ; Node partialNode = null ; int partialInt = START ; Vector d = new Vector ( ) ; if ( fStartContainer == fEndContainer ) { if ( fStartOffset == fEndOffset ) { return frag ; } if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = fStartContainer . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset , fEndOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , fStartOffset , fEndOffset - fStartOffset ) ; } frag . appendChild ( cloneCurrent ) ; } else { current = current . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } int n = fEndOffset - fStartOffset ; for ( i = 0 ; i < n && current != null ; i ++ ) { Node newCurrent = current . getNextSibling ( ) ; if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; frag . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { frag . appendChild ( current ) ; } current = newCurrent ; } } return frag ; } Node root = getCommonAncestorContainer ( ) ; Node parent = null ; current = fStartContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = current . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , fStartOffset , current . getNodeValue ( ) . length ( ) - fStartOffset ) ; } } else { current = current . getFirstChild ( ) ; for ( int i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fStartContainer ; } if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } } Node startRoot = null ; parent = null ; while ( current != root ) { parent = current . getParentNode ( ) ; if ( parent == root ) { cloneParent = frag ; startRoot = current ; } else { if ( parent == null ) System . out . println ( "parent==null: current=" + current ) ; cloneParent = parent . cloneNode ( false ) ; if ( partialNode == null && parent != root ) { partialNode = parent ; partialInt = AFTER ; } } Node next = null ; current = current . getNextSibling ( ) ; cloneParent . appendChild ( cloneCurrent ) ; while ( current != null ) { next = current . getNextSibling ( ) ; if ( current != null && parent != root ) { if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; cloneParent . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneParent . appendChild ( current ) ; } } current = next ; } current = parent ; cloneCurrent = cloneParent ; } Node endRoot = null ; current = fEndContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = current . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( 0 , fEndOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , 0 , fEndOffset ) ; } } else { if ( fEndOffset == 0 ) { current = fEndContainer ; } else { current = current . getFirstChild ( ) ; for ( int i = 1 ; i < fEndOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fEndContainer . getLastChild ( ) ; } } if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { cloneParent = frag ; endRoot = current ; } else { cloneParent = parent . cloneNode ( false ) ; if ( partialNode == null && parent != root ) { partialNode = parent ; partialInt = BEFORE ; } } Node holdCurrent = current ; current = parent . getFirstChild ( ) ; cloneParent . appendChild ( cloneCurrent ) ; Node next = null ; while ( current != holdCurrent && current != null ) { next = current . getNextSibling ( ) ; if ( current != null && parent != root ) { if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; cloneParent . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneParent . appendChild ( current ) ; } } current = next ; } current = parent ; cloneCurrent = cloneParent ; } d . removeAllElements ( ) ; Node clonedPrevious = frag . getLastChild ( ) ; current = endRoot . getPreviousSibling ( ) ; Node prev = null ; while ( current != startRoot && current != null ) { prev = current . getPreviousSibling ( ) ; if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } frag . insertBefore ( cloneCurrent , clonedPrevious ) ; current = prev ; clonedPrevious = cloneCurrent ; } if ( traversalType == EXTRACT_CONTENTS ) { if ( partialNode == null ) { collapse ( true ) ; } else if ( partialInt == AFTER ) { setStartAfter ( partialNode ) ; setEndAfter ( partialNode ) ; } else if ( partialInt == BEFORE ) { setStartBefore ( partialNode ) ; setEndBefore ( partialNode ) ; } } return frag ; } void checkIndex ( Node refNode , int offset ) throws DOMException { if ( offset < 0 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } int type = refNode . getNodeType ( ) ; if ( ( type == Node . TEXT_NODE || type == Node . CDATA_SECTION_NODE || type == Node . COMMENT_NODE || type == Node . PROCESSING_INSTRUCTION_NODE ) && offset > refNode . getNodeValue ( ) . length ( ) ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } Node child = refNode . getFirstChild ( ) ; int i = 1 ; for ( ; child != null ; i ++ ) { child = child . getNextSibling ( ) ; } if ( i > offset ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } boolean isAncestorTypeValid ( Node node ) { for ( Node n = node ; n != null ; n = n . getParentNode ( ) ) { int type = n . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_TYPE_NODE ) return false ; } return true ; } Node nextNode ( Node node , boolean visitChildren ) { if ( node == null ) return null ; Node result ; if ( visitChildren ) { result = node . getFirstChild ( ) ; if ( result != null ) { return result ; } } result = node . getNextSibling ( ) ; if ( result != null ) { return result ; } Node parent = node . getParentNode ( ) ; while ( parent != null && parent != fDocument ) { result = parent . getNextSibling ( ) ; if ( result != null ) { return result ; } else { parent = parent . getParentNode ( ) ; } } return null ; } boolean isAncestorOf ( Node a , Node b ) { for ( Node node = b ; node != null ; node = node . getParentNode ( ) ) { if ( node == a ) return true ; } return false ; } int indexOf ( Node child , Node parent ) { Node node ; int i = 0 ; if ( child . getParentNode ( ) != parent ) return - 1 ; for ( node = child ; node != null ; node = node . getPreviousSibling ( ) ) { i ++ ; } return i ; } } 	1
package org . apache . xerces . dom ; import org . apache . xerces . utils . StringPool ; import org . w3c . dom . * ; public class DeferredEntityImpl extends EntityImpl implements DeferredNode { static final long serialVersionUID = 4760180431078941638L ; protected transient int fNodeIndex ; DeferredEntityImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; needsSyncChildren ( true ) ; } public int getNodeIndex ( ) { return fNodeIndex ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; name = ownerDocument . getNodeNameString ( fNodeIndex ) ; StringPool pool = ownerDocument . getStringPool ( ) ; int extraDataIndex = ownerDocument . getNodeValue ( fNodeIndex ) ; ownerDocument . getNodeType ( extraDataIndex ) ; publicId = pool . toString ( ownerDocument . getNodeName ( extraDataIndex ) ) ; systemId = pool . toString ( ownerDocument . getNodeValue ( extraDataIndex ) ) ; notationName = pool . toString ( ownerDocument . getLastChild ( extraDataIndex ) ) ; } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; isReadOnly ( false ) ; synchronizeChildren ( fNodeIndex ) ; setReadOnly ( true , true ) ; } } 	0
package org . apache . xerces . jaxp ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xerces . parsers . SAXParser ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public class SAXParserImpl extends javax . xml . parsers . SAXParser { private boolean namespaces = false ; private boolean validation = false ; private Parser parser = null ; private SAXParserImpl ( ) { super ( ) ; } protected SAXParserImpl ( boolean namespaces , boolean validation ) throws ParserConfigurationException { this ( ) ; SAXParser p = new SAXParser ( ) ; try { p . setFeature ( "http://xml.org/sax/features/namespaces" , namespaces ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set namespace " + "awareness to " + namespaces ) ; } try { p . setFeature ( "http://xml.org/sax/features/validation" , validation ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set validation to " + validation ) ; } this . namespaces = namespaces ; this . validation = validation ; this . parser = p ; } public Parser getParser ( ) { return ( this . parser ) ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLFieldSetElement extends HTMLElement { public HTMLFormElement getForm ( ) ; } 	0
package javax . xml . parsers ; import org . xml . sax . SAXException ; public abstract class SAXParserFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.SAXParserFactory" ; private static String factory = "org.apache.xerces.jaxp.SAXParserFactoryImpl" ; protected SAXParserFactory ( ) { super ( ) ; } public static SAXParserFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( SAXParserFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "SAXParserFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified SAXParserFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "SAXParserFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"javax.xml.parsers.SAXParserFactory\"" ) ; } } public abstract SAXParser newSAXParser ( ) throws ParserConfigurationException , SAXException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . wml ; public interface WMLFieldsetElement extends WMLElement { public void setTitle ( String newValue ) ; public String getTitle ( ) ; public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . apache . xerces . framework ; public class Version { public static String fVersion = "Xerces 1.2.0" ; public static void main ( String argv [ ] ) { System . out . println ( fVersion ) ; } } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DocumentFragmentImpl extends ParentNode implements DocumentFragment { static final long serialVersionUID = - 7596449967279236746L ; public DocumentFragmentImpl ( DocumentImpl ownerDoc ) { super ( ownerDoc ) ; } public DocumentFragmentImpl ( ) { } public short getNodeType ( ) { return Node . DOCUMENT_FRAGMENT_NODE ; } public String getNodeName ( ) { return "#document-fragment" ; } } 	0
package org . w3c . dom ; public interface CDATASection extends Text { } 	1
package org . apache . xerces . validators . common ; public abstract class CMNode { CMNode ( int type ) throws CMException { fType = type ; } abstract boolean isNullable ( ) throws CMException ; final int type ( ) { return fType ; } final CMStateSet firstPos ( ) throws CMException { if ( fFirstPos == null ) { fFirstPos = new CMStateSet ( fMaxStates ) ; calcFirstPos ( fFirstPos ) ; } return fFirstPos ; } final CMStateSet lastPos ( ) throws CMException { if ( fLastPos == null ) { fLastPos = new CMStateSet ( fMaxStates ) ; calcLastPos ( fLastPos ) ; } return fLastPos ; } final void setFollowPos ( CMStateSet setToAdopt ) { fFollowPos = setToAdopt ; } final void setMaxStates ( int maxStates ) { fMaxStates = maxStates ; } protected abstract void calcFirstPos ( CMStateSet toSet ) throws CMException ; protected abstract void calcLastPos ( CMStateSet toSet ) throws CMException ; private int fType ; private CMStateSet fFirstPos = null ; private CMStateSet fFollowPos = null ; private CMStateSet fLastPos = null ; private int fMaxStates = - 1 ; } ; 	0
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . validators . schema . EquivClassComparator ; public class DFAContentModel implements XMLContentModel { private static final int EPSILON = - 2 ; private static final int EOC = - 3 ; private static final boolean DEBUG_VALIDATE_CONTENT = false ; private EquivClassComparator comparator = null ; private QName fElemMap [ ] = null ; private int fElemMapType [ ] = null ; private int fElemMapSize = 0 ; private boolean fDTD ; private int fEOCIndex = 0 ; private int fEOCPos = 0 ; private int fEpsilonIndex = 0 ; private boolean fFinalStateFlags [ ] = null ; private CMStateSet fFollowList [ ] = null ; private CMNode fHeadNode = null ; private int fLeafCount = 0 ; private CMLeaf fLeafList [ ] = null ; private int fLeafListType [ ] = null ; private ContentLeafNameTypeVector fLeafNameTypeVector = null ; private int fTransTable [ ] [ ] = null ; private int fTransTableSize = 0 ; private boolean fEmptyContentIsValid = false ; private QName fQName = new QName ( ) ; public DFAContentModel ( CMNode syntaxTree , int leafCount ) throws CMException { this ( syntaxTree , leafCount , false ) ; } public DFAContentModel ( CMNode syntaxTree , int leafCount , boolean dtd ) throws CMException { fLeafCount = leafCount ; fEpsilonIndex = EPSILON ; fEOCIndex = EOC ; fDTD = dtd ; buildDFA ( syntaxTree ) ; } public int validateContent ( QName children [ ] , int offset , int length ) throws CMException { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "DFAContentModel#validateContent" ) ; if ( length == 0 ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! no children" ) ; System . out . println ( "elemMap=" + fElemMap ) ; for ( int i = 0 ; i < fElemMap . length ; i ++ ) { int uriIndex = fElemMap [ i ] . uri ; int localpartIndex = fElemMap [ i ] . localpart ; } System . out . println ( "EOCIndex=" + fEOCIndex ) ; } return fEmptyContentIsValid ? - 1 : 0 ; } int curState = 0 ; for ( int childIndex = 0 ; childIndex < length ; childIndex ++ ) { final QName curElem = children [ offset + childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { int type = fElemMapType [ elemIndex ] & 0x0f ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fDTD ) { if ( fElemMap [ elemIndex ] . rawname == curElem . rawname ) { break ; } } else { if ( fElemMap [ elemIndex ] . uri == curElem . uri && fElemMap [ elemIndex ] . localpart == curElem . localpart ) break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ elemIndex ] . uri ; if ( uri == - 1 || uri == curElem . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( curElem . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ elemIndex ] . uri != curElem . uri ) { break ; } } } if ( elemIndex == fElemMapSize ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! didn't find it" ) ; System . out . println ( "curElem : " + curElem ) ; for ( int i = 0 ; i < fElemMapSize ; i ++ ) { System . out . println ( "fElemMap[" + i + "] = " + fElemMap [ i ] ) ; System . out . println ( "fElemMapType[" + i + "] = " + fElemMapType [ i ] ) ; } } return childIndex ; } curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "!!! not a legal transition" ) ; return childIndex ; } } if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "curState=" + curState + ", childCount=" + length ) ; if ( ! fFinalStateFlags [ curState ] ) return length ; return - 1 ; } private boolean isEqual ( QName name1 , QName name2 ) { return name1 . localpart == name2 . localpart && name1 . uri == name2 . uri ; } public int validateContentSpecial ( QName children [ ] , int offset , int length ) throws Exception { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "DFAContentModel#validateContentSpecial" ) ; if ( comparator == null ) { return validateContent ( children , offset , length ) ; } if ( length == 0 ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! no children" ) ; System . out . println ( "elemMap=" + fElemMap ) ; for ( int i = 0 ; i < fElemMap . length ; i ++ ) { int uriIndex = fElemMap [ i ] . uri ; int localpartIndex = fElemMap [ i ] . localpart ; } System . out . println ( "EOCIndex=" + fEOCIndex ) ; } return fEmptyContentIsValid ? - 1 : 0 ; } int curState = 0 ; for ( int childIndex = 0 ; childIndex < length ; childIndex ++ ) { final QName curElem = children [ offset + childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { int type = fElemMapType [ elemIndex ] & 0x0f ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( comparator . isEquivalentTo ( curElem , fElemMap [ elemIndex ] ) ) break ; } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ elemIndex ] . uri ; if ( uri == - 1 || uri == curElem . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( curElem . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ elemIndex ] . uri != curElem . uri ) { break ; } } } if ( elemIndex == fElemMapSize ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! didn't find it" ) ; System . out . println ( "curElem : " + curElem ) ; for ( int i = 0 ; i < fElemMapSize ; i ++ ) { System . out . println ( "fElemMap[" + i + "] = " + fElemMap [ i ] ) ; System . out . println ( "fElemMapType[" + i + "] = " + fElemMapType [ i ] ) ; } } return childIndex ; } curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "!!! not a legal transition" ) ; return childIndex ; } } if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "curState=" + curState + ", childCount=" + length ) ; if ( ! fFinalStateFlags [ curState ] ) return length ; return - 1 ; } public void setEquivClassComparator ( EquivClassComparator comparator ) { this . comparator = comparator ; } public int whatCanGoHere ( boolean fullyValid , InsertableElementsInfo info ) throws CMException { int curState = 0 ; for ( int childIndex = 0 ; childIndex < info . insertAt ; childIndex ++ ) { final QName curElem = info . curChildren [ childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { if ( fElemMap [ elemIndex ] . uri == curElem . uri && fElemMap [ elemIndex ] . localpart == curElem . localpart ) break ; } if ( elemIndex == fElemMapSize ) return childIndex ; curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) return childIndex ; } final int insertState = curState ; info . canHoldPCData = false ; info . isValidEOC = fFinalStateFlags [ insertState ] ; info . resultsCount = fElemMapSize ; if ( ( info . results == null ) || ( info . results . length < info . resultsCount ) ) info . results = new boolean [ info . resultsCount ] ; if ( ( info . possibleChildren == null ) || ( info . possibleChildren . length < info . resultsCount ) ) { info . possibleChildren = new QName [ info . resultsCount ] ; for ( int i = 0 ; i < info . possibleChildren . length ; i ++ ) { info . possibleChildren [ i ] = new QName ( ) ; } } for ( int index = 0 ; index < fElemMapSize ; index ++ ) { info . possibleChildren [ index ] . setValues ( fElemMap [ index ] ) ; info . results [ index ] = ( fTransTable [ insertState ] [ index ] != - 1 ) ; } if ( fullyValid ) { for ( int index = 0 ; index < info . resultsCount ; index ++ ) { if ( ! info . results [ index ] ) continue ; info . curChildren [ info . insertAt ] = info . possibleChildren [ index ] ; if ( validateContent ( info . curChildren , 0 , info . childCount ) != - 1 ) info . results [ index ] = false ; } } return - 1 ; } public ContentLeafNameTypeVector getContentLeafNameTypeVector ( ) { return fLeafNameTypeVector ; } private void buildDFA ( CMNode syntaxTree ) throws CMException { fQName . setValues ( - 1 , fEOCIndex , fEOCIndex ) ; CMLeaf nodeEOC = new CMLeaf ( fQName ) ; fHeadNode = new CMBinOp ( XMLContentSpec . CONTENTSPECNODE_SEQ , syntaxTree , nodeEOC ) ; fEOCPos = fLeafCount ; nodeEOC . setPosition ( fLeafCount ++ ) ; fLeafList = new CMLeaf [ fLeafCount ] ; fLeafListType = new int [ fLeafCount ] ; postTreeBuildInit ( fHeadNode , 0 ) ; fFollowList = new CMStateSet [ fLeafCount ] ; for ( int index = 0 ; index < fLeafCount ; index ++ ) fFollowList [ index ] = new CMStateSet ( fLeafCount ) ; calcFollowList ( fHeadNode ) ; fElemMap = new QName [ fLeafCount ] ; fElemMapType = new int [ fLeafCount ] ; fElemMapSize = 0 ; for ( int outIndex = 0 ; outIndex < fLeafCount ; outIndex ++ ) { fElemMap [ outIndex ] = new QName ( ) ; if ( ( fLeafListType [ outIndex ] & 0x0f ) != 0 ) { if ( fLeafNameTypeVector == null ) { fLeafNameTypeVector = new ContentLeafNameTypeVector ( ) ; } } final QName element = fLeafList [ outIndex ] . getElement ( ) ; int inIndex = 0 ; for ( ; inIndex < fElemMapSize ; inIndex ++ ) { if ( fDTD ) { if ( fElemMap [ inIndex ] . rawname == element . rawname ) { break ; } } else { if ( fElemMap [ inIndex ] . uri == element . uri && fElemMap [ inIndex ] . localpart == element . localpart && fElemMapType [ inIndex ] == fLeafListType [ outIndex ] ) break ; } } if ( inIndex == fElemMapSize ) { fElemMap [ fElemMapSize ] . setValues ( element ) ; fElemMapType [ fElemMapSize ] = fLeafListType [ outIndex ] ; fElemMapSize ++ ; } } if ( fLeafNameTypeVector != null ) { fLeafNameTypeVector . setValues ( fElemMap , fElemMapType , fElemMapSize ) ; } int curArraySize = fLeafCount * 4 ; CMStateSet [ ] statesToDo = new CMStateSet [ curArraySize ] ; fFinalStateFlags = new boolean [ curArraySize ] ; fTransTable = new int [ curArraySize ] [ ] ; CMStateSet setT = fHeadNode . firstPos ( ) ; int unmarkedState = 0 ; int curState = 0 ; fTransTable [ curState ] = makeDefStateList ( ) ; statesToDo [ curState ] = setT ; curState ++ ; while ( unmarkedState < curState ) { setT = statesToDo [ unmarkedState ] ; int [ ] transEntry = fTransTable [ unmarkedState ] ; fFinalStateFlags [ unmarkedState ] = setT . getBit ( fEOCPos ) ; unmarkedState ++ ; CMStateSet newSet = null ; for ( int elemIndex = 0 ; elemIndex < fElemMapSize ; elemIndex ++ ) { if ( newSet == null ) newSet = new CMStateSet ( fLeafCount ) ; else newSet . zeroBits ( ) ; for ( int leafIndex = 0 ; leafIndex < fLeafCount ; leafIndex ++ ) { if ( setT . getBit ( leafIndex ) ) { final QName leaf = fLeafList [ leafIndex ] . getElement ( ) ; final QName element = fElemMap [ elemIndex ] ; if ( fDTD ) { if ( leaf . rawname == element . rawname ) { newSet . union ( fFollowList [ leafIndex ] ) ; } } else { if ( leaf . uri == element . uri && leaf . localpart == element . localpart ) newSet . union ( fFollowList [ leafIndex ] ) ; } } } if ( ! newSet . isEmpty ( ) ) { int stateIndex = 0 ; for ( ; stateIndex < curState ; stateIndex ++ ) { if ( statesToDo [ stateIndex ] . isSameSet ( newSet ) ) break ; } if ( stateIndex == curState ) { statesToDo [ curState ] = newSet ; fTransTable [ curState ] = makeDefStateList ( ) ; curState ++ ; newSet = null ; } transEntry [ elemIndex ] = stateIndex ; if ( curState == curArraySize ) { final int newSize = ( int ) ( curArraySize * 1.5 ) ; CMStateSet [ ] newToDo = new CMStateSet [ newSize ] ; boolean [ ] newFinalFlags = new boolean [ newSize ] ; int [ ] [ ] newTransTable = new int [ newSize ] [ ] ; for ( int expIndex = 0 ; expIndex < curArraySize ; expIndex ++ ) { newToDo [ expIndex ] = statesToDo [ expIndex ] ; newFinalFlags [ expIndex ] = fFinalStateFlags [ expIndex ] ; newTransTable [ expIndex ] = fTransTable [ expIndex ] ; } curArraySize = newSize ; statesToDo = newToDo ; fFinalStateFlags = newFinalFlags ; fTransTable = newTransTable ; } } } } fEmptyContentIsValid = ( ( CMBinOp ) fHeadNode ) . getLeft ( ) . isNullable ( ) ; if ( DEBUG_VALIDATE_CONTENT ) dumpTree ( fHeadNode , 0 ) ; fHeadNode = null ; fLeafList = null ; fFollowList = null ; } private void calcFollowList ( CMNode nodeCur ) throws CMException { if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) { calcFollowList ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( CMBinOp ) nodeCur ) . getRight ( ) ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) { calcFollowList ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( CMBinOp ) nodeCur ) . getRight ( ) ) ; final CMStateSet last = ( ( CMBinOp ) nodeCur ) . getLeft ( ) . lastPos ( ) ; final CMStateSet first = ( ( CMBinOp ) nodeCur ) . getRight ( ) . firstPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { calcFollowList ( ( ( CMUniOp ) nodeCur ) . getChild ( ) ) ; final CMStateSet first = nodeCur . firstPos ( ) ; final CMStateSet last = nodeCur . lastPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) || ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) ) { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } } private void dumpTree ( CMNode nodeCur , int level ) throws CMException { for ( int index = 0 ; index < level ; index ++ ) System . out . print ( "   " ) ; int type = nodeCur . type ( ) ; if ( ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( type == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { if ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) System . out . print ( "Choice Node " ) ; else System . out . print ( "Seq Node " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( "Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; dumpTree ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) , level + 1 ) ; dumpTree ( ( ( CMBinOp ) nodeCur ) . getRight ( ) , level + 1 ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { System . out . print ( "Rep Node " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( "Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; dumpTree ( ( ( CMUniOp ) nodeCur ) . getChild ( ) , level + 1 ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { System . out . print ( "Leaf: (pos=" + ( ( CMLeaf ) nodeCur ) . getPosition ( ) + "), " + ( ( CMLeaf ) nodeCur ) . getElement ( ) + "(elemIndex=" + ( ( CMLeaf ) nodeCur ) . getElement ( ) + ") " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( " Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; } else { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } } private int [ ] makeDefStateList ( ) { int [ ] retArray = new int [ fElemMapSize ] ; for ( int index = 0 ; index < fElemMapSize ; index ++ ) retArray [ index ] = - 1 ; return retArray ; } private int postTreeBuildInit ( CMNode nodeCur , int curIndex ) throws CMException { nodeCur . setMaxStates ( fLeafCount ) ; if ( ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY || ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL || ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { QName qname = new QName ( - 1 , - 1 , - 1 , ( ( CMAny ) nodeCur ) . getURI ( ) ) ; fLeafList [ curIndex ] = new CMLeaf ( qname , ( ( CMAny ) nodeCur ) . getPosition ( ) ) ; fLeafListType [ curIndex ] = nodeCur . type ( ) ; curIndex ++ ; } else if ( ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { curIndex = postTreeBuildInit ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) , curIndex ) ; curIndex = postTreeBuildInit ( ( ( CMBinOp ) nodeCur ) . getRight ( ) , curIndex ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { curIndex = postTreeBuildInit ( ( ( CMUniOp ) nodeCur ) . getChild ( ) , curIndex ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { final QName node = ( ( CMLeaf ) nodeCur ) . getElement ( ) ; if ( node . localpart != fEpsilonIndex ) { fLeafList [ curIndex ] = ( CMLeaf ) nodeCur ; fLeafListType [ curIndex ] = XMLContentSpec . CONTENTSPECNODE_LEAF ; curIndex ++ ; } } else { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } return curIndex ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLScriptElementImpl extends HTMLElementImpl implements HTMLScriptElement { public String getText ( ) { Node child ; String text ; child = getFirstChild ( ) ; text = "" ; while ( child != null ) { if ( child instanceof Text ) text = text + ( ( Text ) child ) . getData ( ) ; child = child . getNextSibling ( ) ; } return text ; } public void setText ( String text ) { Node child ; Node next ; child = getFirstChild ( ) ; while ( child != null ) { next = child . getNextSibling ( ) ; removeChild ( child ) ; child = next ; } insertBefore ( getOwnerDocument ( ) . createTextNode ( text ) , getFirstChild ( ) ) ; } public String getHtmlFor ( ) { return getAttribute ( "for" ) ; } public void setHtmlFor ( String htmlFor ) { setAttribute ( "for" , htmlFor ) ; } public String getEvent ( ) { return getAttribute ( "event" ) ; } public void setEvent ( String event ) { setAttribute ( "event" , event ) ; } public String getCharset ( ) { return getAttribute ( "charset" ) ; } public void setCharset ( String charset ) { setAttribute ( "charset" , charset ) ; } public boolean getDefer ( ) { return getBinary ( "defer" ) ; } public void setDefer ( boolean defer ) { setAttribute ( "defer" , defer ) ; } public String getSrc ( ) { return getAttribute ( "src" ) ; } public void setSrc ( String src ) { setAttribute ( "src" , src ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } public void setType ( String type ) { setAttribute ( "type" , type ) ; } public HTMLScriptElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLDocumentScanner ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . readers . DefaultEntityHandler ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . ChunkyCharArray ; import org . apache . xerces . utils . Hash2intTable ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . parsers . DOMParser ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . InputSource ; import org . xml . sax . EntityResolver ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xerces . validators . dtd . DTDGrammar ; import org . apache . xerces . validators . schema . EquivClassComparator ; import org . apache . xerces . validators . schema . SchemaGrammar ; import org . apache . xerces . validators . schema . SchemaMessageProvider ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . schema . TraverseSchema ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . validators . datatype . StateMessageDatatype ; import org . apache . xerces . validators . datatype . IDREFDatatypeValidator ; import org . apache . xerces . validators . datatype . IDDatatypeValidator ; import org . apache . xerces . validators . datatype . ENTITYDatatypeValidator ; public final class XMLValidator implements DefaultEntityHandler . EventHandler , XMLEntityHandler . CharDataHandler , XMLDocumentScanner . EventHandler , NamespacesScope . NamespacesHandler { private static final boolean PRINT_EXCEPTION_STACK_TRACE = false ; private static final boolean DEBUG_PRINT_ATTRIBUTES = false ; private static final boolean DEBUG_PRINT_CONTENT = false ; private static final boolean DEBUG_SCHEMA_VALIDATION = false ; private static final boolean DEBUG_ELEMENT_CHILDREN = false ; private static final int CHUNK_SHIFT = 8 ; private static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; private static final int CHUNK_MASK = CHUNK_SIZE - 1 ; private static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; private Hashtable fIdDefs = null ; private StateMessageDatatype fStoreIDRef = new StateMessageDatatype ( ) { private Hashtable fIdDefs ; public Object getDatatypeObject ( ) { return ( Object ) fIdDefs ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_STORE ; } public void setDatatypeObject ( Object data ) { fIdDefs = ( Hashtable ) data ; } } ; private StateMessageDatatype fResetID = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDDatatypeValidator . ID_CLEAR ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fResetIDRef = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_CLEAR ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fValidateIDRef = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_VALIDATE ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fValidateENTITYMsg = new StateMessageDatatype ( ) { private Object packagedMessage = null ; public Object getDatatypeObject ( ) { return packagedMessage ; } public int getDatatypeState ( ) { return ENTITYDatatypeValidator . ENTITY_INITIALIZE ; } public void setDatatypeObject ( Object data ) { packagedMessage = data ; } } ; private AttributeValidator fAttValidatorNOTATION = new AttValidatorNOTATION ( ) ; private AttributeValidator fAttValidatorENUMERATION = new AttValidatorENUMERATION ( ) ; private AttributeValidator fAttValidatorDATATYPE = null ; StringPool fStringPool = null ; boolean fValidating = false ; boolean fInElementContent = false ; int fStandaloneReader = - 1 ; private boolean fValidationEnabled = false ; private boolean fDynamicValidation = false ; private boolean fSchemaValidation = true ; private boolean fValidationEnabledByDynamic = false ; private boolean fDynamicDisabledByValidation = false ; private boolean fWarningOnDuplicateAttDef = false ; private boolean fWarningOnUndeclaredElements = false ; private boolean fLoadDTDGrammar = true ; private int fDeclaration [ ] ; private XMLErrorReporter fErrorReporter = null ; private DefaultEntityHandler fEntityHandler = null ; private QName fCurrentElement = new QName ( ) ; private ContentLeafNameTypeVector [ ] fContentLeafStack = new ContentLeafNameTypeVector [ 8 ] ; private int [ ] fValidationFlagStack = new int [ 8 ] ; private int [ ] fScopeStack = new int [ 8 ] ; private int [ ] fGrammarNameSpaceIndexStack = new int [ 8 ] ; private int [ ] fElementEntityStack = new int [ 8 ] ; private int [ ] fElementIndexStack = new int [ 8 ] ; private int [ ] fContentSpecTypeStack = new int [ 8 ] ; private static final int sizeQNameParts = 8 ; private QName [ ] fElementQNamePartsStack = new QName [ sizeQNameParts ] ; private QName [ ] fElementChildren = new QName [ 32 ] ; private int fElementChildrenLength = 0 ; private int [ ] fElementChildrenOffsetStack = new int [ 32 ] ; private int fElementDepth = - 1 ; private boolean fNamespacesEnabled = false ; private NamespacesScope fNamespacesScope = null ; private int fNamespacesPrefix = - 1 ; private QName fRootElement = new QName ( ) ; private int fAttrListHandle = - 1 ; private int fCurrentElementEntity = - 1 ; private int fCurrentElementIndex = - 1 ; private int fCurrentContentSpecType = - 1 ; private boolean fSeenDoctypeDecl = false ; private final int TOP_LEVEL_SCOPE = - 1 ; private int fCurrentScope = TOP_LEVEL_SCOPE ; private int fCurrentSchemaURI = - 1 ; private int fEmptyURI = - 1 ; private int fXsiPrefix = - 1 ; private int fXsiURI = - 2 ; private int fXsiTypeAttValue = - 1 ; private DatatypeValidator fXsiTypeValidator = null ; private Grammar fGrammar = null ; private int fGrammarNameSpaceIndex = - 1 ; private GrammarResolver fGrammarResolver = null ; private boolean fScanningDTD = false ; private XMLDocumentScanner fDocumentScanner = null ; private boolean fCalledStartDocument = false ; private XMLDocumentHandler fDocumentHandler = null ; private XMLDocumentHandler . DTDHandler fDTDHandler = null ; private boolean fSeenRootElement = false ; private XMLAttrList fAttrList = null ; private int fXMLLang = - 1 ; private LocatorImpl fAttrNameLocator = null ; private boolean fCheckedForSchema = false ; private boolean fDeclsAreExternal = false ; private StringPool . CharArrayRange fCurrentElementCharArrayRange = null ; private char [ ] fCharRefData = null ; private boolean fSendCharDataAsCharArray = false ; private boolean fBufferDatatype = false ; private StringBuffer fDatatypeBuffer = new StringBuffer ( ) ; private QName fTempQName = new QName ( ) ; private XMLAttributeDecl fTempAttDecl = new XMLAttributeDecl ( ) ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; private boolean fGrammarIsDTDGrammar = false ; private boolean fGrammarIsSchemaGrammar = false ; private boolean fNeedValidationOff = false ; private int fEMPTYSymbol = - 1 ; private int fANYSymbol = - 1 ; private int fMIXEDSymbol = - 1 ; private int fCHILDRENSymbol = - 1 ; private int fCDATASymbol = - 1 ; private int fIDSymbol = - 1 ; private int fIDREFSymbol = - 1 ; private int fIDREFSSymbol = - 1 ; private int fENTITYSymbol = - 1 ; private int fENTITIESSymbol = - 1 ; private int fNMTOKENSymbol = - 1 ; private int fNMTOKENSSymbol = - 1 ; private int fNOTATIONSymbol = - 1 ; private int fENUMERATIONSymbol = - 1 ; private int fREQUIREDSymbol = - 1 ; private int fFIXEDSymbol = - 1 ; private int fDATATYPESymbol = - 1 ; private int fEpsilonIndex = - 1 ; private DatatypeValidatorFactoryImpl fDataTypeReg = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; private DatatypeValidator fValID = this . fDataTypeReg . getDatatypeValidator ( "ID" ) ; private DatatypeValidator fValIDRef = this . fDataTypeReg . getDatatypeValidator ( "IDREF" ) ; private DatatypeValidator fValIDRefs = this . fDataTypeReg . getDatatypeValidator ( "IDREFS" ) ; private DatatypeValidator fValENTITY = this . fDataTypeReg . getDatatypeValidator ( "ENTITY" ) ; private DatatypeValidator fValENTITIES = this . fDataTypeReg . getDatatypeValidator ( "ENTITIES" ) ; private DatatypeValidator fValNMTOKEN = this . fDataTypeReg . getDatatypeValidator ( "NMTOKEN" ) ; private DatatypeValidator fValNMTOKENS = this . fDataTypeReg . getDatatypeValidator ( "NMTOKENS" ) ; private DatatypeValidator fValNOTATION = this . fDataTypeReg . getDatatypeValidator ( "NOTATION" ) ; public XMLValidator ( StringPool stringPool , XMLErrorReporter errorReporter , DefaultEntityHandler entityHandler , XMLDocumentScanner documentScanner ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fEntityHandler = entityHandler ; fDocumentScanner = documentScanner ; fEmptyURI = fStringPool . addSymbol ( "" ) ; fXsiURI = fStringPool . addSymbol ( SchemaSymbols . URI_XSI ) ; fAttrList = new XMLAttrList ( fStringPool ) ; entityHandler . setEventHandler ( this ) ; entityHandler . setCharDataHandler ( this ) ; fDocumentScanner . setEventHandler ( this ) ; for ( int i = 0 ; i < sizeQNameParts ; i ++ ) { fElementQNamePartsStack [ i ] = new QName ( ) ; } init ( ) ; } public void setGrammarResolver ( GrammarResolver grammarResolver ) { fGrammarResolver = grammarResolver ; } public void initHandlers ( boolean sendCharDataAsCharArray , XMLDocumentHandler docHandler , XMLDocumentHandler . DTDHandler dtdHandler ) { fSendCharDataAsCharArray = sendCharDataAsCharArray ; fEntityHandler . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; fDocumentHandler = docHandler ; fDTDHandler = dtdHandler ; } public void resetOrCopy ( StringPool stringPool ) throws Exception { fAttrList = new XMLAttrList ( stringPool ) ; resetCommon ( stringPool ) ; } public void reset ( StringPool stringPool ) throws Exception { fAttrList . reset ( stringPool ) ; resetCommon ( stringPool ) ; } public void setValidationEnabled ( boolean flag ) throws Exception { fValidationEnabled = flag ; fValidationEnabledByDynamic = false ; if ( fValidationEnabled ) { if ( fDynamicDisabledByValidation ) { fDynamicValidation = true ; fDynamicDisabledByValidation = false ; } } else if ( fDynamicValidation ) { fDynamicValidation = false ; fDynamicDisabledByValidation = true ; } fValidating = fValidationEnabled ; } public boolean getValidationEnabled ( ) { return fValidationEnabled ; } public void setSchemaValidationEnabled ( boolean flag ) { fSchemaValidation = flag ; } public boolean getSchemaValidationEnabled ( ) { return fSchemaValidation ; } public void setDynamicValidationEnabled ( boolean flag ) throws Exception { fDynamicValidation = flag ; fDynamicDisabledByValidation = false ; if ( ! fDynamicValidation ) { if ( fValidationEnabledByDynamic ) { fValidationEnabled = false ; fValidationEnabledByDynamic = false ; } } else if ( ! fValidationEnabled ) { fValidationEnabled = true ; fValidationEnabledByDynamic = true ; } fValidating = fValidationEnabled ; } public boolean getDynamicValidationEnabled ( ) { return fDynamicValidation ; } public void setLoadDTDGrammar ( boolean loadDG ) { if ( fValidating ) { fLoadDTDGrammar = true ; } else { fLoadDTDGrammar = loadDG ; } } public boolean getLoadDTDGrammar ( ) { return fLoadDTDGrammar ; } public void setNamespacesEnabled ( boolean flag ) { fNamespacesEnabled = flag ; } public boolean getNamespacesEnabled ( ) { return fNamespacesEnabled ; } public void setWarningOnDuplicateAttDef ( boolean flag ) { fWarningOnDuplicateAttDef = flag ; } public boolean getWarningOnDuplicateAttDef ( ) { return fWarningOnDuplicateAttDef ; } public void setWarningOnUndeclaredElements ( boolean flag ) { fWarningOnUndeclaredElements = flag ; } public boolean getWarningOnUndeclaredElements ( ) { return fWarningOnUndeclaredElements ; } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { fDocumentHandler . startEntityReference ( entityName , entityType , entityContext ) ; } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { fDocumentHandler . endEntityReference ( entityName , entityType , entityContext ) ; } public void sendEndOfInputNotifications ( int entityName , boolean moreToFollow ) throws Exception { fDocumentScanner . endOfInput ( entityName , moreToFollow ) ; } public void sendReaderChangeNotifications ( XMLEntityHandler . EntityReader reader , int readerId ) throws Exception { fDocumentScanner . readerChange ( reader , readerId ) ; } public boolean externalEntityStandaloneCheck ( ) { return ( fStandaloneReader != - 1 && fValidating ) ; } public boolean getValidating ( ) { return fValidating ; } public void processCharacters ( char [ ] chars , int offset , int length ) throws Exception { if ( fValidating ) { if ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } if ( fBufferDatatype ) { fDatatypeBuffer . append ( chars , offset , length ) ; } } fDocumentHandler . characters ( chars , offset , length ) ; } public void processCharacters ( int data ) throws Exception { if ( fValidating ) { if ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } if ( fBufferDatatype ) { fDatatypeBuffer . append ( fStringPool . toString ( data ) ) ; } } fDocumentHandler . characters ( data ) ; } public void processWhitespace ( char [ ] chars , int offset , int length ) throws Exception { if ( fInElementContent ) { if ( fStandaloneReader != - 1 && fValidating && getElementDeclIsExternal ( fCurrentElementIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION ) ; } fDocumentHandler . ignorableWhitespace ( chars , offset , length ) ; } else { if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } fDocumentHandler . characters ( chars , offset , length ) ; } } public void processWhitespace ( int data ) throws Exception { if ( fInElementContent ) { if ( fStandaloneReader != - 1 && fValidating && getElementDeclIsExternal ( fCurrentElementIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION ) ; } fDocumentHandler . ignorableWhitespace ( data ) ; } else { if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } fDocumentHandler . characters ( data ) ; } } public void scanElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( ! fNamespacesEnabled ) { element . clear ( ) ; element . localpart = entityReader . scanName ( fastchar ) ; element . rawname = element . localpart ; } else { entityReader . scanQName ( fastchar , element ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } public boolean scanExpectedElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( fCurrentElementCharArrayRange == null ) { fCurrentElementCharArrayRange = fStringPool . createCharArrayRange ( ) ; } fStringPool . getCharArrayRange ( fCurrentElement . rawname , fCurrentElementCharArrayRange ) ; return entityReader . scanExpectedName ( fastchar , fCurrentElementCharArrayRange ) ; } public void scanAttributeName ( XMLEntityHandler . EntityReader entityReader , QName element , QName attribute ) throws Exception { if ( ! fSeenRootElement ) { fSeenRootElement = true ; rootElementSpecified ( element ) ; fStringPool . resetShuffleCount ( ) ; } if ( ! fNamespacesEnabled ) { attribute . clear ( ) ; attribute . localpart = entityReader . scanName ( '=' ) ; attribute . rawname = attribute . localpart ; } else { entityReader . scanQName ( '=' , attribute ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } public void callStartDocument ( ) throws Exception { if ( ! fCalledStartDocument ) { fDocumentHandler . startDocument ( ) ; fCalledStartDocument = true ; } } public void callEndDocument ( ) throws Exception { if ( fCalledStartDocument ) { fDocumentHandler . endDocument ( ) ; } } public void callXMLDecl ( int version , int encoding , int standalone ) throws Exception { fDocumentHandler . xmlDecl ( version , encoding , standalone ) ; } public void callStandaloneIsYes ( ) throws Exception { fStandaloneReader = fEntityHandler . getReaderId ( ) ; } public void callTextDecl ( int version , int encoding ) throws Exception { fDocumentHandler . textDecl ( version , encoding ) ; } public void element ( QName element ) throws Exception { fAttrListHandle = - 1 ; } public boolean attribute ( QName element , QName attrName , int attrValue ) throws Exception { if ( fAttrListHandle == - 1 ) { fAttrListHandle = fAttrList . startAttrList ( ) ; } return fAttrList . addAttr ( attrName , attrValue , fCDATASymbol , true , true ) == - 1 ; } public void callStartElement ( QName element ) throws Exception { if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "\n=======StartElement : " + fStringPool . toString ( element . localpart ) ) ; if ( ! fSeenRootElement ) { fSeenRootElement = true ; rootElementSpecified ( element ) ; fStringPool . resetShuffleCount ( ) ; } if ( fGrammar != null && fGrammarIsDTDGrammar ) { fAttrListHandle = addDTDDefaultAttributes ( element , fAttrList , fAttrListHandle , fValidating , fStandaloneReader != - 1 ) ; } fCheckedForSchema = true ; if ( fNamespacesEnabled ) { bindNamespacesToElementAndAttributes ( element , fAttrList ) ; } validateElementAndAttributes ( element , fAttrList ) ; if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; } fDocumentHandler . startElement ( element , fAttrList , fAttrListHandle ) ; fAttrListHandle = - 1 ; fElementDepth ++ ; if ( fValidating ) { if ( fElementChildrenOffsetStack . length < fElementDepth ) { int newarray [ ] = new int [ fElementChildrenOffsetStack . length * 2 ] ; System . arraycopy ( fElementChildrenOffsetStack , 0 , newarray , 0 , fElementChildrenOffsetStack . length ) ; fElementChildrenOffsetStack = newarray ; } fElementChildrenOffsetStack [ fElementDepth ] = fElementChildrenLength ; if ( fElementChildren . length <= fElementChildrenLength ) { QName [ ] newarray = new QName [ fElementChildrenLength * 2 ] ; System . arraycopy ( fElementChildren , 0 , newarray , 0 , fElementChildren . length ) ; fElementChildren = newarray ; } QName qname = fElementChildren [ fElementChildrenLength ] ; if ( qname == null ) { for ( int i = fElementChildrenLength ; i < fElementChildren . length ; i ++ ) { fElementChildren [ i ] = new QName ( ) ; } qname = fElementChildren [ fElementChildrenLength ] ; } qname . setValues ( element ) ; fElementChildrenLength ++ ; if ( DEBUG_ELEMENT_CHILDREN ) { printChildren ( ) ; printStack ( ) ; } } ensureStackCapacity ( fElementDepth ) ; fCurrentElement . setValues ( element ) ; fCurrentElementEntity = fEntityHandler . getReaderId ( ) ; fElementQNamePartsStack [ fElementDepth ] . setValues ( fCurrentElement ) ; fElementEntityStack [ fElementDepth ] = fCurrentElementEntity ; fElementIndexStack [ fElementDepth ] = fCurrentElementIndex ; fContentSpecTypeStack [ fElementDepth ] = fCurrentContentSpecType ; if ( fNeedValidationOff ) { fValidating = false ; fNeedValidationOff = false ; } if ( fValidating && fGrammarIsSchemaGrammar ) { pushContentLeafStack ( ) ; } fValidationFlagStack [ fElementDepth ] = fValidating ? 0 : - 1 ; fScopeStack [ fElementDepth ] = fCurrentScope ; fGrammarNameSpaceIndexStack [ fElementDepth ] = fGrammarNameSpaceIndex ; } private void pushContentLeafStack ( ) throws Exception { int contentType = getContentSpecType ( fCurrentElementIndex ) ; if ( contentType == XMLElementDecl . TYPE_CHILDREN ) { XMLContentModel cm = getElementContentModel ( fCurrentElementIndex ) ; ContentLeafNameTypeVector cv = cm . getContentLeafNameTypeVector ( ) ; if ( cm != null ) { fContentLeafStack [ fElementDepth ] = cv ; } } } private void ensureStackCapacity ( int newElementDepth ) { if ( newElementDepth == fElementQNamePartsStack . length ) { int [ ] newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fScopeStack , 0 , newStack , 0 , newElementDepth ) ; fScopeStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fGrammarNameSpaceIndexStack , 0 , newStack , 0 , newElementDepth ) ; fGrammarNameSpaceIndexStack = newStack ; QName [ ] newStackOfQueue = new QName [ newElementDepth * 2 ] ; System . arraycopy ( this . fElementQNamePartsStack , 0 , newStackOfQueue , 0 , newElementDepth ) ; fElementQNamePartsStack = newStackOfQueue ; QName qname = fElementQNamePartsStack [ newElementDepth ] ; if ( qname == null ) { for ( int i = newElementDepth ; i < fElementQNamePartsStack . length ; i ++ ) { fElementQNamePartsStack [ i ] = new QName ( ) ; } } newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fElementEntityStack , 0 , newStack , 0 , newElementDepth ) ; fElementEntityStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fElementIndexStack , 0 , newStack , 0 , newElementDepth ) ; fElementIndexStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fContentSpecTypeStack , 0 , newStack , 0 , newElementDepth ) ; fContentSpecTypeStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fValidationFlagStack , 0 , newStack , 0 , newElementDepth ) ; fValidationFlagStack = newStack ; ContentLeafNameTypeVector [ ] newStackV = new ContentLeafNameTypeVector [ newElementDepth * 2 ] ; System . arraycopy ( fContentLeafStack , 0 , newStackV , 0 , newElementDepth ) ; fContentLeafStack = newStackV ; } } public void callEndElement ( int readerId ) throws Exception { if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "=======EndElement : " + fStringPool . toString ( fCurrentElement . localpart ) + "\n" ) ; int prefixIndex = fCurrentElement . prefix ; int elementType = fCurrentElement . rawname ; if ( fCurrentElementEntity != readerId ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ELEMENT_ENTITY_MISMATCH , XMLMessages . P78_NOT_WELLFORMED , new Object [ ] { fStringPool . toString ( elementType ) } , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } fElementDepth -- ; if ( fValidating ) { int elementIndex = fCurrentElementIndex ; if ( elementIndex != - 1 && fCurrentContentSpecType != - 1 ) { QName children [ ] = fElementChildren ; int childrenOffset = fElementChildrenOffsetStack [ fElementDepth + 1 ] + 1 ; int childrenLength = fElementChildrenLength - childrenOffset ; if ( DEBUG_ELEMENT_CHILDREN ) { System . out . println ( "endElement(" + fStringPool . toString ( fCurrentElement . rawname ) + ')' ) ; System . out . println ( "fCurrentContentSpecType : " + fCurrentContentSpecType ) ; System . out . print ( "offset: " ) ; System . out . print ( childrenOffset ) ; System . out . print ( ", length: " ) ; System . out . print ( childrenLength ) ; System . out . println ( ) ; printChildren ( ) ; printStack ( ) ; } int result = checkContent ( elementIndex , children , childrenOffset , childrenLength ) ; if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "!!!!!!!!In XMLValidator, the return value from checkContent : " + result ) ; if ( result != - 1 ) { int majorCode = result != childrenLength ? XMLMessages . MSG_CONTENT_INVALID : XMLMessages . MSG_CONTENT_INCOMPLETE ; fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; if ( fTempElementDecl . type == XMLElementDecl . TYPE_EMPTY ) { reportRecoverableXMLError ( majorCode , 0 , fStringPool . toString ( elementType ) , "EMPTY" ) ; } else reportRecoverableXMLError ( majorCode , 0 , fStringPool . toString ( elementType ) , XMLContentSpec . toString ( fGrammar , fStringPool , fTempElementDecl . contentSpecIndex ) ) ; } } fElementChildrenLength = fElementChildrenOffsetStack [ fElementDepth + 1 ] + 1 ; } fDocumentHandler . endElement ( fCurrentElement ) ; if ( fNamespacesEnabled ) { fNamespacesScope . decreaseDepth ( ) ; } if ( fElementDepth < - 1 ) { throw new RuntimeException ( "FWK008 Element stack underflow" ) ; } if ( fElementDepth < 0 ) { fCurrentElement . clear ( ) ; fCurrentElementEntity = - 1 ; fCurrentElementIndex = - 1 ; fCurrentContentSpecType = - 1 ; fInElementContent = false ; if ( fValidating ) { try { this . fValIDRef . validate ( null , this . fValidateIDRef ) ; this . fValIDRefs . validate ( null , this . fValidateIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , ex . getMessage ( ) ) ; } } try { this . fValID . validate ( null , this . fResetID ) ; this . fValIDRef . validate ( null , this . fResetIDRef ) ; this . fValIDRefs . validate ( null , this . fResetIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error re-Initializing: ID,IDRef,IDRefs pools" ) ; } return ; } fCurrentElement . prefix = - 1 ; if ( fNamespacesEnabled ) { fCurrentElement . localpart = fElementQNamePartsStack [ fElementDepth ] . localpart ; } else { fCurrentElement . localpart = fElementQNamePartsStack [ fElementDepth ] . rawname ; } fCurrentElement . rawname = fElementQNamePartsStack [ fElementDepth ] . rawname ; fCurrentElement . uri = fElementQNamePartsStack [ fElementDepth ] . uri ; fCurrentElement . prefix = fElementQNamePartsStack [ fElementDepth ] . prefix ; fCurrentElementEntity = fElementEntityStack [ fElementDepth ] ; fCurrentElementIndex = fElementIndexStack [ fElementDepth ] ; fCurrentContentSpecType = fContentSpecTypeStack [ fElementDepth ] ; fValidating = fValidationFlagStack [ fElementDepth ] == 0 ? true : false ; fCurrentScope = fScopeStack [ fElementDepth ] ; if ( fGrammarNameSpaceIndex != fGrammarNameSpaceIndexStack [ fElementDepth ] ) { fGrammarNameSpaceIndex = fGrammarNameSpaceIndexStack [ fElementDepth ] ; if ( fValidating && fGrammarIsSchemaGrammar ) if ( ! switchGrammar ( fGrammarNameSpaceIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fGrammarNameSpaceIndex ) + " , can not found" ) ; } } if ( fValidating ) { fBufferDatatype = false ; } fInElementContent = ( fCurrentContentSpecType == XMLElementDecl . TYPE_CHILDREN ) ; } public void callStartCDATA ( ) throws Exception { fDocumentHandler . startCDATA ( ) ; } public void callEndCDATA ( ) throws Exception { fDocumentHandler . endCDATA ( ) ; } public void callCharacters ( int ch ) throws Exception { if ( fCharRefData == null ) { fCharRefData = new char [ 2 ] ; } int count = ( ch < 0x10000 ) ? 1 : 2 ; if ( count == 1 ) { fCharRefData [ 0 ] = ( char ) ch ; } else { fCharRefData [ 0 ] = ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; fCharRefData [ 1 ] = ( char ) ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; } if ( fValidating && ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) ) { charDataInContent ( ) ; } if ( fSendCharDataAsCharArray ) { fDocumentHandler . characters ( fCharRefData , 0 , count ) ; } else { int index = fStringPool . addString ( new String ( fCharRefData , 0 , count ) ) ; fDocumentHandler . characters ( index ) ; } } public void callProcessingInstruction ( int target , int data ) throws Exception { fDocumentHandler . processingInstruction ( target , data ) ; } public void callComment ( int comment ) throws Exception { fDocumentHandler . comment ( comment ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { fDocumentHandler . startNamespaceDeclScope ( prefix , uri ) ; } public void endNamespaceDeclScope ( int prefix ) throws Exception { fDocumentHandler . endNamespaceDeclScope ( prefix ) ; } public void setRootElementType ( QName rootElement ) { fRootElement . setValues ( rootElement ) ; } private boolean getElementDeclIsExternal ( int elementIndex ) { if ( fGrammarIsDTDGrammar ) { return ( ( DTDGrammar ) fGrammar ) . getElementDeclIsExternal ( elementIndex ) ; } return false ; } public int getContentSpecType ( int elementIndex ) { int contentSpecType = - 1 ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentSpecType = fTempElementDecl . type ; } } return contentSpecType ; } public int getContentSpecHandle ( int elementIndex ) { int contentSpecHandle = - 1 ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentSpecHandle = fTempElementDecl . contentSpecIndex ; } } return contentSpecHandle ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode ) throws Exception { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , null , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 ) throws Exception { Object [ ] args = { string1 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 , int stringIndex2 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) , fStringPool . toString ( stringIndex2 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 ) throws Exception { Object [ ] args = { string1 , string2 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 , String string3 ) throws Exception { Object [ ] args = { string1 , string2 , string3 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected int whatCanGoHere ( int elementIndex , boolean fullyValid , InsertableElementsInfo info ) throws Exception { if ( info . insertAt > info . childCount || info . curChildren == null || info . childCount < 1 || info . childCount > info . curChildren . length ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . VAL_WCGHI , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } int retVal = 0 ; try { final XMLContentModel cmElem = getElementContentModel ( elementIndex ) ; retVal = cmElem . whatCanGoHere ( fullyValid , info ) ; } catch ( CMException excToCatch ) { int majorCode = excToCatch . getErrorCode ( ) ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , majorCode , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; throw excToCatch ; } return retVal ; } protected boolean getAttDefIsExternal ( QName element , QName attribute ) { int attDefIndex = getAttDef ( element , attribute ) ; if ( fGrammarIsDTDGrammar ) { return ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attDefIndex ) ; } return false ; } private boolean usingStandaloneReader ( ) { return fStandaloneReader == - 1 || fEntityHandler . getReaderId ( ) == fStandaloneReader ; } private LocatorImpl getLocatorImpl ( LocatorImpl fillin ) { Locator here = fErrorReporter . getLocator ( ) ; if ( fillin == null ) return new LocatorImpl ( here ) ; fillin . setPublicId ( here . getPublicId ( ) ) ; fillin . setSystemId ( here . getSystemId ( ) ) ; fillin . setLineNumber ( here . getLineNumber ( ) ) ; fillin . setColumnNumber ( here . getColumnNumber ( ) ) ; return fillin ; } private void poolReset ( ) { try { this . fValID . validate ( null , this . fResetID ) ; this . fValIDRef . validate ( null , this . fResetIDRef ) ; this . fValIDRefs . validate ( null , this . fResetIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error re-Initializing: ID,IDRef,IDRefs pools" ) ; } } private void resetCommon ( StringPool stringPool ) throws Exception { fStringPool = stringPool ; fValidating = fValidationEnabled ; fValidationEnabledByDynamic = false ; fDynamicDisabledByValidation = false ; poolReset ( ) ; fCalledStartDocument = false ; fStandaloneReader = - 1 ; fElementChildrenLength = 0 ; fElementDepth = - 1 ; fSeenRootElement = false ; fSeenDoctypeDecl = false ; fNamespacesScope = null ; fNamespacesPrefix = - 1 ; fRootElement . clear ( ) ; fAttrListHandle = - 1 ; fCheckedForSchema = false ; fCurrentScope = TOP_LEVEL_SCOPE ; fCurrentSchemaURI = - 1 ; fEmptyURI = - 1 ; fXsiPrefix = - 1 ; fXsiTypeValidator = null ; fGrammar = null ; fGrammarNameSpaceIndex = - 1 ; if ( fGrammarResolver != null ) { fGrammarResolver . clearGrammarResolver ( ) ; } fGrammarIsDTDGrammar = false ; fGrammarIsSchemaGrammar = false ; init ( ) ; } private void init ( ) { fEmptyURI = fStringPool . addSymbol ( "" ) ; fXsiURI = fStringPool . addSymbol ( SchemaSymbols . URI_XSI ) ; fEMPTYSymbol = fStringPool . addSymbol ( "EMPTY" ) ; fANYSymbol = fStringPool . addSymbol ( "ANY" ) ; fMIXEDSymbol = fStringPool . addSymbol ( "MIXED" ) ; fCHILDRENSymbol = fStringPool . addSymbol ( "CHILDREN" ) ; fCDATASymbol = fStringPool . addSymbol ( "CDATA" ) ; fIDSymbol = fStringPool . addSymbol ( "ID" ) ; fIDREFSymbol = fStringPool . addSymbol ( "IDREF" ) ; fIDREFSSymbol = fStringPool . addSymbol ( "IDREFS" ) ; fENTITYSymbol = fStringPool . addSymbol ( "ENTITY" ) ; fENTITIESSymbol = fStringPool . addSymbol ( "ENTITIES" ) ; fNMTOKENSymbol = fStringPool . addSymbol ( "NMTOKEN" ) ; fNMTOKENSSymbol = fStringPool . addSymbol ( "NMTOKENS" ) ; fNOTATIONSymbol = fStringPool . addSymbol ( "NOTATION" ) ; fENUMERATIONSymbol = fStringPool . addSymbol ( "ENUMERATION" ) ; fREQUIREDSymbol = fStringPool . addSymbol ( "#REQUIRED" ) ; fFIXEDSymbol = fStringPool . addSymbol ( "#FIXED" ) ; fDATATYPESymbol = fStringPool . addSymbol ( "<<datatype>>" ) ; fEpsilonIndex = fStringPool . addSymbol ( "<<CMNODE_EPSILON>>" ) ; fXMLLang = fStringPool . addSymbol ( "xml:lang" ) ; try { Object [ ] packageArgsEntityVal = { ( Object ) this . fEntityHandler , ( Object ) this . fStringPool } ; fValidateENTITYMsg . setDatatypeObject ( ( Object ) packageArgsEntityVal ) ; fValENTITIES . validate ( null , fValidateENTITYMsg ) ; fValENTITY . validate ( null , fValidateENTITYMsg ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } private int addDefaultAttributes ( int elementIndex , XMLAttrList attrList , int attrIndex , boolean validationEnabled , boolean standalone ) throws Exception { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; int elementNameIndex = fTempElementDecl . name . localpart ; int attlistIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int firstCheck = attrIndex ; int lastCheck = - 1 ; while ( attlistIndex != - 1 ) { fGrammar . getAttributeDecl ( attlistIndex , fTempAttDecl ) ; int attPrefix = fTempAttDecl . name . prefix ; int attName = fTempAttDecl . name . localpart ; int attType = attributeTypeName ( fTempAttDecl ) ; int attDefType = fTempAttDecl . defaultType ; int attValue = - 1 ; if ( fTempAttDecl . defaultValue != null ) { attValue = fStringPool . addSymbol ( fTempAttDecl . defaultValue ) ; } boolean specified = false ; boolean required = attDefType == XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; if ( firstCheck != - 1 ) { boolean cdata = attType == fCDATASymbol ; if ( ! cdata || required || attValue != - 1 ) { int i = attrList . getFirstAttr ( firstCheck ) ; while ( i != - 1 && ( lastCheck == - 1 || i <= lastCheck ) ) { if ( ( fGrammarIsDTDGrammar && ( attrList . getAttrName ( i ) == fTempAttDecl . name . rawname ) ) || ( fStringPool . equalNames ( attrList . getAttrLocalpart ( i ) , attName ) && fStringPool . equalNames ( attrList . getAttrURI ( i ) , fTempAttDecl . name . uri ) ) ) { if ( validationEnabled && attDefType == XMLAttributeDecl . DEFAULT_TYPE_FIXED ) { int alistValue = attrList . getAttValue ( i ) ; if ( alistValue != attValue && ! fStringPool . toString ( alistValue ) . equals ( fStringPool . toString ( attValue ) ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) , fStringPool . toString ( alistValue ) , fStringPool . toString ( attValue ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_FIXED_ATTVALUE_INVALID , XMLMessages . VC_FIXED_ATTRIBUTE_DEFAULT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } specified = true ; break ; } i = attrList . getNextAttr ( i ) ; } } } if ( ! specified ) { if ( required ) { if ( validationEnabled ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_REQUIRED_ATTRIBUTE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else if ( attValue != - 1 ) { if ( validationEnabled && standalone ) if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attlistIndex ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( attType == fIDREFSymbol ) { this . fValIDRef . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } else if ( attType == fIDREFSSymbol ) { this . fValIDRefs . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } if ( attrIndex == - 1 ) { attrIndex = attrList . startAttrList ( ) ; } fTempQName . setValues ( attPrefix , attName , attName , fTempAttDecl . name . uri ) ; int newAttr = attrList . addAttr ( fTempQName , attValue , attType , false , false ) ; if ( lastCheck == - 1 ) { lastCheck = newAttr ; } } } attlistIndex = fGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } return attrIndex ; } private int addDTDDefaultAttributes ( QName element , XMLAttrList attrList , int attrIndex , boolean validationEnabled , boolean standalone ) throws Exception { int elementIndex = fGrammar . getElementDeclIndex ( element , - 1 ) ; if ( elementIndex == - 1 ) { return attrIndex ; } fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; int elementNameIndex = fTempElementDecl . name . rawname ; int attlistIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int firstCheck = attrIndex ; int lastCheck = - 1 ; while ( attlistIndex != - 1 ) { fGrammar . getAttributeDecl ( attlistIndex , fTempAttDecl ) ; int attPrefix = fTempAttDecl . name . prefix ; int attName = fTempAttDecl . name . rawname ; int attLocalpart = fTempAttDecl . name . localpart ; int attType = attributeTypeName ( fTempAttDecl ) ; int attDefType = fTempAttDecl . defaultType ; int attValue = - 1 ; if ( fTempAttDecl . defaultValue != null ) { attValue = fStringPool . addSymbol ( fTempAttDecl . defaultValue ) ; } boolean specified = false ; boolean required = attDefType == XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; if ( firstCheck != - 1 ) { boolean cdata = attType == fCDATASymbol ; if ( ! cdata || required || attValue != - 1 ) { int i = attrList . getFirstAttr ( firstCheck ) ; while ( i != - 1 && ( lastCheck == - 1 || i <= lastCheck ) ) { if ( attrList . getAttrName ( i ) == fTempAttDecl . name . rawname ) { if ( validationEnabled && attDefType == XMLAttributeDecl . DEFAULT_TYPE_FIXED ) { int alistValue = attrList . getAttValue ( i ) ; if ( alistValue != attValue && ! fStringPool . toString ( alistValue ) . equals ( fStringPool . toString ( attValue ) ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) , fStringPool . toString ( alistValue ) , fStringPool . toString ( attValue ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_FIXED_ATTVALUE_INVALID , XMLMessages . VC_FIXED_ATTRIBUTE_DEFAULT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } specified = true ; break ; } i = attrList . getNextAttr ( i ) ; } } } if ( ! specified ) { if ( required ) { if ( validationEnabled ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_REQUIRED_ATTRIBUTE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else if ( attValue != - 1 ) { if ( validationEnabled && standalone ) if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attlistIndex ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( attType == fIDREFSymbol ) { this . fValIDRef . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } else if ( attType == fIDREFSSymbol ) { this . fValIDRefs . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } if ( attrIndex == - 1 ) { attrIndex = attrList . startAttrList ( ) ; } fTempQName . setValues ( attPrefix , attLocalpart , attName , fTempAttDecl . name . uri ) ; int newAttr = attrList . addAttr ( fTempQName , attValue , attType , false , false ) ; if ( lastCheck == - 1 ) { lastCheck = newAttr ; } } } attlistIndex = fGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } return attrIndex ; } private XMLContentModel getElementContentModel ( int elementIndex ) throws CMException { XMLContentModel contentModel = null ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentModel = fGrammar . getElementContentModel ( elementIndex ) ; } } return contentModel ; } private int getAttDef ( QName element , QName attribute ) { if ( fGrammar != null ) { int scope = fCurrentScope ; if ( element . uri > - 1 ) { scope = TOP_LEVEL_SCOPE ; } int elementIndex = fGrammar . getElementDeclIndex ( element , scope ) ; if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { fGrammar . getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . name . localpart == attribute . localpart && fTempAttributeDecl . name . uri == attribute . uri ) { return attDefIndex ; } attDefIndex = fGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } return - 1 ; } private int getAttDefByElementIndex ( int elementIndex , QName attribute ) { if ( fGrammar != null && elementIndex > - 1 ) { if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { fGrammar . getAttributeDecl ( attDefIndex , fTempAttDecl ) ; if ( fGrammarIsDTDGrammar ) { if ( fTempAttDecl . name . rawname == attribute . rawname ) return attDefIndex ; } else if ( fTempAttDecl . name . localpart == attribute . localpart && fTempAttDecl . name . uri == attribute . uri ) { return attDefIndex ; } if ( fGrammarIsSchemaGrammar ) { if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return attDefIndex ; } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { if ( attribute . uri == - 1 ) { return attDefIndex ; } } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( attribute . uri != fTempAttDecl . name . uri ) { return attDefIndex ; } } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( fStringPool . stringInList ( fTempAttDecl . enumeration , attribute . uri ) ) { return attDefIndex ; } } } attDefIndex = fGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } return - 1 ; } private void rootElementSpecified ( QName rootElement ) throws Exception { if ( fLoadDTDGrammar ) if ( fGrammar == null ) { fGrammar = fGrammarResolver . getGrammar ( "" ) ; if ( fGrammar == null && DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "Oops! no grammar is found for validation" ) ; } if ( fDynamicValidation && fGrammar == null ) { fValidating = false ; } if ( fGrammar != null ) { if ( fGrammar instanceof DTDGrammar ) { fGrammarIsDTDGrammar = true ; fGrammarIsSchemaGrammar = false ; } else if ( fGrammar instanceof SchemaGrammar ) { fGrammarIsSchemaGrammar = true ; fGrammarIsDTDGrammar = false ; } fGrammarNameSpaceIndex = fEmptyURI ; } } if ( fValidating ) { if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getRootElementQName ( fRootElement ) ) { String root1 = fStringPool . toString ( fRootElement . rawname ) ; String root2 = fStringPool . toString ( rootElement . rawname ) ; if ( ! root1 . equals ( root2 ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ROOT_ELEMENT_TYPE , XMLMessages . VC_ROOT_ELEMENT_TYPE , fRootElement . rawname , rootElement . rawname ) ; } } } if ( fNamespacesEnabled ) { if ( fNamespacesScope == null ) { fNamespacesScope = new NamespacesScope ( this ) ; fNamespacesPrefix = fStringPool . addSymbol ( "xmlns" ) ; fNamespacesScope . setNamespaceForPrefix ( fNamespacesPrefix , - 1 ) ; int xmlSymbol = fStringPool . addSymbol ( "xml" ) ; int xmlNamespace = fStringPool . addSymbol ( "http://www.w3.org/XML/1998/namespace" ) ; fNamespacesScope . setNamespaceForPrefix ( xmlSymbol , xmlNamespace ) ; } } } private boolean switchGrammar ( int newGrammarNameSpaceIndex ) throws Exception { Grammar tempGrammar = fGrammarResolver . getGrammar ( fStringPool . toString ( newGrammarNameSpaceIndex ) ) ; if ( tempGrammar == null ) { tempGrammar = fGrammarResolver . getGrammar ( "" ) ; } if ( tempGrammar == null ) { return false ; } else { fGrammar = tempGrammar ; if ( fGrammar instanceof DTDGrammar ) { fGrammarIsDTDGrammar = true ; fGrammarIsSchemaGrammar = false ; } else if ( fGrammar instanceof SchemaGrammar ) { fGrammarIsSchemaGrammar = true ; fGrammarIsDTDGrammar = false ; } return true ; } } private void bindNamespacesToElementAndAttributes ( QName element , XMLAttrList attrList ) throws Exception { fNamespacesScope . increaseDepth ( ) ; Hashtable locationUriPairs = null ; if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; int attPrefix = attrList . getAttrPrefix ( index ) ; if ( fStringPool . equalNames ( attName , fXMLLang ) ) { } else if ( fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int uri = fStringPool . addSymbol ( attrList . getAttValue ( index ) ) ; fNamespacesScope . setNamespaceForPrefix ( StringPool . EMPTY_STRING , uri ) ; } else { if ( attPrefix == fNamespacesPrefix ) { int nsPrefix = attrList . getAttrLocalpart ( index ) ; int uri = fStringPool . addSymbol ( attrList . getAttValue ( index ) ) ; fNamespacesScope . setNamespaceForPrefix ( nsPrefix , uri ) ; if ( fValidating && fSchemaValidation ) { boolean seeXsi = false ; String attrValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; if ( attrValue . equals ( SchemaSymbols . URI_XSI ) ) { fXsiPrefix = nsPrefix ; seeXsi = true ; } if ( ! seeXsi ) { } } } } index = attrList . getNextAttr ( index ) ; } if ( fValidating && fSchemaValidation ) { fXsiTypeAttValue = - 1 ; index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; int attPrefix = attrList . getAttrPrefix ( index ) ; if ( fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { } else { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "deal with XSI" ) ; System . out . println ( "before find XSI: " + fStringPool . toString ( attPrefix ) + "," + fStringPool . toString ( fXsiPrefix ) ) ; } if ( fXsiPrefix != - 1 && attPrefix == fXsiPrefix ) { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "find XSI: " + fStringPool . toString ( attPrefix ) + "," + fStringPool . toString ( attName ) ) ; } int localpart = attrList . getAttrLocalpart ( index ) ; if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_SCHEMALOCACTION ) ) { if ( locationUriPairs == null ) { locationUriPairs = new Hashtable ( ) ; } parseSchemaLocation ( fStringPool . toString ( attrList . getAttValue ( index ) ) , locationUriPairs ) ; } else if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_NONAMESPACESCHEMALOCACTION ) ) { if ( locationUriPairs == null ) { locationUriPairs = new Hashtable ( ) ; } locationUriPairs . put ( fStringPool . toString ( attrList . getAttValue ( index ) ) , "" ) ; if ( fNamespacesScope != null ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } } else if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_TYPE ) ) { fXsiTypeAttValue = attrList . getAttValue ( index ) ; } } } index = attrList . getNextAttr ( index ) ; } if ( locationUriPairs != null ) { Enumeration locations = locationUriPairs . keys ( ) ; while ( locations . hasMoreElements ( ) ) { String loc = ( String ) locations . nextElement ( ) ; String uri = ( String ) locationUriPairs . get ( loc ) ; resolveSchemaGrammar ( loc , uri ) ; } } } } int prefix = element . prefix != - 1 ? element . prefix : 0 ; int uri = fNamespacesScope . getNamespaceForPrefix ( prefix ) ; if ( element . prefix != - 1 || uri != - 1 ) { element . uri = uri ; if ( element . uri == - 1 ) { Object [ ] args = { fStringPool . toString ( element . prefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; if ( ! fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int attPrefix = attrList . getAttrPrefix ( index ) ; if ( attPrefix != fNamespacesPrefix ) { if ( attPrefix != - 1 ) { int attrUri = fNamespacesScope . getNamespaceForPrefix ( attPrefix ) ; if ( attrUri == - 1 ) { Object [ ] args = { fStringPool . toString ( attPrefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } attrList . setAttrURI ( index , attrUri ) ; } } } index = attrList . getNextAttr ( index ) ; } } } void parseSchemaLocation ( String schemaLocationStr , Hashtable locationUriPairs ) { if ( locationUriPairs != null ) { StringTokenizer tokenizer = new StringTokenizer ( schemaLocationStr , " \n\t\r" , false ) ; int tokenTotal = tokenizer . countTokens ( ) ; if ( tokenTotal % 2 != 0 ) { } else { while ( tokenizer . hasMoreTokens ( ) ) { String uri = tokenizer . nextToken ( ) ; String location = tokenizer . nextToken ( ) ; locationUriPairs . put ( location , uri ) ; } } } else { } } private void resolveSchemaGrammar ( String loc , String uri ) throws Exception { SchemaGrammar grammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uri ) ; if ( grammar == null ) { DOMParser parser = new DOMParser ( ) ; parser . setEntityResolver ( new Resolver ( fEntityHandler ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } InputSource source = null ; EntityResolver currentER = parser . getEntityResolver ( ) ; if ( currentER != null ) { source = currentER . resolveEntity ( "" , loc ) ; } if ( source == null ) { loc = fEntityHandler . expandSystemId ( loc ) ; source = new InputSource ( loc ) ; } try { parser . parse ( source ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , e . getMessage ( ) ) ; } Document document = parser . getDocument ( ) ; TraverseSchema tst = null ; try { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "I am geting the Schema Document" ) ; } Element root = document . getDocumentElement ( ) ; if ( root == null ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Can't get back Schema document's root element :" + loc ) ; } else { if ( uri == null || ! uri . equals ( root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ) ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Schema in " + loc + " has a different target namespace " + "from the one specified in the instance document :" + uri ) ; } grammar = new SchemaGrammar ( ) ; grammar . setGrammarDocument ( document ) ; tst = new TraverseSchema ( root , fStringPool , ( SchemaGrammar ) grammar , fGrammarResolver , fErrorReporter , source . getSystemId ( ) ) ; fGrammarResolver . putGrammar ( document . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) , grammar ) ; } } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } } } private void resolveSchemaGrammar ( String uri ) throws Exception { resolveSchemaGrammar ( uri , uri ) ; } static class Resolver implements EntityResolver { private static final String SYSTEM [ ] = { "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/structures.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/datatypes.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/versionInfo.ent" , } ; private static final String PATH [ ] = { "structures.dtd" , "datatypes.dtd" , "versionInfo.ent" , } ; private DefaultEntityHandler fEntityHandler ; public Resolver ( DefaultEntityHandler handler ) { fEntityHandler = handler ; } public InputSource resolveEntity ( String publicId , String systemId ) throws IOException , SAXException { for ( int i = 0 ; i < SYSTEM . length ; i ++ ) { if ( systemId . equals ( SYSTEM [ i ] ) ) { InputSource source = new InputSource ( getClass ( ) . getResourceAsStream ( PATH [ i ] ) ) ; source . setPublicId ( publicId ) ; source . setSystemId ( systemId ) ; return source ; } } EntityResolver resolver = fEntityHandler . getEntityResolver ( ) ; if ( resolver != null ) { InputSource source = resolver . resolveEntity ( publicId , systemId ) ; if ( source != null ) { return source ; } } return new InputSource ( fEntityHandler . expandSystemId ( systemId ) ) ; } } static class ErrorHandler implements org . xml . sax . ErrorHandler { public void warning ( SAXParseException ex ) { System . err . println ( "[Warning] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { System . err . println ( "[Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) { System . err . println ( "[Fatal Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId_ = ex . getSystemId ( ) ; if ( systemId_ != null ) { int index = systemId_ . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId_ = systemId_ . substring ( index + 1 ) ; str . append ( systemId_ ) ; } str . append ( ':' ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( ':' ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } } private int attributeTypeName ( XMLAttributeDecl attrDecl ) { switch ( attrDecl . type ) { case XMLAttributeDecl . TYPE_ENTITY : { return attrDecl . list ? fENTITIESSymbol : fENTITYSymbol ; } case XMLAttributeDecl . TYPE_ENUMERATION : { String enumeration = fStringPool . stringListAsString ( attrDecl . enumeration ) ; return fStringPool . addString ( enumeration ) ; } case XMLAttributeDecl . TYPE_ID : { return fIDSymbol ; } case XMLAttributeDecl . TYPE_IDREF : { return attrDecl . list ? fIDREFSSymbol : fIDREFSymbol ; } case XMLAttributeDecl . TYPE_NMTOKEN : { return attrDecl . list ? fNMTOKENSSymbol : fNMTOKENSSymbol ; } case XMLAttributeDecl . TYPE_NOTATION : { return fNOTATIONSymbol ; } } return fCDATASymbol ; } private void validateElementAndAttributes ( QName element , XMLAttrList attrList ) throws Exception { if ( ( fElementDepth >= 0 && fValidationFlagStack [ fElementDepth ] != 0 ) || ( fGrammar == null && ! fValidating && ! fNamespacesEnabled ) ) { fCurrentElementIndex = - 1 ; fCurrentContentSpecType = - 1 ; fInElementContent = false ; if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; int index = fAttrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { if ( fStringPool . equalNames ( fAttrList . getAttrName ( index ) , fXMLLang ) ) { fDocumentScanner . checkXMLLangAttributeValue ( fAttrList . getAttValue ( index ) ) ; break ; } index = fAttrList . getNextAttr ( index ) ; } } return ; } int elementIndex = - 1 ; int contentSpecType = - 1 ; boolean skipThisOne = false ; boolean laxThisOne = false ; if ( fGrammarIsSchemaGrammar && fContentLeafStack [ fElementDepth ] != null ) { ContentLeafNameTypeVector cv = fContentLeafStack [ fElementDepth ] ; QName [ ] fElemMap = cv . leafNames ; for ( int i = 0 ; i < cv . leafCount ; i ++ ) { int type = cv . leafTypes [ i ] ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fElemMap [ i ] . uri == element . uri && fElemMap [ i ] . localpart == element . localpart ) break ; } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( element . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ i ] . uri != element . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_SKIP ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_SKIP ) { if ( element . uri == - 1 ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_SKIP ) { if ( fElemMap [ i ] . uri != element . uri ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LAX ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { laxThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_LAX ) { if ( element . uri == - 1 ) { laxThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_LAX ) { if ( fElemMap [ i ] . uri != element . uri ) { laxThisOne = true ; break ; } } } } if ( skipThisOne ) { fNeedValidationOff = true ; } else { if ( fNamespacesEnabled && fValidating && element . uri != fGrammarNameSpaceIndex && element . uri != - 1 ) { fGrammarNameSpaceIndex = element . uri ; boolean success = switchGrammar ( fGrammarNameSpaceIndex ) ; if ( ! success && ! laxThisOne ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fGrammarNameSpaceIndex ) + " , can not found" ) ; } } if ( fGrammar != null ) { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "*******Lookup element: uri: " + fStringPool . toString ( element . uri ) + "localpart: '" + fStringPool . toString ( element . localpart ) + "' and scope : " + fCurrentScope + "\n" ) ; } elementIndex = fGrammar . getElementDeclIndex ( element , fCurrentScope ) ; if ( elementIndex == - 1 ) { elementIndex = fGrammar . getElementDeclIndex ( element , TOP_LEVEL_SCOPE ) ; } if ( elementIndex == - 1 ) { if ( fGrammarIsSchemaGrammar && fCurrentElementIndex != - 1 ) { TraverseSchema . ComplexTypeInfo baseTypeInfo = null ; baseTypeInfo = ( ( SchemaGrammar ) fGrammar ) . getElementComplexTypeInfo ( fCurrentElementIndex ) ; while ( baseTypeInfo != null ) { elementIndex = fGrammar . getElementDeclIndex ( element , baseTypeInfo . scopeDefined ) ; if ( elementIndex > - 1 ) { break ; } baseTypeInfo = baseTypeInfo . baseComplexTypeInfo ; } } if ( elementIndex == - 1 ) { if ( laxThisOne ) { fNeedValidationOff = true ; } else if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "!!! can not find elementDecl in the grammar, " + " the element localpart: " + element . localpart + "[" + fStringPool . toString ( element . localpart ) + "]" + " the element uri: " + element . uri + "[" + fStringPool . toString ( element . uri ) + "]" + " and the current enclosing scope: " + fCurrentScope ) ; } } if ( DEBUG_SCHEMA_VALIDATION ) { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; System . out . println ( "elementIndex: " + elementIndex + " \n and itsName : '" + fStringPool . toString ( fTempElementDecl . name . localpart ) + "' \n its ContentType:" + fTempElementDecl . type + "\n its ContentSpecIndex : " + fTempElementDecl . contentSpecIndex + "\n" + " and the current enclosing scope: " + fCurrentScope ) ; } } contentSpecType = getContentSpecType ( elementIndex ) ; if ( fGrammarIsSchemaGrammar && elementIndex != - 1 ) { if ( fXsiTypeAttValue > - 1 ) { String xsiType = fStringPool . toString ( fXsiTypeAttValue ) ; int colonP = xsiType . indexOf ( ":" ) ; String prefix = "" ; String localpart = xsiType ; if ( colonP > - 1 ) { prefix = xsiType . substring ( 0 , colonP ) ; localpart = xsiType . substring ( colonP + 1 ) ; } String uri = "" ; int uriIndex = - 1 ; if ( fNamespacesScope != null ) { uriIndex = fNamespacesScope . getNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) ) ; if ( uriIndex > - 1 ) { uri = fStringPool . toString ( uriIndex ) ; if ( uriIndex != fGrammarNameSpaceIndex ) { fGrammarNameSpaceIndex = fCurrentSchemaURI = uriIndex ; boolean success = switchGrammar ( fCurrentSchemaURI ) ; if ( ! success && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fCurrentSchemaURI ) + " , can not found" ) ; } } } } Hashtable complexRegistry = ( ( SchemaGrammar ) fGrammar ) . getComplexTypeRegistry ( ) ; DatatypeValidatorFactoryImpl dataTypeReg = ( ( SchemaGrammar ) fGrammar ) . getDatatypeRegistry ( ) ; if ( complexRegistry == null || dataTypeReg == null ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , fErrorReporter . getLocator ( ) . getSystemId ( ) + " line" + fErrorReporter . getLocator ( ) . getLineNumber ( ) + ", canot resolve xsi:type = " + xsiType + "  ---2" ) ; } else { TraverseSchema . ComplexTypeInfo typeInfo = ( TraverseSchema . ComplexTypeInfo ) complexRegistry . get ( uri + "," + localpart ) ; if ( typeInfo == null ) { if ( uri . length ( ) == 0 || uri . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { fXsiTypeValidator = dataTypeReg . getDatatypeValidator ( localpart ) ; } else fXsiTypeValidator = dataTypeReg . getDatatypeValidator ( uri + "," + localpart ) ; if ( fXsiTypeValidator == null ) reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "unresolved type : " + uri + "," + localpart + " found  in xsi:type handling" ) ; } else elementIndex = typeInfo . templateElementIndex ; } fXsiTypeAttValue = - 1 ; } fCurrentScope = ( ( SchemaGrammar ) fGrammar ) . getElementDefinedScope ( elementIndex ) ; String anotherSchemaURI = ( ( SchemaGrammar ) fGrammar ) . getElementFromAnotherSchemaURI ( elementIndex ) ; if ( anotherSchemaURI != null ) { if ( contentSpecType != - 1 && contentSpecType != XMLElementDecl . TYPE_SIMPLE && contentSpecType != XMLElementDecl . TYPE_EMPTY ) { TraverseSchema . ComplexTypeInfo typeInfo = ( ( SchemaGrammar ) fGrammar ) . getElementComplexTypeInfo ( elementIndex ) ; if ( typeInfo != null ) { elementIndex = typeInfo . templateElementIndex ; } } fGrammarNameSpaceIndex = fCurrentSchemaURI = fStringPool . addSymbol ( anotherSchemaURI ) ; boolean success = switchGrammar ( fCurrentSchemaURI ) ; if ( ! success && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fCurrentSchemaURI ) + " , can not found" ) ; } } } if ( contentSpecType == - 1 && fValidating && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_NOT_DECLARED , XMLMessages . VC_ELEMENT_VALID , element . rawname ) ; } if ( fGrammar != null && fGrammarIsSchemaGrammar && elementIndex != - 1 ) { fAttrListHandle = addDefaultAttributes ( elementIndex , attrList , fAttrListHandle , fValidating , fStandaloneReader != - 1 ) ; } if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; } if ( DEBUG_PRINT_ATTRIBUTES ) { String elementStr = fStringPool . toString ( element . rawname ) ; System . out . print ( "startElement: <" + elementStr ) ; if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { System . out . print ( " " + fStringPool . toString ( attrList . getAttrName ( index ) ) + "=\"" + fStringPool . toString ( attrList . getAttValue ( index ) ) + "\"" ) ; index = attrList . getNextAttr ( index ) ; } } System . out . println ( ">" ) ; } if ( fAttrListHandle != - 1 && ! fNeedValidationOff ) { int index = fAttrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attrNameIndex = attrList . getAttrName ( index ) ; if ( fStringPool . equalNames ( attrNameIndex , fXMLLang ) ) { fDocumentScanner . checkXMLLangAttributeValue ( attrList . getAttValue ( index ) ) ; } int _xmlns = fStringPool . addSymbol ( "xmlns" ) ; if ( attrNameIndex != _xmlns && attrList . getAttrPrefix ( index ) != _xmlns ) if ( fGrammar != null ) { fAttrNameLocator = getLocatorImpl ( fAttrNameLocator ) ; fTempQName . setValues ( attrList . getAttrPrefix ( index ) , attrList . getAttrLocalpart ( index ) , attrList . getAttrName ( index ) , attrList . getAttrURI ( index ) ) ; int attDefIndex = getAttDefByElementIndex ( elementIndex , fTempQName ) ; if ( fTempQName . uri != fXsiURI ) if ( attDefIndex == - 1 ) { if ( fValidating ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( attrList . getAttrName ( index ) ) } ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else { fGrammar . getAttributeDecl ( attDefIndex , fTempAttDecl ) ; int attributeType = attributeTypeName ( fTempAttDecl ) ; attrList . setAttType ( index , attributeType ) ; if ( fValidating ) { if ( fGrammarIsDTDGrammar && ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ENTITY || fTempAttDecl . type == XMLAttributeDecl . TYPE_ENUMERATION || fTempAttDecl . type == XMLAttributeDecl . TYPE_ID || fTempAttDecl . type == XMLAttributeDecl . TYPE_IDREF || fTempAttDecl . type == XMLAttributeDecl . TYPE_NMTOKEN || fTempAttDecl . type == XMLAttributeDecl . TYPE_NOTATION ) ) { validateDTDattribute ( element , attrList . getAttValue ( index ) , fTempAttDecl ) ; } else if ( fGrammarIsSchemaGrammar && ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_ANY || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LIST || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) ) { if ( fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_SKIP ) { } else if ( fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_STRICT || fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_LAX ) { boolean reportError = false ; boolean processContentStrict = fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_STRICT ; if ( fTempQName . uri == - 1 ) { if ( processContentStrict ) { reportError = true ; } } else { Grammar aGrammar = fGrammarResolver . getGrammar ( fStringPool . toString ( fTempQName . uri ) ) ; if ( aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { if ( processContentStrict ) { reportError = true ; } } else { SchemaGrammar sGrammar = ( SchemaGrammar ) aGrammar ; Hashtable attRegistry = sGrammar . getAttirubteDeclRegistry ( ) ; if ( attRegistry == null ) { if ( processContentStrict ) { reportError = true ; } } else { XMLAttributeDecl attDecl = ( XMLAttributeDecl ) attRegistry . get ( fStringPool . toString ( fTempQName . localpart ) ) ; if ( attDecl == null ) { if ( processContentStrict ) { reportError = true ; } } else { DatatypeValidator attDV = attDecl . datatypeValidator ; if ( attDV == null ) { if ( processContentStrict ) { reportError = true ; } } else { try { String unTrimValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; String value = unTrimValue . trim ( ) ; if ( attDecl . type == XMLAttributeDecl . TYPE_ID ) { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } if ( attDecl . type == XMLAttributeDecl . TYPE_IDREF ) { attDV . validate ( value , this . fStoreIDRef ) ; } else attDV . validate ( unTrimValue , null ) ; } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } } if ( reportError ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , "ANY---" + fStringPool . toString ( attrList . getAttrName ( index ) ) } ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } else if ( fTempAttDecl . datatypeValidator == null ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( attrList . getAttrName ( index ) ) } ; System . out . println ( "[Error] Datatypevalidator for attribute " + fStringPool . toString ( attrList . getAttrName ( index ) ) + " not found in element type " + fStringPool . toString ( element . rawname ) ) ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } else { try { String unTrimValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; String value = unTrimValue . trim ( ) ; if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ID ) { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_IDREF ) { fTempAttDecl . datatypeValidator . validate ( value , this . fStoreIDRef ) ; } else { fTempAttDecl . datatypeValidator . validate ( unTrimValue , null ) ; } } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } index = fAttrList . getNextAttr ( index ) ; } } } if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; if ( ! fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int attPrefix = attrList . getAttrPrefix ( index ) ; if ( attPrefix != fNamespacesPrefix ) { if ( attPrefix != - 1 ) { int uri = fNamespacesScope . getNamespaceForPrefix ( attPrefix ) ; if ( uri == - 1 ) { Object [ ] args = { fStringPool . toString ( attPrefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } attrList . setAttrURI ( index , uri ) ; } } } index = attrList . getNextAttr ( index ) ; } } fCurrentElementIndex = elementIndex ; fCurrentContentSpecType = contentSpecType ; if ( fValidating && contentSpecType == XMLElementDecl . TYPE_SIMPLE ) { fBufferDatatype = true ; fDatatypeBuffer . setLength ( 0 ) ; } fInElementContent = ( contentSpecType == XMLElementDecl . TYPE_CHILDREN ) ; } private void validateDTDattribute ( QName element , int attValue , XMLAttributeDecl attributeDecl ) throws Exception { AttributeValidator av = null ; switch ( attributeDecl . type ) { case XMLAttributeDecl . TYPE_ENTITY : { boolean isAlistAttribute = attributeDecl . list ; String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValENTITIES . validate ( value , null ) ; } else { fValENTITY . validate ( value , null ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( ex . getMajorCode ( ) != 1 && ex . getMinorCode ( ) != - 1 ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } else { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } } break ; case XMLAttributeDecl . TYPE_ENUMERATION : av = fAttValidatorENUMERATION ; break ; case XMLAttributeDecl . TYPE_ID : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } } break ; case XMLAttributeDecl . TYPE_IDREF : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; boolean isAlistAttribute = attributeDecl . list ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValIDRefs . validate ( value , this . fStoreIDRef ) ; } else { fValIDRef . validate ( value , this . fStoreIDRef ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( ex . getMajorCode ( ) != 1 && ex . getMinorCode ( ) != - 1 ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } else { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } } break ; case XMLAttributeDecl . TYPE_NOTATION : { av = fAttValidatorNOTATION ; } break ; case XMLAttributeDecl . TYPE_NMTOKEN : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; boolean isAlistAttribute = attributeDecl . list ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValNMTOKENS . validate ( value , null ) ; } else { fValNMTOKEN . validate ( value , null ) ; } } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( XMLMessages . MSG_NMTOKEN_INVALID , XMLMessages . VC_NAME_TOKEN , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } } break ; } if ( av != null ) av . normalize ( element , attributeDecl . name , attValue , attributeDecl . type , attributeDecl . enumeration ) ; } private void charDataInContent ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . println ( "charDataInContent()" ) ; } if ( fElementChildren . length <= fElementChildrenLength ) { QName [ ] newarray = new QName [ fElementChildren . length * 2 ] ; System . arraycopy ( fElementChildren , 0 , newarray , 0 , fElementChildren . length ) ; fElementChildren = newarray ; } QName qname = fElementChildren [ fElementChildrenLength ] ; if ( qname == null ) { for ( int i = fElementChildrenLength ; i < fElementChildren . length ; i ++ ) { fElementChildren [ i ] = new QName ( ) ; } qname = fElementChildren [ fElementChildrenLength ] ; } qname . clear ( ) ; fElementChildrenLength ++ ; } private int checkContent ( int elementIndex , QName [ ] children , int childOffset , int childCount ) throws Exception { final int elementType = fCurrentElement . rawname ; if ( DEBUG_PRINT_CONTENT ) { String strTmp = fStringPool . toString ( elementType ) ; System . out . println ( "Name: " + strTmp + ", " + "Count: " + childCount + ", " + "ContentSpecType: " + fCurrentContentSpecType ) ; for ( int index = childOffset ; index < ( childOffset + childCount ) && index < 10 ; index ++ ) { if ( index == 0 ) { System . out . print ( "  (" ) ; } String childName = ( children [ index ] . localpart == - 1 ) ? "#PCDATA" : fStringPool . toString ( children [ index ] . localpart ) ; if ( index + 1 == childCount ) { System . out . println ( childName + ")" ) ; } else if ( index + 1 == 10 ) { System . out . println ( childName + ",...)" ) ; } else { System . out . print ( childName + "," ) ; } } } final int contentType = fCurrentContentSpecType ; if ( contentType == XMLElementDecl . TYPE_EMPTY ) { if ( childCount != 0 ) { return 0 ; } } else if ( contentType == XMLElementDecl . TYPE_ANY ) { } else if ( contentType == XMLElementDecl . TYPE_MIXED || contentType == XMLElementDecl . TYPE_CHILDREN ) { XMLContentModel cmElem = null ; try { cmElem = getElementContentModel ( elementIndex ) ; int result = cmElem . validateContent ( children , childOffset , childCount ) ; if ( result != - 1 && fGrammarIsSchemaGrammar ) { EquivClassComparator comparator = new EquivClassComparator ( fGrammarResolver , fStringPool ) ; cmElem . setEquivClassComparator ( comparator ) ; result = cmElem . validateContentSpecial ( children , childOffset , childCount ) ; } return result ; } catch ( CMException excToCatch ) { int majorCode = excToCatch . getErrorCode ( ) ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , majorCode , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } else if ( contentType == - 1 ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_NOT_DECLARED , XMLMessages . VC_ELEMENT_VALID , elementType ) ; } else if ( contentType == XMLElementDecl . TYPE_SIMPLE ) { XMLContentModel cmElem = null ; if ( childCount > 0 ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { "In element '" + fStringPool . toString ( elementType ) + "' : " + "Can not have element children within a simple type content" } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } else { try { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; DatatypeValidator dv = fTempElementDecl . datatypeValidator ; if ( fXsiTypeValidator != null ) { dv = fXsiTypeValidator ; fXsiTypeValidator = null ; } if ( dv == null ) { System . out . println ( "Internal Error: this element have a simpletype " + "but no datatypevalidator was found, element " + fTempElementDecl . name + ",locapart: " + fStringPool . toString ( fTempElementDecl . name . localpart ) ) ; } else { dv . validate ( fDatatypeBuffer . toString ( ) , null ) ; } } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } else { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . VAL_CST , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } return - 1 ; } private void printChildren ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . print ( '[' ) ; for ( int i = 0 ; i < fElementChildrenLength ; i ++ ) { System . out . print ( ' ' ) ; QName qname = fElementChildren [ i ] ; if ( qname != null ) { System . out . print ( fStringPool . toString ( qname . rawname ) ) ; } else { System . out . print ( "null" ) ; } if ( i < fElementChildrenLength - 1 ) { System . out . print ( ", " ) ; } System . out . flush ( ) ; } System . out . print ( " ]" ) ; System . out . println ( ) ; } } private void printStack ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . print ( '{' ) ; for ( int i = 0 ; i <= fElementDepth ; i ++ ) { System . out . print ( ' ' ) ; System . out . print ( fElementChildrenOffsetStack [ i ] ) ; if ( i < fElementDepth ) { System . out . print ( ", " ) ; } System . out . flush ( ) ; } System . out . print ( " }" ) ; System . out . println ( ) ; } } public interface AttributeValidator { public int normalize ( QName element , QName attribute , int attValue , int attType , int enumHandle ) throws Exception ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } final class AttValidatorNOTATION implements AttributeValidator { public int normalize ( QName element , QName attribute , int attValueHandle , int attType , int enumHandle ) throws Exception { String attValue = fStringPool . toString ( attValueHandle ) ; String newAttValue = attValue . trim ( ) ; if ( fValidating ) { if ( newAttValue != attValue ) { if ( invalidStandaloneAttDef ( element , attribute ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attribute . rawname ) , attValue , newAttValue ) ; } attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } else { attValueHandle = fStringPool . addSymbol ( attValueHandle ) ; } if ( ! fStringPool . stringInList ( enumHandle , attValueHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_NOT_IN_LIST , XMLMessages . VC_NOTATION_ATTRIBUTES , fStringPool . toString ( attribute . rawname ) , newAttValue , fStringPool . stringListAsString ( enumHandle ) ) ; } } else if ( newAttValue != attValue ) { attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } return attValueHandle ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } } final class AttValidatorENUMERATION implements AttributeValidator { public int normalize ( QName element , QName attribute , int attValueHandle , int attType , int enumHandle ) throws Exception { String attValue = fStringPool . toString ( attValueHandle ) ; String newAttValue = attValue . trim ( ) ; if ( fValidating ) { if ( newAttValue != attValue ) { if ( invalidStandaloneAttDef ( element , attribute ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attribute . rawname ) , attValue , newAttValue ) ; } attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } else { attValueHandle = fStringPool . addSymbol ( attValueHandle ) ; } if ( ! fStringPool . stringInList ( enumHandle , attValueHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_NOT_IN_LIST , XMLMessages . VC_ENUMERATION , fStringPool . toString ( attribute . rawname ) , newAttValue , fStringPool . stringListAsString ( enumHandle ) ) ; } } else if ( newAttValue != attValue ) { attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } return attValueHandle ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } } } 	1
package org . w3c . dom . html ; public interface HTMLDListElement extends HTMLElement { public boolean getCompact ( ) ; public void setCompact ( boolean compact ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class ElementNSImpl extends ElementImpl { static final long serialVersionUID = - 9142310625494392642L ; protected String namespaceURI ; protected String localName ; protected ElementNSImpl ( DocumentImpl ownerDocument , String namespaceURI , String qualifiedName ) throws DOMException { super ( ownerDocument , qualifiedName ) ; if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = qualifiedName ; } else { prefix = qualifiedName . substring ( 0 , index ) ; localName = qualifiedName . substring ( index + 1 ) ; } if ( prefix != null && ( namespaceURI == null || namespaceURI . equals ( "" ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } this . namespaceURI = namespaceURI ; } protected ElementNSImpl ( DocumentImpl ownerDocument , String value ) { super ( ownerDocument , value ) ; } public String getNamespaceURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return namespaceURI ; } public String getPrefix ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int index = name . indexOf ( ':' ) ; return index < 0 ? null : name . substring ( 0 , index ) ; } public void setPrefix ( String prefix ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( namespaceURI == null || ( prefix != null && prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } if ( ownerDocument . errorChecking && ! DocumentImpl . isXMLName ( prefix ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } name = prefix + ":" + localName ; } public String getLocalName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return localName ; } } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . utils . QName ; import org . apache . xerces . validators . schema . EquivClassComparator ; public interface XMLContentModel { public int validateContent ( QName children [ ] , int offset , int length ) throws Exception ; public int validateContentSpecial ( QName children [ ] , int offset , int length ) throws Exception ; public void setEquivClassComparator ( EquivClassComparator comparator ) ; public int whatCanGoHere ( boolean fullyValid , InsertableElementsInfo info ) throws Exception ; public ContentLeafNameTypeVector getContentLeafNameTypeVector ( ) ; } 	0
package org . w3c . dom ; public interface Document extends Node { public DocumentType getDoctype ( ) ; public DOMImplementation getImplementation ( ) ; public Element getDocumentElement ( ) ; public Element createElement ( String tagName ) throws DOMException ; public DocumentFragment createDocumentFragment ( ) ; public Text createTextNode ( String data ) ; public Comment createComment ( String data ) ; public CDATASection createCDATASection ( String data ) throws DOMException ; public ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException ; public Attr createAttribute ( String name ) throws DOMException ; public EntityReference createEntityReference ( String name ) throws DOMException ; public NodeList getElementsByTagName ( String tagname ) ; public Node importNode ( Node importedNode , boolean deep ) throws DOMException ; public Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException ; public Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public Element getElementById ( String elementId ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLFontElementImpl extends HTMLElementImpl implements HTMLFontElement { public String getColor ( ) { return capitalize ( getAttribute ( "color" ) ) ; } public void setColor ( String color ) { setAttribute ( "color" , color ) ; } public String getFace ( ) { return capitalize ( getAttribute ( "face" ) ) ; } public void setFace ( String face ) { setAttribute ( "face" , face ) ; } public String getSize ( ) { return getAttribute ( "size" ) ; } public void setSize ( String size ) { setAttribute ( "size" , size ) ; } public HTMLFontElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface NodeIterator { public Node getRoot ( ) ; public int getWhatToShow ( ) ; public NodeFilter getFilter ( ) ; public boolean getExpandEntityReferences ( ) ; public Node nextNode ( ) throws DOMException ; public Node previousNode ( ) throws DOMException ; public void detach ( ) ; } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import java . util . Locale ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; public class IDDatatypeValidator extends AbstractDatatypeValidator { private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; private Object fNullValue = null ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; private Hashtable fTableOfId ; private Locale fLocale = null ; public static final int IDREF_STORE = 0 ; public static final int ID_CLEAR = 1 ; public IDDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public IDDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { fDerivedByList = derivedByList ; } public Object validate ( String content , Object IDStorage ) throws InvalidDatatypeValueException { StateMessageDatatype message ; if ( this . fDerivedByList == false ) { if ( IDStorage != null ) { message = ( StateMessageDatatype ) IDStorage ; if ( message . getDatatypeState ( ) == IDDatatypeValidator . ID_CLEAR ) { if ( this . fTableOfId != null ) { this . fTableOfId . clear ( ) ; this . fTableOfId = null ; } return null ; } } if ( ! XMLCharacterProperties . validName ( content ) ) { InvalidDatatypeValueException error = new InvalidDatatypeValueException ( "ID is not valid: " + content ) ; error . setMinorCode ( XMLMessages . MSG_ID_INVALID ) ; error . setMajorCode ( XMLMessages . VC_ID ) ; throw error ; } if ( ! addId ( content , IDStorage ) ) { InvalidDatatypeValueException error = new InvalidDatatypeValueException ( "ID '" + content + "'  has to be unique" ) ; error . setMinorCode ( XMLMessages . MSG_ID_NOT_UNIQUE ) ; error . setMajorCode ( XMLMessages . VC_ID ) ; throw error ; } } else { } return fTableOfId ; } public int compare ( String content1 , String content2 ) { return - 1 ; } public Hashtable getFacets ( ) { return null ; } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } private boolean addId ( String content , Object idTable ) { if ( this . fTableOfId == null ) { this . fTableOfId = new Hashtable ( ) ; } else if ( this . fTableOfId . containsKey ( content ) ) { return false ; } if ( this . fNullValue == null ) { fNullValue = new Object ( ) ; } try { this . fTableOfId . put ( content , fNullValue ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return true ; } public void setLocale ( Locale locale ) { fLocale = locale ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } } 	0
package org . w3c . dom . events ; public class EventException extends RuntimeException { public EventException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short UNSPECIFIED_EVENT_TYPE_ERR = 0 ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLTableCaptionElementImpl extends HTMLElementImpl implements HTMLTableCaptionElement { public String getAlign ( ) { return getAttribute ( "align" ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public HTMLTableCaptionElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface DeclHandler { public abstract void elementDecl ( String name , String model ) throws SAXException ; public abstract void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException ; public abstract void internalEntityDecl ( String name , String value ) throws SAXException ; public abstract void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLLIElementImpl extends HTMLElementImpl implements HTMLLIElement { public String getType ( ) { return getAttribute ( "type" ) ; } public void setType ( String type ) { setAttribute ( "type" , type ) ; } public int getValue ( ) { return getInteger ( getAttribute ( "value" ) ) ; } public void setValue ( int value ) { setAttribute ( "value" , String . valueOf ( value ) ) ; } public HTMLLIElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . validators . schema ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . validators . common . Grammar ; import org . apache . xerces . validators . common . GrammarResolver ; import org . apache . xerces . validators . common . GrammarResolverImpl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . schema . XUtil ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . utils . StringPool ; import org . w3c . dom . Element ; import org . w3c . dom . * ; import java . util . * ; import java . net . URL ; import java . net . MalformedURLException ; import org . apache . xerces . parsers . DOMParser ; import org . apache . xerces . validators . common . XMLValidator ; import org . apache . xerces . validators . datatype . DatatypeValidator . * ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . parsers . SAXParser ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . framework . XMLDocumentScanner ; import org . xml . sax . InputSource ; import org . xml . sax . SAXParseException ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import java . io . IOException ; import org . w3c . dom . Document ; import org . apache . xml . serialize . OutputFormat ; import org . apache . xml . serialize . XMLSerializer ; import org . apache . xerces . validators . schema . SchemaSymbols ; public class TraverseSchema implements NamespacesScope . NamespacesHandler { private static final int TOP_LEVEL_SCOPE = - 1 ; private static boolean DEBUGGING = false ; private XMLErrorReporter fErrorReporter = null ; private StringPool fStringPool = null ; private GrammarResolver fGrammarResolver = null ; private SchemaGrammar fSchemaGrammar = null ; private Element fSchemaRootElement ; private DatatypeValidatorFactoryImpl fDatatypeRegistry = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; private Hashtable fComplexTypeRegistry = new Hashtable ( ) ; private Hashtable fAttributeDeclRegistry = new Hashtable ( ) ; private Vector fIncludeLocations = new Vector ( ) ; private Vector fImportLocations = new Vector ( ) ; private int fAnonTypeCount = 0 ; private int fScopeCount = 0 ; private int fCurrentScope = TOP_LEVEL_SCOPE ; private int fSimpleTypeAnonCount = 0 ; private Stack fCurrentTypeNameStack = new Stack ( ) ; private Hashtable fElementRecurseComplex = new Hashtable ( ) ; private boolean fElementDefaultQualified = false ; private boolean fAttributeDefaultQualified = false ; private int fTargetNSURI ; private String fTargetNSURIString = "" ; private NamespacesScope fNamespacesScope = null ; private String fCurrentSchemaURL = "" ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; public class ComplexTypeInfo { public String typeName ; public DatatypeValidator baseDataTypeValidator ; public ComplexTypeInfo baseComplexTypeInfo ; public int derivedBy = 0 ; public int blockSet = 0 ; public int finalSet = 0 ; public boolean isAbstract = false ; public int scopeDefined = - 1 ; public int contentType ; public int contentSpecHandle = - 1 ; public int templateElementIndex = - 1 ; public int attlistHead = - 1 ; public DatatypeValidator datatypeValidator ; } public final static String SchemaForSchemaURI = "http://www.w3.org/TR-1/Schema" ; private TraverseSchema ( ) { } public void setGrammarResolver ( GrammarResolver grammarResolver ) { fGrammarResolver = grammarResolver ; } public void startNamespaceDeclScope ( int prefix , int uri ) { } public void endNamespaceDeclScope ( int prefix ) { } private String resolvePrefixToURI ( String prefix ) throws Exception { String uriStr = fStringPool . toString ( fNamespacesScope . getNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) ) ) ; if ( uriStr == null ) { reportGenericSchemaError ( "prefix : [" + prefix + "] can not be resolved to a URI" ) ; return "" ; } if ( prefix . length ( ) == 0 && uriStr . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && fTargetNSURIString . length ( ) == 0 ) { uriStr = "" ; } return uriStr ; } public TraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver , XMLErrorReporter errorReporter , String schemaURL ) throws Exception { fErrorReporter = errorReporter ; fCurrentSchemaURL = schemaURL ; doTraverseSchema ( root , stringPool , schemaGrammar , grammarResolver ) ; } public TraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver ) throws Exception { doTraverseSchema ( root , stringPool , schemaGrammar , grammarResolver ) ; } public void doTraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver ) throws Exception { fNamespacesScope = new NamespacesScope ( this ) ; fSchemaRootElement = root ; fStringPool = stringPool ; fSchemaGrammar = schemaGrammar ; fGrammarResolver = grammarResolver ; if ( root == null ) { return ; } String rootPrefix = root . getPrefix ( ) ; if ( rootPrefix == null || rootPrefix . length ( ) == 0 ) { String xmlns = root . getAttribute ( "xmlns" ) ; if ( xmlns . length ( ) == 0 ) root . setAttribute ( "xmlns" , SchemaSymbols . URI_SCHEMAFORSCHEMA ) ; } fTargetNSURIString = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( fTargetNSURIString == null ) { fTargetNSURIString = "" ; } fTargetNSURI = fStringPool . addSymbol ( fTargetNSURIString ) ; if ( fGrammarResolver == null ) { reportGenericSchemaError ( "Internal error: don't have a GrammarResolver for TraverseSchema" ) ; } else { fSchemaGrammar . setComplexTypeRegistry ( fComplexTypeRegistry ) ; fSchemaGrammar . setDatatypeRegistry ( fDatatypeRegistry ) ; fSchemaGrammar . setAttributeDeclRegistry ( fAttributeDeclRegistry ) ; fSchemaGrammar . setNamespacesScope ( fNamespacesScope ) ; fSchemaGrammar . setTargetNamespaceURI ( fTargetNSURIString ) ; fGrammarResolver . putGrammar ( fTargetNSURIString , fSchemaGrammar ) ; } NamedNodeMap schemaEltAttrs = root . getAttributes ( ) ; int i = 0 ; Attr sattr = null ; boolean seenXMLNS = false ; while ( ( sattr = ( Attr ) schemaEltAttrs . item ( i ++ ) ) != null ) { String attName = sattr . getName ( ) ; if ( attName . startsWith ( "xmlns:" ) ) { String attValue = sattr . getValue ( ) ; String prefix = attName . substring ( attName . indexOf ( ":" ) + 1 ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) , fStringPool . addSymbol ( attValue ) ) ; } if ( attName . equals ( "xmlns" ) ) { String attValue = sattr . getValue ( ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( attValue ) ) ; seenXMLNS = true ; } } if ( ! seenXMLNS && fTargetNSURIString . length ( ) == 0 ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } fElementDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ELEMENTFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; fAttributeDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ATTRIBUTEFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; if ( fTargetNSURI == StringPool . EMPTY_STRING ) { fElementDefaultQualified = true ; } fCurrentScope = - 1 ; checkTopLevelDuplicateNames ( root ) ; extractTopLevel3Components ( root ) ; for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { traverseSimpleTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { traverseComplexTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ELEMENT ) ) { traverseElementDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , null ) ; } else if ( name . equals ( SchemaSymbols . ELT_WILDCARD ) ) { traverseWildcardDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { } else if ( name . equals ( SchemaSymbols . ELT_NOTATION ) ) { ; } else if ( name . equals ( SchemaSymbols . ELT_INCLUDE ) ) { traverseInclude ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_IMPORT ) ) { traverseImport ( child ) ; } } } private void checkTopLevelDuplicateNames ( Element root ) { } private void extractTopLevel3Components ( Element root ) { for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { fSchemaGrammar . topLevelAttrGrpDecls . put ( name , child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { fSchemaGrammar . topLevelAttrDecls . put ( name , child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { fSchemaGrammar . topLevelGroupDecls . put ( name , child ) ; } } } private String expandSystemId ( String systemId , String currentSystemId ) throws Exception { String id = systemId ; if ( id == null || id . length ( ) == 0 ) { return systemId ; } try { URL url = new URL ( id ) ; if ( url != null ) { return systemId ; } } catch ( MalformedURLException e ) { } id = fixURI ( id ) ; URL base = null ; URL url = null ; try { if ( currentSystemId == null ) { String dir ; try { dir = fixURI ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { dir = "" ; } if ( ! dir . endsWith ( "/" ) ) { dir = dir + "/" ; } base = new URL ( "file" , "" , dir ) ; } else { base = new URL ( currentSystemId ) ; } url = new URL ( base , id ) ; } catch ( Exception e ) { } if ( url == null ) { return systemId ; } return url . toString ( ) ; } private static String fixURI ( String str ) { str = str . replace ( java . io . File . separatorChar , '/' ) ; if ( str . length ( ) >= 2 ) { char ch1 = str . charAt ( 1 ) ; if ( ch1 == ':' ) { char ch0 = Character . toUpperCase ( str . charAt ( 0 ) ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { str = "/" + str ; } } } return str ; } private void traverseInclude ( Element includeDecl ) throws Exception { String location = includeDecl . getAttribute ( SchemaSymbols . ATT_SCHEMALOCATION ) ; location = expandSystemId ( location , fCurrentSchemaURL ) ; if ( fIncludeLocations . contains ( ( Object ) location ) ) { return ; } fIncludeLocations . addElement ( ( Object ) location ) ; DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( location ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { } Document document = parser . getDocument ( ) ; Element root = null ; if ( document != null ) { root = document . getDocumentElement ( ) ; } if ( root != null ) { String targetNSURI = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( targetNSURI . length ( ) > 0 && ! targetNSURI . equals ( fTargetNSURIString ) ) { reportGenericSchemaError ( "included schema '" + location + "' has a different targetNameSpace '" + targetNSURI + "'" ) ; } else { boolean saveElementDefaultQualified = fElementDefaultQualified ; boolean saveAttributeDefaultQualified = fAttributeDefaultQualified ; int saveScope = fCurrentScope ; String savedSchemaURL = fCurrentSchemaURL ; Element saveRoot = fSchemaRootElement ; fSchemaRootElement = root ; fCurrentSchemaURL = location ; traverseIncludedSchema ( root ) ; fCurrentSchemaURL = savedSchemaURL ; fCurrentScope = saveScope ; fElementDefaultQualified = saveElementDefaultQualified ; fAttributeDefaultQualified = saveAttributeDefaultQualified ; fSchemaRootElement = saveRoot ; } } } private void traverseIncludedSchema ( Element root ) throws Exception { NamedNodeMap schemaEltAttrs = root . getAttributes ( ) ; int i = 0 ; Attr sattr = null ; boolean seenXMLNS = false ; while ( ( sattr = ( Attr ) schemaEltAttrs . item ( i ++ ) ) != null ) { String attName = sattr . getName ( ) ; if ( attName . startsWith ( "xmlns:" ) ) { String attValue = sattr . getValue ( ) ; String prefix = attName . substring ( attName . indexOf ( ":" ) + 1 ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) , fStringPool . addSymbol ( attValue ) ) ; } if ( attName . equals ( "xmlns" ) ) { String attValue = sattr . getValue ( ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( attValue ) ) ; seenXMLNS = true ; } } if ( ! seenXMLNS && fTargetNSURIString . length ( ) == 0 ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } fElementDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ELEMENTFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; fAttributeDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ATTRIBUTEFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; if ( fTargetNSURI == StringPool . EMPTY_STRING ) { fElementDefaultQualified = true ; } fCurrentScope = - 1 ; checkTopLevelDuplicateNames ( root ) ; extractTopLevel3Components ( root ) ; for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { traverseSimpleTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { traverseComplexTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ELEMENT ) ) { traverseElementDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , null ) ; } else if ( name . equals ( SchemaSymbols . ELT_WILDCARD ) ) { traverseWildcardDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { } else if ( name . equals ( SchemaSymbols . ELT_NOTATION ) ) { ; } else if ( name . equals ( SchemaSymbols . ELT_INCLUDE ) ) { traverseInclude ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_IMPORT ) ) { traverseImport ( child ) ; } } } private void traverseImport ( Element importDecl ) throws Exception { String location = importDecl . getAttribute ( SchemaSymbols . ATT_SCHEMALOCATION ) ; location = expandSystemId ( location , fCurrentSchemaURL ) ; String namespaceString = importDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) ; SchemaGrammar importedGrammar = new SchemaGrammar ( ) ; if ( fGrammarResolver . getGrammar ( namespaceString ) != null ) { importedGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( namespaceString ) ; } if ( fImportLocations . contains ( ( Object ) location ) ) { return ; } fImportLocations . addElement ( ( Object ) location ) ; DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( location ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } Document document = parser . getDocument ( ) ; Element root = null ; if ( document != null ) { root = document . getDocumentElement ( ) ; } if ( root != null ) { String targetNSURI = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( ! targetNSURI . equals ( namespaceString ) ) { reportGenericSchemaError ( "imported schema '" + location + "' has a different targetNameSpace '" + targetNSURI + "' from what is declared '" + namespaceString + "'." ) ; } else new TraverseSchema ( root , fStringPool , importedGrammar , fGrammarResolver , fErrorReporter , location ) ; } else { reportGenericSchemaError ( "Could not get the doc root for imported Schema file: " + location ) ; } } private void traverseAnnotationDecl ( Element comment ) { return ; } private int traverseSimpleTypeDecl ( Element simpleTypeDecl ) throws Exception { String varietyProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_DERIVEDBY ) ; if ( varietyProperty . length ( ) == 0 ) { varietyProperty = SchemaSymbols . ATTVAL_RESTRICTION ; } String nameProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; String baseTypeQNameProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) ; String abstractProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) ; int newSimpleTypeName = - 1 ; if ( nameProperty . equals ( "" ) ) { newSimpleTypeName = fStringPool . addSymbol ( "#S#" + fSimpleTypeAnonCount ++ ) ; } else newSimpleTypeName = fStringPool . addSymbol ( nameProperty ) ; int basetype ; DatatypeValidator baseValidator = null ; if ( baseTypeQNameProperty != null ) { basetype = fStringPool . addSymbol ( baseTypeQNameProperty ) ; String prefix = "" ; String localpart = baseTypeQNameProperty ; int colonptr = baseTypeQNameProperty . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = baseTypeQNameProperty . substring ( 0 , colonptr ) ; localpart = baseTypeQNameProperty . substring ( colonptr + 1 ) ; } String uri = resolvePrefixToURI ( prefix ) ; baseValidator = getDatatypeValidator ( uri , localpart ) ; if ( baseValidator == null ) { Element baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( baseTypeNode != null ) { traverseSimpleTypeDecl ( baseTypeNode ) ; baseValidator = getDatatypeValidator ( uri , localpart ) ; if ( baseValidator == null ) { reportSchemaError ( SchemaMessageProvider . UnknownBaseDatatype , new Object [ ] { simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) , simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) } ) ; return - 1 ; } } else { reportSchemaError ( SchemaMessageProvider . UnknownBaseDatatype , new Object [ ] { simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) , simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) } ) ; return - 1 ; } } } Element content = XUtil . getFirstChildElement ( simpleTypeDecl ) ; int numFacets = 0 ; Hashtable facetData = null ; if ( content != null ) { if ( content . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content ) ; content = XUtil . getNextSiblingElement ( content ) ; } int numEnumerationLiterals = 0 ; facetData = new Hashtable ( ) ; Vector enumData = new Vector ( ) ; while ( content != null ) { if ( content . getNodeType ( ) == Node . ELEMENT_NODE ) { Element facetElt = ( Element ) content ; numFacets ++ ; if ( facetElt . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { numEnumerationLiterals ++ ; String enumVal = facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ; enumData . addElement ( enumVal ) ; Element enumContent = XUtil . getFirstChildElement ( facetElt ) ; if ( enumContent != null && enumContent != null && enumContent . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content ) ; } } else { facetData . put ( facetElt . getNodeName ( ) , facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; } } content = XUtil . getNextSiblingElement ( content ) ; } if ( numEnumerationLiterals > 0 ) { facetData . put ( SchemaSymbols . ELT_ENUMERATION , enumData ) ; } } String nameOfType = fStringPool . toString ( newSimpleTypeName ) ; if ( fTargetNSURIString . length ( ) != 0 ) { nameOfType = fTargetNSURIString + "," + nameOfType ; } try { DatatypeValidator newValidator = fDatatypeRegistry . getDatatypeValidator ( nameOfType ) ; if ( newValidator == null ) { boolean derivedByList = varietyProperty . equals ( SchemaSymbols . ATTVAL_LIST ) ? true : false ; fDatatypeRegistry . createDatatypeValidator ( nameOfType , baseValidator , facetData , derivedByList ) ; } } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . DatatypeError , new Object [ ] { e . getMessage ( ) } ) ; } return fStringPool . addSymbol ( nameOfType ) ; } private int traverseAny ( Element child ) throws Exception { int anyIndex = - 1 ; String namespace = child . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) . trim ( ) ; String processContents = child . getAttribute ( "processContents" ) . trim ( ) ; int processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY ; int processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ; int processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ; if ( processContents . length ( ) > 0 && ! processContents . equals ( "strict" ) ) { if ( processContents . equals ( "lax" ) ) { processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY_LAX ; processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_LAX ; processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_LAX ; } else if ( processContents . equals ( "skip" ) ) { processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY_SKIP ; processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_SKIP ; processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_SKIP ; } } if ( namespace . length ( ) == 0 || namespace . equals ( "##any" ) ) { anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , - 1 , false ) ; } else if ( namespace . equals ( "##other" ) ) { String uri = child . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; int uriIndex = fStringPool . addSymbol ( uri ) ; anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAnyOther , - 1 , uriIndex , false ) ; } else if ( namespace . equals ( "##local" ) ) { anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAnyLocal , - 1 , - 1 , false ) ; } else if ( namespace . length ( ) > 0 ) { StringTokenizer tokenizer = new StringTokenizer ( namespace ) ; Vector tokens = new Vector ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( "##targetNamespace" ) ) { token = child . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; } tokens . addElement ( token ) ; } String uri = ( String ) tokens . elementAt ( 0 ) ; int uriIndex = fStringPool . addSymbol ( uri ) ; int leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; int valueIndex = leafIndex ; int count = tokens . size ( ) ; if ( count > 1 ) { uri = ( String ) tokens . elementAt ( 1 ) ; uriIndex = fStringPool . addSymbol ( uri ) ; leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; int otherValueIndex = leafIndex ; int choiceIndex = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , valueIndex , otherValueIndex , false ) ; for ( int i = 2 ; i < count ; i ++ ) { uri = ( String ) tokens . elementAt ( i ) ; uriIndex = fStringPool . addSymbol ( uri ) ; leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; otherValueIndex = leafIndex ; choiceIndex = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , choiceIndex , otherValueIndex , false ) ; } anyIndex = choiceIndex ; } else { anyIndex = leafIndex ; } } else { reportGenericSchemaError ( "Empty namespace attribute for any element" ) ; } return anyIndex ; } public DatatypeValidator getDatatypeValidator ( String uri , String localpart ) { DatatypeValidator dv = null ; if ( uri . length ( ) == 0 || uri . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { dv = fDatatypeRegistry . getDatatypeValidator ( localpart ) ; } else { dv = fDatatypeRegistry . getDatatypeValidator ( uri + "," + localpart ) ; } return dv ; } private XMLAttributeDecl traverseAnyAttribute ( Element anyAttributeDecl ) throws Exception { XMLAttributeDecl anyAttDecl = new XMLAttributeDecl ( ) ; String processContents = anyAttributeDecl . getAttribute ( SchemaSymbols . ATT_PROCESSCONTENTS ) . trim ( ) ; String namespace = anyAttributeDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) . trim ( ) ; String curTargetUri = anyAttributeDecl . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; if ( namespace . length ( ) == 0 || namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDANY ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_ANY ; } else if ( namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDOTHER ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_OTHER ; anyAttDecl . name . uri = fStringPool . addSymbol ( curTargetUri ) ; } else if ( namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDLOCAL ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_LOCAL ; } else if ( namespace . length ( ) > 0 ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_LIST ; StringTokenizer tokenizer = new StringTokenizer ( namespace ) ; int aStringList = fStringPool . startStringList ( ) ; Vector tokens = new Vector ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( "##targetNamespace" ) ) { token = curTargetUri ; } if ( ! fStringPool . addStringToList ( aStringList , fStringPool . addSymbol ( token ) ) ) { reportGenericSchemaError ( "Internal StringPool error when reading the " + "namespace attribute for anyattribute declaration" ) ; } } fStringPool . finishStringList ( aStringList ) ; anyAttDecl . enumeration = aStringList ; } else { reportGenericSchemaError ( "Empty namespace attribute for anyattribute declaration" ) ; } anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_STRICT ; if ( processContents . equals ( SchemaSymbols . ATTVAL_SKIP ) ) { anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_SKIP ; } else if ( processContents . equals ( SchemaSymbols . ATTVAL_LAX ) ) { anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_LAX ; } return anyAttDecl ; } private XMLAttributeDecl mergeTwoAnyAttribute ( XMLAttributeDecl oneAny , XMLAttributeDecl anotherAny ) { if ( oneAny . type == - 1 ) { return oneAny ; } if ( anotherAny . type == - 1 ) { return anotherAny ; } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return anotherAny ; } if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return oneAny ; } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( anotherAny . name . uri == oneAny . name . uri ) { return oneAny ; } else { oneAny . type = - 1 ; return oneAny ; } } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { return anotherAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( ! fStringPool . stringInList ( anotherAny . enumeration , oneAny . name . uri ) ) { return anotherAny ; } else { int [ ] anotherAnyURIs = fStringPool . stringListAsIntArray ( anotherAny . enumeration ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < anotherAnyURIs . length ; i ++ ) { if ( anotherAnyURIs [ i ] != oneAny . name . uri ) { fStringPool . addStringToList ( newList , anotherAnyURIs [ i ] ) ; } } fStringPool . finishStringList ( newList ) ; anotherAny . enumeration = newList ; return anotherAny ; } } } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER || anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { return oneAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { oneAny . type = - 1 ; return oneAny ; } } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( ! fStringPool . stringInList ( oneAny . enumeration , anotherAny . name . uri ) ) { return oneAny ; } else { int [ ] oneAnyURIs = fStringPool . stringListAsIntArray ( oneAny . enumeration ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < oneAnyURIs . length ; i ++ ) { if ( oneAnyURIs [ i ] != anotherAny . name . uri ) { fStringPool . addStringToList ( newList , oneAnyURIs [ i ] ) ; } } fStringPool . finishStringList ( newList ) ; oneAny . enumeration = newList ; return oneAny ; } } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { oneAny . type = - 1 ; return oneAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { int [ ] result = intersect2sets ( fStringPool . stringListAsIntArray ( oneAny . enumeration ) , fStringPool . stringListAsIntArray ( anotherAny . enumeration ) ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < result . length ; i ++ ) { fStringPool . addStringToList ( newList , result [ i ] ) ; } fStringPool . finishStringList ( newList ) ; oneAny . enumeration = newList ; return oneAny ; } } return oneAny ; } int [ ] intersect2sets ( int [ ] one , int [ ] theOther ) { int [ ] result = new int [ ( one . length > theOther . length ? one . length : theOther . length ) ] ; int count = 0 ; for ( int i = 0 ; i < one . length ; i ++ ) { for ( int j = 0 ; j < theOther . length ; j ++ ) { if ( one [ i ] == theOther [ j ] ) { result [ count ++ ] = one [ i ] ; } } } int [ ] result2 = new int [ count ] ; System . arraycopy ( result , 0 , result2 , 0 , count ) ; return result2 ; } private int traverseComplexTypeDecl ( Element complexTypeDecl ) throws Exception { String isAbstract = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) ; String base = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) ; String blockSet = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ; String content = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_CONTENT ) ; String derivedBy = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_DERIVEDBY ) ; String finalSet = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ; String typeId = complexTypeDecl . getAttribute ( SchemaSymbols . ATTVAL_ID ) ; String typeName = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; boolean isNamedType = false ; if ( DEBUGGING ) System . out . println ( "traversing complex Type : " + typeName + "," + base + "," + content + "." ) ; if ( typeName . equals ( "" ) ) { typeName = "#" + fAnonTypeCount ++ ; } else { fCurrentTypeNameStack . push ( typeName ) ; isNamedType = true ; } if ( isTopLevel ( complexTypeDecl ) ) { String fullName = fTargetNSURIString + "," + typeName ; ComplexTypeInfo temp = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fullName ) ; if ( temp != null ) { return fStringPool . addSymbol ( fullName ) ; } } int scopeDefined = fScopeCount ++ ; int previousScope = fCurrentScope ; fCurrentScope = scopeDefined ; Element child = null ; int contentSpecType = - 1 ; int csnType = 0 ; int left = - 2 ; int right = - 2 ; ComplexTypeInfo baseTypeInfo = null ; DatatypeValidator baseTypeValidator = null ; DatatypeValidator simpleTypeValidator = null ; int baseTypeSymbol = - 1 ; String fullBaseName = "" ; boolean baseIsSimpleSimple = false ; boolean baseIsComplexSimple = false ; boolean derivedByRestriction = true ; boolean derivedByExtension = false ; int baseContentSpecHandle = - 1 ; Element baseTypeNode = null ; if ( base . length ( ) > 0 ) { if ( derivedBy . length ( ) == 0 ) { reportGenericSchemaError ( "derivedBy must be present when base is present in " + SchemaSymbols . ELT_COMPLEXTYPE + " " + typeName ) ; } else { if ( derivedBy . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { derivedByRestriction = false ; } String prefix = "" ; String localpart = base ; int colonptr = base . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = base . substring ( 0 , colonptr ) ; localpart = base . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String typeURI = resolvePrefixToURI ( prefix ) ; if ( ! typeURI . equals ( fTargetNSURIString ) && ! typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && typeURI . length ( ) != 0 ) { baseTypeInfo = getTypeInfoFromNS ( typeURI , localpart ) ; if ( baseTypeInfo == null ) { baseTypeValidator = getTypeValidatorFromNS ( typeURI , localpart ) ; if ( baseTypeValidator == null ) { System . out . println ( "Could not find base type " + localpart + " in schema " + typeURI ) ; } else { baseIsSimpleSimple = true ; } } } else { fullBaseName = typeURI + "," + localpart ; baseTypeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fullBaseName ) ; if ( baseTypeInfo == null ) { baseTypeValidator = getDatatypeValidator ( typeURI , localpart ) ; if ( baseTypeValidator == null ) { baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_COMPLEXTYPE , localpart ) ; if ( baseTypeNode != null ) { baseTypeSymbol = traverseComplexTypeDecl ( baseTypeNode ) ; baseTypeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( baseTypeSymbol ) ) ; } else { baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( baseTypeNode != null ) { baseTypeSymbol = traverseSimpleTypeDecl ( baseTypeNode ) ; simpleTypeValidator = baseTypeValidator = getDatatypeValidator ( typeURI , localpart ) ; if ( simpleTypeValidator == null ) { } baseIsSimpleSimple = true ; } else { reportGenericSchemaError ( "Base type could not be found : " + base ) ; } } } else { simpleTypeValidator = baseTypeValidator ; baseIsSimpleSimple = true ; } } } if ( baseIsSimpleSimple && derivedByRestriction ) { reportGenericSchemaError ( "base is a simpledType, can't derive by restriction in " + typeName ) ; } if ( baseTypeInfo != null ) { if ( derivedByRestriction ) { } else { } if ( baseTypeInfo . contentSpecHandle > - 1 ) { if ( derivedByRestriction ) { checkParticleDerivationOK ( complexTypeDecl , baseTypeNode ) ; } baseContentSpecHandle = baseTypeInfo . contentSpecHandle ; } else if ( baseTypeInfo . datatypeValidator != null ) { baseTypeValidator = baseTypeInfo . datatypeValidator ; baseIsComplexSimple = true ; } } if ( baseIsComplexSimple && ! derivedByRestriction ) { reportGenericSchemaError ( "base is ComplexSimple, can't derive by extension in " + typeName ) ; } } } child = null ; if ( baseIsComplexSimple ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; int numEnumerationLiterals = 0 ; int numFacets = 0 ; Hashtable facetData = new Hashtable ( ) ; Vector enumData = new Vector ( ) ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null && ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MININCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PRECISION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SCALE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_LENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MINLENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXLENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENCODING ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PERIOD ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_DURATION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PATTERN ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { Element facetElt = ( Element ) child ; numFacets ++ ; if ( facetElt . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { numEnumerationLiterals ++ ; enumData . addElement ( facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; Element enumContent = XUtil . getFirstChildElement ( facetElt ) ; if ( enumContent != null && enumContent . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } } else { facetData . put ( facetElt . getNodeName ( ) , facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; } } } if ( numEnumerationLiterals > 0 ) { facetData . put ( SchemaSymbols . ELT_ENUMERATION , enumData ) ; } if ( numFacets > 0 ) { simpleTypeValidator = fDatatypeRegistry . createDatatypeValidator ( typeName , baseTypeValidator , facetData , false ) ; } else simpleTypeValidator = baseTypeValidator ; if ( child != null ) { reportGenericSchemaError ( "Invalid child '" + child . getNodeName ( ) + "' in complexType : '" + typeName + "', because it restricts another complexSimpleType" ) ; } } if ( content . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { if ( base . length ( ) == 0 ) { simpleTypeValidator = baseTypeValidator = getDatatypeValidator ( "" , SchemaSymbols . ATTVAL_STRING ) ; } else if ( baseTypeValidator == null && baseTypeInfo != null && baseTypeInfo . datatypeValidator == null ) reportSchemaError ( SchemaMessageProvider . NotADatatype , new Object [ ] { base } ) ; contentSpecType = XMLElementDecl . TYPE_SIMPLE ; } else { if ( ! baseIsComplexSimple ) { contentSpecType = XMLElementDecl . TYPE_CHILDREN ; } csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; boolean mixedContent = false ; boolean elementContent = true ; boolean textContent = false ; boolean emptyContent = false ; left = - 2 ; right = - 2 ; boolean hadContent = false ; if ( content . equals ( SchemaSymbols . ATTVAL_EMPTY ) ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; emptyContent = true ; elementContent = false ; left = - 1 ; } else if ( content . equals ( SchemaSymbols . ATTVAL_MIXED ) ) { contentSpecType = XMLElementDecl . TYPE_MIXED ; mixedContent = true ; elementContent = false ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; } else if ( content . equals ( SchemaSymbols . ATTVAL_ELEMENTONLY ) || content . equals ( "" ) ) { elementContent = true ; } else if ( content . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { textContent = true ; elementContent = false ; } if ( mixedContent ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , - 1 , - 1 , false ) ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; } boolean seeParticle = false ; boolean seeOtherParticle = false ; boolean seeAll = false ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { if ( mixedContent || elementContent ) { if ( DEBUGGING ) System . out . println ( " child element name " + child . getAttribute ( SchemaSymbols . ATT_NAME ) ) ; QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; seeOtherParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . EltRefOnlyInMixedElemOnly , null ) ; } } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeParticle = true ; seeAll = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTE ) || childName . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { break ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } else if ( childName . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { break ; } else { if ( ! baseIsComplexSimple ) if ( base . equals ( "" ) ) reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "unrecogized child '" + childName + "' in compelx type " + typeName } ) ; else reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "unrecogized child '" + childName + "' in compelx type '" + typeName + "' with base " + base } ) ; } if ( baseIsComplexSimple && seeParticle ) { reportGenericSchemaError ( "In complexType " + typeName + ", base type is complextype with simpleType content, can't have any particle children at all" ) ; hadContent = false ; left = index = - 2 ; contentSpecType = XMLElementDecl . TYPE_SIMPLE ; break ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( seeAll && seeOtherParticle ) { reportGenericSchemaError ( " 'All' group needs to be the only child in Complextype : " + typeName ) ; } if ( seeAll ) { } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( ! ( seeOtherParticle || seeAll ) && ( elementContent || mixedContent ) && ( base . length ( ) == 0 || ( base . length ( ) > 0 && derivedByRestriction && ! baseIsComplexSimple ) ) ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; simpleTypeValidator = getDatatypeValidator ( "" , SchemaSymbols . ATTVAL_STRING ) ; reportGenericSchemaError ( " complexType '" + typeName + "' with a elementOnly or mixed content " + "need to have at least one particle child" ) ; } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; if ( mixedContent && hadContent ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , left , - 1 , false ) ; } } if ( ! derivedByRestriction && baseContentSpecHandle > - 1 ) { if ( left == - 2 ) { left = baseContentSpecHandle ; } else left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , baseContentSpecHandle , left , false ) ; } if ( content . length ( ) == 0 && base . length ( ) == 0 && left == - 2 ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } if ( content . length ( ) == 0 && simpleTypeValidator == null && left == - 2 ) { if ( base . length ( ) > 0 && baseTypeInfo != null && baseTypeInfo . contentType == XMLElementDecl . TYPE_EMPTY ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; } } if ( DEBUGGING ) System . out . println ( "!!!!!>>>>>" + typeName + ", " + baseTypeInfo + ", " + baseContentSpecHandle + ", " + left + ", " + scopeDefined ) ; ComplexTypeInfo typeInfo = new ComplexTypeInfo ( ) ; typeInfo . baseComplexTypeInfo = baseTypeInfo ; typeInfo . baseDataTypeValidator = baseTypeValidator ; int derivedByInt = - 1 ; if ( derivedBy . length ( ) > 0 ) { derivedByInt = parseComplexDerivedBy ( derivedBy ) ; } typeInfo . derivedBy = derivedByInt ; typeInfo . scopeDefined = scopeDefined ; typeInfo . contentSpecHandle = left ; typeInfo . contentType = contentSpecType ; typeInfo . datatypeValidator = simpleTypeValidator ; typeInfo . blockSet = parseBlockSet ( complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ) ; typeInfo . finalSet = parseFinalSet ( complexTypeDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ) ; typeInfo . isAbstract = isAbstract . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; int typeNameIndex = fStringPool . addSymbol ( typeName ) ; int templateElementNameIndex = fStringPool . addSymbol ( "$" + typeName ) ; typeInfo . templateElementIndex = fSchemaGrammar . addElementDecl ( new QName ( - 1 , templateElementNameIndex , typeNameIndex , fTargetNSURI ) , ( fTargetNSURI == - 1 ) ? - 1 : fCurrentScope , scopeDefined , contentSpecType , left , - 1 , simpleTypeValidator ) ; typeInfo . attlistHead = fSchemaGrammar . getFirstAttributeDeclIndex ( typeInfo . templateElementIndex ) ; XMLAttributeDecl attWildcard = null ; Vector anyAttDecls = new Vector ( ) ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { if ( ( baseIsComplexSimple || baseIsSimpleSimple ) && derivedByRestriction ) { reportGenericSchemaError ( "In complexType " + typeName + ", base type has simpleType " + "content and derivation method is" + " 'restriction', can't have any " + "attribute children at all" ) ; break ; } traverseAttributeDecl ( child , typeInfo ) ; } else if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { if ( ( baseIsComplexSimple || baseIsSimpleSimple ) && derivedByRestriction ) { reportGenericSchemaError ( "In complexType " + typeName + ", base " + "type has simpleType content and " + "derivation method is 'restriction'," + " can't have any attribute children at all" ) ; break ; } traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( childName . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { attWildcard = traverseAnyAttribute ( child ) ; } } if ( attWildcard != null ) { XMLAttributeDecl fromGroup = null ; final int count = anyAttDecls . size ( ) ; if ( count > 0 ) { fromGroup = ( XMLAttributeDecl ) anyAttDecls . elementAt ( 0 ) ; for ( int i = 1 ; i < count ; i ++ ) { fromGroup = mergeTwoAnyAttribute ( fromGroup , ( XMLAttributeDecl ) anyAttDecls . elementAt ( i ) ) ; } } if ( fromGroup != null ) { int saveProcessContents = attWildcard . defaultType ; attWildcard = mergeTwoAnyAttribute ( attWildcard , fromGroup ) ; attWildcard . defaultType = saveProcessContents ; } } else { } XMLAttributeDecl baseAttWildcard = null ; if ( baseTypeInfo != null && baseTypeInfo . attlistHead > - 1 ) { int attDefIndex = baseTypeInfo . attlistHead ; while ( attDefIndex > - 1 ) { fTempAttributeDecl . clear ( ) ; fSchemaGrammar . getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_ANY || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_LIST || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( attWildcard == null ) { baseAttWildcard = fTempAttributeDecl ; } attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; continue ; } int temp = fSchemaGrammar . getAttributeDeclIndex ( typeInfo . templateElementIndex , fTempAttributeDecl . name ) ; if ( temp > - 1 ) { if ( derivedByRestriction ) { attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; continue ; } } fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , fTempAttributeDecl . name , fTempAttributeDecl . type , fTempAttributeDecl . enumeration , fTempAttributeDecl . defaultType , fTempAttributeDecl . defaultValue , fTempAttributeDecl . datatypeValidator , fTempAttributeDecl . list ) ; attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } if ( attWildcard != null ) { if ( attWildcard . type != - 1 ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , attWildcard . name , attWildcard . type , attWildcard . enumeration , attWildcard . defaultType , attWildcard . defaultValue , attWildcard . datatypeValidator , attWildcard . list ) ; } else { } } else if ( baseAttWildcard != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , baseAttWildcard . name , baseAttWildcard . type , baseAttWildcard . enumeration , baseAttWildcard . defaultType , baseAttWildcard . defaultValue , baseAttWildcard . datatypeValidator , baseAttWildcard . list ) ; } typeInfo . attlistHead = fSchemaGrammar . getFirstAttributeDeclIndex ( typeInfo . templateElementIndex ) ; if ( ! typeName . startsWith ( "#" ) ) { typeName = fTargetNSURIString + "," + typeName ; } typeInfo . typeName = new String ( typeName ) ; if ( DEBUGGING ) System . out . println ( "add complex Type to Registry: " + typeName + "," + content + "." ) ; fComplexTypeRegistry . put ( typeName , typeInfo ) ; fCurrentScope = previousScope ; if ( isNamedType ) { fCurrentTypeNameStack . pop ( ) ; checkRecursingComplexType ( ) ; } fSchemaGrammar . setElementComplexTypeInfo ( typeInfo . templateElementIndex , typeInfo ) ; typeNameIndex = fStringPool . addSymbol ( typeName ) ; return typeNameIndex ; } private void checkRecursingComplexType ( ) throws Exception { if ( fCurrentTypeNameStack . empty ( ) ) { if ( ! fElementRecurseComplex . isEmpty ( ) ) { Enumeration e = fElementRecurseComplex . keys ( ) ; while ( e . hasMoreElements ( ) ) { QName nameThenScope = ( QName ) e . nextElement ( ) ; String typeName = ( String ) fElementRecurseComplex . get ( nameThenScope ) ; int eltUriIndex = nameThenScope . uri ; int eltNameIndex = nameThenScope . localpart ; int enclosingScope = nameThenScope . prefix ; ComplexTypeInfo typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fTargetNSURIString + "," + typeName ) ; if ( typeInfo == null ) { throw new Exception ( "Internal Error in void checkRecursingComplexType(). " ) ; } else { int elementIndex = fSchemaGrammar . addElementDecl ( new QName ( - 1 , eltNameIndex , eltNameIndex , eltUriIndex ) , enclosingScope , typeInfo . scopeDefined , typeInfo . contentType , typeInfo . contentSpecHandle , typeInfo . attlistHead , typeInfo . datatypeValidator ) ; fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } } fElementRecurseComplex . clear ( ) ; } } } private void checkParticleDerivationOK ( Element derivedTypeNode , Element baseTypeNode ) { } private int expandContentModel ( int index , Element particle ) throws Exception { String minOccurs = particle . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ; String maxOccurs = particle . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ; int min = 1 , max = 1 ; if ( minOccurs . equals ( "" ) ) { minOccurs = "1" ; } if ( maxOccurs . equals ( "" ) ) { if ( minOccurs . equals ( "0" ) ) { maxOccurs = "1" ; } else { maxOccurs = minOccurs ; } } int leafIndex = index ; if ( minOccurs . equals ( "1" ) && maxOccurs . equals ( "1" ) ) { } else if ( minOccurs . equals ( "0" ) && maxOccurs . equals ( "1" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , index , - 1 , false ) ; } else if ( minOccurs . equals ( "0" ) && maxOccurs . equals ( "unbounded" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , index , - 1 , false ) ; } else if ( minOccurs . equals ( "1" ) && maxOccurs . equals ( "unbounded" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , index , - 1 , false ) ; } else if ( maxOccurs . equals ( "unbounded" ) ) { try { min = Integer . parseInt ( minOccurs ) ; } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "illegal value for minOccurs : '" + e . getMessage ( ) + "' " } ) ; } if ( min < 2 ) { } index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , index , - 1 , false ) ; for ( int i = 0 ; i < ( min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , leafIndex , index , false ) ; } } else { try { min = Integer . parseInt ( minOccurs ) ; max = Integer . parseInt ( maxOccurs ) ; } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "illegal value for minOccurs or maxOccurs : '" + e . getMessage ( ) + "' " } ) ; } if ( min == 0 ) { int optional = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , leafIndex , - 1 , false ) ; index = optional ; for ( int i = 0 ; i < ( max - min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , optional , false ) ; } } else { for ( int i = 0 ; i < ( min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , leafIndex , false ) ; } int optional = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , leafIndex , - 1 , false ) ; for ( int i = 0 ; i < ( max - min ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , optional , false ) ; } } } return index ; } private int traverseAttributeDecl ( Element attrDecl , ComplexTypeInfo typeInfo ) throws Exception { String attNameStr = attrDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; int attName = fStringPool . addSymbol ( attNameStr ) ; String isQName = attrDecl . getAttribute ( SchemaSymbols . ATT_FORM ) ; DatatypeValidator dv = null ; int attType = - 1 ; boolean attIsList = false ; int dataTypeSymbol = - 1 ; String ref = attrDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; String datatype = attrDecl . getAttribute ( SchemaSymbols . ATT_TYPE ) ; String localpart = null ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( attrDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { addAttributeDeclFromAnotherSchema ( localpart , uriStr , typeInfo ) ; return - 1 ; } Element referredAttribute = getTopLevelComponentByName ( SchemaSymbols . ELT_ATTRIBUTE , localpart ) ; if ( referredAttribute != null ) { traverseAttributeDecl ( referredAttribute , typeInfo ) ; } else { reportGenericSchemaError ( "Couldn't find top level attribute " + ref ) ; } return - 1 ; } if ( datatype . equals ( "" ) ) { Element child = XUtil . getFirstChildElement ( attrDecl ) ; while ( child != null && ! child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) child = XUtil . getNextSiblingElement ( child ) ; if ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { attType = XMLAttributeDecl . TYPE_SIMPLE ; dataTypeSymbol = traverseSimpleTypeDecl ( child ) ; localpart = fStringPool . toString ( dataTypeSymbol ) ; } else { attType = XMLAttributeDecl . TYPE_SIMPLE ; localpart = "string" ; dataTypeSymbol = fStringPool . addSymbol ( localpart ) ; } localpart = fStringPool . toString ( dataTypeSymbol ) ; dv = fDatatypeRegistry . getDatatypeValidator ( localpart ) ; } else { String prefix = "" ; localpart = datatype ; dataTypeSymbol = fStringPool . addSymbol ( localpart ) ; int colonptr = datatype . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = datatype . substring ( 0 , colonptr ) ; localpart = datatype . substring ( colonptr + 1 ) ; } String typeURI = resolvePrefixToURI ( prefix ) ; if ( typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) || typeURI . length ( ) == 0 ) { dv = getDatatypeValidator ( "" , localpart ) ; if ( localpart . equals ( "ID" ) ) { attType = XMLAttributeDecl . TYPE_ID ; } else if ( localpart . equals ( "IDREF" ) ) { attType = XMLAttributeDecl . TYPE_IDREF ; } else if ( localpart . equals ( "IDREFS" ) ) { attType = XMLAttributeDecl . TYPE_IDREF ; attIsList = true ; } else if ( localpart . equals ( "ENTITY" ) ) { attType = XMLAttributeDecl . TYPE_ENTITY ; } else if ( localpart . equals ( "ENTITIES" ) ) { attType = XMLAttributeDecl . TYPE_ENTITY ; attIsList = true ; } else if ( localpart . equals ( "NMTOKEN" ) ) { attType = XMLAttributeDecl . TYPE_NMTOKEN ; } else if ( localpart . equals ( "NMTOKENS" ) ) { attType = XMLAttributeDecl . TYPE_NMTOKEN ; attIsList = true ; } else if ( localpart . equals ( SchemaSymbols . ELT_NOTATION ) ) { attType = XMLAttributeDecl . TYPE_NOTATION ; } else { attType = XMLAttributeDecl . TYPE_SIMPLE ; if ( dv == null && typeURI . length ( ) == 0 ) { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { reportGenericSchemaError ( "simpleType not found : " + localpart ) ; } } } } else { dv = getDatatypeValidator ( typeURI , localpart ) ; if ( dv == null && typeURI . equals ( fTargetNSURIString ) ) { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { reportGenericSchemaError ( "simpleType not found : " + localpart ) ; } } attType = XMLAttributeDecl . TYPE_SIMPLE ; } } int attDefaultType = - 1 ; int attDefaultValue = - 1 ; String use = attrDecl . getAttribute ( SchemaSymbols . ATT_USE ) ; boolean required = use . equals ( SchemaSymbols . ATTVAL_REQUIRED ) ; if ( dv == null ) { reportGenericSchemaError ( "could not resolve the type or get a null validator for datatype : " + fStringPool . toString ( dataTypeSymbol ) ) ; } if ( required ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; } else { if ( use . equals ( SchemaSymbols . ATTVAL_FIXED ) ) { String fixed = attrDecl . getAttribute ( SchemaSymbols . ATT_VALUE ) ; if ( ! fixed . equals ( "" ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_FIXED ; attDefaultValue = fStringPool . addString ( fixed ) ; } } else if ( use . equals ( SchemaSymbols . ATTVAL_DEFAULT ) ) { String defaultValue = attrDecl . getAttribute ( SchemaSymbols . ATT_VALUE ) ; if ( ! defaultValue . equals ( "" ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_DEFAULT ; attDefaultValue = fStringPool . addString ( defaultValue ) ; } } else if ( use . equals ( SchemaSymbols . ATTVAL_PROHIBITED ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } else { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } if ( attType == XMLAttributeDecl . TYPE_SIMPLE && attDefaultValue != - 1 ) { try { if ( dv != null ) dv . validate ( fStringPool . toString ( attDefaultValue ) , null ) ; else reportSchemaError ( SchemaMessageProvider . NoValidatorFor , new Object [ ] { datatype } ) ; } catch ( InvalidDatatypeValueException idve ) { reportSchemaError ( SchemaMessageProvider . IncorrectDefaultType , new Object [ ] { attrDecl . getAttribute ( SchemaSymbols . ATT_NAME ) , idve . getMessage ( ) } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . out . println ( "Internal error in attribute datatype validation" ) ; } } } int uriIndex = - 1 ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fAttributeDefaultQualified || isTopLevel ( attrDecl ) ) { uriIndex = fTargetNSURI ; } QName attQName = new QName ( - 1 , attName , attName , uriIndex ) ; if ( DEBUGGING ) System . out . println ( " the dataType Validator for " + fStringPool . toString ( attName ) + " is " + dv ) ; if ( isTopLevel ( attrDecl ) ) { fTempAttributeDecl . datatypeValidator = dv ; fTempAttributeDecl . name . setValues ( attQName ) ; fTempAttributeDecl . type = attType ; fTempAttributeDecl . defaultType = attDefaultType ; fTempAttributeDecl . list = attIsList ; if ( attDefaultValue != - 1 ) { fTempAttributeDecl . defaultValue = new String ( fStringPool . toString ( attDefaultValue ) ) ; } fAttributeDeclRegistry . put ( attNameStr , new XMLAttributeDecl ( fTempAttributeDecl ) ) ; } if ( typeInfo != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , attQName , attType , dataTypeSymbol , attDefaultType , fStringPool . toString ( attDefaultValue ) , dv , attIsList ) ; } return - 1 ; } private int addAttributeDeclFromAnotherSchema ( String name , String uriStr , ComplexTypeInfo typeInfo ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #addAttributeDeclFromAnotherSchema, schema uri : " + uriStr ) ; return - 1 ; } Hashtable attrRegistry = aGrammar . getAttirubteDeclRegistry ( ) ; if ( attrRegistry == null ) { reportGenericSchemaError ( "no attribute was defined in schema : " + uriStr ) ; return - 1 ; } XMLAttributeDecl tempAttrDecl = ( XMLAttributeDecl ) attrRegistry . get ( name ) ; if ( tempAttrDecl == null ) { reportGenericSchemaError ( "no attribute named \"" + name + "\" was defined in schema : " + uriStr ) ; return - 1 ; } if ( typeInfo != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , tempAttrDecl . name , tempAttrDecl . type , - 1 , tempAttrDecl . defaultType , tempAttrDecl . defaultValue , tempAttrDecl . datatypeValidator , tempAttrDecl . list ) ; } return 0 ; } private int traverseAttributeGroupDecl ( Element attrGrpDecl , ComplexTypeInfo typeInfo , Vector anyAttDecls ) throws Exception { int attGrpName = fStringPool . addSymbol ( attrGrpDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ) ; String ref = attrGrpDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; int attType = - 1 ; int enumeration = - 1 ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( attrGrpDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { traverseAttributeGroupDeclFromAnotherSchema ( localpart , uriStr , typeInfo , anyAttDecls ) ; return - 1 ; } Element referredAttrGrp = getTopLevelComponentByName ( SchemaSymbols . ELT_ATTRIBUTEGROUP , localpart ) ; if ( referredAttrGrp != null ) { traverseAttributeGroupDecl ( referredAttrGrp , typeInfo , anyAttDecls ) ; } else { reportGenericSchemaError ( "Couldn't find top level attributegroup " + ref ) ; } return - 1 ; } for ( Element child = XUtil . getFirstChildElement ( attrGrpDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , typeInfo ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { anyAttDecls . addElement ( traverseAnyAttribute ( child ) ) ; break ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } } return - 1 ; } private int traverseAttributeGroupDeclFromAnotherSchema ( String attGrpName , String uriStr , ComplexTypeInfo typeInfo , Vector anyAttDecls ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #traverseAttributeGroupDeclFromAnotherSchema, schema uri : " + uriStr ) ; return - 1 ; } Element attGrpDecl = ( Element ) aGrammar . topLevelAttrGrpDecls . get ( ( Object ) attGrpName ) ; if ( attGrpDecl == null ) { reportGenericSchemaError ( "no attribute group named \"" + attGrpName + "\" was defined in schema : " + uriStr ) ; return - 1 ; } NamespacesScope saveNSMapping = fNamespacesScope ; int saveTargetNSUri = fTargetNSURI ; fTargetNSURI = fStringPool . addSymbol ( aGrammar . getTargetNamespaceURI ( ) ) ; fNamespacesScope = aGrammar . getNamespacesScope ( ) ; int attType = - 1 ; int enumeration = - 1 ; for ( Element child = XUtil . getFirstChildElement ( attGrpDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { String childAttName = child . getAttribute ( SchemaSymbols . ATT_NAME ) ; if ( childAttName . length ( ) > 0 ) { Hashtable attDeclRegistry = aGrammar . getAttirubteDeclRegistry ( ) ; if ( attDeclRegistry != null ) { if ( attDeclRegistry . get ( ( Object ) childAttName ) != null ) { addAttributeDeclFromAnotherSchema ( childAttName , uriStr , typeInfo ) ; return - 1 ; } } } else traverseAttributeDecl ( child , typeInfo ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { anyAttDecls . addElement ( traverseAnyAttribute ( child ) ) ; break ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } } fNamespacesScope = saveNSMapping ; fTargetNSURI = saveTargetNSUri ; return - 1 ; } private QName traverseElementDecl ( Element elementDecl ) throws Exception { int contentSpecType = - 1 ; int contentSpecNodeIndex = - 1 ; int typeNameIndex = - 1 ; int scopeDefined = - 2 ; DatatypeValidator dv = null ; String name = elementDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; if ( DEBUGGING ) System . out . println ( "traversing element decl : " + name ) ; String ref = elementDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; String type = elementDecl . getAttribute ( SchemaSymbols . ATT_TYPE ) ; String minOccurs = elementDecl . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ; String maxOccurs = elementDecl . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ; String dflt = elementDecl . getAttribute ( SchemaSymbols . ATT_DEFAULT ) ; String fixed = elementDecl . getAttribute ( SchemaSymbols . ATT_FIXED ) ; String equivClass = elementDecl . getAttribute ( SchemaSymbols . ATT_EQUIVCLASS ) ; String isQName = elementDecl . getAttribute ( SchemaSymbols . ATT_FORM ) ; String fromAnotherSchema = null ; if ( isTopLevel ( elementDecl ) ) { int nameIndex = fStringPool . addSymbol ( name ) ; int eltKey = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , nameIndex , TOP_LEVEL_SCOPE ) ; if ( eltKey > - 1 ) { return new QName ( - 1 , nameIndex , nameIndex , fTargetNSURI ) ; } } int blockSet = parseBlockSet ( elementDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ) ; int finalSet = parseFinalSet ( elementDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ) ; boolean isNullable = elementDecl . getAttribute ( SchemaSymbols . ATT_NULLABLE ) . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; boolean isAbstract = elementDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; int elementMiscFlags = 0 ; if ( isNullable ) { elementMiscFlags += SchemaSymbols . NULLABLE ; } if ( isAbstract ) { elementMiscFlags += SchemaSymbols . ABSTRACT ; } int attrCount = 0 ; if ( ! ref . equals ( "" ) ) attrCount ++ ; if ( ! type . equals ( "" ) ) attrCount ++ ; if ( attrCount > 1 ) reportSchemaError ( SchemaMessageProvider . OneOfTypeRefArchRef , null ) ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( elementDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String uriString = resolvePrefixToURI ( prefix ) ; QName eltName = new QName ( prefix != null ? fStringPool . addSymbol ( prefix ) : - 1 , localpartIndex , fStringPool . addSymbol ( ref ) , uriString != null ? fStringPool . addSymbol ( uriString ) : - 1 ) ; if ( ! uriString . equals ( fTargetNSURIString ) ) { return eltName ; } int elementIndex = fSchemaGrammar . getElementDeclIndex ( eltName , TOP_LEVEL_SCOPE ) ; if ( elementIndex == - 1 ) { Element targetElement = getTopLevelComponentByName ( SchemaSymbols . ELT_ELEMENT , localpart ) ; if ( targetElement == null ) { reportGenericSchemaError ( "Element " + localpart + " not found in the Schema" ) ; return eltName ; } else { } } return eltName ; } Element equivClassElementDecl = null ; int equivClassElementDeclIndex = - 1 ; boolean noErrorSoFar = true ; String equivClassUri = null ; String equivClassLocalpart = null ; String equivClassFullName = null ; ComplexTypeInfo equivClassEltTypeInfo = null ; DatatypeValidator equivClassEltDV = null ; if ( equivClass . length ( ) > 0 ) { equivClassUri = resolvePrefixToURI ( getPrefix ( equivClass ) ) ; equivClassLocalpart = getLocalPart ( equivClass ) ; equivClassFullName = equivClassUri + "," + equivClassLocalpart ; if ( ! equivClassUri . equals ( fTargetNSURIString ) ) { equivClassEltTypeInfo = getElementDeclTypeInfoFromNS ( equivClassUri , equivClassLocalpart ) ; if ( equivClassEltTypeInfo == null ) { equivClassEltDV = getElementDeclTypeValidatorFromNS ( equivClassUri , equivClassLocalpart ) ; if ( equivClassEltDV == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type for element '" + equivClassLocalpart + "' in schema '" + equivClassUri + "'" ) ; } } } else { equivClassElementDecl = getTopLevelComponentByName ( SchemaSymbols . ELT_ELEMENT , equivClassLocalpart ) ; if ( equivClassElementDecl == null ) { equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; if ( equivClassElementDeclIndex == - 1 ) { noErrorSoFar = false ; reportGenericSchemaError ( "Equivclass affiliation element " + equivClass + " in element declaration " + name ) ; } } else { equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; if ( equivClassElementDeclIndex == - 1 ) { traverseElementDecl ( equivClassElementDecl ) ; equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; } } if ( equivClassElementDeclIndex != - 1 ) { equivClassEltTypeInfo = fSchemaGrammar . getElementComplexTypeInfo ( equivClassElementDeclIndex ) ; if ( equivClassEltTypeInfo == null ) { fSchemaGrammar . getElementDecl ( equivClassElementDeclIndex , fTempElementDecl ) ; equivClassEltDV = fTempElementDecl . datatypeValidator ; if ( equivClassEltDV == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type for element '" + equivClassLocalpart + "' in schema '" + equivClassUri + "'" ) ; } } } } } ComplexTypeInfo typeInfo = null ; Element child = XUtil . getFirstChildElement ( elementDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; boolean haveAnonType = false ; if ( child != null ) { String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . length ( ) > 0 ) { noErrorSoFar = false ; reportGenericSchemaError ( "anonymous complexType in element '" + name + "' has a name attribute" ) ; } else typeNameIndex = traverseComplexTypeDecl ( child ) ; if ( typeNameIndex != - 1 ) { typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( typeNameIndex ) ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "traverse complexType error in element '" + name + "'" ) ; } haveAnonType = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . length ( ) > 0 ) { noErrorSoFar = false ; reportGenericSchemaError ( "anonymous simpleType in element '" + name + "' has a name attribute" ) ; } else typeNameIndex = traverseSimpleTypeDecl ( child ) ; if ( typeNameIndex != - 1 ) { dv = fDatatypeRegistry . getDatatypeValidator ( fStringPool . toString ( typeNameIndex ) ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "traverse simpleType error in element '" + name + "'" ) ; } contentSpecType = XMLElementDecl . TYPE_SIMPLE ; haveAnonType = true ; } else if ( type . equals ( "" ) ) { contentSpecType = XMLElementDecl . TYPE_ANY ; contentSpecNodeIndex = - 1 ; } else { System . out . println ( "unhandled case in TraverseElementDecl" ) ; } } if ( haveAnonType && ( type . length ( ) > 0 ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "Element '" + name + "' have both a type attribute and a annoymous type child" ) ; } else if ( ! type . equals ( "" ) ) { if ( equivClassElementDecl != null ) { checkEquivClassOK ( elementDecl , equivClassElementDecl ) ; } String prefix = "" ; String localpart = type ; int colonptr = type . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = type . substring ( 0 , colonptr ) ; localpart = type . substring ( colonptr + 1 ) ; } String typeURI = resolvePrefixToURI ( prefix ) ; if ( ! typeURI . equals ( fTargetNSURIString ) && ! typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && typeURI . length ( ) != 0 ) { fromAnotherSchema = typeURI ; typeInfo = getTypeInfoFromNS ( typeURI , localpart ) ; if ( typeInfo == null ) { dv = getTypeValidatorFromNS ( typeURI , localpart ) ; if ( dv == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type " + localpart + " in schema " + typeURI ) ; } } } else { typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( typeURI + "," + localpart ) ; if ( typeInfo == null ) { dv = getDatatypeValidator ( typeURI , localpart ) ; if ( dv == null ) if ( typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && ! fTargetNSURIString . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "type not found : " + typeURI + ":" + localpart ) ; } else { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_COMPLEXTYPE , localpart ) ; if ( topleveltype != null ) { if ( fCurrentTypeNameStack . search ( ( Object ) localpart ) > - 1 ) { int uriInd = - 1 ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fElementDefaultQualified ) { uriInd = fTargetNSURI ; } int nameIndex = fStringPool . addSymbol ( name ) ; QName tempQName = new QName ( fCurrentScope , nameIndex , nameIndex , uriInd ) ; fElementRecurseComplex . put ( tempQName , localpart ) ; return new QName ( - 1 , nameIndex , nameIndex , uriInd ) ; } else { typeNameIndex = traverseComplexTypeDecl ( topleveltype ) ; typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( typeNameIndex ) ) ; } } else { topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { typeNameIndex = traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "type not found : " + typeURI + ":" + localpart ) ; } } } } } } else if ( haveAnonType ) { if ( equivClassElementDecl != null ) { checkEquivClassOK ( elementDecl , equivClassElementDecl ) ; } } else { if ( typeInfo == null && dv == null ) typeInfo = equivClassEltTypeInfo ; if ( typeInfo == null && dv == null ) dv = equivClassEltDV ; } if ( typeInfo == null && dv == null ) { if ( noErrorSoFar ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "untyped element : " + name ) ; } } if ( typeInfo != null ) { contentSpecNodeIndex = typeInfo . contentSpecHandle ; contentSpecType = typeInfo . contentType ; scopeDefined = typeInfo . scopeDefined ; dv = typeInfo . datatypeValidator ; } if ( dv != null ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; } child = XUtil . getFirstChildElement ( elementDecl ) ; Vector idConstraints = null ; while ( child != null ) { String childName = child . getNodeName ( ) ; child = XUtil . getNextSiblingElement ( child ) ; } int elementNameIndex = fStringPool . addSymbol ( name ) ; int localpartIndex = elementNameIndex ; int uriIndex = - 1 ; int enclosingScope = fCurrentScope ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fElementDefaultQualified ) { uriIndex = fTargetNSURI ; } if ( isTopLevel ( elementDecl ) ) { uriIndex = fTargetNSURI ; enclosingScope = TOP_LEVEL_SCOPE ; } int existSuchElementIndex = fSchemaGrammar . getElementDeclIndex ( uriIndex , localpartIndex , enclosingScope ) ; if ( existSuchElementIndex > - 1 ) { fSchemaGrammar . getElementDecl ( existSuchElementIndex , fTempElementDecl ) ; DatatypeValidator edv = fTempElementDecl . datatypeValidator ; ComplexTypeInfo eTypeInfo = fSchemaGrammar . getElementComplexTypeInfo ( existSuchElementIndex ) ; if ( ( ( eTypeInfo != null ) && ( eTypeInfo != typeInfo ) ) || ( ( edv != null ) && ( edv != dv ) ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "duplicate element decl in the same scope : " + fStringPool . toString ( localpartIndex ) ) ; } } QName eltQName = new QName ( - 1 , localpartIndex , elementNameIndex , uriIndex ) ; int attrListHead = - 1 ; if ( typeInfo != null ) { attrListHead = typeInfo . attlistHead ; } int elementIndex = fSchemaGrammar . addElementDecl ( eltQName , enclosingScope , scopeDefined , contentSpecType , contentSpecNodeIndex , attrListHead , dv ) ; if ( DEBUGGING ) { System . out . println ( "########elementIndex:" + elementIndex + " (" + fStringPool . toString ( eltQName . uri ) + "," + fStringPool . toString ( eltQName . localpart ) + ")" + " eltType:" + type + " contentSpecType:" + contentSpecType + " SpecNodeIndex:" + contentSpecNodeIndex + " enclosingScope: " + enclosingScope + " scopeDefined: " + scopeDefined + "\n" ) ; } if ( typeInfo != null ) { fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } else { fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } fSchemaGrammar . setElementFromAnotherSchemaURI ( elementIndex , fromAnotherSchema ) ; fSchemaGrammar . setElementDeclBlockSet ( elementIndex , blockSet ) ; fSchemaGrammar . setElementDeclFinalSet ( elementIndex , finalSet ) ; fSchemaGrammar . setElementDeclMiscFlags ( elementIndex , elementMiscFlags ) ; fSchemaGrammar . setElementDeclEquivClassElementFullName ( elementIndex , equivClassFullName ) ; return eltQName ; } int getLocalPartIndex ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String localpart = fullName ; if ( colonAt > - 1 ) { localpart = fullName . substring ( colonAt + 1 ) ; } return fStringPool . addSymbol ( localpart ) ; } String getLocalPart ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String localpart = fullName ; if ( colonAt > - 1 ) { localpart = fullName . substring ( colonAt + 1 ) ; } return localpart ; } int getPrefixIndex ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String prefix = "" ; if ( colonAt > - 1 ) { prefix = fullName . substring ( 0 , colonAt ) ; } return fStringPool . addSymbol ( prefix ) ; } String getPrefix ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String prefix = "" ; if ( colonAt > - 1 ) { prefix = fullName . substring ( 0 , colonAt ) ; } return prefix ; } private void checkEquivClassOK ( Element elementDecl , Element equivClassElementDecl ) { } private Element getTopLevelComponentByName ( String componentCategory , String name ) throws Exception { Element child = XUtil . getFirstChildElement ( fSchemaRootElement ) ; if ( child == null ) { return null ; } while ( child != null ) { if ( child . getNodeName ( ) . equals ( componentCategory ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . equals ( name ) ) { return child ; } } child = XUtil . getNextSiblingElement ( child ) ; } return null ; } private boolean isTopLevel ( Element component ) { if ( component . getParentNode ( ) . getNodeName ( ) . endsWith ( SchemaSymbols . ELT_SCHEMA ) ) { return true ; } return false ; } DatatypeValidator getTypeValidatorFromNS ( String newSchemaURI , String localpart ) throws Exception { return getDatatypeValidator ( newSchemaURI , localpart ) ; } ComplexTypeInfo getTypeInfoFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; ComplexTypeInfo typeInfo = ( ComplexTypeInfo ) sGrammar . getComplexTypeRegistry ( ) . get ( newSchemaURI + "," + localpart ) ; return typeInfo ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getTypeInfoFromNS" ) ; } return null ; } DatatypeValidator getElementDeclTypeValidatorFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; int eltIndex = sGrammar . getElementDeclIndex ( fStringPool . addSymbol ( newSchemaURI ) , fStringPool . addSymbol ( localpart ) , TOP_LEVEL_SCOPE ) ; DatatypeValidator dv = null ; if ( eltIndex > - 1 ) { sGrammar . getElementDecl ( eltIndex , fTempElementDecl ) ; dv = fTempElementDecl . datatypeValidator ; } else { reportGenericSchemaError ( "could not find global element : '" + localpart + " in the SchemaGrammar " + newSchemaURI ) ; } return dv ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getELementDeclTypeValidatorFromNS" ) ; } return null ; } ComplexTypeInfo getElementDeclTypeInfoFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; int eltIndex = sGrammar . getElementDeclIndex ( fStringPool . addSymbol ( newSchemaURI ) , fStringPool . addSymbol ( localpart ) , TOP_LEVEL_SCOPE ) ; ComplexTypeInfo typeInfo = null ; if ( eltIndex > - 1 ) { typeInfo = sGrammar . getElementComplexTypeInfo ( eltIndex ) ; } else { reportGenericSchemaError ( "could not find global element : '" + localpart + " in the SchemaGrammar " + newSchemaURI ) ; } return typeInfo ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getElementDeclTypeInfoFromNS" ) ; } return null ; } private int traverseGroupDecl ( Element groupDecl ) throws Exception { String groupName = groupDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; String ref = groupDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( groupDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { return traverseGroupDeclFromAnotherSchema ( localpart , uriStr ) ; } int contentSpecIndex = - 1 ; Element referredGroup = getTopLevelComponentByName ( SchemaSymbols . ELT_GROUP , localpart ) ; if ( referredGroup == null ) { reportGenericSchemaError ( "Group " + localpart + " not found in the Schema" ) ; throw new Exception ( "Group " + localpart + " not found in the Schema" ) ; } else { contentSpecIndex = traverseGroupDecl ( referredGroup ) ; } return contentSpecIndex ; } boolean traverseElt = true ; if ( fCurrentScope == TOP_LEVEL_SCOPE ) { traverseElt = false ; } Element child = XUtil . getFirstChildElement ( groupDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; int allChildren [ ] = null ; int allChildCount = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; boolean seeAll = false ; boolean seeParticle = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean illegalChild = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeAll = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { illegalChild = true ; reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( ! illegalChild ) { index = expandContentModel ( index , child ) ; } if ( seeParticle && seeAll ) { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "'all' needs to be 'the' only Child" , childName } ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } private int traverseGroupDeclFromAnotherSchema ( String groupName , String uriStr ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #traverseGroupDeclFromAnotherSchema, " + "schema uri: " + uriStr + ", groupName: " + groupName ) ; return - 1 ; } Element groupDecl = ( Element ) aGrammar . topLevelGroupDecls . get ( ( Object ) groupName ) ; if ( groupDecl == null ) { reportGenericSchemaError ( "no group named \"" + groupName + "\" was defined in schema : " + uriStr ) ; return - 1 ; } NamespacesScope saveNSMapping = fNamespacesScope ; int saveTargetNSUri = fTargetNSURI ; fTargetNSURI = fStringPool . addSymbol ( aGrammar . getTargetNamespaceURI ( ) ) ; fNamespacesScope = aGrammar . getNamespacesScope ( ) ; boolean traverseElt = true ; if ( fCurrentScope == TOP_LEVEL_SCOPE ) { traverseElt = false ; } Element child = XUtil . getFirstChildElement ( groupDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; int allChildren [ ] = null ; int allChildCount = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; int childNameIndex = fStringPool . addSymbol ( childName ) ; String formAttrVal = child . getAttribute ( SchemaSymbols . ATT_FORM ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; fNamespacesScope = saveNSMapping ; fTargetNSURI = saveTargetNSUri ; return left ; } int traverseSequence ( Element sequenceDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( sequenceDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } int traverseChoice ( Element choiceDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( choiceDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } int traverseAll ( Element allDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( allDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int allChildren [ ] = null ; int allChildCount = 0 ; int left = - 2 ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } try { allChildren [ allChildCount ] = index ; } catch ( NullPointerException ne ) { allChildren = new int [ 32 ] ; allChildren [ allChildCount ] = index ; } catch ( ArrayIndexOutOfBoundsException ae ) { int [ ] newArray = new int [ allChildren . length * 2 ] ; System . arraycopy ( allChildren , 0 , newArray , 0 , allChildren . length ) ; allChildren [ allChildCount ] = index ; } allChildCount ++ ; } left = buildAllModel ( allChildren , allChildCount ) ; return left ; } private int buildAllModel ( int children [ ] , int count ) throws Exception { if ( count > 1 ) { XMLContentSpec choice = new XMLContentSpec ( ) ; choice . type = XMLContentSpec . CONTENTSPECNODE_CHOICE ; choice . value = - 1 ; choice . otherValue = - 1 ; int [ ] exactChildren = new int [ count ] ; System . arraycopy ( children , 0 , exactChildren , 0 , count ) ; sort ( exactChildren , 0 , count ) ; int index = buildAllModel ( exactChildren , 0 , choice ) ; return index ; } if ( count > 0 ) { return children [ 0 ] ; } return - 1 ; } private int buildAllModel ( int src [ ] , int offset , XMLContentSpec choice ) throws Exception { if ( src . length - offset == 2 ) { int seqIndex = createSeq ( src ) ; if ( choice . value == - 1 ) { choice . value = seqIndex ; } else { if ( choice . otherValue != - 1 ) { choice . value = fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } choice . otherValue = seqIndex ; } swap ( src , offset , offset + 1 ) ; seqIndex = createSeq ( src ) ; if ( choice . value == - 1 ) { choice . value = seqIndex ; } else { if ( choice . otherValue != - 1 ) { choice . value = fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } choice . otherValue = seqIndex ; } return fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } for ( int i = offset ; i < src . length - 1 ; i ++ ) { choice . value = buildAllModel ( src , offset + 1 , choice ) ; choice . otherValue = - 1 ; sort ( src , offset , src . length - offset ) ; shift ( src , offset , i + 1 ) ; } int choiceIndex = buildAllModel ( src , offset + 1 , choice ) ; sort ( src , offset , src . length - offset ) ; return choiceIndex ; } private int createSeq ( int src [ ] ) throws Exception { int left = src [ 0 ] ; int right = src [ 1 ] ; for ( int i = 2 ; i < src . length ; i ++ ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , left , right , false ) ; right = src [ i ] ; } return fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , left , right , false ) ; } private void shift ( int src [ ] , int pos , int offset ) { int temp = src [ offset ] ; for ( int i = offset ; i > pos ; i -- ) { src [ i ] = src [ i - 1 ] ; } src [ pos ] = temp ; } private void sort ( int src [ ] , final int offset , final int length ) { for ( int i = offset ; i < offset + length - 1 ; i ++ ) { int lowest = i ; for ( int j = i + 1 ; j < offset + length ; j ++ ) { if ( src [ j ] < src [ lowest ] ) { lowest = j ; } } if ( lowest != i ) { int temp = src [ i ] ; src [ i ] = src [ lowest ] ; src [ lowest ] = temp ; } } } private void swap ( int src [ ] , int i , int j ) { int temp = src [ i ] ; src [ i ] = src [ j ] ; src [ j ] = temp ; } private int traverseWildcardDecl ( Element wildcardDecl ) throws Exception { int wildcardID = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATTVAL_ID ) ) ; int wildcardMaxOccurs = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ) ; int wildcardMinOccurs = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ) ; int wildcardNamespace = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) ) ; int wildcardProcessContents = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_PROCESSCONTENTS ) ) ; int wildcardContent = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_CONTENT ) ) ; return - 1 ; } private int parseInt ( String intString ) throws Exception { if ( intString . equals ( "*" ) ) { return SchemaSymbols . INFINITY ; } else { return Integer . parseInt ( intString ) ; } } private int parseSimpleDerivedBy ( String derivedByString ) throws Exception { if ( derivedByString . equals ( SchemaSymbols . ATTVAL_LIST ) ) { return SchemaSymbols . LIST ; } else if ( derivedByString . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { return SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "SimpleType: Invalid value for 'derivedBy'" ) ; return - 1 ; } } private int parseComplexDerivedBy ( String derivedByString ) throws Exception { if ( derivedByString . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { return SchemaSymbols . EXTENSION ; } else if ( derivedByString . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { return SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "ComplexType: Invalid value for 'derivedBy'" ) ; return - 1 ; } } private int parseSimpleFinal ( String finalString ) throws Exception { if ( finalString . equals ( SchemaSymbols . ATTVAL_POUNDALL ) ) { return SchemaSymbols . ENUMERATION + SchemaSymbols . RESTRICTION + SchemaSymbols . LIST + SchemaSymbols . REPRODUCTION ; } else { int enumerate = 0 ; int restrict = 0 ; int list = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction in set twice" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( list == 0 ) { list = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "list in set twice" ) ; } } else { reportGenericSchemaError ( "Invalid value (" + finalString + ")" ) ; } } return enumerate + restrict + list + reproduce ; } } private int parseComplexContent ( String contentString ) throws Exception { if ( contentString . equals ( SchemaSymbols . ATTVAL_EMPTY ) ) { return XMLElementDecl . TYPE_EMPTY ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_ELEMENTONLY ) ) { return XMLElementDecl . TYPE_CHILDREN ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { return XMLElementDecl . TYPE_SIMPLE ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_MIXED ) ) { return XMLElementDecl . TYPE_MIXED ; } else { reportGenericSchemaError ( "Invalid value for content" ) ; return - 1 ; } } private int parseDerivationSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EXTENSION + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private int parseBlockSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EQUIVCLASS + SchemaSymbols . EXTENSION + SchemaSymbols . LIST + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EQUIVCLASS ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EQUIVCLASS ; } else { reportGenericSchemaError ( "'equivClass' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( extend == 0 ) { extend = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "'list' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private int parseFinalSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EQUIVCLASS + SchemaSymbols . EXTENSION + SchemaSymbols . LIST + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EQUIVCLASS ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EQUIVCLASS ; } else { reportGenericSchemaError ( "'equivClass' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( extend == 0 ) { extend = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "'list' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private void reportGenericSchemaError ( String error ) throws Exception { if ( fErrorReporter == null ) { System . err . println ( "__TraverseSchemaError__ : " + error ) ; } else { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { error } ) ; } } private void reportSchemaError ( int major , Object args [ ] ) throws Exception { if ( fErrorReporter == null ) { System . out . println ( "__TraverseSchemaError__ : " + SchemaMessageProvider . fgMessageKeys [ major ] ) ; for ( int i = 0 ; i < args . length ; i ++ ) { System . out . println ( ( String ) args [ i ] ) ; } } else { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , major , SchemaMessageProvider . MSG_NONE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } public static void main ( String args [ ] ) { if ( args . length != 1 ) { System . out . println ( "Error: Usage java TraverseSchema yourFile.xsd" ) ; System . exit ( 0 ) ; } DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( args [ 0 ] ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } Document document = parser . getDocument ( ) ; OutputFormat format = new OutputFormat ( document ) ; java . io . StringWriter outWriter = new java . io . StringWriter ( ) ; XMLSerializer serial = new XMLSerializer ( outWriter , format ) ; TraverseSchema tst = null ; try { Element root = document . getDocumentElement ( ) ; tst = new TraverseSchema ( root , new StringPool ( ) , new SchemaGrammar ( ) , ( GrammarResolver ) new GrammarResolverImpl ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } parser . getDocument ( ) ; } static class Resolver implements EntityResolver { private static final String SYSTEM [ ] = { "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/structures.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/datatypes.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/versionInfo.ent" , } ; private static final String PATH [ ] = { "structures.dtd" , "datatypes.dtd" , "versionInfo.ent" , } ; public InputSource resolveEntity ( String publicId , String systemId ) throws IOException { for ( int i = 0 ; i < SYSTEM . length ; i ++ ) { if ( systemId . equals ( SYSTEM [ i ] ) ) { InputSource source = new InputSource ( getClass ( ) . getResourceAsStream ( PATH [ i ] ) ) ; source . setPublicId ( publicId ) ; source . setSystemId ( systemId ) ; return source ; } } return null ; } } static class ErrorHandler implements org . xml . sax . ErrorHandler { public void warning ( SAXParseException ex ) { System . err . println ( "[Warning] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { System . err . println ( "[Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) throws SAXException { System . err . println ( "[Fatal Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; throw ex ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId_ = ex . getSystemId ( ) ; if ( systemId_ != null ) { int index = systemId_ . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId_ = systemId_ . substring ( index + 1 ) ; str . append ( systemId_ ) ; } str . append ( ':' ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( ':' ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } } } 	1
package org . apache . wml ; public interface WMLOptionElement extends WMLElement { public void setValue ( String newValue ) ; public String getValue ( ) ; public void setTitle ( String newValue ) ; public String getTitle ( ) ; public void setOnPick ( String href ) ; public String getOnPick ( ) ; public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . w3c . dom ; public interface Node { public static final short ELEMENT_NODE = 1 ; public static final short ATTRIBUTE_NODE = 2 ; public static final short TEXT_NODE = 3 ; public static final short CDATA_SECTION_NODE = 4 ; public static final short ENTITY_REFERENCE_NODE = 5 ; public static final short ENTITY_NODE = 6 ; public static final short PROCESSING_INSTRUCTION_NODE = 7 ; public static final short COMMENT_NODE = 8 ; public static final short DOCUMENT_NODE = 9 ; public static final short DOCUMENT_TYPE_NODE = 10 ; public static final short DOCUMENT_FRAGMENT_NODE = 11 ; public static final short NOTATION_NODE = 12 ; public String getNodeName ( ) ; public String getNodeValue ( ) throws DOMException ; public void setNodeValue ( String nodeValue ) throws DOMException ; public short getNodeType ( ) ; public Node getParentNode ( ) ; public NodeList getChildNodes ( ) ; public Node getFirstChild ( ) ; public Node getLastChild ( ) ; public Node getPreviousSibling ( ) ; public Node getNextSibling ( ) ; public NamedNodeMap getAttributes ( ) ; public Document getOwnerDocument ( ) ; public Node insertBefore ( Node newChild , Node refChild ) throws DOMException ; public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException ; public Node removeChild ( Node oldChild ) throws DOMException ; public Node appendChild ( Node newChild ) throws DOMException ; public boolean hasChildNodes ( ) ; public Node cloneNode ( boolean deep ) ; public void normalize ( ) ; public boolean supports ( String feature , String version ) ; public String getNamespaceURI ( ) ; public String getPrefix ( ) ; public void setPrefix ( String prefix ) throws DOMException ; public String getLocalName ( ) ; public boolean hasAttributes ( ) ; } 	1
package org . apache . xerces . utils ; import org . apache . xerces . readers . XMLEntityHandler ; public final class ChunkyCharArray implements XMLEntityHandler . CharBuffer { public ChunkyCharArray ( StringPool stringPool ) { fStringPool = stringPool ; fCurrentChunk = CharDataChunk . createChunk ( stringPool , null ) ; } public int length ( ) { return fLength ; } public void append ( char ch ) { try { fCurrentData [ fCurrentIndex ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { if ( fCurrentIndex == CharDataChunk . CHUNK_SIZE ) { fCurrentChunk = CharDataChunk . createChunk ( fStringPool , fCurrentChunk ) ; fCurrentData = new char [ INITIAL_CHUNK_SIZE ] ; fCurrentIndex = 0 ; } else { char [ ] newData = new char [ fCurrentIndex * 2 ] ; System . arraycopy ( fCurrentData , 0 , newData , 0 , fCurrentIndex ) ; fCurrentData = newData ; } fCurrentChunk . setCharArray ( fCurrentData ) ; fCurrentData [ fCurrentIndex ] = ch ; } catch ( NullPointerException ex ) { fCurrentData = new char [ INITIAL_CHUNK_SIZE ] ; fCurrentChunk . setCharArray ( fCurrentData ) ; fCurrentData [ fCurrentIndex ] = ch ; } fCurrentIndex ++ ; fLength ++ ; } public void append ( String s ) { int slen = s . length ( ) ; for ( int i = 0 ; i < slen ; i ++ ) append ( s . charAt ( i ) ) ; } public void append ( char [ ] ch , int offset , int length ) { while ( length -- > 0 ) append ( ch [ offset ++ ] ) ; } public void append ( ChunkyCharArray charArray , int offset , int length ) { fCurrentChunk . append ( charArray , offset , length ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } private static final int INITIAL_CHUNK_SHIFT = 7 ; private static final int INITIAL_CHUNK_SIZE = ( 1 << INITIAL_CHUNK_SHIFT ) ; private StringPool fStringPool = null ; private CharDataChunk fCurrentChunk = null ; private char [ ] fCurrentData = null ; private int fCurrentIndex = 0 ; private int fLength = 0 ; } 	0
package org . w3c . dom ; public interface Entity extends Node { public String getPublicId ( ) ; public String getSystemId ( ) ; public String getNotationName ( ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLHRElementImpl extends HTMLElementImpl implements HTMLHRElement { public String getAlign ( ) { return capitalize ( getAttribute ( "align" ) ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public boolean getNoShade ( ) { return getBinary ( "noshade" ) ; } public void setNoShade ( boolean noShade ) { setAttribute ( "noshade" , noShade ) ; } public String getSize ( ) { return getAttribute ( "size" ) ; } public void setSize ( String size ) { setAttribute ( "size" , size ) ; } public String getWidth ( ) { return getAttribute ( "width" ) ; } public void setWidth ( String width ) { setAttribute ( "width" , width ) ; } public HTMLHRElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom ; public interface Text extends CharacterData { public Text splitText ( int offset ) throws DOMException ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLAnchorElementImpl extends WMLElementImpl implements WMLAnchorElement { public WMLAnchorElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setTitle ( String newValue ) { setAttribute ( "title" , newValue ) ; } public String getTitle ( ) { return getAttribute ( "title" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . Node ; public interface NodeFilter { public static final short FILTER_ACCEPT = 1 ; public static final short FILTER_REJECT = 2 ; public static final short FILTER_SKIP = 3 ; public static final int SHOW_ALL = 0xFFFFFFFF ; public static final int SHOW_ELEMENT = 0x00000001 ; public static final int SHOW_ATTRIBUTE = 0x00000002 ; public static final int SHOW_TEXT = 0x00000004 ; public static final int SHOW_CDATA_SECTION = 0x00000008 ; public static final int SHOW_ENTITY_REFERENCE = 0x00000010 ; public static final int SHOW_ENTITY = 0x00000020 ; public static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040 ; public static final int SHOW_COMMENT = 0x00000080 ; public static final int SHOW_DOCUMENT = 0x00000100 ; public static final int SHOW_DOCUMENT_TYPE = 0x00000200 ; public static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400 ; public static final int SHOW_NOTATION = 0x00000800 ; public short acceptNode ( Node n ) ; } 	1
package org . apache . wml ; public interface WMLImgElement extends WMLElement { public void setAlt ( String newValue ) ; public String getAlt ( ) ; public void setSrc ( String newValue ) ; public String getSrc ( ) ; public void setLocalSrc ( String newValue ) ; public String getLocalSrc ( ) ; public void setVspace ( String newValue ) ; public String getVspace ( ) ; public void setHspace ( String newValue ) ; public String getHspace ( ) ; public void setAlign ( String newValue ) ; public String getAlign ( ) ; public void setWidth ( String newValue ) ; public String getWidth ( ) ; public void setHeight ( String newValue ) ; public String getHeight ( ) ; public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . w3c . dom ; public interface Notation extends Node { public String getPublicId ( ) ; public String getSystemId ( ) ; } 	1
package org . w3c . dom . html ; public interface HTMLHRElement extends HTMLElement { public String getAlign ( ) ; public void setAlign ( String align ) ; public boolean getNoShade ( ) ; public void setNoShade ( boolean noShade ) ; public String getSize ( ) ; public void setSize ( String size ) ; public String getWidth ( ) ; public void setWidth ( String width ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public abstract class CharacterDataImpl extends ChildNode { static final long serialVersionUID = 7931170150428474230L ; protected String data ; private static transient NodeList singletonNodeList = new NodeList ( ) { public Node item ( int index ) { return null ; } public int getLength ( ) { return 0 ; } } ; protected CharacterDataImpl ( DocumentImpl ownerDocument , String data ) { super ( ownerDocument ) ; this . data = data ; } public NodeList getChildNodes ( ) { return singletonNodeList ; } public String getNodeValue ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } void setNodeValueInternal ( String value ) { setValueCalled ( true ) ; setNodeValue ( value ) ; setValueCalled ( false ) ; } public void setNodeValue ( String value ) { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; if ( needsSyncData ( ) ) { synchronizeData ( ) ; } String oldvalue = value ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } this . data = value ; if ( ! setValueCalled ( ) ) { ownerDocument ( ) . replacedText ( this ) ; } if ( MUTATIONEVENTS ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_CHARACTER_DATA_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_CHARACTER_DATA_MODIFIED , true , false , null , oldvalue , value , null ) ; dispatchEvent ( me ) ; } dispatchAggregateEvents ( enclosingAttr ) ; } } public String getData ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } public int getLength ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data . length ( ) ; } public void appendData ( String data ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } setNodeValue ( this . data + data ) ; } public void deleteData ( int offset , int count ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( count < 0 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int tailLength = Math . max ( data . length ( ) - count - offset , 0 ) ; try { setNodeValueInternal ( data . substring ( 0 , offset ) + ( tailLength > 0 ? data . substring ( offset + count , offset + count + tailLength ) : "" ) ) ; ownerDocument ( ) . deletedText ( this , offset , count ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } public void insertData ( int offset , String data ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } try { setNodeValueInternal ( new StringBuffer ( this . data ) . insert ( offset , data ) . toString ( ) ) ; ownerDocument ( ) . insertedText ( this , offset , data . length ( ) ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } public void replaceData ( int offset , int count , String data ) throws DOMException { deleteData ( offset , count ) ; insertData ( offset , data ) ; } public void setData ( String value ) throws DOMException { setNodeValue ( value ) ; } public String substringData ( int offset , int count ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int length = data . length ( ) ; if ( count < 0 || offset < 0 || offset > length - 1 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } int tailIndex = Math . min ( offset + count , length ) ; return data . substring ( offset , tailIndex ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLTableRowElementImpl extends HTMLElementImpl implements HTMLTableRowElement { public int getRowIndex ( ) { Node parent ; parent = getParentNode ( ) ; if ( parent instanceof HTMLTableSectionElement ) parent = parent . getParentNode ( ) ; if ( parent instanceof HTMLTableElement ) return getRowIndex ( parent ) ; ; return - 1 ; } public void setRowIndex ( int rowIndex ) { Node parent ; parent = getParentNode ( ) ; if ( parent instanceof HTMLTableSectionElement ) parent = parent . getParentNode ( ) ; if ( parent instanceof HTMLTableElement ) ( ( HTMLTableElementImpl ) parent ) . insertRowX ( rowIndex , this ) ; } public int getSectionRowIndex ( ) { Node parent ; parent = getParentNode ( ) ; if ( parent instanceof HTMLTableSectionElement ) return getRowIndex ( parent ) ; else return - 1 ; } public void setSectionRowIndex ( int sectionRowIndex ) { Node parent ; parent = getParentNode ( ) ; if ( parent instanceof HTMLTableSectionElement ) ( ( HTMLTableSectionElementImpl ) parent ) . insertRowX ( sectionRowIndex , this ) ; } int getRowIndex ( Node parent ) { NodeList rows ; int i ; rows = ( ( HTMLElement ) parent ) . getElementsByTagName ( "TR" ) ; for ( i = 0 ; i < rows . getLength ( ) ; ++ i ) if ( rows . item ( i ) == this ) return i ; return - 1 ; } public HTMLCollection getCells ( ) { if ( _cells == null ) _cells = new HTMLCollectionImpl ( this , HTMLCollectionImpl . CELL ) ; return _cells ; } public void setCells ( HTMLCollection cells ) { Node child ; int i ; child = getFirstChild ( ) ; while ( child != null ) { removeChild ( child ) ; child = child . getNextSibling ( ) ; } i = 0 ; child = cells . item ( i ) ; while ( child != null ) { appendChild ( child ) ; ++ i ; child = cells . item ( i ) ; } } public HTMLElement insertCell ( int index ) { Node child ; HTMLElement newCell ; newCell = new HTMLTableCellElementImpl ( ( HTMLDocumentImpl ) getOwnerDocument ( ) , "TD" ) ; child = getFirstChild ( ) ; while ( child != null ) { if ( child instanceof HTMLTableCellElement ) { if ( index == 0 ) { insertBefore ( newCell , child ) ; return newCell ; } -- index ; } child = child . getNextSibling ( ) ; } appendChild ( newCell ) ; return newCell ; } public void deleteCell ( int index ) { Node child ; child = getFirstChild ( ) ; while ( child != null ) { if ( child instanceof HTMLTableCellElement ) { if ( index == 0 ) { removeChild ( child ) ; return ; } -- index ; } child = child . getNextSibling ( ) ; } } public String getAlign ( ) { return capitalize ( getAttribute ( "align" ) ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public String getBgColor ( ) { return getAttribute ( "bgcolor" ) ; } public void setBgColor ( String bgColor ) { setAttribute ( "bgcolor" , bgColor ) ; } public String getCh ( ) { String ch ; ch = getAttribute ( "char" ) ; if ( ch != null && ch . length ( ) > 1 ) ch = ch . substring ( 0 , 1 ) ; return ch ; } public void setCh ( String ch ) { if ( ch != null && ch . length ( ) > 1 ) ch = ch . substring ( 0 , 1 ) ; setAttribute ( "char" , ch ) ; } public String getChOff ( ) { return getAttribute ( "charoff" ) ; } public void setChOff ( String chOff ) { setAttribute ( "charoff" , chOff ) ; } public String getVAlign ( ) { return capitalize ( getAttribute ( "valign" ) ) ; } public void setVAlign ( String vAlign ) { setAttribute ( "valign" , vAlign ) ; } public HTMLTableRowElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } HTMLCollection _cells ; } 	0
package org . apache . xerces . jaxp ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . xml . sax . SAXException ; public class DocumentBuilderFactoryImpl extends DocumentBuilderFactory { public DocumentBuilderFactoryImpl ( ) { super ( ) ; } public DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException { return ( new DocumentBuilderImpl ( this . isNamespaceAware ( ) , this . isValidating ( ) ) ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLButtonElement extends HTMLElement { public HTMLFormElement getForm ( ) ; public String getAccessKey ( ) ; public void setAccessKey ( String accessKey ) ; public boolean getDisabled ( ) ; public void setDisabled ( boolean disabled ) ; public String getName ( ) ; public void setName ( String name ) ; public int getTabIndex ( ) ; public void setTabIndex ( int tabIndex ) ; public String getType ( ) ; public String getValue ( ) ; public void setValue ( String value ) ; } 	0
package org . apache . xerces . parsers ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . xml . sax . Attributes ; import org . xml . sax . AttributeList ; import org . xml . sax . ContentHandler ; import org . xml . sax . DocumentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . Parser ; import org . xml . sax . XMLReader ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . AttributesImpl ; public class SAXParser extends XMLParser implements XMLDocumentHandler , XMLDocumentHandler . DTDHandler , Parser , XMLReader { private static final String RECOGNIZED_FEATURES [ ] = { "http://xml.org/sax/features/namespace-prefixes" , "http://xml.org/sax/features/string-interning" , } ; private static final String RECOGNIZED_PROPERTIES [ ] = { "http://xml.org/sax/properties/lexical-handler" , "http://xml.org/sax/properties/declaration-handler" , "http://xml.org/sax/properties/dom-node" , } ; private static final boolean DEBUG_CALLBACKS = false ; private DocumentHandler fDocumentHandler ; private org . xml . sax . DTDHandler fDTDHandler ; private ContentHandler fContentHandler ; private DeclHandler fDeclHandler ; private LexicalHandler fLexicalHandler ; private boolean fNamespacePrefixes = false ; private transient AttributesImpl fAttributes = new AttributesImpl ( ) ; public SAXParser ( ) { initHandlers ( true , this , this ) ; } public String [ ] getFeaturesRecognized ( ) { String superRecognized [ ] = super . getFeaturesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_FEATURES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } public String [ ] getPropertiesRecognized ( ) { String superRecognized [ ] = super . getPropertiesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_PROPERTIES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } protected void setDeclHandler ( DeclHandler handler ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR011 Feature: http://xml.org/sax/properties/declaration-handler" + " is not supported during parse." + "\nhttp://xml.org/sax/properties/declaration-handler" ) ; } fDeclHandler = handler ; } protected DeclHandler getDeclHandler ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fDeclHandler ; } protected void setLexicalHandler ( LexicalHandler handler ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR011 Feature: http://xml.org/sax/properties/lexical-handler" + " is not supported during parse." + "\nhttp://xml.org/sax/properties/lexical-handler" ) ; } fLexicalHandler = handler ; } protected LexicalHandler getLexicalHandler ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fLexicalHandler ; } public void setDocumentHandler ( DocumentHandler handler ) { fDocumentHandler = handler ; } public void setDTDHandler ( org . xml . sax . DTDHandler handler ) { fDTDHandler = handler ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return fDTDHandler ; } protected void setNamespacePrefixes ( boolean process ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR004 Cannot setFeature(http://xml.org/sax/features/namespace-prefixes): parse is in progress.\n" + "http://xml.org/sax/features/namespace-prefixes" ) ; } fNamespacePrefixes = process ; } protected boolean getNamespacePrefixes ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fNamespacePrefixes ; } public void setFeature ( String featureId , boolean state ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "namespace-prefixes" ) ) { setNamespacePrefixes ( state ) ; return ; } if ( feature . equals ( "string-interning" ) ) { if ( state ) { throw new SAXNotSupportedException ( "PAR018 " + state + " state for feature \"" + featureId + "\" is not supported.\n" + state + '\t' + featureId ) ; } return ; } } super . setFeature ( featureId , state ) ; } public boolean getFeature ( String featureId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "namespace-prefixes" ) ) { return getNamespacePrefixes ( ) ; } if ( feature . equals ( "string-interning" ) ) { return false ; } } return super . getFeature ( featureId ) ; } public void setProperty ( String propertyId , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "lexical-handler" ) ) { try { setLexicalHandler ( ( LexicalHandler ) value ) ; } catch ( ClassCastException e ) { throw new SAXNotSupportedException ( "PAR012 For propertyID \"" + propertyId + "\", the value \"" + value + "\" cannot be cast to LexicalHandler." + '\n' + propertyId + '\t' + value + "\tLexicalHandler" ) ; } return ; } if ( property . equals ( "declaration-handler" ) ) { try { setDeclHandler ( ( DeclHandler ) value ) ; } catch ( ClassCastException e ) { throw new SAXNotSupportedException ( "PAR012 For propertyID \"" + propertyId + "\", the value \"" + value + "\" cannot be cast to DeclHandler." + '\n' + propertyId + '\t' + value + "\tDeclHandler" ) ; } return ; } if ( property . equals ( "dom-node" ) ) { throw new SAXNotSupportedException ( "PAR013 Property \"" + propertyId + "\" is read only." + '\n' + propertyId ) ; } } super . setProperty ( propertyId , value ) ; } public Object getProperty ( String propertyId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "lexical-handler" ) ) { return getLexicalHandler ( ) ; } if ( property . equals ( "declaration-handler" ) ) { return getDeclHandler ( ) ; } if ( property . equals ( "dom-node" ) ) { throw new SAXNotSupportedException ( "PAR014 Cannot getProperty(\"" + propertyId + "\". No DOM Tree exists.\n" + propertyId ) ; } } return super . getProperty ( propertyId ) ; } public void setContentHandler ( ContentHandler handler ) { if ( handler == null ) { throw new NullPointerException ( ) ; } fContentHandler = handler ; } public ContentHandler getContentHandler ( ) { return fContentHandler ; } public void startDTD ( QName rootElement , int publicId , int systemId ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( rootElement . rawname ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "startDTD(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startDTD ( name , pubid , sysid ) ; } } } public void endDTD ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endDTD()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endDTD ( ) ; } } public void elementDecl ( QName elementDecl , int contentSpecType , int contentSpecIndex , XMLContentSpec . Provider contentSpecProvider ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( elementDecl . rawname ) ; String contentModel ; if ( contentSpecType == XMLElementDecl . TYPE_ANY ) { contentModel = "ANY" ; } else if ( contentSpecType == XMLElementDecl . TYPE_EMPTY ) { contentModel = "EMPTY" ; } else { contentModel = XMLContentSpec . toString ( contentSpecProvider , fStringPool , contentSpecIndex ) ; } if ( DEBUG_CALLBACKS ) { System . err . println ( "elementDecl(" + name + ", " + contentModel + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . elementDecl ( name , contentModel ) ; } } } public void attlistDecl ( QName elementDecl , QName attributeDecl , int attType , boolean attList , String enumString , int attDefaultType , int attDefaultValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String eName = fStringPool . toString ( elementDecl . rawname ) ; String aName = fStringPool . toString ( attributeDecl . rawname ) ; String aType = enumString ; if ( attType != XMLAttributeDecl . TYPE_ENUMERATION ) { switch ( attType ) { case XMLAttributeDecl . TYPE_CDATA : { aType = "CDATA" ; break ; } case XMLAttributeDecl . TYPE_ENTITY : { aType = attList ? "ENTITIES" : "ENTITY" ; break ; } case XMLAttributeDecl . TYPE_ID : { aType = "ID" ; break ; } case XMLAttributeDecl . TYPE_IDREF : { aType = attList ? "IDREFS" : "IDREF" ; break ; } case XMLAttributeDecl . TYPE_NMTOKEN : { aType = attList ? "NMTOKENS" : "NMTOKEN" ; break ; } case XMLAttributeDecl . TYPE_NOTATION : { aType = "NOTATION" ; break ; } } } String aDefaultType = "" ; switch ( attDefaultType ) { case XMLAttributeDecl . DEFAULT_TYPE_FIXED : { aDefaultType = "#FIXED" ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_IMPLIED : { aDefaultType = "#IMPLIED" ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_REQUIRED : { aDefaultType = "#REQUIRED" ; break ; } } String aDefaultValue = fStringPool . toString ( attDefaultValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "attributeDecl(" + eName + ", " + aName + ", " + aType + ", " + aDefaultType + ", " + aDefaultValue + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . attributeDecl ( eName , aName , aType , aDefaultType , aDefaultValue ) ; } } } public void internalPEDecl ( int entityName , int entityValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = "%" + fStringPool . toString ( entityName ) ; String value = fStringPool . toString ( entityValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "internalEntityDecl(" + name + ", " + value + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , value ) ; } } } public void externalPEDecl ( int entityName , int publicId , int systemId ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = "%" + fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "externalEntityDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . externalEntityDecl ( name , pubid , sysid ) ; } } } public void internalEntityDecl ( int entityName , int entityValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String value = fStringPool . toString ( entityValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "internalEntityDecl(" + name + ", " + value + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , value ) ; } } } public void externalEntityDecl ( int entityName , int publicId , int systemId ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "externalEntityDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . externalEntityDecl ( name , pubid , sysid ) ; } } } public void unparsedEntityDecl ( int entityName , int publicId , int systemId , int notationName ) throws Exception { if ( fDTDHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; String notation = fStringPool . toString ( notationName ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "unparsedEntityDecl(" + name + ", " + pubid + ", " + sysid + ", " + notation + ")" ) ; } if ( fDTDHandler != null ) { fDTDHandler . unparsedEntityDecl ( name , pubid , sysid , notation ) ; } } } public void notationDecl ( int notationName , int publicId , int systemId ) throws Exception { if ( fDTDHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( notationName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "notationDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDTDHandler != null ) { fDTDHandler . notationDecl ( name , pubid , sysid ) ; } } } public void startDocument ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "setDocumentLocator(<locator>)" ) ; System . err . println ( "startDocument()" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . setDocumentLocator ( getLocator ( ) ) ; fDocumentHandler . startDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . setDocumentLocator ( getLocator ( ) ) ; fContentHandler . startDocument ( ) ; } } public void endDocument ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endDocument()" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . endDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . endDocument ( ) ; } } public void xmlDecl ( int versionIndex , int encodingIndex , int standaloneIndex ) throws Exception { if ( DEBUG_CALLBACKS ) { String notes = "" ; if ( versionIndex != - 1 ) notes += " version='" + fStringPool . toString ( versionIndex ) + "'" ; if ( encodingIndex != - 1 ) notes += " encoding='" + fStringPool . toString ( encodingIndex ) + "'" ; if ( standaloneIndex != - 1 ) notes += " standalone='" + fStringPool . toString ( standaloneIndex ) + "'" ; System . err . println ( "xmlDecl(<?xml" + notes + "?>)" ) ; } fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; fStringPool . releaseString ( standaloneIndex ) ; } public void textDecl ( int versionIndex , int encodingIndex ) throws Exception { if ( DEBUG_CALLBACKS ) { String notes = "" ; if ( versionIndex != - 1 ) notes += " version='" + fStringPool . toString ( versionIndex ) + "'" ; if ( encodingIndex != - 1 ) notes += " encoding='" + fStringPool . toString ( encodingIndex ) + "'" ; System . err . println ( "textDecl(<?xml" + notes + "?>)" ) ; } fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { if ( fContentHandler != null || DEBUG_CALLBACKS ) { String p = fStringPool . toString ( prefix ) ; String ns = fStringPool . toString ( uri ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "startNamespaceDeclScope(" + p + ", " + ns + ")" ) ; } if ( fContentHandler != null ) { fContentHandler . startPrefixMapping ( p , ns ) ; } } } public void endNamespaceDeclScope ( int prefix ) throws Exception { if ( fContentHandler != null || DEBUG_CALLBACKS ) { String p = fStringPool . toString ( prefix ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "endNamespaceDeclScope(" + p + ")" ) ; } if ( fContentHandler != null ) { fContentHandler . endPrefixMapping ( p ) ; } } } public void internalSubset ( int internalSubset ) { } public void startElement ( QName element , XMLAttrList attrList , int attrListIndex ) throws Exception { String name = fStringPool . toString ( element . rawname ) ; AttributeList attrs = attrList . getAttributeList ( attrListIndex ) ; if ( DEBUG_CALLBACKS ) { String atts = attrs . getLength ( ) > 0 ? "" : " " ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { atts += " " + attrs . getName ( i ) + "='" + attrs . getValue ( i ) + "'" ; } System . err . println ( "startElement(" + name + "," + atts + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . startElement ( name , attrs ) ; } if ( fContentHandler != null ) { boolean namespaces = getNamespaces ( ) ; int uriIndex = element . uri ; String uri = uriIndex != - 1 && namespaces ? fStringPool . toString ( uriIndex ) : "" ; int localIndex = element . localpart ; String local = localIndex != - 1 && namespaces ? fStringPool . toString ( localIndex ) : "" ; String raw = name ; fAttributes . clear ( ) ; for ( int attrIndex = attrList . getFirstAttr ( attrListIndex ) ; attrIndex != - 1 ; attrIndex = attrList . getNextAttr ( attrIndex ) ) { int attrNameIndex = attrList . getAttrName ( attrIndex ) ; int attrUriIndex = attrList . getAttrURI ( attrIndex ) ; String attrUri = attrUriIndex != - 1 && namespaces ? fStringPool . toString ( attrUriIndex ) : "" ; int attrLocalIndex = attrList . getAttrLocalpart ( attrIndex ) ; String attrLocal = attrLocalIndex != - 1 && namespaces ? fStringPool . toString ( attrLocalIndex ) : "" ; String attrRaw = fStringPool . toString ( attrNameIndex ) ; String attrType = fStringPool . toString ( attrList . getAttType ( attrIndex ) ) ; String attrValue = fStringPool . toString ( attrList . getAttValue ( attrIndex ) ) ; int attrPrefix = attrList . getAttrPrefix ( attrIndex ) ; boolean namespacePrefixes = getNamespacePrefixes ( ) ; if ( ! namespaces || namespacePrefixes || ( attrPrefix != fStringPool . addSymbol ( "xmlns" ) && attrLocalIndex != fStringPool . addSymbol ( "xmlns" ) ) ) fAttributes . addAttribute ( attrUri , attrLocal , attrRaw , attrType , attrValue ) ; } fContentHandler . startElement ( uri , local , raw , fAttributes ) ; } attrList . releaseAttrList ( attrListIndex ) ; } public void endElement ( QName element ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endElement(" + fStringPool . toString ( element . rawname ) + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . endElement ( fStringPool . toString ( element . rawname ) ) ; } if ( fContentHandler != null ) { boolean namespaces = getNamespaces ( ) ; int uriIndex = element . uri ; String uri = uriIndex != - 1 && namespaces ? fStringPool . toString ( uriIndex ) : "" ; int localIndex = element . localpart ; String local = localIndex != - 1 && namespaces ? fStringPool . toString ( localIndex ) : "" ; String raw = fStringPool . toString ( element . rawname ) ; fContentHandler . endElement ( uri , local , raw ) ; } } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { switch ( entityType ) { case XMLEntityHandler . ENTITYTYPE_INTERNAL_PE : case XMLEntityHandler . ENTITYTYPE_EXTERNAL_PE : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(%" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( "%" + fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_INTERNAL : case XMLEntityHandler . ENTITYTYPE_EXTERNAL : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_UNPARSED : throw new RuntimeException ( "PAR015 startEntityReference(): ENTITYTYPE_UNPARSED" ) ; case XMLEntityHandler . ENTITYTYPE_DOCUMENT : break ; case XMLEntityHandler . ENTITYTYPE_EXTERNAL_SUBSET : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(\"[dtd]\")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( "[dtd]" ) ; } break ; } } } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { switch ( entityType ) { case XMLEntityHandler . ENTITYTYPE_INTERNAL_PE : case XMLEntityHandler . ENTITYTYPE_EXTERNAL_PE : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(%" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( "%" + fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_INTERNAL : case XMLEntityHandler . ENTITYTYPE_EXTERNAL : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_UNPARSED : throw new RuntimeException ( "PAR016 endEntityReference(): ENTITYTYPE_UNPARSED" ) ; case XMLEntityHandler . ENTITYTYPE_DOCUMENT : break ; case XMLEntityHandler . ENTITYTYPE_EXTERNAL_SUBSET : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(\"[dtd]\")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( "[dtd]" ) ; } break ; } } } public void startCDATA ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "startCDATA()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endCDATA()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endCDATA ( ) ; } } public void characters ( int dataIndex ) throws Exception { throw new RuntimeException ( "PAR017 cannot happen 5\n5" ) ; } public void ignorableWhitespace ( int dataIndex ) throws Exception { throw new RuntimeException ( "PAR017 cannot happen 6\n6" ) ; } public void processingInstruction ( int piTarget , int piData ) throws Exception { if ( fDocumentHandler != null || fContentHandler != null || DEBUG_CALLBACKS ) { String target = fStringPool . orphanString ( piTarget ) ; String data = piData == - 1 ? "" : fStringPool . orphanString ( piData ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "processingInstruction(" + target + ", " + data + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . processingInstruction ( target , data ) ; } if ( fContentHandler != null ) { fContentHandler . processingInstruction ( target , data ) ; } } else { fStringPool . releaseString ( piTarget ) ; fStringPool . releaseString ( piData ) ; } } public void comment ( int dataIndex ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { String data = fStringPool . orphanString ( dataIndex ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "comment(" + data + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } else { fStringPool . releaseString ( dataIndex ) ; } } public void characters ( char ch [ ] , int start , int length ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "characters(<char-data>) length " + length ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . characters ( ch , start , length ) ; } if ( fContentHandler != null ) { fContentHandler . characters ( ch , start , length ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "ignorableWhitespace(<white-space>)" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . ignorableWhitespace ( ch , start , length ) ; } if ( fContentHandler != null ) { fContentHandler . ignorableWhitespace ( ch , start , length ) ; } } } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . StringPool ; import org . xml . sax . InputSource ; import java . io . InputStream ; import java . io . Reader ; public interface XMLEntityReaderFactory { public void addRecognizer ( XMLDeclRecognizer recognizer ) ; public void setSendCharDataAsCharArray ( boolean flag ) ; public void setAllowJavaEncodingName ( boolean flag ) ; public boolean getAllowJavaEncodingName ( ) ; public XMLEntityHandler . EntityReader createReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , InputSource source , String systemId , boolean xmlDecl , StringPool stringPool ) throws Exception ; public XMLEntityHandler . EntityReader createCharReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , Reader reader , StringPool stringPool ) throws Exception ; public XMLEntityHandler . EntityReader createUTF8Reader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , InputStream data , StringPool stringPool ) throws Exception ; public XMLEntityHandler . EntityReader createStringReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , int lineNumber , int columnNumber , int stringHandle , StringPool stringPool , boolean addEnclosingSpaces ) throws Exception ; } 	0
package org . w3c . dom ; public interface DocumentType extends Node { public String getName ( ) ; public NamedNodeMap getEntities ( ) ; public NamedNodeMap getNotations ( ) ; public String getPublicId ( ) ; public String getSystemId ( ) ; public String getInternalSubset ( ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLTextAreaElementImpl extends HTMLElementImpl implements HTMLTextAreaElement , HTMLFormControl { public String getDefaultValue ( ) { return getAttribute ( "default-value" ) ; } public void setDefaultValue ( String defaultValue ) { setAttribute ( "default-value" , defaultValue ) ; } public String getAccessKey ( ) { String accessKey ; accessKey = getAttribute ( "accesskey" ) ; if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; return accessKey ; } public void setAccessKey ( String accessKey ) { if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; setAttribute ( "accesskey" , accessKey ) ; } public int getCols ( ) { return getInteger ( getAttribute ( "cols" ) ) ; } public void setCols ( int cols ) { setAttribute ( "cols" , String . valueOf ( cols ) ) ; } public boolean getDisabled ( ) { return getBinary ( "disabled" ) ; } public void setDisabled ( boolean disabled ) { setAttribute ( "disabled" , disabled ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public boolean getReadOnly ( ) { return getBinary ( "readonly" ) ; } public void setReadOnly ( boolean readOnly ) { setAttribute ( "readonly" , readOnly ) ; } public int getRows ( ) { return getInteger ( getAttribute ( "rows" ) ) ; } public void setRows ( int rows ) { setAttribute ( "rows" , String . valueOf ( rows ) ) ; } public int getTabIndex ( ) { return getInteger ( getAttribute ( "tabindex" ) ) ; } public void setTabIndex ( int tabIndex ) { setAttribute ( "tabindex" , String . valueOf ( tabIndex ) ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } public String getValue ( ) { return getAttribute ( "value" ) ; } public void setValue ( String value ) { setAttribute ( "value" , value ) ; } public void blur ( ) { } public void focus ( ) { } public void select ( ) { } public HTMLTextAreaElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . dom ; import org . apache . xerces . domx . DOMException ; public class DOMExceptionImpl extends DOMException { public DOMExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . ChunkyByteArray ; import org . apache . xerces . utils . StringPool ; import java . io . InputStreamReader ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; final class EBCDICRecognizer extends XMLDeclRecognizer { public XMLEntityHandler . EntityReader recognize ( XMLEntityReaderFactory readerFactory , XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , StringPool stringPool , ChunkyByteArray data , boolean xmlDecl , boolean allowJavaEncodingName ) throws Exception { XMLEntityHandler . EntityReader reader = null ; byte b0 = data . byteAt ( 0 ) ; byte b1 = data . byteAt ( 1 ) ; byte b2 = data . byteAt ( 2 ) ; byte b3 = data . byteAt ( 3 ) ; boolean debug = false ; if ( b0 != 0x4c || b1 != 0x6f || b2 != ( byte ) 0xa7 || b3 != ( byte ) 0x94 ) return reader ; XMLEntityHandler . EntityReader declReader = readerFactory . createCharReader ( entityHandler , errorReporter , sendCharDataAsCharArray , new InputStreamReader ( data , "CP037" ) , stringPool ) ; int encoding = prescanXMLDeclOrTextDecl ( declReader , xmlDecl ) ; if ( encoding == - 1 ) { data . rewind ( ) ; throw new UnsupportedEncodingException ( null ) ; } String enc = stringPool . orphanString ( encoding ) . toUpperCase ( ) ; if ( "ISO-10646-UCS-2" . equals ( enc ) ) throw new UnsupportedEncodingException ( enc ) ; if ( "ISO-10646-UCS-4" . equals ( enc ) ) throw new UnsupportedEncodingException ( enc ) ; if ( "UTF-16" . equals ( enc ) ) throw new UnsupportedEncodingException ( enc ) ; String javaencname = MIME2Java . convert ( enc ) ; if ( null == javaencname ) { if ( allowJavaEncodingName ) { javaencname = enc ; } else { throw new UnsupportedEncodingException ( enc ) ; } } try { data . rewind ( ) ; reader = readerFactory . createCharReader ( entityHandler , errorReporter , sendCharDataAsCharArray , new InputStreamReader ( data , javaencname ) , stringPool ) ; } catch ( UnsupportedEncodingException e ) { throw e ; } catch ( Exception e ) { if ( debug == true ) e . printStackTrace ( ) ; } return reader ; } } 	0
package org . w3c . dom ; public interface Comment extends CharacterData { } 	1
package org . apache . wml ; public interface WMLDoElement extends WMLElement { public void setOptional ( String newValue ) ; public String getOptional ( ) ; public void setLabel ( String newValue ) ; public String getLabel ( ) ; public void setType ( String newValue ) ; public String getType ( ) ; public void setName ( String newValue ) ; public String getName ( ) ; public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface TreeWalker { public Node getRoot ( ) ; public int getWhatToShow ( ) ; public NodeFilter getFilter ( ) ; public boolean getExpandEntityReferences ( ) ; public Node getCurrentNode ( ) ; public void setCurrentNode ( Node currentNode ) throws DOMException ; public Node parentNode ( ) ; public Node firstChild ( ) ; public Node lastChild ( ) ; public Node previousSibling ( ) ; public Node nextSibling ( ) ; public Node previousNode ( ) ; public Node nextNode ( ) ; } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . utils . StringPool ; public class DeferredDocumentTypeImpl extends DocumentTypeImpl implements DeferredNode { static final long serialVersionUID = - 2172579663227313509L ; protected transient int fNodeIndex ; DeferredDocumentTypeImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; needsSyncChildren ( true ) ; } public int getNodeIndex ( ) { return fNodeIndex ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; name = ownerDocument . getNodeNameString ( fNodeIndex ) ; StringPool pool = ownerDocument . getStringPool ( ) ; int extraDataIndex = ownerDocument . getNodeValue ( fNodeIndex ) ; publicID = pool . toString ( ownerDocument . getNodeName ( extraDataIndex ) ) ; systemID = pool . toString ( ownerDocument . getNodeValue ( extraDataIndex ) ) ; internalSubset = pool . toString ( ownerDocument . getLastChild ( extraDataIndex ) ) ; } protected void synchronizeChildren ( ) { boolean orig = ownerDocument ( ) . mutationEvents ; ownerDocument ( ) . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; entities = new NamedNodeMapImpl ( this ) ; notations = new NamedNodeMapImpl ( this ) ; elements = new NamedNodeMapImpl ( this ) ; DeferredNode last = null ; for ( int index = ownerDocument . getLastChild ( fNodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { DeferredNode node = ownerDocument . getNodeObject ( index ) ; int type = node . getNodeType ( ) ; switch ( type ) { case Node . ENTITY_NODE : { entities . setNamedItem ( node ) ; break ; } case Node . NOTATION_NODE : { notations . setNamedItem ( node ) ; break ; } case NodeImpl . ELEMENT_DEFINITION_NODE : { elements . setNamedItem ( node ) ; break ; } case Node . ELEMENT_NODE : { if ( ( ( DocumentImpl ) getOwnerDocument ( ) ) . allowGrammarAccess ) { insertBefore ( node , last ) ; last = node ; break ; } } default : { System . out . println ( "DeferredDocumentTypeImpl#synchronizeInfo: node.getNodeType() = " + node . getNodeType ( ) + ", class = " + node . getClass ( ) . getName ( ) ) ; } } } ownerDocument ( ) . mutationEvents = orig ; } } 	0
package org . w3c . dom ; public interface ProcessingInstruction extends Node { public String getTarget ( ) ; public String getData ( ) ; public void setData ( String data ) throws DOMException ; } 	1
package org . w3c . dom . html ; import org . w3c . dom . DOMException ; public interface HTMLTableElement extends HTMLElement { public HTMLTableCaptionElement getCaption ( ) ; public void setCaption ( HTMLTableCaptionElement caption ) ; public HTMLTableSectionElement getTHead ( ) ; public void setTHead ( HTMLTableSectionElement tHead ) ; public HTMLTableSectionElement getTFoot ( ) ; public void setTFoot ( HTMLTableSectionElement tFoot ) ; public HTMLCollection getRows ( ) ; public HTMLCollection getTBodies ( ) ; public String getAlign ( ) ; public void setAlign ( String align ) ; public String getBgColor ( ) ; public void setBgColor ( String bgColor ) ; public String getBorder ( ) ; public void setBorder ( String border ) ; public String getCellPadding ( ) ; public void setCellPadding ( String cellPadding ) ; public String getCellSpacing ( ) ; public void setCellSpacing ( String cellSpacing ) ; public String getFrame ( ) ; public void setFrame ( String frame ) ; public String getRules ( ) ; public void setRules ( String rules ) ; public String getSummary ( ) ; public void setSummary ( String summary ) ; public String getWidth ( ) ; public void setWidth ( String width ) ; public HTMLElement createTHead ( ) ; public void deleteTHead ( ) ; public HTMLElement createTFoot ( ) ; public void deleteTFoot ( ) ; public HTMLElement createCaption ( ) ; public void deleteCaption ( ) ; public HTMLElement insertRow ( int index ) throws DOMException ; public void deleteRow ( int index ) throws DOMException ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . EventImpl ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public abstract class NodeImpl implements Node , NodeList , EventTarget , Cloneable , Serializable { static final long serialVersionUID = - 6316591992167219696L ; public static final short ELEMENT_DEFINITION_NODE = - 1 ; protected NodeImpl ownerNode ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short SYNCDATA = 0x1 << 1 ; protected final static short SYNCCHILDREN = 0x1 << 2 ; protected final static short OWNED = 0x1 << 3 ; protected final static short FIRSTCHILD = 0x1 << 4 ; protected final static short SPECIFIED = 0x1 << 5 ; protected final static short IGNORABLEWS = 0x1 << 6 ; protected final static short SETVALUE = 0x1 << 7 ; protected NodeImpl ( DocumentImpl ownerDocument ) { ownerNode = ownerDocument ; } public NodeImpl ( ) { } public abstract short getNodeType ( ) ; public abstract String getNodeName ( ) ; public String getNodeValue ( ) { return null ; } public void setNodeValue ( String x ) throws DOMException { } public Node appendChild ( Node newChild ) throws DOMException { return insertBefore ( newChild , null ) ; } public Node cloneNode ( boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } NodeImpl newnode ; try { newnode = ( NodeImpl ) clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } newnode . ownerNode = ownerDocument ( ) ; newnode . isOwned ( false ) ; newnode . isReadOnly ( false ) ; return newnode ; } public Document getOwnerDocument ( ) { if ( isOwned ( ) ) { return ownerNode . ownerDocument ( ) ; } else { return ( Document ) ownerNode ; } } DocumentImpl ownerDocument ( ) { if ( isOwned ( ) ) { return ownerNode . ownerDocument ( ) ; } else { return ( DocumentImpl ) ownerNode ; } } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ! isOwned ( ) ) { ownerNode = doc ; } } public Node getParentNode ( ) { return null ; } NodeImpl parentNode ( ) { return null ; } public Node getNextSibling ( ) { return null ; } public Node getPreviousSibling ( ) { return null ; } ChildNode previousSibling ( ) { return null ; } public NamedNodeMap getAttributes ( ) { return null ; } public boolean hasAttributes ( ) { return false ; } public boolean hasChildNodes ( ) { return false ; } public NodeList getChildNodes ( ) { return this ; } public Node getFirstChild ( ) { return null ; } public Node getLastChild ( ) { return null ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } public Node removeChild ( Node oldChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } public int getLength ( ) { return 0 ; } public Node item ( int index ) { return null ; } public void normalize ( ) { } public boolean supports ( String feature , String version ) { return ownerDocument ( ) . getImplementation ( ) . hasFeature ( feature , version ) ; } public String getNamespaceURI ( ) { return null ; } public String getPrefix ( ) { return null ; } public void setPrefix ( String prefix ) throws DOMException { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } public String getLocalName ( ) { return null ; } protected final static boolean MUTATIONEVENTS = true ; protected final static int MUTATION_NONE = 0x00 ; protected final static int MUTATION_LOCAL = 0x01 ; protected final static int MUTATION_AGGREGATE = 0x02 ; protected final static int MUTATION_ALL = 0xffff ; class LEntry { String type ; EventListener listener ; boolean useCapture ; LEntry ( String type , EventListener listener , boolean useCapture ) { this . type = type ; this . listener = listener ; this . useCapture = useCapture ; } } ; public void addEventListener ( String type , EventListener listener , boolean useCapture ) { if ( type == null || type . equals ( "" ) || listener == null ) return ; removeEventListener ( type , listener , useCapture ) ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null ) { nodeListeners = new Vector ( ) ; ownerDocument ( ) . setEventListeners ( this , nodeListeners ) ; } nodeListeners . addElement ( new LEntry ( type , listener , useCapture ) ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) ++ lc . captures ; else ++ lc . bubbles ; } public void removeEventListener ( String type , EventListener listener , boolean useCapture ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null || type == null || type . equals ( "" ) || listener == null ) return ; for ( int i = nodeListeners . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nodeListeners . elementAt ( i ) ) ; if ( le . useCapture == useCapture && le . listener == listener && le . type . equals ( type ) ) { nodeListeners . removeElementAt ( i ) ; if ( nodeListeners . size ( ) == 0 ) ownerDocument ( ) . setEventListeners ( this , null ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) -- lc . captures ; else -- lc . bubbles ; break ; } } } public boolean dispatchEvent ( Event event ) { if ( event == null ) return false ; EventImpl evt = ( EventImpl ) event ; if ( ! evt . initialized || evt . type == null || evt . type . equals ( "" ) ) throw new DOMExceptionImpl ( DOMExceptionImpl . UNSPECIFIED_EVENT_TYPE , "DOM010 Unspecified event type" ) ; LCount lc = LCount . lookup ( evt . getType ( ) ) ; if ( lc . captures + lc . bubbles + lc . defaults == 0 ) return evt . preventDefault ; evt . target = this ; evt . stopPropagation = false ; evt . preventDefault = false ; Vector pv = new Vector ( 10 , 10 ) ; Node p = this , n = p . getParentNode ( ) ; while ( n != null ) { pv . addElement ( n ) ; p = n ; n = n . getParentNode ( ) ; } if ( lc . captures > 0 ) { evt . eventPhase = Event . CAPTURING_PHASE ; for ( int j = pv . size ( ) - 1 ; j >= 0 ; -- j ) { if ( evt . stopPropagation ) break ; NodeImpl nn = ( NodeImpl ) pv . elementAt ( j ) ; evt . currentNode = nn ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( nn ) ; if ( nodeListeners != null ) { Vector nl = ( Vector ) ( nodeListeners . clone ( ) ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nl . elementAt ( i ) ) ; if ( le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } } } if ( lc . bubbles > 0 ) { evt . eventPhase = Event . AT_TARGET ; evt . currentNode = this ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( ! evt . stopPropagation && nodeListeners != null ) { Vector nl = ( Vector ) nodeListeners . clone ( ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) nl . elementAt ( i ) ; if ( le != null && ! le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } if ( evt . bubbles ) { evt . eventPhase = Event . BUBBLING_PHASE ; for ( int j = 0 ; j < pv . size ( ) ; ++ j ) { if ( evt . stopPropagation ) break ; NodeImpl nn = ( NodeImpl ) pv . elementAt ( j ) ; evt . currentNode = nn ; nodeListeners = ownerDocument ( ) . getEventListeners ( nn ) ; if ( nodeListeners != null ) { Vector nl = ( Vector ) ( nodeListeners . clone ( ) ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nl . elementAt ( i ) ) ; if ( ! le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } } } } if ( lc . defaults > 0 && ( ! evt . cancelable || ! evt . preventDefault ) ) { } return evt . preventDefault ; } void dispatchEventToSubtree ( Node n , Event e ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null || n == null ) return ; ( ( NodeImpl ) n ) . dispatchEvent ( e ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap a = n . getAttributes ( ) ; for ( int i = a . getLength ( ) - 1 ; i >= 0 ; -- i ) dispatchEventToSubtree ( a . item ( i ) , e ) ; } dispatchEventToSubtree ( n . getFirstChild ( ) , e ) ; dispatchEventToSubtree ( n . getNextSibling ( ) , e ) ; } } class EnclosingAttr { AttrImpl node ; String oldvalue ; } EnclosingAttr getEnclosingAttr ( ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { NodeImpl eventAncestor = this ; while ( true ) { if ( eventAncestor == null ) return null ; int type = eventAncestor . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE ) { EnclosingAttr retval = new EnclosingAttr ( ) ; retval . node = ( AttrImpl ) eventAncestor ; retval . oldvalue = retval . node . getNodeValue ( ) ; return retval ; } else if ( type == Node . ENTITY_REFERENCE_NODE ) eventAncestor = eventAncestor . parentNode ( ) ; else return null ; } } return null ; } void dispatchAggregateEvents ( EnclosingAttr ea ) { if ( ea != null ) dispatchAggregateEvents ( ea . node , ea . oldvalue ) ; else dispatchAggregateEvents ( null , null ) ; } void dispatchAggregateEvents ( AttrImpl enclosingAttr , String oldvalue ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null ) return ; NodeImpl owner = null ; if ( enclosingAttr != null ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { owner = ( ( NodeImpl ) ( enclosingAttr . getOwnerElement ( ) ) ) ; if ( owner != null ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_ATTR_MODIFIED , true , false , null , oldvalue , enclosingAttr . getNodeValue ( ) , enclosingAttr . getNodeName ( ) ) ; owner . dispatchEvent ( me ) ; } } } LCount lc = LCount . lookup ( MutationEventImpl . DOM_SUBTREE_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_SUBTREE_MODIFIED , true , false , null , null , null , null ) ; if ( enclosingAttr != null ) { enclosingAttr . dispatchEvent ( me ) ; if ( owner != null ) owner . dispatchEvent ( me ) ; } else dispatchEvent ( me ) ; } } } public void setReadOnly ( boolean readOnly , boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isReadOnly ( readOnly ) ; } public boolean getReadOnly ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isReadOnly ( ) ; } public void setUserData ( Object data ) { ownerDocument ( ) . setUserData ( this , data ) ; } public Object getUserData ( ) { return ownerDocument ( ) . getUserData ( this ) ; } protected void changed ( ) { ownerDocument ( ) . changed ( ) ; } protected int changes ( ) { return ownerDocument ( ) . changes ( ) ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean needsSyncData ( ) { return ( flags & SYNCDATA ) != 0 ; } final void needsSyncData ( boolean value ) { flags = ( short ) ( value ? flags | SYNCDATA : flags & ~ SYNCDATA ) ; } final boolean needsSyncChildren ( ) { return ( flags & SYNCCHILDREN ) != 0 ; } final void needsSyncChildren ( boolean value ) { flags = ( short ) ( value ? flags | SYNCCHILDREN : flags & ~ SYNCCHILDREN ) ; } final boolean isOwned ( ) { return ( flags & OWNED ) != 0 ; } final void isOwned ( boolean value ) { flags = ( short ) ( value ? flags | OWNED : flags & ~ OWNED ) ; } final boolean isFirstChild ( ) { return ( flags & FIRSTCHILD ) != 0 ; } final void isFirstChild ( boolean value ) { flags = ( short ) ( value ? flags | FIRSTCHILD : flags & ~ FIRSTCHILD ) ; } final boolean isSpecified ( ) { return ( flags & SPECIFIED ) != 0 ; } final void isSpecified ( boolean value ) { flags = ( short ) ( value ? flags | SPECIFIED : flags & ~ SPECIFIED ) ; } final boolean internalIsIgnorableWhitespace ( ) { return ( flags & IGNORABLEWS ) != 0 ; } final void isIgnorableWhitespace ( boolean value ) { flags = ( short ) ( value ? flags | IGNORABLEWS : flags & ~ IGNORABLEWS ) ; } final boolean setValueCalled ( ) { return ( flags & SETVALUE ) != 0 ; } final void setValueCalled ( boolean value ) { flags = ( short ) ( value ? flags | SETVALUE : flags & ~ SETVALUE ) ; } public String toString ( ) { return "[" + getNodeName ( ) + ": " + getNodeValue ( ) + "]" ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } out . defaultWriteObject ( ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLTableCellElement extends HTMLElement { public int getCellIndex ( ) ; public String getAbbr ( ) ; public void setAbbr ( String abbr ) ; public String getAlign ( ) ; public void setAlign ( String align ) ; public String getAxis ( ) ; public void setAxis ( String axis ) ; public String getBgColor ( ) ; public void setBgColor ( String bgColor ) ; public String getCh ( ) ; public void setCh ( String ch ) ; public String getChOff ( ) ; public void setChOff ( String chOff ) ; public int getColSpan ( ) ; public void setColSpan ( int colSpan ) ; public String getHeaders ( ) ; public void setHeaders ( String headers ) ; public String getHeight ( ) ; public void setHeight ( String height ) ; public boolean getNoWrap ( ) ; public void setNoWrap ( boolean noWrap ) ; public int getRowSpan ( ) ; public void setRowSpan ( int rowSpan ) ; public String getScope ( ) ; public void setScope ( String scope ) ; public String getVAlign ( ) ; public void setVAlign ( String vAlign ) ; public String getWidth ( ) ; public void setWidth ( String width ) ; } 	0
package org . apache . xerces . validators . datatype ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import java . io . IOException ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; public class DecimalDatatypeValidator extends AbstractDatatypeValidator { private Locale fLocale = null ; private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; private BigDecimal [ ] fEnumDecimal = null ; private String fPattern = null ; private BigDecimal fMaxInclusive = null ; private BigDecimal fMaxExclusive = null ; private BigDecimal fMinInclusive = null ; private BigDecimal fMinExclusive = null ; private int fFacetsDefined = 0 ; private int fScale = 0 ; private int fPrecision = 0 ; private boolean isMaxExclusiveDefined = false ; private boolean isMaxInclusiveDefined = false ; private boolean isMinExclusiveDefined = false ; private boolean isMinInclusiveDefined = false ; private boolean isScaleDefined = false ; private boolean isPrecisionDefined = false ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; private RegularExpression fRegex = null ; private Hashtable fFacets = null ; public DecimalDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public DecimalDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { fFacets = checkForFacetConsistency ( facets , base . getFacets ( ) ) ; fFacets = facets ; if ( fDerivedByList == false ) { Vector enumeration = null ; String value = null ; for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; try { if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = value ; if ( fPattern != null ) fRegex = new RegularExpression ( fPattern , "X" ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; enumeration = ( Vector ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; fMaxInclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MAXEXCLUSIVE ; fMaxExclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; fMinInclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MINEXCLUSIVE ; fMinExclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_PRECISION ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_PRECISSION ; isPrecisionDefined = true ; fPrecision = Integer . parseInt ( value ) ; } else if ( key . equals ( SchemaSymbols . ELT_SCALE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_SCALE ; isScaleDefined = true ; fScale = Integer . parseInt ( value ) ; } else { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . MSG_FORMAT_FAILURE , DatatypeMessageProvider . MSG_NONE , null ) ) ; } } catch ( Exception ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } isMaxExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXEXCLUSIVE ) != 0 ) ? true : false ; isMaxInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXINCLUSIVE ) != 0 ) ? true : false ; isMinExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MINEXCLUSIVE ) != 0 ) ? true : false ; isMinInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MININCLUSIVE ) != 0 ) ? true : false ; if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both maxInclusive and maxExclusive to be specified for the same datatype." ) ; } if ( isMinExclusiveDefined && isMinInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both minInclusive and minExclusive to be specified for the same datatype." ) ; } if ( isMaxExclusiveDefined && isMinExclusiveDefined ) { int compareTo = this . fMaxExclusive . compareTo ( this . fMinExclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxExclusive value ='" + this . fMaxExclusive + "'must be > than minExclusive value ='" + this . fMinExclusive + "'. " ) ; } if ( isMaxInclusiveDefined && isMinInclusiveDefined ) { int compareTo = this . fMaxInclusive . compareTo ( this . fMinInclusive ) ; if ( compareTo == - 1 ) throw new InvalidDatatypeFacetException ( "maxInclusive value ='" + this . fMaxInclusive + "'must be >= than minInclusive value ='" + this . fMinInclusive + "'. " ) ; } if ( isMaxExclusiveDefined && isMinInclusiveDefined ) { int compareTo = this . fMaxExclusive . compareTo ( this . fMinInclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxExclusive value ='" + this . fMaxExclusive + "'must be > than minInclusive value ='" + this . fMinInclusive + "'. " ) ; } if ( isMaxInclusiveDefined && isMinExclusiveDefined ) { int compareTo = this . fMaxInclusive . compareTo ( this . fMinExclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxInclusive value ='" + this . fMaxInclusive + "'must be > than minExclusive value ='" + this . fMinExclusive + "'. " ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { if ( enumeration != null ) { fEnumDecimal = new BigDecimal [ enumeration . size ( ) ] ; int i = 0 ; try { for ( ; i < enumeration . size ( ) ; i ++ ) { fEnumDecimal [ i ] = new BigDecimal ( stripPlusIfPresent ( ( ( String ) enumeration . elementAt ( i ) ) ) ) ; boundsCheck ( fEnumDecimal [ i ] ) ; } } catch ( Exception idve ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . InvalidEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { enumeration . elementAt ( i ) } ) ) ; } } } } else { } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { if ( fDerivedByList == false ) { if ( this . fBaseValidator != null ) { this . fBaseValidator . validate ( content , state ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_PATTERN ) != 0 ) { if ( fRegex == null || fRegex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value'" + content + "' does not match regular expression facet " + fRegex . getPattern ( ) ) ; } BigDecimal d = null ; try { d = new BigDecimal ( stripPlusIfPresent ( content ) ) ; } catch ( Exception nfe ) { throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotDecimal , DatatypeMessageProvider . MSG_NONE , new Object [ ] { "'" + content + "'" } ) ) ; } if ( isScaleDefined == true ) { if ( d . scale ( ) > fScale ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . ScaleExceeded , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } if ( isPrecisionDefined == true ) { int precision = d . movePointRight ( d . scale ( ) ) . toString ( ) . length ( ) - ( ( d . signum ( ) < 0 ) ? 1 : 0 ) ; if ( precision > fPrecision ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . PrecisionExceeded , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } boundsCheck ( d ) ; if ( fEnumDecimal != null ) enumCheck ( d ) ; } else { } return null ; } public void boundsCheck ( BigDecimal d ) throws InvalidDatatypeValueException { boolean minOk = false ; boolean maxOk = false ; String upperBound = ( fMaxExclusive != null ) ? ( fMaxExclusive . toString ( ) ) : ( ( fMaxInclusive != null ) ? fMaxInclusive . toString ( ) : "" ) ; String lowerBound = ( fMinExclusive != null ) ? ( fMinExclusive . toString ( ) ) : ( ( fMinInclusive != null ) ? fMinInclusive . toString ( ) : "" ) ; String lowerBoundIndicator = "" ; String upperBoundIndicator = "" ; if ( isMaxInclusiveDefined ) { maxOk = ( d . compareTo ( fMaxInclusive ) <= 0 ) ; upperBound = fMaxInclusive . toString ( ) ; if ( upperBound != null ) { upperBoundIndicator = "<=" ; } else { upperBound = "" ; } } else if ( isMaxExclusiveDefined ) { maxOk = ( d . compareTo ( fMaxExclusive ) < 0 ) ; upperBound = fMaxExclusive . toString ( ) ; if ( upperBound != null ) { upperBoundIndicator = "<" ; } else { upperBound = "" ; } } else { maxOk = ( ! isMaxInclusiveDefined && ! isMaxExclusiveDefined ) ; } if ( isMinInclusiveDefined ) { minOk = ( d . compareTo ( fMinInclusive ) >= 0 ) ; lowerBound = fMinInclusive . toString ( ) ; if ( lowerBound != null ) { lowerBoundIndicator = "<=" ; } else { lowerBound = "" ; } } else if ( isMinExclusiveDefined ) { minOk = ( d . compareTo ( fMinExclusive ) > 0 ) ; lowerBound = fMinExclusive . toString ( ) ; if ( lowerBound != null ) { lowerBoundIndicator = "<" ; } else { lowerBound = "" ; } } else { minOk = ( ! isMinInclusiveDefined && ! isMinExclusiveDefined ) ; } if ( ! ( minOk && maxOk ) ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . OutOfBounds , DatatypeMessageProvider . MSG_NONE , new Object [ ] { d . toString ( ) , lowerBound , upperBound , lowerBoundIndicator , upperBoundIndicator } ) ) ; } private void enumCheck ( BigDecimal v ) throws InvalidDatatypeValueException { for ( int i = 0 ; i < fEnumDecimal . length ; i ++ ) { if ( v . equals ( fEnumDecimal [ i ] ) ) { return ; } } throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotAnEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { v } ) ) ; } public void setLocale ( Locale locale ) { fLocale = locale ; } public Hashtable getFacets ( ) { return fFacets ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } public int compare ( String content1 , String content2 ) { return 0 ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } static private String stripPlusIfPresent ( String value ) { String strippedPlus = value ; if ( value . length ( ) >= 2 && value . charAt ( 0 ) == '+' && value . charAt ( 1 ) != '-' ) { strippedPlus = value . substring ( 1 ) ; } return strippedPlus ; } private Hashtable checkForFacetConsistency ( Hashtable thisTypeFacets , Hashtable baseTypeFacets ) throws InvalidDatatypeFacetException { String thisTypeFacetValue ; String baseValue ; if ( baseTypeFacets != null ) { Enumeration setOfBaseKeys = baseTypeFacets . keys ( ) ; String keyInBase ; BigDecimal valueOfThisType = null ; BigDecimal valueOfBase = null ; while ( setOfBaseKeys . hasMoreElements ( ) ) { keyInBase = ( String ) setOfBaseKeys . nextElement ( ) ; baseValue = ( String ) baseTypeFacets . get ( keyInBase ) ; thisTypeFacetValue = ( String ) thisTypeFacets . get ( keyInBase ) ; if ( thisTypeFacetValue == null ) { String strThisType = null ; thisTypeFacets . put ( keyInBase , baseValue ) ; if ( keyInBase . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MAXINCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == - 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MAXINCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == - 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MININCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MININCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MININCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MININCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MINEXCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MINEXCLUSIVE ) ; } } } else { if ( keyInBase . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } } } } return thisTypeFacets ; } } 	1
package org . apache . wml ; public interface WMLRefreshElement extends WMLElement { } 	0
package javax . xml . parsers ; public class FactoryConfigurationError extends Error { private Exception exception = null ; public FactoryConfigurationError ( ) { this ( null , null ) ; } public FactoryConfigurationError ( String msg ) { this ( null , msg ) ; } public FactoryConfigurationError ( Exception e ) { this ( e , null ) ; } public FactoryConfigurationError ( Exception e , String msg ) { super ( msg ) ; this . exception = e ; } public Exception getException ( ) { return ( this . exception ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLPreElementImpl extends HTMLElementImpl implements HTMLPreElement { public int getWidth ( ) { return getInteger ( getAttribute ( "width" ) ) ; } public void setWidth ( int width ) { setAttribute ( "width" , String . valueOf ( width ) ) ; } public HTMLPreElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom ; public interface DocumentFragment extends Node { } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . QName ; import org . apache . xerces . validators . schema . EquivClassComparator ; public class MixedContentModel implements XMLContentModel { private int fCount ; private QName fChildren [ ] ; private int fChildrenType [ ] ; private EquivClassComparator comparator = null ; private boolean fOrdered ; private boolean fDTD ; public MixedContentModel ( QName childList [ ] , int childListType [ ] , int offset , int length ) throws CMException { this ( childList , childListType , offset , length , false , false ) ; } public MixedContentModel ( QName childList [ ] , int childListType [ ] , int offset , int length , boolean ordered ) throws CMException { this ( childList , childListType , offset , length , ordered , false ) ; } public MixedContentModel ( QName childList [ ] , int childListType [ ] , int offset , int length , boolean ordered , boolean dtd ) throws CMException { fCount = length ; fChildren = new QName [ fCount ] ; fChildrenType = new int [ fCount ] ; for ( int i = 0 ; i < fCount ; i ++ ) { fChildren [ i ] = new QName ( childList [ offset + i ] ) ; fChildrenType [ i ] = childListType [ offset + i ] ; } fOrdered = ordered ; fDTD = dtd ; } public int validateContent ( QName children [ ] , int offset , int length ) throws Exception { if ( fOrdered ) { int inIndex = 0 ; for ( int outIndex = 0 ; outIndex < length ; outIndex ++ ) { final QName curChild = children [ offset + outIndex ] ; if ( curChild . localpart == - 1 ) { continue ; } int type = fChildrenType [ inIndex ] ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fDTD ) { if ( fChildren [ inIndex ] . rawname != children [ offset + outIndex ] . rawname ) { return outIndex ; } } else { if ( fChildren [ inIndex ] . uri != children [ offset + outIndex ] . uri && fChildren [ inIndex ] . localpart != children [ offset + outIndex ] . localpart ) { return outIndex ; } } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fChildren [ inIndex ] . uri ; if ( uri != - 1 && uri != children [ outIndex ] . uri ) { return outIndex ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( children [ outIndex ] . uri != - 1 ) { return outIndex ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fChildren [ inIndex ] . uri == children [ outIndex ] . uri ) { return outIndex ; } } inIndex ++ ; } } else { for ( int outIndex = 0 ; outIndex < length ; outIndex ++ ) { final QName curChild = children [ offset + outIndex ] ; if ( curChild . localpart == - 1 ) continue ; int inIndex = 0 ; for ( ; inIndex < fCount ; inIndex ++ ) { int type = fChildrenType [ inIndex ] ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fDTD ) { if ( curChild . rawname == fChildren [ inIndex ] . rawname ) { break ; } } else { if ( curChild . uri == fChildren [ inIndex ] . uri && curChild . localpart == fChildren [ inIndex ] . localpart ) break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fChildren [ inIndex ] . uri ; if ( uri == - 1 || uri == children [ outIndex ] . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( children [ outIndex ] . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fChildren [ inIndex ] . uri != children [ outIndex ] . uri ) { break ; } } } if ( inIndex == fCount ) return outIndex ; } } return - 1 ; } public int validateContentSpecial ( QName children [ ] , int offset , int length ) throws Exception { return validateContent ( children , offset , length ) ; } public void setEquivClassComparator ( EquivClassComparator comparator ) { this . comparator = comparator ; } public int whatCanGoHere ( boolean fullyValid , InsertableElementsInfo info ) throws Exception { for ( int index = info . insertAt ; index < info . childCount ; index ++ ) info . curChildren [ index ] = info . curChildren [ index + 1 ] ; info . childCount -- ; final int failedIndex = validateContent ( info . curChildren , 0 , info . childCount ) ; if ( ( failedIndex != - 1 ) && ( failedIndex < info . insertAt ) ) return failedIndex ; info . canHoldPCData = true ; info . isValidEOC = true ; info . resultsCount = fCount ; if ( ( info . results == null ) || ( info . results . length < info . resultsCount ) ) info . results = new boolean [ info . resultsCount ] ; if ( ( info . possibleChildren == null ) || ( info . possibleChildren . length < info . resultsCount ) ) { info . possibleChildren = new QName [ info . resultsCount ] ; for ( int i = 0 ; i < info . possibleChildren . length ; i ++ ) { info . possibleChildren [ i ] = new QName ( ) ; } } boolean bStatus = true ; if ( fullyValid && ( failedIndex < info . childCount ) ) bStatus = false ; for ( int index = 0 ; index < fCount ; index ++ ) { info . possibleChildren [ index ] . setValues ( fChildren [ index ] ) ; info . results [ index ] = bStatus ; } return - 1 ; } public ContentLeafNameTypeVector getContentLeafNameTypeVector ( ) { return null ; } } 	0
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface MutationEvent extends Event { public Node getRelatedNode ( ) ; public String getPrevValue ( ) ; public String getNewValue ( ) ; public String getAttrName ( ) ; public void initMutationEvent ( String typeArg , boolean canBubbleArg , boolean cancelableArg , Node relatedNodeArg , String prevValueArg , String newValueArg , String attrNameArg ) ; } 	1
package org . apache . wml ; public interface WMLBElement extends WMLElement { public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . w3c . dom . traversal . * ; import org . apache . xerces . dom . DocumentImpl ; import org . apache . xerces . dom . DOMExceptionImpl ; public class NodeIteratorImpl implements NodeIterator { private DocumentImpl fDocument ; private Node fRoot ; private int fWhatToShow = NodeFilter . SHOW_ALL ; private NodeFilter fNodeFilter ; private boolean fDetach = false ; private Node fCurrentNode ; private boolean fForward = true ; private boolean fEntityReferenceExpansion ; public NodeIteratorImpl ( DocumentImpl document , Node root , int whatToShow , NodeFilter nodeFilter , boolean entityReferenceExpansion ) { fDocument = document ; fRoot = root ; fCurrentNode = null ; fWhatToShow = whatToShow ; fNodeFilter = nodeFilter ; fEntityReferenceExpansion = entityReferenceExpansion ; } public Node getRoot ( ) { return fRoot ; } public int getWhatToShow ( ) { return fWhatToShow ; } public NodeFilter getFilter ( ) { return fNodeFilter ; } public boolean getExpandEntityReferences ( ) { return fEntityReferenceExpansion ; } public Node nextNode ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMExceptionImpl . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( fRoot == null ) return null ; Node nextNode = fCurrentNode ; boolean accepted = false ; accepted_loop : while ( ! accepted ) { if ( ! fForward && nextNode != null ) { nextNode = fCurrentNode ; } else { if ( ! fEntityReferenceExpansion && nextNode != null && nextNode . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) { nextNode = nextNode ( nextNode , false ) ; } else { nextNode = nextNode ( nextNode , true ) ; } } fForward = true ; if ( nextNode == null ) return null ; accepted = acceptNode ( nextNode ) ; if ( accepted ) { fCurrentNode = nextNode ; return fCurrentNode ; } else continue accepted_loop ; } return null ; } public Node previousNode ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMExceptionImpl . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( fRoot == null || fCurrentNode == null ) return null ; Node previousNode = fCurrentNode ; boolean accepted = false ; accepted_loop : while ( ! accepted ) { if ( fForward && previousNode != null ) { previousNode = fCurrentNode ; } else { previousNode = previousNode ( previousNode ) ; } fForward = false ; if ( previousNode == null ) return null ; accepted = acceptNode ( previousNode ) ; if ( accepted ) { fCurrentNode = previousNode ; return fCurrentNode ; } else continue accepted_loop ; } return null ; } boolean acceptNode ( Node node ) { if ( fNodeFilter == null ) { return ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ; } else { return ( ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ) && fNodeFilter . acceptNode ( node ) == NodeFilter . FILTER_ACCEPT ; } } Node matchNodeOrParent ( Node node ) { for ( Node n = node ; n != fRoot ; n = n . getParentNode ( ) ) { if ( node == n ) return n ; } return null ; } Node nextNode ( Node node , boolean visitChildren ) { if ( node == null ) return fRoot ; Node result ; if ( visitChildren ) { if ( node . hasChildNodes ( ) ) { result = node . getFirstChild ( ) ; return result ; } } result = node . getNextSibling ( ) ; if ( result != null ) return result ; Node parent = node . getParentNode ( ) ; while ( parent != null && parent != fRoot ) { result = parent . getNextSibling ( ) ; if ( result != null ) { return result ; } else { parent = parent . getParentNode ( ) ; } } return null ; } Node previousNode ( Node node ) { Node result ; if ( node == fRoot ) return null ; result = node . getPreviousSibling ( ) ; if ( result == null ) { result = node . getParentNode ( ) ; return result ; } if ( result . hasChildNodes ( ) && ! ( ! fEntityReferenceExpansion && result != null && result . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) ) { while ( result . hasChildNodes ( ) ) { result = result . getLastChild ( ) ; } } return result ; } public void removeNode ( Node node ) { if ( node == null ) return ; Node deleted = matchNodeOrParent ( node ) ; if ( deleted == null ) return ; if ( fForward ) { fCurrentNode = previousNode ( deleted ) ; } else { Node next = nextNode ( deleted , false ) ; if ( next != null ) { fCurrentNode = next ; } else { fCurrentNode = previousNode ( deleted ) ; fForward = true ; } } } public void detach ( ) { fDetach = true ; fDocument . removeNodeIterator ( this ) ; } } 	1
package org . apache . xml . serialize ; import java . io . Writer ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . w3c . dom . * ; import org . xml . sax . DocumentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ContentHandler ; import org . xml . sax . Attributes ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . ext . DeclHandler ; public abstract class BaseMarkupSerializer implements ContentHandler , DocumentHandler , LexicalHandler , DTDHandler , DeclHandler , DOMSerializer , Serializer { private int _lastPrintable = 0x7E ; private ElementState [ ] _elementStates ; private int _elementStateCount ; private Vector _preRoot ; protected boolean _started ; private boolean _prepared ; protected Hashtable _prefixes ; protected String _docTypePublicId ; protected String _docTypeSystemId ; protected OutputFormat _format ; protected Printer _printer ; protected boolean _indenting ; private Writer _writer ; private OutputStream _output ; protected BaseMarkupSerializer ( OutputFormat format ) { int i ; _elementStates = new ElementState [ 10 ] ; for ( i = 0 ; i < _elementStates . length ; ++ i ) _elementStates [ i ] = new ElementState ( ) ; _format = format ; } public DocumentHandler asDocumentHandler ( ) throws IOException { prepare ( ) ; return this ; } public ContentHandler asContentHandler ( ) throws IOException { prepare ( ) ; return this ; } public DOMSerializer asDOMSerializer ( ) throws IOException { prepare ( ) ; return this ; } public void setOutputByteStream ( OutputStream output ) { String encoding ; if ( output == null ) throw new NullPointerException ( "SER001 Argument 'output' is null." ) ; _output = output ; _writer = null ; reset ( ) ; } public void setOutputCharStream ( Writer writer ) { if ( writer == null ) throw new NullPointerException ( "SER001 Argument 'writer' is null." ) ; _writer = writer ; _output = null ; reset ( ) ; } public void setOutputFormat ( OutputFormat format ) { if ( format == null ) throw new NullPointerException ( "SER001 Argument 'format' is null." ) ; _format = format ; reset ( ) ; } public boolean reset ( ) { if ( _elementStateCount > 1 ) throw new IllegalStateException ( "Serializer reset in the middle of serialization" ) ; _prepared = false ; return true ; } protected void prepare ( ) throws IOException { if ( _prepared ) return ; if ( _writer == null && _output == null ) throw new IOException ( "SER002 No writer supplied for serializer" ) ; if ( _output != null ) { if ( _format . getEncoding ( ) == null ) _writer = new OutputStreamWriter ( _output ) ; else _writer = Encodings . getWriter ( _output , _format . getEncoding ( ) ) ; } if ( _format . getEncoding ( ) == null ) _lastPrintable = Encodings . getLastPrintable ( ) ; else _lastPrintable = Encodings . getLastPrintable ( _format . getEncoding ( ) ) ; if ( _format . getIndenting ( ) ) { _indenting = true ; _printer = new IndentPrinter ( _writer , _format ) ; } else { _indenting = false ; _printer = new Printer ( _writer , _format ) ; } ElementState state ; _elementStateCount = 0 ; state = _elementStates [ 0 ] ; state . namespaceURI = null ; state . localName = null ; state . rawName = null ; state . preserveSpace = _format . getPreserveSpace ( ) ; state . empty = true ; state . afterElement = false ; state . doCData = state . inCData = false ; state . prefixes = null ; _docTypePublicId = _format . getDoctypePublic ( ) ; _docTypeSystemId = _format . getDoctypeSystem ( ) ; _started = false ; _prepared = true ; } public void serialize ( Element elem ) throws IOException { prepare ( ) ; serializeNode ( elem ) ; _printer . flush ( ) ; if ( _printer . getException ( ) != null ) throw _printer . getException ( ) ; } public void serialize ( DocumentFragment frag ) throws IOException { prepare ( ) ; serializeNode ( frag ) ; _printer . flush ( ) ; if ( _printer . getException ( ) != null ) throw _printer . getException ( ) ; } public void serialize ( Document doc ) throws IOException { prepare ( ) ; serializeNode ( doc ) ; serializePreRoot ( ) ; _printer . flush ( ) ; if ( _printer . getException ( ) != null ) throw _printer . getException ( ) ; } public void startDocument ( ) throws SAXException { try { prepare ( ) ; } catch ( IOException except ) { throw new SAXException ( except . toString ( ) ) ; } } public void characters ( char [ ] chars , int start , int length ) { ElementState state ; state = content ( ) ; if ( state . inCData || state . doCData ) { int saveIndent ; if ( ! state . inCData ) { _printer . printText ( "<![CDATA[" ) ; state . inCData = true ; } saveIndent = _printer . getNextIndent ( ) ; _printer . setNextIndent ( 0 ) ; for ( int index = 0 ; index < length ; ++ index ) { if ( index + 2 < length && chars [ index ] == ']' && chars [ index + 1 ] == ']' && chars [ index + 2 ] == '>' ) { printText ( chars , start , index + 2 , true , true ) ; _printer . printText ( "]]><![CDATA[" ) ; start += index + 2 ; length -= index + 2 ; index = 0 ; } } if ( length > 0 ) printText ( chars , start , length , true , true ) ; _printer . setNextIndent ( saveIndent ) ; } else { int saveIndent ; if ( state . preserveSpace ) { saveIndent = _printer . getNextIndent ( ) ; _printer . setNextIndent ( 0 ) ; printText ( chars , start , length , true , state . unescaped ) ; _printer . setNextIndent ( saveIndent ) ; } else { printText ( chars , start , length , false , state . unescaped ) ; } } } public void ignorableWhitespace ( char [ ] chars , int start , int length ) { int i ; content ( ) ; if ( _indenting ) { _printer . setThisIndent ( 0 ) ; for ( i = start ; length -- > 0 ; ++ i ) _printer . printText ( chars [ i ] ) ; } } public void processingInstruction ( String target , String code ) { int index ; StringBuffer buffer ; ElementState state ; state = content ( ) ; buffer = new StringBuffer ( 40 ) ; index = target . indexOf ( "?>" ) ; if ( index >= 0 ) buffer . append ( "<?" ) . append ( target . substring ( 0 , index ) ) ; else buffer . append ( "<?" ) . append ( target ) ; if ( code != null ) { buffer . append ( ' ' ) ; index = code . indexOf ( "?>" ) ; if ( index >= 0 ) buffer . append ( code . substring ( 0 , index ) ) ; else buffer . append ( code ) ; } buffer . append ( "?>" ) ; if ( isDocumentState ( ) ) { if ( _preRoot == null ) _preRoot = new Vector ( ) ; _preRoot . addElement ( buffer . toString ( ) ) ; } else { _printer . indent ( ) ; printText ( buffer . toString ( ) , true , true ) ; _printer . unindent ( ) ; } } public void comment ( char [ ] chars , int start , int length ) { comment ( new String ( chars , start , length ) ) ; } public void comment ( String text ) { StringBuffer buffer ; int index ; ElementState state ; if ( _format . getOmitComments ( ) ) return ; state = content ( ) ; buffer = new StringBuffer ( 40 ) ; index = text . indexOf ( "-->" ) ; if ( index >= 0 ) buffer . append ( "<!--" ) . append ( text . substring ( 0 , index ) ) . append ( "-->" ) ; else buffer . append ( "<!--" ) . append ( text ) . append ( "-->" ) ; if ( isDocumentState ( ) ) { if ( _preRoot == null ) _preRoot = new Vector ( ) ; _preRoot . addElement ( buffer . toString ( ) ) ; } else { _printer . indent ( ) ; printText ( buffer . toString ( ) , false , true ) ; _printer . unindent ( ) ; } } public void startCDATA ( ) { ElementState state ; state = getElementState ( ) ; state . doCData = true ; } public void endCDATA ( ) { ElementState state ; state = getElementState ( ) ; state . doCData = false ; } public void startNonEscaping ( ) { ElementState state ; state = getElementState ( ) ; state . unescaped = true ; } public void endNonEscaping ( ) { ElementState state ; state = getElementState ( ) ; state . unescaped = false ; } public void startPreserving ( ) { ElementState state ; state = getElementState ( ) ; state . preserveSpace = true ; } public void endPreserving ( ) { ElementState state ; state = getElementState ( ) ; state . preserveSpace = false ; } public void endDocument ( ) throws SAXException { serializePreRoot ( ) ; _printer . flush ( ) ; if ( _printer . getException ( ) != null ) throw new SAXException ( _printer . getException ( ) ) ; } public void startEntity ( String name ) { } public void endEntity ( String name ) { } public void setDocumentLocator ( Locator locator ) { } public void skippedEntity ( String name ) throws SAXException { endCDATA ( ) ; content ( ) ; _printer . printText ( '&' ) ; _printer . printText ( name ) ; _printer . printText ( ';' ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { if ( _prefixes == null ) _prefixes = new Hashtable ( ) ; _prefixes . put ( uri , prefix == null ? "" : prefix ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { } public void startDTD ( String name , String publicId , String systemId ) { _printer . enterDTD ( ) ; _docTypePublicId = publicId ; _docTypeSystemId = systemId ; } public void endDTD ( ) { } public void elementDecl ( String name , String model ) { _printer . enterDTD ( ) ; _printer . printText ( "<!ELEMENT " ) ; _printer . printText ( name ) ; _printer . printText ( ' ' ) ; _printer . printText ( model ) ; _printer . printText ( '>' ) ; if ( _indenting ) _printer . breakLine ( ) ; } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) { _printer . enterDTD ( ) ; _printer . printText ( "<!ATTLIST " ) ; _printer . printText ( eName ) ; _printer . printText ( ' ' ) ; _printer . printText ( aName ) ; _printer . printText ( ' ' ) ; _printer . printText ( type ) ; if ( valueDefault != null ) { _printer . printText ( ' ' ) ; _printer . printText ( valueDefault ) ; } if ( value != null ) { _printer . printText ( " \"" ) ; printEscaped ( value ) ; _printer . printText ( '"' ) ; } _printer . printText ( '>' ) ; if ( _indenting ) _printer . breakLine ( ) ; } public void internalEntityDecl ( String name , String value ) { _printer . enterDTD ( ) ; _printer . printText ( "<!ENTITY " ) ; _printer . printText ( name ) ; _printer . printText ( " \"" ) ; printEscaped ( value ) ; _printer . printText ( "\">" ) ; if ( _indenting ) _printer . breakLine ( ) ; } public void externalEntityDecl ( String name , String publicId , String systemId ) { _printer . enterDTD ( ) ; unparsedEntityDecl ( name , publicId , systemId , null ) ; } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) { _printer . enterDTD ( ) ; if ( publicId == null ) { _printer . printText ( "<!ENTITY " ) ; _printer . printText ( name ) ; _printer . printText ( " SYSTEM " ) ; printDoctypeURL ( systemId ) ; } else { _printer . printText ( "<!ENTITY " ) ; _printer . printText ( name ) ; _printer . printText ( " PUBLIC " ) ; printDoctypeURL ( publicId ) ; _printer . printText ( ' ' ) ; printDoctypeURL ( systemId ) ; } if ( notationName != null ) { _printer . printText ( " NDATA " ) ; _printer . printText ( notationName ) ; } _printer . printText ( '>' ) ; if ( _indenting ) _printer . breakLine ( ) ; } public void notationDecl ( String name , String publicId , String systemId ) { _printer . enterDTD ( ) ; if ( publicId != null ) { _printer . printText ( "<!NOTATION " ) ; _printer . printText ( name ) ; _printer . printText ( " PUBLIC " ) ; printDoctypeURL ( publicId ) ; if ( systemId != null ) { _printer . printText ( ' ' ) ; printDoctypeURL ( systemId ) ; } } else { _printer . printText ( "<!NOTATION " ) ; _printer . printText ( name ) ; _printer . printText ( " SYSTEM " ) ; printDoctypeURL ( systemId ) ; } _printer . printText ( '>' ) ; if ( _indenting ) _printer . breakLine ( ) ; } protected void serializeNode ( Node node ) { switch ( node . getNodeType ( ) ) { case Node . TEXT_NODE : { String text ; text = node . getNodeValue ( ) ; if ( text != null ) characters ( node . getNodeValue ( ) ) ; break ; } case Node . CDATA_SECTION_NODE : { String text ; text = node . getNodeValue ( ) ; if ( text != null ) { startCDATA ( ) ; characters ( node . getNodeValue ( ) ) ; endCDATA ( ) ; } break ; } case Node . COMMENT_NODE : { String text ; if ( ! _format . getOmitComments ( ) ) { text = node . getNodeValue ( ) ; if ( text != null ) comment ( node . getNodeValue ( ) ) ; } break ; } case Node . ENTITY_REFERENCE_NODE : { Node child ; endCDATA ( ) ; content ( ) ; child = node . getFirstChild ( ) ; while ( child != null ) { serializeNode ( child ) ; child = child . getNextSibling ( ) ; } break ; } case Node . PROCESSING_INSTRUCTION_NODE : processingInstruction ( node . getNodeName ( ) , node . getNodeValue ( ) ) ; break ; case Node . ELEMENT_NODE : serializeElement ( ( Element ) node ) ; break ; case Node . DOCUMENT_NODE : { DocumentType docType ; DOMImplementation domImpl ; NamedNodeMap map ; Entity entity ; Notation notation ; int i ; docType = ( ( Document ) node ) . getDoctype ( ) ; if ( docType != null ) { domImpl = ( ( Document ) node ) . getImplementation ( ) ; try { String internal ; startDTD ( docType . getName ( ) , docType . getPublicId ( ) , docType . getSystemId ( ) ) ; internal = docType . getInternalSubset ( ) ; if ( internal != null && internal . length ( ) > 0 ) _printer . printText ( internal ) ; endDTD ( ) ; } catch ( NoSuchMethodError nsme ) { Class docTypeClass = docType . getClass ( ) ; String docTypePublicId = null ; String docTypeSystemId = null ; try { java . lang . reflect . Method getPublicId = docTypeClass . getMethod ( "getPublicId" , null ) ; if ( getPublicId . getReturnType ( ) . equals ( String . class ) ) { docTypePublicId = ( String ) getPublicId . invoke ( docType , null ) ; } } catch ( Exception e ) { } try { java . lang . reflect . Method getSystemId = docTypeClass . getMethod ( "getSystemId" , null ) ; if ( getSystemId . getReturnType ( ) . equals ( String . class ) ) { docTypeSystemId = ( String ) getSystemId . invoke ( docType , null ) ; } } catch ( Exception e ) { } startDTD ( docType . getName ( ) , docTypePublicId , docTypeSystemId ) ; endDTD ( ) ; } } } case Node . DOCUMENT_FRAGMENT_NODE : { Node child ; child = node . getFirstChild ( ) ; while ( child != null ) { serializeNode ( child ) ; child = child . getNextSibling ( ) ; } break ; } default : break ; } } protected ElementState content ( ) { ElementState state ; state = getElementState ( ) ; if ( ! isDocumentState ( ) ) { if ( state . inCData && ! state . doCData ) { _printer . printText ( "]]>" ) ; state . inCData = false ; } if ( state . empty ) { _printer . printText ( '>' ) ; state . empty = false ; } state . afterElement = false ; } return state ; } protected void characters ( String text ) { ElementState state ; state = content ( ) ; if ( state . inCData || state . doCData ) { StringBuffer buffer ; int index ; int saveIndent ; buffer = new StringBuffer ( text . length ( ) ) ; if ( ! state . inCData ) { buffer . append ( "<![CDATA[" ) ; state . inCData = true ; } index = text . indexOf ( "]]>" ) ; while ( index >= 0 ) { buffer . append ( text . substring ( 0 , index + 2 ) ) . append ( "]]><![CDATA[" ) ; text = text . substring ( index + 2 ) ; index = text . indexOf ( "]]>" ) ; } buffer . append ( text ) ; saveIndent = _printer . getNextIndent ( ) ; _printer . setNextIndent ( 0 ) ; printText ( buffer . toString ( ) , true , true ) ; _printer . setNextIndent ( saveIndent ) ; } else { int saveIndent ; if ( state . preserveSpace ) { saveIndent = _printer . getNextIndent ( ) ; _printer . setNextIndent ( 0 ) ; printText ( text , true , state . unescaped ) ; _printer . setNextIndent ( saveIndent ) ; } else { printText ( text , false , state . unescaped ) ; } } } protected abstract String getEntityRef ( char ch ) ; protected abstract void serializeElement ( Element elem ) ; protected void serializePreRoot ( ) { int i ; if ( _preRoot != null ) { for ( i = 0 ; i < _preRoot . size ( ) ; ++ i ) { printText ( ( String ) _preRoot . elementAt ( i ) , true , true ) ; _printer . breakLine ( ) ; } _preRoot . removeAllElements ( ) ; } } protected final void printText ( char [ ] chars , int start , int length , boolean preserveSpace , boolean unescaped ) { int index ; char ch ; if ( preserveSpace ) { while ( length -- > 0 ) { ch = chars [ start ] ; ++ start ; if ( ch == '\n' || ch == '\r' || unescaped ) _printer . printText ( ch ) ; else printEscaped ( ch ) ; } } else { while ( length -- > 0 ) { ch = chars [ start ] ; ++ start ; if ( ch == ' ' || ch == '\f' || ch == '\t' || ch == '\n' || ch == '\r' ) _printer . printSpace ( ) ; else if ( unescaped ) _printer . printText ( ch ) ; else printEscaped ( ch ) ; } } } protected final void printText ( String text , boolean preserveSpace , boolean unescaped ) { int index ; char ch ; if ( preserveSpace ) { for ( index = 0 ; index < text . length ( ) ; ++ index ) { ch = text . charAt ( index ) ; if ( ch == '\n' || ch == '\r' || unescaped ) _printer . printText ( ch ) ; else printEscaped ( ch ) ; } } else { for ( index = 0 ; index < text . length ( ) ; ++ index ) { ch = text . charAt ( index ) ; if ( ch == ' ' || ch == '\f' || ch == '\t' || ch == '\n' || ch == '\r' ) _printer . printSpace ( ) ; else if ( unescaped ) _printer . printText ( ch ) ; else printEscaped ( ch ) ; } } } protected void printDoctypeURL ( String url ) { int i ; _printer . printText ( '"' ) ; for ( i = 0 ; i < url . length ( ) ; ++ i ) { if ( url . charAt ( i ) == '"' || url . charAt ( i ) < 0x20 || url . charAt ( i ) > 0x7F ) { _printer . printText ( '%' ) ; _printer . printText ( Integer . toHexString ( url . charAt ( i ) ) ) ; } else _printer . printText ( url . charAt ( i ) ) ; } _printer . printText ( '"' ) ; } protected void printEscaped ( char ch ) { String charRef ; charRef = getEntityRef ( ch ) ; if ( charRef != null ) { _printer . printText ( '&' ) ; _printer . printText ( charRef ) ; _printer . printText ( ';' ) ; } else if ( ( ch >= ' ' && ch <= _lastPrintable && ch != 0xF7 ) || ch == '\n' || ch == '\r' || ch == '\t' ) { _printer . printText ( ch ) ; } else { _printer . printText ( "&#" ) ; _printer . printText ( Integer . toString ( ch ) ) ; _printer . printText ( ';' ) ; } } protected void printEscaped ( String source ) { for ( int i = 0 ; i < source . length ( ) ; ++ i ) printEscaped ( source . charAt ( i ) ) ; } protected ElementState getElementState ( ) { return _elementStates [ _elementStateCount ] ; } protected ElementState enterElementState ( String namespaceURI , String localName , String rawName , boolean preserveSpace ) { ElementState state ; if ( _elementStateCount + 1 == _elementStates . length ) { ElementState [ ] newStates ; newStates = new ElementState [ _elementStates . length + 10 ] ; for ( int i = 0 ; i < _elementStates . length ; ++ i ) newStates [ i ] = _elementStates [ i ] ; for ( int i = _elementStates . length ; i < newStates . length ; ++ i ) newStates [ i ] = new ElementState ( ) ; _elementStates = newStates ; } ++ _elementStateCount ; state = _elementStates [ _elementStateCount ] ; state . namespaceURI = namespaceURI ; state . localName = localName ; state . rawName = rawName ; state . preserveSpace = preserveSpace ; state . empty = true ; state . afterElement = false ; state . doCData = state . inCData = false ; state . unescaped = false ; state . prefixes = _prefixes ; _prefixes = null ; return state ; } protected ElementState leaveElementState ( ) { if ( _elementStateCount > 0 ) { _prefixes = _elementStates [ _elementStateCount ] . prefixes ; -- _elementStateCount ; return _elementStates [ _elementStateCount ] ; } else throw new IllegalStateException ( "Internal error: element state is zero" ) ; } protected boolean isDocumentState ( ) { return _elementStateCount == 0 ; } protected String getPrefix ( String namespaceURI ) { String prefix ; if ( _prefixes != null ) { prefix = ( String ) _prefixes . get ( namespaceURI ) ; if ( prefix != null ) return prefix ; } if ( _elementStateCount == 0 ) return null ; else { for ( int i = _elementStateCount ; i > 0 ; -- i ) { if ( _elementStates [ i ] . prefixes != null ) { prefix = ( String ) _elementStates [ i ] . prefixes . get ( namespaceURI ) ; if ( prefix != null ) return prefix ; } } } return null ; } } 	0
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . CharDataChunk ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringHasher ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . ImplementationMessages ; import org . xml . sax . SAXParseException ; import java . util . Vector ; abstract class AbstractCharReader extends XMLEntityReader { protected AbstractCharReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , StringPool stringPool ) { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fStringPool = stringPool ; fCurrentChunk = CharDataChunk . createChunk ( fStringPool , null ) ; } protected CharDataChunk fCurrentChunk = null ; protected int fCurrentIndex = 0 ; protected char [ ] fMostRecentData = null ; protected int fMostRecentChar = 0 ; protected int fLength = 0 ; protected abstract int fillCurrentChunk ( ) throws Exception ; protected void deferException ( int errorCode , Object [ ] args , int offset ) { if ( fDeferredErrors == null ) fDeferredErrors = new Vector ( ) ; DeferredError de = new DeferredError ( errorCode , args , offset ) ; fDeferredErrors . addElement ( de ) ; } protected XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; return nextReader ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } public boolean lookingAtChar ( char chr , boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch != chr ) { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( chr , skipPastChar ) ; } } return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ; } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0xD800 ) { if ( ch >= 0x20 || ch == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } if ( ch == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } return true ; } if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } if ( ch > 0xFFFD ) { return false ; } if ( ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; boolean valid = ( ch >= 0xDC00 && ch < 0xE000 ) ; if ( ! valid || ! skipPastChar ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return valid ; } } else if ( ch < 0xE000 ) { return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ; return true ; } public void skipToChar ( char chr ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == chr ) return ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( chr ) ; return ; } fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch >= 0xD800 && ch < 0xDC00 ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) continue ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } ch = loadNextChar ( ) ; } } public void skipPastName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return ; } while ( true ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int length = s . length ; char [ ] data = fMostRecentData ; int index = fCurrentIndex ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { for ( int i = 0 ; i < length ; i ++ ) { if ( data [ index ++ ] != s [ i ] ) return false ; } fCharacterCounter += length ; fCurrentOffset += length ; fCurrentIndex = index ; if ( index == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = data [ index ] & 0xFFFF ; return true ; } CharDataChunk dataChunk = fCurrentChunk ; int offset = fCurrentOffset ; int savedIndex = index ; int i = 0 ; while ( index < CharDataChunk . CHUNK_SIZE ) { if ( data [ index ++ ] != s [ i ++ ] ) return false ; } slowLoadNextChar ( ) ; data = fMostRecentData ; index = 0 ; while ( i < length ) { if ( data [ index ++ ] != s [ i ++ ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } fCharacterCounter += length ; fCurrentOffset += length ; fCurrentIndex = index ; if ( index == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = data [ index ] & 0xFFFF ; return true ; } public int scanInvalidChar ( ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } if ( fDeferredErrors != null ) { for ( int i = 0 ; i < fDeferredErrors . size ( ) ; i ++ ) { DeferredError de = ( DeferredError ) fDeferredErrors . elementAt ( i ) ; if ( de . offset == fCurrentIndex ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , de . errorCode , 0 , de . args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; fDeferredErrors . removeElementAt ( i ) ; fCharacterCounter ++ ; loadNextChar ( ) ; return - 1 ; } } } fCharacterCounter ++ ; loadNextChar ( ) ; } else { fCharacterCounter ++ ; if ( ch >= 0xD800 && ch < 0xDC00 ) { int ch2 = loadNextChar ( ) ; if ( ch2 >= 0xDC00 && ch2 < 0xE000 ) { ch = ( ( ch - 0xD800 ) << 10 ) + ( ch2 - 0xDC00 ) + 0x10000 ; loadNextChar ( ) ; } } else loadNextChar ( ) ; } return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextChar ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentChar ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextChar ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextChar ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( lookingAtChar ( qchar , false ) ) { break ; } if ( lookingAtChar ( ' ' , true ) ) { continue ; } if ( lookingAtSpace ( false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '<' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } int result = asSymbol ? addSymbol ( offset , fCurrentOffset - offset ) : addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return result ; } public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } if ( qchar != - 1 && lookingAtChar ( ( char ) qchar , false ) ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; break ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; } if ( lookingAtChar ( '%' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } int result = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( ( char ) qchar , true ) ; return result ; } public int scanName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return - 1 ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return - 1 ; } int offset = fCurrentOffset ; int index = fCurrentIndex ; char [ ] data = fMostRecentData ; if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; int hashcode = 0 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = data [ index ] & 0xFFFF ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; } fCurrentIndex = index ; fMostRecentChar = ch ; hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; int nameIndex = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; return nameIndex ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int ch = fMostRecentChar ; for ( int i = 0 ; i < len ; i ++ ) { if ( ch != expected [ offset ++ ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } fCharacterCounter ++ ; fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) ch = slowLoadNextChar ( ) ; else ch = ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; int index = fCurrentIndex ; char [ ] data = fMostRecentData ; if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; int hashcode = 0 ; int prefixend = - 1 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = data [ index ] & 0xFFFF ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; if ( index + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; ch = slowLoadNextChar ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; } else ch = data [ index + 1 ] & 0xFFFF ; boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; break ; } } } else { if ( fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; } fCurrentIndex = index ; fMostRecentChar = ch ; hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; qname . rawname = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentChar ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeMarkup ( ch ) ; } break ; case 2 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } break ; case 3 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch != ']' ) break ; if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) break ; fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , true ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } break ; } } else if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , false ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextChar ( ) ; break ; } callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentChar ; } } } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool fStringPool = null ; private boolean fCalledCharPropInit = false ; private boolean fCallClearPreviousChunk = true ; private Vector fDeferredErrors = null ; private class DeferredError { int errorCode ; Object [ ] args ; int offset ; DeferredError ( int ec , Object [ ] a , int o ) { errorCode = ec ; args = a ; offset = o ; } } private int recognizeMarkup ( int ch ) throws Exception { switch ( ch ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( ch == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } private boolean skipMultiByteCharData ( int ch ) throws Exception { if ( ch < 0xD800 ) { loadNextChar ( ) ; return true ; } if ( ch > 0xFFFD ) return false ; if ( ch >= 0xDC00 && ch < 0xE000 ) return false ; if ( ch >= 0xD800 && ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } loadNextChar ( ) ; return true ; } private int skipAsciiCharData ( ) throws Exception { int index = fCurrentIndex ; int offset = fCurrentOffset - index ; while ( true ) { char [ ] data = fMostRecentData ; while ( index < CharDataChunk . CHUNK_SIZE ) { int ch = data [ index ] & 0xFFFF ; if ( ch >= 0x80 ) { fCurrentOffset = offset + index ; fCurrentIndex = index ; fMostRecentChar = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { fCurrentOffset = offset + index ; fCurrentIndex = index ; fMostRecentChar = ch ; return ch ; } index ++ ; } offset += index ; slowLoadNextChar ( ) ; index = 0 ; } } private void callCharDataHandler ( int offset , int endOffset , boolean isWhitespace ) throws Exception { int length = endOffset - offset ; if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , length ) ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( stringIndex ) ; else fCharDataHandler . processCharacters ( stringIndex ) ; return ; } CharDataChunk dataChunk = fCurrentChunk . chunkFor ( offset ) ; int index = offset & CharDataChunk . CHUNK_MASK ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { if ( length != 0 ) { if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , length ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , length ) ; } return ; } int count = length ; int nbytes = CharDataChunk . CHUNK_SIZE - index ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , nbytes ) ; count -= nbytes ; do { dataChunk = dataChunk . nextChunk ( ) ; if ( dataChunk == null ) { throw new RuntimeException ( new ImplementationMessages ( ) . createMessage ( null , ImplementationMessages . INT_DCN , 0 , null ) ) ; } nbytes = count <= CharDataChunk . CHUNK_SIZE ? count : CharDataChunk . CHUNK_SIZE ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; count -= nbytes ; } while ( count > 0 ) ; } private int slowLoadNextChar ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toCharArray ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } else { fCurrentChunk = CharDataChunk . createChunk ( fStringPool , fCurrentChunk ) ; return fillCurrentChunk ( ) ; } } private int loadNextChar ( ) throws Exception { fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) return slowLoadNextChar ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } } 	1
package org . apache . xml . serialize ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . BufferedReader ; import java . util . Hashtable ; public final class HTMLdtd { private static Hashtable _byChar ; private static Hashtable _byName ; private static Hashtable _boolAttrs ; private static Hashtable _elemDefs ; private static final String ENTITIES_RESOURCE = "HTMLEntities.res" ; private static final int ONLY_OPENING = 0x0001 ; private static final int ELEM_CONTENT = 0x0002 ; private static final int PRESERVE = 0x0004 ; private static final int OPT_CLOSING = 0x0008 ; private static final int EMPTY = 0x0010 | ONLY_OPENING ; private static final int ALLOWED_HEAD = 0x0020 ; private static final int CLOSE_P = 0x0040 ; private static final int CLOSE_DD_DT = 0x0080 ; private static final int CLOSE_SELF = 0x0100 ; private static final int CLOSE_TABLE = 0x0200 ; private static final int CLOSE_TH_TD = 0x04000 ; public static boolean isEmptyTag ( String tagName ) { return isElement ( tagName , EMPTY ) ; } public static boolean isElementContent ( String tagName ) { return isElement ( tagName , ELEM_CONTENT ) ; } public static boolean isPreserveSpace ( String tagName ) { return isElement ( tagName , PRESERVE ) ; } public static boolean isOptionalClosing ( String tagName ) { return isElement ( tagName , OPT_CLOSING ) ; } public static boolean isOnlyOpening ( String tagName ) { return isElement ( tagName , ONLY_OPENING ) ; } public static boolean isClosing ( String tagName , String openTag ) { if ( openTag . equalsIgnoreCase ( "HEAD" ) ) return ! isElement ( tagName , ALLOWED_HEAD ) ; if ( openTag . equalsIgnoreCase ( "P" ) ) return isElement ( tagName , CLOSE_P ) ; if ( openTag . equalsIgnoreCase ( "DT" ) || openTag . equalsIgnoreCase ( "DD" ) ) return isElement ( tagName , CLOSE_DD_DT ) ; if ( openTag . equalsIgnoreCase ( "LI" ) || openTag . equalsIgnoreCase ( "OPTION" ) ) return isElement ( tagName , CLOSE_SELF ) ; if ( openTag . equalsIgnoreCase ( "THEAD" ) || openTag . equalsIgnoreCase ( "TFOOT" ) || openTag . equalsIgnoreCase ( "TBODY" ) || openTag . equalsIgnoreCase ( "TR" ) || openTag . equalsIgnoreCase ( "COLGROUP" ) ) return isElement ( tagName , CLOSE_TABLE ) ; if ( openTag . equalsIgnoreCase ( "TH" ) || openTag . equalsIgnoreCase ( "TD" ) ) return isElement ( tagName , CLOSE_TH_TD ) ; return false ; } public static boolean isURI ( String tagName , String attrName ) { return ( attrName . equalsIgnoreCase ( "href" ) || attrName . equalsIgnoreCase ( "src" ) ) ; } public static boolean isBoolean ( String tagName , String attrName ) { String [ ] attrNames ; attrNames = ( String [ ] ) _boolAttrs . get ( tagName . toUpperCase ( ) ) ; if ( attrNames == null ) return false ; for ( int i = 0 ; i < attrNames . length ; ++ i ) if ( attrNames [ i ] . equalsIgnoreCase ( attrName ) ) return true ; return false ; } public static int charFromName ( String name ) { Object value ; initialize ( ) ; value = _byName . get ( name ) ; if ( value != null && value instanceof Character ) return ( ( Character ) value ) . charValue ( ) ; else return - 1 ; } public static String fromChar ( char value ) { String name ; initialize ( ) ; name = ( String ) _byChar . get ( String . valueOf ( value ) ) ; if ( name == null ) return null ; else return name ; } private static void initialize ( ) { InputStream is = null ; BufferedReader reader = null ; int index ; String name ; String value ; int code ; String line ; if ( _byName != null ) return ; try { _byName = new Hashtable ( ) ; _byChar = new Hashtable ( ) ; is = HTMLdtd . class . getResourceAsStream ( ENTITIES_RESOURCE ) ; if ( is == null ) throw new RuntimeException ( "SER003 The resource [" + ENTITIES_RESOURCE + "] could not be found.\n" + ENTITIES_RESOURCE ) ; reader = new BufferedReader ( new InputStreamReader ( is ) ) ; line = reader . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 || line . charAt ( 0 ) == '#' ) { line = reader . readLine ( ) ; continue ; } index = line . indexOf ( ' ' ) ; if ( index > 1 ) { name = line . substring ( 0 , index ) ; ++ index ; if ( index < line . length ( ) ) { value = line . substring ( index ) ; index = value . indexOf ( ' ' ) ; if ( index > 0 ) value = value . substring ( 0 , index ) ; code = Integer . parseInt ( value ) ; defineEntity ( name , ( char ) code ) ; } } line = reader . readLine ( ) ; } is . close ( ) ; } catch ( Exception except ) { throw new RuntimeException ( "SER003 The resource [" + ENTITIES_RESOURCE + "] could not load: " + except . toString ( ) + "\n" + ENTITIES_RESOURCE + "\t" + except . toString ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( Exception except ) { } } } } private static void defineEntity ( String name , char value ) { if ( _byName . get ( name ) == null ) { _byName . put ( name , new Character ( value ) ) ; _byChar . put ( String . valueOf ( value ) , name ) ; } } private static void defineElement ( String name , int flags ) { _elemDefs . put ( name , new Integer ( flags ) ) ; } private static void defineBoolean ( String tagName , String attrName ) { defineBoolean ( tagName , new String [ ] { attrName } ) ; } private static void defineBoolean ( String tagName , String [ ] attrNames ) { _boolAttrs . put ( tagName , attrNames ) ; } private static boolean isElement ( String name , int flag ) { Integer flags ; flags = ( Integer ) _elemDefs . get ( name . toUpperCase ( ) ) ; if ( flags == null ) return false ; else return ( ( flags . intValue ( ) & flag ) == flag ) ; } static { _elemDefs = new Hashtable ( ) ; defineElement ( "ADDRESS" , CLOSE_P ) ; defineElement ( "AREA" , EMPTY ) ; defineElement ( "BASE" , EMPTY | ALLOWED_HEAD ) ; defineElement ( "BASEFONT" , EMPTY ) ; defineElement ( "BLOCKQUOTE" , CLOSE_P ) ; defineElement ( "BODY" , OPT_CLOSING ) ; defineElement ( "BR" , EMPTY ) ; defineElement ( "COL" , EMPTY ) ; defineElement ( "COLGROUP" , ELEM_CONTENT | OPT_CLOSING | CLOSE_TABLE ) ; defineElement ( "DD" , OPT_CLOSING | ONLY_OPENING | CLOSE_DD_DT ) ; defineElement ( "DIV" , CLOSE_P ) ; defineElement ( "DL" , ELEM_CONTENT | CLOSE_P ) ; defineElement ( "DT" , OPT_CLOSING | ONLY_OPENING | CLOSE_DD_DT ) ; defineElement ( "FIELDSET" , CLOSE_P ) ; defineElement ( "FORM" , CLOSE_P ) ; defineElement ( "FRAME" , EMPTY | OPT_CLOSING ) ; defineElement ( "H1" , CLOSE_P ) ; defineElement ( "H2" , CLOSE_P ) ; defineElement ( "H3" , CLOSE_P ) ; defineElement ( "H4" , CLOSE_P ) ; defineElement ( "H5" , CLOSE_P ) ; defineElement ( "H6" , CLOSE_P ) ; defineElement ( "HEAD" , ELEM_CONTENT | OPT_CLOSING ) ; defineElement ( "HR" , EMPTY | CLOSE_P ) ; defineElement ( "HTML" , ELEM_CONTENT | OPT_CLOSING ) ; defineElement ( "IMG" , EMPTY ) ; defineElement ( "INPUT" , EMPTY ) ; defineElement ( "ISINDEX" , EMPTY | ALLOWED_HEAD ) ; defineElement ( "LI" , OPT_CLOSING | ONLY_OPENING | CLOSE_SELF ) ; defineElement ( "LINK" , EMPTY | ALLOWED_HEAD ) ; defineElement ( "MAP" , ALLOWED_HEAD ) ; defineElement ( "META" , EMPTY | ALLOWED_HEAD ) ; defineElement ( "OL" , ELEM_CONTENT | CLOSE_P ) ; defineElement ( "OPTGROUP" , ELEM_CONTENT ) ; defineElement ( "OPTION" , OPT_CLOSING | ONLY_OPENING | CLOSE_SELF ) ; defineElement ( "P" , OPT_CLOSING | CLOSE_P | CLOSE_SELF ) ; defineElement ( "PARAM" , EMPTY ) ; defineElement ( "PRE" , PRESERVE | CLOSE_P ) ; defineElement ( "SCRIPT" , ALLOWED_HEAD | PRESERVE ) ; defineElement ( "NOSCRIPT" , ALLOWED_HEAD | PRESERVE ) ; defineElement ( "SELECT" , ELEM_CONTENT ) ; defineElement ( "STYLE" , ALLOWED_HEAD | PRESERVE ) ; defineElement ( "TABLE" , ELEM_CONTENT | CLOSE_P ) ; defineElement ( "TBODY" , ELEM_CONTENT | OPT_CLOSING | CLOSE_TABLE ) ; defineElement ( "TD" , OPT_CLOSING | CLOSE_TH_TD ) ; defineElement ( "TEXTAREA" , PRESERVE ) ; defineElement ( "TFOOT" , ELEM_CONTENT | OPT_CLOSING | CLOSE_TABLE ) ; defineElement ( "TH" , OPT_CLOSING | CLOSE_TH_TD ) ; defineElement ( "THEAD" , ELEM_CONTENT | OPT_CLOSING | CLOSE_TABLE ) ; defineElement ( "TITLE" , ALLOWED_HEAD ) ; defineElement ( "TR" , ELEM_CONTENT | OPT_CLOSING | CLOSE_TABLE ) ; defineElement ( "UL" , ELEM_CONTENT | CLOSE_P ) ; _boolAttrs = new Hashtable ( ) ; defineBoolean ( "AREA" , "href" ) ; defineBoolean ( "BUTTON" , "disabled" ) ; defineBoolean ( "DIR" , "compact" ) ; defineBoolean ( "DL" , "compact" ) ; defineBoolean ( "FRAME" , "noresize" ) ; defineBoolean ( "HR" , "noshade" ) ; defineBoolean ( "IMAGE" , "ismap" ) ; defineBoolean ( "INPUT" , new String [ ] { "defaultchecked" , "checked" , "readonly" , "disabled" } ) ; defineBoolean ( "LINK" , "link" ) ; defineBoolean ( "MENU" , "compact" ) ; defineBoolean ( "OBJECT" , "declare" ) ; defineBoolean ( "OL" , "compact" ) ; defineBoolean ( "OPTGROUP" , "disabled" ) ; defineBoolean ( "OPTION" , new String [ ] { "default-selected" , "selected" , "disabled" } ) ; defineBoolean ( "SCRIPT" , "defer" ) ; defineBoolean ( "SELECT" , new String [ ] { "multiple" , "disabled" } ) ; defineBoolean ( "STYLE" , "disabled" ) ; defineBoolean ( "TD" , "nowrap" ) ; defineBoolean ( "TH" , "nowrap" ) ; defineBoolean ( "TEXTAREA" , new String [ ] { "disabled" , "readonly" } ) ; defineBoolean ( "UL" , "compact" ) ; initialize ( ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . range . * ; public class RangeExceptionImpl extends RangeException { public RangeExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLTableSectionElementImpl extends HTMLElementImpl implements HTMLTableSectionElement { public String getAlign ( ) { return capitalize ( getAttribute ( "align" ) ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public String getCh ( ) { String ch ; ch = getAttribute ( "char" ) ; if ( ch != null && ch . length ( ) > 1 ) ch = ch . substring ( 0 , 1 ) ; return ch ; } public void setCh ( String ch ) { if ( ch != null && ch . length ( ) > 1 ) ch = ch . substring ( 0 , 1 ) ; setAttribute ( "char" , ch ) ; } public String getChOff ( ) { return getAttribute ( "charoff" ) ; } public void setChOff ( String chOff ) { setAttribute ( "charoff" , chOff ) ; } public String getVAlign ( ) { return capitalize ( getAttribute ( "valign" ) ) ; } public void setVAlign ( String vAlign ) { setAttribute ( "valign" , vAlign ) ; } public HTMLCollection getRows ( ) { if ( _rows == null ) _rows = new HTMLCollectionImpl ( this , HTMLCollectionImpl . ROW ) ; return _rows ; } public HTMLElement insertRow ( int index ) { HTMLTableRowElementImpl newRow ; newRow = new HTMLTableRowElementImpl ( ( HTMLDocumentImpl ) getOwnerDocument ( ) , "TR" ) ; newRow . insertCell ( 0 ) ; if ( insertRowX ( index , newRow ) >= 0 ) appendChild ( newRow ) ; return newRow ; } int insertRowX ( int index , HTMLTableRowElementImpl newRow ) { Node child ; child = getFirstChild ( ) ; while ( child != null ) { if ( child instanceof HTMLTableRowElement ) { if ( index == 0 ) { insertBefore ( newRow , child ) ; return - 1 ; } -- index ; } child = child . getNextSibling ( ) ; } return index ; } public void deleteRow ( int index ) { deleteRowX ( index ) ; } int deleteRowX ( int index ) { Node child ; child = getFirstChild ( ) ; while ( child != null ) { if ( child instanceof HTMLTableRowElement ) { if ( index == 0 ) { removeChild ( child ) ; return - 1 ; } -- index ; } child = child . getNextSibling ( ) ; } return index ; } public HTMLTableSectionElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } private HTMLCollectionImpl _rows ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ChildAndParentNode extends ChildNode { static final long serialVersionUID = 0 ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ChildAndParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ChildAndParentNode ( ) { } public Node cloneNode ( boolean deep ) { ChildAndParentNode newnode = ( ChildAndParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLEmElementImpl extends WMLElementImpl implements WMLEmElement { public WMLEmElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom . events ; import org . w3c . dom . DOMException ; public interface DocumentEvent { public Event createEvent ( String eventType ) throws DOMException ; } 	1
package org . apache . wml ; public interface WMLUElement extends WMLElement { public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ParentNode extends NodeImpl { static final long serialVersionUID = 2815829867152120872L ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ParentNode ( ) { } public Node cloneNode ( boolean deep ) { ParentNode newnode = ( ParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class ProcessingInstructionImpl extends CharacterDataImpl implements ProcessingInstruction { static final long serialVersionUID = 7554435174099981510L ; protected String target ; public ProcessingInstructionImpl ( DocumentImpl ownerDoc , String target , String data ) { super ( ownerDoc , data ) ; this . target = target ; } public short getNodeType ( ) { return Node . PROCESSING_INSTRUCTION_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return target ; } public String getTarget ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return target ; } public String getData ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } public void setData ( String data ) { setNodeValue ( data ) ; } } 	0
package javax . xml . parsers ; public abstract class DocumentBuilderFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.DocumentBuilderFactory" ; private static String factory = "org.apache.xerces.jaxp.DocumentBuilderFactoryImpl" ; protected DocumentBuilderFactory ( ) { super ( ) ; } public static DocumentBuilderFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( DocumentBuilderFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"" + "javax.xml.parsers.DocumentBuilderFactory\"" ) ; } } public abstract DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLHtmlElement extends HTMLElement { public String getVersion ( ) ; public void setVersion ( String version ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; public class NamedNodeMapImpl implements NamedNodeMap , Serializable { static final long serialVersionUID = - 7039242451046758020L ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short CHANGED = 0x1 << 1 ; protected final static short HASDEFAULTS = 0x1 << 2 ; protected Vector nodes ; protected NodeImpl ownerNode ; protected NamedNodeMapImpl ( NodeImpl ownerNode ) { this . ownerNode = ownerNode ; } public int getLength ( ) { return ( nodes != null ) ? nodes . size ( ) : 0 ; } public Node item ( int index ) { return ( nodes != null && index < nodes . size ( ) ) ? ( Node ) ( nodes . elementAt ( index ) ) : null ; } public Node getNamedItem ( String name ) { int i = findNamePoint ( name , 0 ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node getNamedItemNS ( String namespaceURI , String localName ) { int i = findNamePoint ( namespaceURI , localName ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNamespaceURI ( ) , arg . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { NamedNodeMapImpl newmap = new NamedNodeMapImpl ( ownerNode ) ; newmap . cloneContent ( this ) ; return newmap ; } protected void cloneContent ( NamedNodeMapImpl srcmap ) { if ( srcmap . nodes != null ) { nodes = new Vector ( srcmap . nodes . size ( ) ) ; for ( int i = 0 ; i < srcmap . nodes . size ( ) ; ++ i ) { NodeImpl n = ( NodeImpl ) srcmap . nodes . elementAt ( i ) ; NodeImpl clone = ( NodeImpl ) n . cloneNode ( true ) ; clone . isSpecified ( n . isSpecified ( ) ) ; nodes . insertElementAt ( clone , i ) ; } } } void setReadOnly ( boolean readOnly , boolean deep ) { isReadOnly ( readOnly ) ; if ( deep && nodes != null ) { Enumeration e = nodes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( NodeImpl ) e . nextElement ( ) ) . setReadOnly ( readOnly , deep ) ; } } } boolean getReadOnly ( ) { return isReadOnly ( ) ; } void setOwnerDocument ( DocumentImpl doc ) { if ( nodes != null ) { for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { ( ( NodeImpl ) item ( i ) ) . setOwnerDocument ( doc ) ; } } } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean changed ( ) { return ( flags & CHANGED ) != 0 ; } final void changed ( boolean value ) { flags = ( short ) ( value ? flags | CHANGED : flags & ~ CHANGED ) ; } final boolean hasDefaults ( ) { return ( flags & HASDEFAULTS ) != 0 ; } final void hasDefaults ( boolean value ) { flags = ( short ) ( value ? flags | HASDEFAULTS : flags & ~ HASDEFAULTS ) ; } protected int findNamePoint ( String name , int start ) { int i = 0 ; if ( nodes != null ) { int first = start ; int last = nodes . size ( ) - 1 ; while ( first <= last ) { i = ( first + last ) / 2 ; int test = name . compareTo ( ( ( Node ) ( nodes . elementAt ( i ) ) ) . getNodeName ( ) ) ; if ( test == 0 ) { return i ; } else if ( test < 0 ) { last = i - 1 ; } else { first = i + 1 ; } } if ( first > i ) { i = first ; } } return - 1 - i ; } protected int findNamePoint ( String namespaceURI , String name ) { if ( nodes == null ) return - 1 ; if ( namespaceURI == null ) return - 1 ; if ( name == null ) return - 1 ; for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { NodeImpl a = ( NodeImpl ) nodes . elementAt ( i ) ; if ( namespaceURI . equals ( a . getNamespaceURI ( ) ) && name . equals ( a . getLocalName ( ) ) ) { return i ; } } return - 1 ; } } 	1
package org . w3c . dom . html ; public interface HTMLScriptElement extends HTMLElement { public String getText ( ) ; public void setText ( String text ) ; public String getHtmlFor ( ) ; public void setHtmlFor ( String htmlFor ) ; public String getEvent ( ) ; public void setEvent ( String event ) ; public String getCharset ( ) ; public void setCharset ( String charset ) ; public boolean getDefer ( ) ; public void setDefer ( boolean defer ) ; public String getSrc ( ) ; public void setSrc ( String src ) ; public String getType ( ) ; public void setType ( String type ) ; } 	0
package org . w3c . dom ; public interface NamedNodeMap { public Node getNamedItem ( String name ) ; public Node setNamedItem ( Node arg ) throws DOMException ; public Node removeNamedItem ( String name ) throws DOMException ; public Node item ( int index ) ; public int getLength ( ) ; public Node getNamedItemNS ( String namespaceURI , String localName ) ; public Node setNamedItemNS ( Node arg ) throws DOMException ; public Node removeNamedItemNS ( String namespaceURI , String localName ) throws DOMException ; } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; abstract class XMLEntityReader implements XMLEntityHandler . EntityReader { protected XMLEntityHandler fEntityHandler = null ; protected XMLErrorReporter fErrorReporter = null ; protected boolean fSendCharDataAsCharArray ; protected XMLEntityHandler . CharDataHandler fCharDataHandler = null ; protected boolean fInCDSect = false ; private boolean fStillActive = true ; protected int fCarriageReturnCounter = 1 ; protected int fLinefeedCounter = 1 ; protected int fCharacterCounter = 1 ; protected int fCurrentOffset = 0 ; protected XMLEntityReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray ) { fEntityHandler = entityHandler ; fErrorReporter = errorReporter ; fSendCharDataAsCharArray = sendCharDataAsCharArray ; fCharDataHandler = fEntityHandler . getCharDataHandler ( ) ; } protected XMLEntityReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , int lineNumber , int columnNumber ) { fEntityHandler = entityHandler ; fErrorReporter = errorReporter ; fSendCharDataAsCharArray = sendCharDataAsCharArray ; fCharDataHandler = fEntityHandler . getCharDataHandler ( ) ; fLinefeedCounter = lineNumber ; fCharacterCounter = columnNumber ; } protected void init ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , int lineNumber , int columnNumber ) { fEntityHandler = entityHandler ; fErrorReporter = errorReporter ; fSendCharDataAsCharArray = sendCharDataAsCharArray ; fCharDataHandler = fEntityHandler . getCharDataHandler ( ) ; fLinefeedCounter = lineNumber ; fCharacterCounter = columnNumber ; fStillActive = true ; fInCDSect = false ; fCarriageReturnCounter = 1 ; fCurrentOffset = 0 ; } public int currentOffset ( ) { return fCurrentOffset ; } public int getLineNumber ( ) { if ( fLinefeedCounter > 1 ) return fLinefeedCounter ; else return fCarriageReturnCounter ; } public int getColumnNumber ( ) { return fCharacterCounter ; } public void setInCDSect ( boolean inCDSect ) { fInCDSect = inCDSect ; } public boolean getInCDSect ( ) { return fInCDSect ; } protected XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = null ; if ( fStillActive ) { nextReader = fEntityHandler . changeReaders ( ) ; fStillActive = false ; } return nextReader ; } } 	0
package org . apache . xml . serialize ; import java . util . Hashtable ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Node ; import org . w3c . dom . html . HTMLDocument ; public class OutputFormat { public static class DTD { public static final String HTMLPublicId = "-//W3C//DTD HTML 4.0//EN" ; public static final String HTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; public static final String XHTMLPublicId = "-//W3C//DTD XHTML 1.0 Strict//EN" ; public static final String XHTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; } public static class Defaults { public static final int Indent = 4 ; public static final String Encoding = "UTF-8" ; public static final int LineWidth = 72 ; } private String _method ; private String _version ; private int _indent = 0 ; private String _encoding = Defaults . Encoding ; private String _mediaType ; private String _doctypeSystem ; private String _doctypePublic ; private boolean _omitXmlDeclaration = false ; private boolean _omitDoctype = false ; private boolean _omitComments = false ; private boolean _stripComments = false ; private boolean _standalone = false ; private String [ ] _cdataElements ; private String [ ] _nonEscapingElements ; private String _lineSeparator = LineSeparator . Web ; private int _lineWidth = Defaults . LineWidth ; private boolean _preserve = false ; public OutputFormat ( ) { } public OutputFormat ( String method , String encoding , boolean indenting ) { setMethod ( method ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public OutputFormat ( Document doc ) { setMethod ( whichMethod ( doc ) ) ; setDoctype ( whichDoctypePublic ( doc ) , whichDoctypeSystem ( doc ) ) ; setMediaType ( whichMediaType ( getMethod ( ) ) ) ; } public OutputFormat ( Document doc , String encoding , boolean indenting ) { this ( doc ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public String getMethod ( ) { return _method ; } public void setMethod ( String method ) { _method = method ; } public String getVersion ( ) { return _version ; } public void setVersion ( String version ) { _version = version ; } public int getIndent ( ) { return _indent ; } public boolean getIndenting ( ) { return ( _indent > 0 ) ; } public void setIndent ( int indent ) { if ( indent < 0 ) _indent = 0 ; else _indent = indent ; } public void setIndenting ( boolean on ) { if ( on ) { _indent = Defaults . Indent ; _lineWidth = Defaults . LineWidth ; } else { _indent = 0 ; _lineWidth = 0 ; } } public String getEncoding ( ) { return _encoding ; } public void setEncoding ( String encoding ) { _encoding = encoding ; } public String getMediaType ( ) { return _mediaType ; } public void setMediaType ( String mediaType ) { _mediaType = mediaType ; } public void setDoctype ( String publicId , String systemId ) { _doctypePublic = publicId ; _doctypeSystem = systemId ; } public String getDoctypePublic ( ) { return _doctypePublic ; } public String getDoctypeSystem ( ) { return _doctypeSystem ; } public boolean getOmitComments ( ) { return _omitComments ; } public void setOmitComments ( boolean omit ) { _omitComments = omit ; } public boolean getOmitDocumentType ( ) { return _omitDoctype ; } public void setOmitDocumentType ( boolean omit ) { _omitDoctype = omit ; } public boolean getOmitXMLDeclaration ( ) { return _omitXmlDeclaration ; } public void setOmitXMLDeclaration ( boolean omit ) { _omitXmlDeclaration = omit ; } public boolean getStandalone ( ) { return _standalone ; } public void setStandalone ( boolean standalone ) { _standalone = standalone ; } public String [ ] getCDataElements ( ) { return _cdataElements ; } public boolean isCDataElement ( String tagName ) { int i ; if ( _cdataElements == null ) return false ; for ( i = 0 ; i < _cdataElements . length ; ++ i ) if ( _cdataElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setCDataElements ( String [ ] cdataElements ) { _cdataElements = cdataElements ; } public String [ ] getNonEscapingElements ( ) { return _nonEscapingElements ; } public boolean isNonEscapingElement ( String tagName ) { int i ; if ( _nonEscapingElements == null ) return false ; for ( i = 0 ; i < _nonEscapingElements . length ; ++ i ) if ( _nonEscapingElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setNonEscapingElements ( String [ ] nonEscapingElements ) { _nonEscapingElements = nonEscapingElements ; } public String getLineSeparator ( ) { return _lineSeparator ; } public void setLineSeparator ( String lineSeparator ) { if ( lineSeparator == null ) _lineSeparator = LineSeparator . Web ; else _lineSeparator = lineSeparator ; } public boolean getPreserveSpace ( ) { return _preserve ; } public void setPreserveSpace ( boolean preserve ) { _preserve = preserve ; } public int getLineWidth ( ) { return _lineWidth ; } public void setLineWidth ( int lineWidth ) { if ( lineWidth <= 0 ) _lineWidth = 0 ; else _lineWidth = lineWidth ; } public char getLastPrintable ( ) { if ( getEncoding ( ) != null && ( getEncoding ( ) . equalsIgnoreCase ( "ASCII" ) ) ) return 0xFF ; else return 0xFFFF ; } public static String whichMethod ( Document doc ) { Node node ; String value ; int i ; if ( doc instanceof HTMLDocument ) return Method . HTML ; node = doc . getFirstChild ( ) ; while ( node != null ) { if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( node . getNodeName ( ) . equalsIgnoreCase ( "html" ) ) { return Method . HTML ; } else if ( node . getNodeName ( ) . equalsIgnoreCase ( "root" ) ) { return Method . FOP ; } else { return Method . XML ; } } else if ( node . getNodeType ( ) == Node . TEXT_NODE ) { value = node . getNodeValue ( ) ; for ( i = 0 ; i < value . length ( ) ; ++ i ) if ( value . charAt ( i ) != 0x20 && value . charAt ( i ) != 0x0A && value . charAt ( i ) != 0x09 && value . charAt ( i ) != 0x0D ) return Method . XML ; } node = node . getNextSibling ( ) ; } return Method . XML ; } public static String whichDoctypePublic ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLPublicId ; return null ; } public static String whichDoctypeSystem ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLSystemId ; return null ; } public static String whichMediaType ( String method ) { if ( method . equalsIgnoreCase ( Method . XML ) ) return "text/xml" ; if ( method . equalsIgnoreCase ( Method . HTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . XHTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . TEXT ) ) return "text/plain" ; if ( method . equalsIgnoreCase ( Method . FOP ) ) return "application/pdf" ; return null ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLTemplateElementImpl extends WMLElementImpl implements WMLTemplateElement { public WMLTemplateElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setOnTimer ( String newValue ) { setAttribute ( "ontimer" , newValue ) ; } public String getOnTimer ( ) { return getAttribute ( "ontimer" ) ; } public void setOnEnterBackward ( String newValue ) { setAttribute ( "onenterbackward" , newValue ) ; } public String getOnEnterBackward ( ) { return getAttribute ( "onenterbackward" ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setOnEnterForward ( String newValue ) { setAttribute ( "onenterforward" , newValue ) ; } public String getOnEnterForward ( ) { return getAttribute ( "onenterforward" ) ; } } 	0
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public abstract class SAXParser { protected SAXParser ( ) { super ( ) ; } public void parse ( InputStream stream , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( stream ) , base ) ; } public void parse ( String uri , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( uri ) , base ) ; } public void parse ( File file , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; String path = file . getAbsolutePath ( ) ; if ( File . separatorChar != '/' ) { path = path . replace ( File . separatorChar , '/' ) ; } if ( ! path . startsWith ( "/" ) ) { path = "/" + path ; } if ( ! path . endsWith ( "/" ) && file . isDirectory ( ) ) { path = path + "/" ; } java . net . URL url = new java . net . URL ( "file" , "" , path ) ; this . parse ( new InputSource ( url . toString ( ) ) , base ) ; } public void parse ( InputSource source , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( source == null ) throw new IllegalArgumentException ( ) ; Parser p = this . getParser ( ) ; if ( base != null ) { p . setDocumentHandler ( base ) ; p . setDTDHandler ( base ) ; p . setEntityResolver ( base ) ; p . setErrorHandler ( base ) ; } p . parse ( source ) ; } public abstract Parser getParser ( ) throws SAXException ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; import org . apache . xerces . dom . ElementImpl ; public class HTMLElementImpl extends ElementImpl implements HTMLElement { HTMLElementImpl ( HTMLDocumentImpl owner , String tagName ) { super ( owner , tagName . toUpperCase ( ) ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setId ( String id ) { setAttribute ( "id" , id ) ; } public String getTitle ( ) { return getAttribute ( "title" ) ; } public void setTitle ( String title ) { setAttribute ( "title" , title ) ; } public String getLang ( ) { return getAttribute ( "lang" ) ; } public void setLang ( String lang ) { setAttribute ( "lang" , lang ) ; } public String getDir ( ) { return getAttribute ( "dir" ) ; } public void setDir ( String dir ) { setAttribute ( "dir" , dir ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setClassName ( String className ) { setAttribute ( "class" , className ) ; } int getInteger ( String value ) { try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException except ) { return 0 ; } } boolean getBinary ( String name ) { return ( getAttributeNode ( name ) != null ) ; } void setAttribute ( String name , boolean value ) { if ( value ) setAttribute ( name , name ) ; else removeAttribute ( name ) ; } public Attr getAttributeNode ( String attrName ) { return super . getAttributeNode ( attrName . toLowerCase ( ) ) ; } public Attr getAttributeNodeNS ( String namespaceURI , String localName ) { if ( namespaceURI != null && namespaceURI . length ( ) > 0 ) return super . getAttributeNodeNS ( namespaceURI , localName ) ; else return super . getAttributeNode ( localName . toLowerCase ( ) ) ; } public String getAttribute ( String attrName ) { return super . getAttribute ( attrName . toLowerCase ( ) ) ; } public String getAttributeNS ( String namespaceURI , String localName ) { if ( namespaceURI != null && namespaceURI . length ( ) > 0 ) return super . getAttributeNS ( namespaceURI , localName ) ; else return super . getAttribute ( localName . toLowerCase ( ) ) ; } public final NodeList getElementsByTagName ( String tagName ) { return super . getElementsByTagName ( tagName . toUpperCase ( ) ) ; } public final NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { if ( namespaceURI != null && namespaceURI . length ( ) > 0 ) return super . getElementsByTagNameNS ( namespaceURI , localName . toUpperCase ( ) ) ; else return super . getElementsByTagName ( localName . toUpperCase ( ) ) ; } String capitalize ( String value ) { char [ ] chars ; int i ; chars = value . toCharArray ( ) ; if ( chars . length > 0 ) { chars [ 0 ] = Character . toUpperCase ( chars [ 0 ] ) ; for ( i = 1 ; i < chars . length ; ++ i ) chars [ i ] = Character . toLowerCase ( chars [ i ] ) ; return String . valueOf ( chars ) ; } return value ; } String getCapitalized ( String name ) { String value ; char [ ] chars ; int i ; value = getAttribute ( name ) ; if ( value != null ) { chars = value . toCharArray ( ) ; if ( chars . length > 0 ) { chars [ 0 ] = Character . toUpperCase ( chars [ 0 ] ) ; for ( i = 1 ; i < chars . length ; ++ i ) chars [ i ] = Character . toLowerCase ( chars [ i ] ) ; return String . valueOf ( chars ) ; } } return value ; } public HTMLFormElement getForm ( ) { Node parent ; parent = getParentNode ( ) ; while ( parent != null ) { if ( parent instanceof HTMLFormElement ) return ( HTMLFormElement ) parent ; parent = parent . getParentNode ( ) ; } return null ; } } 	0
package org . w3c . dom ; public interface Element extends Node { public String getTagName ( ) ; public String getAttribute ( String name ) ; public void setAttribute ( String name , String value ) throws DOMException ; public void removeAttribute ( String name ) throws DOMException ; public Attr getAttributeNode ( String name ) ; public Attr setAttributeNode ( Attr newAttr ) throws DOMException ; public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException ; public NodeList getElementsByTagName ( String name ) ; public String getAttributeNS ( String namespaceURI , String localName ) ; public void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException ; public void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException ; public Attr getAttributeNodeNS ( String namespaceURI , String localName ) ; public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public boolean hasAttribute ( String name ) ; public boolean hasAttributeNS ( String namespaceURI , String localName ) ; } 	1
package org . w3c . dom . html ; public interface HTMLPreElement extends HTMLElement { public int getWidth ( ) ; public void setWidth ( int width ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class NotationImpl extends NodeImpl implements Notation { static final long serialVersionUID = - 764632195890658402L ; protected String name ; protected String publicId ; protected String systemId ; public NotationImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; } public short getNodeType ( ) { return Node . NOTATION_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public String getPublicId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return publicId ; } public String getSystemId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return systemId ; } public void setPublicId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } publicId = id ; } public void setSystemId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } systemId = id ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLBodyElementImpl extends HTMLElementImpl implements HTMLBodyElement { public String getALink ( ) { return getAttribute ( "alink" ) ; } public void setALink ( String aLink ) { setAttribute ( "alink" , aLink ) ; } public String getBackground ( ) { return getAttribute ( "background" ) ; } public void setBackground ( String background ) { setAttribute ( "background" , background ) ; } public String getBgColor ( ) { return getAttribute ( "bgcolor" ) ; } public void setBgColor ( String bgColor ) { setAttribute ( "bgcolor" , bgColor ) ; } public String getLink ( ) { return getAttribute ( "link" ) ; } public void setLink ( String link ) { setAttribute ( "link" , link ) ; } public String getText ( ) { return getAttribute ( "text" ) ; } public void setText ( String text ) { setAttribute ( "text" , text ) ; } public String getVLink ( ) { return getAttribute ( "vlink" ) ; } public void setVLink ( String vLink ) { setAttribute ( "vlink" , vLink ) ; } public HTMLBodyElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom . events ; public interface EventListener { public void handleEvent ( Event evt ) ; } 	1
package org . apache . xerces . utils ; import org . apache . xerces . readers . XMLEntityHandler ; public final class CharDataChunk implements StringPool . StringProducer { public static final int CHUNK_SHIFT = 14 ; public static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; public static final int CHUNK_MASK = CHUNK_SIZE - 1 ; public static CharDataChunk createChunk ( StringPool stringPool , CharDataChunk prev ) { CharDataChunk newChunk = null ; synchronized ( CharDataChunk . class ) { newChunk = fgFreeChunks ; if ( newChunk != null ) { fgFreeChunks = newChunk . fNextChunk ; } else { newChunk = new CharDataChunk ( ) ; } } newChunk . fStringPool = stringPool ; newChunk . fRefCount = 1 ; newChunk . fChunk = prev == null ? 0 : prev . fChunk + 1 ; newChunk . fNextChunk = null ; newChunk . fPreviousChunk = prev ; if ( prev != null ) { prev . setNextChunk ( newChunk ) ; } return newChunk ; } public CharDataChunk chunkFor ( int offset ) { int firstChunk = offset > > CHUNK_SHIFT ; if ( firstChunk == fChunk ) return this ; CharDataChunk dataChunk = fPreviousChunk ; while ( firstChunk != dataChunk . fChunk ) dataChunk = dataChunk . fPreviousChunk ; return dataChunk ; } public char [ ] toCharArray ( ) { return fData ; } public void setCharArray ( char [ ] data ) { fData = data ; } public CharDataChunk nextChunk ( ) { return fNextChunk ; } public boolean clearPreviousChunk ( ) { if ( fPreviousChunk != null ) { fPreviousChunk . clearNextChunk ( ) ; fPreviousChunk . removeRef ( ) ; fPreviousChunk = null ; return true ; } return false ; } public void releaseChunk ( ) { removeRef ( ) ; } public int addString ( int offset , int length ) { int chunk = offset > > CHUNK_SHIFT ; if ( chunk != fChunk ) { if ( fPreviousChunk == null ) throw new RuntimeException ( new ImplementationMessages ( ) . createMessage ( null , ImplementationMessages . INT_PCN , 0 , null ) ) ; return fPreviousChunk . addString ( offset , length ) ; } int lastChunk = ( offset + length - 1 ) > > CHUNK_SHIFT ; if ( chunk == lastChunk ) { addRef ( ) ; return fStringPool . addString ( this , offset & CHUNK_MASK , length ) ; } String str = toString ( offset & CHUNK_MASK , length ) ; return fStringPool . addString ( str ) ; } public int addSymbol ( int offset , int length , int hashcode ) { int chunk = offset > > CHUNK_SHIFT ; if ( chunk != fChunk ) { if ( fPreviousChunk == null ) throw new RuntimeException ( new ImplementationMessages ( ) . createMessage ( null , ImplementationMessages . INT_PCN , 0 , null ) ) ; return fPreviousChunk . addSymbol ( offset , length , hashcode ) ; } int lastChunk = ( offset + length - 1 ) > > CHUNK_SHIFT ; int index = offset & CHUNK_MASK ; if ( chunk == lastChunk ) { if ( hashcode == 0 ) hashcode = StringHasher . hashChars ( fData , index , length ) ; int symbol = fStringPool . lookupSymbol ( this , offset & CHUNK_MASK , length , hashcode ) ; if ( symbol == - 1 ) { String str = toString ( offset & CHUNK_MASK , length ) ; symbol = fStringPool . addNewSymbol ( str , hashcode ) ; } return symbol ; } String str = toString ( offset & CHUNK_MASK , length ) ; return fStringPool . addSymbol ( str ) ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { CharDataChunk dataChunk = chunkFor ( offset ) ; int index = offset & CHUNK_MASK ; int nbytes = ( index + length <= CHUNK_SIZE ) ? length : CHUNK_SIZE - index ; while ( true ) { charBuffer . append ( dataChunk . fData , index , nbytes ) ; length -= nbytes ; if ( length == 0 ) break ; dataChunk = dataChunk . fNextChunk ; index = 0 ; nbytes = length <= CHUNK_SIZE ? length : CHUNK_SIZE ; } } public String toString ( int offset , int length ) { if ( offset + length <= CHUNK_SIZE ) { return new String ( fData , offset , length ) ; } StringBuffer sb = new StringBuffer ( length ) ; int nbytes = CHUNK_SIZE - offset ; sb . append ( fData , offset , nbytes ) ; length -= nbytes ; CharDataChunk aChunk = fNextChunk ; do { nbytes = length <= CHUNK_SIZE ? length : CHUNK_SIZE ; sb . append ( aChunk . fData , 0 , nbytes ) ; length -= nbytes ; aChunk = aChunk . fNextChunk ; } while ( length > 0 ) ; String retval = sb . toString ( ) ; sb = null ; return retval ; } public void releaseString ( int offset , int length ) { removeRef ( ) ; } public boolean equalsString ( int offset , int length , char [ ] strChars , int strOffset , int strLength ) { if ( length != strLength ) return false ; if ( offset + length <= CHUNK_SIZE ) { for ( int i = 0 ; i < length ; i ++ ) { if ( fData [ offset ++ ] != strChars [ strOffset ++ ] ) return false ; } return true ; } int nbytes = CHUNK_SIZE - offset ; length -= nbytes ; while ( nbytes -- > 0 ) { if ( fData [ offset ++ ] != strChars [ strOffset ++ ] ) return false ; } CharDataChunk aChunk = fNextChunk ; do { offset = 0 ; nbytes = length <= CHUNK_SIZE ? length : CHUNK_SIZE ; length -= nbytes ; while ( nbytes -- > 0 ) { if ( aChunk . fData [ offset ++ ] != strChars [ strOffset ++ ] ) return false ; } aChunk = aChunk . fNextChunk ; } while ( length > 0 ) ; return true ; } private CharDataChunk ( ) { } private void addRef ( ) { fRefCount ++ ; } private void removeRef ( ) { fRefCount -- ; if ( fRefCount == 0 ) { fStringPool = null ; fChunk = - 1 ; fPreviousChunk = null ; synchronized ( CharDataChunk . class ) { fNextChunk = null ; fgFreeChunks = this ; } } } private void clearNextChunk ( ) { if ( fNextChunk != null ) fNextChunk . removeRef ( ) ; fNextChunk = null ; } private void setNextChunk ( CharDataChunk nextChunk ) { if ( fNextChunk != null ) { throw new RuntimeException ( "CharDataChunk::setNextChunk" ) ; } nextChunk . addRef ( ) ; fNextChunk = nextChunk ; } private StringPool fStringPool ; private int fRefCount ; private int fChunk ; private char [ ] fData = null ; private CharDataChunk fNextChunk ; private CharDataChunk fPreviousChunk ; private static CharDataChunk fgFreeChunks = null ; } 	0
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface LexicalHandler { public abstract void startDTD ( String name , String publicId , String systemId ) throws SAXException ; public abstract void endDTD ( ) throws SAXException ; public abstract void startEntity ( String name ) throws SAXException ; public abstract void endEntity ( String name ) throws SAXException ; public abstract void startCDATA ( ) throws SAXException ; public abstract void endCDATA ( ) throws SAXException ; public abstract void comment ( char ch [ ] , int start , int length ) throws SAXException ; } 	1
package org . apache . xerces . utils ; public final class SymbolCache { public static final int CHAR_OFFSET = 0 ; public static final int INDEX_OFFSET = 1 ; public static final int NEXT_OFFSET = 2 ; public static final int CACHE_RECORD_SIZE = 3 ; public static final int INITIAL_CACHE_RECORD_COUNT = 4 ; public char [ ] fSymbolChars = new char [ 8192 ] ; public int fSymbolCharsOffset = 0 ; public int [ ] [ ] fCacheLines = new int [ 8 ] [ ] ; public int fCacheLineCount = 0 ; public SymbolCache ( ) { fCacheLines [ fCacheLineCount ++ ] = new int [ 1 + ( INITIAL_CACHE_RECORD_COUNT * CACHE_RECORD_SIZE ) ] ; } public void reset ( ) { fSymbolCharsOffset = 0 ; fCacheLineCount = 0 ; fCacheLines [ fCacheLineCount ++ ] = new int [ 1 + ( INITIAL_CACHE_RECORD_COUNT * CACHE_RECORD_SIZE ) ] ; } public char [ ] getSymbolChars ( ) { return fSymbolChars ; } public String createSymbol ( int symbolHandle , int startOffset , int entry , int [ ] entries , int offset ) { int slen = fSymbolCharsOffset - startOffset ; String str = new String ( fSymbolChars , startOffset , slen ) ; try { entries [ offset + SymbolCache . INDEX_OFFSET ] = symbolHandle ; } catch ( ArrayIndexOutOfBoundsException ex ) { throw new RuntimeException ( "UTL001 untested" ) ; } return str ; } public int addSymbolToCache ( String str , int slen , int symbolHandle ) { int charsOffset = fSymbolCharsOffset ; if ( slen == 0 ) return charsOffset ; int strIndex = 0 ; char ch = str . charAt ( strIndex ++ ) ; try { fSymbolChars [ fSymbolCharsOffset ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { char [ ] newChars = new char [ fSymbolChars . length * 2 ] ; System . arraycopy ( fSymbolChars , 0 , newChars , 0 , fSymbolChars . length ) ; fSymbolChars = newChars ; fSymbolChars [ fSymbolCharsOffset ] = ch ; } fSymbolCharsOffset ++ ; int entry = 0 ; int [ ] entries = fCacheLines [ entry ] ; int count = entries [ 0 ] ; int i = 0 ; int offset = 1 ; while ( true ) { if ( i == count ) break ; if ( entries [ offset + CHAR_OFFSET ] != ch ) { i ++ ; offset += CACHE_RECORD_SIZE ; continue ; } if ( strIndex == slen ) { if ( entries [ offset + INDEX_OFFSET ] != - 1 ) { throw new RuntimeException ( "addSymbolToCache" ) ; } entries [ offset + INDEX_OFFSET ] = symbolHandle ; return charsOffset ; } ch = str . charAt ( strIndex ++ ) ; try { fSymbolChars [ fSymbolCharsOffset ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { char [ ] newChars = new char [ fSymbolChars . length * 2 ] ; System . arraycopy ( fSymbolChars , 0 , newChars , 0 , fSymbolChars . length ) ; fSymbolChars = newChars ; fSymbolChars [ fSymbolCharsOffset ] = ch ; } fSymbolCharsOffset ++ ; entry = entries [ offset + NEXT_OFFSET ] ; try { entries = fCacheLines [ entry ] ; } catch ( ArrayIndexOutOfBoundsException ex ) { if ( entry == - 1 ) { entry = fCacheLineCount ++ ; entries [ offset + NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( INITIAL_CACHE_RECORD_COUNT * CACHE_RECORD_SIZE ) ] ; try { fCacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex2 ) { int [ ] [ ] newCache = new int [ entry * 2 ] [ ] ; System . arraycopy ( fCacheLines , 0 , newCache , 0 , entry ) ; fCacheLines = newCache ; fCacheLines [ entry ] = entries ; } } else { entries = fCacheLines [ entry ] ; throw new RuntimeException ( "UTL001 untested" ) ; } } count = entries [ 0 ] ; i = 0 ; offset = 1 ; } while ( true ) { entries [ 0 ] ++ ; try { entries [ offset + CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; int [ ] newEntries = new int [ newSize ] ; System . arraycopy ( entries , 0 , newEntries , 0 , offset ) ; fCacheLines [ entry ] = entries = newEntries ; entries [ offset + CHAR_OFFSET ] = ch ; } if ( strIndex == slen ) { entries [ offset + INDEX_OFFSET ] = symbolHandle ; entries [ offset + NEXT_OFFSET ] = - 1 ; break ; } entry = fCacheLineCount ++ ; entries [ offset + INDEX_OFFSET ] = - 1 ; entries [ offset + NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( INITIAL_CACHE_RECORD_COUNT * CACHE_RECORD_SIZE ) ] ; try { fCacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex ) { int [ ] [ ] newCache = new int [ entry * 2 ] [ ] ; System . arraycopy ( fCacheLines , 0 , newCache , 0 , entry ) ; fCacheLines = newCache ; fCacheLines [ entry ] = entries ; } offset = 1 ; ch = str . charAt ( strIndex ++ ) ; try { fSymbolChars [ fSymbolCharsOffset ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { char [ ] newChars = new char [ fSymbolChars . length * 2 ] ; System . arraycopy ( fSymbolChars , 0 , newChars , 0 , fSymbolChars . length ) ; fSymbolChars = newChars ; fSymbolChars [ fSymbolCharsOffset ] = ch ; } fSymbolCharsOffset ++ ; } return charsOffset ; } public void updateCacheLine ( int charsOffset , int totalMisses , int length ) { int entry = 0 ; int [ ] entries = fCacheLines [ 0 ] ; int ch = fSymbolChars [ charsOffset ++ ] ; int count = entries [ 0 ] ; int offset = 1 + ( ( count - 1 ) * CACHE_RECORD_SIZE ) ; int misses = 0 ; while ( true ) { if ( ch != entries [ offset + CHAR_OFFSET ] ) { offset -= CACHE_RECORD_SIZE ; misses ++ ; continue ; } if ( misses > 4 ) { int symIndex = entries [ offset + INDEX_OFFSET ] ; int nextIndex = entries [ offset + NEXT_OFFSET ] ; System . arraycopy ( entries , offset + CACHE_RECORD_SIZE , entries , offset , misses * CACHE_RECORD_SIZE ) ; offset = 1 + ( ( count - 1 ) * CACHE_RECORD_SIZE ) ; entries [ offset + CHAR_OFFSET ] = ch ; entries [ offset + INDEX_OFFSET ] = symIndex ; entries [ offset + NEXT_OFFSET ] = nextIndex ; } if ( -- length == 0 ) break ; entry = entries [ offset + NEXT_OFFSET ] ; entries = fCacheLines [ entry ] ; ch = fSymbolChars [ charsOffset ++ ] ; count = entries [ 0 ] ; offset = 1 + ( ( count - 1 ) * CACHE_RECORD_SIZE ) ; misses = 0 ; } } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrImpl extends ParentNode implements Attr { static final long serialVersionUID = 7277707688218972102L ; protected String name ; protected AttrImpl ( DocumentImpl ownerDocument , String name ) { super ( ownerDocument ) ; this . name = name ; isSpecified ( true ) ; } protected AttrImpl ( ) { } public Node cloneNode ( boolean deep ) { AttrImpl clone = ( AttrImpl ) super . cloneNode ( deep ) ; clone . isSpecified ( true ) ; return clone ; } public short getNodeType ( ) { return Node . ATTRIBUTE_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setNodeValue ( String value ) throws DOMException { setValue ( value ) ; } public String getNodeValue ( ) { return getValue ( ) ; } public String getName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setValue ( String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } LCount lc = null ; String oldvalue = "" ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 && ownerNode != null ) { oldvalue = getValue ( ) ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } while ( firstChild != null ) internalRemoveChild ( firstChild , MUTATION_LOCAL ) ; } else { if ( firstChild != null ) { firstChild . previousSibling = null ; firstChild . isFirstChild ( false ) ; firstChild = null ; } needsSyncChildren ( false ) ; } isSpecified ( true ) ; if ( value != null ) { internalInsertBefore ( ownerDocument . createTextNode ( value ) , null , MUTATION_LOCAL ) ; } changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( this , oldvalue ) ; } } public String getValue ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( firstChild == null ) { return "" ; } ChildNode node = firstChild . nextSibling ; if ( node == null ) { return firstChild . getNodeValue ( ) ; } StringBuffer value = new StringBuffer ( firstChild . getNodeValue ( ) ) ; while ( node != null ) { value . append ( node . getNodeValue ( ) ) ; node = node . nextSibling ; } return value . toString ( ) ; } public boolean getSpecified ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isSpecified ( ) ; } public Element getElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public Element getOwnerElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public void normalize ( ) { Node kid , next ; for ( kid = firstChild ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } } } public void setSpecified ( boolean arg ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isSpecified ( arg ) ; } public String toString ( ) { return getName ( ) + "=" + "\"" + getValue ( ) + "\"" ; } } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . ChunkyByteArray ; import org . apache . xerces . utils . StringPool ; import java . io . IOException ; final class UCSRecognizer extends XMLDeclRecognizer { public XMLEntityHandler . EntityReader recognize ( XMLEntityReaderFactory readerFactory , XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , StringPool stringPool , ChunkyByteArray data , boolean xmlDecl , boolean allowJavaEncodingName ) throws Exception { XMLEntityHandler . EntityReader reader = null ; byte b0 = data . byteAt ( 0 ) ; if ( b0 == 0 ) { int b1 = data . byteAt ( 1 ) ; if ( b1 == 0 ) { if ( data . byteAt ( 2 ) == 0 && data . byteAt ( 3 ) == '<' ) reader = new UCSReader ( entityHandler , errorReporter , sendCharDataAsCharArray , data , UCSReader . E_UCS4B , stringPool ) ; } else if ( b1 == '<' ) { if ( data . byteAt ( 2 ) == 0 && data . byteAt ( 3 ) == '?' ) reader = new UCSReader ( entityHandler , errorReporter , sendCharDataAsCharArray , data , UCSReader . E_UCS2B_NOBOM , stringPool ) ; } } else if ( b0 == '<' ) { int b1 = data . byteAt ( 1 ) ; if ( b1 == 0 ) { int b2 = data . byteAt ( 2 ) ; if ( data . byteAt ( 3 ) == 0 ) { if ( b2 == 0 ) reader = new UCSReader ( entityHandler , errorReporter , sendCharDataAsCharArray , data , UCSReader . E_UCS4L , stringPool ) ; else if ( b2 == '?' ) reader = new UCSReader ( entityHandler , errorReporter , sendCharDataAsCharArray , data , UCSReader . E_UCS2L_NOBOM , stringPool ) ; } } } else if ( b0 == ( byte ) 0xfe ) { if ( data . byteAt ( 1 ) == ( byte ) 0xff ) reader = new UCSReader ( entityHandler , errorReporter , sendCharDataAsCharArray , data , UCSReader . E_UCS2B , stringPool ) ; } else if ( b0 == ( byte ) 0xff ) { if ( data . byteAt ( 1 ) == ( byte ) 0xfe ) reader = new UCSReader ( entityHandler , errorReporter , sendCharDataAsCharArray , data , UCSReader . E_UCS2L , stringPool ) ; } return reader ; } } 	0
package org . w3c . dom ; public interface CharacterData extends Node { public String getData ( ) throws DOMException ; public void setData ( String data ) throws DOMException ; public int getLength ( ) ; public String substringData ( int offset , int count ) throws DOMException ; public void appendData ( String arg ) throws DOMException ; public void insertData ( int offset , String arg ) throws DOMException ; public void deleteData ( int offset , int count ) throws DOMException ; public void replaceData ( int offset , int count , String arg ) throws DOMException ; } 	1
package org . xml . sax ; public interface AttributeList { public abstract int getLength ( ) ; public abstract String getName ( int i ) ; public abstract String getType ( int i ) ; public abstract String getValue ( int i ) ; public abstract String getType ( String name ) ; public abstract String getValue ( String name ) ; } 	0
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface Event { public static final short CAPTURING_PHASE = 1 ; public static final short AT_TARGET = 2 ; public static final short BUBBLING_PHASE = 3 ; public String getType ( ) ; public EventTarget getTarget ( ) ; public Node getCurrentNode ( ) ; public short getEventPhase ( ) ; public boolean getBubbles ( ) ; public boolean getCancelable ( ) ; public long getTimeStamp ( ) ; public void stopPropagation ( ) ; public void preventDefault ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) ; } 	1
package org . apache . wml ; public interface WMLPElement extends WMLElement { public void setMode ( String newValue ) ; public String getMode ( ) ; public void setAlign ( String newValue ) ; public String getAlign ( ) ; public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Enumeration ; import java . util . Vector ; import org . w3c . dom . * ; public class ElementImpl extends ChildAndParentNode implements Element { static final long serialVersionUID = 3717253516652722278L ; protected String name ; protected AttributeMap attributes ; public ElementImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; needsSyncData ( true ) ; } protected ElementImpl ( ) { } public short getNodeType ( ) { return Node . ELEMENT_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public NamedNodeMap getAttributes ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return attributes ; } public Node cloneNode ( boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } ElementImpl newnode = ( ElementImpl ) super . cloneNode ( deep ) ; if ( attributes != null ) { newnode . attributes = ( AttributeMap ) attributes . cloneMap ( newnode ) ; } return newnode ; } void setOwnerDocument ( DocumentImpl doc ) { super . setOwnerDocument ( doc ) ; if ( attributes != null ) { attributes . setOwnerDocument ( doc ) ; } } public String getAttribute ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return "" ; } Attr attr = ( Attr ) ( attributes . getNamedItem ( name ) ) ; return ( attr == null ) ? "" : attr . getValue ( ) ; } public Attr getAttributeNode ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItem ( name ) ; } public NodeList getElementsByTagName ( String tagname ) { return new DeepNodeListImpl ( this , tagname ) ; } public String getTagName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void normalize ( ) { Node kid , next ; for ( kid = getFirstChild ( ) ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } else if ( kid . getNodeType ( ) == Node . ELEMENT_NODE ) { ( ( Element ) kid ) . normalize ( ) ; } } } public void removeAttribute ( String name ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItem ( name ) ; } public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } return ( Attr ) attributes . removeNamedItem ( oldAttr . getName ( ) ) ; } public void setAttribute ( String name , String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } Attr newAttr = getAttributeNode ( name ) ; if ( newAttr == null ) { newAttr = getOwnerDocument ( ) . createAttribute ( name ) ; if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } attributes . setNamedItem ( newAttr ) ; } newAttr . setNodeValue ( value ) ; } public Attr setAttributeNode ( Attr newAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ownerDocument . errorChecking && newAttr . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return ( Attr ) attributes . setNamedItem ( newAttr ) ; } public String getAttributeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return "" ; } Attr attr = ( Attr ) ( attributes . getNamedItemNS ( namespaceURI , localName ) ) ; return ( attr == null ) ? null : attr . getValue ( ) ; } public void setAttributeNS ( String namespaceURI , String localName , String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } Attr newAttr = getAttributeNodeNS ( namespaceURI , localName ) ; if ( newAttr == null ) { newAttr = getOwnerDocument ( ) . createAttributeNS ( namespaceURI , localName ) ; if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } attributes . setNamedItemNS ( newAttr ) ; } newAttr . setNodeValue ( value ) ; } public void removeAttributeNS ( String namespaceURI , String localName ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItemNS ( namespaceURI , localName ) ; } public Attr getAttributeNodeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItemNS ( namespaceURI , localName ) ; } public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ownerDocument . errorChecking && newAttr . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return ( Attr ) attributes . setNamedItemNS ( newAttr ) ; } public boolean hasAttributes ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return ( attributes != null && attributes . getLength ( ) != 0 ) ; } public boolean hasAttribute ( String name ) { return getAttributeNode ( name ) != null ; } public boolean hasAttributeNS ( String namespaceURI , String localName ) { return getAttributeNodeNS ( namespaceURI , localName ) != null ; } public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { return new DeepNodeListImpl ( this , namespaceURI , localName ) ; } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( attributes != null ) { attributes . setReadOnly ( readOnly , true ) ; } } protected void synchronizeData ( ) { needsSyncData ( false ) ; setupDefaultAttributes ( ) ; } protected void setupDefaultAttributes ( ) { NamedNodeMapImpl defaults = getDefaultAttributes ( ) ; if ( defaults != null ) { attributes = new AttributeMap ( this , defaults ) ; } } protected NamedNodeMapImpl getDefaultAttributes ( ) { DocumentTypeImpl doctype = ( DocumentTypeImpl ) ownerDocument . getDoctype ( ) ; if ( doctype == null ) { return null ; } ElementDefinitionImpl eldef = ( ElementDefinitionImpl ) doctype . getElements ( ) . getNamedItem ( getNodeName ( ) ) ; if ( eldef == null ) { return null ; } return ( NamedNodeMapImpl ) eldef . getAttributes ( ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLLegendElement extends HTMLElement { public HTMLFormElement getForm ( ) ; public String getAccessKey ( ) ; public void setAccessKey ( String accessKey ) ; public String getAlign ( ) ; public void setAlign ( String align ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class TextImpl extends CharacterDataImpl implements CharacterData , Text { static final long serialVersionUID = - 5294980852957403469L ; public TextImpl ( DocumentImpl ownerDoc , String data ) { super ( ownerDoc , data ) ; } public short getNodeType ( ) { return Node . TEXT_NODE ; } public String getNodeName ( ) { return "#text" ; } public void setIgnorableWhitespace ( boolean ignore ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isIgnorableWhitespace ( ignore ) ; } public boolean isIgnorableWhitespace ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return internalIsIgnorableWhitespace ( ) ; } public Text splitText ( int offset ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( offset < 0 || offset > data . length ( ) - 1 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } Text newText = getOwnerDocument ( ) . createTextNode ( data . substring ( offset ) ) ; setNodeValue ( data . substring ( 0 , offset ) ) ; Node parentNode = getParentNode ( ) ; if ( parentNode != null ) { parentNode . insertBefore ( newText , nextSibling ) ; } return newText ; } } 	1
package org . apache . xerces . validators . datatype ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; public class DoubleDatatypeValidator extends AbstractDatatypeValidator { private Locale fLocale = null ; private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; private double [ ] fEnumDoubles = null ; private String fPattern = null ; private double fMaxInclusive = Double . MAX_VALUE ; private double fMaxExclusive = Double . MAX_VALUE ; private double fMinInclusive = Double . MIN_VALUE ; private double fMinExclusive = Double . MIN_VALUE ; private int fFacetsDefined = 0 ; private boolean isMaxExclusiveDefined = false ; private boolean isMaxInclusiveDefined = false ; private boolean isMinExclusiveDefined = false ; private boolean isMinInclusiveDefined = false ; private RegularExpression fRegex = null ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; public DoubleDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public DoubleDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { if ( base != null ) setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { if ( fDerivedByList == false ) { for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = ( String ) facets . get ( key ) ; if ( fPattern != null ) fRegex = new RegularExpression ( fPattern , "X" ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; continue ; } else if ( key . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMaxInclusive = Double . valueOf ( value ) . doubleValue ( ) ; } catch ( NumberFormatException ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXEXCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMaxExclusive = Double . valueOf ( value ) . doubleValue ( ) ; } catch ( NumberFormatException ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMinInclusive = Double . valueOf ( value ) . doubleValue ( ) ; } catch ( NumberFormatException ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMinExclusive = Double . valueOf ( value ) . doubleValue ( ) ; } catch ( NumberFormatException ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . MSG_FORMAT_FAILURE , DatatypeMessageProvider . MSG_NONE , null ) ) ; } } isMaxExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXEXCLUSIVE ) != 0 ) ? true : false ; isMaxInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXINCLUSIVE ) != 0 ) ? true : false ; isMinExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MINEXCLUSIVE ) != 0 ) ? true : false ; isMinInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MININCLUSIVE ) != 0 ) ? true : false ; if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both maxInclusive and maxExclusive to be specified for the same datatype." ) ; } if ( isMinExclusiveDefined && isMinInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both minInclusive and minExclusive to be specified for the same datatype." ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { Vector v = ( Vector ) facets . get ( SchemaSymbols . ELT_ENUMERATION ) ; if ( v != null ) { fEnumDoubles = new double [ v . size ( ) ] ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) try { fEnumDoubles [ i ] = Double . valueOf ( ( String ) v . elementAt ( i ) ) . doubleValue ( ) ; boundsCheck ( fEnumDoubles [ i ] ) ; } catch ( InvalidDatatypeValueException idve ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . InvalidEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { v . elementAt ( i ) } ) ) ; } catch ( NumberFormatException nfe ) { System . out . println ( "Internal Error parsing enumerated values for real type" ) ; } } } } else { } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { if ( fDerivedByList == false ) { if ( ( fFacetsDefined & DatatypeValidator . FACET_PATTERN ) != 0 ) { if ( fRegex == null || fRegex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value'" + content + "does not match regular expression facet" + fPattern ) ; } double d = 0.0 ; try { d = Double . valueOf ( content ) . doubleValue ( ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotReal , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } boundsCheck ( d ) ; if ( ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) ) enumCheck ( d ) ; } else { ; } return null ; } private void boundsCheck ( double d ) throws InvalidDatatypeValueException { boolean inUpperBound = false ; boolean inLowerBound = false ; if ( isMaxInclusiveDefined ) { inUpperBound = ( d <= fMaxInclusive ) ; } else if ( isMaxExclusiveDefined ) { inUpperBound = ( d < fMaxExclusive ) ; } if ( isMinInclusiveDefined ) { inLowerBound = ( d >= fMinInclusive ) ; } else if ( isMinExclusiveDefined ) { inLowerBound = ( d > fMinExclusive ) ; } if ( inUpperBound == false || inLowerBound == false ) { getErrorString ( DatatypeMessageProvider . OutOfBounds , DatatypeMessageProvider . MSG_NONE , new Object [ ] { new Double ( d ) , "" , "" , "" , "" } ) ; } } private void enumCheck ( double v ) throws InvalidDatatypeValueException { for ( int i = 0 ; i < fEnumDoubles . length ; i ++ ) { if ( v == fEnumDoubles [ i ] ) return ; } throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotAnEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { new Double ( v ) } ) ) ; } public int compare ( String content1 , String content2 ) { return 0 ; } public Hashtable getFacets ( ) { return null ; } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } } 	0
package org . w3c . dom ; public class DOMException extends RuntimeException { public DOMException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short INDEX_SIZE_ERR = 1 ; public static final short DOMSTRING_SIZE_ERR = 2 ; public static final short HIERARCHY_REQUEST_ERR = 3 ; public static final short WRONG_DOCUMENT_ERR = 4 ; public static final short INVALID_CHARACTER_ERR = 5 ; public static final short NO_DATA_ALLOWED_ERR = 6 ; public static final short NO_MODIFICATION_ALLOWED_ERR = 7 ; public static final short NOT_FOUND_ERR = 8 ; public static final short NOT_SUPPORTED_ERR = 9 ; public static final short INUSE_ATTRIBUTE_ERR = 10 ; public static final short INVALID_STATE_ERR = 11 ; public static final short SYNTAX_ERR = 12 ; public static final short INVALID_MODIFICATION_ERR = 13 ; public static final short NAMESPACE_ERR = 14 ; public static final short INVALID_ACCESS_ERR = 15 ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLModElementImpl extends HTMLElementImpl implements HTMLModElement { public String getCite ( ) { return getAttribute ( "cite" ) ; } public void setCite ( String cite ) { setAttribute ( "cite" , cite ) ; } public String getDateTime ( ) { return getAttribute ( "datetime" ) ; } public void setDateTime ( String dateTime ) { setAttribute ( "datetime" , dateTime ) ; } public HTMLModElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom . events ; public interface EventTarget { public void addEventListener ( String type , EventListener listener , boolean useCapture ) ; public void removeEventListener ( String type , EventListener listener , boolean useCapture ) ; public boolean dispatchEvent ( Event evt ) throws EventException ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLTrElementImpl extends WMLElementImpl implements WMLTrElement { public WMLTrElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom ; public interface NodeList { public Node item ( int index ) ; public int getLength ( ) ; } 	1
package org . apache . xerces . utils ; public final class XMLCharacterProperties { public static boolean validVersionNum ( String version ) { if ( version . length ( ) == 0 ) return false ; for ( int i = 0 ; i < version . length ( ) ; i ++ ) { char ch = version . charAt ( i ) ; if ( ch > 'z' || fgAsciiNameChar [ ch ] == 0 ) return false ; } return true ; } public static boolean validEncName ( String encoding ) { if ( encoding . length ( ) == 0 ) return false ; char ch = encoding . charAt ( 0 ) ; if ( ch > 'z' || fgAsciiAlphaChar [ ch ] == 0 ) return false ; for ( int i = 1 ; i < encoding . length ( ) ; i ++ ) { ch = encoding . charAt ( i ) ; if ( ch > 'z' || fgAsciiEncNameChar [ ch ] == 0 ) return false ; } return true ; } public static int validPublicId ( String publicId ) { if ( publicId . length ( ) == 0 ) return - 1 ; for ( int i = 0 ; i < publicId . length ( ) ; i ++ ) { char ch = publicId . charAt ( i ) ; if ( ch > 'z' || fgAsciiPubidChar [ ch ] == 0 ) return i ; } return - 1 ; } public static boolean validName ( String name ) { if ( name . length ( ) == 0 ) return false ; char ch = name . charAt ( 0 ) ; if ( ch > 'z' ) { if ( ( fgCharFlags [ ch ] & E_InitialNameCharFlag ) == 0 ) return false ; } else if ( fgAsciiInitialNameChar [ ch ] == 0 ) return false ; for ( int i = 1 ; i < name . length ( ) ; i ++ ) { ch = name . charAt ( i ) ; if ( ch > 'z' ) { if ( ( fgCharFlags [ ch ] & E_NameCharFlag ) == 0 ) return false ; } else if ( fgAsciiNameChar [ ch ] == 0 ) return false ; } return true ; } public static boolean validNCName ( String name ) { if ( name . length ( ) == 0 ) return false ; char ch = name . charAt ( 0 ) ; if ( ch > 'z' ) { if ( ( fgCharFlags [ ch ] & E_InitialNameCharFlag ) == 0 ) return false ; } else if ( fgAsciiInitialNCNameChar [ ch ] == 0 ) return false ; for ( int i = 1 ; i < name . length ( ) ; i ++ ) { ch = name . charAt ( i ) ; if ( ch > 'z' ) { if ( ( fgCharFlags [ ch ] & E_NameCharFlag ) == 0 ) return false ; } else if ( fgAsciiNCNameChar [ ch ] == 0 ) return false ; } return true ; } public static boolean validNmtoken ( String nmtoken ) { if ( nmtoken . length ( ) == 0 ) return false ; for ( int i = 0 ; i < nmtoken . length ( ) ; i ++ ) { char ch = nmtoken . charAt ( i ) ; if ( ch > 'z' ) { if ( ( fgCharFlags [ ch ] & E_NameCharFlag ) == 0 ) return false ; } else if ( fgAsciiNameChar [ ch ] == 0 ) { return false ; } } return true ; } public static final byte fgAsciiXDigitChar [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public static final byte fgAsciiAlphaChar [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 } ; public static final byte fgAsciiEncNameChar [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 } ; public static final byte fgAsciiPubidChar [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 } ; public static final byte fgAsciiInitialNameChar [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 } ; public static final byte fgAsciiNameChar [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 } ; public static final byte fgAsciiInitialNCNameChar [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 } ; public static final byte fgAsciiNCNameChar [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 } ; public static final byte fgAsciiCharData [ ] = { 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public static final byte fgAsciiWSCharData [ ] = { 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 4 , 4 , 5 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 5 , 0 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public static final byte E_CharDataFlag = 1 << 0 ; public static final byte E_InitialNameCharFlag = 1 << 1 ; public static final byte E_NameCharFlag = 1 << 2 ; public static byte [ ] fgCharFlags = null ; public static synchronized void initCharFlags ( ) { if ( fgCharFlags == null ) { fgCharFlags = new byte [ 0x10000 ] ; setFlagForRange ( fgCharDataRanges , E_CharDataFlag ) ; setFlagForRange ( fgInitialNameCharRanges , ( byte ) ( E_InitialNameCharFlag | E_NameCharFlag ) ) ; setFlagForRange ( fgNameCharRanges , E_NameCharFlag ) ; } } private static void setFlagForRange ( char [ ] ranges , byte flag ) { int i ; int ch ; for ( i = 0 ; ( ch = ranges [ i ] ) != 0 ; i += 2 ) { int endch = ranges [ i + 1 ] ; while ( ch <= endch ) fgCharFlags [ ch ++ ] |= flag ; } for ( i ++ ; ( ch = ranges [ i ] ) != 0 ; i ++ ) fgCharFlags [ ch ] |= flag ; } private static final char fgCharDataRanges [ ] = { 0x0020 , 0x0025 , 0x0027 , 0x003B , 0x003D , 0x005C , 0x005E , 0xD7FF , 0xE000 , 0xFFFD , 0x0000 , 0x0009 , 0x0000 } ; private static final char fgInitialNameCharRanges [ ] = { 0x0041 , 0x005A , 0x0061 , 0x007A , 0x00C0 , 0x00D6 , 0x00D8 , 0x00F6 , 0x00F8 , 0x0131 , 0x0134 , 0x013E , 0x0141 , 0x0148 , 0x014A , 0x017E , 0x0180 , 0x01C3 , 0x01CD , 0x01F0 , 0x01F4 , 0x01F5 , 0x01FA , 0x0217 , 0x0250 , 0x02A8 , 0x02BB , 0x02C1 , 0x0388 , 0x038A , 0x038E , 0x03A1 , 0x03A3 , 0x03CE , 0x03D0 , 0x03D6 , 0x03E2 , 0x03F3 , 0x0401 , 0x040C , 0x040E , 0x044F , 0x0451 , 0x045C , 0x045E , 0x0481 , 0x0490 , 0x04C4 , 0x04C7 , 0x04C8 , 0x04CB , 0x04CC , 0x04D0 , 0x04EB , 0x04EE , 0x04F5 , 0x04F8 , 0x04F9 , 0x0531 , 0x0556 , 0x0561 , 0x0586 , 0x05D0 , 0x05EA , 0x05F0 , 0x05F2 , 0x0621 , 0x063A , 0x0641 , 0x064A , 0x0671 , 0x06B7 , 0x06BA , 0x06BE , 0x06C0 , 0x06CE , 0x06D0 , 0x06D3 , 0x06E5 , 0x06E6 , 0x0905 , 0x0939 , 0x0958 , 0x0961 , 0x0985 , 0x098C , 0x098F , 0x0990 , 0x0993 , 0x09A8 , 0x09AA , 0x09B0 , 0x09B6 , 0x09B9 , 0x09DC , 0x09DD , 0x09DF , 0x09E1 , 0x09F0 , 0x09F1 , 0x0A05 , 0x0A0A , 0x0A0F , 0x0A10 , 0x0A13 , 0x0A28 , 0x0A2A , 0x0A30 , 0x0A32 , 0x0A33 , 0x0A35 , 0x0A36 , 0x0A38 , 0x0A39 , 0x0A59 , 0x0A5C , 0x0A72 , 0x0A74 , 0x0A85 , 0x0A8B , 0x0A8F , 0x0A91 , 0x0A93 , 0x0AA8 , 0x0AAA , 0x0AB0 , 0x0AB2 , 0x0AB3 , 0x0AB5 , 0x0AB9 , 0x0B05 , 0x0B0C , 0x0B0F , 0x0B10 , 0x0B13 , 0x0B28 , 0x0B2A , 0x0B30 , 0x0B32 , 0x0B33 , 0x0B36 , 0x0B39 , 0x0B5C , 0x0B5D , 0x0B5F , 0x0B61 , 0x0B85 , 0x0B8A , 0x0B8E , 0x0B90 , 0x0B92 , 0x0B95 , 0x0B99 , 0x0B9A , 0x0B9E , 0x0B9F , 0x0BA3 , 0x0BA4 , 0x0BA8 , 0x0BAA , 0x0BAE , 0x0BB5 , 0x0BB7 , 0x0BB9 , 0x0C05 , 0x0C0C , 0x0C0E , 0x0C10 , 0x0C12 , 0x0C28 , 0x0C2A , 0x0C33 , 0x0C35 , 0x0C39 , 0x0C60 , 0x0C61 , 0x0C85 , 0x0C8C , 0x0C8E , 0x0C90 , 0x0C92 , 0x0CA8 , 0x0CAA , 0x0CB3 , 0x0CB5 , 0x0CB9 , 0x0CE0 , 0x0CE1 , 0x0D05 , 0x0D0C , 0x0D0E , 0x0D10 , 0x0D12 , 0x0D28 , 0x0D2A , 0x0D39 , 0x0D60 , 0x0D61 , 0x0E01 , 0x0E2E , 0x0E32 , 0x0E33 , 0x0E40 , 0x0E45 , 0x0E81 , 0x0E82 , 0x0E87 , 0x0E88 , 0x0E94 , 0x0E97 , 0x0E99 , 0x0E9F , 0x0EA1 , 0x0EA3 , 0x0EAA , 0x0EAB , 0x0EAD , 0x0EAE , 0x0EB2 , 0x0EB3 , 0x0EC0 , 0x0EC4 , 0x0F40 , 0x0F47 , 0x0F49 , 0x0F69 , 0x10A0 , 0x10C5 , 0x10D0 , 0x10F6 , 0x1102 , 0x1103 , 0x1105 , 0x1107 , 0x110B , 0x110C , 0x110E , 0x1112 , 0x1154 , 0x1155 , 0x115F , 0x1161 , 0x116D , 0x116E , 0x1172 , 0x1173 , 0x11AE , 0x11AF , 0x11B7 , 0x11B8 , 0x11BC , 0x11C2 , 0x1E00 , 0x1E9B , 0x1EA0 , 0x1EF9 , 0x1F00 , 0x1F15 , 0x1F18 , 0x1F1D , 0x1F20 , 0x1F45 , 0x1F48 , 0x1F4D , 0x1F50 , 0x1F57 , 0x1F5F , 0x1F7D , 0x1F80 , 0x1FB4 , 0x1FB6 , 0x1FBC , 0x1FC2 , 0x1FC4 , 0x1FC6 , 0x1FCC , 0x1FD0 , 0x1FD3 , 0x1FD6 , 0x1FDB , 0x1FE0 , 0x1FEC , 0x1FF2 , 0x1FF4 , 0x1FF6 , 0x1FFC , 0x212A , 0x212B , 0x2180 , 0x2182 , 0x3041 , 0x3094 , 0x30A1 , 0x30FA , 0x3105 , 0x312C , 0xAC00 , 0xD7A3 , 0x3021 , 0x3029 , 0x4E00 , 0x9FA5 , 0x0000 , 0x003A , 0x005F , 0x0386 , 0x038C , 0x03DA , 0x03DC , 0x03DE , 0x03E0 , 0x0559 , 0x06D5 , 0x093D , 0x09B2 , 0x0A5E , 0x0A8D , 0x0ABD , 0x0AE0 , 0x0B3D , 0x0B9C , 0x0CDE , 0x0E30 , 0x0E84 , 0x0E8A , 0x0E8D , 0x0EA5 , 0x0EA7 , 0x0EB0 , 0x0EBD , 0x1100 , 0x1109 , 0x113C , 0x113E , 0x1140 , 0x114C , 0x114E , 0x1150 , 0x1159 , 0x1163 , 0x1165 , 0x1167 , 0x1169 , 0x1175 , 0x119E , 0x11A8 , 0x11AB , 0x11BA , 0x11EB , 0x11F0 , 0x11F9 , 0x1F59 , 0x1F5B , 0x1F5D , 0x1FBE , 0x2126 , 0x212E , 0x3007 , 0x0000 } ; private static final char fgNameCharRanges [ ] = { 0x002D , 0x002E , 0x0300 , 0x0345 , 0x0360 , 0x0361 , 0x0483 , 0x0486 , 0x0591 , 0x05A1 , 0x05A3 , 0x05B9 , 0x05BB , 0x05BD , 0x05C1 , 0x05C2 , 0x064B , 0x0652 , 0x06D6 , 0x06DC , 0x06DD , 0x06DF , 0x06E0 , 0x06E4 , 0x06E7 , 0x06E8 , 0x06EA , 0x06ED , 0x0901 , 0x0903 , 0x093E , 0x094C , 0x0951 , 0x0954 , 0x0962 , 0x0963 , 0x0981 , 0x0983 , 0x09C0 , 0x09C4 , 0x09C7 , 0x09C8 , 0x09CB , 0x09CD , 0x09E2 , 0x09E3 , 0x0A40 , 0x0A42 , 0x0A47 , 0x0A48 , 0x0A4B , 0x0A4D , 0x0A70 , 0x0A71 , 0x0A81 , 0x0A83 , 0x0ABE , 0x0AC5 , 0x0AC7 , 0x0AC9 , 0x0ACB , 0x0ACD , 0x0B01 , 0x0B03 , 0x0B3E , 0x0B43 , 0x0B47 , 0x0B48 , 0x0B4B , 0x0B4D , 0x0B56 , 0x0B57 , 0x0B82 , 0x0B83 , 0x0BBE , 0x0BC2 , 0x0BC6 , 0x0BC8 , 0x0BCA , 0x0BCD , 0x0C01 , 0x0C03 , 0x0C3E , 0x0C44 , 0x0C46 , 0x0C48 , 0x0C4A , 0x0C4D , 0x0C55 , 0x0C56 , 0x0C82 , 0x0C83 , 0x0CBE , 0x0CC4 , 0x0CC6 , 0x0CC8 , 0x0CCA , 0x0CCD , 0x0CD5 , 0x0CD6 , 0x0D02 , 0x0D03 , 0x0D3E , 0x0D43 , 0x0D46 , 0x0D48 , 0x0D4A , 0x0D4D , 0x0E34 , 0x0E3A , 0x0E47 , 0x0E4E , 0x0EB4 , 0x0EB9 , 0x0EBB , 0x0EBC , 0x0EC8 , 0x0ECD , 0x0F18 , 0x0F19 , 0x0F71 , 0x0F84 , 0x0F86 , 0x0F8B , 0x0F90 , 0x0F95 , 0x0F99 , 0x0FAD , 0x0FB1 , 0x0FB7 , 0x20D0 , 0x20DC , 0x302A , 0x302F , 0x0030 , 0x0039 , 0x0660 , 0x0669 , 0x06F0 , 0x06F9 , 0x0966 , 0x096F , 0x09E6 , 0x09EF , 0x0A66 , 0x0A6F , 0x0AE6 , 0x0AEF , 0x0B66 , 0x0B6F , 0x0BE7 , 0x0BEF , 0x0C66 , 0x0C6F , 0x0CE6 , 0x0CEF , 0x0D66 , 0x0D6F , 0x0E50 , 0x0E59 , 0x0ED0 , 0x0ED9 , 0x0F20 , 0x0F29 , 0x3031 , 0x3035 , 0x309D , 0x309E , 0x30FC , 0x30FE , 0x0000 , 0x05BF , 0x05C4 , 0x0670 , 0x093C , 0x094D , 0x09BC , 0x09BE , 0x09BF , 0x09D7 , 0x0A02 , 0x0A3C , 0x0A3E , 0x0A3F , 0x0ABC , 0x0B3C , 0x0BD7 , 0x0D57 , 0x0E31 , 0x0EB1 , 0x0F35 , 0x0F37 , 0x0F39 , 0x0F3E , 0x0F3F , 0x0F97 , 0x0FB9 , 0x20E1 , 0x3099 , 0x309A , 0x00B7 , 0x02D0 , 0x02D1 , 0x0387 , 0x0640 , 0x0E46 , 0x0EC6 , 0x3005 , 0x0000 } ; } 	0
package javax . xml . parsers ; public class ParserConfigurationException extends Exception { public ParserConfigurationException ( ) { super ( ) ; } public ParserConfigurationException ( String msg ) { super ( msg ) ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLOneventElementImpl extends WMLElementImpl implements WMLOneventElement { public WMLOneventElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setType ( String newValue ) { setAttribute ( "type" , newValue ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } } 	0
package org . apache . xerces . domx ; public abstract class DOMException extends org . w3c . dom . DOMException { public static final short UNSPECIFIED_EVENT_TYPE = 100 ; public static final short UNSUPPORTED_EVENT_TYPE = 101 ; public DOMException ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class EntityImpl extends ParentNode implements Entity { static final long serialVersionUID = - 3575760943444303423L ; protected String name ; protected String publicId ; protected String systemId ; protected String notationName ; public EntityImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; isReadOnly ( true ) ; } public short getNodeType ( ) { return Node . ENTITY_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public Node cloneNode ( boolean deep ) { EntityImpl newentity = ( EntityImpl ) super . cloneNode ( deep ) ; return newentity ; } public String getPublicId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return publicId ; } public String getSystemId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return systemId ; } public String getNotationName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return notationName ; } public void setPublicId ( String id ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } publicId = id ; } public void setSystemId ( String id ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } systemId = id ; } public void setNotationName ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } notationName = name ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrNSImpl extends AttrImpl { static final long serialVersionUID = - 781906615369795414L ; protected String namespaceURI ; protected String localName ; protected AttrNSImpl ( DocumentImpl ownerDocument , String namespaceURI , String qualifiedName ) { super ( ownerDocument , qualifiedName ) ; if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = qualifiedName ; } else { prefix = qualifiedName . substring ( 0 , index ) ; localName = qualifiedName . substring ( index + 1 ) ; } if ( ( prefix != null && ( namespaceURI == null || namespaceURI . equals ( "" ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) || ( prefix . equals ( "xmlns" ) && ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) ) || ( qualifiedName . equals ( "xmlns" ) && ( namespaceURI == null || ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } this . namespaceURI = namespaceURI ; } protected AttrNSImpl ( DocumentImpl ownerDocument , String value ) { super ( ownerDocument , value ) ; } public String getNamespaceURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return namespaceURI ; } public String getPrefix ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int index = name . indexOf ( ':' ) ; return index < 0 ? null : name . substring ( 0 , index ) ; } public void setPrefix ( String prefix ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( namespaceURI == null || ( prefix != null && ( ( prefix . equals ( "xmlns" ) && ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } if ( ownerDocument . errorChecking && ! DocumentImpl . isXMLName ( prefix ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } name = prefix + ":" + localName ; } public String getLocalName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return localName ; } } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DeferredEntityReferenceImpl extends EntityReferenceImpl implements DeferredNode { static final long serialVersionUID = 390319091370032223L ; protected transient int fNodeIndex ; DeferredEntityReferenceImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; needsSyncChildren ( true ) ; } public int getNodeIndex ( ) { return fNodeIndex ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; name = ownerDocument . getNodeNameString ( fNodeIndex ) ; } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; DocumentType doctype = ownerDocument . getDoctype ( ) ; boolean found = false ; if ( doctype != null ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; NamedNodeMap entities = doctype . getEntities ( ) ; if ( entities != null ) { Entity entity = ( Entity ) entities . getNamedItem ( getNodeName ( ) ) ; if ( entity != null ) { found = true ; boolean ro = isReadOnly ( ) ; isReadOnly ( false ) ; Node child = entity . getFirstChild ( ) ; while ( child != null ) { appendChild ( child . cloneNode ( true ) ) ; child = child . getNextSibling ( ) ; } if ( ro ) { setReadOnly ( true , true ) ; } } } ownerDocument ( ) . mutationEvents = orig ; } if ( ! found ) { isReadOnly ( false ) ; synchronizeChildren ( fNodeIndex ) ; setReadOnly ( true , true ) ; } } protected void synchronize ( ) { } } 	0
package org . apache . xerces . jaxp ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . xml . sax . SAXException ; public class SAXParserFactoryImpl extends SAXParserFactory { public SAXParserFactoryImpl ( ) { super ( ) ; } public SAXParser newSAXParser ( ) throws ParserConfigurationException { return ( new SAXParserImpl ( this . isNamespaceAware ( ) , this . isValidating ( ) ) ) ; } } 	1
package org . apache . wml ; public interface WMLSelectElement extends WMLElement { public void setTabIndex ( int newValue ) ; public int getTabIndex ( ) ; public void setMultiple ( boolean newValue ) ; public boolean getMultiple ( ) ; public void setName ( String newValue ) ; public String getName ( ) ; public void setValue ( String newValue ) ; public String getValue ( ) ; public void setTitle ( String newValue ) ; public String getTitle ( ) ; public void setIName ( String newValue ) ; public String getIName ( ) ; public void setIValue ( String newValue ) ; public String getIValue ( ) ; public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public class AttributeMap extends NamedNodeMapImpl { protected AttributeMap ( ElementImpl ownerNode , NamedNodeMapImpl defaults ) { super ( ownerNode ) ; if ( defaults != null ) { cloneContent ( defaults ) ; if ( nodes != null ) { hasDefaults ( true ) ; } } } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } NodeImpl argn = ( NodeImpl ) arg ; if ( argn . isOwned ( ) ) { throw new DOMExceptionImpl ( DOMException . INUSE_ATTRIBUTE_ERR , "DOM009 Attribute already in use" ) ; } argn . ownerNode = ownerNode ; argn . isOwned ( true ) ; int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; previous . ownerNode = ownerNode . ownerDocument ( ) ; previous . isOwned ( false ) ; previous . isSpecified ( true ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { ownerNode . dispatchAggregateEvents ( ( AttrImpl ) arg , previous == null ? null : previous . getNodeValue ( ) ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } NodeImpl argn = ( NodeImpl ) arg ; if ( argn . isOwned ( ) ) { throw new DOMExceptionImpl ( DOMException . INUSE_ATTRIBUTE_ERR , "DOM009 Attribute already in use" ) ; } argn . ownerNode = ownerNode ; argn . isOwned ( true ) ; int i = findNamePoint ( argn . getNamespaceURI ( ) , argn . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; previous . ownerNode = ownerNode . ownerDocument ( ) ; previous . isOwned ( false ) ; previous . isSpecified ( true ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { ownerNode . dispatchAggregateEvents ( ( AttrImpl ) arg , previous == null ? null : previous . getNodeValue ( ) ) ; } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { return internalRemoveNamedItem ( name , true ) ; } Node safeRemoveNamedItem ( String name ) { return internalRemoveNamedItem ( name , false ) ; } final protected Node internalRemoveNamedItem ( String name , boolean raiseEx ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { if ( raiseEx ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } else { return null ; } } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; if ( hasDefaults ( ) ) { NamedNodeMapImpl defaults = ( ( ElementImpl ) ownerNode ) . getDefaultAttributes ( ) ; Node d ; if ( defaults != null && ( d = defaults . getNamedItem ( name ) ) != null && findNamePoint ( name , i + 1 ) < 0 ) { NodeImpl clone = ( NodeImpl ) d . cloneNode ( true ) ; clone . ownerNode = ownerNode ; clone . isOwned ( true ) ; clone . isSpecified ( false ) ; nodes . setElementAt ( clone , i ) ; } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } n . ownerNode = ownerNode . ownerDocument ( ) ; n . isOwned ( false ) ; n . isSpecified ( true ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { return internalRemoveNamedItemNS ( namespaceURI , name , true ) ; } Node safeRemoveNamedItemNS ( String namespaceURI , String name ) { return internalRemoveNamedItemNS ( namespaceURI , name , false ) ; } final protected Node internalRemoveNamedItemNS ( String namespaceURI , String name , boolean raiseEx ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { if ( raiseEx ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } else { return null ; } } LCount lc = null ; String oldvalue = "" ; AttrImpl enclosingAttribute = null ; if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttribute = ( AttrImpl ) ( nodes . elementAt ( i ) ) ; oldvalue = enclosingAttribute . getNodeValue ( ) ; } } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; String nodeName = n . getNodeName ( ) ; if ( hasDefaults ( ) ) { NamedNodeMapImpl defaults = ( ( ElementImpl ) ownerNode ) . getDefaultAttributes ( ) ; Node d ; if ( defaults != null && ( d = defaults . getNamedItem ( nodeName ) ) != null ) { int j = findNamePoint ( nodeName , 0 ) ; if ( j >= 0 && findNamePoint ( nodeName , j + 1 ) < 0 ) { NodeImpl clone = ( NodeImpl ) d . cloneNode ( true ) ; clone . ownerNode = ownerNode ; clone . isOwned ( true ) ; clone . isSpecified ( false ) ; nodes . setElementAt ( clone , i ) ; } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } n . ownerNode = ownerNode . ownerDocument ( ) ; n . isOwned ( false ) ; n . isSpecified ( true ) ; if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_ATTR_MODIFIED , true , false , null , n . getNodeValue ( ) , ( ( ElementImpl ) ownerNode ) . getAttribute ( name ) , name ) ; ownerNode . dispatchEvent ( me ) ; } ownerNode . dispatchAggregateEvents ( null , null ) ; } return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { AttributeMap newmap = new AttributeMap ( ( ElementImpl ) ownerNode , null ) ; newmap . hasDefaults ( hasDefaults ( ) ) ; newmap . cloneContent ( this ) ; return newmap ; } } 	1
package org . w3c . dom . html ; public interface HTMLTableColElement extends HTMLElement { public String getAlign ( ) ; public void setAlign ( String align ) ; public String getCh ( ) ; public void setCh ( String ch ) ; public String getChOff ( ) ; public void setChOff ( String chOff ) ; public int getSpan ( ) ; public void setSpan ( int span ) ; public String getVAlign ( ) ; public void setVAlign ( String vAlign ) ; public String getWidth ( ) ; public void setWidth ( String width ) ; } 	0
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . w3c . dom . Document ; public abstract class DocumentBuilder { protected DocumentBuilder ( ) { super ( ) ; } public Document parse ( InputStream stream ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( stream ) ) ) ; } public Document parse ( String uri ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( uri ) ) ) ; } public Document parse ( File file ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( file . getName ( ) ) ) ) ; } public abstract Document parse ( InputSource source ) throws SAXException , IOException , IllegalArgumentException ; public abstract Document newDocument ( ) ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; public abstract void setEntityResolver ( EntityResolver er ) ; public abstract void setErrorHandler ( ErrorHandler eh ) ; } 	1
package org . apache . xerces . msg ; import java . util . ListResourceBundle ; public class XMLMessages extends ListResourceBundle { public static final Object CONTENTS [ ] [ ] = { { "BadMajorCode" , "The majorCode parameter to createMessage was out of bounds." } , { "FormatFailed" , "An internal error occurred while formatting the following message:\n  " } , { "RootElementRequired" , "The root element is required in a well-formed document." } , { "InvalidCharInCDSect" , "An invalid XML character (Unicode: 0x{0}) was found in the CDATA section." } , { "InvalidCharInContent" , "An invalid XML character (Unicode: 0x{0}) was found in the element content of the document." } , { "TwoColonsInQName" , "An invalid second ':' was found in the element type or attribute name." } , { "InvalidCharInMisc" , "An invalid XML character (Unicode: 0x{0}) was found in markup after the end of the element content." } , { "InvalidCharInProlog" , "An invalid XML character (Unicode: 0x{0}) was found in the prolog of the document." } , { "InvalidCharInXMLDecl" , "An invalid XML character (Unicode: 0x{0}) was found in the XML declaration." } , { "CDEndInContent" , "The character sequence \"]]>\" must not appear in content unless used to mark the end of a CDATA section." } , { "CDSectUnterminated" , "The CDATA section must end with \"]]>\"." } , { "XMLDeclMustBeFirst" , "The XML declaration may only appear at the very beginning of the document." } , { "EqRequiredInXMLDecl" , "The ''='' character must follow \"{0}\" in the XML declaration." } , { "QuoteRequiredInXMLDecl" , "The value following \"{0}\" in the XML declaration must be a quoted string." } , { "XMLDeclUnterminated" , "The XML declaration must end with \"?>\"." } , { "VersionInfoRequired" , "The version is required in the XML declaration." } , { "MarkupNotRecognizedInProlog" , "The markup in the document preceding the root element must be well-formed." } , { "MarkupNotRecognizedInMisc" , "The markup in the document following the root element must be well-formed." } , { "SDDeclInvalid" , "The standalone document declaration value must be \"yes\" or \"no\", not \"{0}\"." } , { "XMLLangInvalid" , "The xml:lang attribute value \"{0}\" is an invalid language identifier." } , { "ETagRequired" , "The element type \"{0}\" must be terminated by the matching end-tag \"</{0}>\"." } , { "ElementUnterminated" , "Element type \"{0}\" must be followed by either attribute specifications, \">\" or \"/>\"." } , { "EqRequiredInAttribute" , "Attribute name \"{0}\" must be followed by the ''='' character." } , { "AttributeNotUnique" , "Attribute \"{1}\" was already specified for element \"{0}\"." } , { "ETagUnterminated" , "The end-tag for element type \"{0}\" must end with a ''>'' delimiter." } , { "MarkupNotRecognizedInContent" , "The content of elements must consist of well-formed character data or markup." } , { "ReferenceUnterminated" , "The reference must be terminated by a ';' delimiter." } , { "ReferenceNotInOneEntity" , "The reference must be entirely contained within the same parsed entity." } , { "ElementEntityMismatch" , "The element \"{0}\" must start and end within the same entity." } , { "InvalidCharInAttValue" , "An invalid XML character (Unicode: 0x{2}) was found in the value of attribute \"{1}\"." } , { "InvalidCharInComment" , "An invalid XML character (Unicode: 0x{0}) was found in the comment." } , { "InvalidCharInPI" , "An invalid XML character (Unicode: 0x{0}) was found in the processing instruction." } , { "InvalidCharInInternalSubset" , "An invalid XML character (Unicode: 0x{0}) was found in the internal subset of the DTD." } , { "InvalidCharInTextDecl" , "An invalid XML character (Unicode: 0x{0}) was found in the text declaration." } , { "QuoteRequiredInAttValue" , "The value of attribute \"{1}\" must begin with either a single or double quote character." } , { "LessthanInAttValue" , "The value of attribute \"{1}\" must not contain the ''<'' character." } , { "AttributeValueUnterminated" , "The value for attribute \"{1}\" must end with the matching quote character." } , { "DashDashInComment" , "The string \"--\" is not permitted within comments." } , { "CommentUnterminated" , "The comment must end with \"-->\"." } , { "PITargetRequired" , "The processing instruction must begin with the name of the target." } , { "SpaceRequiredInPI" , "White space is required between the processing instruction target and data." } , { "PIUnterminated" , "The processing instruction must end with \"?>\"." } , { "ReservedPITarget" , "The processing instruction target matching \"[xX][mM][lL]\" is not allowed." } , { "VersionInfoInvalid" , "Invalid version \"{0}\"." } , { "VersionNotSupported" , "XML version \"{0}\" is not supported." } , { "DigitRequiredInCharRef" , "A decimal representation must immediately follow the \"&#\" in a character reference." } , { "HexdigitRequiredInCharRef" , "A hexadecimal representation must immediately follow the \"&#x\" in a character reference." } , { "SemicolonRequiredInCharRef" , "The character reference must end with the ';' delimiter." } , { "InvalidCharRef" , "Character reference \"&#{0}\" is an invalid XML character." } , { "NameRequiredInReference" , "The entity name must immediately follow the '&' in the entity reference." } , { "SemicolonRequiredInReference" , "The reference to entity \"{0}\" must end with the '';'' delimiter." } , { "TextDeclMustBeFirst" , "The text declaration may only appear at the very beginning of the external parsed entity." } , { "EqRequiredInTextDecl" , "The ''='' character must follow \"{0}\" in the text declaration." } , { "QuoteRequiredInTextDecl" , "The value following \"{0}\" in the text declaration must be a quoted string." } , { "SpaceRequiredInTextDecl" , "White space is required between the version and the encoding declaration." } , { "TextDeclUnterminated" , "The text declaration must end with \"?>\"." } , { "EncodingDeclRequired" , "The encoding declaration is required in the text declaration." } , { "CommentNotInOneEntity" , "The comment must be entirely contained within the same parsed entity." } , { "PINotInOneEntity" , "The processing instruction must be entirely contained within the same parsed entity." } , { "EncodingDeclInvalid" , "Invalid encoding name \"{0}\"." } , { "InvalidCharInEntityValue" , "An invalid XML character (Unicode: 0x{0}) was found in the literal entity value." } , { "InvalidCharInExternalSubset" , "An invalid XML character (Unicode: 0x{0}) was found in the external subset of the DTD." } , { "InvalidCharInIgnoreSect" , "An invalid XML character (Unicode: 0x{0}) was found in the excluded conditional section." } , { "InvalidCharInPublicID" , "An invalid XML character (Unicode: 0x{0}) was found in the public identifier." } , { "InvalidCharInSystemID" , "An invalid XML character (Unicode: 0x{0}) was found in the system identifier." } , { "QuoteRequiredInSystemID" , "The system identifier must begin with either a single or double quote character." } , { "SystemIDUnterminated" , "The system identifier must end with the matching quote character." } , { "QuoteRequiredInPublicID" , "The public identifier must begin with either a single or double quote character." } , { "PublicIDUnterminated" , "The public identifier must end with the matching quote character." } , { "PubidCharIllegal" , "The character (Unicode: 0x{0}) is not permitted in the public identifier." } , { "MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL" , "White space is required after \"<!DOCTYPE\" in the document type declaration." } , { "MSG_ROOT_ELEMENT_TYPE_REQUIRED" , "The root element type must appear after \"<!DOCTYPE\" in the document type declaration." } , { "DoctypedeclUnterminated" , "The document type declaration for root element type \"{0}\" must end with ''>''." } , { "PEReferenceWithinMarkup" , "The parameter entity reference \"%{0};\" cannot occur within markup in the internal subset of the DTD." } , { "MSG_MARKUP_NOT_RECOGNIZED_IN_DTD" , "The markup declarations contained or pointed to by the document type declaration must be well-formed." } , { "MSG_XML_SPACE_DECLARATION_ILLEGAL" , "The attribute declaration for \"xml:space\" must be given as an enumerated type whose only possible values are \"default\" and \"preserve\"." } , { "MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL" , "White space is required after \"<!ELEMENT\" in the element type declaration." } , { "MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL" , "The element type is required in the element type declaration." } , { "MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL" , "White space is required after the element type \"{0}\" in the element type declaration." } , { "MSG_CONTENTSPEC_REQUIRED_IN_ELEMENTDECL" , "The constraint is required after the element type \"{0}\" in the element type declaration." } , { "ElementDeclUnterminated" , "The declaration for element type \"{0}\" must end with ''>''." } , { "MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN" , "A ''('' character or an element type is required in the declaration of element type \"{0}\"." } , { "MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN" , "A '')'' is required in the declaration of element type \"{0}\"." } , { "MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT" , "An element type is required in the declaration of element type \"{0}\"." } , { "MSG_CLOSE_PAREN_REQUIRED_IN_MIXED" , "A '')'' is required in the declaration of element type \"{0}\"." } , { "MixedContentUnterminated" , "The mixed content model \"{0}\" must end with \")*\" when the types of child elements are constrained." } , { "MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL" , "White space is required after \"<!ATTLIST\" in the attribute-list declaration." } , { "MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL" , "The element type is required in the attribute-list declaration." } , { "MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF" , "White space is required before the attribute name in the attribute-list declaration for element \"{0}\"." } , { "AttNameRequiredInAttDef" , "The attribute name must be specified in the attribute-list declaration for element \"{0}\"." } , { "MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF" , "White space is required before the attribute type in the declaration of attribute \"{1}\" for element \"{0}\"." } , { "AttTypeRequiredInAttDef" , "The attribute type is required in the declaration of attribute \"{1}\" for element \"{0}\"." } , { "MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF" , "White space is required before the attribute default in the declaration of attribute \"{1}\" for element \"{0}\"." } , { "MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE" , "White space must appear after \"NOTATION\" in the \"{1}\" attribute declaration." } , { "MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE" , "The ''('' character must follow \"NOTATION\" in the \"{1}\" attribute declaration." } , { "MSG_NAME_REQUIRED_IN_NOTATIONTYPE" , "The notation name is required in the notation type list for the \"{1}\" attribute declaration." } , { "NotationTypeUnterminated" , "The notation type list must end with '')'' in the \"{1}\" attribute declaration." } , { "MSG_NMTOKEN_REQUIRED_IN_ENUMERATION" , "The name token is required in the enumerated type list for the \"{1}\" attribute declaration." } , { "EnumerationUnterminated" , "The enumerated type list must end with '')'' in the \"{1}\" attribute declaration." } , { "MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL" , "White space must appear after \"FIXED\" in the \"{1}\" attribute declaration." } , { "IncludeSectUnterminated" , "The included conditional section must end with \"]]>\"." } , { "IgnoreSectUnterminated" , "The excluded conditional section must end with \"]]>\"." } , { "NameRequiredInPEReference" , "The entity name must immediately follow the '%' in the parameter entity reference." } , { "SemicolonRequiredInPEReference" , "The parameter entity reference \"%{0};\" must end with the '';'' delimiter." } , { "MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL" , "White space is required after \"<!ENTITY\" in the entity declaration." } , { "MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL" , "White space is required between \"<!ENTITY\" and the '%' character in the parameter entity declaration." } , { "MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL" , "White space is required between the '%' and the entity name in the parameter entity declaration." } , { "MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL" , "The name of the entity is required in the entity declaration." } , { "MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL" , "White space is required between the entity name \"{0}\" and the definition in the entity declaration." } , { "MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL" , "White space is required between \"NDATA\" and the notation name in the declaration for the entity \"{0}\"." } , { "MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL" , "The notation name is required after \"NDATA\" in the declaration for the entity \"{0}\"." } , { "EntityDeclUnterminated" , "The declaration for the entity \"{0}\" must end with ''>''." } , { "ExternalIDRequired" , "The external entity declaration must begin with either \"SYSTEM\" or \"PUBLIC\"." } , { "MSG_SPACE_REQUIRED_BEFORE_PUBIDLITERAL_IN_EXTERNALID" , "White space is required between \"PUBLIC\" and the public identifier." } , { "MSG_SPACE_REQUIRED_AFTER_PUBIDLITERAL_IN_EXTERNALID" , "White space is required between the public identifier and the system identifier." } , { "MSG_SPACE_REQUIRED_BEFORE_SYSTEMLITERAL_IN_EXTERNALID" , "White space is required between \"SYSTEM\" and the system identifier." } , { "MSG_URI_FRAGMENT_IN_SYSTEMID" , "The fragment identifier should not be specified as part of the system identifier \"{0}\"." } , { "MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL" , "White space is required after \"<!NOTATION\" in the notation declaration." } , { "MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL" , "The name of the notation is required in the notation declaration." } , { "MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL" , "White space is required after the notation name \"{0}\" in the notation declaration." } , { "NotationDeclUnterminated" , "The declaration for the notation \"{0}\" must end with ''>''." } , { "DuplicateTypeInMixedContent" , "The element type \"{0}\" was already specified in this content model." } , { "ENTITIESInvalid" , "Attribute value \"{1}\" of type ENTITIES must be the names of one or more unparsed entities." } , { "ENTITYInvalid" , "Attribute value \"{1}\" of type ENTITY must be the name of an unparsed entity." } , { "IDDefaultTypeInvalid" , "The ID attribute \"{0}\" must have a declared default of \"#IMPLIED\" or \"#REQUIRED\"." } , { "IDInvalid" , "Attribute value \"{1}\" of type ID must be a name." } , { "IDNotUnique" , "Attribute value \"{1}\" of type ID must be unique within the document." } , { "IDREFInvalid" , "Attribute value \"{1}\" of type IDREF must be a name." } , { "IDREFSInvalid" , "Attribute value \"{0}\" of type IDREFS must be one or more names." } , { "ImproperDeclarationNesting" , "The replacement text of parameter entity \"{0}\" must include properly nested declarations." } , { "ImproperGroupNesting" , "The replacement text of parameter entity \"{0}\" must include properly nested pairs of parentheses." } , { "MSG_ATTRIBUTE_NOT_DECLARED" , "Attribute \"{1}\" must be declared for element type \"{0}\"." } , { "MSG_ATTRIBUTE_VALUE_NOT_IN_LIST" , "Attribute \"{0}\" with value \"{1}\" must have a value from the list \"{2}\"." } , { "MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE" , "The value \"{1}\" of attribute \"{0}\" must not be changed by normalization (to \"{2}\") in a standalone document." } , { "MSG_CONTENT_INCOMPLETE" , "The content of element type \"{0}\" is incomplete, it must match \"{1}\"." } , { "MSG_CONTENT_INVALID" , "The content of element type \"{0}\" must match \"{1}\"." } , { "MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED" , "Attribute \"{1}\" for element type \"{0}\" has a default value and must be specified in a standalone document." } , { "MSG_DUPLICATE_ATTDEF" , "Attribute \"{1}\" is already declared for element type \"{0}\"." } , { "MSG_ELEMENT_ALREADY_DECLARED" , "Element type \"{0}\" must not be declared more than once." } , { "MSG_ELEMENT_NOT_DECLARED" , "Element type \"{0}\" must be declared." } , { "MSG_ELEMENT_WITH_ID_REQUIRED" , "An element with the identifier \"{0}\" must appear in the document." } , { "MSG_EXTERNAL_ENTITY_NOT_PERMITTED" , "The reference to external entity \"{0}\" is not permitted in a standalone document." } , { "MSG_FIXED_ATTVALUE_INVALID" , "Attribute \"{1}\" with value \"{2}\" must have a value of \"{3}\"." } , { "MSG_MORE_THAN_ONE_ID_ATTRIBUTE" , "Element type \"{0}\" already has attribute \"{1}\" of type ID, a second attribute \"{2}\" of type ID is not permitted." } , { "MSG_MORE_THAN_ONE_NOTATION_ATTRIBUTE" , "Element type \"{0}\" already has attribute \"{1}\" of type NOTATION, a second attribute \"{2}\" of type NOTATION is not permitted." } , { "MSG_NOTATION_NOT_DECLARED_FOR_NOTATIONTYPE_ATTRIBUTE" , "The notation \"{2}\" must be declared when referenced in the notation type list for attribute \"{1}\"." } , { "MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL" , "The notation \"{1}\" must be declared when referenced in the unparsed entity declaration for \"{0}\"." } , { "MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE" , "The reference to entity \"{0}\" declared in an external parsed entity is not permitted in a standalone document." } , { "MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED" , "Attribute \"{1}\" is required and must be specified for element type \"{0}\"." } , { "MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE" , "White space must not occur between elements declared in an external parsed entity with element content in a standalone document." } , { "NMTOKENInvalid" , "Attribute value \"{1}\" of type NMTOKEN must be a name token." } , { "NMTOKENSInvalid" , "Attribute value \"{0}\" of type NMTOKENS must be one or more name tokens." } , { "RootElementTypeMustMatchDoctypedecl" , "Document root element \"{1}\", must match DOCTYPE root \"{0}\"." } , { "UndeclaredElementInContentSpec" , "The content model of element \"{0}\" refers to the undeclared element \"{1}\"." } , { "ReferenceToExternalEntity" , "The external entity reference \"&{0};\" is not permitted in an attribute value." } , { "EntityNotDeclared" , "The entity \"{0}\" was referenced, but not declared." } , { "ReferenceToUnparsedEntity" , "The unparsed entity reference \"&{0};\" is not permitted." } , { "RecursiveReference" , "Recursive reference \"&{0};\". (Reference path: {1})" } , { "RecursivePEReference" , "Recursive reference \"%{0};\". (Reference path: {1})" } , { "EncodingNotSupported" , "The encoding \"{0}\" is not supported." } , { "EncodingRequired" , "A parsed entity not encoded in either UTF-8 or UTF-16 must contain an encoding declaration." } , { "PrefixDeclared" , "The namespace prefix \"{0}\" was not declared." } , { "MSG_ATT_DEFAULT_INVALID" , "The defaultValue \"{1}\" of attribute \"{0}\" is not legal as for the lexical constraints of this attribute type." } , { "MSG_GENERIC_SCHEMA_ERROR" , "General Schema Error: {0}." } , } ; public Object [ ] [ ] getContents ( ) { return CONTENTS ; } } 	0
package org . apache . xerces . dom . events ; import org . apache . xerces . dom . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; public class MutationEventImpl extends org . apache . xerces . dom . events . EventImpl implements MutationEvent { Node relatedNode = null ; String prevValue = null , newValue = null , attrName = null ; public static final String DOM_SUBTREE_MODIFIED = "DOMSubtreeModified" ; public static final String DOM_NODE_INSERTED = "DOMNodeInserted" ; public static final String DOM_NODE_REMOVED = "DOMNodeRemoved" ; public static final String DOM_NODE_REMOVED_FROM_DOCUMENT = "DOMNodeRemovedFromDocument" ; public static final String DOM_NODE_INSERTED_INTO_DOCUMENT = "DOMNodeInsertedIntoDocument" ; public static final String DOM_ATTR_MODIFIED = "DOMAttrModified" ; public static final String DOM_CHARACTER_DATA_MODIFIED = "DOMCharacterDataModified" ; public String getAttrName ( ) { return attrName ; } public String getNewValue ( ) { return newValue ; } public String getPrevValue ( ) { return prevValue ; } public Node getRelatedNode ( ) { return relatedNode ; } public void initMutationEvent ( String typeArg , boolean canBubbleArg , boolean cancelableArg , Node relatedNodeArg , String prevValueArg , String newValueArg , String attrNameArg ) { relatedNode = relatedNodeArg ; prevValue = prevValueArg ; newValue = newValueArg ; attrName = attrNameArg ; super . initEvent ( typeArg , canBubbleArg , cancelableArg ) ; } } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . utils . QName ; public class InsertableElementsInfo { public boolean canHoldPCData ; public int childCount ; public QName curChildren [ ] ; public boolean isValidEOC ; public int insertAt ; public QName possibleChildren [ ] ; public int resultsCount ; public boolean results [ ] ; } 	0
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . SymbolCache ; import org . apache . xerces . utils . UTF8DataChunk ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . LocatorImpl ; import java . io . InputStream ; import java . util . Vector ; final class UTF8Reader extends XMLEntityReader { private final static boolean USE_OUT_OF_LINE_LOAD_NEXT_BYTE = false ; private final static boolean USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE = true ; public UTF8Reader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , InputStream dataStream , StringPool stringPool ) throws Exception { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fInputStream = dataStream ; fStringPool = stringPool ; fCharArrayRange = fStringPool . createCharArrayRange ( ) ; fCurrentChunk = UTF8DataChunk . createChunk ( fStringPool , null ) ; fillCurrentChunk ( ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } private int addSymbol ( int offset , int length , int hashcode ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , hashcode ) ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } private int slowLoadNextByte ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; return ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } else { fCurrentChunk = UTF8DataChunk . createChunk ( fStringPool , fCurrentChunk ) ; return fillCurrentChunk ( ) ; } } private int loadNextByte ( ) throws Exception { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; return fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { return slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) return slowLoadNextByte ( ) ; else return ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; fMostRecentData = null ; fMostRecentByte = 0 ; return nextReader ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) throws Exception { int b0 = fMostRecentByte ; if ( b0 != ch ) { if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( ch , skipPastChar ) ; } } if ( ch == 0x0A && b0 == 0x0D ) { if ( skipPastChar ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; b0 = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == 0x0A ) { fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } } return true ; } return false ; } if ( ch == 0x0D ) return false ; if ( skipPastChar ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int b0 = fMostRecentByte ; if ( b0 < 0x80 ) { if ( b0 >= 0x20 || b0 == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } if ( b0 == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } if ( b0 == 0x0D ) { if ( skipPastChar ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; b0 = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == 0x0A ) { fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } } return true ; } if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; } return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { boolean result = false ; if ( ! ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; return true ; } result = true ; } fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } int b3 = loadNextByte ( ) ; boolean result = false ; if ( ( ( b0 & 0xf8 ) == 0xf0 ) && ( ( b1 & 0xc0 ) == 0x80 ) && ( ( b2 & 0xc0 ) == 0x80 ) && ( ( b3 & 0xc0 ) == 0x80 ) ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; return true ; } result = true ; fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentByte ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { if ( ! skipPastChar ) return true ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) return true ; fLinefeedCounter ++ ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return true ; } public void skipToChar ( char ch ) throws Exception { int b0 = fMostRecentByte ; while ( true ) { if ( b0 == ch ) return ; if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( ch ) ; return ; } fCharacterCounter ++ ; } else if ( b0 == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( b0 == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; if ( b0 != 0x0A ) continue ; fLinefeedCounter ++ ; } else if ( b0 < 0x80 ) { fCharacterCounter ++ ; } else { fCharacterCounter ++ ; if ( ( 0xe0 & b0 ) == 0xc0 ) { loadNextByte ( ) ; } else if ( ( 0xf0 & b0 ) == 0xe0 ) { loadNextByte ( ) ; loadNextByte ( ) ; } else { loadNextByte ( ) ; loadNextByte ( ) ; loadNextByte ( ) ; } } b0 = loadNextByte ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentByte ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) continue ; fLinefeedCounter ++ ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } } protected boolean skippedMultiByteCharWithFlag ( int b0 , int flag ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { if ( ( XMLCharacterProperties . fgCharFlags [ ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ] & flag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } if ( ( XMLCharacterProperties . fgCharFlags [ ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ] & flag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } return true ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } public void skipPastName ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ b0 ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_InitialNameCharFlag ) ) return ; } while ( true ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( fastcheck == b0 ) return ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_NameCharFlag ) ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; while ( true ) { if ( fastcheck == b0 ) return ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) return ; } else { if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_NameCharFlag ) ) return ; } fCharacterCounter ++ ; b0 = loadNextByte ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int length = s . length ; byte [ ] data = fMostRecentData ; int index = fCurrentIndex + length ; int sindex = length ; try { while ( sindex -- > 0 ) { if ( data [ -- index ] != s [ sindex ] ) return false ; } fCurrentIndex += length ; } catch ( ArrayIndexOutOfBoundsException ex ) { int i = 0 ; index = fCurrentIndex ; while ( index < UTF8DataChunk . CHUNK_SIZE ) { if ( data [ index ++ ] != s [ i ++ ] ) return false ; } UTF8DataChunk dataChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; int savedIndex = fCurrentIndex ; slowLoadNextByte ( ) ; data = fMostRecentData ; index = 0 ; while ( i < length ) { if ( data [ index ++ ] != s [ i ++ ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; return false ; } } fCurrentIndex = index ; } fCharacterCounter += length ; fCurrentOffset += length ; try { fMostRecentByte = data [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } return true ; } public int scanInvalidChar ( ) throws Exception { int b0 = fMostRecentByte ; int ch = b0 ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; if ( ch != 0x0A ) return 0x0A ; fLinefeedCounter ++ ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } fCharacterCounter ++ ; } else if ( b0 >= 0x80 ) { fCharacterCounter ++ ; int b1 = loadNextByte ( ) ; int b2 = 0 ; if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; } else if ( ( 0xf0 & b0 ) == 0xe0 ) { b2 = loadNextByte ( ) ; ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; } else if ( ( 0xf8 & b0 ) == 0xf0 ) { b2 = loadNextByte ( ) ; int b3 = loadNextByte ( ) ; ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; } } loadNextByte ( ) ; return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentByte ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextByte ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentByte ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextByte ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextByte ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = fCurrentChunk . addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public static final byte fgAsciiAttValueChar [ ] = { 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 2 , 2 , 4 , 4 , 2 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 0 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; int b0 = fMostRecentByte ; while ( true ) { if ( b0 < 0x80 ) { switch ( fgAsciiAttValueChar [ b0 ] ) { case 1 : if ( b0 == qchar ) { int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : ( asSymbol ? fCurrentChunk . addSymbol ( offset , length , 0 ) : fCurrentChunk . addString ( offset , length ) ) ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return result ; } case 0 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 2 : return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; case 3 : return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; case 4 : return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( b0 ) ) return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; b0 = fMostRecentByte ; } } } public static final byte fgAsciiEntityValueChar [ ] = { 7 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 5 , 4 , 4 , 6 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 3 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; int b0 = fMostRecentByte ; while ( true ) { if ( b0 < 0x80 ) { switch ( fgAsciiEntityValueChar [ b0 ] ) { case 1 : if ( b0 == qchar ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : fCurrentChunk . addString ( offset , length ) ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return result ; } case 0 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 5 : fLinefeedCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 6 : fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 != 0x0A ) { continue ; } fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 2 : return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; case 3 : return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; case 7 : if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } case 4 : return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( b0 ) ) return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; b0 = fMostRecentByte ; } } } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int b0 = fMostRecentByte ; int ch = 0 ; int i = 0 ; while ( true ) { if ( b0 < 0x80 ) { ch = b0 ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } } else { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; skipPastNmtoken ( fastcheck ) ; return false ; } } else { int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; skipPastNmtoken ( fastcheck ) ; return false ; } } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } } i ++ ; offset ++ ; fCharacterCounter ++ ; fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentByte ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; int index = fCurrentIndex ; byte [ ] data = fMostRecentData ; int prefixend = - 1 ; while ( true ) { fCharacterCounter ++ ; fCurrentOffset ++ ; index ++ ; try { ch = data [ index ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; index = 0 ; data = fMostRecentData ; } if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; try { ch = data [ index + 1 ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { UTF8DataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; ch = slowLoadNextByte ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; } boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; break ; } } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } } fCurrentIndex = index ; fMostRecentByte = ch ; int length = fCurrentOffset - offset ; qname . rawname = addSymbol ( offset , length ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } private int getMultiByteSymbolChar ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } loadNextByte ( ) ; return ch ; } int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } loadNextByte ( ) ; return ch ; } fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } public int scanName ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; int ch ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ b0 ] == 0 ) { if ( b0 == 0 && atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanName ( fastcheck ) ; } return - 1 ; } ch = b0 ; } else { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } else { int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return scanMatchingName ( ch , b0 , fastcheck ) ; } private int scanMatchingName ( int ch , int b0 , int fastcheck ) throws Exception { SymbolCache cache = fStringPool . getSymbolCache ( ) ; int [ ] [ ] cacheLines = cache . fCacheLines ; char [ ] symbolChars = cache . fSymbolChars ; boolean lengthOfOne = fastcheck == fMostRecentByte ; int startOffset = cache . fSymbolCharsOffset ; int entry = 0 ; int [ ] entries = cacheLines [ entry ] ; int offset = 1 + ( ( entries [ 0 ] - 1 ) * SymbolCache . CACHE_RECORD_SIZE ) ; int totalMisses = 0 ; if ( lengthOfOne ) { while ( offset > 0 ) { if ( entries [ offset + SymbolCache . CHAR_OFFSET ] == ch ) { if ( entries [ offset + SymbolCache . INDEX_OFFSET ] != - 1 ) { int symbolIndex = entries [ offset + SymbolCache . INDEX_OFFSET ] ; if ( totalMisses > 3 ) fStringPool . updateCacheLine ( symbolIndex , totalMisses , 1 ) ; return symbolIndex ; } break ; } offset -= SymbolCache . CACHE_RECORD_SIZE ; totalMisses ++ ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; if ( offset < 0 ) { offset = 1 + ( entries [ 0 ] * SymbolCache . CACHE_RECORD_SIZE ) ; entries [ 0 ] ++ ; try { entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; entries = new int [ newSize ] ; System . arraycopy ( cacheLines [ entry ] , 0 , entries , 0 , offset ) ; cacheLines [ entry ] = entries ; entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } entries [ offset + SymbolCache . NEXT_OFFSET ] = - 1 ; } int result = fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; return result ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; int depth = 1 ; while ( true ) { if ( offset < 0 ) break ; if ( entries [ offset + SymbolCache . CHAR_OFFSET ] != ch ) { offset -= SymbolCache . CACHE_RECORD_SIZE ; totalMisses ++ ; continue ; } if ( b0 >= 0x80 ) { ch = getMultiByteSymbolChar ( b0 ) ; b0 = fMostRecentByte ; } else if ( b0 == fastcheck || XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) { ch = - 1 ; } else { ch = b0 ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } if ( ch == - 1 ) { if ( entries [ offset + SymbolCache . INDEX_OFFSET ] == - 1 ) { return fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; } cache . fSymbolCharsOffset = startOffset ; int symbolIndex = entries [ offset + SymbolCache . INDEX_OFFSET ] ; if ( totalMisses > ( depth * 3 ) ) fStringPool . updateCacheLine ( symbolIndex , totalMisses , depth ) ; return symbolIndex ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; entry = entries [ offset + SymbolCache . NEXT_OFFSET ] ; try { entries = cacheLines [ entry ] ; } catch ( ArrayIndexOutOfBoundsException ex ) { if ( entry == - 1 ) { entry = cache . fCacheLineCount ++ ; entries [ offset + SymbolCache . NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( SymbolCache . INITIAL_CACHE_RECORD_COUNT * SymbolCache . CACHE_RECORD_SIZE ) ] ; try { cacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex2 ) { cacheLines = new int [ entry * 2 ] [ ] ; System . arraycopy ( cache . fCacheLines , 0 , cacheLines , 0 , entry ) ; cache . fCacheLines = cacheLines ; cacheLines [ entry ] = entries ; } } else { entries = cacheLines [ entry ] ; throw new RuntimeException ( "RDR001 untested" ) ; } } offset = 1 + ( ( entries [ 0 ] - 1 ) * SymbolCache . CACHE_RECORD_SIZE ) ; depth ++ ; } if ( offset < 0 ) offset = 1 + ( entries [ 0 ] * SymbolCache . CACHE_RECORD_SIZE ) ; while ( true ) { entries [ 0 ] ++ ; try { entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; entries = new int [ newSize ] ; System . arraycopy ( cacheLines [ entry ] , 0 , entries , 0 , offset ) ; cacheLines [ entry ] = entries ; entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } if ( b0 >= 0x80 ) { ch = getMultiByteSymbolChar ( b0 ) ; b0 = fMostRecentByte ; } else if ( b0 == fastcheck || XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) { ch = - 1 ; } else { ch = b0 ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } if ( ch == - 1 ) { entries [ offset + SymbolCache . NEXT_OFFSET ] = - 1 ; break ; } entry = cache . fCacheLineCount ++ ; entries [ offset + SymbolCache . INDEX_OFFSET ] = - 1 ; entries [ offset + SymbolCache . NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( SymbolCache . INITIAL_CACHE_RECORD_COUNT * SymbolCache . CACHE_RECORD_SIZE ) ] ; try { cacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex ) { cacheLines = new int [ entry * 2 ] [ ] ; System . arraycopy ( cache . fCacheLines , 0 , cacheLines , 0 , entry ) ; cache . fCacheLines = cacheLines ; cacheLines [ entry ] = entries ; } offset = 1 ; try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; } int result = fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; return result ; } private int recognizeMarkup ( int b0 , QName element ) throws Exception { switch ( b0 ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 == '-' ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 == '-' ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( b0 == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } int expectedName = element . rawname ; fStringPool . getCharArrayRange ( expectedName , fCharArrayRange ) ; char [ ] expected = fCharArrayRange . chars ; int offset = fCharArrayRange . offset ; int len = fCharArrayRange . length ; if ( b0 == expected [ offset ++ ] ) { UTF8DataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; for ( int i = 1 ; i < len ; i ++ ) { if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 != expected [ offset ++ ] ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; } } fCharacterCounter += len ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == '>' ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG ; } while ( b0 == 0x20 || b0 == 0x09 || b0 == 0x0A || b0 == 0x0D ) { if ( b0 == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; } else if ( b0 == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; if ( b0 == 0x0A ) { fLinefeedCounter ++ ; b0 = loadNextByte ( ) ; } } else { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; } if ( b0 == '>' ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG ; } } fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; } return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; fCharDataLength = 0 ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentByte ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } break ; case 1 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ! fInCDSect ) { return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; break ; case 2 : fCharacterCounter ++ ; ch = loadNextByte ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; break ; case 3 : fCharacterCounter ++ ; ch = loadNextByte ( ) ; if ( ch != ']' ) { if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) { if ( fSendCharDataAsCharArray ) appendCharData ( 0x0A ) ; if ( ch == 0x20 || ch == 0x09 || ch == 0x0D ) continue ; break ; } fLinefeedCounter ++ ; } else { fCharacterCounter ++ ; } if ( fSendCharDataAsCharArray ) { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A || ch == 0x0D ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 1 : if ( ! fInCDSect ) { if ( fSendCharDataAsCharArray ) { fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = addString ( charDataOffset , fCurrentOffset - charDataOffset ) ; fCharDataHandler . processWhitespace ( stringIndex ) ; } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 2 : if ( ! fInCDSect ) { whitespace ( charDataOffset , fCurrentOffset ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextByte ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; whitespace ( charDataOffset , endOffset ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : whitespace ( charDataOffset , fCurrentOffset ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { whitespace ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { whitespace ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } break ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } } if ( fSendCharDataAsCharArray ) ch = copyAsciiCharData ( ) ; else ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 1 : if ( ! fInCDSect ) { if ( fSendCharDataAsCharArray ) { fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = addString ( charDataOffset , fCurrentOffset - charDataOffset ) ; fCharDataHandler . processCharacters ( stringIndex ) ; } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 2 : if ( ! fInCDSect ) { characters ( charDataOffset , fCurrentOffset ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextByte ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; characters ( charDataOffset , endOffset ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; break ; } if ( ch == 0x0D ) { if ( fSendCharDataAsCharArray ) appendCharData ( 0x0A ) ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; ch = loadNextByte ( ) ; } break ; } characters ( charDataOffset , fCurrentOffset ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { characters ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { characters ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentByte ; } } } private boolean copyMultiByteCharData ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; appendCharData ( ch ) ; loadNextByte ( ) ; return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; appendCharData ( ch ) ; loadNextByte ( ) ; return true ; } int b3 = loadNextByte ( ) ; if ( ( 0xf8 & b0 ) == 0xf0 ) { if ( b0 > 0xF4 || ( b0 == 0xF4 && b1 >= 0x90 ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } int ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; if ( ch < 0x10000 ) { appendCharData ( ch ) ; } else { appendCharData ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; appendCharData ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; } loadNextByte ( ) ; return true ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } private boolean skipMultiByteCharData ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { loadNextByte ( ) ; return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } loadNextByte ( ) ; return true ; } int b3 = loadNextByte ( ) ; if ( b0 > 0xF4 || ( b0 == 0xF4 && b1 >= 0x90 ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } loadNextByte ( ) ; return true ; } private int copyAsciiCharData ( ) throws Exception { int srcIndex = fCurrentIndex ; int offset = fCurrentOffset - srcIndex ; byte [ ] data = fMostRecentData ; int dstIndex = fCharDataLength ; boolean skiplf = false ; while ( true ) { int ch ; try { ch = data [ srcIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { offset += srcIndex ; slowLoadNextByte ( ) ; srcIndex = 0 ; data = fMostRecentData ; ch = data [ srcIndex ] & 0xFF ; } if ( ch >= 0x80 ) { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; skiplf = false ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; if ( skiplf ) { skiplf = false ; srcIndex ++ ; continue ; } fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; skiplf = true ; ch = 0x0A ; } else { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } srcIndex ++ ; try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } } private int skipAsciiCharData ( ) throws Exception { int srcIndex = fCurrentIndex ; int offset = fCurrentOffset - srcIndex ; byte [ ] data = fMostRecentData ; while ( true ) { int ch ; try { ch = data [ srcIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { offset += srcIndex ; slowLoadNextByte ( ) ; srcIndex = 0 ; data = fMostRecentData ; ch = data [ srcIndex ] & 0xFF ; } if ( ch >= 0x80 ) { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } srcIndex ++ ; } } private char [ ] fCharacters = new char [ UTF8DataChunk . CHUNK_SIZE ] ; private int fCharDataLength = 0 ; private void appendCharData ( int ch ) throws Exception { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } private void slowAppendCharData ( int ch ) throws Exception { characters ( 0 , fCharDataLength ) ; fCharDataLength = 0 ; fCharacters [ fCharDataLength ++ ] = ( char ) ch ; } private void characters ( int offset , int endOffset ) throws Exception { if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , endOffset - offset ) ; fCharDataHandler . processCharacters ( stringIndex ) ; return ; } fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } private void whitespace ( int offset , int endOffset ) throws Exception { if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , endOffset - offset ) ; fCharDataHandler . processWhitespace ( stringIndex ) ; return ; } fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool . CharArrayRange fCharArrayRange = null ; private InputStream fInputStream = null ; private StringPool fStringPool = null ; private UTF8DataChunk fCurrentChunk = null ; private int fCurrentIndex = 0 ; private byte [ ] fMostRecentData = null ; private int fMostRecentByte = 0 ; private int fLength = 0 ; private boolean fCalledCharPropInit = false ; private boolean fCallClearPreviousChunk = true ; private int fillCurrentChunk ( ) throws Exception { byte [ ] buf = fCurrentChunk . toByteArray ( ) ; if ( fInputStream == null ) { if ( buf == null ) buf = new byte [ 1 ] ; buf [ 0 ] = 0 ; fMostRecentData = buf ; fCurrentIndex = 0 ; fCurrentChunk . setByteArray ( fMostRecentData ) ; return ( fMostRecentByte = fMostRecentData [ 0 ] & 0xFF ) ; } if ( buf == null ) buf = new byte [ UTF8DataChunk . CHUNK_SIZE ] ; int offset = 0 ; int capacity = UTF8DataChunk . CHUNK_SIZE ; int result = 0 ; do { try { result = fInputStream . read ( buf , offset , capacity ) ; } catch ( java . io . IOException ex ) { result = - 1 ; } if ( result == - 1 ) { fInputStream . close ( ) ; fInputStream = null ; try { buf [ offset ] = 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { } break ; } if ( result > 0 ) { offset += result ; capacity -= result ; } } while ( capacity > 0 ) ; fMostRecentData = buf ; fLength += offset ; fCurrentIndex = 0 ; fCurrentChunk . setByteArray ( fMostRecentData ) ; return ( fMostRecentByte = fMostRecentData [ 0 ] & 0xFF ) ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLNoopElementImpl extends WMLElementImpl implements WMLNoopElement { public WMLNoopElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . apache . xerces . dom . events ; import org . w3c . dom . events . * ; import org . w3c . dom . Node ; public class EventImpl implements Event { public String type = null ; public EventTarget target ; public Node currentNode ; public short eventPhase ; public boolean initialized = false , bubbles = true , cancelable = false ; public boolean stopPropagation = false , preventDefault = false ; protected long timeStamp = System . currentTimeMillis ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) { type = eventTypeArg ; bubbles = canBubbleArg ; cancelable = cancelableArg ; initialized = true ; } public boolean getBubbles ( ) { return bubbles ; } public boolean getCancelable ( ) { return cancelable ; } public Node getCurrentNode ( ) { return currentNode ; } public short getEventPhase ( ) { return eventPhase ; } public EventTarget getTarget ( ) { return target ; } public String getType ( ) { return type ; } public long getTimeStamp ( ) { return timeStamp ; } public void stopPropagation ( ) { stopPropagation = true ; } public void preventDefault ( ) { preventDefault = true ; } } 	1
package org . xml . sax ; public interface XMLFilter extends XMLReader { public abstract void setParent ( XMLReader parent ) ; public abstract XMLReader getParent ( ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DOMImplementationImpl implements DOMImplementation { static DOMImplementationImpl singleton = new DOMImplementationImpl ( ) ; public boolean hasFeature ( String feature , String version ) { return ( feature . equalsIgnoreCase ( "XML" ) && ( version == null || version . equals ( "1.0" ) || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "Events" ) && ( version == null || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "MutationEvents" ) && ( version == null || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "Traversal" ) && ( version == null || version . equals ( "2.0" ) ) ) ; } public static DOMImplementation getDOMImplementation ( ) { return singleton ; } public DocumentType createDocumentType ( String qualifiedName , String publicID , String systemID ) { if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; if ( index == 0 || index == qualifiedName . length ( ) - 1 ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } return new DocumentTypeImpl ( null , qualifiedName , publicID , systemID ) ; } public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException { if ( doctype != null && doctype . getOwnerDocument ( ) != null ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } DocumentImpl doc = new DocumentImpl ( doctype ) ; Element e = doc . createElementNS ( namespaceURI , qualifiedName ) ; doc . appendChild ( e ) ; return doc ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLAElementImpl extends WMLElementImpl implements WMLAElement { public WMLAElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setHref ( String newValue ) { setAttribute ( "href" , newValue ) ; } public String getHref ( ) { return getAttribute ( "href" ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setTitle ( String newValue ) { setAttribute ( "title" , newValue ) ; } public String getTitle ( ) { return getAttribute ( "title" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface DocumentTraversal { public NodeIterator createNodeIterator ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) ; public TreeWalker createTreeWalker ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) throws DOMException ; } 	1
package org . xml . sax ; public interface ContentHandler { public void setDocumentLocator ( Locator locator ) ; public void startDocument ( ) throws SAXException ; public void endDocument ( ) throws SAXException ; public void startPrefixMapping ( String prefix , String uri ) throws SAXException ; public void endPrefixMapping ( String prefix ) throws SAXException ; public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws SAXException ; public void endElement ( String namespaceURI , String localName , String qName ) throws SAXException ; public void characters ( char ch [ ] , int start , int length ) throws SAXException ; public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException ; public void processingInstruction ( String target , String data ) throws SAXException ; public void skippedEntity ( String name ) throws SAXException ; } 	0
package org . apache . xerces . readers ; import java . io . FileNotFoundException ; import java . io . UnsupportedEncodingException ; import java . net . MalformedURLException ; import java . util . Stack ; import java . util . Vector ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . URI ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; public class DefaultEntityHandler implements XMLEntityHandler , XMLEntityHandler . DTDHandler { public interface EventHandler { public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void sendEndOfInputNotifications ( int entityName , boolean moreToFollow ) throws Exception ; public void sendReaderChangeNotifications ( XMLEntityHandler . EntityReader reader , int readerId ) throws Exception ; public boolean externalEntityStandaloneCheck ( ) ; public boolean getValidating ( ) ; } private class ReaderState { XMLEntityHandler . EntityReader reader ; InputSource source ; int entityName ; int entityType ; int entityContext ; String publicId ; String systemId ; int readerId ; int depth ; ReaderState nextReaderState ; } private ReaderState fReaderStateFreeList = null ; private StringPool fStringPool = null ; private EventHandler fEventHandler = null ; private XMLEntityHandler . CharDataHandler fCharDataHandler = null ; private XMLErrorReporter fErrorReporter = null ; private EntityResolver fResolver = null ; private EntityPool fEntityPool = null ; private EntityPool fParameterEntityPool = null ; private byte [ ] fEntityTypeStack = null ; private int [ ] fEntityNameStack = null ; private int fEntityStackDepth = 0 ; private Stack fReaderStack = new Stack ( ) ; private XMLEntityHandler . EntityReader fReader = null ; private InputSource fSource = null ; private int fEntityName = - 1 ; private int fEntityType = - 1 ; private int fEntityContext = - 1 ; private String fPublicId = null ; private String fSystemId = null ; private int fReaderId = - 1 ; private int fReaderDepth = - 1 ; private int fNextReaderId = 0 ; private NullReader fNullReader = null ; protected XMLEntityReaderFactory fReaderFactory = null ; private boolean fSendCharDataAsCharArray = false ; public DefaultEntityHandler ( StringPool stringPool , XMLErrorReporter errorReporter ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fReaderFactory = new DefaultReaderFactory ( ) ; fEntityPool = new EntityPool ( fStringPool , fErrorReporter , true ) ; } public void setEventHandler ( EventHandler eventHandler ) { fEventHandler = eventHandler ; } public void setCharDataHandler ( XMLEntityHandler . CharDataHandler charDataHandler ) { fCharDataHandler = charDataHandler ; } public XMLEntityHandler . CharDataHandler getCharDataHandler ( ) { return fCharDataHandler ; } public void setSendCharDataAsCharArray ( boolean flag ) { fSendCharDataAsCharArray = flag ; fReaderFactory . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; } public void setReaderFactory ( XMLEntityReaderFactory readerFactory ) { fReaderFactory = readerFactory ; fReaderFactory . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fEntityPool . reset ( fStringPool ) ; fParameterEntityPool = null ; fReaderStack . removeAllElements ( ) ; fEntityStackDepth = 0 ; fReader = null ; fSource = null ; fEntityName = - 1 ; fEntityType = - 1 ; fEntityContext = - 1 ; fPublicId = null ; fSystemId = null ; fReaderId = - 1 ; fReaderDepth = - 1 ; fNextReaderId = 0 ; } public void setAllowJavaEncodings ( boolean flag ) { fReaderFactory . setAllowJavaEncodingName ( flag ) ; } public boolean getAllowJavaEncodings ( ) { return fReaderFactory . getAllowJavaEncodingName ( ) ; } public int addInternalPEDecl ( int name , int value , boolean isExternal ) throws Exception { if ( fParameterEntityPool == null ) fParameterEntityPool = new EntityPool ( fStringPool , fErrorReporter , false ) ; int entityHandle = fParameterEntityPool . addEntityDecl ( name , value , - 1 , - 1 , - 1 , - 1 , isExternal ) ; return entityHandle ; } public int addExternalPEDecl ( int name , int publicId , int systemId , boolean isExternal ) throws Exception { if ( fParameterEntityPool == null ) fParameterEntityPool = new EntityPool ( fStringPool , fErrorReporter , false ) ; int entityHandle = fParameterEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , - 1 , isExternal ) ; return entityHandle ; } public int addInternalEntityDecl ( int name , int value , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , value , - 1 , - 1 , - 1 , - 1 , isExternal ) ; return entityHandle ; } public int addExternalEntityDecl ( int name , int publicId , int systemId , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , - 1 , isExternal ) ; return entityHandle ; } public int addUnparsedEntityDecl ( int name , int publicId , int systemId , int notationName , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , notationName , isExternal ) ; if ( ! fEntityPool . isNotationDeclared ( notationName ) ) { Object [ ] args = { fStringPool . toString ( name ) , fStringPool . toString ( notationName ) } ; fEntityPool . addRequiredNotation ( notationName , fErrorReporter . getLocator ( ) , XMLMessages . MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL , XMLMessages . VC_NOTATION_DECLARED , args ) ; } return entityHandle ; } public int addNotationDecl ( int notationName , int publicId , int systemId , boolean isExternal ) throws Exception { int notationHandle = fEntityPool . addNotationDecl ( notationName , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , isExternal ) ; return notationHandle ; } public boolean isUnparsedEntity ( int entityName ) { int entityHandle = fEntityPool . lookupEntity ( entityName ) ; return ( entityHandle != - 1 && fEntityPool . isUnparsedEntity ( entityHandle ) ) ; } public boolean isNotationDeclared ( int notationName ) { return fEntityPool . isNotationDeclared ( notationName ) ; } public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { fEntityPool . addRequiredNotation ( notationName , locator , majorCode , minorCode , args ) ; } public void checkRequiredNotations ( ) throws Exception { fEntityPool . checkRequiredNotations ( ) ; } protected int lookupEntity ( int entityNameIndex ) { int entityIndex = fEntityPool . lookupEntity ( entityNameIndex ) ; return entityIndex ; } private void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } public boolean externalReferenceInContent ( int entityHandle ) throws Exception { boolean external = fEntityPool . isExternalEntity ( entityHandle ) ; if ( fEventHandler . externalEntityStandaloneCheck ( ) ) { if ( external ) { reportRecoverableXMLError ( XMLMessages . MSG_EXTERNAL_ENTITY_NOT_PERMITTED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } else if ( fEntityPool . getEntityDeclIsExternal ( entityHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } } return external ; } protected int valueOfReferenceInAttValue ( int entityHandle ) throws Exception { if ( fEventHandler . externalEntityStandaloneCheck ( ) && fEntityPool . getEntityDeclIsExternal ( entityHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } int entityValue = fEntityPool . getEntityValue ( entityHandle ) ; return entityValue ; } protected boolean isExternalEntity ( int entityHandle ) { boolean external = fEntityPool . isExternalEntity ( entityHandle ) ; return external ; } protected int getEntityValue ( int entityHandle ) { int value = fEntityPool . getEntityValue ( entityHandle ) ; return value ; } protected String getPublicIdOfEntity ( int entityHandle ) { int publicId = fEntityPool . getPublicId ( entityHandle ) ; return fStringPool . toString ( publicId ) ; } protected String getSystemIdOfEntity ( int entityHandle ) { int systemId = fEntityPool . getSystemId ( entityHandle ) ; return fStringPool . toString ( systemId ) ; } protected int lookupParameterEntity ( int peName ) throws Exception { int entityHandle = - 1 ; if ( fParameterEntityPool != null ) entityHandle = fParameterEntityPool . lookupEntity ( peName ) ; return entityHandle ; } protected boolean isExternalParameterEntity ( int peIndex ) { boolean external = fParameterEntityPool . isExternalEntity ( peIndex ) ; return external ; } protected int getParameterEntityValue ( int peIndex ) { int value = fParameterEntityPool . getEntityValue ( peIndex ) ; return value ; } protected String getPublicIdOfParameterEntity ( int peIndex ) { int publicId = fParameterEntityPool . getPublicId ( peIndex ) ; return fStringPool . toString ( publicId ) ; } protected String getSystemIdOfParameterEntity ( int peIndex ) { int systemId = fParameterEntityPool . getSystemId ( peIndex ) ; return fStringPool . toString ( systemId ) ; } public XMLEntityHandler . EntityReader getEntityReader ( ) { return fReader ; } public void addRecognizer ( XMLDeclRecognizer recognizer ) { fReaderFactory . addRecognizer ( recognizer ) ; } public void setEntityResolver ( EntityResolver resolver ) { fResolver = resolver ; } public EntityResolver getEntityResolver ( ) { return fResolver ; } public String expandSystemId ( String systemId ) { return expandSystemId ( systemId , fSystemId ) ; } private String expandSystemId ( String systemId , String currentSystemId ) { String id = systemId ; if ( id == null || id . length ( ) == 0 ) { return systemId ; } try { URI uri = new URI ( id ) ; if ( uri != null ) { return systemId ; } } catch ( URI . MalformedURIException e ) { } id = fixURI ( id ) ; URI base = null ; URI uri = null ; try { if ( currentSystemId == null ) { String dir ; try { dir = fixURI ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { dir = "" ; } if ( ! dir . endsWith ( "/" ) ) { dir = dir + "/" ; } base = new URI ( "file" , "" , dir , null , null ) ; } else { base = new URI ( currentSystemId ) ; } uri = new URI ( base , id ) ; } catch ( Exception e ) { } if ( uri == null ) { return systemId ; } return uri . toString ( ) ; } private static String fixURI ( String str ) { str = str . replace ( java . io . File . separatorChar , '/' ) ; if ( str . length ( ) >= 2 ) { char ch1 = str . charAt ( 1 ) ; if ( ch1 == ':' ) { char ch0 = Character . toUpperCase ( str . charAt ( 0 ) ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { str = "/" + str ; } } } return str ; } public boolean startReadingFromDocument ( InputSource source ) throws Exception { pushEntity ( false , - 2 ) ; fSystemId = null ; pushNullReader ( ) ; fEntityName = - 2 ; fEntityType = ENTITYTYPE_DOCUMENT ; fEntityContext = ENTITYREF_DOCUMENT ; fReaderDepth = 0 ; fReaderId = fNextReaderId ++ ; fPublicId = source . getPublicId ( ) ; fSystemId = source . getSystemId ( ) ; fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; fSystemId = expandSystemId ( fSystemId , null ) ; fSource = source ; boolean xmlDecl = true ; try { fReader = fReaderFactory . createReader ( this , fErrorReporter , source , fSystemId , xmlDecl , fStringPool ) ; } catch ( MalformedURLException mu ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( FileNotFoundException fnf ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( UnsupportedEncodingException uee ) { fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; String encoding = uee . getMessage ( ) ; if ( encoding == null ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_REQUIRED , XMLMessages . P81_REQUIRED , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else if ( ! XMLCharacterProperties . validEncName ( encoding ) ) { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_NOT_SUPPORTED , XMLMessages . P81_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; return fReader != null ; } public void startReadingFromExternalSubset ( String publicId , String systemId , int readerDepth ) throws Exception { pushEntity ( true , - 1 ) ; pushReader ( ) ; pushNullReader ( ) ; fEntityName = - 1 ; fEntityType = ENTITYTYPE_EXTERNAL_SUBSET ; fEntityContext = ENTITYREF_EXTERNAL_SUBSET ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; fPublicId = publicId ; fSystemId = systemId ; startReadingFromExternalEntity ( false , - 1 ) ; } public void stopReadingFromExternalSubset ( ) throws Exception { if ( ! ( fReader instanceof NullReader ) ) throw new RuntimeException ( "FWK004 cannot happen 18" + "\n18" ) ; popReader ( ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; } public boolean startReadingFromEntity ( int entityName , int readerDepth , int context ) throws Exception { if ( context > XMLEntityHandler . ENTITYREF_IN_CONTENT ) return startReadingFromParameterEntity ( entityName , readerDepth , context ) ; int entityHandle = lookupEntity ( entityName ) ; if ( entityHandle < 0 ) { int minorCode = XMLMessages . VC_ENTITY_DECLARED ; int errorType = XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ; if ( fEntityContext == ENTITYREF_DOCUMENT || fEntityContext == ENTITYREF_IN_ATTVALUE ) { minorCode = XMLMessages . WFC_ENTITY_DECLARED ; errorType = XMLErrorReporter . ERRORTYPE_FATAL_ERROR ; } else if ( ! fEventHandler . getValidating ( ) ) { return false ; } Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENTITY_NOT_DECLARED , minorCode , args , errorType ) ; return false ; } if ( context == ENTITYREF_IN_CONTENT ) { if ( fEntityPool . isUnparsedEntity ( entityHandle ) ) { Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REFERENCE_TO_UNPARSED_ENTITY , XMLMessages . WFC_PARSED_ENTITY , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } } else { if ( isExternalEntity ( entityHandle ) ) { Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REFERENCE_TO_EXTERNAL_ENTITY , XMLMessages . WFC_NO_EXTERNAL_ENTITY_REFERENCES , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } } if ( ! pushEntity ( false , entityName ) ) { Object [ ] args = { fStringPool . toString ( entityName ) , entityReferencePath ( false , entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_RECURSIVE_REFERENCE , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } pushReader ( ) ; fEntityName = entityName ; fEntityContext = context ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; if ( context != ENTITYREF_IN_CONTENT || ! externalReferenceInContent ( entityHandle ) ) { fEntityType = ENTITYTYPE_INTERNAL ; fPublicId = null ; fSystemId = fSystemId ; int value = - 1 ; if ( context == ENTITYREF_IN_CONTENT || context == ENTITYREF_IN_DEFAULTATTVALUE ) value = getEntityValue ( entityHandle ) ; else value = valueOfReferenceInAttValue ( entityHandle ) ; startReadingFromInternalEntity ( value , false ) ; return false ; } fEntityType = ENTITYTYPE_EXTERNAL ; fPublicId = getPublicIdOfEntity ( entityHandle ) ; fSystemId = getSystemIdOfEntity ( entityHandle ) ; return startReadingFromExternalEntity ( true , entityHandle ) ; } private boolean startReadingFromParameterEntity ( int peName , int readerDepth , int context ) throws Exception { int entityHandle = lookupParameterEntity ( peName ) ; if ( entityHandle == - 1 ) { if ( fEventHandler . getValidating ( ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ENTITY_NOT_DECLARED , XMLMessages . VC_ENTITY_DECLARED , peName ) ; } return false ; } if ( ! pushEntity ( true , peName ) ) { Object [ ] args = { fStringPool . toString ( peName ) , entityReferencePath ( true , peName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_RECURSIVE_PEREFERENCE , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } pushReader ( ) ; fEntityName = peName ; fEntityContext = context ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; if ( ! isExternalParameterEntity ( entityHandle ) ) { fEntityType = ENTITYTYPE_INTERNAL_PE ; fPublicId = null ; fSystemId = fSystemId ; int value = getParameterEntityValue ( entityHandle ) ; startReadingFromInternalEntity ( value , fEntityContext == ENTITYREF_IN_ENTITYVALUE ? false : true ) ; return false ; } fEntityType = ENTITYTYPE_EXTERNAL_PE ; fPublicId = getPublicIdOfParameterEntity ( entityHandle ) ; fSystemId = getSystemIdOfParameterEntity ( entityHandle ) ; return startReadingFromExternalEntity ( true , entityHandle ) ; } private void startReadingFromInternalEntity ( int value , boolean addSpaces ) throws Exception { if ( fEntityContext == ENTITYREF_IN_ENTITYVALUE ) { } fSource = null ; fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; fReader = fReaderFactory . createStringReader ( this , fErrorReporter , fSendCharDataAsCharArray , getLineNumber ( ) , getColumnNumber ( ) , value , fStringPool , addSpaces ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; } private boolean startReadingFromExternalEntity ( boolean checkForTextDecl , int entityHandle ) throws Exception { if ( fEntityContext == ENTITYREF_IN_ENTITYVALUE ) { } if ( fEntityContext == ENTITYREF_IN_DTD_WITHIN_MARKUP ) { } fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; String baseSystemId = null ; if ( entityHandle != - 1 ) { if ( fEntityType == ENTITYTYPE_EXTERNAL_PE ) baseSystemId = fParameterEntityPool . getBaseSystemId ( entityHandle ) ; else baseSystemId = fEntityPool . getBaseSystemId ( entityHandle ) ; } if ( baseSystemId == null ) { ReaderState rs = ( ReaderState ) fReaderStack . peek ( ) ; baseSystemId = rs . systemId ; } fSystemId = expandSystemId ( fSystemId , baseSystemId ) ; fSource = fResolver == null ? null : fResolver . resolveEntity ( fPublicId , fSystemId ) ; if ( fSource == null ) { fSource = new InputSource ( fSystemId ) ; if ( fPublicId != null ) fSource . setPublicId ( fPublicId ) ; } else { if ( fSource . getSystemId ( ) != null ) { fSystemId = expandSystemId ( fSource . getSystemId ( ) , baseSystemId ) ; } if ( fSource . getPublicId ( ) != null ) { fPublicId = fSource . getPublicId ( ) ; } } boolean textDecl = false ; try { fReader = fReaderFactory . createReader ( this , fErrorReporter , fSource , fSystemId , textDecl , fStringPool ) ; } catch ( MalformedURLException mu ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( FileNotFoundException fnf ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( UnsupportedEncodingException uee ) { fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; String encoding = uee . getMessage ( ) ; if ( encoding == null ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_REQUIRED , XMLMessages . P81_REQUIRED , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else if ( ! XMLCharacterProperties . validEncName ( encoding ) ) { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_NOT_SUPPORTED , XMLMessages . P81_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } if ( fReader == null || ! checkForTextDecl ) { fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; return false ; } int readerId = fReaderId ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; boolean parseTextDecl = fReader . lookingAtChar ( '<' , false ) ; if ( readerId != fReaderId ) parseTextDecl = false ; return parseTextDecl ; } private void pushNullReader ( ) { ReaderState rs = fReaderStateFreeList ; if ( rs == null ) rs = new ReaderState ( ) ; else fReaderStateFreeList = rs . nextReaderState ; if ( fNullReader == null ) fNullReader = new NullReader ( ) ; rs . reader = fNullReader ; rs . source = null ; rs . entityName = - 1 ; rs . entityType = - 1 ; rs . entityContext = - 1 ; rs . publicId = "Null Entity" ; rs . systemId = fSystemId ; rs . readerId = fNextReaderId ++ ; rs . depth = - 1 ; rs . nextReaderState = null ; fReaderStack . push ( rs ) ; } private void pushReader ( ) { ReaderState rs = fReaderStateFreeList ; if ( rs == null ) rs = new ReaderState ( ) ; else fReaderStateFreeList = rs . nextReaderState ; rs . reader = fReader ; rs . source = fSource ; rs . entityName = fEntityName ; rs . entityType = fEntityType ; rs . entityContext = fEntityContext ; rs . publicId = fPublicId ; rs . systemId = fSystemId ; rs . readerId = fReaderId ; rs . depth = fReaderDepth ; rs . nextReaderState = null ; fReaderStack . push ( rs ) ; } private void popReader ( ) { if ( fReaderStack . empty ( ) ) throw new RuntimeException ( "FWK004 cannot happen 19" + "\n19" ) ; ReaderState rs = ( ReaderState ) fReaderStack . pop ( ) ; fReader = rs . reader ; fSource = rs . source ; fEntityName = rs . entityName ; fEntityType = rs . entityType ; fEntityContext = rs . entityContext ; fPublicId = rs . publicId ; fSystemId = rs . systemId ; fReaderId = rs . readerId ; fReaderDepth = rs . depth ; rs . nextReaderState = fReaderStateFreeList ; fReaderStateFreeList = rs ; } public boolean startEntityDecl ( boolean isPE , int entityName ) throws Exception { if ( ! pushEntity ( isPE , entityName ) ) { int majorCode = isPE ? XMLMessages . MSG_RECURSIVE_PEREFERENCE : XMLMessages . MSG_RECURSIVE_REFERENCE ; Object [ ] args = { fStringPool . toString ( entityName ) , entityReferencePath ( isPE , entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } return true ; } public void endEntityDecl ( ) throws Exception { popEntity ( ) ; } private boolean pushEntity ( boolean isPE , int entityName ) throws Exception { if ( entityName >= 0 ) { for ( int i = 0 ; i < fEntityStackDepth ; i ++ ) { if ( fEntityNameStack [ i ] == entityName && fEntityTypeStack [ i ] == ( isPE ? 1 : 0 ) ) { return false ; } } } if ( fEntityTypeStack == null ) { fEntityTypeStack = new byte [ 8 ] ; fEntityNameStack = new int [ 8 ] ; } else if ( fEntityStackDepth == fEntityTypeStack . length ) { byte [ ] newTypeStack = new byte [ fEntityStackDepth * 2 ] ; System . arraycopy ( fEntityTypeStack , 0 , newTypeStack , 0 , fEntityStackDepth ) ; fEntityTypeStack = newTypeStack ; int [ ] newNameStack = new int [ fEntityStackDepth * 2 ] ; System . arraycopy ( fEntityNameStack , 0 , newNameStack , 0 , fEntityStackDepth ) ; fEntityNameStack = newNameStack ; } fEntityTypeStack [ fEntityStackDepth ] = ( byte ) ( isPE ? 1 : 0 ) ; fEntityNameStack [ fEntityStackDepth ] = entityName ; fEntityStackDepth ++ ; return true ; } private String entityReferencePath ( boolean isPE , int entityName ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "(top-level)" ) ; for ( int i = 0 ; i < fEntityStackDepth ; i ++ ) { if ( fEntityNameStack [ i ] >= 0 ) { sb . append ( '-' ) ; sb . append ( fEntityTypeStack [ i ] == 1 ? '%' : '&' ) ; sb . append ( fStringPool . toString ( fEntityNameStack [ i ] ) ) ; sb . append ( ';' ) ; } } sb . append ( '-' ) ; sb . append ( isPE ? '%' : '&' ) ; sb . append ( fStringPool . toString ( entityName ) ) ; sb . append ( ';' ) ; return sb . toString ( ) ; } private void popEntity ( ) throws Exception { fEntityStackDepth -- ; } public int getReaderId ( ) { return fReaderId ; } public void setReaderDepth ( int depth ) { fReaderDepth = depth ; } public int getReaderDepth ( ) { return fReaderDepth ; } public String getPublicId ( ) { return fPublicId ; } public String getSystemId ( ) { return fSystemId ; } public int getLineNumber ( ) { return fReader == null ? 0 : fReader . getLineNumber ( ) ; } public int getColumnNumber ( ) { return fReader == null ? 0 : fReader . getColumnNumber ( ) ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { fEventHandler . sendEndOfInputNotifications ( fEntityName , fReaderStack . size ( ) > 1 ) ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; popEntity ( ) ; return fReader ; } private final class NullReader implements XMLEntityHandler . EntityReader { public NullReader ( ) { } public int currentOffset ( ) { return - 1 ; } public int getLineNumber ( ) { return - 1 ; } public int getColumnNumber ( ) { return - 1 ; } public void setInCDSect ( boolean inCDSect ) { } public boolean getInCDSect ( ) { return false ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { } public int addString ( int offset , int length ) { return - 1 ; } public int addSymbol ( int offset , int length ) { return - 1 ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) { return false ; } public boolean lookingAtValidChar ( boolean skipPastChar ) { return false ; } public boolean lookingAtSpace ( boolean skipPastChar ) { return false ; } public void skipToChar ( char ch ) { } public void skipPastSpaces ( ) { } public void skipPastName ( char fastcheck ) { } public void skipPastNmtoken ( char fastcheck ) { } public boolean skippedString ( char [ ] s ) { return false ; } public int scanInvalidChar ( ) { return - 1 ; } public int scanCharRef ( boolean hex ) { return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } public int scanStringLiteral ( ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } public int scanAttValue ( char qchar , boolean asSymbol ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } public int scanEntityValue ( int qchar , boolean createString ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) { return false ; } public void scanQName ( char fastcheck , QName qname ) { qname . clear ( ) ; } public int scanName ( char fastcheck ) { return - 1 ; } public int scanContent ( QName element ) throws Exception { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } static final int CHUNK_SHIFT = 5 ; static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; static final int CHUNK_MASK = CHUNK_SIZE - 1 ; static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; public final class EntityPool { private StringPool fStringPool = null ; private XMLErrorReporter fErrorReporter = null ; private int fEntityCount = 0 ; private int [ ] [ ] fName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fValue = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fPublicId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fSystemId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fBaseSystemId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fNotationName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private byte [ ] [ ] fDeclIsExternal = new byte [ INITIAL_CHUNK_COUNT ] [ ] ; private int fNotationListHead = - 1 ; private boolean fCreateStandardEntities = false ; private Vector fRequiredNotations = null ; public EntityPool ( StringPool stringPool , XMLErrorReporter errorReporter , boolean createStandardEntities ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fCreateStandardEntities = createStandardEntities ; if ( fCreateStandardEntities ) { createInternalEntity ( "lt" , "&#60;" ) ; createInternalEntity ( "gt" , ">" ) ; createInternalEntity ( "amp" , "&#38;" ) ; createInternalEntity ( "apos" , "\'" ) ; createInternalEntity ( "quot" , "\"" ) ; } } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fEntityCount = 0 ; fNotationListHead = - 1 ; if ( fRequiredNotations != null ) fRequiredNotations . removeAllElements ( ) ; if ( fCreateStandardEntities ) { createInternalEntity ( "lt" , "&#60;" ) ; createInternalEntity ( "gt" , ">" ) ; createInternalEntity ( "amp" , "&#38;" ) ; createInternalEntity ( "apos" , "\'" ) ; createInternalEntity ( "quot" , "\"" ) ; } } private void createInternalEntity ( String name , String value ) { int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = fStringPool . addSymbol ( name ) ; fValue [ chunk ] [ index ] = fStringPool . addString ( value ) ; fPublicId [ chunk ] [ index ] = - 1 ; fSystemId [ chunk ] [ index ] = - 1 ; fBaseSystemId [ chunk ] [ index ] = - 1 ; fNotationName [ chunk ] [ index ] = - 1 ; fEntityCount ++ ; } private boolean ensureCapacity ( int chunk ) { try { return fName [ chunk ] [ 0 ] == 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { int [ ] [ ] newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fName , 0 , newIntArray , 0 , chunk ) ; fName = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fValue , 0 , newIntArray , 0 , chunk ) ; fValue = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fPublicId , 0 , newIntArray , 0 , chunk ) ; fPublicId = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fSystemId , 0 , newIntArray , 0 , chunk ) ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fBaseSystemId , 0 , newIntArray , 0 , chunk ) ; fBaseSystemId = newIntArray ; fSystemId = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fNotationName , 0 , newIntArray , 0 , chunk ) ; fNotationName = newIntArray ; byte [ ] [ ] newByteArray = new byte [ chunk * 2 ] [ ] ; System . arraycopy ( fDeclIsExternal , 0 , newByteArray , 0 , chunk ) ; fDeclIsExternal = newByteArray ; } catch ( NullPointerException ex ) { } fName [ chunk ] = new int [ CHUNK_SIZE ] ; fValue [ chunk ] = new int [ CHUNK_SIZE ] ; fPublicId [ chunk ] = new int [ CHUNK_SIZE ] ; fSystemId [ chunk ] = new int [ CHUNK_SIZE ] ; fBaseSystemId [ chunk ] = new int [ CHUNK_SIZE ] ; fNotationName [ chunk ] = new int [ CHUNK_SIZE ] ; fDeclIsExternal [ chunk ] = new byte [ CHUNK_SIZE ] ; return true ; } public int addEntityDecl ( int name , int value , int publicId , int systemId , int baseSystemId , int notationName , boolean isExternal ) { int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = name ; fValue [ chunk ] [ index ] = value ; fPublicId [ chunk ] [ index ] = publicId ; fSystemId [ chunk ] [ index ] = systemId ; fBaseSystemId [ chunk ] [ index ] = baseSystemId ; fNotationName [ chunk ] [ index ] = notationName ; fDeclIsExternal [ chunk ] [ index ] = isExternal ? ( byte ) 0x80 : ( byte ) 0 ; int entityIndex = fEntityCount ++ ; return entityIndex ; } public int addNotationDecl ( int notationName , int publicId , int systemId , int baseSystemId , boolean isExternal ) { int nIndex = fNotationListHead ; while ( nIndex != - 1 ) { int chunk = nIndex > > CHUNK_SHIFT ; int index = nIndex & CHUNK_MASK ; if ( fNotationName [ chunk ] [ index ] == notationName ) return - 1 ; nIndex = fValue [ chunk ] [ index ] ; } int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = - 1 ; fValue [ chunk ] [ index ] = fNotationListHead ; fPublicId [ chunk ] [ index ] = publicId ; fSystemId [ chunk ] [ index ] = systemId ; fBaseSystemId [ chunk ] [ index ] = baseSystemId ; fNotationName [ chunk ] [ index ] = notationName ; fDeclIsExternal [ chunk ] [ index ] = isExternal ? ( byte ) 0x80 : ( byte ) 0 ; fNotationListHead = fEntityCount ++ ; return fNotationListHead ; } public int lookupEntity ( int nameIndex ) { if ( nameIndex == - 1 ) return - 1 ; int chunk = 0 ; int index = 0 ; for ( int entityIndex = 0 ; entityIndex < fEntityCount ; entityIndex ++ ) { if ( fName [ chunk ] [ index ] == nameIndex ) return entityIndex ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } return - 1 ; } public boolean isExternalEntity ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fValue [ chunk ] [ index ] == - 1 ) ; } public boolean isUnparsedEntity ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fNotationName [ chunk ] [ index ] != - 1 ) ; } public boolean getEntityDeclIsExternal ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fDeclIsExternal [ chunk ] [ index ] < 0 ) ; } public int getEntityName ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fName [ chunk ] [ index ] ; } public int getEntityValue ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fValue [ chunk ] [ index ] ; } public int getPublicId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fPublicId [ chunk ] [ index ] ; } public int getSystemId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fSystemId [ chunk ] [ index ] ; } public String getBaseSystemId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; int baseIndex = fBaseSystemId [ chunk ] [ index ] ; if ( baseIndex == - 1 ) { return null ; } else { return fStringPool . toString ( baseIndex ) ; } } public boolean isNotationDeclared ( int nameIndex ) { int nIndex = fNotationListHead ; while ( nIndex != - 1 ) { int chunk = nIndex > > CHUNK_SHIFT ; int index = nIndex & CHUNK_MASK ; if ( fNotationName [ chunk ] [ index ] == nameIndex ) return true ; nIndex = fValue [ chunk ] [ index ] ; } return false ; } public boolean getNotationDeclIsExternal ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fDeclIsExternal [ chunk ] [ index ] < 0 ) ; } public int getNotationName ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fNotationName [ chunk ] [ index ] ; } class RequiredNotation { RequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { fNotationName = notationName ; fLocator = new LocatorImpl ( locator ) ; fMajorCode = majorCode ; fMinorCode = minorCode ; fArgs = args ; } int fNotationName ; LocatorImpl fLocator ; int fMajorCode ; int fMinorCode ; Object [ ] fArgs ; } ; public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { if ( fRequiredNotations == null ) fRequiredNotations = new Vector ( ) ; for ( int index = 0 ; index < fRequiredNotations . size ( ) ; index ++ ) { RequiredNotation rn = ( RequiredNotation ) fRequiredNotations . elementAt ( index ) ; if ( rn . fNotationName == notationName ) return ; } fRequiredNotations . addElement ( new RequiredNotation ( notationName , locator , majorCode , minorCode , args ) ) ; } public void checkRequiredNotations ( ) throws Exception { if ( fRequiredNotations == null ) return ; for ( int index = 0 ; index < fRequiredNotations . size ( ) ; index ++ ) { RequiredNotation rn = ( RequiredNotation ) fRequiredNotations . elementAt ( index ) ; if ( ! isNotationDeclared ( rn . fNotationName ) ) { fErrorReporter . reportError ( rn . fLocator , XMLMessages . XML_DOMAIN , rn . fMajorCode , rn . fMinorCode , rn . fArgs , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } 	1
package org . w3c . dom . html ; public interface HTMLTextAreaElement extends HTMLElement { public String getDefaultValue ( ) ; public void setDefaultValue ( String defaultValue ) ; public HTMLFormElement getForm ( ) ; public String getAccessKey ( ) ; public void setAccessKey ( String accessKey ) ; public int getCols ( ) ; public void setCols ( int cols ) ; public boolean getDisabled ( ) ; public void setDisabled ( boolean disabled ) ; public String getName ( ) ; public void setName ( String name ) ; public boolean getReadOnly ( ) ; public void setReadOnly ( boolean readOnly ) ; public int getRows ( ) ; public void setRows ( int rows ) ; public int getTabIndex ( ) ; public void setTabIndex ( int tabIndex ) ; public String getType ( ) ; public String getValue ( ) ; public void setValue ( String value ) ; public void blur ( ) ; public void focus ( ) ; public void select ( ) ; } 	0
package org . w3c . dom ; public interface DOMImplementation { public boolean hasFeature ( String feature , String version ) ; public DocumentType createDocumentType ( String qualifiedName , String publicId , String systemId ) throws DOMException ; public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException ; } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . ImplementationMessages ; public class CMBinOp extends CMNode { public CMBinOp ( int type , CMNode leftNode , CMNode rightNode ) throws CMException { super ( type ) ; if ( ( type ( ) != XMLContentSpec . CONTENTSPECNODE_CHOICE ) && ( type ( ) != XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { throw new CMException ( ImplementationMessages . VAL_BST ) ; } fLeftChild = leftNode ; fRightChild = rightNode ; } final CMNode getLeft ( ) { return fLeftChild ; } final CMNode getRight ( ) { return fRightChild ; } boolean isNullable ( ) throws CMException { if ( type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) return ( fLeftChild . isNullable ( ) || fRightChild . isNullable ( ) ) ; else if ( type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) return ( fLeftChild . isNullable ( ) && fRightChild . isNullable ( ) ) ; else throw new CMException ( ImplementationMessages . VAL_BST ) ; } protected void calcFirstPos ( CMStateSet toSet ) throws CMException { if ( type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) { toSet . setTo ( fLeftChild . firstPos ( ) ) ; toSet . union ( fRightChild . firstPos ( ) ) ; } else if ( type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) { toSet . setTo ( fLeftChild . firstPos ( ) ) ; if ( fLeftChild . isNullable ( ) ) toSet . union ( fRightChild . firstPos ( ) ) ; } else { throw new CMException ( ImplementationMessages . VAL_BST ) ; } } protected void calcLastPos ( CMStateSet toSet ) throws CMException { if ( type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) { toSet . setTo ( fLeftChild . lastPos ( ) ) ; toSet . union ( fRightChild . lastPos ( ) ) ; } else if ( type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) { toSet . setTo ( fRightChild . lastPos ( ) ) ; if ( fRightChild . isNullable ( ) ) toSet . union ( fLeftChild . lastPos ( ) ) ; } else { throw new CMException ( ImplementationMessages . VAL_BST ) ; } } private CMNode fLeftChild ; private CMNode fRightChild ; } ; 	0
package org . apache . xerces . utils ; import java . lang . * ; public final class HexBin { static private final int BASELENGTH = 255 ; static private final int LOOKUPLENGTH = 16 ; static private byte [ ] hexNumberTable = new byte [ BASELENGTH ] ; static private byte [ ] lookUpHexAlphabet = new byte [ LOOKUPLENGTH ] ; static { for ( int i = 0 ; i < BASELENGTH ; i ++ ) { hexNumberTable [ i ] = - 1 ; } for ( int i = '9' ; i >= '0' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - '0' ) ; } for ( int i = 'F' ; i >= 'A' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - 'A' + 10 ) ; } for ( int i = 'f' ; i >= 'a' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - 'a' + 10 ) ; } for ( int i = 0 ; i <= 25 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( 'A' + i ) ; for ( int i = 0 ; i < 10 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( '0' + i ) ; for ( int i = 10 ; i <= 15 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( 'A' + i - 10 ) ; } static boolean isHex ( byte octect ) { return ( hexNumberTable [ octect ] != - 1 ) ; } static boolean isArrayByteHex ( byte [ ] arrayOctect ) { int length = arrayOctect . length ; if ( length == 0 ) return false ; for ( int i = 0 ; i < length ; i ++ ) { if ( HexBin . isHex ( arrayOctect [ i ] ) == false ) return false ; } return true ; } public static boolean isHex ( String isValidString ) { return ( isArrayByteHex ( isValidString . getBytes ( ) ) ) ; } static public byte [ ] encode ( byte [ ] binaryData ) { int lengthData = binaryData . length ; int lengthEncode = lengthData ; byte [ ] encodedData = new byte [ lengthData ] ; for ( int i = 0 ; i < lengthData ; i ++ ) { encodedData [ i ] = lookUpHexAlphabet [ binaryData [ i ] ] ; } return encodedData ; } static public byte [ ] decode ( byte [ ] binaryData ) { int lengthData = binaryData . length ; int lengthEncode = lengthData ; byte [ ] decodedData = new byte [ lengthData ] ; for ( int i = 0 ; i < lengthData ; i ++ ) { decodedData [ i ] = hexNumberTable [ binaryData [ i ] ] ; } return decodedData ; } } 	1
package org . apache . wml ; public interface WMLPostfieldElement extends WMLElement { public void setValue ( String newValue ) ; public String getValue ( ) ; public void setName ( String newValue ) ; public String getName ( ) ; } 	0
package org . w3c . dom ; public interface EntityReference extends Node { } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DeferredCommentImpl extends CommentImpl implements DeferredNode { static final long serialVersionUID = 6498796371083589338L ; protected transient int fNodeIndex ; DeferredCommentImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; } public int getNodeIndex ( ) { return fNodeIndex ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ( ) ; data = ownerDocument . getNodeValueString ( fNodeIndex ) ; } } 	0
package org . w3c . dom ; public interface Attr extends Node { public String getName ( ) ; public boolean getSpecified ( ) ; public String getValue ( ) ; public void setValue ( String value ) throws DOMException ; public Element getOwnerElement ( ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLMetaElementImpl extends HTMLElementImpl implements HTMLMetaElement { public String getContent ( ) { return getAttribute ( "content" ) ; } public void setContent ( String content ) { setAttribute ( "content" , content ) ; } public String getHttpEquiv ( ) { return getAttribute ( "http-equiv" ) ; } public void setHttpEquiv ( String httpEquiv ) { setAttribute ( "http-equiv" , httpEquiv ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public String getScheme ( ) { return getAttribute ( "scheme" ) ; } public void setScheme ( String scheme ) { setAttribute ( "scheme" , scheme ) ; } public HTMLMetaElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . DOMException ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . CharacterData ; import org . apache . xerces . dom . DOMExceptionImpl ; import org . apache . xerces . dom . DocumentImpl ; import org . w3c . dom . range . * ; import java . util . Vector ; public class RangeImpl implements Range { static final int START = 0 ; static final int AFTER = 1 ; static final int BEFORE = - 1 ; DocumentImpl fDocument ; Node fStartContainer ; Node fEndContainer ; int fStartOffset ; int fEndOffset ; boolean fIsCollapsed ; boolean fDetach = false ; Node fInsertNode = null ; Node fDeleteNode = null ; Node fSplitNode = null ; public RangeImpl ( DocumentImpl document ) { fDocument = document ; fStartContainer = document ; fEndContainer = document ; fStartOffset = 0 ; fEndOffset = 0 ; fDetach = false ; } public Node getStartContainer ( ) { return fStartContainer ; } public int getStartOffset ( ) { return fStartOffset ; } public Node getEndContainer ( ) { return fEndContainer ; } public int getEndOffset ( ) { return fEndOffset ; } public boolean getCollapsed ( ) { return ( fStartContainer == fEndContainer && fStartOffset == fEndOffset ) ; } public Node getCommonAncestorContainer ( ) { Vector startV = new Vector ( ) ; Node node ; for ( node = fStartContainer ; node != null ; node = node . getParentNode ( ) ) { startV . addElement ( node ) ; } Vector endV = new Vector ( ) ; for ( node = fEndContainer ; node != null ; node = node . getParentNode ( ) ) { endV . addElement ( node ) ; } int s = startV . size ( ) - 1 ; int e = endV . size ( ) - 1 ; Object result = null ; while ( s >= 0 && e >= 0 ) { if ( startV . elementAt ( s ) == endV . elementAt ( e ) ) { result = startV . elementAt ( s ) ; } else { break ; } -- s ; -- e ; } return ( Node ) result ; } public void setStart ( Node refNode , int offset ) throws RangeException , DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } checkIndex ( refNode , offset ) ; fStartContainer = refNode ; fStartOffset = offset ; } public void setEnd ( Node refNode , int offset ) throws RangeException , DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } checkIndex ( refNode , offset ) ; fEndContainer = refNode ; fEndOffset = offset ; } public void setStartBefore ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i - 1 ; } public void setStartAfter ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i ; } public void setEndBefore ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fEndContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fEndOffset = i - 1 ; } public void setEndAfter ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fEndContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fEndOffset = i ; } public void collapse ( boolean toStart ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( toStart ) { fEndContainer = fStartContainer ; fEndOffset = fStartOffset ; } else { fStartContainer = fEndContainer ; fStartOffset = fEndOffset ; } } public void selectNode ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } Node parent = refNode . getParentNode ( ) ; if ( parent != null ) { fStartContainer = parent ; fEndContainer = parent ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i - 1 ; fEndOffset = fStartOffset + 1 ; } } public void selectNodeContents ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode ; fEndContainer = refNode ; Node first = refNode . getFirstChild ( ) ; fStartOffset = 0 ; if ( first == null ) { fEndOffset = 0 ; } else { int i = 0 ; for ( Node n = first ; n != null ; n = n . getNextSibling ( ) ) { i ++ ; } fEndOffset = i ; } } public short compareBoundaryPoints ( short how , Range sourceRange ) throws DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Node endPointA ; Node endPointB ; int offsetA ; int offsetB ; if ( how == START_TO_START ) { endPointA = sourceRange . getStartContainer ( ) ; endPointB = fStartContainer ; offsetA = sourceRange . getStartOffset ( ) ; offsetB = fStartOffset ; } else if ( how == START_TO_END ) { endPointA = sourceRange . getStartContainer ( ) ; endPointB = fEndContainer ; offsetA = sourceRange . getStartOffset ( ) ; offsetB = fEndOffset ; } else if ( how == END_TO_START ) { endPointA = sourceRange . getEndContainer ( ) ; endPointB = fStartContainer ; offsetA = sourceRange . getEndOffset ( ) ; offsetB = fStartOffset ; } else { endPointA = sourceRange . getEndContainer ( ) ; endPointB = fEndContainer ; offsetA = sourceRange . getEndOffset ( ) ; offsetB = fEndOffset ; } if ( endPointA == endPointB ) { if ( offsetA < offsetB ) return - 1 ; if ( offsetA == offsetB ) return 0 ; return 1 ; } for ( Node node = endPointA . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { if ( isAncestorOf ( node , endPointB ) ) { int index = indexOf ( node , endPointA ) ; if ( offsetA < index ) return - 1 ; if ( offsetA == index ) return 0 ; return 1 ; } } for ( Node node = endPointB . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { if ( isAncestorOf ( node , endPointA ) ) { int index = indexOf ( node , endPointB ) ; if ( offsetB < index ) return - 1 ; if ( offsetB == index ) return 0 ; return 1 ; } } Node ancestor = getCommonAncestorContainer ( ) ; Node current = ancestor ; do { if ( current == endPointA ) return - 1 ; if ( current == endPointB ) return 1 ; current = nextNode ( current , true ) ; } while ( current != null && current != ancestor ) ; return - 2 ; } public void deleteContents ( ) throws DOMException { Node current = fStartContainer ; Node parent = null ; Node next ; boolean deleteCurrent = false ; Node root = getCommonAncestorContainer ( ) ; if ( fStartContainer == fEndContainer ) { if ( fStartOffset == fEndOffset ) { return ; } if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { String value = fStartContainer . getNodeValue ( ) ; int realStart = fStartOffset ; int realEnd = fEndOffset ; if ( fStartOffset > value . length ( ) ) realStart = value . length ( ) - 1 ; if ( fEndOffset > value . length ( ) ) realEnd = value . length ( ) - 1 ; deleteData ( ( CharacterData ) fStartContainer , realStart , realEnd - realStart ) ; } else { current = fStartContainer . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } for ( i = 0 ; i < fEndOffset - fStartOffset && current != null ; i ++ ) { Node newCurrent = current . getNextSibling ( ) ; removeChild ( fStartContainer , current ) ; current = newCurrent ; } } collapse ( true ) ; return ; } Node partialNode = null ; int partialInt = START ; Node startRoot = null ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { deleteData ( ( CharacterData ) current , fStartOffset , current . getNodeValue ( ) . length ( ) - fStartOffset ) ; } else { current = current . getFirstChild ( ) ; for ( int i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fStartContainer ; } else if ( current != fStartContainer ) { deleteCurrent = true ; } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { if ( startRoot == null ) startRoot = current ; } else { if ( partialNode == null ) { partialNode = parent ; partialInt = AFTER ; } } if ( parent != root ) { next = current . getNextSibling ( ) ; Node nextnext ; while ( next != null ) { nextnext = next . getNextSibling ( ) ; removeChild ( parent , next ) ; next = nextnext ; } } if ( deleteCurrent ) { removeChild ( parent , current ) ; deleteCurrent = false ; } current = parent ; } Node endRoot = null ; current = fEndContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { deleteData ( ( CharacterData ) current , 0 , fEndOffset ) ; } else { if ( fEndOffset == 0 ) { current = fEndContainer ; } else { current = current . getFirstChild ( ) ; for ( int i = 1 ; i < fEndOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fEndContainer . getLastChild ( ) ; } else if ( current != fStartContainer ) { deleteCurrent = true ; } } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { if ( endRoot == null ) endRoot = current ; } else { if ( partialNode == null ) { partialNode = parent ; partialInt = BEFORE ; } } if ( parent != root && parent != null ) { next = current . getPreviousSibling ( ) ; Node nextnext ; while ( next != null ) { nextnext = next . getPreviousSibling ( ) ; removeChild ( parent , next ) ; next = nextnext ; } } if ( deleteCurrent ) { removeChild ( parent , current ) ; deleteCurrent = false ; } current = parent ; } current = endRoot . getPreviousSibling ( ) ; Node prev = null ; while ( current != null && current != startRoot ) { prev = current . getPreviousSibling ( ) ; parent = current . getParentNode ( ) ; if ( parent != null ) { removeChild ( parent , current ) ; } current = prev ; } if ( partialNode == null ) { collapse ( true ) ; } else if ( partialInt == AFTER ) { setStartAfter ( partialNode ) ; setEndAfter ( partialNode ) ; } else if ( partialInt == BEFORE ) { setStartBefore ( partialNode ) ; setEndBefore ( partialNode ) ; } } public DocumentFragment extractContents ( ) throws DOMException { return traverseContents ( EXTRACT_CONTENTS ) ; } public DocumentFragment cloneContents ( ) throws DOMException { return traverseContents ( CLONE_CONTENTS ) ; } public void insertNode ( Node newNode ) throws DOMException , RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } int type = newNode . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_NODE || type == Node . DOCUMENT_FRAGMENT_NODE ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } if ( newNode == null ) return ; Node cloneCurrent ; Node current ; boolean MULTIPLE_MODE = false ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( newNode . getNodeType ( ) != Node . TEXT_NODE ) { cloneCurrent = fStartContainer . cloneNode ( false ) ; ( ( TextImpl ) cloneCurrent ) . setNodeValueInternal ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset ) ) ; ( ( TextImpl ) fStartContainer ) . setNodeValueInternal ( ( fStartContainer . getNodeValue ( ) ) . substring ( 0 , fStartOffset ) ) ; Node next = fStartContainer . getNextSibling ( ) ; if ( next != null ) { Node parent = fStartContainer . getParentNode ( ) ; if ( parent != null ) { parent . insertBefore ( newNode , next ) ; parent . insertBefore ( cloneCurrent , next ) ; } } else { Node parent = fStartContainer . getParentNode ( ) ; if ( parent != null ) { parent . appendChild ( newNode ) ; parent . appendChild ( cloneCurrent ) ; } } signalSplitData ( fStartContainer , cloneCurrent , fStartOffset ) ; } else { String value = fStartContainer . getNodeValue ( ) ; String newValue = newNode . getNodeValue ( ) ; insertData ( ( CharacterData ) fStartContainer , fStartOffset , newValue ) ; } } else { current = fStartContainer . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current != null ) { fStartContainer . insertBefore ( newNode , current ) ; } else { fStartContainer . appendChild ( newNode ) ; } } } public void surroundContents ( Node newParent ) throws DOMException , RangeException { if ( newParent == null ) return ; if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } int type = newParent . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_TYPE_NODE || type == Node . DOCUMENT_NODE || type == Node . DOCUMENT_FRAGMENT_NODE ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } Node root = getCommonAncestorContainer ( ) ; Node realStart = fStartContainer ; Node realEnd = fEndContainer ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { realStart = fStartContainer . getParentNode ( ) ; } if ( fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { realEnd = fEndContainer . getParentNode ( ) ; } if ( realStart != realEnd ) { throw new RangeExceptionImpl ( RangeException . BAD_BOUNDARYPOINTS_ERR , "DOM013 Bad boundary points" ) ; } DocumentFragment frag = extractContents ( ) ; insertNode ( newParent ) ; newParent . appendChild ( frag ) ; selectNode ( newParent ) ; } public Range cloneRange ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Range range = fDocument . createRange ( ) ; range . setStart ( fStartContainer , fStartOffset ) ; range . setEnd ( fEndContainer , fEndOffset ) ; return range ; } public String toString ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Node node = fStartContainer ; StringBuffer sb = new StringBuffer ( ) ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE || fStartContainer . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { if ( fStartContainer == fEndContainer ) { sb . append ( fStartContainer . getNodeValue ( ) . substring ( fStartOffset , fEndOffset ) ) ; return sb . toString ( ) ; } else { sb . append ( fStartContainer . getNodeValue ( ) . substring ( fStartOffset ) ) ; } } while ( node != fEndContainer ) { node = nextNode ( node , true ) ; if ( node == null ) break ; if ( node . getNodeType ( ) == Node . TEXT_NODE || node . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { sb . append ( node . getNodeValue ( ) ) ; } } if ( fEndContainer . getNodeType ( ) == Node . TEXT_NODE || fEndContainer . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { sb . append ( fEndContainer . getNodeValue ( ) . substring ( 0 , fEndOffset ) ) ; } return sb . toString ( ) ; } public void detach ( ) { fDetach = true ; fDocument . removeRange ( this ) ; } void signalSplitData ( Node node , Node newNode , int offset ) { fSplitNode = node ; fDocument . splitData ( node , newNode , offset ) ; fSplitNode = null ; } void receiveSplitData ( Node node , Node newNode , int offset ) { if ( node == null || newNode == null ) return ; if ( fSplitNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fStartOffset > offset ) { fStartOffset = fStartOffset - offset ; fStartContainer = newNode ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fEndOffset > offset ) { fEndOffset = fEndOffset - offset ; fEndContainer = newNode ; } } } void deleteData ( CharacterData node , int offset , int count ) { fDeleteNode = node ; node . deleteData ( offset , count ) ; fDeleteNode = null ; } void receiveDeletedText ( Node node , int offset , int count ) { if ( node == null ) return ; if ( fDeleteNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fStartOffset > offset + count ) { fStartOffset = offset + ( fStartOffset - ( offset + count ) ) ; } else if ( fStartOffset > offset ) { fStartOffset = offset ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fEndOffset > offset + count ) { fEndOffset = offset + ( fEndOffset - ( offset + count ) ) ; } else if ( fEndOffset > offset ) { fEndOffset = offset ; } } } void insertData ( CharacterData node , int index , String insert ) { fInsertNode = node ; node . insertData ( index , insert ) ; fInsertNode = null ; } void receiveInsertedText ( Node node , int index , int len ) { if ( node == null ) return ; if ( fInsertNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( index < fStartOffset ) { fStartOffset = fStartOffset + len ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( index < fEndOffset ) { fEndOffset = fEndOffset + len ; } } } void receiveReplacedText ( Node node ) { if ( node == null ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { fStartOffset = 0 ; } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { fEndOffset = 0 ; } } public void insertedNodeFromDOM ( Node node ) { if ( node == null ) return ; if ( fInsertNode == node ) return ; Node parent = node . getParentNode ( ) ; if ( parent == fStartContainer ) { int index = indexOf ( node , fStartContainer ) ; if ( index < fStartOffset ) { fStartOffset ++ ; } } if ( parent == fEndContainer ) { int index = indexOf ( node , fEndContainer ) ; if ( index < fEndOffset ) { fEndOffset ++ ; } } } Node fRemoveChild = null ; Node removeChild ( Node parent , Node child ) { fRemoveChild = child ; Node n = parent . removeChild ( child ) ; fRemoveChild = null ; return n ; } void removeNode ( Node node ) { if ( node == null ) return ; if ( fRemoveChild == node ) return ; Node parent = node . getParentNode ( ) ; if ( parent == fStartContainer ) { int index = indexOf ( node , fStartContainer ) ; if ( index <= fStartOffset ) { fStartOffset -- ; } } if ( parent == fEndContainer ) { int index = indexOf ( node , fEndContainer ) ; if ( index < fEndOffset ) { fEndOffset -- ; } } if ( parent != fStartContainer && parent != fEndContainer ) { if ( isAncestorOf ( node , fStartContainer ) ) { fStartContainer = parent ; fStartOffset = indexOf ( node , parent ) - 1 ; } if ( isAncestorOf ( node , fEndContainer ) ) { fEndContainer = parent ; fEndOffset = indexOf ( node , parent ) - 1 ; } } } static final int EXTRACT_CONTENTS = 1 ; static final int CLONE_CONTENTS = 2 ; DocumentFragment traverseContents ( int traversalType ) throws DOMException { if ( fStartContainer == null || fEndContainer == null ) { return null ; } DocumentFragment frag = fDocument . createDocumentFragment ( ) ; Node current = fStartContainer ; Node cloneCurrent = null ; Node cloneParent = null ; Node partialNode = null ; int partialInt = START ; Vector d = new Vector ( ) ; if ( fStartContainer == fEndContainer ) { if ( fStartOffset == fEndOffset ) { return frag ; } if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = fStartContainer . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset , fEndOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , fStartOffset , fEndOffset - fStartOffset ) ; } frag . appendChild ( cloneCurrent ) ; } else { current = current . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } int n = fEndOffset - fStartOffset ; for ( i = 0 ; i < n && current != null ; i ++ ) { Node newCurrent = current . getNextSibling ( ) ; if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; frag . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { frag . appendChild ( current ) ; } current = newCurrent ; } } return frag ; } Node root = getCommonAncestorContainer ( ) ; Node parent = null ; current = fStartContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = current . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , fStartOffset , current . getNodeValue ( ) . length ( ) - fStartOffset ) ; } } else { current = current . getFirstChild ( ) ; for ( int i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fStartContainer ; } if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } } Node startRoot = null ; parent = null ; while ( current != root ) { parent = current . getParentNode ( ) ; if ( parent == root ) { cloneParent = frag ; startRoot = current ; } else { if ( parent == null ) System . out . println ( "parent==null: current=" + current ) ; cloneParent = parent . cloneNode ( false ) ; if ( partialNode == null && parent != root ) { partialNode = parent ; partialInt = AFTER ; } } Node next = null ; current = current . getNextSibling ( ) ; cloneParent . appendChild ( cloneCurrent ) ; while ( current != null ) { next = current . getNextSibling ( ) ; if ( current != null && parent != root ) { if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; cloneParent . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneParent . appendChild ( current ) ; } } current = next ; } current = parent ; cloneCurrent = cloneParent ; } Node endRoot = null ; current = fEndContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = current . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( 0 , fEndOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , 0 , fEndOffset ) ; } } else { if ( fEndOffset == 0 ) { current = fEndContainer ; } else { current = current . getFirstChild ( ) ; for ( int i = 1 ; i < fEndOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fEndContainer . getLastChild ( ) ; } } if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { cloneParent = frag ; endRoot = current ; } else { cloneParent = parent . cloneNode ( false ) ; if ( partialNode == null && parent != root ) { partialNode = parent ; partialInt = BEFORE ; } } Node holdCurrent = current ; current = parent . getFirstChild ( ) ; cloneParent . appendChild ( cloneCurrent ) ; Node next = null ; while ( current != holdCurrent && current != null ) { next = current . getNextSibling ( ) ; if ( current != null && parent != root ) { if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; cloneParent . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneParent . appendChild ( current ) ; } } current = next ; } current = parent ; cloneCurrent = cloneParent ; } d . removeAllElements ( ) ; Node clonedPrevious = frag . getLastChild ( ) ; current = endRoot . getPreviousSibling ( ) ; Node prev = null ; while ( current != startRoot && current != null ) { prev = current . getPreviousSibling ( ) ; if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } frag . insertBefore ( cloneCurrent , clonedPrevious ) ; current = prev ; clonedPrevious = cloneCurrent ; } if ( traversalType == EXTRACT_CONTENTS ) { if ( partialNode == null ) { collapse ( true ) ; } else if ( partialInt == AFTER ) { setStartAfter ( partialNode ) ; setEndAfter ( partialNode ) ; } else if ( partialInt == BEFORE ) { setStartBefore ( partialNode ) ; setEndBefore ( partialNode ) ; } } return frag ; } void checkIndex ( Node refNode , int offset ) throws DOMException { if ( offset < 0 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } int type = refNode . getNodeType ( ) ; if ( ( type == Node . TEXT_NODE || type == Node . CDATA_SECTION_NODE || type == Node . COMMENT_NODE || type == Node . PROCESSING_INSTRUCTION_NODE ) && offset > refNode . getNodeValue ( ) . length ( ) ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } Node child = refNode . getFirstChild ( ) ; int i = 1 ; for ( ; child != null ; i ++ ) { child = child . getNextSibling ( ) ; } if ( i > offset ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } boolean isAncestorTypeValid ( Node node ) { for ( Node n = node ; n != null ; n = n . getParentNode ( ) ) { int type = n . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_TYPE_NODE ) return false ; } return true ; } Node nextNode ( Node node , boolean visitChildren ) { if ( node == null ) return null ; Node result ; if ( visitChildren ) { result = node . getFirstChild ( ) ; if ( result != null ) { return result ; } } result = node . getNextSibling ( ) ; if ( result != null ) { return result ; } Node parent = node . getParentNode ( ) ; while ( parent != null && parent != fDocument ) { result = parent . getNextSibling ( ) ; if ( result != null ) { return result ; } else { parent = parent . getParentNode ( ) ; } } return null ; } boolean isAncestorOf ( Node a , Node b ) { for ( Node node = b ; node != null ; node = node . getParentNode ( ) ) { if ( node == a ) return true ; } return false ; } int indexOf ( Node child , Node parent ) { Node node ; int i = 0 ; if ( child . getParentNode ( ) != parent ) return - 1 ; for ( node = child ; node != null ; node = node . getPreviousSibling ( ) ) { i ++ ; } return i ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLInputElementImpl extends HTMLElementImpl implements HTMLInputElement , HTMLFormControl { public String getDefaultValue ( ) { return getAttribute ( "defaultValue" ) ; } public void setDefaultValue ( String defaultValue ) { setAttribute ( "defaultValue" , defaultValue ) ; } public boolean getDefaultChecked ( ) { return getBinary ( "defaultChecked" ) ; } public void setDefaultChecked ( boolean defaultChecked ) { setAttribute ( "defaultChecked" , defaultChecked ) ; } public String getAccept ( ) { return getAttribute ( "accept" ) ; } public void setAccept ( String accept ) { setAttribute ( "accept" , accept ) ; } public String getAccessKey ( ) { String accessKey ; accessKey = getAttribute ( "accesskey" ) ; if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; return accessKey ; } public void setAccessKey ( String accessKey ) { if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; setAttribute ( "accesskey" , accessKey ) ; } public String getAlign ( ) { return capitalize ( getAttribute ( "align" ) ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public String getAlt ( ) { return getAttribute ( "alt" ) ; } public void setAlt ( String alt ) { setAttribute ( "alt" , alt ) ; } public boolean getChecked ( ) { return getBinary ( "checked" ) ; } public void setChecked ( boolean checked ) { setAttribute ( "checked" , checked ) ; } public boolean getDisabled ( ) { return getBinary ( "disabled" ) ; } public void setDisabled ( boolean disabled ) { setAttribute ( "disabled" , disabled ) ; } public int getMaxLength ( ) { return getInteger ( getAttribute ( "maxlength" ) ) ; } public void setMaxLength ( int maxLength ) { setAttribute ( "maxlength" , String . valueOf ( maxLength ) ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public boolean getReadOnly ( ) { return getBinary ( "readonly" ) ; } public void setReadOnly ( boolean readOnly ) { setAttribute ( "readonly" , readOnly ) ; } public String getSize ( ) { return getAttribute ( "size" ) ; } public void setSize ( String size ) { setAttribute ( "size" , size ) ; } public String getSrc ( ) { return getAttribute ( "src" ) ; } public void setSrc ( String src ) { setAttribute ( "src" , src ) ; } public int getTabIndex ( ) { try { return Integer . parseInt ( getAttribute ( "tabindex" ) ) ; } catch ( NumberFormatException except ) { return 0 ; } } public void setTabIndex ( int tabIndex ) { setAttribute ( "tabindex" , String . valueOf ( tabIndex ) ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } public String getUseMap ( ) { return getAttribute ( "useMap" ) ; } public void setUseMap ( String useMap ) { setAttribute ( "useMap" , useMap ) ; } public String getValue ( ) { return getAttribute ( "value" ) ; } public void setValue ( String value ) { setAttribute ( "value" , value ) ; } public void blur ( ) { } public void focus ( ) { } public void select ( ) { } public void click ( ) { } public HTMLInputElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . jaxp ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xerces . parsers . SAXParser ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public class SAXParserImpl extends javax . xml . parsers . SAXParser { private boolean namespaces = false ; private boolean validation = false ; private Parser parser = null ; private SAXParserImpl ( ) { super ( ) ; } protected SAXParserImpl ( boolean namespaces , boolean validation ) throws ParserConfigurationException { this ( ) ; SAXParser p = new SAXParser ( ) ; try { p . setFeature ( "http://xml.org/sax/features/namespaces" , namespaces ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set namespace " + "awareness to " + namespaces ) ; } try { p . setFeature ( "http://xml.org/sax/features/validation" , validation ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set validation to " + validation ) ; } this . namespaces = namespaces ; this . validation = validation ; this . parser = p ; } public Parser getParser ( ) { return ( this . parser ) ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLInputElementImpl extends WMLElementImpl implements WMLInputElement { public WMLInputElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setSize ( int newValue ) { setAttribute ( "size" , newValue ) ; } public int getSize ( ) { return getAttribute ( "size" , 0 ) ; } public void setFormat ( String newValue ) { setAttribute ( "format" , newValue ) ; } public String getFormat ( ) { return getAttribute ( "format" ) ; } public void setValue ( String newValue ) { setAttribute ( "value" , newValue ) ; } public String getValue ( ) { return getAttribute ( "value" ) ; } public void setMaxLength ( int newValue ) { setAttribute ( "maxlength" , newValue ) ; } public int getMaxLength ( ) { return getAttribute ( "maxlength" , 0 ) ; } public void setTabIndex ( int newValue ) { setAttribute ( "tabindex" , newValue ) ; } public int getTabIndex ( ) { return getAttribute ( "tabindex" , 0 ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setEmptyOk ( boolean newValue ) { setAttribute ( "emptyok" , newValue ) ; } public boolean getEmptyOk ( ) { return getAttribute ( "emptyok" , false ) ; } public void setTitle ( String newValue ) { setAttribute ( "title" , newValue ) ; } public String getTitle ( ) { return getAttribute ( "title" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setType ( String newValue ) { setAttribute ( "type" , newValue ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } public void setName ( String newValue ) { setAttribute ( "name" , newValue ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } } 	0
package javax . xml . parsers ; import org . xml . sax . SAXException ; public abstract class SAXParserFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.SAXParserFactory" ; private static String factory = "org.apache.xerces.jaxp.SAXParserFactoryImpl" ; protected SAXParserFactory ( ) { super ( ) ; } public static SAXParserFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( SAXParserFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "SAXParserFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified SAXParserFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "SAXParserFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"javax.xml.parsers.SAXParserFactory\"" ) ; } } public abstract SAXParser newSAXParser ( ) throws ParserConfigurationException , SAXException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLHeadElementImpl extends WMLElementImpl implements WMLHeadElement { public WMLHeadElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . apache . xerces . framework ; public class Version { public static String fVersion = "Xerces 1.2.0" ; public static void main ( String argv [ ] ) { System . out . println ( fVersion ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLSelectElementImpl extends HTMLElementImpl implements HTMLSelectElement , HTMLFormControl { public String getType ( ) { return getAttribute ( "type" ) ; } public String getValue ( ) { return getAttribute ( "value" ) ; } public void setValue ( String value ) { setAttribute ( "value" , value ) ; } public int getSelectedIndex ( ) { NodeList options ; int i ; options = getElementsByTagName ( "OPTION" ) ; for ( i = 0 ; i < options . getLength ( ) ; ++ i ) if ( ( ( HTMLOptionElement ) options . item ( i ) ) . getSelected ( ) ) return i ; return - 1 ; } public void setSelectedIndex ( int selectedIndex ) { NodeList options ; int i ; options = getElementsByTagName ( "OPTION" ) ; for ( i = 0 ; i < options . getLength ( ) ; ++ i ) ( ( HTMLOptionElementImpl ) options . item ( i ) ) . setSelected ( i == selectedIndex ) ; } public HTMLCollection getOptions ( ) { if ( _options == null ) _options = new HTMLCollectionImpl ( this , HTMLCollectionImpl . OPTION ) ; return _options ; } public int getLength ( ) { return getOptions ( ) . getLength ( ) ; } public boolean getDisabled ( ) { return getBinary ( "disabled" ) ; } public void setDisabled ( boolean disabled ) { setAttribute ( "disabled" , disabled ) ; } public boolean getMultiple ( ) { return getBinary ( "multiple" ) ; } public void setMultiple ( boolean multiple ) { setAttribute ( "multiple" , multiple ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public int getSize ( ) { return getInteger ( getAttribute ( "size" ) ) ; } public void setSize ( int size ) { setAttribute ( "size" , String . valueOf ( size ) ) ; } public int getTabIndex ( ) { return getInteger ( getAttribute ( "tabindex" ) ) ; } public void setTabIndex ( int tabIndex ) { setAttribute ( "tabindex" , String . valueOf ( tabIndex ) ) ; } public void add ( HTMLElement element , HTMLElement before ) { insertBefore ( element , before ) ; } public void remove ( int index ) { NodeList options ; Node removed ; options = getElementsByTagName ( "OPTION" ) ; removed = options . item ( index ) ; if ( removed != null ) removed . getParentNode ( ) . removeChild ( removed ) ; } public void blur ( ) { } public void focus ( ) { } public HTMLSelectElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } private HTMLCollection _options ; } 	0
package org . w3c . dom ; public interface CDATASection extends Text { } 	1
package org . apache . wml ; public interface WMLInputElement extends WMLElement { public void setName ( String newValue ) ; public String getName ( ) ; public void setValue ( String newValue ) ; public String getValue ( ) ; public void setType ( String newValue ) ; public String getType ( ) ; public void setFormat ( String newValue ) ; public String getFormat ( ) ; public void setEmptyOk ( boolean newValue ) ; public boolean getEmptyOk ( ) ; public void setSize ( int newValue ) ; public int getSize ( ) ; public void setMaxLength ( int newValue ) ; public int getMaxLength ( ) ; public void setTitle ( String newValue ) ; public String getTitle ( ) ; public void setTabIndex ( int newValue ) ; public int getTabIndex ( ) ; public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . validators . schema . EquivClassComparator ; public class DFAContentModel implements XMLContentModel { private static final int EPSILON = - 2 ; private static final int EOC = - 3 ; private static final boolean DEBUG_VALIDATE_CONTENT = false ; private EquivClassComparator comparator = null ; private QName fElemMap [ ] = null ; private int fElemMapType [ ] = null ; private int fElemMapSize = 0 ; private boolean fDTD ; private int fEOCIndex = 0 ; private int fEOCPos = 0 ; private int fEpsilonIndex = 0 ; private boolean fFinalStateFlags [ ] = null ; private CMStateSet fFollowList [ ] = null ; private CMNode fHeadNode = null ; private int fLeafCount = 0 ; private CMLeaf fLeafList [ ] = null ; private int fLeafListType [ ] = null ; private ContentLeafNameTypeVector fLeafNameTypeVector = null ; private int fTransTable [ ] [ ] = null ; private int fTransTableSize = 0 ; private boolean fEmptyContentIsValid = false ; private QName fQName = new QName ( ) ; public DFAContentModel ( CMNode syntaxTree , int leafCount ) throws CMException { this ( syntaxTree , leafCount , false ) ; } public DFAContentModel ( CMNode syntaxTree , int leafCount , boolean dtd ) throws CMException { fLeafCount = leafCount ; fEpsilonIndex = EPSILON ; fEOCIndex = EOC ; fDTD = dtd ; buildDFA ( syntaxTree ) ; } public int validateContent ( QName children [ ] , int offset , int length ) throws CMException { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "DFAContentModel#validateContent" ) ; if ( length == 0 ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! no children" ) ; System . out . println ( "elemMap=" + fElemMap ) ; for ( int i = 0 ; i < fElemMap . length ; i ++ ) { int uriIndex = fElemMap [ i ] . uri ; int localpartIndex = fElemMap [ i ] . localpart ; } System . out . println ( "EOCIndex=" + fEOCIndex ) ; } return fEmptyContentIsValid ? - 1 : 0 ; } int curState = 0 ; for ( int childIndex = 0 ; childIndex < length ; childIndex ++ ) { final QName curElem = children [ offset + childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { int type = fElemMapType [ elemIndex ] & 0x0f ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fDTD ) { if ( fElemMap [ elemIndex ] . rawname == curElem . rawname ) { break ; } } else { if ( fElemMap [ elemIndex ] . uri == curElem . uri && fElemMap [ elemIndex ] . localpart == curElem . localpart ) break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ elemIndex ] . uri ; if ( uri == - 1 || uri == curElem . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( curElem . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ elemIndex ] . uri != curElem . uri ) { break ; } } } if ( elemIndex == fElemMapSize ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! didn't find it" ) ; System . out . println ( "curElem : " + curElem ) ; for ( int i = 0 ; i < fElemMapSize ; i ++ ) { System . out . println ( "fElemMap[" + i + "] = " + fElemMap [ i ] ) ; System . out . println ( "fElemMapType[" + i + "] = " + fElemMapType [ i ] ) ; } } return childIndex ; } curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "!!! not a legal transition" ) ; return childIndex ; } } if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "curState=" + curState + ", childCount=" + length ) ; if ( ! fFinalStateFlags [ curState ] ) return length ; return - 1 ; } private boolean isEqual ( QName name1 , QName name2 ) { return name1 . localpart == name2 . localpart && name1 . uri == name2 . uri ; } public int validateContentSpecial ( QName children [ ] , int offset , int length ) throws Exception { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "DFAContentModel#validateContentSpecial" ) ; if ( comparator == null ) { return validateContent ( children , offset , length ) ; } if ( length == 0 ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! no children" ) ; System . out . println ( "elemMap=" + fElemMap ) ; for ( int i = 0 ; i < fElemMap . length ; i ++ ) { int uriIndex = fElemMap [ i ] . uri ; int localpartIndex = fElemMap [ i ] . localpart ; } System . out . println ( "EOCIndex=" + fEOCIndex ) ; } return fEmptyContentIsValid ? - 1 : 0 ; } int curState = 0 ; for ( int childIndex = 0 ; childIndex < length ; childIndex ++ ) { final QName curElem = children [ offset + childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { int type = fElemMapType [ elemIndex ] & 0x0f ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( comparator . isEquivalentTo ( curElem , fElemMap [ elemIndex ] ) ) break ; } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ elemIndex ] . uri ; if ( uri == - 1 || uri == curElem . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( curElem . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ elemIndex ] . uri != curElem . uri ) { break ; } } } if ( elemIndex == fElemMapSize ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! didn't find it" ) ; System . out . println ( "curElem : " + curElem ) ; for ( int i = 0 ; i < fElemMapSize ; i ++ ) { System . out . println ( "fElemMap[" + i + "] = " + fElemMap [ i ] ) ; System . out . println ( "fElemMapType[" + i + "] = " + fElemMapType [ i ] ) ; } } return childIndex ; } curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "!!! not a legal transition" ) ; return childIndex ; } } if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "curState=" + curState + ", childCount=" + length ) ; if ( ! fFinalStateFlags [ curState ] ) return length ; return - 1 ; } public void setEquivClassComparator ( EquivClassComparator comparator ) { this . comparator = comparator ; } public int whatCanGoHere ( boolean fullyValid , InsertableElementsInfo info ) throws CMException { int curState = 0 ; for ( int childIndex = 0 ; childIndex < info . insertAt ; childIndex ++ ) { final QName curElem = info . curChildren [ childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { if ( fElemMap [ elemIndex ] . uri == curElem . uri && fElemMap [ elemIndex ] . localpart == curElem . localpart ) break ; } if ( elemIndex == fElemMapSize ) return childIndex ; curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) return childIndex ; } final int insertState = curState ; info . canHoldPCData = false ; info . isValidEOC = fFinalStateFlags [ insertState ] ; info . resultsCount = fElemMapSize ; if ( ( info . results == null ) || ( info . results . length < info . resultsCount ) ) info . results = new boolean [ info . resultsCount ] ; if ( ( info . possibleChildren == null ) || ( info . possibleChildren . length < info . resultsCount ) ) { info . possibleChildren = new QName [ info . resultsCount ] ; for ( int i = 0 ; i < info . possibleChildren . length ; i ++ ) { info . possibleChildren [ i ] = new QName ( ) ; } } for ( int index = 0 ; index < fElemMapSize ; index ++ ) { info . possibleChildren [ index ] . setValues ( fElemMap [ index ] ) ; info . results [ index ] = ( fTransTable [ insertState ] [ index ] != - 1 ) ; } if ( fullyValid ) { for ( int index = 0 ; index < info . resultsCount ; index ++ ) { if ( ! info . results [ index ] ) continue ; info . curChildren [ info . insertAt ] = info . possibleChildren [ index ] ; if ( validateContent ( info . curChildren , 0 , info . childCount ) != - 1 ) info . results [ index ] = false ; } } return - 1 ; } public ContentLeafNameTypeVector getContentLeafNameTypeVector ( ) { return fLeafNameTypeVector ; } private void buildDFA ( CMNode syntaxTree ) throws CMException { fQName . setValues ( - 1 , fEOCIndex , fEOCIndex ) ; CMLeaf nodeEOC = new CMLeaf ( fQName ) ; fHeadNode = new CMBinOp ( XMLContentSpec . CONTENTSPECNODE_SEQ , syntaxTree , nodeEOC ) ; fEOCPos = fLeafCount ; nodeEOC . setPosition ( fLeafCount ++ ) ; fLeafList = new CMLeaf [ fLeafCount ] ; fLeafListType = new int [ fLeafCount ] ; postTreeBuildInit ( fHeadNode , 0 ) ; fFollowList = new CMStateSet [ fLeafCount ] ; for ( int index = 0 ; index < fLeafCount ; index ++ ) fFollowList [ index ] = new CMStateSet ( fLeafCount ) ; calcFollowList ( fHeadNode ) ; fElemMap = new QName [ fLeafCount ] ; fElemMapType = new int [ fLeafCount ] ; fElemMapSize = 0 ; for ( int outIndex = 0 ; outIndex < fLeafCount ; outIndex ++ ) { fElemMap [ outIndex ] = new QName ( ) ; if ( ( fLeafListType [ outIndex ] & 0x0f ) != 0 ) { if ( fLeafNameTypeVector == null ) { fLeafNameTypeVector = new ContentLeafNameTypeVector ( ) ; } } final QName element = fLeafList [ outIndex ] . getElement ( ) ; int inIndex = 0 ; for ( ; inIndex < fElemMapSize ; inIndex ++ ) { if ( fDTD ) { if ( fElemMap [ inIndex ] . rawname == element . rawname ) { break ; } } else { if ( fElemMap [ inIndex ] . uri == element . uri && fElemMap [ inIndex ] . localpart == element . localpart && fElemMapType [ inIndex ] == fLeafListType [ outIndex ] ) break ; } } if ( inIndex == fElemMapSize ) { fElemMap [ fElemMapSize ] . setValues ( element ) ; fElemMapType [ fElemMapSize ] = fLeafListType [ outIndex ] ; fElemMapSize ++ ; } } if ( fLeafNameTypeVector != null ) { fLeafNameTypeVector . setValues ( fElemMap , fElemMapType , fElemMapSize ) ; } int curArraySize = fLeafCount * 4 ; CMStateSet [ ] statesToDo = new CMStateSet [ curArraySize ] ; fFinalStateFlags = new boolean [ curArraySize ] ; fTransTable = new int [ curArraySize ] [ ] ; CMStateSet setT = fHeadNode . firstPos ( ) ; int unmarkedState = 0 ; int curState = 0 ; fTransTable [ curState ] = makeDefStateList ( ) ; statesToDo [ curState ] = setT ; curState ++ ; while ( unmarkedState < curState ) { setT = statesToDo [ unmarkedState ] ; int [ ] transEntry = fTransTable [ unmarkedState ] ; fFinalStateFlags [ unmarkedState ] = setT . getBit ( fEOCPos ) ; unmarkedState ++ ; CMStateSet newSet = null ; for ( int elemIndex = 0 ; elemIndex < fElemMapSize ; elemIndex ++ ) { if ( newSet == null ) newSet = new CMStateSet ( fLeafCount ) ; else newSet . zeroBits ( ) ; for ( int leafIndex = 0 ; leafIndex < fLeafCount ; leafIndex ++ ) { if ( setT . getBit ( leafIndex ) ) { final QName leaf = fLeafList [ leafIndex ] . getElement ( ) ; final QName element = fElemMap [ elemIndex ] ; if ( fDTD ) { if ( leaf . rawname == element . rawname ) { newSet . union ( fFollowList [ leafIndex ] ) ; } } else { if ( leaf . uri == element . uri && leaf . localpart == element . localpart ) newSet . union ( fFollowList [ leafIndex ] ) ; } } } if ( ! newSet . isEmpty ( ) ) { int stateIndex = 0 ; for ( ; stateIndex < curState ; stateIndex ++ ) { if ( statesToDo [ stateIndex ] . isSameSet ( newSet ) ) break ; } if ( stateIndex == curState ) { statesToDo [ curState ] = newSet ; fTransTable [ curState ] = makeDefStateList ( ) ; curState ++ ; newSet = null ; } transEntry [ elemIndex ] = stateIndex ; if ( curState == curArraySize ) { final int newSize = ( int ) ( curArraySize * 1.5 ) ; CMStateSet [ ] newToDo = new CMStateSet [ newSize ] ; boolean [ ] newFinalFlags = new boolean [ newSize ] ; int [ ] [ ] newTransTable = new int [ newSize ] [ ] ; for ( int expIndex = 0 ; expIndex < curArraySize ; expIndex ++ ) { newToDo [ expIndex ] = statesToDo [ expIndex ] ; newFinalFlags [ expIndex ] = fFinalStateFlags [ expIndex ] ; newTransTable [ expIndex ] = fTransTable [ expIndex ] ; } curArraySize = newSize ; statesToDo = newToDo ; fFinalStateFlags = newFinalFlags ; fTransTable = newTransTable ; } } } } fEmptyContentIsValid = ( ( CMBinOp ) fHeadNode ) . getLeft ( ) . isNullable ( ) ; if ( DEBUG_VALIDATE_CONTENT ) dumpTree ( fHeadNode , 0 ) ; fHeadNode = null ; fLeafList = null ; fFollowList = null ; } private void calcFollowList ( CMNode nodeCur ) throws CMException { if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) { calcFollowList ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( CMBinOp ) nodeCur ) . getRight ( ) ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) { calcFollowList ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( CMBinOp ) nodeCur ) . getRight ( ) ) ; final CMStateSet last = ( ( CMBinOp ) nodeCur ) . getLeft ( ) . lastPos ( ) ; final CMStateSet first = ( ( CMBinOp ) nodeCur ) . getRight ( ) . firstPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { calcFollowList ( ( ( CMUniOp ) nodeCur ) . getChild ( ) ) ; final CMStateSet first = nodeCur . firstPos ( ) ; final CMStateSet last = nodeCur . lastPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) || ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) ) { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } } private void dumpTree ( CMNode nodeCur , int level ) throws CMException { for ( int index = 0 ; index < level ; index ++ ) System . out . print ( "   " ) ; int type = nodeCur . type ( ) ; if ( ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( type == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { if ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) System . out . print ( "Choice Node " ) ; else System . out . print ( "Seq Node " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( "Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; dumpTree ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) , level + 1 ) ; dumpTree ( ( ( CMBinOp ) nodeCur ) . getRight ( ) , level + 1 ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { System . out . print ( "Rep Node " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( "Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; dumpTree ( ( ( CMUniOp ) nodeCur ) . getChild ( ) , level + 1 ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { System . out . print ( "Leaf: (pos=" + ( ( CMLeaf ) nodeCur ) . getPosition ( ) + "), " + ( ( CMLeaf ) nodeCur ) . getElement ( ) + "(elemIndex=" + ( ( CMLeaf ) nodeCur ) . getElement ( ) + ") " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( " Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; } else { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } } private int [ ] makeDefStateList ( ) { int [ ] retArray = new int [ fElemMapSize ] ; for ( int index = 0 ; index < fElemMapSize ; index ++ ) retArray [ index ] = - 1 ; return retArray ; } private int postTreeBuildInit ( CMNode nodeCur , int curIndex ) throws CMException { nodeCur . setMaxStates ( fLeafCount ) ; if ( ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY || ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL || ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { QName qname = new QName ( - 1 , - 1 , - 1 , ( ( CMAny ) nodeCur ) . getURI ( ) ) ; fLeafList [ curIndex ] = new CMLeaf ( qname , ( ( CMAny ) nodeCur ) . getPosition ( ) ) ; fLeafListType [ curIndex ] = nodeCur . type ( ) ; curIndex ++ ; } else if ( ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { curIndex = postTreeBuildInit ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) , curIndex ) ; curIndex = postTreeBuildInit ( ( ( CMBinOp ) nodeCur ) . getRight ( ) , curIndex ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { curIndex = postTreeBuildInit ( ( ( CMUniOp ) nodeCur ) . getChild ( ) , curIndex ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { final QName node = ( ( CMLeaf ) nodeCur ) . getElement ( ) ; if ( node . localpart != fEpsilonIndex ) { fLeafList [ curIndex ] = ( CMLeaf ) nodeCur ; fLeafListType [ curIndex ] = XMLContentSpec . CONTENTSPECNODE_LEAF ; curIndex ++ ; } } else { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } return curIndex ; } } 	1
package org . apache . xerces . jaxp ; import java . io . IOException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xerces . parsers . DOMParser ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . w3c . dom . Document ; public class DocumentBuilderImpl extends DocumentBuilder { private boolean namespaces = false ; private boolean validation = false ; private DOMParser parser = null ; private DocumentBuilderImpl ( ) { super ( ) ; } protected DocumentBuilderImpl ( boolean namespaces , boolean validation ) throws ParserConfigurationException { this ( ) ; DOMParser p = new DOMParser ( ) ; try { p . setFeature ( "http://xml.org/sax/features/namespaces" , namespaces ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set namespace " + "awareness to " + namespaces ) ; } try { p . setFeature ( "http://xml.org/sax/features/validation" , validation ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set validation to " + validation ) ; } this . namespaces = namespaces ; this . validation = validation ; this . parser = p ; } public Document parse ( InputSource source ) throws SAXException , IOException , IllegalArgumentException { if ( source == null ) throw new IllegalArgumentException ( ) ; this . parser . parse ( source ) ; return ( this . parser . getDocument ( ) ) ; } public Document newDocument ( ) { return ( new org . apache . xerces . dom . DocumentImpl ( ) ) ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } public void setEntityResolver ( EntityResolver er ) { this . parser . setEntityResolver ( er ) ; } public void setErrorHandler ( ErrorHandler eh ) { this . parser . setErrorHandler ( eh ) ; } } 	0
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLDocumentScanner ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . readers . DefaultEntityHandler ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . ChunkyCharArray ; import org . apache . xerces . utils . Hash2intTable ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . parsers . DOMParser ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . InputSource ; import org . xml . sax . EntityResolver ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xerces . validators . dtd . DTDGrammar ; import org . apache . xerces . validators . schema . EquivClassComparator ; import org . apache . xerces . validators . schema . SchemaGrammar ; import org . apache . xerces . validators . schema . SchemaMessageProvider ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . schema . TraverseSchema ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . validators . datatype . StateMessageDatatype ; import org . apache . xerces . validators . datatype . IDREFDatatypeValidator ; import org . apache . xerces . validators . datatype . IDDatatypeValidator ; import org . apache . xerces . validators . datatype . ENTITYDatatypeValidator ; public final class XMLValidator implements DefaultEntityHandler . EventHandler , XMLEntityHandler . CharDataHandler , XMLDocumentScanner . EventHandler , NamespacesScope . NamespacesHandler { private static final boolean PRINT_EXCEPTION_STACK_TRACE = false ; private static final boolean DEBUG_PRINT_ATTRIBUTES = false ; private static final boolean DEBUG_PRINT_CONTENT = false ; private static final boolean DEBUG_SCHEMA_VALIDATION = false ; private static final boolean DEBUG_ELEMENT_CHILDREN = false ; private static final int CHUNK_SHIFT = 8 ; private static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; private static final int CHUNK_MASK = CHUNK_SIZE - 1 ; private static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; private Hashtable fIdDefs = null ; private StateMessageDatatype fStoreIDRef = new StateMessageDatatype ( ) { private Hashtable fIdDefs ; public Object getDatatypeObject ( ) { return ( Object ) fIdDefs ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_STORE ; } public void setDatatypeObject ( Object data ) { fIdDefs = ( Hashtable ) data ; } } ; private StateMessageDatatype fResetID = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDDatatypeValidator . ID_CLEAR ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fResetIDRef = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_CLEAR ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fValidateIDRef = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_VALIDATE ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fValidateENTITYMsg = new StateMessageDatatype ( ) { private Object packagedMessage = null ; public Object getDatatypeObject ( ) { return packagedMessage ; } public int getDatatypeState ( ) { return ENTITYDatatypeValidator . ENTITY_INITIALIZE ; } public void setDatatypeObject ( Object data ) { packagedMessage = data ; } } ; private AttributeValidator fAttValidatorNOTATION = new AttValidatorNOTATION ( ) ; private AttributeValidator fAttValidatorENUMERATION = new AttValidatorENUMERATION ( ) ; private AttributeValidator fAttValidatorDATATYPE = null ; StringPool fStringPool = null ; boolean fValidating = false ; boolean fInElementContent = false ; int fStandaloneReader = - 1 ; private boolean fValidationEnabled = false ; private boolean fDynamicValidation = false ; private boolean fSchemaValidation = true ; private boolean fValidationEnabledByDynamic = false ; private boolean fDynamicDisabledByValidation = false ; private boolean fWarningOnDuplicateAttDef = false ; private boolean fWarningOnUndeclaredElements = false ; private boolean fLoadDTDGrammar = true ; private int fDeclaration [ ] ; private XMLErrorReporter fErrorReporter = null ; private DefaultEntityHandler fEntityHandler = null ; private QName fCurrentElement = new QName ( ) ; private ContentLeafNameTypeVector [ ] fContentLeafStack = new ContentLeafNameTypeVector [ 8 ] ; private int [ ] fValidationFlagStack = new int [ 8 ] ; private int [ ] fScopeStack = new int [ 8 ] ; private int [ ] fGrammarNameSpaceIndexStack = new int [ 8 ] ; private int [ ] fElementEntityStack = new int [ 8 ] ; private int [ ] fElementIndexStack = new int [ 8 ] ; private int [ ] fContentSpecTypeStack = new int [ 8 ] ; private static final int sizeQNameParts = 8 ; private QName [ ] fElementQNamePartsStack = new QName [ sizeQNameParts ] ; private QName [ ] fElementChildren = new QName [ 32 ] ; private int fElementChildrenLength = 0 ; private int [ ] fElementChildrenOffsetStack = new int [ 32 ] ; private int fElementDepth = - 1 ; private boolean fNamespacesEnabled = false ; private NamespacesScope fNamespacesScope = null ; private int fNamespacesPrefix = - 1 ; private QName fRootElement = new QName ( ) ; private int fAttrListHandle = - 1 ; private int fCurrentElementEntity = - 1 ; private int fCurrentElementIndex = - 1 ; private int fCurrentContentSpecType = - 1 ; private boolean fSeenDoctypeDecl = false ; private final int TOP_LEVEL_SCOPE = - 1 ; private int fCurrentScope = TOP_LEVEL_SCOPE ; private int fCurrentSchemaURI = - 1 ; private int fEmptyURI = - 1 ; private int fXsiPrefix = - 1 ; private int fXsiURI = - 2 ; private int fXsiTypeAttValue = - 1 ; private DatatypeValidator fXsiTypeValidator = null ; private Grammar fGrammar = null ; private int fGrammarNameSpaceIndex = - 1 ; private GrammarResolver fGrammarResolver = null ; private boolean fScanningDTD = false ; private XMLDocumentScanner fDocumentScanner = null ; private boolean fCalledStartDocument = false ; private XMLDocumentHandler fDocumentHandler = null ; private XMLDocumentHandler . DTDHandler fDTDHandler = null ; private boolean fSeenRootElement = false ; private XMLAttrList fAttrList = null ; private int fXMLLang = - 1 ; private LocatorImpl fAttrNameLocator = null ; private boolean fCheckedForSchema = false ; private boolean fDeclsAreExternal = false ; private StringPool . CharArrayRange fCurrentElementCharArrayRange = null ; private char [ ] fCharRefData = null ; private boolean fSendCharDataAsCharArray = false ; private boolean fBufferDatatype = false ; private StringBuffer fDatatypeBuffer = new StringBuffer ( ) ; private QName fTempQName = new QName ( ) ; private XMLAttributeDecl fTempAttDecl = new XMLAttributeDecl ( ) ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; private boolean fGrammarIsDTDGrammar = false ; private boolean fGrammarIsSchemaGrammar = false ; private boolean fNeedValidationOff = false ; private int fEMPTYSymbol = - 1 ; private int fANYSymbol = - 1 ; private int fMIXEDSymbol = - 1 ; private int fCHILDRENSymbol = - 1 ; private int fCDATASymbol = - 1 ; private int fIDSymbol = - 1 ; private int fIDREFSymbol = - 1 ; private int fIDREFSSymbol = - 1 ; private int fENTITYSymbol = - 1 ; private int fENTITIESSymbol = - 1 ; private int fNMTOKENSymbol = - 1 ; private int fNMTOKENSSymbol = - 1 ; private int fNOTATIONSymbol = - 1 ; private int fENUMERATIONSymbol = - 1 ; private int fREQUIREDSymbol = - 1 ; private int fFIXEDSymbol = - 1 ; private int fDATATYPESymbol = - 1 ; private int fEpsilonIndex = - 1 ; private DatatypeValidatorFactoryImpl fDataTypeReg = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; private DatatypeValidator fValID = this . fDataTypeReg . getDatatypeValidator ( "ID" ) ; private DatatypeValidator fValIDRef = this . fDataTypeReg . getDatatypeValidator ( "IDREF" ) ; private DatatypeValidator fValIDRefs = this . fDataTypeReg . getDatatypeValidator ( "IDREFS" ) ; private DatatypeValidator fValENTITY = this . fDataTypeReg . getDatatypeValidator ( "ENTITY" ) ; private DatatypeValidator fValENTITIES = this . fDataTypeReg . getDatatypeValidator ( "ENTITIES" ) ; private DatatypeValidator fValNMTOKEN = this . fDataTypeReg . getDatatypeValidator ( "NMTOKEN" ) ; private DatatypeValidator fValNMTOKENS = this . fDataTypeReg . getDatatypeValidator ( "NMTOKENS" ) ; private DatatypeValidator fValNOTATION = this . fDataTypeReg . getDatatypeValidator ( "NOTATION" ) ; public XMLValidator ( StringPool stringPool , XMLErrorReporter errorReporter , DefaultEntityHandler entityHandler , XMLDocumentScanner documentScanner ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fEntityHandler = entityHandler ; fDocumentScanner = documentScanner ; fEmptyURI = fStringPool . addSymbol ( "" ) ; fXsiURI = fStringPool . addSymbol ( SchemaSymbols . URI_XSI ) ; fAttrList = new XMLAttrList ( fStringPool ) ; entityHandler . setEventHandler ( this ) ; entityHandler . setCharDataHandler ( this ) ; fDocumentScanner . setEventHandler ( this ) ; for ( int i = 0 ; i < sizeQNameParts ; i ++ ) { fElementQNamePartsStack [ i ] = new QName ( ) ; } init ( ) ; } public void setGrammarResolver ( GrammarResolver grammarResolver ) { fGrammarResolver = grammarResolver ; } public void initHandlers ( boolean sendCharDataAsCharArray , XMLDocumentHandler docHandler , XMLDocumentHandler . DTDHandler dtdHandler ) { fSendCharDataAsCharArray = sendCharDataAsCharArray ; fEntityHandler . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; fDocumentHandler = docHandler ; fDTDHandler = dtdHandler ; } public void resetOrCopy ( StringPool stringPool ) throws Exception { fAttrList = new XMLAttrList ( stringPool ) ; resetCommon ( stringPool ) ; } public void reset ( StringPool stringPool ) throws Exception { fAttrList . reset ( stringPool ) ; resetCommon ( stringPool ) ; } public void setValidationEnabled ( boolean flag ) throws Exception { fValidationEnabled = flag ; fValidationEnabledByDynamic = false ; if ( fValidationEnabled ) { if ( fDynamicDisabledByValidation ) { fDynamicValidation = true ; fDynamicDisabledByValidation = false ; } } else if ( fDynamicValidation ) { fDynamicValidation = false ; fDynamicDisabledByValidation = true ; } fValidating = fValidationEnabled ; } public boolean getValidationEnabled ( ) { return fValidationEnabled ; } public void setSchemaValidationEnabled ( boolean flag ) { fSchemaValidation = flag ; } public boolean getSchemaValidationEnabled ( ) { return fSchemaValidation ; } public void setDynamicValidationEnabled ( boolean flag ) throws Exception { fDynamicValidation = flag ; fDynamicDisabledByValidation = false ; if ( ! fDynamicValidation ) { if ( fValidationEnabledByDynamic ) { fValidationEnabled = false ; fValidationEnabledByDynamic = false ; } } else if ( ! fValidationEnabled ) { fValidationEnabled = true ; fValidationEnabledByDynamic = true ; } fValidating = fValidationEnabled ; } public boolean getDynamicValidationEnabled ( ) { return fDynamicValidation ; } public void setLoadDTDGrammar ( boolean loadDG ) { if ( fValidating ) { fLoadDTDGrammar = true ; } else { fLoadDTDGrammar = loadDG ; } } public boolean getLoadDTDGrammar ( ) { return fLoadDTDGrammar ; } public void setNamespacesEnabled ( boolean flag ) { fNamespacesEnabled = flag ; } public boolean getNamespacesEnabled ( ) { return fNamespacesEnabled ; } public void setWarningOnDuplicateAttDef ( boolean flag ) { fWarningOnDuplicateAttDef = flag ; } public boolean getWarningOnDuplicateAttDef ( ) { return fWarningOnDuplicateAttDef ; } public void setWarningOnUndeclaredElements ( boolean flag ) { fWarningOnUndeclaredElements = flag ; } public boolean getWarningOnUndeclaredElements ( ) { return fWarningOnUndeclaredElements ; } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { fDocumentHandler . startEntityReference ( entityName , entityType , entityContext ) ; } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { fDocumentHandler . endEntityReference ( entityName , entityType , entityContext ) ; } public void sendEndOfInputNotifications ( int entityName , boolean moreToFollow ) throws Exception { fDocumentScanner . endOfInput ( entityName , moreToFollow ) ; } public void sendReaderChangeNotifications ( XMLEntityHandler . EntityReader reader , int readerId ) throws Exception { fDocumentScanner . readerChange ( reader , readerId ) ; } public boolean externalEntityStandaloneCheck ( ) { return ( fStandaloneReader != - 1 && fValidating ) ; } public boolean getValidating ( ) { return fValidating ; } public void processCharacters ( char [ ] chars , int offset , int length ) throws Exception { if ( fValidating ) { if ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } if ( fBufferDatatype ) { fDatatypeBuffer . append ( chars , offset , length ) ; } } fDocumentHandler . characters ( chars , offset , length ) ; } public void processCharacters ( int data ) throws Exception { if ( fValidating ) { if ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } if ( fBufferDatatype ) { fDatatypeBuffer . append ( fStringPool . toString ( data ) ) ; } } fDocumentHandler . characters ( data ) ; } public void processWhitespace ( char [ ] chars , int offset , int length ) throws Exception { if ( fInElementContent ) { if ( fStandaloneReader != - 1 && fValidating && getElementDeclIsExternal ( fCurrentElementIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION ) ; } fDocumentHandler . ignorableWhitespace ( chars , offset , length ) ; } else { if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } fDocumentHandler . characters ( chars , offset , length ) ; } } public void processWhitespace ( int data ) throws Exception { if ( fInElementContent ) { if ( fStandaloneReader != - 1 && fValidating && getElementDeclIsExternal ( fCurrentElementIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION ) ; } fDocumentHandler . ignorableWhitespace ( data ) ; } else { if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } fDocumentHandler . characters ( data ) ; } } public void scanElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( ! fNamespacesEnabled ) { element . clear ( ) ; element . localpart = entityReader . scanName ( fastchar ) ; element . rawname = element . localpart ; } else { entityReader . scanQName ( fastchar , element ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } public boolean scanExpectedElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( fCurrentElementCharArrayRange == null ) { fCurrentElementCharArrayRange = fStringPool . createCharArrayRange ( ) ; } fStringPool . getCharArrayRange ( fCurrentElement . rawname , fCurrentElementCharArrayRange ) ; return entityReader . scanExpectedName ( fastchar , fCurrentElementCharArrayRange ) ; } public void scanAttributeName ( XMLEntityHandler . EntityReader entityReader , QName element , QName attribute ) throws Exception { if ( ! fSeenRootElement ) { fSeenRootElement = true ; rootElementSpecified ( element ) ; fStringPool . resetShuffleCount ( ) ; } if ( ! fNamespacesEnabled ) { attribute . clear ( ) ; attribute . localpart = entityReader . scanName ( '=' ) ; attribute . rawname = attribute . localpart ; } else { entityReader . scanQName ( '=' , attribute ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } public void callStartDocument ( ) throws Exception { if ( ! fCalledStartDocument ) { fDocumentHandler . startDocument ( ) ; fCalledStartDocument = true ; } } public void callEndDocument ( ) throws Exception { if ( fCalledStartDocument ) { fDocumentHandler . endDocument ( ) ; } } public void callXMLDecl ( int version , int encoding , int standalone ) throws Exception { fDocumentHandler . xmlDecl ( version , encoding , standalone ) ; } public void callStandaloneIsYes ( ) throws Exception { fStandaloneReader = fEntityHandler . getReaderId ( ) ; } public void callTextDecl ( int version , int encoding ) throws Exception { fDocumentHandler . textDecl ( version , encoding ) ; } public void element ( QName element ) throws Exception { fAttrListHandle = - 1 ; } public boolean attribute ( QName element , QName attrName , int attrValue ) throws Exception { if ( fAttrListHandle == - 1 ) { fAttrListHandle = fAttrList . startAttrList ( ) ; } return fAttrList . addAttr ( attrName , attrValue , fCDATASymbol , true , true ) == - 1 ; } public void callStartElement ( QName element ) throws Exception { if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "\n=======StartElement : " + fStringPool . toString ( element . localpart ) ) ; if ( ! fSeenRootElement ) { fSeenRootElement = true ; rootElementSpecified ( element ) ; fStringPool . resetShuffleCount ( ) ; } if ( fGrammar != null && fGrammarIsDTDGrammar ) { fAttrListHandle = addDTDDefaultAttributes ( element , fAttrList , fAttrListHandle , fValidating , fStandaloneReader != - 1 ) ; } fCheckedForSchema = true ; if ( fNamespacesEnabled ) { bindNamespacesToElementAndAttributes ( element , fAttrList ) ; } validateElementAndAttributes ( element , fAttrList ) ; if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; } fDocumentHandler . startElement ( element , fAttrList , fAttrListHandle ) ; fAttrListHandle = - 1 ; fElementDepth ++ ; if ( fValidating ) { if ( fElementChildrenOffsetStack . length < fElementDepth ) { int newarray [ ] = new int [ fElementChildrenOffsetStack . length * 2 ] ; System . arraycopy ( fElementChildrenOffsetStack , 0 , newarray , 0 , fElementChildrenOffsetStack . length ) ; fElementChildrenOffsetStack = newarray ; } fElementChildrenOffsetStack [ fElementDepth ] = fElementChildrenLength ; if ( fElementChildren . length <= fElementChildrenLength ) { QName [ ] newarray = new QName [ fElementChildrenLength * 2 ] ; System . arraycopy ( fElementChildren , 0 , newarray , 0 , fElementChildren . length ) ; fElementChildren = newarray ; } QName qname = fElementChildren [ fElementChildrenLength ] ; if ( qname == null ) { for ( int i = fElementChildrenLength ; i < fElementChildren . length ; i ++ ) { fElementChildren [ i ] = new QName ( ) ; } qname = fElementChildren [ fElementChildrenLength ] ; } qname . setValues ( element ) ; fElementChildrenLength ++ ; if ( DEBUG_ELEMENT_CHILDREN ) { printChildren ( ) ; printStack ( ) ; } } ensureStackCapacity ( fElementDepth ) ; fCurrentElement . setValues ( element ) ; fCurrentElementEntity = fEntityHandler . getReaderId ( ) ; fElementQNamePartsStack [ fElementDepth ] . setValues ( fCurrentElement ) ; fElementEntityStack [ fElementDepth ] = fCurrentElementEntity ; fElementIndexStack [ fElementDepth ] = fCurrentElementIndex ; fContentSpecTypeStack [ fElementDepth ] = fCurrentContentSpecType ; if ( fNeedValidationOff ) { fValidating = false ; fNeedValidationOff = false ; } if ( fValidating && fGrammarIsSchemaGrammar ) { pushContentLeafStack ( ) ; } fValidationFlagStack [ fElementDepth ] = fValidating ? 0 : - 1 ; fScopeStack [ fElementDepth ] = fCurrentScope ; fGrammarNameSpaceIndexStack [ fElementDepth ] = fGrammarNameSpaceIndex ; } private void pushContentLeafStack ( ) throws Exception { int contentType = getContentSpecType ( fCurrentElementIndex ) ; if ( contentType == XMLElementDecl . TYPE_CHILDREN ) { XMLContentModel cm = getElementContentModel ( fCurrentElementIndex ) ; ContentLeafNameTypeVector cv = cm . getContentLeafNameTypeVector ( ) ; if ( cm != null ) { fContentLeafStack [ fElementDepth ] = cv ; } } } private void ensureStackCapacity ( int newElementDepth ) { if ( newElementDepth == fElementQNamePartsStack . length ) { int [ ] newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fScopeStack , 0 , newStack , 0 , newElementDepth ) ; fScopeStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fGrammarNameSpaceIndexStack , 0 , newStack , 0 , newElementDepth ) ; fGrammarNameSpaceIndexStack = newStack ; QName [ ] newStackOfQueue = new QName [ newElementDepth * 2 ] ; System . arraycopy ( this . fElementQNamePartsStack , 0 , newStackOfQueue , 0 , newElementDepth ) ; fElementQNamePartsStack = newStackOfQueue ; QName qname = fElementQNamePartsStack [ newElementDepth ] ; if ( qname == null ) { for ( int i = newElementDepth ; i < fElementQNamePartsStack . length ; i ++ ) { fElementQNamePartsStack [ i ] = new QName ( ) ; } } newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fElementEntityStack , 0 , newStack , 0 , newElementDepth ) ; fElementEntityStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fElementIndexStack , 0 , newStack , 0 , newElementDepth ) ; fElementIndexStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fContentSpecTypeStack , 0 , newStack , 0 , newElementDepth ) ; fContentSpecTypeStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fValidationFlagStack , 0 , newStack , 0 , newElementDepth ) ; fValidationFlagStack = newStack ; ContentLeafNameTypeVector [ ] newStackV = new ContentLeafNameTypeVector [ newElementDepth * 2 ] ; System . arraycopy ( fContentLeafStack , 0 , newStackV , 0 , newElementDepth ) ; fContentLeafStack = newStackV ; } } public void callEndElement ( int readerId ) throws Exception { if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "=======EndElement : " + fStringPool . toString ( fCurrentElement . localpart ) + "\n" ) ; int prefixIndex = fCurrentElement . prefix ; int elementType = fCurrentElement . rawname ; if ( fCurrentElementEntity != readerId ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ELEMENT_ENTITY_MISMATCH , XMLMessages . P78_NOT_WELLFORMED , new Object [ ] { fStringPool . toString ( elementType ) } , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } fElementDepth -- ; if ( fValidating ) { int elementIndex = fCurrentElementIndex ; if ( elementIndex != - 1 && fCurrentContentSpecType != - 1 ) { QName children [ ] = fElementChildren ; int childrenOffset = fElementChildrenOffsetStack [ fElementDepth + 1 ] + 1 ; int childrenLength = fElementChildrenLength - childrenOffset ; if ( DEBUG_ELEMENT_CHILDREN ) { System . out . println ( "endElement(" + fStringPool . toString ( fCurrentElement . rawname ) + ')' ) ; System . out . println ( "fCurrentContentSpecType : " + fCurrentContentSpecType ) ; System . out . print ( "offset: " ) ; System . out . print ( childrenOffset ) ; System . out . print ( ", length: " ) ; System . out . print ( childrenLength ) ; System . out . println ( ) ; printChildren ( ) ; printStack ( ) ; } int result = checkContent ( elementIndex , children , childrenOffset , childrenLength ) ; if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "!!!!!!!!In XMLValidator, the return value from checkContent : " + result ) ; if ( result != - 1 ) { int majorCode = result != childrenLength ? XMLMessages . MSG_CONTENT_INVALID : XMLMessages . MSG_CONTENT_INCOMPLETE ; fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; if ( fTempElementDecl . type == XMLElementDecl . TYPE_EMPTY ) { reportRecoverableXMLError ( majorCode , 0 , fStringPool . toString ( elementType ) , "EMPTY" ) ; } else reportRecoverableXMLError ( majorCode , 0 , fStringPool . toString ( elementType ) , XMLContentSpec . toString ( fGrammar , fStringPool , fTempElementDecl . contentSpecIndex ) ) ; } } fElementChildrenLength = fElementChildrenOffsetStack [ fElementDepth + 1 ] + 1 ; } fDocumentHandler . endElement ( fCurrentElement ) ; if ( fNamespacesEnabled ) { fNamespacesScope . decreaseDepth ( ) ; } if ( fElementDepth < - 1 ) { throw new RuntimeException ( "FWK008 Element stack underflow" ) ; } if ( fElementDepth < 0 ) { fCurrentElement . clear ( ) ; fCurrentElementEntity = - 1 ; fCurrentElementIndex = - 1 ; fCurrentContentSpecType = - 1 ; fInElementContent = false ; if ( fValidating ) { try { this . fValIDRef . validate ( null , this . fValidateIDRef ) ; this . fValIDRefs . validate ( null , this . fValidateIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , ex . getMessage ( ) ) ; } } try { this . fValID . validate ( null , this . fResetID ) ; this . fValIDRef . validate ( null , this . fResetIDRef ) ; this . fValIDRefs . validate ( null , this . fResetIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error re-Initializing: ID,IDRef,IDRefs pools" ) ; } return ; } fCurrentElement . prefix = - 1 ; if ( fNamespacesEnabled ) { fCurrentElement . localpart = fElementQNamePartsStack [ fElementDepth ] . localpart ; } else { fCurrentElement . localpart = fElementQNamePartsStack [ fElementDepth ] . rawname ; } fCurrentElement . rawname = fElementQNamePartsStack [ fElementDepth ] . rawname ; fCurrentElement . uri = fElementQNamePartsStack [ fElementDepth ] . uri ; fCurrentElement . prefix = fElementQNamePartsStack [ fElementDepth ] . prefix ; fCurrentElementEntity = fElementEntityStack [ fElementDepth ] ; fCurrentElementIndex = fElementIndexStack [ fElementDepth ] ; fCurrentContentSpecType = fContentSpecTypeStack [ fElementDepth ] ; fValidating = fValidationFlagStack [ fElementDepth ] == 0 ? true : false ; fCurrentScope = fScopeStack [ fElementDepth ] ; if ( fGrammarNameSpaceIndex != fGrammarNameSpaceIndexStack [ fElementDepth ] ) { fGrammarNameSpaceIndex = fGrammarNameSpaceIndexStack [ fElementDepth ] ; if ( fValidating && fGrammarIsSchemaGrammar ) if ( ! switchGrammar ( fGrammarNameSpaceIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fGrammarNameSpaceIndex ) + " , can not found" ) ; } } if ( fValidating ) { fBufferDatatype = false ; } fInElementContent = ( fCurrentContentSpecType == XMLElementDecl . TYPE_CHILDREN ) ; } public void callStartCDATA ( ) throws Exception { fDocumentHandler . startCDATA ( ) ; } public void callEndCDATA ( ) throws Exception { fDocumentHandler . endCDATA ( ) ; } public void callCharacters ( int ch ) throws Exception { if ( fCharRefData == null ) { fCharRefData = new char [ 2 ] ; } int count = ( ch < 0x10000 ) ? 1 : 2 ; if ( count == 1 ) { fCharRefData [ 0 ] = ( char ) ch ; } else { fCharRefData [ 0 ] = ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; fCharRefData [ 1 ] = ( char ) ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; } if ( fValidating && ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) ) { charDataInContent ( ) ; } if ( fSendCharDataAsCharArray ) { fDocumentHandler . characters ( fCharRefData , 0 , count ) ; } else { int index = fStringPool . addString ( new String ( fCharRefData , 0 , count ) ) ; fDocumentHandler . characters ( index ) ; } } public void callProcessingInstruction ( int target , int data ) throws Exception { fDocumentHandler . processingInstruction ( target , data ) ; } public void callComment ( int comment ) throws Exception { fDocumentHandler . comment ( comment ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { fDocumentHandler . startNamespaceDeclScope ( prefix , uri ) ; } public void endNamespaceDeclScope ( int prefix ) throws Exception { fDocumentHandler . endNamespaceDeclScope ( prefix ) ; } public void setRootElementType ( QName rootElement ) { fRootElement . setValues ( rootElement ) ; } private boolean getElementDeclIsExternal ( int elementIndex ) { if ( fGrammarIsDTDGrammar ) { return ( ( DTDGrammar ) fGrammar ) . getElementDeclIsExternal ( elementIndex ) ; } return false ; } public int getContentSpecType ( int elementIndex ) { int contentSpecType = - 1 ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentSpecType = fTempElementDecl . type ; } } return contentSpecType ; } public int getContentSpecHandle ( int elementIndex ) { int contentSpecHandle = - 1 ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentSpecHandle = fTempElementDecl . contentSpecIndex ; } } return contentSpecHandle ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode ) throws Exception { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , null , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 ) throws Exception { Object [ ] args = { string1 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 , int stringIndex2 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) , fStringPool . toString ( stringIndex2 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 ) throws Exception { Object [ ] args = { string1 , string2 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 , String string3 ) throws Exception { Object [ ] args = { string1 , string2 , string3 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected int whatCanGoHere ( int elementIndex , boolean fullyValid , InsertableElementsInfo info ) throws Exception { if ( info . insertAt > info . childCount || info . curChildren == null || info . childCount < 1 || info . childCount > info . curChildren . length ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . VAL_WCGHI , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } int retVal = 0 ; try { final XMLContentModel cmElem = getElementContentModel ( elementIndex ) ; retVal = cmElem . whatCanGoHere ( fullyValid , info ) ; } catch ( CMException excToCatch ) { int majorCode = excToCatch . getErrorCode ( ) ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , majorCode , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; throw excToCatch ; } return retVal ; } protected boolean getAttDefIsExternal ( QName element , QName attribute ) { int attDefIndex = getAttDef ( element , attribute ) ; if ( fGrammarIsDTDGrammar ) { return ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attDefIndex ) ; } return false ; } private boolean usingStandaloneReader ( ) { return fStandaloneReader == - 1 || fEntityHandler . getReaderId ( ) == fStandaloneReader ; } private LocatorImpl getLocatorImpl ( LocatorImpl fillin ) { Locator here = fErrorReporter . getLocator ( ) ; if ( fillin == null ) return new LocatorImpl ( here ) ; fillin . setPublicId ( here . getPublicId ( ) ) ; fillin . setSystemId ( here . getSystemId ( ) ) ; fillin . setLineNumber ( here . getLineNumber ( ) ) ; fillin . setColumnNumber ( here . getColumnNumber ( ) ) ; return fillin ; } private void poolReset ( ) { try { this . fValID . validate ( null , this . fResetID ) ; this . fValIDRef . validate ( null , this . fResetIDRef ) ; this . fValIDRefs . validate ( null , this . fResetIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error re-Initializing: ID,IDRef,IDRefs pools" ) ; } } private void resetCommon ( StringPool stringPool ) throws Exception { fStringPool = stringPool ; fValidating = fValidationEnabled ; fValidationEnabledByDynamic = false ; fDynamicDisabledByValidation = false ; poolReset ( ) ; fCalledStartDocument = false ; fStandaloneReader = - 1 ; fElementChildrenLength = 0 ; fElementDepth = - 1 ; fSeenRootElement = false ; fSeenDoctypeDecl = false ; fNamespacesScope = null ; fNamespacesPrefix = - 1 ; fRootElement . clear ( ) ; fAttrListHandle = - 1 ; fCheckedForSchema = false ; fCurrentScope = TOP_LEVEL_SCOPE ; fCurrentSchemaURI = - 1 ; fEmptyURI = - 1 ; fXsiPrefix = - 1 ; fXsiTypeValidator = null ; fGrammar = null ; fGrammarNameSpaceIndex = - 1 ; if ( fGrammarResolver != null ) { fGrammarResolver . clearGrammarResolver ( ) ; } fGrammarIsDTDGrammar = false ; fGrammarIsSchemaGrammar = false ; init ( ) ; } private void init ( ) { fEmptyURI = fStringPool . addSymbol ( "" ) ; fXsiURI = fStringPool . addSymbol ( SchemaSymbols . URI_XSI ) ; fEMPTYSymbol = fStringPool . addSymbol ( "EMPTY" ) ; fANYSymbol = fStringPool . addSymbol ( "ANY" ) ; fMIXEDSymbol = fStringPool . addSymbol ( "MIXED" ) ; fCHILDRENSymbol = fStringPool . addSymbol ( "CHILDREN" ) ; fCDATASymbol = fStringPool . addSymbol ( "CDATA" ) ; fIDSymbol = fStringPool . addSymbol ( "ID" ) ; fIDREFSymbol = fStringPool . addSymbol ( "IDREF" ) ; fIDREFSSymbol = fStringPool . addSymbol ( "IDREFS" ) ; fENTITYSymbol = fStringPool . addSymbol ( "ENTITY" ) ; fENTITIESSymbol = fStringPool . addSymbol ( "ENTITIES" ) ; fNMTOKENSymbol = fStringPool . addSymbol ( "NMTOKEN" ) ; fNMTOKENSSymbol = fStringPool . addSymbol ( "NMTOKENS" ) ; fNOTATIONSymbol = fStringPool . addSymbol ( "NOTATION" ) ; fENUMERATIONSymbol = fStringPool . addSymbol ( "ENUMERATION" ) ; fREQUIREDSymbol = fStringPool . addSymbol ( "#REQUIRED" ) ; fFIXEDSymbol = fStringPool . addSymbol ( "#FIXED" ) ; fDATATYPESymbol = fStringPool . addSymbol ( "<<datatype>>" ) ; fEpsilonIndex = fStringPool . addSymbol ( "<<CMNODE_EPSILON>>" ) ; fXMLLang = fStringPool . addSymbol ( "xml:lang" ) ; try { Object [ ] packageArgsEntityVal = { ( Object ) this . fEntityHandler , ( Object ) this . fStringPool } ; fValidateENTITYMsg . setDatatypeObject ( ( Object ) packageArgsEntityVal ) ; fValENTITIES . validate ( null , fValidateENTITYMsg ) ; fValENTITY . validate ( null , fValidateENTITYMsg ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } private int addDefaultAttributes ( int elementIndex , XMLAttrList attrList , int attrIndex , boolean validationEnabled , boolean standalone ) throws Exception { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; int elementNameIndex = fTempElementDecl . name . localpart ; int attlistIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int firstCheck = attrIndex ; int lastCheck = - 1 ; while ( attlistIndex != - 1 ) { fGrammar . getAttributeDecl ( attlistIndex , fTempAttDecl ) ; int attPrefix = fTempAttDecl . name . prefix ; int attName = fTempAttDecl . name . localpart ; int attType = attributeTypeName ( fTempAttDecl ) ; int attDefType = fTempAttDecl . defaultType ; int attValue = - 1 ; if ( fTempAttDecl . defaultValue != null ) { attValue = fStringPool . addSymbol ( fTempAttDecl . defaultValue ) ; } boolean specified = false ; boolean required = attDefType == XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; if ( firstCheck != - 1 ) { boolean cdata = attType == fCDATASymbol ; if ( ! cdata || required || attValue != - 1 ) { int i = attrList . getFirstAttr ( firstCheck ) ; while ( i != - 1 && ( lastCheck == - 1 || i <= lastCheck ) ) { if ( ( fGrammarIsDTDGrammar && ( attrList . getAttrName ( i ) == fTempAttDecl . name . rawname ) ) || ( fStringPool . equalNames ( attrList . getAttrLocalpart ( i ) , attName ) && fStringPool . equalNames ( attrList . getAttrURI ( i ) , fTempAttDecl . name . uri ) ) ) { if ( validationEnabled && attDefType == XMLAttributeDecl . DEFAULT_TYPE_FIXED ) { int alistValue = attrList . getAttValue ( i ) ; if ( alistValue != attValue && ! fStringPool . toString ( alistValue ) . equals ( fStringPool . toString ( attValue ) ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) , fStringPool . toString ( alistValue ) , fStringPool . toString ( attValue ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_FIXED_ATTVALUE_INVALID , XMLMessages . VC_FIXED_ATTRIBUTE_DEFAULT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } specified = true ; break ; } i = attrList . getNextAttr ( i ) ; } } } if ( ! specified ) { if ( required ) { if ( validationEnabled ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_REQUIRED_ATTRIBUTE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else if ( attValue != - 1 ) { if ( validationEnabled && standalone ) if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attlistIndex ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( attType == fIDREFSymbol ) { this . fValIDRef . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } else if ( attType == fIDREFSSymbol ) { this . fValIDRefs . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } if ( attrIndex == - 1 ) { attrIndex = attrList . startAttrList ( ) ; } fTempQName . setValues ( attPrefix , attName , attName , fTempAttDecl . name . uri ) ; int newAttr = attrList . addAttr ( fTempQName , attValue , attType , false , false ) ; if ( lastCheck == - 1 ) { lastCheck = newAttr ; } } } attlistIndex = fGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } return attrIndex ; } private int addDTDDefaultAttributes ( QName element , XMLAttrList attrList , int attrIndex , boolean validationEnabled , boolean standalone ) throws Exception { int elementIndex = fGrammar . getElementDeclIndex ( element , - 1 ) ; if ( elementIndex == - 1 ) { return attrIndex ; } fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; int elementNameIndex = fTempElementDecl . name . rawname ; int attlistIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int firstCheck = attrIndex ; int lastCheck = - 1 ; while ( attlistIndex != - 1 ) { fGrammar . getAttributeDecl ( attlistIndex , fTempAttDecl ) ; int attPrefix = fTempAttDecl . name . prefix ; int attName = fTempAttDecl . name . rawname ; int attLocalpart = fTempAttDecl . name . localpart ; int attType = attributeTypeName ( fTempAttDecl ) ; int attDefType = fTempAttDecl . defaultType ; int attValue = - 1 ; if ( fTempAttDecl . defaultValue != null ) { attValue = fStringPool . addSymbol ( fTempAttDecl . defaultValue ) ; } boolean specified = false ; boolean required = attDefType == XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; if ( firstCheck != - 1 ) { boolean cdata = attType == fCDATASymbol ; if ( ! cdata || required || attValue != - 1 ) { int i = attrList . getFirstAttr ( firstCheck ) ; while ( i != - 1 && ( lastCheck == - 1 || i <= lastCheck ) ) { if ( attrList . getAttrName ( i ) == fTempAttDecl . name . rawname ) { if ( validationEnabled && attDefType == XMLAttributeDecl . DEFAULT_TYPE_FIXED ) { int alistValue = attrList . getAttValue ( i ) ; if ( alistValue != attValue && ! fStringPool . toString ( alistValue ) . equals ( fStringPool . toString ( attValue ) ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) , fStringPool . toString ( alistValue ) , fStringPool . toString ( attValue ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_FIXED_ATTVALUE_INVALID , XMLMessages . VC_FIXED_ATTRIBUTE_DEFAULT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } specified = true ; break ; } i = attrList . getNextAttr ( i ) ; } } } if ( ! specified ) { if ( required ) { if ( validationEnabled ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_REQUIRED_ATTRIBUTE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else if ( attValue != - 1 ) { if ( validationEnabled && standalone ) if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attlistIndex ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( attType == fIDREFSymbol ) { this . fValIDRef . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } else if ( attType == fIDREFSSymbol ) { this . fValIDRefs . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } if ( attrIndex == - 1 ) { attrIndex = attrList . startAttrList ( ) ; } fTempQName . setValues ( attPrefix , attLocalpart , attName , fTempAttDecl . name . uri ) ; int newAttr = attrList . addAttr ( fTempQName , attValue , attType , false , false ) ; if ( lastCheck == - 1 ) { lastCheck = newAttr ; } } } attlistIndex = fGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } return attrIndex ; } private XMLContentModel getElementContentModel ( int elementIndex ) throws CMException { XMLContentModel contentModel = null ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentModel = fGrammar . getElementContentModel ( elementIndex ) ; } } return contentModel ; } private int getAttDef ( QName element , QName attribute ) { if ( fGrammar != null ) { int scope = fCurrentScope ; if ( element . uri > - 1 ) { scope = TOP_LEVEL_SCOPE ; } int elementIndex = fGrammar . getElementDeclIndex ( element , scope ) ; if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { fGrammar . getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . name . localpart == attribute . localpart && fTempAttributeDecl . name . uri == attribute . uri ) { return attDefIndex ; } attDefIndex = fGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } return - 1 ; } private int getAttDefByElementIndex ( int elementIndex , QName attribute ) { if ( fGrammar != null && elementIndex > - 1 ) { if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { fGrammar . getAttributeDecl ( attDefIndex , fTempAttDecl ) ; if ( fGrammarIsDTDGrammar ) { if ( fTempAttDecl . name . rawname == attribute . rawname ) return attDefIndex ; } else if ( fTempAttDecl . name . localpart == attribute . localpart && fTempAttDecl . name . uri == attribute . uri ) { return attDefIndex ; } if ( fGrammarIsSchemaGrammar ) { if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return attDefIndex ; } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { if ( attribute . uri == - 1 ) { return attDefIndex ; } } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( attribute . uri != fTempAttDecl . name . uri ) { return attDefIndex ; } } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( fStringPool . stringInList ( fTempAttDecl . enumeration , attribute . uri ) ) { return attDefIndex ; } } } attDefIndex = fGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } return - 1 ; } private void rootElementSpecified ( QName rootElement ) throws Exception { if ( fLoadDTDGrammar ) if ( fGrammar == null ) { fGrammar = fGrammarResolver . getGrammar ( "" ) ; if ( fGrammar == null && DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "Oops! no grammar is found for validation" ) ; } if ( fDynamicValidation && fGrammar == null ) { fValidating = false ; } if ( fGrammar != null ) { if ( fGrammar instanceof DTDGrammar ) { fGrammarIsDTDGrammar = true ; fGrammarIsSchemaGrammar = false ; } else if ( fGrammar instanceof SchemaGrammar ) { fGrammarIsSchemaGrammar = true ; fGrammarIsDTDGrammar = false ; } fGrammarNameSpaceIndex = fEmptyURI ; } } if ( fValidating ) { if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getRootElementQName ( fRootElement ) ) { String root1 = fStringPool . toString ( fRootElement . rawname ) ; String root2 = fStringPool . toString ( rootElement . rawname ) ; if ( ! root1 . equals ( root2 ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ROOT_ELEMENT_TYPE , XMLMessages . VC_ROOT_ELEMENT_TYPE , fRootElement . rawname , rootElement . rawname ) ; } } } if ( fNamespacesEnabled ) { if ( fNamespacesScope == null ) { fNamespacesScope = new NamespacesScope ( this ) ; fNamespacesPrefix = fStringPool . addSymbol ( "xmlns" ) ; fNamespacesScope . setNamespaceForPrefix ( fNamespacesPrefix , - 1 ) ; int xmlSymbol = fStringPool . addSymbol ( "xml" ) ; int xmlNamespace = fStringPool . addSymbol ( "http://www.w3.org/XML/1998/namespace" ) ; fNamespacesScope . setNamespaceForPrefix ( xmlSymbol , xmlNamespace ) ; } } } private boolean switchGrammar ( int newGrammarNameSpaceIndex ) throws Exception { Grammar tempGrammar = fGrammarResolver . getGrammar ( fStringPool . toString ( newGrammarNameSpaceIndex ) ) ; if ( tempGrammar == null ) { tempGrammar = fGrammarResolver . getGrammar ( "" ) ; } if ( tempGrammar == null ) { return false ; } else { fGrammar = tempGrammar ; if ( fGrammar instanceof DTDGrammar ) { fGrammarIsDTDGrammar = true ; fGrammarIsSchemaGrammar = false ; } else if ( fGrammar instanceof SchemaGrammar ) { fGrammarIsSchemaGrammar = true ; fGrammarIsDTDGrammar = false ; } return true ; } } private void bindNamespacesToElementAndAttributes ( QName element , XMLAttrList attrList ) throws Exception { fNamespacesScope . increaseDepth ( ) ; Hashtable locationUriPairs = null ; if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; int attPrefix = attrList . getAttrPrefix ( index ) ; if ( fStringPool . equalNames ( attName , fXMLLang ) ) { } else if ( fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int uri = fStringPool . addSymbol ( attrList . getAttValue ( index ) ) ; fNamespacesScope . setNamespaceForPrefix ( StringPool . EMPTY_STRING , uri ) ; } else { if ( attPrefix == fNamespacesPrefix ) { int nsPrefix = attrList . getAttrLocalpart ( index ) ; int uri = fStringPool . addSymbol ( attrList . getAttValue ( index ) ) ; fNamespacesScope . setNamespaceForPrefix ( nsPrefix , uri ) ; if ( fValidating && fSchemaValidation ) { boolean seeXsi = false ; String attrValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; if ( attrValue . equals ( SchemaSymbols . URI_XSI ) ) { fXsiPrefix = nsPrefix ; seeXsi = true ; } if ( ! seeXsi ) { } } } } index = attrList . getNextAttr ( index ) ; } if ( fValidating && fSchemaValidation ) { fXsiTypeAttValue = - 1 ; index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; int attPrefix = attrList . getAttrPrefix ( index ) ; if ( fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { } else { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "deal with XSI" ) ; System . out . println ( "before find XSI: " + fStringPool . toString ( attPrefix ) + "," + fStringPool . toString ( fXsiPrefix ) ) ; } if ( fXsiPrefix != - 1 && attPrefix == fXsiPrefix ) { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "find XSI: " + fStringPool . toString ( attPrefix ) + "," + fStringPool . toString ( attName ) ) ; } int localpart = attrList . getAttrLocalpart ( index ) ; if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_SCHEMALOCACTION ) ) { if ( locationUriPairs == null ) { locationUriPairs = new Hashtable ( ) ; } parseSchemaLocation ( fStringPool . toString ( attrList . getAttValue ( index ) ) , locationUriPairs ) ; } else if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_NONAMESPACESCHEMALOCACTION ) ) { if ( locationUriPairs == null ) { locationUriPairs = new Hashtable ( ) ; } locationUriPairs . put ( fStringPool . toString ( attrList . getAttValue ( index ) ) , "" ) ; if ( fNamespacesScope != null ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } } else if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_TYPE ) ) { fXsiTypeAttValue = attrList . getAttValue ( index ) ; } } } index = attrList . getNextAttr ( index ) ; } if ( locationUriPairs != null ) { Enumeration locations = locationUriPairs . keys ( ) ; while ( locations . hasMoreElements ( ) ) { String loc = ( String ) locations . nextElement ( ) ; String uri = ( String ) locationUriPairs . get ( loc ) ; resolveSchemaGrammar ( loc , uri ) ; } } } } int prefix = element . prefix != - 1 ? element . prefix : 0 ; int uri = fNamespacesScope . getNamespaceForPrefix ( prefix ) ; if ( element . prefix != - 1 || uri != - 1 ) { element . uri = uri ; if ( element . uri == - 1 ) { Object [ ] args = { fStringPool . toString ( element . prefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; if ( ! fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int attPrefix = attrList . getAttrPrefix ( index ) ; if ( attPrefix != fNamespacesPrefix ) { if ( attPrefix != - 1 ) { int attrUri = fNamespacesScope . getNamespaceForPrefix ( attPrefix ) ; if ( attrUri == - 1 ) { Object [ ] args = { fStringPool . toString ( attPrefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } attrList . setAttrURI ( index , attrUri ) ; } } } index = attrList . getNextAttr ( index ) ; } } } void parseSchemaLocation ( String schemaLocationStr , Hashtable locationUriPairs ) { if ( locationUriPairs != null ) { StringTokenizer tokenizer = new StringTokenizer ( schemaLocationStr , " \n\t\r" , false ) ; int tokenTotal = tokenizer . countTokens ( ) ; if ( tokenTotal % 2 != 0 ) { } else { while ( tokenizer . hasMoreTokens ( ) ) { String uri = tokenizer . nextToken ( ) ; String location = tokenizer . nextToken ( ) ; locationUriPairs . put ( location , uri ) ; } } } else { } } private void resolveSchemaGrammar ( String loc , String uri ) throws Exception { SchemaGrammar grammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uri ) ; if ( grammar == null ) { DOMParser parser = new DOMParser ( ) ; parser . setEntityResolver ( new Resolver ( fEntityHandler ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } InputSource source = null ; EntityResolver currentER = parser . getEntityResolver ( ) ; if ( currentER != null ) { source = currentER . resolveEntity ( "" , loc ) ; } if ( source == null ) { loc = fEntityHandler . expandSystemId ( loc ) ; source = new InputSource ( loc ) ; } try { parser . parse ( source ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , e . getMessage ( ) ) ; } Document document = parser . getDocument ( ) ; TraverseSchema tst = null ; try { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "I am geting the Schema Document" ) ; } Element root = document . getDocumentElement ( ) ; if ( root == null ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Can't get back Schema document's root element :" + loc ) ; } else { if ( uri == null || ! uri . equals ( root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ) ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Schema in " + loc + " has a different target namespace " + "from the one specified in the instance document :" + uri ) ; } grammar = new SchemaGrammar ( ) ; grammar . setGrammarDocument ( document ) ; tst = new TraverseSchema ( root , fStringPool , ( SchemaGrammar ) grammar , fGrammarResolver , fErrorReporter , source . getSystemId ( ) ) ; fGrammarResolver . putGrammar ( document . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) , grammar ) ; } } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } } } private void resolveSchemaGrammar ( String uri ) throws Exception { resolveSchemaGrammar ( uri , uri ) ; } static class Resolver implements EntityResolver { private static final String SYSTEM [ ] = { "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/structures.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/datatypes.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/versionInfo.ent" , } ; private static final String PATH [ ] = { "structures.dtd" , "datatypes.dtd" , "versionInfo.ent" , } ; private DefaultEntityHandler fEntityHandler ; public Resolver ( DefaultEntityHandler handler ) { fEntityHandler = handler ; } public InputSource resolveEntity ( String publicId , String systemId ) throws IOException , SAXException { for ( int i = 0 ; i < SYSTEM . length ; i ++ ) { if ( systemId . equals ( SYSTEM [ i ] ) ) { InputSource source = new InputSource ( getClass ( ) . getResourceAsStream ( PATH [ i ] ) ) ; source . setPublicId ( publicId ) ; source . setSystemId ( systemId ) ; return source ; } } EntityResolver resolver = fEntityHandler . getEntityResolver ( ) ; if ( resolver != null ) { InputSource source = resolver . resolveEntity ( publicId , systemId ) ; if ( source != null ) { return source ; } } return new InputSource ( fEntityHandler . expandSystemId ( systemId ) ) ; } } static class ErrorHandler implements org . xml . sax . ErrorHandler { public void warning ( SAXParseException ex ) { System . err . println ( "[Warning] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { System . err . println ( "[Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) { System . err . println ( "[Fatal Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId_ = ex . getSystemId ( ) ; if ( systemId_ != null ) { int index = systemId_ . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId_ = systemId_ . substring ( index + 1 ) ; str . append ( systemId_ ) ; } str . append ( ':' ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( ':' ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } } private int attributeTypeName ( XMLAttributeDecl attrDecl ) { switch ( attrDecl . type ) { case XMLAttributeDecl . TYPE_ENTITY : { return attrDecl . list ? fENTITIESSymbol : fENTITYSymbol ; } case XMLAttributeDecl . TYPE_ENUMERATION : { String enumeration = fStringPool . stringListAsString ( attrDecl . enumeration ) ; return fStringPool . addString ( enumeration ) ; } case XMLAttributeDecl . TYPE_ID : { return fIDSymbol ; } case XMLAttributeDecl . TYPE_IDREF : { return attrDecl . list ? fIDREFSSymbol : fIDREFSymbol ; } case XMLAttributeDecl . TYPE_NMTOKEN : { return attrDecl . list ? fNMTOKENSSymbol : fNMTOKENSSymbol ; } case XMLAttributeDecl . TYPE_NOTATION : { return fNOTATIONSymbol ; } } return fCDATASymbol ; } private void validateElementAndAttributes ( QName element , XMLAttrList attrList ) throws Exception { if ( ( fElementDepth >= 0 && fValidationFlagStack [ fElementDepth ] != 0 ) || ( fGrammar == null && ! fValidating && ! fNamespacesEnabled ) ) { fCurrentElementIndex = - 1 ; fCurrentContentSpecType = - 1 ; fInElementContent = false ; if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; int index = fAttrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { if ( fStringPool . equalNames ( fAttrList . getAttrName ( index ) , fXMLLang ) ) { fDocumentScanner . checkXMLLangAttributeValue ( fAttrList . getAttValue ( index ) ) ; break ; } index = fAttrList . getNextAttr ( index ) ; } } return ; } int elementIndex = - 1 ; int contentSpecType = - 1 ; boolean skipThisOne = false ; boolean laxThisOne = false ; if ( fGrammarIsSchemaGrammar && fContentLeafStack [ fElementDepth ] != null ) { ContentLeafNameTypeVector cv = fContentLeafStack [ fElementDepth ] ; QName [ ] fElemMap = cv . leafNames ; for ( int i = 0 ; i < cv . leafCount ; i ++ ) { int type = cv . leafTypes [ i ] ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fElemMap [ i ] . uri == element . uri && fElemMap [ i ] . localpart == element . localpart ) break ; } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( element . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ i ] . uri != element . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_SKIP ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_SKIP ) { if ( element . uri == - 1 ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_SKIP ) { if ( fElemMap [ i ] . uri != element . uri ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LAX ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { laxThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_LAX ) { if ( element . uri == - 1 ) { laxThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_LAX ) { if ( fElemMap [ i ] . uri != element . uri ) { laxThisOne = true ; break ; } } } } if ( skipThisOne ) { fNeedValidationOff = true ; } else { if ( fNamespacesEnabled && fValidating && element . uri != fGrammarNameSpaceIndex && element . uri != - 1 ) { fGrammarNameSpaceIndex = element . uri ; boolean success = switchGrammar ( fGrammarNameSpaceIndex ) ; if ( ! success && ! laxThisOne ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fGrammarNameSpaceIndex ) + " , can not found" ) ; } } if ( fGrammar != null ) { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "*******Lookup element: uri: " + fStringPool . toString ( element . uri ) + "localpart: '" + fStringPool . toString ( element . localpart ) + "' and scope : " + fCurrentScope + "\n" ) ; } elementIndex = fGrammar . getElementDeclIndex ( element , fCurrentScope ) ; if ( elementIndex == - 1 ) { elementIndex = fGrammar . getElementDeclIndex ( element , TOP_LEVEL_SCOPE ) ; } if ( elementIndex == - 1 ) { if ( fGrammarIsSchemaGrammar && fCurrentElementIndex != - 1 ) { TraverseSchema . ComplexTypeInfo baseTypeInfo = null ; baseTypeInfo = ( ( SchemaGrammar ) fGrammar ) . getElementComplexTypeInfo ( fCurrentElementIndex ) ; while ( baseTypeInfo != null ) { elementIndex = fGrammar . getElementDeclIndex ( element , baseTypeInfo . scopeDefined ) ; if ( elementIndex > - 1 ) { break ; } baseTypeInfo = baseTypeInfo . baseComplexTypeInfo ; } } if ( elementIndex == - 1 ) { if ( laxThisOne ) { fNeedValidationOff = true ; } else if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "!!! can not find elementDecl in the grammar, " + " the element localpart: " + element . localpart + "[" + fStringPool . toString ( element . localpart ) + "]" + " the element uri: " + element . uri + "[" + fStringPool . toString ( element . uri ) + "]" + " and the current enclosing scope: " + fCurrentScope ) ; } } if ( DEBUG_SCHEMA_VALIDATION ) { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; System . out . println ( "elementIndex: " + elementIndex + " \n and itsName : '" + fStringPool . toString ( fTempElementDecl . name . localpart ) + "' \n its ContentType:" + fTempElementDecl . type + "\n its ContentSpecIndex : " + fTempElementDecl . contentSpecIndex + "\n" + " and the current enclosing scope: " + fCurrentScope ) ; } } contentSpecType = getContentSpecType ( elementIndex ) ; if ( fGrammarIsSchemaGrammar && elementIndex != - 1 ) { if ( fXsiTypeAttValue > - 1 ) { String xsiType = fStringPool . toString ( fXsiTypeAttValue ) ; int colonP = xsiType . indexOf ( ":" ) ; String prefix = "" ; String localpart = xsiType ; if ( colonP > - 1 ) { prefix = xsiType . substring ( 0 , colonP ) ; localpart = xsiType . substring ( colonP + 1 ) ; } String uri = "" ; int uriIndex = - 1 ; if ( fNamespacesScope != null ) { uriIndex = fNamespacesScope . getNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) ) ; if ( uriIndex > - 1 ) { uri = fStringPool . toString ( uriIndex ) ; if ( uriIndex != fGrammarNameSpaceIndex ) { fGrammarNameSpaceIndex = fCurrentSchemaURI = uriIndex ; boolean success = switchGrammar ( fCurrentSchemaURI ) ; if ( ! success && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fCurrentSchemaURI ) + " , can not found" ) ; } } } } Hashtable complexRegistry = ( ( SchemaGrammar ) fGrammar ) . getComplexTypeRegistry ( ) ; DatatypeValidatorFactoryImpl dataTypeReg = ( ( SchemaGrammar ) fGrammar ) . getDatatypeRegistry ( ) ; if ( complexRegistry == null || dataTypeReg == null ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , fErrorReporter . getLocator ( ) . getSystemId ( ) + " line" + fErrorReporter . getLocator ( ) . getLineNumber ( ) + ", canot resolve xsi:type = " + xsiType + "  ---2" ) ; } else { TraverseSchema . ComplexTypeInfo typeInfo = ( TraverseSchema . ComplexTypeInfo ) complexRegistry . get ( uri + "," + localpart ) ; if ( typeInfo == null ) { if ( uri . length ( ) == 0 || uri . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { fXsiTypeValidator = dataTypeReg . getDatatypeValidator ( localpart ) ; } else fXsiTypeValidator = dataTypeReg . getDatatypeValidator ( uri + "," + localpart ) ; if ( fXsiTypeValidator == null ) reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "unresolved type : " + uri + "," + localpart + " found  in xsi:type handling" ) ; } else elementIndex = typeInfo . templateElementIndex ; } fXsiTypeAttValue = - 1 ; } fCurrentScope = ( ( SchemaGrammar ) fGrammar ) . getElementDefinedScope ( elementIndex ) ; String anotherSchemaURI = ( ( SchemaGrammar ) fGrammar ) . getElementFromAnotherSchemaURI ( elementIndex ) ; if ( anotherSchemaURI != null ) { if ( contentSpecType != - 1 && contentSpecType != XMLElementDecl . TYPE_SIMPLE && contentSpecType != XMLElementDecl . TYPE_EMPTY ) { TraverseSchema . ComplexTypeInfo typeInfo = ( ( SchemaGrammar ) fGrammar ) . getElementComplexTypeInfo ( elementIndex ) ; if ( typeInfo != null ) { elementIndex = typeInfo . templateElementIndex ; } } fGrammarNameSpaceIndex = fCurrentSchemaURI = fStringPool . addSymbol ( anotherSchemaURI ) ; boolean success = switchGrammar ( fCurrentSchemaURI ) ; if ( ! success && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fCurrentSchemaURI ) + " , can not found" ) ; } } } if ( contentSpecType == - 1 && fValidating && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_NOT_DECLARED , XMLMessages . VC_ELEMENT_VALID , element . rawname ) ; } if ( fGrammar != null && fGrammarIsSchemaGrammar && elementIndex != - 1 ) { fAttrListHandle = addDefaultAttributes ( elementIndex , attrList , fAttrListHandle , fValidating , fStandaloneReader != - 1 ) ; } if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; } if ( DEBUG_PRINT_ATTRIBUTES ) { String elementStr = fStringPool . toString ( element . rawname ) ; System . out . print ( "startElement: <" + elementStr ) ; if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { System . out . print ( " " + fStringPool . toString ( attrList . getAttrName ( index ) ) + "=\"" + fStringPool . toString ( attrList . getAttValue ( index ) ) + "\"" ) ; index = attrList . getNextAttr ( index ) ; } } System . out . println ( ">" ) ; } if ( fAttrListHandle != - 1 && ! fNeedValidationOff ) { int index = fAttrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attrNameIndex = attrList . getAttrName ( index ) ; if ( fStringPool . equalNames ( attrNameIndex , fXMLLang ) ) { fDocumentScanner . checkXMLLangAttributeValue ( attrList . getAttValue ( index ) ) ; } int _xmlns = fStringPool . addSymbol ( "xmlns" ) ; if ( attrNameIndex != _xmlns && attrList . getAttrPrefix ( index ) != _xmlns ) if ( fGrammar != null ) { fAttrNameLocator = getLocatorImpl ( fAttrNameLocator ) ; fTempQName . setValues ( attrList . getAttrPrefix ( index ) , attrList . getAttrLocalpart ( index ) , attrList . getAttrName ( index ) , attrList . getAttrURI ( index ) ) ; int attDefIndex = getAttDefByElementIndex ( elementIndex , fTempQName ) ; if ( fTempQName . uri != fXsiURI ) if ( attDefIndex == - 1 ) { if ( fValidating ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( attrList . getAttrName ( index ) ) } ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else { fGrammar . getAttributeDecl ( attDefIndex , fTempAttDecl ) ; int attributeType = attributeTypeName ( fTempAttDecl ) ; attrList . setAttType ( index , attributeType ) ; if ( fValidating ) { if ( fGrammarIsDTDGrammar && ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ENTITY || fTempAttDecl . type == XMLAttributeDecl . TYPE_ENUMERATION || fTempAttDecl . type == XMLAttributeDecl . TYPE_ID || fTempAttDecl . type == XMLAttributeDecl . TYPE_IDREF || fTempAttDecl . type == XMLAttributeDecl . TYPE_NMTOKEN || fTempAttDecl . type == XMLAttributeDecl . TYPE_NOTATION ) ) { validateDTDattribute ( element , attrList . getAttValue ( index ) , fTempAttDecl ) ; } else if ( fGrammarIsSchemaGrammar && ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_ANY || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LIST || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) ) { if ( fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_SKIP ) { } else if ( fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_STRICT || fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_LAX ) { boolean reportError = false ; boolean processContentStrict = fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_STRICT ; if ( fTempQName . uri == - 1 ) { if ( processContentStrict ) { reportError = true ; } } else { Grammar aGrammar = fGrammarResolver . getGrammar ( fStringPool . toString ( fTempQName . uri ) ) ; if ( aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { if ( processContentStrict ) { reportError = true ; } } else { SchemaGrammar sGrammar = ( SchemaGrammar ) aGrammar ; Hashtable attRegistry = sGrammar . getAttirubteDeclRegistry ( ) ; if ( attRegistry == null ) { if ( processContentStrict ) { reportError = true ; } } else { XMLAttributeDecl attDecl = ( XMLAttributeDecl ) attRegistry . get ( fStringPool . toString ( fTempQName . localpart ) ) ; if ( attDecl == null ) { if ( processContentStrict ) { reportError = true ; } } else { DatatypeValidator attDV = attDecl . datatypeValidator ; if ( attDV == null ) { if ( processContentStrict ) { reportError = true ; } } else { try { String unTrimValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; String value = unTrimValue . trim ( ) ; if ( attDecl . type == XMLAttributeDecl . TYPE_ID ) { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } if ( attDecl . type == XMLAttributeDecl . TYPE_IDREF ) { attDV . validate ( value , this . fStoreIDRef ) ; } else attDV . validate ( unTrimValue , null ) ; } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } } if ( reportError ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , "ANY---" + fStringPool . toString ( attrList . getAttrName ( index ) ) } ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } else if ( fTempAttDecl . datatypeValidator == null ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( attrList . getAttrName ( index ) ) } ; System . out . println ( "[Error] Datatypevalidator for attribute " + fStringPool . toString ( attrList . getAttrName ( index ) ) + " not found in element type " + fStringPool . toString ( element . rawname ) ) ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } else { try { String unTrimValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; String value = unTrimValue . trim ( ) ; if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ID ) { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_IDREF ) { fTempAttDecl . datatypeValidator . validate ( value , this . fStoreIDRef ) ; } else { fTempAttDecl . datatypeValidator . validate ( unTrimValue , null ) ; } } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } index = fAttrList . getNextAttr ( index ) ; } } } if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; if ( ! fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int attPrefix = attrList . getAttrPrefix ( index ) ; if ( attPrefix != fNamespacesPrefix ) { if ( attPrefix != - 1 ) { int uri = fNamespacesScope . getNamespaceForPrefix ( attPrefix ) ; if ( uri == - 1 ) { Object [ ] args = { fStringPool . toString ( attPrefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } attrList . setAttrURI ( index , uri ) ; } } } index = attrList . getNextAttr ( index ) ; } } fCurrentElementIndex = elementIndex ; fCurrentContentSpecType = contentSpecType ; if ( fValidating && contentSpecType == XMLElementDecl . TYPE_SIMPLE ) { fBufferDatatype = true ; fDatatypeBuffer . setLength ( 0 ) ; } fInElementContent = ( contentSpecType == XMLElementDecl . TYPE_CHILDREN ) ; } private void validateDTDattribute ( QName element , int attValue , XMLAttributeDecl attributeDecl ) throws Exception { AttributeValidator av = null ; switch ( attributeDecl . type ) { case XMLAttributeDecl . TYPE_ENTITY : { boolean isAlistAttribute = attributeDecl . list ; String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValENTITIES . validate ( value , null ) ; } else { fValENTITY . validate ( value , null ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( ex . getMajorCode ( ) != 1 && ex . getMinorCode ( ) != - 1 ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } else { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } } break ; case XMLAttributeDecl . TYPE_ENUMERATION : av = fAttValidatorENUMERATION ; break ; case XMLAttributeDecl . TYPE_ID : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } } break ; case XMLAttributeDecl . TYPE_IDREF : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; boolean isAlistAttribute = attributeDecl . list ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValIDRefs . validate ( value , this . fStoreIDRef ) ; } else { fValIDRef . validate ( value , this . fStoreIDRef ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( ex . getMajorCode ( ) != 1 && ex . getMinorCode ( ) != - 1 ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } else { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } } break ; case XMLAttributeDecl . TYPE_NOTATION : { av = fAttValidatorNOTATION ; } break ; case XMLAttributeDecl . TYPE_NMTOKEN : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; boolean isAlistAttribute = attributeDecl . list ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValNMTOKENS . validate ( value , null ) ; } else { fValNMTOKEN . validate ( value , null ) ; } } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( XMLMessages . MSG_NMTOKEN_INVALID , XMLMessages . VC_NAME_TOKEN , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } } break ; } if ( av != null ) av . normalize ( element , attributeDecl . name , attValue , attributeDecl . type , attributeDecl . enumeration ) ; } private void charDataInContent ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . println ( "charDataInContent()" ) ; } if ( fElementChildren . length <= fElementChildrenLength ) { QName [ ] newarray = new QName [ fElementChildren . length * 2 ] ; System . arraycopy ( fElementChildren , 0 , newarray , 0 , fElementChildren . length ) ; fElementChildren = newarray ; } QName qname = fElementChildren [ fElementChildrenLength ] ; if ( qname == null ) { for ( int i = fElementChildrenLength ; i < fElementChildren . length ; i ++ ) { fElementChildren [ i ] = new QName ( ) ; } qname = fElementChildren [ fElementChildrenLength ] ; } qname . clear ( ) ; fElementChildrenLength ++ ; } private int checkContent ( int elementIndex , QName [ ] children , int childOffset , int childCount ) throws Exception { final int elementType = fCurrentElement . rawname ; if ( DEBUG_PRINT_CONTENT ) { String strTmp = fStringPool . toString ( elementType ) ; System . out . println ( "Name: " + strTmp + ", " + "Count: " + childCount + ", " + "ContentSpecType: " + fCurrentContentSpecType ) ; for ( int index = childOffset ; index < ( childOffset + childCount ) && index < 10 ; index ++ ) { if ( index == 0 ) { System . out . print ( "  (" ) ; } String childName = ( children [ index ] . localpart == - 1 ) ? "#PCDATA" : fStringPool . toString ( children [ index ] . localpart ) ; if ( index + 1 == childCount ) { System . out . println ( childName + ")" ) ; } else if ( index + 1 == 10 ) { System . out . println ( childName + ",...)" ) ; } else { System . out . print ( childName + "," ) ; } } } final int contentType = fCurrentContentSpecType ; if ( contentType == XMLElementDecl . TYPE_EMPTY ) { if ( childCount != 0 ) { return 0 ; } } else if ( contentType == XMLElementDecl . TYPE_ANY ) { } else if ( contentType == XMLElementDecl . TYPE_MIXED || contentType == XMLElementDecl . TYPE_CHILDREN ) { XMLContentModel cmElem = null ; try { cmElem = getElementContentModel ( elementIndex ) ; int result = cmElem . validateContent ( children , childOffset , childCount ) ; if ( result != - 1 && fGrammarIsSchemaGrammar ) { EquivClassComparator comparator = new EquivClassComparator ( fGrammarResolver , fStringPool ) ; cmElem . setEquivClassComparator ( comparator ) ; result = cmElem . validateContentSpecial ( children , childOffset , childCount ) ; } return result ; } catch ( CMException excToCatch ) { int majorCode = excToCatch . getErrorCode ( ) ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , majorCode , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } else if ( contentType == - 1 ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_NOT_DECLARED , XMLMessages . VC_ELEMENT_VALID , elementType ) ; } else if ( contentType == XMLElementDecl . TYPE_SIMPLE ) { XMLContentModel cmElem = null ; if ( childCount > 0 ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { "In element '" + fStringPool . toString ( elementType ) + "' : " + "Can not have element children within a simple type content" } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } else { try { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; DatatypeValidator dv = fTempElementDecl . datatypeValidator ; if ( fXsiTypeValidator != null ) { dv = fXsiTypeValidator ; fXsiTypeValidator = null ; } if ( dv == null ) { System . out . println ( "Internal Error: this element have a simpletype " + "but no datatypevalidator was found, element " + fTempElementDecl . name + ",locapart: " + fStringPool . toString ( fTempElementDecl . name . localpart ) ) ; } else { dv . validate ( fDatatypeBuffer . toString ( ) , null ) ; } } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } else { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . VAL_CST , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } return - 1 ; } private void printChildren ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . print ( '[' ) ; for ( int i = 0 ; i < fElementChildrenLength ; i ++ ) { System . out . print ( ' ' ) ; QName qname = fElementChildren [ i ] ; if ( qname != null ) { System . out . print ( fStringPool . toString ( qname . rawname ) ) ; } else { System . out . print ( "null" ) ; } if ( i < fElementChildrenLength - 1 ) { System . out . print ( ", " ) ; } System . out . flush ( ) ; } System . out . print ( " ]" ) ; System . out . println ( ) ; } } private void printStack ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . print ( '{' ) ; for ( int i = 0 ; i <= fElementDepth ; i ++ ) { System . out . print ( ' ' ) ; System . out . print ( fElementChildrenOffsetStack [ i ] ) ; if ( i < fElementDepth ) { System . out . print ( ", " ) ; } System . out . flush ( ) ; } System . out . print ( " }" ) ; System . out . println ( ) ; } } public interface AttributeValidator { public int normalize ( QName element , QName attribute , int attValue , int attType , int enumHandle ) throws Exception ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } final class AttValidatorNOTATION implements AttributeValidator { public int normalize ( QName element , QName attribute , int attValueHandle , int attType , int enumHandle ) throws Exception { String attValue = fStringPool . toString ( attValueHandle ) ; String newAttValue = attValue . trim ( ) ; if ( fValidating ) { if ( newAttValue != attValue ) { if ( invalidStandaloneAttDef ( element , attribute ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attribute . rawname ) , attValue , newAttValue ) ; } attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } else { attValueHandle = fStringPool . addSymbol ( attValueHandle ) ; } if ( ! fStringPool . stringInList ( enumHandle , attValueHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_NOT_IN_LIST , XMLMessages . VC_NOTATION_ATTRIBUTES , fStringPool . toString ( attribute . rawname ) , newAttValue , fStringPool . stringListAsString ( enumHandle ) ) ; } } else if ( newAttValue != attValue ) { attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } return attValueHandle ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } } final class AttValidatorENUMERATION implements AttributeValidator { public int normalize ( QName element , QName attribute , int attValueHandle , int attType , int enumHandle ) throws Exception { String attValue = fStringPool . toString ( attValueHandle ) ; String newAttValue = attValue . trim ( ) ; if ( fValidating ) { if ( newAttValue != attValue ) { if ( invalidStandaloneAttDef ( element , attribute ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attribute . rawname ) , attValue , newAttValue ) ; } attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } else { attValueHandle = fStringPool . addSymbol ( attValueHandle ) ; } if ( ! fStringPool . stringInList ( enumHandle , attValueHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_NOT_IN_LIST , XMLMessages . VC_ENUMERATION , fStringPool . toString ( attribute . rawname ) , newAttValue , fStringPool . stringListAsString ( enumHandle ) ) ; } } else if ( newAttValue != attValue ) { attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } return attValueHandle ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } } } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class ElementDefinitionImpl extends ParentNode { static final long serialVersionUID = - 8373890672670022714L ; protected String name ; protected NamedNodeMapImpl attributes ; public ElementDefinitionImpl ( DocumentImpl ownerDocument , String name ) { super ( ownerDocument ) ; this . name = name ; attributes = new NamedNodeMapImpl ( ownerDocument ) ; } public short getNodeType ( ) { return NodeImpl . ELEMENT_DEFINITION_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public Node cloneNode ( boolean deep ) { ElementDefinitionImpl newnode = ( ElementDefinitionImpl ) super . cloneNode ( deep ) ; newnode . attributes = attributes . cloneMap ( newnode ) ; return newnode ; } public NamedNodeMap getAttributes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return attributes ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class ElementNSImpl extends ElementImpl { static final long serialVersionUID = - 9142310625494392642L ; protected String namespaceURI ; protected String localName ; protected ElementNSImpl ( DocumentImpl ownerDocument , String namespaceURI , String qualifiedName ) throws DOMException { super ( ownerDocument , qualifiedName ) ; if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = qualifiedName ; } else { prefix = qualifiedName . substring ( 0 , index ) ; localName = qualifiedName . substring ( index + 1 ) ; } if ( prefix != null && ( namespaceURI == null || namespaceURI . equals ( "" ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } this . namespaceURI = namespaceURI ; } protected ElementNSImpl ( DocumentImpl ownerDocument , String value ) { super ( ownerDocument , value ) ; } public String getNamespaceURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return namespaceURI ; } public String getPrefix ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int index = name . indexOf ( ':' ) ; return index < 0 ? null : name . substring ( 0 , index ) ; } public void setPrefix ( String prefix ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( namespaceURI == null || ( prefix != null && prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } if ( ownerDocument . errorChecking && ! DocumentImpl . isXMLName ( prefix ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } name = prefix + ":" + localName ; } public String getLocalName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return localName ; } } 	1
package org . apache . xerces . utils ; import java . util . Locale ; import java . util . ResourceBundle ; import java . util . ListResourceBundle ; public class ImplementationMessages implements XMLMessageProvider { public static final String XERCES_IMPLEMENTATION_DOMAIN = "http://www.apache.org/xml/xerces.html" ; public void setLocale ( Locale locale ) { fLocale = locale ; } public Locale getLocale ( ) { return fLocale ; } public String createMessage ( Locale locale , int majorCode , int minorCode , Object args [ ] ) { boolean throwex = false ; if ( fResourceBundle == null || locale != fLocale ) { if ( locale != null ) fResourceBundle = ListResourceBundle . getBundle ( "org.apache.xerces.msg.ImplementationMessages" , locale ) ; if ( fResourceBundle == null ) fResourceBundle = ListResourceBundle . getBundle ( "org.apache.xerces.msg.ImplementationMessages" ) ; } if ( majorCode < 0 || majorCode >= fgMessageKeys . length - 1 ) { majorCode = BAD_MAJORCODE ; throwex = true ; } String msgKey = fgMessageKeys [ majorCode ] ; String msg = fResourceBundle . getString ( msgKey ) ; if ( args != null ) { try { msg = java . text . MessageFormat . format ( msg , args ) ; } catch ( Exception e ) { msg = fResourceBundle . getString ( fgMessageKeys [ FORMAT_FAILED ] ) ; msg += " " + fResourceBundle . getString ( msgKey ) ; } } if ( throwex ) { throw new RuntimeException ( msg ) ; } return msg ; } private Locale fLocale = null ; private ResourceBundle fResourceBundle = null ; public static final int BAD_MAJORCODE = 0 , ENC4 = 1 , ENC5 = 2 , ENC6 = 3 , ENC7 = 4 , IO0 = 5 , VAL_BST = 6 , VAL_CMSI = 7 , VAL_CST = 8 , VAL_LST = 9 , VAL_NIICM = 10 , VAL_NPCD = 11 , VAL_UST = 12 , VAL_WCGHI = 13 , INT_DCN = 14 , INT_PCN = 15 , FATAL_ERROR = 16 , FORMAT_FAILED = 17 ; private static final String [ ] fgMessageKeys = { "BadMajorCode" , "ENC4" , "ENC5" , "ENC6" , "ENC7" , "FileNotFound" , "VAL_BST" , "VAL_CMSI" , "VAL_CST" , "VAL_LST" , "VAL_NIICM" , "VAL_NPCD" , "VAL_UST" , "VAL_WCGHI" , "INT_DCN" , "INT_PCN" , "FatalError" , "FormatFailed" , null } ; } 	0
package org . w3c . dom ; public interface Document extends Node { public DocumentType getDoctype ( ) ; public DOMImplementation getImplementation ( ) ; public Element getDocumentElement ( ) ; public Element createElement ( String tagName ) throws DOMException ; public DocumentFragment createDocumentFragment ( ) ; public Text createTextNode ( String data ) ; public Comment createComment ( String data ) ; public CDATASection createCDATASection ( String data ) throws DOMException ; public ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException ; public Attr createAttribute ( String name ) throws DOMException ; public EntityReference createEntityReference ( String name ) throws DOMException ; public NodeList getElementsByTagName ( String tagname ) ; public Node importNode ( Node importedNode , boolean deep ) throws DOMException ; public Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException ; public Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public Element getElementById ( String elementId ) ; } 	1
package org . w3c . dom . html ; public interface HTMLTableCaptionElement extends HTMLElement { public String getAlign ( ) ; public void setAlign ( String align ) ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface NodeIterator { public Node getRoot ( ) ; public int getWhatToShow ( ) ; public NodeFilter getFilter ( ) ; public boolean getExpandEntityReferences ( ) ; public Node nextNode ( ) throws DOMException ; public Node previousNode ( ) throws DOMException ; public void detach ( ) ; } 	1
package org . apache . xerces . msg ; import java . util . ListResourceBundle ; public class ExceptionMessages extends ListResourceBundle { public static final Object CONTENTS [ ] [ ] = { { "FMT001" , "Message Formatting Error." } , { "HTM001" , "State error: startDocument fired twice on one builder." } , { "HTM002" , "State error: document never started or missing document element." } , { "HTM003" , "State error: document ended before end of document element." } , { "HTM004" , "Argument ''tagName'' is null." } , { "HTM005" , "State error: Document.getDocumentElement returns null." } , { "HTM006" , "State error: startElement called after end of document element." } , { "HTM007" , "State error: endElement called with no current node." } , { "HTM008" , "State error: mismatch in closing tag name {0}" } , { "HTM009" , "State error: character data found outside of root element." } , { "HTM010" , "State error: character data found outside of root element." } , { "HTM011" , "Argument ''topLevel'' is null." } , { "HTM012" , "Argument ''index'' is negative." } , { "HTM013" , "Argument ''name'' is null." } , { "HTM014" , "Argument ''title'' is null." } , { "HTM015" , "Tag ''{0}'' associated with an Element class that failed to construct." } , { "HTM016" , "Argument ''caption'' is not an element of type <CAPTION>." } , { "HTM017" , "Argument ''tHead'' is not an element of type <THEAD>." } , { "HTM018" , "Argument ''tFoot'' is not an element of type <TFOOT>." } , { "HTM019" , "OpenXML Error: Could not find class {0} implementing HTML element {1}" } , { "SER001" , "Argument ''output'' is null." } , { "SER002" , "No writer supplied for serializer" } , { "SER003" , "The resource [{0}] could not be found." } , { "SER004" , "The resource [{0}] could not load: {1}" } , { "SER005" , "The method ''{0}'' is not supported by this factory" } , { "DOM001" , "Modification not allowed" } , { "DOM002" , "Illegal character" } , { "DOM003" , "Namespace error" } , { "DOM004" , "Index out of bounds" } , { "DOM005" , "Wrong document" } , { "DOM006" , "Hierarchy request error" } , { "DOM007" , "Not supported" } , { "DOM008" , "Not found" } , { "DOM009" , "Attribute already in use" } , { "DOM010" , "Unspecified event type" } , { "DOM011" , "Invalid state" } , { "DOM012" , "Invalid node type" } , { "DOM013" , "Bad boundary points" } , { "FWK001" , "{0}] scannerState: {1}" } , { "FWK002" , "{0}] popElementType: fElementDepth-- == 0." } , { "FWK003" , "TrailingMiscDispatcher.endOfInput moreToFollow" } , { "FWK004" , "cannot happen: {0}" } , { "FWK005" , "parse may not be called while parsing." } , { "FWK006" , "setLocale may not be called while parsing." } , { "FWK007" , "Unknown error domain \"{0}\"." } , { "FWK008" , "Element stack underflow." } , { "PAR001" , "Fatal error constructing DOMParser." } , { "PAR002" , "Class, \"{0}\", is not of type org.w3c.dom" } , { "PAR003" , "Class, \"{0}\", not found." } , { "PAR004" , "Cannot setFeature({0}): parse is in progress." } , { "PAR005" , "Property, \"{0}\" is read-only." } , { "PAR006" , "Property value must be of type java.lang.String." } , { "PAR007" , "Current element node cannot be queried when node expansion is deferred." } , { "PAR008" , "Fatal error getting document factory." } , { "PAR009" , "Fatal error reading expansion mode." } , { "PAR010" , "Can''t copy node type, {0} ({1})." } , { "PAR011" , "Feature {0} not supported during parse." } , { "PAR012" , "For propertyId \"{0}\", the value \"" + "{1}\" cannot be cast to {2}." } , { "PAR013" , "Property \"{0}\" is read only." } , { "PAR014" , "Cannot getProperty(\"{0}\". No DOM tree exists." } , { "PAR015" , "startEntityReference(): ENTITYTYPE_UNPARSED" } , { "PAR016" , "endEntityReference(): ENTITYTYPE_UNPARSED" } , { "PAR017" , "cannot happen: {0}" } , { "RDR001" , "untested" } , { "RDR002" , "cannot happen" } , { "UTL001" , "untested" } , { "UTL002" , "cannot happen" } , { "VAL001" , "Element stack underflow" } , { "VAL002" , "getValidatorForAttType ({0})" } , { "VAL003" , "cannot happen" } } ; public Object [ ] [ ] getContents ( ) { return CONTENTS ; } } 	0
package org . w3c . dom . events ; public class EventException extends RuntimeException { public EventException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short UNSPECIFIED_EVENT_TYPE_ERR = 0 ; } 	1
package org . apache . wml ; public interface WMLTdElement extends WMLElement { public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface DeclHandler { public abstract void elementDecl ( String name , String model ) throws SAXException ; public abstract void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException ; public abstract void internalEntityDecl ( String name , String value ) throws SAXException ; public abstract void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLFrameSetElementImpl extends HTMLElementImpl implements HTMLFrameSetElement { public String getCols ( ) { return getAttribute ( "cols" ) ; } public void setCols ( String cols ) { setAttribute ( "cols" , cols ) ; } public String getRows ( ) { return getAttribute ( "rows" ) ; } public void setRows ( String rows ) { setAttribute ( "rows" , rows ) ; } public HTMLFrameSetElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . validators . schema ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . validators . common . Grammar ; import org . apache . xerces . validators . common . GrammarResolver ; import org . apache . xerces . validators . common . GrammarResolverImpl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . schema . XUtil ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . utils . StringPool ; import org . w3c . dom . Element ; import org . w3c . dom . * ; import java . util . * ; import java . net . URL ; import java . net . MalformedURLException ; import org . apache . xerces . parsers . DOMParser ; import org . apache . xerces . validators . common . XMLValidator ; import org . apache . xerces . validators . datatype . DatatypeValidator . * ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . parsers . SAXParser ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . framework . XMLDocumentScanner ; import org . xml . sax . InputSource ; import org . xml . sax . SAXParseException ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import java . io . IOException ; import org . w3c . dom . Document ; import org . apache . xml . serialize . OutputFormat ; import org . apache . xml . serialize . XMLSerializer ; import org . apache . xerces . validators . schema . SchemaSymbols ; public class TraverseSchema implements NamespacesScope . NamespacesHandler { private static final int TOP_LEVEL_SCOPE = - 1 ; private static boolean DEBUGGING = false ; private XMLErrorReporter fErrorReporter = null ; private StringPool fStringPool = null ; private GrammarResolver fGrammarResolver = null ; private SchemaGrammar fSchemaGrammar = null ; private Element fSchemaRootElement ; private DatatypeValidatorFactoryImpl fDatatypeRegistry = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; private Hashtable fComplexTypeRegistry = new Hashtable ( ) ; private Hashtable fAttributeDeclRegistry = new Hashtable ( ) ; private Vector fIncludeLocations = new Vector ( ) ; private Vector fImportLocations = new Vector ( ) ; private int fAnonTypeCount = 0 ; private int fScopeCount = 0 ; private int fCurrentScope = TOP_LEVEL_SCOPE ; private int fSimpleTypeAnonCount = 0 ; private Stack fCurrentTypeNameStack = new Stack ( ) ; private Hashtable fElementRecurseComplex = new Hashtable ( ) ; private boolean fElementDefaultQualified = false ; private boolean fAttributeDefaultQualified = false ; private int fTargetNSURI ; private String fTargetNSURIString = "" ; private NamespacesScope fNamespacesScope = null ; private String fCurrentSchemaURL = "" ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; public class ComplexTypeInfo { public String typeName ; public DatatypeValidator baseDataTypeValidator ; public ComplexTypeInfo baseComplexTypeInfo ; public int derivedBy = 0 ; public int blockSet = 0 ; public int finalSet = 0 ; public boolean isAbstract = false ; public int scopeDefined = - 1 ; public int contentType ; public int contentSpecHandle = - 1 ; public int templateElementIndex = - 1 ; public int attlistHead = - 1 ; public DatatypeValidator datatypeValidator ; } public final static String SchemaForSchemaURI = "http://www.w3.org/TR-1/Schema" ; private TraverseSchema ( ) { } public void setGrammarResolver ( GrammarResolver grammarResolver ) { fGrammarResolver = grammarResolver ; } public void startNamespaceDeclScope ( int prefix , int uri ) { } public void endNamespaceDeclScope ( int prefix ) { } private String resolvePrefixToURI ( String prefix ) throws Exception { String uriStr = fStringPool . toString ( fNamespacesScope . getNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) ) ) ; if ( uriStr == null ) { reportGenericSchemaError ( "prefix : [" + prefix + "] can not be resolved to a URI" ) ; return "" ; } if ( prefix . length ( ) == 0 && uriStr . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && fTargetNSURIString . length ( ) == 0 ) { uriStr = "" ; } return uriStr ; } public TraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver , XMLErrorReporter errorReporter , String schemaURL ) throws Exception { fErrorReporter = errorReporter ; fCurrentSchemaURL = schemaURL ; doTraverseSchema ( root , stringPool , schemaGrammar , grammarResolver ) ; } public TraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver ) throws Exception { doTraverseSchema ( root , stringPool , schemaGrammar , grammarResolver ) ; } public void doTraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver ) throws Exception { fNamespacesScope = new NamespacesScope ( this ) ; fSchemaRootElement = root ; fStringPool = stringPool ; fSchemaGrammar = schemaGrammar ; fGrammarResolver = grammarResolver ; if ( root == null ) { return ; } String rootPrefix = root . getPrefix ( ) ; if ( rootPrefix == null || rootPrefix . length ( ) == 0 ) { String xmlns = root . getAttribute ( "xmlns" ) ; if ( xmlns . length ( ) == 0 ) root . setAttribute ( "xmlns" , SchemaSymbols . URI_SCHEMAFORSCHEMA ) ; } fTargetNSURIString = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( fTargetNSURIString == null ) { fTargetNSURIString = "" ; } fTargetNSURI = fStringPool . addSymbol ( fTargetNSURIString ) ; if ( fGrammarResolver == null ) { reportGenericSchemaError ( "Internal error: don't have a GrammarResolver for TraverseSchema" ) ; } else { fSchemaGrammar . setComplexTypeRegistry ( fComplexTypeRegistry ) ; fSchemaGrammar . setDatatypeRegistry ( fDatatypeRegistry ) ; fSchemaGrammar . setAttributeDeclRegistry ( fAttributeDeclRegistry ) ; fSchemaGrammar . setNamespacesScope ( fNamespacesScope ) ; fSchemaGrammar . setTargetNamespaceURI ( fTargetNSURIString ) ; fGrammarResolver . putGrammar ( fTargetNSURIString , fSchemaGrammar ) ; } NamedNodeMap schemaEltAttrs = root . getAttributes ( ) ; int i = 0 ; Attr sattr = null ; boolean seenXMLNS = false ; while ( ( sattr = ( Attr ) schemaEltAttrs . item ( i ++ ) ) != null ) { String attName = sattr . getName ( ) ; if ( attName . startsWith ( "xmlns:" ) ) { String attValue = sattr . getValue ( ) ; String prefix = attName . substring ( attName . indexOf ( ":" ) + 1 ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) , fStringPool . addSymbol ( attValue ) ) ; } if ( attName . equals ( "xmlns" ) ) { String attValue = sattr . getValue ( ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( attValue ) ) ; seenXMLNS = true ; } } if ( ! seenXMLNS && fTargetNSURIString . length ( ) == 0 ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } fElementDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ELEMENTFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; fAttributeDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ATTRIBUTEFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; if ( fTargetNSURI == StringPool . EMPTY_STRING ) { fElementDefaultQualified = true ; } fCurrentScope = - 1 ; checkTopLevelDuplicateNames ( root ) ; extractTopLevel3Components ( root ) ; for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { traverseSimpleTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { traverseComplexTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ELEMENT ) ) { traverseElementDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , null ) ; } else if ( name . equals ( SchemaSymbols . ELT_WILDCARD ) ) { traverseWildcardDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { } else if ( name . equals ( SchemaSymbols . ELT_NOTATION ) ) { ; } else if ( name . equals ( SchemaSymbols . ELT_INCLUDE ) ) { traverseInclude ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_IMPORT ) ) { traverseImport ( child ) ; } } } private void checkTopLevelDuplicateNames ( Element root ) { } private void extractTopLevel3Components ( Element root ) { for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { fSchemaGrammar . topLevelAttrGrpDecls . put ( name , child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { fSchemaGrammar . topLevelAttrDecls . put ( name , child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { fSchemaGrammar . topLevelGroupDecls . put ( name , child ) ; } } } private String expandSystemId ( String systemId , String currentSystemId ) throws Exception { String id = systemId ; if ( id == null || id . length ( ) == 0 ) { return systemId ; } try { URL url = new URL ( id ) ; if ( url != null ) { return systemId ; } } catch ( MalformedURLException e ) { } id = fixURI ( id ) ; URL base = null ; URL url = null ; try { if ( currentSystemId == null ) { String dir ; try { dir = fixURI ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { dir = "" ; } if ( ! dir . endsWith ( "/" ) ) { dir = dir + "/" ; } base = new URL ( "file" , "" , dir ) ; } else { base = new URL ( currentSystemId ) ; } url = new URL ( base , id ) ; } catch ( Exception e ) { } if ( url == null ) { return systemId ; } return url . toString ( ) ; } private static String fixURI ( String str ) { str = str . replace ( java . io . File . separatorChar , '/' ) ; if ( str . length ( ) >= 2 ) { char ch1 = str . charAt ( 1 ) ; if ( ch1 == ':' ) { char ch0 = Character . toUpperCase ( str . charAt ( 0 ) ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { str = "/" + str ; } } } return str ; } private void traverseInclude ( Element includeDecl ) throws Exception { String location = includeDecl . getAttribute ( SchemaSymbols . ATT_SCHEMALOCATION ) ; location = expandSystemId ( location , fCurrentSchemaURL ) ; if ( fIncludeLocations . contains ( ( Object ) location ) ) { return ; } fIncludeLocations . addElement ( ( Object ) location ) ; DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( location ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { } Document document = parser . getDocument ( ) ; Element root = null ; if ( document != null ) { root = document . getDocumentElement ( ) ; } if ( root != null ) { String targetNSURI = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( targetNSURI . length ( ) > 0 && ! targetNSURI . equals ( fTargetNSURIString ) ) { reportGenericSchemaError ( "included schema '" + location + "' has a different targetNameSpace '" + targetNSURI + "'" ) ; } else { boolean saveElementDefaultQualified = fElementDefaultQualified ; boolean saveAttributeDefaultQualified = fAttributeDefaultQualified ; int saveScope = fCurrentScope ; String savedSchemaURL = fCurrentSchemaURL ; Element saveRoot = fSchemaRootElement ; fSchemaRootElement = root ; fCurrentSchemaURL = location ; traverseIncludedSchema ( root ) ; fCurrentSchemaURL = savedSchemaURL ; fCurrentScope = saveScope ; fElementDefaultQualified = saveElementDefaultQualified ; fAttributeDefaultQualified = saveAttributeDefaultQualified ; fSchemaRootElement = saveRoot ; } } } private void traverseIncludedSchema ( Element root ) throws Exception { NamedNodeMap schemaEltAttrs = root . getAttributes ( ) ; int i = 0 ; Attr sattr = null ; boolean seenXMLNS = false ; while ( ( sattr = ( Attr ) schemaEltAttrs . item ( i ++ ) ) != null ) { String attName = sattr . getName ( ) ; if ( attName . startsWith ( "xmlns:" ) ) { String attValue = sattr . getValue ( ) ; String prefix = attName . substring ( attName . indexOf ( ":" ) + 1 ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) , fStringPool . addSymbol ( attValue ) ) ; } if ( attName . equals ( "xmlns" ) ) { String attValue = sattr . getValue ( ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( attValue ) ) ; seenXMLNS = true ; } } if ( ! seenXMLNS && fTargetNSURIString . length ( ) == 0 ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } fElementDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ELEMENTFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; fAttributeDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ATTRIBUTEFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; if ( fTargetNSURI == StringPool . EMPTY_STRING ) { fElementDefaultQualified = true ; } fCurrentScope = - 1 ; checkTopLevelDuplicateNames ( root ) ; extractTopLevel3Components ( root ) ; for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { traverseSimpleTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { traverseComplexTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ELEMENT ) ) { traverseElementDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , null ) ; } else if ( name . equals ( SchemaSymbols . ELT_WILDCARD ) ) { traverseWildcardDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { } else if ( name . equals ( SchemaSymbols . ELT_NOTATION ) ) { ; } else if ( name . equals ( SchemaSymbols . ELT_INCLUDE ) ) { traverseInclude ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_IMPORT ) ) { traverseImport ( child ) ; } } } private void traverseImport ( Element importDecl ) throws Exception { String location = importDecl . getAttribute ( SchemaSymbols . ATT_SCHEMALOCATION ) ; location = expandSystemId ( location , fCurrentSchemaURL ) ; String namespaceString = importDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) ; SchemaGrammar importedGrammar = new SchemaGrammar ( ) ; if ( fGrammarResolver . getGrammar ( namespaceString ) != null ) { importedGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( namespaceString ) ; } if ( fImportLocations . contains ( ( Object ) location ) ) { return ; } fImportLocations . addElement ( ( Object ) location ) ; DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( location ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } Document document = parser . getDocument ( ) ; Element root = null ; if ( document != null ) { root = document . getDocumentElement ( ) ; } if ( root != null ) { String targetNSURI = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( ! targetNSURI . equals ( namespaceString ) ) { reportGenericSchemaError ( "imported schema '" + location + "' has a different targetNameSpace '" + targetNSURI + "' from what is declared '" + namespaceString + "'." ) ; } else new TraverseSchema ( root , fStringPool , importedGrammar , fGrammarResolver , fErrorReporter , location ) ; } else { reportGenericSchemaError ( "Could not get the doc root for imported Schema file: " + location ) ; } } private void traverseAnnotationDecl ( Element comment ) { return ; } private int traverseSimpleTypeDecl ( Element simpleTypeDecl ) throws Exception { String varietyProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_DERIVEDBY ) ; if ( varietyProperty . length ( ) == 0 ) { varietyProperty = SchemaSymbols . ATTVAL_RESTRICTION ; } String nameProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; String baseTypeQNameProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) ; String abstractProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) ; int newSimpleTypeName = - 1 ; if ( nameProperty . equals ( "" ) ) { newSimpleTypeName = fStringPool . addSymbol ( "#S#" + fSimpleTypeAnonCount ++ ) ; } else newSimpleTypeName = fStringPool . addSymbol ( nameProperty ) ; int basetype ; DatatypeValidator baseValidator = null ; if ( baseTypeQNameProperty != null ) { basetype = fStringPool . addSymbol ( baseTypeQNameProperty ) ; String prefix = "" ; String localpart = baseTypeQNameProperty ; int colonptr = baseTypeQNameProperty . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = baseTypeQNameProperty . substring ( 0 , colonptr ) ; localpart = baseTypeQNameProperty . substring ( colonptr + 1 ) ; } String uri = resolvePrefixToURI ( prefix ) ; baseValidator = getDatatypeValidator ( uri , localpart ) ; if ( baseValidator == null ) { Element baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( baseTypeNode != null ) { traverseSimpleTypeDecl ( baseTypeNode ) ; baseValidator = getDatatypeValidator ( uri , localpart ) ; if ( baseValidator == null ) { reportSchemaError ( SchemaMessageProvider . UnknownBaseDatatype , new Object [ ] { simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) , simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) } ) ; return - 1 ; } } else { reportSchemaError ( SchemaMessageProvider . UnknownBaseDatatype , new Object [ ] { simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) , simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) } ) ; return - 1 ; } } } Element content = XUtil . getFirstChildElement ( simpleTypeDecl ) ; int numFacets = 0 ; Hashtable facetData = null ; if ( content != null ) { if ( content . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content ) ; content = XUtil . getNextSiblingElement ( content ) ; } int numEnumerationLiterals = 0 ; facetData = new Hashtable ( ) ; Vector enumData = new Vector ( ) ; while ( content != null ) { if ( content . getNodeType ( ) == Node . ELEMENT_NODE ) { Element facetElt = ( Element ) content ; numFacets ++ ; if ( facetElt . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { numEnumerationLiterals ++ ; String enumVal = facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ; enumData . addElement ( enumVal ) ; Element enumContent = XUtil . getFirstChildElement ( facetElt ) ; if ( enumContent != null && enumContent != null && enumContent . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content ) ; } } else { facetData . put ( facetElt . getNodeName ( ) , facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; } } content = XUtil . getNextSiblingElement ( content ) ; } if ( numEnumerationLiterals > 0 ) { facetData . put ( SchemaSymbols . ELT_ENUMERATION , enumData ) ; } } String nameOfType = fStringPool . toString ( newSimpleTypeName ) ; if ( fTargetNSURIString . length ( ) != 0 ) { nameOfType = fTargetNSURIString + "," + nameOfType ; } try { DatatypeValidator newValidator = fDatatypeRegistry . getDatatypeValidator ( nameOfType ) ; if ( newValidator == null ) { boolean derivedByList = varietyProperty . equals ( SchemaSymbols . ATTVAL_LIST ) ? true : false ; fDatatypeRegistry . createDatatypeValidator ( nameOfType , baseValidator , facetData , derivedByList ) ; } } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . DatatypeError , new Object [ ] { e . getMessage ( ) } ) ; } return fStringPool . addSymbol ( nameOfType ) ; } private int traverseAny ( Element child ) throws Exception { int anyIndex = - 1 ; String namespace = child . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) . trim ( ) ; String processContents = child . getAttribute ( "processContents" ) . trim ( ) ; int processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY ; int processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ; int processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ; if ( processContents . length ( ) > 0 && ! processContents . equals ( "strict" ) ) { if ( processContents . equals ( "lax" ) ) { processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY_LAX ; processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_LAX ; processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_LAX ; } else if ( processContents . equals ( "skip" ) ) { processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY_SKIP ; processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_SKIP ; processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_SKIP ; } } if ( namespace . length ( ) == 0 || namespace . equals ( "##any" ) ) { anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , - 1 , false ) ; } else if ( namespace . equals ( "##other" ) ) { String uri = child . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; int uriIndex = fStringPool . addSymbol ( uri ) ; anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAnyOther , - 1 , uriIndex , false ) ; } else if ( namespace . equals ( "##local" ) ) { anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAnyLocal , - 1 , - 1 , false ) ; } else if ( namespace . length ( ) > 0 ) { StringTokenizer tokenizer = new StringTokenizer ( namespace ) ; Vector tokens = new Vector ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( "##targetNamespace" ) ) { token = child . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; } tokens . addElement ( token ) ; } String uri = ( String ) tokens . elementAt ( 0 ) ; int uriIndex = fStringPool . addSymbol ( uri ) ; int leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; int valueIndex = leafIndex ; int count = tokens . size ( ) ; if ( count > 1 ) { uri = ( String ) tokens . elementAt ( 1 ) ; uriIndex = fStringPool . addSymbol ( uri ) ; leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; int otherValueIndex = leafIndex ; int choiceIndex = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , valueIndex , otherValueIndex , false ) ; for ( int i = 2 ; i < count ; i ++ ) { uri = ( String ) tokens . elementAt ( i ) ; uriIndex = fStringPool . addSymbol ( uri ) ; leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; otherValueIndex = leafIndex ; choiceIndex = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , choiceIndex , otherValueIndex , false ) ; } anyIndex = choiceIndex ; } else { anyIndex = leafIndex ; } } else { reportGenericSchemaError ( "Empty namespace attribute for any element" ) ; } return anyIndex ; } public DatatypeValidator getDatatypeValidator ( String uri , String localpart ) { DatatypeValidator dv = null ; if ( uri . length ( ) == 0 || uri . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { dv = fDatatypeRegistry . getDatatypeValidator ( localpart ) ; } else { dv = fDatatypeRegistry . getDatatypeValidator ( uri + "," + localpart ) ; } return dv ; } private XMLAttributeDecl traverseAnyAttribute ( Element anyAttributeDecl ) throws Exception { XMLAttributeDecl anyAttDecl = new XMLAttributeDecl ( ) ; String processContents = anyAttributeDecl . getAttribute ( SchemaSymbols . ATT_PROCESSCONTENTS ) . trim ( ) ; String namespace = anyAttributeDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) . trim ( ) ; String curTargetUri = anyAttributeDecl . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; if ( namespace . length ( ) == 0 || namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDANY ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_ANY ; } else if ( namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDOTHER ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_OTHER ; anyAttDecl . name . uri = fStringPool . addSymbol ( curTargetUri ) ; } else if ( namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDLOCAL ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_LOCAL ; } else if ( namespace . length ( ) > 0 ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_LIST ; StringTokenizer tokenizer = new StringTokenizer ( namespace ) ; int aStringList = fStringPool . startStringList ( ) ; Vector tokens = new Vector ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( "##targetNamespace" ) ) { token = curTargetUri ; } if ( ! fStringPool . addStringToList ( aStringList , fStringPool . addSymbol ( token ) ) ) { reportGenericSchemaError ( "Internal StringPool error when reading the " + "namespace attribute for anyattribute declaration" ) ; } } fStringPool . finishStringList ( aStringList ) ; anyAttDecl . enumeration = aStringList ; } else { reportGenericSchemaError ( "Empty namespace attribute for anyattribute declaration" ) ; } anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_STRICT ; if ( processContents . equals ( SchemaSymbols . ATTVAL_SKIP ) ) { anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_SKIP ; } else if ( processContents . equals ( SchemaSymbols . ATTVAL_LAX ) ) { anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_LAX ; } return anyAttDecl ; } private XMLAttributeDecl mergeTwoAnyAttribute ( XMLAttributeDecl oneAny , XMLAttributeDecl anotherAny ) { if ( oneAny . type == - 1 ) { return oneAny ; } if ( anotherAny . type == - 1 ) { return anotherAny ; } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return anotherAny ; } if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return oneAny ; } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( anotherAny . name . uri == oneAny . name . uri ) { return oneAny ; } else { oneAny . type = - 1 ; return oneAny ; } } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { return anotherAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( ! fStringPool . stringInList ( anotherAny . enumeration , oneAny . name . uri ) ) { return anotherAny ; } else { int [ ] anotherAnyURIs = fStringPool . stringListAsIntArray ( anotherAny . enumeration ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < anotherAnyURIs . length ; i ++ ) { if ( anotherAnyURIs [ i ] != oneAny . name . uri ) { fStringPool . addStringToList ( newList , anotherAnyURIs [ i ] ) ; } } fStringPool . finishStringList ( newList ) ; anotherAny . enumeration = newList ; return anotherAny ; } } } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER || anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { return oneAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { oneAny . type = - 1 ; return oneAny ; } } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( ! fStringPool . stringInList ( oneAny . enumeration , anotherAny . name . uri ) ) { return oneAny ; } else { int [ ] oneAnyURIs = fStringPool . stringListAsIntArray ( oneAny . enumeration ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < oneAnyURIs . length ; i ++ ) { if ( oneAnyURIs [ i ] != anotherAny . name . uri ) { fStringPool . addStringToList ( newList , oneAnyURIs [ i ] ) ; } } fStringPool . finishStringList ( newList ) ; oneAny . enumeration = newList ; return oneAny ; } } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { oneAny . type = - 1 ; return oneAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { int [ ] result = intersect2sets ( fStringPool . stringListAsIntArray ( oneAny . enumeration ) , fStringPool . stringListAsIntArray ( anotherAny . enumeration ) ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < result . length ; i ++ ) { fStringPool . addStringToList ( newList , result [ i ] ) ; } fStringPool . finishStringList ( newList ) ; oneAny . enumeration = newList ; return oneAny ; } } return oneAny ; } int [ ] intersect2sets ( int [ ] one , int [ ] theOther ) { int [ ] result = new int [ ( one . length > theOther . length ? one . length : theOther . length ) ] ; int count = 0 ; for ( int i = 0 ; i < one . length ; i ++ ) { for ( int j = 0 ; j < theOther . length ; j ++ ) { if ( one [ i ] == theOther [ j ] ) { result [ count ++ ] = one [ i ] ; } } } int [ ] result2 = new int [ count ] ; System . arraycopy ( result , 0 , result2 , 0 , count ) ; return result2 ; } private int traverseComplexTypeDecl ( Element complexTypeDecl ) throws Exception { String isAbstract = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) ; String base = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) ; String blockSet = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ; String content = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_CONTENT ) ; String derivedBy = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_DERIVEDBY ) ; String finalSet = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ; String typeId = complexTypeDecl . getAttribute ( SchemaSymbols . ATTVAL_ID ) ; String typeName = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; boolean isNamedType = false ; if ( DEBUGGING ) System . out . println ( "traversing complex Type : " + typeName + "," + base + "," + content + "." ) ; if ( typeName . equals ( "" ) ) { typeName = "#" + fAnonTypeCount ++ ; } else { fCurrentTypeNameStack . push ( typeName ) ; isNamedType = true ; } if ( isTopLevel ( complexTypeDecl ) ) { String fullName = fTargetNSURIString + "," + typeName ; ComplexTypeInfo temp = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fullName ) ; if ( temp != null ) { return fStringPool . addSymbol ( fullName ) ; } } int scopeDefined = fScopeCount ++ ; int previousScope = fCurrentScope ; fCurrentScope = scopeDefined ; Element child = null ; int contentSpecType = - 1 ; int csnType = 0 ; int left = - 2 ; int right = - 2 ; ComplexTypeInfo baseTypeInfo = null ; DatatypeValidator baseTypeValidator = null ; DatatypeValidator simpleTypeValidator = null ; int baseTypeSymbol = - 1 ; String fullBaseName = "" ; boolean baseIsSimpleSimple = false ; boolean baseIsComplexSimple = false ; boolean derivedByRestriction = true ; boolean derivedByExtension = false ; int baseContentSpecHandle = - 1 ; Element baseTypeNode = null ; if ( base . length ( ) > 0 ) { if ( derivedBy . length ( ) == 0 ) { reportGenericSchemaError ( "derivedBy must be present when base is present in " + SchemaSymbols . ELT_COMPLEXTYPE + " " + typeName ) ; } else { if ( derivedBy . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { derivedByRestriction = false ; } String prefix = "" ; String localpart = base ; int colonptr = base . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = base . substring ( 0 , colonptr ) ; localpart = base . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String typeURI = resolvePrefixToURI ( prefix ) ; if ( ! typeURI . equals ( fTargetNSURIString ) && ! typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && typeURI . length ( ) != 0 ) { baseTypeInfo = getTypeInfoFromNS ( typeURI , localpart ) ; if ( baseTypeInfo == null ) { baseTypeValidator = getTypeValidatorFromNS ( typeURI , localpart ) ; if ( baseTypeValidator == null ) { System . out . println ( "Could not find base type " + localpart + " in schema " + typeURI ) ; } else { baseIsSimpleSimple = true ; } } } else { fullBaseName = typeURI + "," + localpart ; baseTypeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fullBaseName ) ; if ( baseTypeInfo == null ) { baseTypeValidator = getDatatypeValidator ( typeURI , localpart ) ; if ( baseTypeValidator == null ) { baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_COMPLEXTYPE , localpart ) ; if ( baseTypeNode != null ) { baseTypeSymbol = traverseComplexTypeDecl ( baseTypeNode ) ; baseTypeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( baseTypeSymbol ) ) ; } else { baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( baseTypeNode != null ) { baseTypeSymbol = traverseSimpleTypeDecl ( baseTypeNode ) ; simpleTypeValidator = baseTypeValidator = getDatatypeValidator ( typeURI , localpart ) ; if ( simpleTypeValidator == null ) { } baseIsSimpleSimple = true ; } else { reportGenericSchemaError ( "Base type could not be found : " + base ) ; } } } else { simpleTypeValidator = baseTypeValidator ; baseIsSimpleSimple = true ; } } } if ( baseIsSimpleSimple && derivedByRestriction ) { reportGenericSchemaError ( "base is a simpledType, can't derive by restriction in " + typeName ) ; } if ( baseTypeInfo != null ) { if ( derivedByRestriction ) { } else { } if ( baseTypeInfo . contentSpecHandle > - 1 ) { if ( derivedByRestriction ) { checkParticleDerivationOK ( complexTypeDecl , baseTypeNode ) ; } baseContentSpecHandle = baseTypeInfo . contentSpecHandle ; } else if ( baseTypeInfo . datatypeValidator != null ) { baseTypeValidator = baseTypeInfo . datatypeValidator ; baseIsComplexSimple = true ; } } if ( baseIsComplexSimple && ! derivedByRestriction ) { reportGenericSchemaError ( "base is ComplexSimple, can't derive by extension in " + typeName ) ; } } } child = null ; if ( baseIsComplexSimple ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; int numEnumerationLiterals = 0 ; int numFacets = 0 ; Hashtable facetData = new Hashtable ( ) ; Vector enumData = new Vector ( ) ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null && ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MININCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PRECISION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SCALE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_LENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MINLENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXLENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENCODING ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PERIOD ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_DURATION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PATTERN ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { Element facetElt = ( Element ) child ; numFacets ++ ; if ( facetElt . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { numEnumerationLiterals ++ ; enumData . addElement ( facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; Element enumContent = XUtil . getFirstChildElement ( facetElt ) ; if ( enumContent != null && enumContent . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } } else { facetData . put ( facetElt . getNodeName ( ) , facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; } } } if ( numEnumerationLiterals > 0 ) { facetData . put ( SchemaSymbols . ELT_ENUMERATION , enumData ) ; } if ( numFacets > 0 ) { simpleTypeValidator = fDatatypeRegistry . createDatatypeValidator ( typeName , baseTypeValidator , facetData , false ) ; } else simpleTypeValidator = baseTypeValidator ; if ( child != null ) { reportGenericSchemaError ( "Invalid child '" + child . getNodeName ( ) + "' in complexType : '" + typeName + "', because it restricts another complexSimpleType" ) ; } } if ( content . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { if ( base . length ( ) == 0 ) { simpleTypeValidator = baseTypeValidator = getDatatypeValidator ( "" , SchemaSymbols . ATTVAL_STRING ) ; } else if ( baseTypeValidator == null && baseTypeInfo != null && baseTypeInfo . datatypeValidator == null ) reportSchemaError ( SchemaMessageProvider . NotADatatype , new Object [ ] { base } ) ; contentSpecType = XMLElementDecl . TYPE_SIMPLE ; } else { if ( ! baseIsComplexSimple ) { contentSpecType = XMLElementDecl . TYPE_CHILDREN ; } csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; boolean mixedContent = false ; boolean elementContent = true ; boolean textContent = false ; boolean emptyContent = false ; left = - 2 ; right = - 2 ; boolean hadContent = false ; if ( content . equals ( SchemaSymbols . ATTVAL_EMPTY ) ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; emptyContent = true ; elementContent = false ; left = - 1 ; } else if ( content . equals ( SchemaSymbols . ATTVAL_MIXED ) ) { contentSpecType = XMLElementDecl . TYPE_MIXED ; mixedContent = true ; elementContent = false ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; } else if ( content . equals ( SchemaSymbols . ATTVAL_ELEMENTONLY ) || content . equals ( "" ) ) { elementContent = true ; } else if ( content . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { textContent = true ; elementContent = false ; } if ( mixedContent ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , - 1 , - 1 , false ) ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; } boolean seeParticle = false ; boolean seeOtherParticle = false ; boolean seeAll = false ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { if ( mixedContent || elementContent ) { if ( DEBUGGING ) System . out . println ( " child element name " + child . getAttribute ( SchemaSymbols . ATT_NAME ) ) ; QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; seeOtherParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . EltRefOnlyInMixedElemOnly , null ) ; } } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeParticle = true ; seeAll = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTE ) || childName . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { break ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } else if ( childName . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { break ; } else { if ( ! baseIsComplexSimple ) if ( base . equals ( "" ) ) reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "unrecogized child '" + childName + "' in compelx type " + typeName } ) ; else reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "unrecogized child '" + childName + "' in compelx type '" + typeName + "' with base " + base } ) ; } if ( baseIsComplexSimple && seeParticle ) { reportGenericSchemaError ( "In complexType " + typeName + ", base type is complextype with simpleType content, can't have any particle children at all" ) ; hadContent = false ; left = index = - 2 ; contentSpecType = XMLElementDecl . TYPE_SIMPLE ; break ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( seeAll && seeOtherParticle ) { reportGenericSchemaError ( " 'All' group needs to be the only child in Complextype : " + typeName ) ; } if ( seeAll ) { } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( ! ( seeOtherParticle || seeAll ) && ( elementContent || mixedContent ) && ( base . length ( ) == 0 || ( base . length ( ) > 0 && derivedByRestriction && ! baseIsComplexSimple ) ) ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; simpleTypeValidator = getDatatypeValidator ( "" , SchemaSymbols . ATTVAL_STRING ) ; reportGenericSchemaError ( " complexType '" + typeName + "' with a elementOnly or mixed content " + "need to have at least one particle child" ) ; } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; if ( mixedContent && hadContent ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , left , - 1 , false ) ; } } if ( ! derivedByRestriction && baseContentSpecHandle > - 1 ) { if ( left == - 2 ) { left = baseContentSpecHandle ; } else left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , baseContentSpecHandle , left , false ) ; } if ( content . length ( ) == 0 && base . length ( ) == 0 && left == - 2 ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } if ( content . length ( ) == 0 && simpleTypeValidator == null && left == - 2 ) { if ( base . length ( ) > 0 && baseTypeInfo != null && baseTypeInfo . contentType == XMLElementDecl . TYPE_EMPTY ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; } } if ( DEBUGGING ) System . out . println ( "!!!!!>>>>>" + typeName + ", " + baseTypeInfo + ", " + baseContentSpecHandle + ", " + left + ", " + scopeDefined ) ; ComplexTypeInfo typeInfo = new ComplexTypeInfo ( ) ; typeInfo . baseComplexTypeInfo = baseTypeInfo ; typeInfo . baseDataTypeValidator = baseTypeValidator ; int derivedByInt = - 1 ; if ( derivedBy . length ( ) > 0 ) { derivedByInt = parseComplexDerivedBy ( derivedBy ) ; } typeInfo . derivedBy = derivedByInt ; typeInfo . scopeDefined = scopeDefined ; typeInfo . contentSpecHandle = left ; typeInfo . contentType = contentSpecType ; typeInfo . datatypeValidator = simpleTypeValidator ; typeInfo . blockSet = parseBlockSet ( complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ) ; typeInfo . finalSet = parseFinalSet ( complexTypeDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ) ; typeInfo . isAbstract = isAbstract . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; int typeNameIndex = fStringPool . addSymbol ( typeName ) ; int templateElementNameIndex = fStringPool . addSymbol ( "$" + typeName ) ; typeInfo . templateElementIndex = fSchemaGrammar . addElementDecl ( new QName ( - 1 , templateElementNameIndex , typeNameIndex , fTargetNSURI ) , ( fTargetNSURI == - 1 ) ? - 1 : fCurrentScope , scopeDefined , contentSpecType , left , - 1 , simpleTypeValidator ) ; typeInfo . attlistHead = fSchemaGrammar . getFirstAttributeDeclIndex ( typeInfo . templateElementIndex ) ; XMLAttributeDecl attWildcard = null ; Vector anyAttDecls = new Vector ( ) ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { if ( ( baseIsComplexSimple || baseIsSimpleSimple ) && derivedByRestriction ) { reportGenericSchemaError ( "In complexType " + typeName + ", base type has simpleType " + "content and derivation method is" + " 'restriction', can't have any " + "attribute children at all" ) ; break ; } traverseAttributeDecl ( child , typeInfo ) ; } else if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { if ( ( baseIsComplexSimple || baseIsSimpleSimple ) && derivedByRestriction ) { reportGenericSchemaError ( "In complexType " + typeName + ", base " + "type has simpleType content and " + "derivation method is 'restriction'," + " can't have any attribute children at all" ) ; break ; } traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( childName . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { attWildcard = traverseAnyAttribute ( child ) ; } } if ( attWildcard != null ) { XMLAttributeDecl fromGroup = null ; final int count = anyAttDecls . size ( ) ; if ( count > 0 ) { fromGroup = ( XMLAttributeDecl ) anyAttDecls . elementAt ( 0 ) ; for ( int i = 1 ; i < count ; i ++ ) { fromGroup = mergeTwoAnyAttribute ( fromGroup , ( XMLAttributeDecl ) anyAttDecls . elementAt ( i ) ) ; } } if ( fromGroup != null ) { int saveProcessContents = attWildcard . defaultType ; attWildcard = mergeTwoAnyAttribute ( attWildcard , fromGroup ) ; attWildcard . defaultType = saveProcessContents ; } } else { } XMLAttributeDecl baseAttWildcard = null ; if ( baseTypeInfo != null && baseTypeInfo . attlistHead > - 1 ) { int attDefIndex = baseTypeInfo . attlistHead ; while ( attDefIndex > - 1 ) { fTempAttributeDecl . clear ( ) ; fSchemaGrammar . getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_ANY || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_LIST || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( attWildcard == null ) { baseAttWildcard = fTempAttributeDecl ; } attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; continue ; } int temp = fSchemaGrammar . getAttributeDeclIndex ( typeInfo . templateElementIndex , fTempAttributeDecl . name ) ; if ( temp > - 1 ) { if ( derivedByRestriction ) { attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; continue ; } } fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , fTempAttributeDecl . name , fTempAttributeDecl . type , fTempAttributeDecl . enumeration , fTempAttributeDecl . defaultType , fTempAttributeDecl . defaultValue , fTempAttributeDecl . datatypeValidator , fTempAttributeDecl . list ) ; attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } if ( attWildcard != null ) { if ( attWildcard . type != - 1 ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , attWildcard . name , attWildcard . type , attWildcard . enumeration , attWildcard . defaultType , attWildcard . defaultValue , attWildcard . datatypeValidator , attWildcard . list ) ; } else { } } else if ( baseAttWildcard != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , baseAttWildcard . name , baseAttWildcard . type , baseAttWildcard . enumeration , baseAttWildcard . defaultType , baseAttWildcard . defaultValue , baseAttWildcard . datatypeValidator , baseAttWildcard . list ) ; } typeInfo . attlistHead = fSchemaGrammar . getFirstAttributeDeclIndex ( typeInfo . templateElementIndex ) ; if ( ! typeName . startsWith ( "#" ) ) { typeName = fTargetNSURIString + "," + typeName ; } typeInfo . typeName = new String ( typeName ) ; if ( DEBUGGING ) System . out . println ( "add complex Type to Registry: " + typeName + "," + content + "." ) ; fComplexTypeRegistry . put ( typeName , typeInfo ) ; fCurrentScope = previousScope ; if ( isNamedType ) { fCurrentTypeNameStack . pop ( ) ; checkRecursingComplexType ( ) ; } fSchemaGrammar . setElementComplexTypeInfo ( typeInfo . templateElementIndex , typeInfo ) ; typeNameIndex = fStringPool . addSymbol ( typeName ) ; return typeNameIndex ; } private void checkRecursingComplexType ( ) throws Exception { if ( fCurrentTypeNameStack . empty ( ) ) { if ( ! fElementRecurseComplex . isEmpty ( ) ) { Enumeration e = fElementRecurseComplex . keys ( ) ; while ( e . hasMoreElements ( ) ) { QName nameThenScope = ( QName ) e . nextElement ( ) ; String typeName = ( String ) fElementRecurseComplex . get ( nameThenScope ) ; int eltUriIndex = nameThenScope . uri ; int eltNameIndex = nameThenScope . localpart ; int enclosingScope = nameThenScope . prefix ; ComplexTypeInfo typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fTargetNSURIString + "," + typeName ) ; if ( typeInfo == null ) { throw new Exception ( "Internal Error in void checkRecursingComplexType(). " ) ; } else { int elementIndex = fSchemaGrammar . addElementDecl ( new QName ( - 1 , eltNameIndex , eltNameIndex , eltUriIndex ) , enclosingScope , typeInfo . scopeDefined , typeInfo . contentType , typeInfo . contentSpecHandle , typeInfo . attlistHead , typeInfo . datatypeValidator ) ; fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } } fElementRecurseComplex . clear ( ) ; } } } private void checkParticleDerivationOK ( Element derivedTypeNode , Element baseTypeNode ) { } private int expandContentModel ( int index , Element particle ) throws Exception { String minOccurs = particle . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ; String maxOccurs = particle . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ; int min = 1 , max = 1 ; if ( minOccurs . equals ( "" ) ) { minOccurs = "1" ; } if ( maxOccurs . equals ( "" ) ) { if ( minOccurs . equals ( "0" ) ) { maxOccurs = "1" ; } else { maxOccurs = minOccurs ; } } int leafIndex = index ; if ( minOccurs . equals ( "1" ) && maxOccurs . equals ( "1" ) ) { } else if ( minOccurs . equals ( "0" ) && maxOccurs . equals ( "1" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , index , - 1 , false ) ; } else if ( minOccurs . equals ( "0" ) && maxOccurs . equals ( "unbounded" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , index , - 1 , false ) ; } else if ( minOccurs . equals ( "1" ) && maxOccurs . equals ( "unbounded" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , index , - 1 , false ) ; } else if ( maxOccurs . equals ( "unbounded" ) ) { try { min = Integer . parseInt ( minOccurs ) ; } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "illegal value for minOccurs : '" + e . getMessage ( ) + "' " } ) ; } if ( min < 2 ) { } index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , index , - 1 , false ) ; for ( int i = 0 ; i < ( min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , leafIndex , index , false ) ; } } else { try { min = Integer . parseInt ( minOccurs ) ; max = Integer . parseInt ( maxOccurs ) ; } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "illegal value for minOccurs or maxOccurs : '" + e . getMessage ( ) + "' " } ) ; } if ( min == 0 ) { int optional = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , leafIndex , - 1 , false ) ; index = optional ; for ( int i = 0 ; i < ( max - min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , optional , false ) ; } } else { for ( int i = 0 ; i < ( min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , leafIndex , false ) ; } int optional = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , leafIndex , - 1 , false ) ; for ( int i = 0 ; i < ( max - min ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , optional , false ) ; } } } return index ; } private int traverseAttributeDecl ( Element attrDecl , ComplexTypeInfo typeInfo ) throws Exception { String attNameStr = attrDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; int attName = fStringPool . addSymbol ( attNameStr ) ; String isQName = attrDecl . getAttribute ( SchemaSymbols . ATT_FORM ) ; DatatypeValidator dv = null ; int attType = - 1 ; boolean attIsList = false ; int dataTypeSymbol = - 1 ; String ref = attrDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; String datatype = attrDecl . getAttribute ( SchemaSymbols . ATT_TYPE ) ; String localpart = null ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( attrDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { addAttributeDeclFromAnotherSchema ( localpart , uriStr , typeInfo ) ; return - 1 ; } Element referredAttribute = getTopLevelComponentByName ( SchemaSymbols . ELT_ATTRIBUTE , localpart ) ; if ( referredAttribute != null ) { traverseAttributeDecl ( referredAttribute , typeInfo ) ; } else { reportGenericSchemaError ( "Couldn't find top level attribute " + ref ) ; } return - 1 ; } if ( datatype . equals ( "" ) ) { Element child = XUtil . getFirstChildElement ( attrDecl ) ; while ( child != null && ! child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) child = XUtil . getNextSiblingElement ( child ) ; if ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { attType = XMLAttributeDecl . TYPE_SIMPLE ; dataTypeSymbol = traverseSimpleTypeDecl ( child ) ; localpart = fStringPool . toString ( dataTypeSymbol ) ; } else { attType = XMLAttributeDecl . TYPE_SIMPLE ; localpart = "string" ; dataTypeSymbol = fStringPool . addSymbol ( localpart ) ; } localpart = fStringPool . toString ( dataTypeSymbol ) ; dv = fDatatypeRegistry . getDatatypeValidator ( localpart ) ; } else { String prefix = "" ; localpart = datatype ; dataTypeSymbol = fStringPool . addSymbol ( localpart ) ; int colonptr = datatype . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = datatype . substring ( 0 , colonptr ) ; localpart = datatype . substring ( colonptr + 1 ) ; } String typeURI = resolvePrefixToURI ( prefix ) ; if ( typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) || typeURI . length ( ) == 0 ) { dv = getDatatypeValidator ( "" , localpart ) ; if ( localpart . equals ( "ID" ) ) { attType = XMLAttributeDecl . TYPE_ID ; } else if ( localpart . equals ( "IDREF" ) ) { attType = XMLAttributeDecl . TYPE_IDREF ; } else if ( localpart . equals ( "IDREFS" ) ) { attType = XMLAttributeDecl . TYPE_IDREF ; attIsList = true ; } else if ( localpart . equals ( "ENTITY" ) ) { attType = XMLAttributeDecl . TYPE_ENTITY ; } else if ( localpart . equals ( "ENTITIES" ) ) { attType = XMLAttributeDecl . TYPE_ENTITY ; attIsList = true ; } else if ( localpart . equals ( "NMTOKEN" ) ) { attType = XMLAttributeDecl . TYPE_NMTOKEN ; } else if ( localpart . equals ( "NMTOKENS" ) ) { attType = XMLAttributeDecl . TYPE_NMTOKEN ; attIsList = true ; } else if ( localpart . equals ( SchemaSymbols . ELT_NOTATION ) ) { attType = XMLAttributeDecl . TYPE_NOTATION ; } else { attType = XMLAttributeDecl . TYPE_SIMPLE ; if ( dv == null && typeURI . length ( ) == 0 ) { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { reportGenericSchemaError ( "simpleType not found : " + localpart ) ; } } } } else { dv = getDatatypeValidator ( typeURI , localpart ) ; if ( dv == null && typeURI . equals ( fTargetNSURIString ) ) { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { reportGenericSchemaError ( "simpleType not found : " + localpart ) ; } } attType = XMLAttributeDecl . TYPE_SIMPLE ; } } int attDefaultType = - 1 ; int attDefaultValue = - 1 ; String use = attrDecl . getAttribute ( SchemaSymbols . ATT_USE ) ; boolean required = use . equals ( SchemaSymbols . ATTVAL_REQUIRED ) ; if ( dv == null ) { reportGenericSchemaError ( "could not resolve the type or get a null validator for datatype : " + fStringPool . toString ( dataTypeSymbol ) ) ; } if ( required ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; } else { if ( use . equals ( SchemaSymbols . ATTVAL_FIXED ) ) { String fixed = attrDecl . getAttribute ( SchemaSymbols . ATT_VALUE ) ; if ( ! fixed . equals ( "" ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_FIXED ; attDefaultValue = fStringPool . addString ( fixed ) ; } } else if ( use . equals ( SchemaSymbols . ATTVAL_DEFAULT ) ) { String defaultValue = attrDecl . getAttribute ( SchemaSymbols . ATT_VALUE ) ; if ( ! defaultValue . equals ( "" ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_DEFAULT ; attDefaultValue = fStringPool . addString ( defaultValue ) ; } } else if ( use . equals ( SchemaSymbols . ATTVAL_PROHIBITED ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } else { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } if ( attType == XMLAttributeDecl . TYPE_SIMPLE && attDefaultValue != - 1 ) { try { if ( dv != null ) dv . validate ( fStringPool . toString ( attDefaultValue ) , null ) ; else reportSchemaError ( SchemaMessageProvider . NoValidatorFor , new Object [ ] { datatype } ) ; } catch ( InvalidDatatypeValueException idve ) { reportSchemaError ( SchemaMessageProvider . IncorrectDefaultType , new Object [ ] { attrDecl . getAttribute ( SchemaSymbols . ATT_NAME ) , idve . getMessage ( ) } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . out . println ( "Internal error in attribute datatype validation" ) ; } } } int uriIndex = - 1 ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fAttributeDefaultQualified || isTopLevel ( attrDecl ) ) { uriIndex = fTargetNSURI ; } QName attQName = new QName ( - 1 , attName , attName , uriIndex ) ; if ( DEBUGGING ) System . out . println ( " the dataType Validator for " + fStringPool . toString ( attName ) + " is " + dv ) ; if ( isTopLevel ( attrDecl ) ) { fTempAttributeDecl . datatypeValidator = dv ; fTempAttributeDecl . name . setValues ( attQName ) ; fTempAttributeDecl . type = attType ; fTempAttributeDecl . defaultType = attDefaultType ; fTempAttributeDecl . list = attIsList ; if ( attDefaultValue != - 1 ) { fTempAttributeDecl . defaultValue = new String ( fStringPool . toString ( attDefaultValue ) ) ; } fAttributeDeclRegistry . put ( attNameStr , new XMLAttributeDecl ( fTempAttributeDecl ) ) ; } if ( typeInfo != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , attQName , attType , dataTypeSymbol , attDefaultType , fStringPool . toString ( attDefaultValue ) , dv , attIsList ) ; } return - 1 ; } private int addAttributeDeclFromAnotherSchema ( String name , String uriStr , ComplexTypeInfo typeInfo ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #addAttributeDeclFromAnotherSchema, schema uri : " + uriStr ) ; return - 1 ; } Hashtable attrRegistry = aGrammar . getAttirubteDeclRegistry ( ) ; if ( attrRegistry == null ) { reportGenericSchemaError ( "no attribute was defined in schema : " + uriStr ) ; return - 1 ; } XMLAttributeDecl tempAttrDecl = ( XMLAttributeDecl ) attrRegistry . get ( name ) ; if ( tempAttrDecl == null ) { reportGenericSchemaError ( "no attribute named \"" + name + "\" was defined in schema : " + uriStr ) ; return - 1 ; } if ( typeInfo != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , tempAttrDecl . name , tempAttrDecl . type , - 1 , tempAttrDecl . defaultType , tempAttrDecl . defaultValue , tempAttrDecl . datatypeValidator , tempAttrDecl . list ) ; } return 0 ; } private int traverseAttributeGroupDecl ( Element attrGrpDecl , ComplexTypeInfo typeInfo , Vector anyAttDecls ) throws Exception { int attGrpName = fStringPool . addSymbol ( attrGrpDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ) ; String ref = attrGrpDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; int attType = - 1 ; int enumeration = - 1 ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( attrGrpDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { traverseAttributeGroupDeclFromAnotherSchema ( localpart , uriStr , typeInfo , anyAttDecls ) ; return - 1 ; } Element referredAttrGrp = getTopLevelComponentByName ( SchemaSymbols . ELT_ATTRIBUTEGROUP , localpart ) ; if ( referredAttrGrp != null ) { traverseAttributeGroupDecl ( referredAttrGrp , typeInfo , anyAttDecls ) ; } else { reportGenericSchemaError ( "Couldn't find top level attributegroup " + ref ) ; } return - 1 ; } for ( Element child = XUtil . getFirstChildElement ( attrGrpDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , typeInfo ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { anyAttDecls . addElement ( traverseAnyAttribute ( child ) ) ; break ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } } return - 1 ; } private int traverseAttributeGroupDeclFromAnotherSchema ( String attGrpName , String uriStr , ComplexTypeInfo typeInfo , Vector anyAttDecls ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #traverseAttributeGroupDeclFromAnotherSchema, schema uri : " + uriStr ) ; return - 1 ; } Element attGrpDecl = ( Element ) aGrammar . topLevelAttrGrpDecls . get ( ( Object ) attGrpName ) ; if ( attGrpDecl == null ) { reportGenericSchemaError ( "no attribute group named \"" + attGrpName + "\" was defined in schema : " + uriStr ) ; return - 1 ; } NamespacesScope saveNSMapping = fNamespacesScope ; int saveTargetNSUri = fTargetNSURI ; fTargetNSURI = fStringPool . addSymbol ( aGrammar . getTargetNamespaceURI ( ) ) ; fNamespacesScope = aGrammar . getNamespacesScope ( ) ; int attType = - 1 ; int enumeration = - 1 ; for ( Element child = XUtil . getFirstChildElement ( attGrpDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { String childAttName = child . getAttribute ( SchemaSymbols . ATT_NAME ) ; if ( childAttName . length ( ) > 0 ) { Hashtable attDeclRegistry = aGrammar . getAttirubteDeclRegistry ( ) ; if ( attDeclRegistry != null ) { if ( attDeclRegistry . get ( ( Object ) childAttName ) != null ) { addAttributeDeclFromAnotherSchema ( childAttName , uriStr , typeInfo ) ; return - 1 ; } } } else traverseAttributeDecl ( child , typeInfo ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { anyAttDecls . addElement ( traverseAnyAttribute ( child ) ) ; break ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } } fNamespacesScope = saveNSMapping ; fTargetNSURI = saveTargetNSUri ; return - 1 ; } private QName traverseElementDecl ( Element elementDecl ) throws Exception { int contentSpecType = - 1 ; int contentSpecNodeIndex = - 1 ; int typeNameIndex = - 1 ; int scopeDefined = - 2 ; DatatypeValidator dv = null ; String name = elementDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; if ( DEBUGGING ) System . out . println ( "traversing element decl : " + name ) ; String ref = elementDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; String type = elementDecl . getAttribute ( SchemaSymbols . ATT_TYPE ) ; String minOccurs = elementDecl . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ; String maxOccurs = elementDecl . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ; String dflt = elementDecl . getAttribute ( SchemaSymbols . ATT_DEFAULT ) ; String fixed = elementDecl . getAttribute ( SchemaSymbols . ATT_FIXED ) ; String equivClass = elementDecl . getAttribute ( SchemaSymbols . ATT_EQUIVCLASS ) ; String isQName = elementDecl . getAttribute ( SchemaSymbols . ATT_FORM ) ; String fromAnotherSchema = null ; if ( isTopLevel ( elementDecl ) ) { int nameIndex = fStringPool . addSymbol ( name ) ; int eltKey = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , nameIndex , TOP_LEVEL_SCOPE ) ; if ( eltKey > - 1 ) { return new QName ( - 1 , nameIndex , nameIndex , fTargetNSURI ) ; } } int blockSet = parseBlockSet ( elementDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ) ; int finalSet = parseFinalSet ( elementDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ) ; boolean isNullable = elementDecl . getAttribute ( SchemaSymbols . ATT_NULLABLE ) . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; boolean isAbstract = elementDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; int elementMiscFlags = 0 ; if ( isNullable ) { elementMiscFlags += SchemaSymbols . NULLABLE ; } if ( isAbstract ) { elementMiscFlags += SchemaSymbols . ABSTRACT ; } int attrCount = 0 ; if ( ! ref . equals ( "" ) ) attrCount ++ ; if ( ! type . equals ( "" ) ) attrCount ++ ; if ( attrCount > 1 ) reportSchemaError ( SchemaMessageProvider . OneOfTypeRefArchRef , null ) ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( elementDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String uriString = resolvePrefixToURI ( prefix ) ; QName eltName = new QName ( prefix != null ? fStringPool . addSymbol ( prefix ) : - 1 , localpartIndex , fStringPool . addSymbol ( ref ) , uriString != null ? fStringPool . addSymbol ( uriString ) : - 1 ) ; if ( ! uriString . equals ( fTargetNSURIString ) ) { return eltName ; } int elementIndex = fSchemaGrammar . getElementDeclIndex ( eltName , TOP_LEVEL_SCOPE ) ; if ( elementIndex == - 1 ) { Element targetElement = getTopLevelComponentByName ( SchemaSymbols . ELT_ELEMENT , localpart ) ; if ( targetElement == null ) { reportGenericSchemaError ( "Element " + localpart + " not found in the Schema" ) ; return eltName ; } else { } } return eltName ; } Element equivClassElementDecl = null ; int equivClassElementDeclIndex = - 1 ; boolean noErrorSoFar = true ; String equivClassUri = null ; String equivClassLocalpart = null ; String equivClassFullName = null ; ComplexTypeInfo equivClassEltTypeInfo = null ; DatatypeValidator equivClassEltDV = null ; if ( equivClass . length ( ) > 0 ) { equivClassUri = resolvePrefixToURI ( getPrefix ( equivClass ) ) ; equivClassLocalpart = getLocalPart ( equivClass ) ; equivClassFullName = equivClassUri + "," + equivClassLocalpart ; if ( ! equivClassUri . equals ( fTargetNSURIString ) ) { equivClassEltTypeInfo = getElementDeclTypeInfoFromNS ( equivClassUri , equivClassLocalpart ) ; if ( equivClassEltTypeInfo == null ) { equivClassEltDV = getElementDeclTypeValidatorFromNS ( equivClassUri , equivClassLocalpart ) ; if ( equivClassEltDV == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type for element '" + equivClassLocalpart + "' in schema '" + equivClassUri + "'" ) ; } } } else { equivClassElementDecl = getTopLevelComponentByName ( SchemaSymbols . ELT_ELEMENT , equivClassLocalpart ) ; if ( equivClassElementDecl == null ) { equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; if ( equivClassElementDeclIndex == - 1 ) { noErrorSoFar = false ; reportGenericSchemaError ( "Equivclass affiliation element " + equivClass + " in element declaration " + name ) ; } } else { equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; if ( equivClassElementDeclIndex == - 1 ) { traverseElementDecl ( equivClassElementDecl ) ; equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; } } if ( equivClassElementDeclIndex != - 1 ) { equivClassEltTypeInfo = fSchemaGrammar . getElementComplexTypeInfo ( equivClassElementDeclIndex ) ; if ( equivClassEltTypeInfo == null ) { fSchemaGrammar . getElementDecl ( equivClassElementDeclIndex , fTempElementDecl ) ; equivClassEltDV = fTempElementDecl . datatypeValidator ; if ( equivClassEltDV == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type for element '" + equivClassLocalpart + "' in schema '" + equivClassUri + "'" ) ; } } } } } ComplexTypeInfo typeInfo = null ; Element child = XUtil . getFirstChildElement ( elementDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; boolean haveAnonType = false ; if ( child != null ) { String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . length ( ) > 0 ) { noErrorSoFar = false ; reportGenericSchemaError ( "anonymous complexType in element '" + name + "' has a name attribute" ) ; } else typeNameIndex = traverseComplexTypeDecl ( child ) ; if ( typeNameIndex != - 1 ) { typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( typeNameIndex ) ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "traverse complexType error in element '" + name + "'" ) ; } haveAnonType = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . length ( ) > 0 ) { noErrorSoFar = false ; reportGenericSchemaError ( "anonymous simpleType in element '" + name + "' has a name attribute" ) ; } else typeNameIndex = traverseSimpleTypeDecl ( child ) ; if ( typeNameIndex != - 1 ) { dv = fDatatypeRegistry . getDatatypeValidator ( fStringPool . toString ( typeNameIndex ) ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "traverse simpleType error in element '" + name + "'" ) ; } contentSpecType = XMLElementDecl . TYPE_SIMPLE ; haveAnonType = true ; } else if ( type . equals ( "" ) ) { contentSpecType = XMLElementDecl . TYPE_ANY ; contentSpecNodeIndex = - 1 ; } else { System . out . println ( "unhandled case in TraverseElementDecl" ) ; } } if ( haveAnonType && ( type . length ( ) > 0 ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "Element '" + name + "' have both a type attribute and a annoymous type child" ) ; } else if ( ! type . equals ( "" ) ) { if ( equivClassElementDecl != null ) { checkEquivClassOK ( elementDecl , equivClassElementDecl ) ; } String prefix = "" ; String localpart = type ; int colonptr = type . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = type . substring ( 0 , colonptr ) ; localpart = type . substring ( colonptr + 1 ) ; } String typeURI = resolvePrefixToURI ( prefix ) ; if ( ! typeURI . equals ( fTargetNSURIString ) && ! typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && typeURI . length ( ) != 0 ) { fromAnotherSchema = typeURI ; typeInfo = getTypeInfoFromNS ( typeURI , localpart ) ; if ( typeInfo == null ) { dv = getTypeValidatorFromNS ( typeURI , localpart ) ; if ( dv == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type " + localpart + " in schema " + typeURI ) ; } } } else { typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( typeURI + "," + localpart ) ; if ( typeInfo == null ) { dv = getDatatypeValidator ( typeURI , localpart ) ; if ( dv == null ) if ( typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && ! fTargetNSURIString . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "type not found : " + typeURI + ":" + localpart ) ; } else { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_COMPLEXTYPE , localpart ) ; if ( topleveltype != null ) { if ( fCurrentTypeNameStack . search ( ( Object ) localpart ) > - 1 ) { int uriInd = - 1 ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fElementDefaultQualified ) { uriInd = fTargetNSURI ; } int nameIndex = fStringPool . addSymbol ( name ) ; QName tempQName = new QName ( fCurrentScope , nameIndex , nameIndex , uriInd ) ; fElementRecurseComplex . put ( tempQName , localpart ) ; return new QName ( - 1 , nameIndex , nameIndex , uriInd ) ; } else { typeNameIndex = traverseComplexTypeDecl ( topleveltype ) ; typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( typeNameIndex ) ) ; } } else { topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { typeNameIndex = traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "type not found : " + typeURI + ":" + localpart ) ; } } } } } } else if ( haveAnonType ) { if ( equivClassElementDecl != null ) { checkEquivClassOK ( elementDecl , equivClassElementDecl ) ; } } else { if ( typeInfo == null && dv == null ) typeInfo = equivClassEltTypeInfo ; if ( typeInfo == null && dv == null ) dv = equivClassEltDV ; } if ( typeInfo == null && dv == null ) { if ( noErrorSoFar ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "untyped element : " + name ) ; } } if ( typeInfo != null ) { contentSpecNodeIndex = typeInfo . contentSpecHandle ; contentSpecType = typeInfo . contentType ; scopeDefined = typeInfo . scopeDefined ; dv = typeInfo . datatypeValidator ; } if ( dv != null ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; } child = XUtil . getFirstChildElement ( elementDecl ) ; Vector idConstraints = null ; while ( child != null ) { String childName = child . getNodeName ( ) ; child = XUtil . getNextSiblingElement ( child ) ; } int elementNameIndex = fStringPool . addSymbol ( name ) ; int localpartIndex = elementNameIndex ; int uriIndex = - 1 ; int enclosingScope = fCurrentScope ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fElementDefaultQualified ) { uriIndex = fTargetNSURI ; } if ( isTopLevel ( elementDecl ) ) { uriIndex = fTargetNSURI ; enclosingScope = TOP_LEVEL_SCOPE ; } int existSuchElementIndex = fSchemaGrammar . getElementDeclIndex ( uriIndex , localpartIndex , enclosingScope ) ; if ( existSuchElementIndex > - 1 ) { fSchemaGrammar . getElementDecl ( existSuchElementIndex , fTempElementDecl ) ; DatatypeValidator edv = fTempElementDecl . datatypeValidator ; ComplexTypeInfo eTypeInfo = fSchemaGrammar . getElementComplexTypeInfo ( existSuchElementIndex ) ; if ( ( ( eTypeInfo != null ) && ( eTypeInfo != typeInfo ) ) || ( ( edv != null ) && ( edv != dv ) ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "duplicate element decl in the same scope : " + fStringPool . toString ( localpartIndex ) ) ; } } QName eltQName = new QName ( - 1 , localpartIndex , elementNameIndex , uriIndex ) ; int attrListHead = - 1 ; if ( typeInfo != null ) { attrListHead = typeInfo . attlistHead ; } int elementIndex = fSchemaGrammar . addElementDecl ( eltQName , enclosingScope , scopeDefined , contentSpecType , contentSpecNodeIndex , attrListHead , dv ) ; if ( DEBUGGING ) { System . out . println ( "########elementIndex:" + elementIndex + " (" + fStringPool . toString ( eltQName . uri ) + "," + fStringPool . toString ( eltQName . localpart ) + ")" + " eltType:" + type + " contentSpecType:" + contentSpecType + " SpecNodeIndex:" + contentSpecNodeIndex + " enclosingScope: " + enclosingScope + " scopeDefined: " + scopeDefined + "\n" ) ; } if ( typeInfo != null ) { fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } else { fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } fSchemaGrammar . setElementFromAnotherSchemaURI ( elementIndex , fromAnotherSchema ) ; fSchemaGrammar . setElementDeclBlockSet ( elementIndex , blockSet ) ; fSchemaGrammar . setElementDeclFinalSet ( elementIndex , finalSet ) ; fSchemaGrammar . setElementDeclMiscFlags ( elementIndex , elementMiscFlags ) ; fSchemaGrammar . setElementDeclEquivClassElementFullName ( elementIndex , equivClassFullName ) ; return eltQName ; } int getLocalPartIndex ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String localpart = fullName ; if ( colonAt > - 1 ) { localpart = fullName . substring ( colonAt + 1 ) ; } return fStringPool . addSymbol ( localpart ) ; } String getLocalPart ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String localpart = fullName ; if ( colonAt > - 1 ) { localpart = fullName . substring ( colonAt + 1 ) ; } return localpart ; } int getPrefixIndex ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String prefix = "" ; if ( colonAt > - 1 ) { prefix = fullName . substring ( 0 , colonAt ) ; } return fStringPool . addSymbol ( prefix ) ; } String getPrefix ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String prefix = "" ; if ( colonAt > - 1 ) { prefix = fullName . substring ( 0 , colonAt ) ; } return prefix ; } private void checkEquivClassOK ( Element elementDecl , Element equivClassElementDecl ) { } private Element getTopLevelComponentByName ( String componentCategory , String name ) throws Exception { Element child = XUtil . getFirstChildElement ( fSchemaRootElement ) ; if ( child == null ) { return null ; } while ( child != null ) { if ( child . getNodeName ( ) . equals ( componentCategory ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . equals ( name ) ) { return child ; } } child = XUtil . getNextSiblingElement ( child ) ; } return null ; } private boolean isTopLevel ( Element component ) { if ( component . getParentNode ( ) . getNodeName ( ) . endsWith ( SchemaSymbols . ELT_SCHEMA ) ) { return true ; } return false ; } DatatypeValidator getTypeValidatorFromNS ( String newSchemaURI , String localpart ) throws Exception { return getDatatypeValidator ( newSchemaURI , localpart ) ; } ComplexTypeInfo getTypeInfoFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; ComplexTypeInfo typeInfo = ( ComplexTypeInfo ) sGrammar . getComplexTypeRegistry ( ) . get ( newSchemaURI + "," + localpart ) ; return typeInfo ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getTypeInfoFromNS" ) ; } return null ; } DatatypeValidator getElementDeclTypeValidatorFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; int eltIndex = sGrammar . getElementDeclIndex ( fStringPool . addSymbol ( newSchemaURI ) , fStringPool . addSymbol ( localpart ) , TOP_LEVEL_SCOPE ) ; DatatypeValidator dv = null ; if ( eltIndex > - 1 ) { sGrammar . getElementDecl ( eltIndex , fTempElementDecl ) ; dv = fTempElementDecl . datatypeValidator ; } else { reportGenericSchemaError ( "could not find global element : '" + localpart + " in the SchemaGrammar " + newSchemaURI ) ; } return dv ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getELementDeclTypeValidatorFromNS" ) ; } return null ; } ComplexTypeInfo getElementDeclTypeInfoFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; int eltIndex = sGrammar . getElementDeclIndex ( fStringPool . addSymbol ( newSchemaURI ) , fStringPool . addSymbol ( localpart ) , TOP_LEVEL_SCOPE ) ; ComplexTypeInfo typeInfo = null ; if ( eltIndex > - 1 ) { typeInfo = sGrammar . getElementComplexTypeInfo ( eltIndex ) ; } else { reportGenericSchemaError ( "could not find global element : '" + localpart + " in the SchemaGrammar " + newSchemaURI ) ; } return typeInfo ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getElementDeclTypeInfoFromNS" ) ; } return null ; } private int traverseGroupDecl ( Element groupDecl ) throws Exception { String groupName = groupDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; String ref = groupDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( groupDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { return traverseGroupDeclFromAnotherSchema ( localpart , uriStr ) ; } int contentSpecIndex = - 1 ; Element referredGroup = getTopLevelComponentByName ( SchemaSymbols . ELT_GROUP , localpart ) ; if ( referredGroup == null ) { reportGenericSchemaError ( "Group " + localpart + " not found in the Schema" ) ; throw new Exception ( "Group " + localpart + " not found in the Schema" ) ; } else { contentSpecIndex = traverseGroupDecl ( referredGroup ) ; } return contentSpecIndex ; } boolean traverseElt = true ; if ( fCurrentScope == TOP_LEVEL_SCOPE ) { traverseElt = false ; } Element child = XUtil . getFirstChildElement ( groupDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; int allChildren [ ] = null ; int allChildCount = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; boolean seeAll = false ; boolean seeParticle = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean illegalChild = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeAll = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { illegalChild = true ; reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( ! illegalChild ) { index = expandContentModel ( index , child ) ; } if ( seeParticle && seeAll ) { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "'all' needs to be 'the' only Child" , childName } ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } private int traverseGroupDeclFromAnotherSchema ( String groupName , String uriStr ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #traverseGroupDeclFromAnotherSchema, " + "schema uri: " + uriStr + ", groupName: " + groupName ) ; return - 1 ; } Element groupDecl = ( Element ) aGrammar . topLevelGroupDecls . get ( ( Object ) groupName ) ; if ( groupDecl == null ) { reportGenericSchemaError ( "no group named \"" + groupName + "\" was defined in schema : " + uriStr ) ; return - 1 ; } NamespacesScope saveNSMapping = fNamespacesScope ; int saveTargetNSUri = fTargetNSURI ; fTargetNSURI = fStringPool . addSymbol ( aGrammar . getTargetNamespaceURI ( ) ) ; fNamespacesScope = aGrammar . getNamespacesScope ( ) ; boolean traverseElt = true ; if ( fCurrentScope == TOP_LEVEL_SCOPE ) { traverseElt = false ; } Element child = XUtil . getFirstChildElement ( groupDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; int allChildren [ ] = null ; int allChildCount = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; int childNameIndex = fStringPool . addSymbol ( childName ) ; String formAttrVal = child . getAttribute ( SchemaSymbols . ATT_FORM ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; fNamespacesScope = saveNSMapping ; fTargetNSURI = saveTargetNSUri ; return left ; } int traverseSequence ( Element sequenceDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( sequenceDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } int traverseChoice ( Element choiceDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( choiceDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } int traverseAll ( Element allDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( allDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int allChildren [ ] = null ; int allChildCount = 0 ; int left = - 2 ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } try { allChildren [ allChildCount ] = index ; } catch ( NullPointerException ne ) { allChildren = new int [ 32 ] ; allChildren [ allChildCount ] = index ; } catch ( ArrayIndexOutOfBoundsException ae ) { int [ ] newArray = new int [ allChildren . length * 2 ] ; System . arraycopy ( allChildren , 0 , newArray , 0 , allChildren . length ) ; allChildren [ allChildCount ] = index ; } allChildCount ++ ; } left = buildAllModel ( allChildren , allChildCount ) ; return left ; } private int buildAllModel ( int children [ ] , int count ) throws Exception { if ( count > 1 ) { XMLContentSpec choice = new XMLContentSpec ( ) ; choice . type = XMLContentSpec . CONTENTSPECNODE_CHOICE ; choice . value = - 1 ; choice . otherValue = - 1 ; int [ ] exactChildren = new int [ count ] ; System . arraycopy ( children , 0 , exactChildren , 0 , count ) ; sort ( exactChildren , 0 , count ) ; int index = buildAllModel ( exactChildren , 0 , choice ) ; return index ; } if ( count > 0 ) { return children [ 0 ] ; } return - 1 ; } private int buildAllModel ( int src [ ] , int offset , XMLContentSpec choice ) throws Exception { if ( src . length - offset == 2 ) { int seqIndex = createSeq ( src ) ; if ( choice . value == - 1 ) { choice . value = seqIndex ; } else { if ( choice . otherValue != - 1 ) { choice . value = fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } choice . otherValue = seqIndex ; } swap ( src , offset , offset + 1 ) ; seqIndex = createSeq ( src ) ; if ( choice . value == - 1 ) { choice . value = seqIndex ; } else { if ( choice . otherValue != - 1 ) { choice . value = fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } choice . otherValue = seqIndex ; } return fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } for ( int i = offset ; i < src . length - 1 ; i ++ ) { choice . value = buildAllModel ( src , offset + 1 , choice ) ; choice . otherValue = - 1 ; sort ( src , offset , src . length - offset ) ; shift ( src , offset , i + 1 ) ; } int choiceIndex = buildAllModel ( src , offset + 1 , choice ) ; sort ( src , offset , src . length - offset ) ; return choiceIndex ; } private int createSeq ( int src [ ] ) throws Exception { int left = src [ 0 ] ; int right = src [ 1 ] ; for ( int i = 2 ; i < src . length ; i ++ ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , left , right , false ) ; right = src [ i ] ; } return fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , left , right , false ) ; } private void shift ( int src [ ] , int pos , int offset ) { int temp = src [ offset ] ; for ( int i = offset ; i > pos ; i -- ) { src [ i ] = src [ i - 1 ] ; } src [ pos ] = temp ; } private void sort ( int src [ ] , final int offset , final int length ) { for ( int i = offset ; i < offset + length - 1 ; i ++ ) { int lowest = i ; for ( int j = i + 1 ; j < offset + length ; j ++ ) { if ( src [ j ] < src [ lowest ] ) { lowest = j ; } } if ( lowest != i ) { int temp = src [ i ] ; src [ i ] = src [ lowest ] ; src [ lowest ] = temp ; } } } private void swap ( int src [ ] , int i , int j ) { int temp = src [ i ] ; src [ i ] = src [ j ] ; src [ j ] = temp ; } private int traverseWildcardDecl ( Element wildcardDecl ) throws Exception { int wildcardID = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATTVAL_ID ) ) ; int wildcardMaxOccurs = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ) ; int wildcardMinOccurs = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ) ; int wildcardNamespace = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) ) ; int wildcardProcessContents = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_PROCESSCONTENTS ) ) ; int wildcardContent = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_CONTENT ) ) ; return - 1 ; } private int parseInt ( String intString ) throws Exception { if ( intString . equals ( "*" ) ) { return SchemaSymbols . INFINITY ; } else { return Integer . parseInt ( intString ) ; } } private int parseSimpleDerivedBy ( String derivedByString ) throws Exception { if ( derivedByString . equals ( SchemaSymbols . ATTVAL_LIST ) ) { return SchemaSymbols . LIST ; } else if ( derivedByString . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { return SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "SimpleType: Invalid value for 'derivedBy'" ) ; return - 1 ; } } private int parseComplexDerivedBy ( String derivedByString ) throws Exception { if ( derivedByString . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { return SchemaSymbols . EXTENSION ; } else if ( derivedByString . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { return SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "ComplexType: Invalid value for 'derivedBy'" ) ; return - 1 ; } } private int parseSimpleFinal ( String finalString ) throws Exception { if ( finalString . equals ( SchemaSymbols . ATTVAL_POUNDALL ) ) { return SchemaSymbols . ENUMERATION + SchemaSymbols . RESTRICTION + SchemaSymbols . LIST + SchemaSymbols . REPRODUCTION ; } else { int enumerate = 0 ; int restrict = 0 ; int list = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction in set twice" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( list == 0 ) { list = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "list in set twice" ) ; } } else { reportGenericSchemaError ( "Invalid value (" + finalString + ")" ) ; } } return enumerate + restrict + list + reproduce ; } } private int parseComplexContent ( String contentString ) throws Exception { if ( contentString . equals ( SchemaSymbols . ATTVAL_EMPTY ) ) { return XMLElementDecl . TYPE_EMPTY ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_ELEMENTONLY ) ) { return XMLElementDecl . TYPE_CHILDREN ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { return XMLElementDecl . TYPE_SIMPLE ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_MIXED ) ) { return XMLElementDecl . TYPE_MIXED ; } else { reportGenericSchemaError ( "Invalid value for content" ) ; return - 1 ; } } private int parseDerivationSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EXTENSION + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private int parseBlockSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EQUIVCLASS + SchemaSymbols . EXTENSION + SchemaSymbols . LIST + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EQUIVCLASS ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EQUIVCLASS ; } else { reportGenericSchemaError ( "'equivClass' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( extend == 0 ) { extend = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "'list' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private int parseFinalSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EQUIVCLASS + SchemaSymbols . EXTENSION + SchemaSymbols . LIST + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EQUIVCLASS ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EQUIVCLASS ; } else { reportGenericSchemaError ( "'equivClass' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( extend == 0 ) { extend = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "'list' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private void reportGenericSchemaError ( String error ) throws Exception { if ( fErrorReporter == null ) { System . err . println ( "__TraverseSchemaError__ : " + error ) ; } else { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { error } ) ; } } private void reportSchemaError ( int major , Object args [ ] ) throws Exception { if ( fErrorReporter == null ) { System . out . println ( "__TraverseSchemaError__ : " + SchemaMessageProvider . fgMessageKeys [ major ] ) ; for ( int i = 0 ; i < args . length ; i ++ ) { System . out . println ( ( String ) args [ i ] ) ; } } else { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , major , SchemaMessageProvider . MSG_NONE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } public static void main ( String args [ ] ) { if ( args . length != 1 ) { System . out . println ( "Error: Usage java TraverseSchema yourFile.xsd" ) ; System . exit ( 0 ) ; } DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( args [ 0 ] ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } Document document = parser . getDocument ( ) ; OutputFormat format = new OutputFormat ( document ) ; java . io . StringWriter outWriter = new java . io . StringWriter ( ) ; XMLSerializer serial = new XMLSerializer ( outWriter , format ) ; TraverseSchema tst = null ; try { Element root = document . getDocumentElement ( ) ; tst = new TraverseSchema ( root , new StringPool ( ) , new SchemaGrammar ( ) , ( GrammarResolver ) new GrammarResolverImpl ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } parser . getDocument ( ) ; } static class Resolver implements EntityResolver { private static final String SYSTEM [ ] = { "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/structures.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/datatypes.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/versionInfo.ent" , } ; private static final String PATH [ ] = { "structures.dtd" , "datatypes.dtd" , "versionInfo.ent" , } ; public InputSource resolveEntity ( String publicId , String systemId ) throws IOException { for ( int i = 0 ; i < SYSTEM . length ; i ++ ) { if ( systemId . equals ( SYSTEM [ i ] ) ) { InputSource source = new InputSource ( getClass ( ) . getResourceAsStream ( PATH [ i ] ) ) ; source . setPublicId ( publicId ) ; source . setSystemId ( systemId ) ; return source ; } } return null ; } } static class ErrorHandler implements org . xml . sax . ErrorHandler { public void warning ( SAXParseException ex ) { System . err . println ( "[Warning] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { System . err . println ( "[Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) throws SAXException { System . err . println ( "[Fatal Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; throw ex ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId_ = ex . getSystemId ( ) ; if ( systemId_ != null ) { int index = systemId_ . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId_ = systemId_ . substring ( index + 1 ) ; str . append ( systemId_ ) ; } str . append ( ':' ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( ':' ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLCardElementImpl extends WMLElementImpl implements WMLCardElement { public WMLCardElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setOnTimer ( String newValue ) { setAttribute ( "ontimer" , newValue ) ; } public String getOnTimer ( ) { return getAttribute ( "ontimer" ) ; } public void setOrdered ( boolean newValue ) { setAttribute ( "ordered" , newValue ) ; } public boolean getOrdered ( ) { return getAttribute ( "ordered" , true ) ; } public void setOnEnterBackward ( String newValue ) { setAttribute ( "onenterbackward" , newValue ) ; } public String getOnEnterBackward ( ) { return getAttribute ( "onenterbackward" ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setTitle ( String newValue ) { setAttribute ( "title" , newValue ) ; } public String getTitle ( ) { return getAttribute ( "title" ) ; } public void setNewContext ( boolean newValue ) { setAttribute ( "newcontext" , newValue ) ; } public boolean getNewContext ( ) { return getAttribute ( "newcontext" , false ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setOnEnterForward ( String newValue ) { setAttribute ( "onenterforward" , newValue ) ; } public String getOnEnterForward ( ) { return getAttribute ( "onenterforward" ) ; } } 	0
package org . w3c . dom ; public interface Node { public static final short ELEMENT_NODE = 1 ; public static final short ATTRIBUTE_NODE = 2 ; public static final short TEXT_NODE = 3 ; public static final short CDATA_SECTION_NODE = 4 ; public static final short ENTITY_REFERENCE_NODE = 5 ; public static final short ENTITY_NODE = 6 ; public static final short PROCESSING_INSTRUCTION_NODE = 7 ; public static final short COMMENT_NODE = 8 ; public static final short DOCUMENT_NODE = 9 ; public static final short DOCUMENT_TYPE_NODE = 10 ; public static final short DOCUMENT_FRAGMENT_NODE = 11 ; public static final short NOTATION_NODE = 12 ; public String getNodeName ( ) ; public String getNodeValue ( ) throws DOMException ; public void setNodeValue ( String nodeValue ) throws DOMException ; public short getNodeType ( ) ; public Node getParentNode ( ) ; public NodeList getChildNodes ( ) ; public Node getFirstChild ( ) ; public Node getLastChild ( ) ; public Node getPreviousSibling ( ) ; public Node getNextSibling ( ) ; public NamedNodeMap getAttributes ( ) ; public Document getOwnerDocument ( ) ; public Node insertBefore ( Node newChild , Node refChild ) throws DOMException ; public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException ; public Node removeChild ( Node oldChild ) throws DOMException ; public Node appendChild ( Node newChild ) throws DOMException ; public boolean hasChildNodes ( ) ; public Node cloneNode ( boolean deep ) ; public void normalize ( ) ; public boolean supports ( String feature , String version ) ; public String getNamespaceURI ( ) ; public String getPrefix ( ) ; public void setPrefix ( String prefix ) throws DOMException ; public String getLocalName ( ) ; public boolean hasAttributes ( ) ; } 	1
package org . xml . sax ; public class SAXParseException extends SAXException { public SAXParseException ( String message , Locator locator ) { super ( message ) ; if ( locator != null ) { init ( locator . getPublicId ( ) , locator . getSystemId ( ) , locator . getLineNumber ( ) , locator . getColumnNumber ( ) ) ; } else { init ( null , null , - 1 , - 1 ) ; } } public SAXParseException ( String message , Locator locator , Exception e ) { super ( message , e ) ; if ( locator != null ) { init ( locator . getPublicId ( ) , locator . getSystemId ( ) , locator . getLineNumber ( ) , locator . getColumnNumber ( ) ) ; } else { init ( null , null , - 1 , - 1 ) ; } } public SAXParseException ( String message , String publicId , String systemId , int lineNumber , int columnNumber ) { super ( message ) ; init ( publicId , systemId , lineNumber , columnNumber ) ; } public SAXParseException ( String message , String publicId , String systemId , int lineNumber , int columnNumber , Exception e ) { super ( message , e ) ; init ( publicId , systemId , lineNumber , columnNumber ) ; } private void init ( String publicId , String systemId , int lineNumber , int columnNumber ) { this . publicId = publicId ; this . systemId = systemId ; this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; } public String getPublicId ( ) { return this . publicId ; } public String getSystemId ( ) { return this . systemId ; } public int getLineNumber ( ) { return this . lineNumber ; } public int getColumnNumber ( ) { return this . columnNumber ; } private String publicId ; private String systemId ; private int lineNumber ; private int columnNumber ; } 	0
package org . w3c . dom ; public interface Entity extends Node { public String getPublicId ( ) ; public String getSystemId ( ) ; public String getNotationName ( ) ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLUElementImpl extends WMLElementImpl implements WMLUElement { public WMLUElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom ; public interface Text extends CharacterData { public Text splitText ( int offset ) throws DOMException ; } 	1
package org . w3c . dom . html ; public interface HTMLBaseElement extends HTMLElement { public String getHref ( ) ; public void setHref ( String href ) ; public String getTarget ( ) ; public void setTarget ( String target ) ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . Node ; public interface NodeFilter { public static final short FILTER_ACCEPT = 1 ; public static final short FILTER_REJECT = 2 ; public static final short FILTER_SKIP = 3 ; public static final int SHOW_ALL = 0xFFFFFFFF ; public static final int SHOW_ELEMENT = 0x00000001 ; public static final int SHOW_ATTRIBUTE = 0x00000002 ; public static final int SHOW_TEXT = 0x00000004 ; public static final int SHOW_CDATA_SECTION = 0x00000008 ; public static final int SHOW_ENTITY_REFERENCE = 0x00000010 ; public static final int SHOW_ENTITY = 0x00000020 ; public static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040 ; public static final int SHOW_COMMENT = 0x00000080 ; public static final int SHOW_DOCUMENT = 0x00000100 ; public static final int SHOW_DOCUMENT_TYPE = 0x00000200 ; public static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400 ; public static final int SHOW_NOTATION = 0x00000800 ; public short acceptNode ( Node n ) ; } 	1
package org . w3c . dom . html ; public interface HTMLOptionElement extends HTMLElement { public HTMLFormElement getForm ( ) ; public boolean getDefaultSelected ( ) ; public void setDefaultSelected ( boolean defaultSelected ) ; public String getText ( ) ; public int getIndex ( ) ; public boolean getDisabled ( ) ; public void setDisabled ( boolean disabled ) ; public String getLabel ( ) ; public void setLabel ( String label ) ; public boolean getSelected ( ) ; public void setSelected ( boolean selected ) ; public String getValue ( ) ; public void setValue ( String value ) ; } 	0
package org . w3c . dom ; public interface Notation extends Node { public String getPublicId ( ) ; public String getSystemId ( ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLBaseFontElementImpl extends HTMLElementImpl implements HTMLBaseFontElement { public String getColor ( ) { return capitalize ( getAttribute ( "color" ) ) ; } public void setColor ( String color ) { setAttribute ( "color" , color ) ; } public String getFace ( ) { return capitalize ( getAttribute ( "face" ) ) ; } public void setFace ( String face ) { setAttribute ( "face" , face ) ; } public String getSize ( ) { return getAttribute ( "size" ) ; } public void setSize ( String size ) { setAttribute ( "size" , size ) ; } public HTMLBaseFontElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public abstract class CharacterDataImpl extends ChildNode { static final long serialVersionUID = 7931170150428474230L ; protected String data ; private static transient NodeList singletonNodeList = new NodeList ( ) { public Node item ( int index ) { return null ; } public int getLength ( ) { return 0 ; } } ; protected CharacterDataImpl ( DocumentImpl ownerDocument , String data ) { super ( ownerDocument ) ; this . data = data ; } public NodeList getChildNodes ( ) { return singletonNodeList ; } public String getNodeValue ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } void setNodeValueInternal ( String value ) { setValueCalled ( true ) ; setNodeValue ( value ) ; setValueCalled ( false ) ; } public void setNodeValue ( String value ) { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; if ( needsSyncData ( ) ) { synchronizeData ( ) ; } String oldvalue = value ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } this . data = value ; if ( ! setValueCalled ( ) ) { ownerDocument ( ) . replacedText ( this ) ; } if ( MUTATIONEVENTS ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_CHARACTER_DATA_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_CHARACTER_DATA_MODIFIED , true , false , null , oldvalue , value , null ) ; dispatchEvent ( me ) ; } dispatchAggregateEvents ( enclosingAttr ) ; } } public String getData ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } public int getLength ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data . length ( ) ; } public void appendData ( String data ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } setNodeValue ( this . data + data ) ; } public void deleteData ( int offset , int count ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( count < 0 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int tailLength = Math . max ( data . length ( ) - count - offset , 0 ) ; try { setNodeValueInternal ( data . substring ( 0 , offset ) + ( tailLength > 0 ? data . substring ( offset + count , offset + count + tailLength ) : "" ) ) ; ownerDocument ( ) . deletedText ( this , offset , count ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } public void insertData ( int offset , String data ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } try { setNodeValueInternal ( new StringBuffer ( this . data ) . insert ( offset , data ) . toString ( ) ) ; ownerDocument ( ) . insertedText ( this , offset , data . length ( ) ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } public void replaceData ( int offset , int count , String data ) throws DOMException { deleteData ( offset , count ) ; insertData ( offset , data ) ; } public void setData ( String value ) throws DOMException { setNodeValue ( value ) ; } public String substringData ( int offset , int count ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int length = data . length ( ) ; if ( count < 0 || offset < 0 || offset > length - 1 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } int tailIndex = Math . min ( offset + count , length ) ; return data . substring ( offset , tailIndex ) ; } } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; public class CMLeaf extends CMNode { private QName fElement = new QName ( ) ; private int fPosition = - 1 ; public CMLeaf ( QName element , int position ) throws CMException { super ( XMLContentSpec . CONTENTSPECNODE_LEAF ) ; fElement . setValues ( element ) ; fPosition = position ; } public CMLeaf ( QName element ) throws CMException { super ( XMLContentSpec . CONTENTSPECNODE_LEAF ) ; fElement . setValues ( element ) ; } final QName getElement ( ) { return fElement ; } final int getPosition ( ) { return fPosition ; } final void setPosition ( int newPosition ) { fPosition = newPosition ; } boolean isNullable ( ) throws CMException { return ( fPosition == - 1 ) ; } String toString ( StringPool stringPool ) { StringBuffer strRet = new StringBuffer ( fElement . toString ( ) ) ; strRet . append ( " (" ) ; strRet . append ( stringPool . toString ( fElement . uri ) ) ; strRet . append ( ',' ) ; strRet . append ( stringPool . toString ( fElement . localpart ) ) ; strRet . append ( ')' ) ; if ( fPosition >= 0 ) { strRet . append ( " (Pos:" + new Integer ( fPosition ) . toString ( ) + ")" ) ; } return strRet . toString ( ) ; } protected void calcFirstPos ( CMStateSet toSet ) throws CMException { if ( fPosition == - 1 ) toSet . zeroBits ( ) ; else toSet . setBit ( fPosition ) ; } protected void calcLastPos ( CMStateSet toSet ) throws CMException { if ( fPosition == - 1 ) toSet . zeroBits ( ) ; else toSet . setBit ( fPosition ) ; } } 	0
package org . apache . xerces . jaxp ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . xml . sax . SAXException ; public class DocumentBuilderFactoryImpl extends DocumentBuilderFactory { public DocumentBuilderFactoryImpl ( ) { super ( ) ; } public DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException { return ( new DocumentBuilderImpl ( this . isNamespaceAware ( ) , this . isValidating ( ) ) ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLLinkElementImpl extends HTMLElementImpl implements HTMLLinkElement { public boolean getDisabled ( ) { return getBinary ( "disabled" ) ; } public void setDisabled ( boolean disabled ) { setAttribute ( "disabled" , disabled ) ; } public String getCharset ( ) { return getAttribute ( "charset" ) ; } public void setCharset ( String charset ) { setAttribute ( "charset" , charset ) ; } public String getHref ( ) { return getAttribute ( "href" ) ; } public void setHref ( String href ) { setAttribute ( "href" , href ) ; } public String getHreflang ( ) { return getAttribute ( "hreflang" ) ; } public void setHreflang ( String hreflang ) { setAttribute ( "hreflang" , hreflang ) ; } public String getMedia ( ) { return getAttribute ( "media" ) ; } public void setMedia ( String media ) { setAttribute ( "media" , media ) ; } public String getRel ( ) { return getAttribute ( "rel" ) ; } public void setRel ( String rel ) { setAttribute ( "rel" , rel ) ; } public String getRev ( ) { return getAttribute ( "rev" ) ; } public void setRev ( String rev ) { setAttribute ( "rev" , rev ) ; } public String getTarget ( ) { return getAttribute ( "target" ) ; } public void setTarget ( String target ) { setAttribute ( "target" , target ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } public void setType ( String type ) { setAttribute ( "type" , type ) ; } public HTMLLinkElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . parsers ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . xml . sax . Attributes ; import org . xml . sax . AttributeList ; import org . xml . sax . ContentHandler ; import org . xml . sax . DocumentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . Parser ; import org . xml . sax . XMLReader ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . AttributesImpl ; public class SAXParser extends XMLParser implements XMLDocumentHandler , XMLDocumentHandler . DTDHandler , Parser , XMLReader { private static final String RECOGNIZED_FEATURES [ ] = { "http://xml.org/sax/features/namespace-prefixes" , "http://xml.org/sax/features/string-interning" , } ; private static final String RECOGNIZED_PROPERTIES [ ] = { "http://xml.org/sax/properties/lexical-handler" , "http://xml.org/sax/properties/declaration-handler" , "http://xml.org/sax/properties/dom-node" , } ; private static final boolean DEBUG_CALLBACKS = false ; private DocumentHandler fDocumentHandler ; private org . xml . sax . DTDHandler fDTDHandler ; private ContentHandler fContentHandler ; private DeclHandler fDeclHandler ; private LexicalHandler fLexicalHandler ; private boolean fNamespacePrefixes = false ; private transient AttributesImpl fAttributes = new AttributesImpl ( ) ; public SAXParser ( ) { initHandlers ( true , this , this ) ; } public String [ ] getFeaturesRecognized ( ) { String superRecognized [ ] = super . getFeaturesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_FEATURES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } public String [ ] getPropertiesRecognized ( ) { String superRecognized [ ] = super . getPropertiesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_PROPERTIES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } protected void setDeclHandler ( DeclHandler handler ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR011 Feature: http://xml.org/sax/properties/declaration-handler" + " is not supported during parse." + "\nhttp://xml.org/sax/properties/declaration-handler" ) ; } fDeclHandler = handler ; } protected DeclHandler getDeclHandler ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fDeclHandler ; } protected void setLexicalHandler ( LexicalHandler handler ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR011 Feature: http://xml.org/sax/properties/lexical-handler" + " is not supported during parse." + "\nhttp://xml.org/sax/properties/lexical-handler" ) ; } fLexicalHandler = handler ; } protected LexicalHandler getLexicalHandler ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fLexicalHandler ; } public void setDocumentHandler ( DocumentHandler handler ) { fDocumentHandler = handler ; } public void setDTDHandler ( org . xml . sax . DTDHandler handler ) { fDTDHandler = handler ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return fDTDHandler ; } protected void setNamespacePrefixes ( boolean process ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR004 Cannot setFeature(http://xml.org/sax/features/namespace-prefixes): parse is in progress.\n" + "http://xml.org/sax/features/namespace-prefixes" ) ; } fNamespacePrefixes = process ; } protected boolean getNamespacePrefixes ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fNamespacePrefixes ; } public void setFeature ( String featureId , boolean state ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "namespace-prefixes" ) ) { setNamespacePrefixes ( state ) ; return ; } if ( feature . equals ( "string-interning" ) ) { if ( state ) { throw new SAXNotSupportedException ( "PAR018 " + state + " state for feature \"" + featureId + "\" is not supported.\n" + state + '\t' + featureId ) ; } return ; } } super . setFeature ( featureId , state ) ; } public boolean getFeature ( String featureId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "namespace-prefixes" ) ) { return getNamespacePrefixes ( ) ; } if ( feature . equals ( "string-interning" ) ) { return false ; } } return super . getFeature ( featureId ) ; } public void setProperty ( String propertyId , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "lexical-handler" ) ) { try { setLexicalHandler ( ( LexicalHandler ) value ) ; } catch ( ClassCastException e ) { throw new SAXNotSupportedException ( "PAR012 For propertyID \"" + propertyId + "\", the value \"" + value + "\" cannot be cast to LexicalHandler." + '\n' + propertyId + '\t' + value + "\tLexicalHandler" ) ; } return ; } if ( property . equals ( "declaration-handler" ) ) { try { setDeclHandler ( ( DeclHandler ) value ) ; } catch ( ClassCastException e ) { throw new SAXNotSupportedException ( "PAR012 For propertyID \"" + propertyId + "\", the value \"" + value + "\" cannot be cast to DeclHandler." + '\n' + propertyId + '\t' + value + "\tDeclHandler" ) ; } return ; } if ( property . equals ( "dom-node" ) ) { throw new SAXNotSupportedException ( "PAR013 Property \"" + propertyId + "\" is read only." + '\n' + propertyId ) ; } } super . setProperty ( propertyId , value ) ; } public Object getProperty ( String propertyId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "lexical-handler" ) ) { return getLexicalHandler ( ) ; } if ( property . equals ( "declaration-handler" ) ) { return getDeclHandler ( ) ; } if ( property . equals ( "dom-node" ) ) { throw new SAXNotSupportedException ( "PAR014 Cannot getProperty(\"" + propertyId + "\". No DOM Tree exists.\n" + propertyId ) ; } } return super . getProperty ( propertyId ) ; } public void setContentHandler ( ContentHandler handler ) { if ( handler == null ) { throw new NullPointerException ( ) ; } fContentHandler = handler ; } public ContentHandler getContentHandler ( ) { return fContentHandler ; } public void startDTD ( QName rootElement , int publicId , int systemId ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( rootElement . rawname ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "startDTD(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startDTD ( name , pubid , sysid ) ; } } } public void endDTD ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endDTD()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endDTD ( ) ; } } public void elementDecl ( QName elementDecl , int contentSpecType , int contentSpecIndex , XMLContentSpec . Provider contentSpecProvider ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( elementDecl . rawname ) ; String contentModel ; if ( contentSpecType == XMLElementDecl . TYPE_ANY ) { contentModel = "ANY" ; } else if ( contentSpecType == XMLElementDecl . TYPE_EMPTY ) { contentModel = "EMPTY" ; } else { contentModel = XMLContentSpec . toString ( contentSpecProvider , fStringPool , contentSpecIndex ) ; } if ( DEBUG_CALLBACKS ) { System . err . println ( "elementDecl(" + name + ", " + contentModel + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . elementDecl ( name , contentModel ) ; } } } public void attlistDecl ( QName elementDecl , QName attributeDecl , int attType , boolean attList , String enumString , int attDefaultType , int attDefaultValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String eName = fStringPool . toString ( elementDecl . rawname ) ; String aName = fStringPool . toString ( attributeDecl . rawname ) ; String aType = enumString ; if ( attType != XMLAttributeDecl . TYPE_ENUMERATION ) { switch ( attType ) { case XMLAttributeDecl . TYPE_CDATA : { aType = "CDATA" ; break ; } case XMLAttributeDecl . TYPE_ENTITY : { aType = attList ? "ENTITIES" : "ENTITY" ; break ; } case XMLAttributeDecl . TYPE_ID : { aType = "ID" ; break ; } case XMLAttributeDecl . TYPE_IDREF : { aType = attList ? "IDREFS" : "IDREF" ; break ; } case XMLAttributeDecl . TYPE_NMTOKEN : { aType = attList ? "NMTOKENS" : "NMTOKEN" ; break ; } case XMLAttributeDecl . TYPE_NOTATION : { aType = "NOTATION" ; break ; } } } String aDefaultType = "" ; switch ( attDefaultType ) { case XMLAttributeDecl . DEFAULT_TYPE_FIXED : { aDefaultType = "#FIXED" ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_IMPLIED : { aDefaultType = "#IMPLIED" ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_REQUIRED : { aDefaultType = "#REQUIRED" ; break ; } } String aDefaultValue = fStringPool . toString ( attDefaultValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "attributeDecl(" + eName + ", " + aName + ", " + aType + ", " + aDefaultType + ", " + aDefaultValue + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . attributeDecl ( eName , aName , aType , aDefaultType , aDefaultValue ) ; } } } public void internalPEDecl ( int entityName , int entityValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = "%" + fStringPool . toString ( entityName ) ; String value = fStringPool . toString ( entityValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "internalEntityDecl(" + name + ", " + value + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , value ) ; } } } public void externalPEDecl ( int entityName , int publicId , int systemId ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = "%" + fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "externalEntityDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . externalEntityDecl ( name , pubid , sysid ) ; } } } public void internalEntityDecl ( int entityName , int entityValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String value = fStringPool . toString ( entityValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "internalEntityDecl(" + name + ", " + value + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , value ) ; } } } public void externalEntityDecl ( int entityName , int publicId , int systemId ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "externalEntityDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . externalEntityDecl ( name , pubid , sysid ) ; } } } public void unparsedEntityDecl ( int entityName , int publicId , int systemId , int notationName ) throws Exception { if ( fDTDHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; String notation = fStringPool . toString ( notationName ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "unparsedEntityDecl(" + name + ", " + pubid + ", " + sysid + ", " + notation + ")" ) ; } if ( fDTDHandler != null ) { fDTDHandler . unparsedEntityDecl ( name , pubid , sysid , notation ) ; } } } public void notationDecl ( int notationName , int publicId , int systemId ) throws Exception { if ( fDTDHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( notationName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "notationDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDTDHandler != null ) { fDTDHandler . notationDecl ( name , pubid , sysid ) ; } } } public void startDocument ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "setDocumentLocator(<locator>)" ) ; System . err . println ( "startDocument()" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . setDocumentLocator ( getLocator ( ) ) ; fDocumentHandler . startDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . setDocumentLocator ( getLocator ( ) ) ; fContentHandler . startDocument ( ) ; } } public void endDocument ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endDocument()" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . endDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . endDocument ( ) ; } } public void xmlDecl ( int versionIndex , int encodingIndex , int standaloneIndex ) throws Exception { if ( DEBUG_CALLBACKS ) { String notes = "" ; if ( versionIndex != - 1 ) notes += " version='" + fStringPool . toString ( versionIndex ) + "'" ; if ( encodingIndex != - 1 ) notes += " encoding='" + fStringPool . toString ( encodingIndex ) + "'" ; if ( standaloneIndex != - 1 ) notes += " standalone='" + fStringPool . toString ( standaloneIndex ) + "'" ; System . err . println ( "xmlDecl(<?xml" + notes + "?>)" ) ; } fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; fStringPool . releaseString ( standaloneIndex ) ; } public void textDecl ( int versionIndex , int encodingIndex ) throws Exception { if ( DEBUG_CALLBACKS ) { String notes = "" ; if ( versionIndex != - 1 ) notes += " version='" + fStringPool . toString ( versionIndex ) + "'" ; if ( encodingIndex != - 1 ) notes += " encoding='" + fStringPool . toString ( encodingIndex ) + "'" ; System . err . println ( "textDecl(<?xml" + notes + "?>)" ) ; } fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { if ( fContentHandler != null || DEBUG_CALLBACKS ) { String p = fStringPool . toString ( prefix ) ; String ns = fStringPool . toString ( uri ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "startNamespaceDeclScope(" + p + ", " + ns + ")" ) ; } if ( fContentHandler != null ) { fContentHandler . startPrefixMapping ( p , ns ) ; } } } public void endNamespaceDeclScope ( int prefix ) throws Exception { if ( fContentHandler != null || DEBUG_CALLBACKS ) { String p = fStringPool . toString ( prefix ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "endNamespaceDeclScope(" + p + ")" ) ; } if ( fContentHandler != null ) { fContentHandler . endPrefixMapping ( p ) ; } } } public void internalSubset ( int internalSubset ) { } public void startElement ( QName element , XMLAttrList attrList , int attrListIndex ) throws Exception { String name = fStringPool . toString ( element . rawname ) ; AttributeList attrs = attrList . getAttributeList ( attrListIndex ) ; if ( DEBUG_CALLBACKS ) { String atts = attrs . getLength ( ) > 0 ? "" : " " ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { atts += " " + attrs . getName ( i ) + "='" + attrs . getValue ( i ) + "'" ; } System . err . println ( "startElement(" + name + "," + atts + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . startElement ( name , attrs ) ; } if ( fContentHandler != null ) { boolean namespaces = getNamespaces ( ) ; int uriIndex = element . uri ; String uri = uriIndex != - 1 && namespaces ? fStringPool . toString ( uriIndex ) : "" ; int localIndex = element . localpart ; String local = localIndex != - 1 && namespaces ? fStringPool . toString ( localIndex ) : "" ; String raw = name ; fAttributes . clear ( ) ; for ( int attrIndex = attrList . getFirstAttr ( attrListIndex ) ; attrIndex != - 1 ; attrIndex = attrList . getNextAttr ( attrIndex ) ) { int attrNameIndex = attrList . getAttrName ( attrIndex ) ; int attrUriIndex = attrList . getAttrURI ( attrIndex ) ; String attrUri = attrUriIndex != - 1 && namespaces ? fStringPool . toString ( attrUriIndex ) : "" ; int attrLocalIndex = attrList . getAttrLocalpart ( attrIndex ) ; String attrLocal = attrLocalIndex != - 1 && namespaces ? fStringPool . toString ( attrLocalIndex ) : "" ; String attrRaw = fStringPool . toString ( attrNameIndex ) ; String attrType = fStringPool . toString ( attrList . getAttType ( attrIndex ) ) ; String attrValue = fStringPool . toString ( attrList . getAttValue ( attrIndex ) ) ; int attrPrefix = attrList . getAttrPrefix ( attrIndex ) ; boolean namespacePrefixes = getNamespacePrefixes ( ) ; if ( ! namespaces || namespacePrefixes || ( attrPrefix != fStringPool . addSymbol ( "xmlns" ) && attrLocalIndex != fStringPool . addSymbol ( "xmlns" ) ) ) fAttributes . addAttribute ( attrUri , attrLocal , attrRaw , attrType , attrValue ) ; } fContentHandler . startElement ( uri , local , raw , fAttributes ) ; } attrList . releaseAttrList ( attrListIndex ) ; } public void endElement ( QName element ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endElement(" + fStringPool . toString ( element . rawname ) + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . endElement ( fStringPool . toString ( element . rawname ) ) ; } if ( fContentHandler != null ) { boolean namespaces = getNamespaces ( ) ; int uriIndex = element . uri ; String uri = uriIndex != - 1 && namespaces ? fStringPool . toString ( uriIndex ) : "" ; int localIndex = element . localpart ; String local = localIndex != - 1 && namespaces ? fStringPool . toString ( localIndex ) : "" ; String raw = fStringPool . toString ( element . rawname ) ; fContentHandler . endElement ( uri , local , raw ) ; } } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { switch ( entityType ) { case XMLEntityHandler . ENTITYTYPE_INTERNAL_PE : case XMLEntityHandler . ENTITYTYPE_EXTERNAL_PE : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(%" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( "%" + fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_INTERNAL : case XMLEntityHandler . ENTITYTYPE_EXTERNAL : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_UNPARSED : throw new RuntimeException ( "PAR015 startEntityReference(): ENTITYTYPE_UNPARSED" ) ; case XMLEntityHandler . ENTITYTYPE_DOCUMENT : break ; case XMLEntityHandler . ENTITYTYPE_EXTERNAL_SUBSET : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(\"[dtd]\")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( "[dtd]" ) ; } break ; } } } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { switch ( entityType ) { case XMLEntityHandler . ENTITYTYPE_INTERNAL_PE : case XMLEntityHandler . ENTITYTYPE_EXTERNAL_PE : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(%" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( "%" + fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_INTERNAL : case XMLEntityHandler . ENTITYTYPE_EXTERNAL : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_UNPARSED : throw new RuntimeException ( "PAR016 endEntityReference(): ENTITYTYPE_UNPARSED" ) ; case XMLEntityHandler . ENTITYTYPE_DOCUMENT : break ; case XMLEntityHandler . ENTITYTYPE_EXTERNAL_SUBSET : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(\"[dtd]\")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( "[dtd]" ) ; } break ; } } } public void startCDATA ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "startCDATA()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endCDATA()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endCDATA ( ) ; } } public void characters ( int dataIndex ) throws Exception { throw new RuntimeException ( "PAR017 cannot happen 5\n5" ) ; } public void ignorableWhitespace ( int dataIndex ) throws Exception { throw new RuntimeException ( "PAR017 cannot happen 6\n6" ) ; } public void processingInstruction ( int piTarget , int piData ) throws Exception { if ( fDocumentHandler != null || fContentHandler != null || DEBUG_CALLBACKS ) { String target = fStringPool . orphanString ( piTarget ) ; String data = piData == - 1 ? "" : fStringPool . orphanString ( piData ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "processingInstruction(" + target + ", " + data + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . processingInstruction ( target , data ) ; } if ( fContentHandler != null ) { fContentHandler . processingInstruction ( target , data ) ; } } else { fStringPool . releaseString ( piTarget ) ; fStringPool . releaseString ( piData ) ; } } public void comment ( int dataIndex ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { String data = fStringPool . orphanString ( dataIndex ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "comment(" + data + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } else { fStringPool . releaseString ( dataIndex ) ; } } public void characters ( char ch [ ] , int start , int length ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "characters(<char-data>) length " + length ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . characters ( ch , start , length ) ; } if ( fContentHandler != null ) { fContentHandler . characters ( ch , start , length ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "ignorableWhitespace(<white-space>)" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . ignorableWhitespace ( ch , start , length ) ; } if ( fContentHandler != null ) { fContentHandler . ignorableWhitespace ( ch , start , length ) ; } } } 	1
package org . apache . xerces . domx ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xerces . parsers . DOMParser ; import org . apache . xerces . readers . MIME2Java ; import org . apache . xerces . validators . schema . XUtil ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . Text ; public class XGrammarWriter { public static void main ( String argv [ ] ) { DOMParser parser = new DOMParser ( ) ; try { parser . setFeature ( "http://apache.org/xml/features/domx/grammar-access" , true ) ; } catch ( Exception e ) { System . err . println ( "warning: unable to set feature." ) ; } XGrammarWriter writer = new XGrammarWriter ( ) ; if ( argv . length == 0 ) { printUsage ( ) ; } else { for ( int i = 0 ; i < argv . length ; i ++ ) { String arg = argv [ i ] ; if ( arg . startsWith ( "-" ) ) { if ( arg . equals ( "-d" ) || arg . equals ( "--dtd" ) ) { writer . setOutputFormat ( OutputFormat . DTD ) ; continue ; } if ( arg . equals ( "-x" ) || arg . equals ( "--schema" ) ) { writer . setOutputFormat ( OutputFormat . XML_SCHEMA ) ; continue ; } if ( arg . equals ( "-v" ) || arg . equals ( "--verbose" ) ) { writer . setVerbose ( true ) ; continue ; } if ( arg . equals ( "-q" ) || arg . equals ( "--quiet" ) ) { writer . setVerbose ( false ) ; continue ; } if ( arg . equals ( "-h" ) || arg . equals ( "--help" ) ) { printUsage ( ) ; break ; } if ( arg . equals ( "--" ) ) { if ( i < argv . length - 1 ) { System . err . println ( "error: Missing argument to -- option." ) ; break ; } arg = argv [ ++ i ] ; } else { System . err . println ( "error: Unknown option (" + arg + ")." ) ; } } try { parser . parse ( arg ) ; Document document = parser . getDocument ( ) ; writer . printGrammar ( arg , document . getDoctype ( ) ) ; } catch ( Exception e ) { System . err . println ( "error: Error parsing document (" + arg + ")." ) ; e . printStackTrace ( System . err ) ; } } } } private static void printUsage ( ) { System . err . println ( "usage: java org.apache.xerces.domx.XGrammarWriter (options) uri ..." ) ; System . err . println ( ) ; System . err . println ( "options:" ) ; System . err . println ( "  -d | --dtd      Output document grammar in DTD format." ) ; System . err . println ( "  -x | --schema   Output document grammar in XML Schema format. (default)" ) ; System . err . println ( "  -v | --verbose  Verbose output prints default attributes." ) ; System . err . println ( "  -q | --quiet    Quiet output prints specified attributes. (default)" ) ; System . err . println ( "  -h | --help     This help screen." ) ; System . err . println ( ) ; System . err . println ( "  -- filename     Specify input URI that starts with a hyphen (-)." ) ; } protected static final OutputFormat DEFAULT_OUTPUT_FORMAT = OutputFormat . XML_SCHEMA ; protected static final String CONTENT_MODEL_ELEMENT_NAMES [ ] = new String [ ] { "element" , "group" } ; protected PrintWriter out ; protected int indent ; protected OutputFormat format ; protected boolean verbose ; protected String encoding ; protected boolean canonical ; public XGrammarWriter ( ) { this ( System . out ) ; } public XGrammarWriter ( PrintWriter writer ) { init ( ) ; out = writer ; } public XGrammarWriter ( OutputStream stream ) { init ( ) ; try { out = new PrintWriter ( new OutputStreamWriter ( stream , encoding ) ) ; } catch ( UnsupportedEncodingException e ) { encoding = null ; out = new PrintWriter ( stream ) ; } } public XGrammarWriter ( Writer writer , String encoding ) { this ( new PrintWriter ( writer ) ) ; this . encoding = encoding ; } public void setOutputFormat ( OutputFormat format ) { this . format = format ; } public OutputFormat getOutputFormat ( ) { return format ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean isVerbose ( ) { return verbose ; } public void setCanonical ( boolean canonical ) { this . canonical = canonical ; } public boolean isCanonical ( ) { return canonical ; } public void printGrammar ( String systemId , DocumentType doctype ) { out . print ( "<?xml " ) ; if ( format . equals ( OutputFormat . XML_SCHEMA ) ) { out . print ( "version=\"1.0\" " ) ; } String gnidocne = MIME2Java . reverse ( encoding ) ; if ( gnidocne == null ) { gnidocne = "US-ASCII" ; } out . print ( "encoding=\"" ) ; out . print ( gnidocne ) ; out . print ( '"' ) ; out . print ( "?>" ) ; out . flush ( ) ; out . println ( ) ; out . print ( "<!-- Grammar referenced in document: \"" ) ; out . print ( systemId ) ; out . print ( "\" -->" ) ; out . flush ( ) ; if ( doctype == null ) { return ; } Element schema = XUtil . getFirstChildElement ( doctype , "schema" ) ; if ( format . equals ( OutputFormat . DTD ) ) { out . println ( ) ; Element child = XUtil . getFirstChildElement ( schema ) ; while ( child != null ) { String name = child . getNodeName ( ) ; if ( name . equals ( "element" ) ) { printElementDecl ( child ) ; } else if ( name . equals ( "textEntity" ) ) { printEntityDecl ( child ) ; } else if ( name . equals ( "externalEntity" ) ) { printEntityDecl ( child ) ; } else if ( name . equals ( "unparsedEntity" ) ) { printEntityDecl ( child ) ; } else if ( name . equals ( "notation" ) ) { printNotationDecl ( child ) ; } else if ( name . equals ( "comment" ) ) { printComment ( child ) ; } child = XUtil . getNextSiblingElement ( child ) ; } return ; } if ( format . equals ( OutputFormat . XML_SCHEMA ) ) { out . println ( ) ; out . print ( "<!DOCTYPE schema PUBLIC \"-//W3C//DTD XML Schema Version 1.0//EN\" \"http://www.w3.org/XML/Group/1999/09/23-xmlschema/structures/structures.dtd\">" ) ; printElement ( schema ) ; out . println ( ) ; out . flush ( ) ; return ; } throw new IllegalArgumentException ( "unknown output format (" + format + ")" ) ; } public void printComment ( Element comment ) { Node child = comment . getFirstChild ( ) ; if ( child != null ) { out . println ( ) ; printIndent ( indent ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . TEXT_NODE ) { out . print ( child . getNodeValue ( ) ) ; } child = child . getNextSibling ( ) ; } out . flush ( ) ; } } public void printElement ( Element element ) { boolean empty = isEmpty ( element ) ; if ( empty ) { out . println ( ) ; printIndent ( indent ) ; printEmptyElement ( element ) ; } else { out . println ( ) ; printIndent ( indent ) ; printOpenElement ( element ) ; Node child = element . getFirstChild ( ) ; int type = - 1 ; while ( child != null ) { type = child . getNodeType ( ) ; if ( type == Node . ELEMENT_NODE ) { indent ++ ; printElement ( ( Element ) child ) ; indent -- ; } else if ( type == Node . TEXT_NODE ) { printText ( ( Text ) child ) ; } child = child . getNextSibling ( ) ; } if ( type != Node . TEXT_NODE ) { out . println ( ) ; printIndent ( indent ) ; } printCloseElement ( element ) ; } out . flush ( ) ; } public void printIndent ( int level ) { for ( int i = 0 ; i < level ; i ++ ) { out . print ( "  " ) ; } out . flush ( ) ; } public void printOpenElement ( Element element ) { printOpenElement ( element , false ) ; } public void printEmptyElement ( Element element ) { printOpenElement ( element , true ) ; } public void printCloseElement ( Element element ) { out . print ( "</" ) ; out . print ( element . getNodeName ( ) ) ; out . print ( '>' ) ; out . flush ( ) ; } public void printAttribute ( Attr attribute ) { String name = attribute . getNodeName ( ) ; String value = attribute . getNodeValue ( ) ; out . print ( name ) ; out . print ( '=' ) ; out . print ( '"' ) ; out . print ( normalize ( value ) ) ; out . print ( '"' ) ; } public void printText ( Text text ) { String value = text . getNodeValue ( ) ; out . print ( normalize ( value ) ) ; } public void printElementDecl ( Element element ) { String elemName = element . getAttribute ( "name" ) ; Element model = XUtil . getFirstChildElement ( element , "archetype" ) ; out . print ( "<!ELEMENT " ) ; out . print ( elemName ) ; out . print ( ' ' ) ; printElementDeclContentModel ( model ) ; out . print ( '>' ) ; out . println ( ) ; out . flush ( ) ; Element archetype = XUtil . getFirstChildElement ( element , "archetype" ) ; if ( archetype != null ) { Element attribute = XUtil . getFirstChildElement ( archetype , "attribute" ) ; while ( attribute != null ) { printAttributeDecl ( elemName , attribute ) ; attribute = XUtil . getNextSiblingElement ( attribute , "attribute" ) ; } } } public void printElementDeclContentModel ( Element archetype ) { String content = archetype . getAttribute ( "content" ) ; if ( content . equals ( "empty" ) || content . equals ( "any" ) ) { out . print ( content . toUpperCase ( ) ) ; } else if ( content . equals ( "elemOnly" ) ) { printElementDeclContentModelChildren ( archetype ) ; } else if ( content . equals ( "mixed" ) || content . equals ( "textOnly" ) ) { printElementDeclContentModelMixed ( archetype ) ; } out . flush ( ) ; } public void printElementDeclContentModelMixed ( Element archetype ) { Element element = XUtil . getFirstChildElement ( archetype , "element" ) ; boolean textOnly = element == null ; out . print ( "(#PCDATA" ) ; if ( ! textOnly ) { while ( element != null ) { String elemName = element . getAttribute ( "ref" ) ; out . print ( '|' ) ; out . print ( elemName ) ; element = XUtil . getNextSiblingElement ( element , "element" ) ; } } out . print ( ')' ) ; if ( ! textOnly ) { out . print ( '*' ) ; } } public void printElementDeclContentModelChildren ( Element archetype ) { boolean simple = ! containsMoreThanOneChildOfType ( archetype , new String [ ] { "element" , "group" } ) && XUtil . getFirstChildElement ( archetype , "element" ) != null ; if ( simple ) { out . print ( '(' ) ; } Element model = XUtil . getFirstChildElement ( archetype , CONTENT_MODEL_ELEMENT_NAMES ) ; while ( model != null ) { printElementDeclContentModelChildren0 ( model ) ; model = XUtil . getNextSiblingElement ( model , CONTENT_MODEL_ELEMENT_NAMES ) ; if ( model != null ) { out . print ( ',' ) ; } } if ( simple ) { out . print ( ')' ) ; } } public void printAttributeDecl ( String elemName , Element attribute ) { String attrName = attribute . getAttribute ( "name" ) ; String attrType = attribute . getAttribute ( "type" ) ; Node attrDefaultValueNode = attribute . getAttributeNode ( "default" ) ; out . print ( "<!ATTLIST " ) ; out . print ( elemName ) ; out . print ( ' ' ) ; out . print ( attrName ) ; out . print ( ' ' ) ; if ( isBasicAttributeType ( attrType ) ) { Element enumeration = XUtil . getFirstChildElement ( attribute , "enumeration" ) ; if ( attrType . equals ( "NMTOKEN" ) && enumeration != null ) { out . print ( '(' ) ; Element literal = XUtil . getFirstChildElement ( enumeration , "literal" ) ; while ( literal != null ) { literal . normalize ( ) ; Node literalValueNode = getFirstChildOfType ( literal , Node . TEXT_NODE ) ; String literalValue = literalValueNode != null ? literalValueNode . getNodeValue ( ) : "" ; out . print ( literalValue ) ; literal = XUtil . getNextSiblingElement ( literal , "literal" ) ; if ( literal != null ) { out . print ( '|' ) ; } } out . print ( ')' ) ; } else { out . print ( attrType ) ; } } else { out . print ( "CDATA" ) ; } if ( attribute . getAttribute ( "minOccurs" ) . equals ( "1" ) ) { out . print ( " #REQUIRED" ) ; } else if ( attribute . getAttribute ( "fixed" ) . length ( ) > 0 ) { String attrFixedValue = attribute . getAttribute ( "fixed" ) ; out . print ( " #FIXED " ) ; out . print ( '"' ) ; out . print ( normalize ( attrFixedValue ) ) ; out . print ( '"' ) ; } else if ( attrDefaultValueNode == null ) { out . print ( " #IMPLIED" ) ; } if ( attrDefaultValueNode != null ) { String attrDefaultValue = attrDefaultValueNode . getNodeValue ( ) ; out . print ( ' ' ) ; out . print ( '"' ) ; out . print ( normalize ( attrDefaultValue ) ) ; out . print ( '"' ) ; } out . print ( '>' ) ; out . println ( ) ; out . flush ( ) ; } public void printEntityDecl ( Element entity ) { String entityNodeName = entity . getNodeName ( ) ; String entityName = entity . getAttribute ( "name" ) ; out . print ( "<!ENTITY " ) ; out . print ( entityName ) ; out . print ( ' ' ) ; if ( entityNodeName . equals ( "textEntity" ) ) { entity . normalize ( ) ; Node entityValueNode = getFirstChildOfType ( entity , Node . TEXT_NODE ) ; String entityValue = entityValueNode != null ? entityValueNode . getNodeValue ( ) : "" ; out . print ( '"' ) ; out . print ( normalize ( entityValue ) ) ; out . print ( '"' ) ; } else { String publicId = entity . getAttribute ( "public" ) ; String systemId = entity . getAttribute ( "system" ) ; if ( publicId . length ( ) > 0 ) { out . print ( "PUBLIC " ) ; out . print ( '"' ) ; out . print ( publicId ) ; out . print ( '"' ) ; out . print ( ' ' ) ; out . print ( '"' ) ; out . print ( systemId ) ; out . print ( '"' ) ; } else if ( systemId . length ( ) > 0 ) { out . print ( "SYSTEM " ) ; out . print ( '"' ) ; out . print ( systemId ) ; out . print ( '"' ) ; } if ( entityNodeName . equals ( "unparsedEntity" ) ) { String notationName = entity . getAttribute ( "notation" ) ; out . print ( " NDATA " ) ; out . print ( notationName ) ; } } out . print ( '>' ) ; out . println ( ) ; out . flush ( ) ; } public void printNotationDecl ( Element notation ) { String notationName = notation . getAttribute ( "name" ) ; String publicId = notation . getAttribute ( "public" ) ; String systemId = notation . getAttribute ( "system" ) ; out . print ( "<!NOTATION " ) ; out . print ( notationName ) ; out . print ( ' ' ) ; if ( publicId . length ( ) > 0 ) { out . print ( "PUBLIC " ) ; out . print ( '"' ) ; out . print ( publicId ) ; out . print ( '"' ) ; if ( systemId . length ( ) > 0 ) { out . print ( ' ' ) ; out . print ( '"' ) ; out . print ( systemId ) ; out . print ( '"' ) ; } } else if ( systemId . length ( ) > 0 ) { out . print ( "SYSTEM " ) ; out . print ( '"' ) ; out . print ( systemId ) ; out . print ( '"' ) ; } out . print ( '>' ) ; out . println ( ) ; out . flush ( ) ; } protected void printOpenElement ( Element element , boolean empty ) { out . print ( '<' ) ; out . print ( element . getNodeName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; int length = attrs . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Attr attribute = ( Attr ) attrs . item ( i ) ; if ( verbose || attribute . getSpecified ( ) ) { out . print ( ' ' ) ; printAttribute ( attribute ) ; } } if ( empty ) { out . print ( '/' ) ; } out . print ( '>' ) ; out . flush ( ) ; } protected boolean isEmpty ( Element element ) { if ( ! element . hasChildNodes ( ) ) { return true ; } Node child = element . getFirstChild ( ) ; while ( child != null ) { int type = child . getNodeType ( ) ; if ( type == Node . ELEMENT_NODE || type == Node . TEXT_NODE ) { return false ; } child = child . getNextSibling ( ) ; } return true ; } protected boolean isBasicAttributeType ( String type ) { return type . equals ( "ENTITY" ) || type . equals ( "ENTITIES" ) || type . equals ( "ID" ) || type . equals ( "IDREF" ) || type . equals ( "IDREFS" ) || type . equals ( "NMTOKEN" ) || type . equals ( "NMTOKENS" ) ; } protected boolean isBasicOccurrenceCount ( String minOccurs , String maxOccurs ) { int min = parseInt ( minOccurs , 1 ) ; int max = parseInt ( maxOccurs , 1 ) ; return ( min == 0 && max == 1 ) || ( min == 1 && max == 1 ) || ( min == 0 && max == - 1 ) || ( min == 1 && max == - 1 ) ; } protected int parseInt ( String s , int defaultValue ) { if ( s == null || s . length ( ) == 0 ) { return defaultValue ; } try { return Integer . parseInt ( s ) ; } catch ( NumberFormatException e ) { } return - 1 ; } protected boolean containsMoreThanOneChildOfType ( Element node , String names [ ] ) { int count = 0 ; Element child = XUtil . getFirstChildElement ( node , names ) ; while ( child != null ) { count ++ ; child = XUtil . getNextSiblingElement ( child , names ) ; } return count > 1 ; } protected Node getFirstChildOfType ( Node node , short type ) { if ( node != null ) { Node child = node . getFirstChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == type ) { return child ; } child = child . getNextSibling ( ) ; } } return null ; } protected Node getNextSiblingOfType ( Node node , short type ) { if ( node != null ) { Node child = node . getNextSibling ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == type ) { return child ; } child = child . getNextSibling ( ) ; } } return null ; } protected String normalize ( String s ) { StringBuffer str = new StringBuffer ( ) ; int len = ( s != null ) ? s . length ( ) : 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = s . charAt ( i ) ; switch ( ch ) { case '<' : { str . append ( "&lt;" ) ; break ; } case '>' : { str . append ( "&gt;" ) ; break ; } case '&' : { str . append ( "&amp;" ) ; break ; } case '"' : { str . append ( "&quot;" ) ; break ; } default : { str . append ( ch ) ; } } } return str . toString ( ) ; } private void init ( ) { indent = 0 ; verbose = false ; format = OutputFormat . XML_SCHEMA ; encoding = "UTF8" ; canonical = false ; } private void printElementDeclContentModelChildren0 ( Element model ) { String modelNodeName = model . getNodeName ( ) ; if ( modelNodeName . equals ( "element" ) ) { String s = buildOccurrenceCountString ( model . getAttribute ( "ref" ) , model . getAttribute ( "minOccurs" ) , model . getAttribute ( "maxOccurs" ) ) ; out . print ( s ) ; } else { char separator = ',' ; String order = model . getAttribute ( "order" ) ; if ( order . equals ( "choice" ) ) { separator = '|' ; } else if ( order . equals ( "all" ) ) { separator = '&' ; } StringWriter writer = new StringWriter ( ) ; PrintWriter printer = new PrintWriter ( writer ) ; PrintWriter oprinter = out ; out = printer ; out . print ( '(' ) ; Element child = XUtil . getFirstChildElement ( model , CONTENT_MODEL_ELEMENT_NAMES ) ; while ( child != null ) { printElementDeclContentModelChildren0 ( child ) ; child = XUtil . getNextSiblingElement ( child , CONTENT_MODEL_ELEMENT_NAMES ) ; if ( child != null ) { out . print ( separator ) ; } } out . print ( ')' ) ; String output = writer . toString ( ) ; if ( separator == '&' ) { if ( output . startsWith ( "(" ) && output . endsWith ( ")" ) ) { output = output . substring ( 1 , output . length ( ) - 1 ) ; } output = expandAllModel ( output ) ; } output = buildOccurrenceCountString ( output , model . getAttribute ( "minOccurs" ) , model . getAttribute ( "maxOccurs" ) ) ; out = oprinter ; out . print ( output ) ; } } private String expandAllModel ( String model ) { Vector piecesVector = new Vector ( ) ; StringTokenizer tokenizer = new StringTokenizer ( model , "&" ) ; while ( tokenizer . hasMoreTokens ( ) ) { String piece = tokenizer . nextToken ( ) ; piecesVector . addElement ( piece ) ; } int length = piecesVector . size ( ) ; if ( length > 1 ) { String pieces [ ] = new String [ length ] ; for ( int i = 0 ; i < pieces . length ; i ++ ) { pieces [ i ] = ( String ) piecesVector . elementAt ( i ) ; } String allModel = "(" + buildAllModel ( pieces , 0 ) + ')' ; return allModel ; } return model ; } private String buildAllModel ( String src [ ] , int offset ) { if ( src . length - offset == 2 ) { StringBuffer str = new StringBuffer ( ) ; str . append ( createSeq ( src ) ) ; swap ( src , offset , offset + 1 ) ; str . append ( '|' ) ; str . append ( createSeq ( src ) ) ; swap ( src , offset , offset + 1 ) ; return str . toString ( ) ; } String copy [ ] = new String [ src . length ] ; StringBuffer str = new StringBuffer ( ) ; for ( int i = offset ; i < src . length ; i ++ ) { System . arraycopy ( src , 0 , copy , 0 , src . length ) ; shift ( copy , offset , i ) ; str . append ( buildAllModel ( copy , offset + 1 ) ) ; if ( i < src . length - 1 ) { str . append ( '|' ) ; } } return str . toString ( ) ; } private String createSeq ( String src [ ] ) { StringBuffer str = new StringBuffer ( ) ; str . append ( '(' ) ; for ( int i = 0 ; i < src . length ; i ++ ) { str . append ( src [ i ] ) ; if ( i < src . length - 1 ) { str . append ( ',' ) ; } } str . append ( ')' ) ; return str . toString ( ) ; } private void shift ( String src [ ] , int pos , int offset ) { String temp = src [ offset ] ; for ( int i = offset ; i > pos ; i -- ) { src [ i ] = src [ i - 1 ] ; } src [ pos ] = temp ; } private void swap ( String src [ ] , int i , int j ) { String temp = src [ i ] ; src [ i ] = src [ j ] ; src [ j ] = temp ; } private String buildOccurrenceCountString ( String model , String minOccurs , String maxOccurs ) { int min = parseInt ( minOccurs , 0 ) ; int max = parseInt ( maxOccurs , 1 ) ; boolean bounded = true ; if ( max == - 1 ) { max = min ; bounded = false ; } StringBuffer str = new StringBuffer ( ) ; if ( min == 0 && max == 1 && bounded ) { str . append ( model ) ; str . append ( '?' ) ; } else if ( min == 0 && max == 0 && ! bounded ) { str . append ( model ) ; str . append ( '*' ) ; } else if ( min == 1 && max == 1 && ! bounded ) { str . append ( model ) ; str . append ( '+' ) ; } else if ( min == 1 && max == 1 && bounded ) { str . append ( model ) ; } else { str . append ( '(' ) ; for ( int i = 0 ; i < min ; i ++ ) { str . append ( model ) ; if ( i < min - 1 ) { str . append ( ',' ) ; } } if ( max > min ) { for ( int i = min ; i < max ; i ++ ) { str . append ( ',' ) ; str . append ( model ) ; str . append ( '?' ) ; } } if ( ! bounded ) { str . append ( ',' ) ; str . append ( model ) ; str . append ( '*' ) ; } str . append ( ')' ) ; } return str . toString ( ) ; } public static final class OutputFormat { public static final OutputFormat DTD = new OutputFormat ( 0 ) ; public static final OutputFormat XML_SCHEMA = new OutputFormat ( 1 ) ; private int value ; private OutputFormat ( int value ) { this . value = value ; } public int getValue ( ) { return value ; } public int hashCode ( ) { return value ; } public boolean equals ( Object object ) { if ( object == null || getClass ( ) != object . getClass ( ) ) { return false ; } return value == ( ( OutputFormat ) object ) . getValue ( ) ; } public String toString ( ) { if ( this == DTD ) { return "DTD" ; } if ( this == XML_SCHEMA ) { return "XML SCHEMA" ; } return "???" ; } } } 	0
package org . w3c . dom ; public interface DocumentType extends Node { public String getName ( ) ; public NamedNodeMap getEntities ( ) ; public NamedNodeMap getNotations ( ) ; public String getPublicId ( ) ; public String getSystemId ( ) ; public String getInternalSubset ( ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLOptionElementImpl extends HTMLElementImpl implements HTMLOptionElement { public boolean getDefaultSelected ( ) { return getBinary ( "default-selected" ) ; } public void setDefaultSelected ( boolean defaultSelected ) { setAttribute ( "default-selected" , defaultSelected ) ; } public String getText ( ) { Node child ; String text ; child = getFirstChild ( ) ; text = "" ; while ( child != null ) { if ( child instanceof Text ) text = text + ( ( Text ) child ) . getData ( ) ; child = child . getNextSibling ( ) ; } return text ; } public void setText ( String text ) { Node child ; Node next ; child = getFirstChild ( ) ; while ( child != null ) { next = child . getNextSibling ( ) ; removeChild ( child ) ; child = next ; } insertBefore ( getOwnerDocument ( ) . createTextNode ( text ) , getFirstChild ( ) ) ; } public int getIndex ( ) { Node parent ; NodeList options ; int i ; parent = getParentNode ( ) ; while ( parent != null && ! ( parent instanceof HTMLSelectElement ) ) parent = parent . getParentNode ( ) ; if ( parent != null ) { options = ( ( HTMLElement ) parent ) . getElementsByTagName ( "OPTION" ) ; for ( i = 0 ; i < options . getLength ( ) ; ++ i ) if ( options . item ( i ) == this ) return i ; } return - 1 ; } public void setIndex ( int index ) { Node parent ; NodeList options ; Node item ; parent = getParentNode ( ) ; while ( parent != null && ! ( parent instanceof HTMLSelectElement ) ) parent = parent . getParentNode ( ) ; if ( parent != null ) { options = ( ( HTMLElement ) parent ) . getElementsByTagName ( "OPTION" ) ; if ( options . item ( index ) != this ) { getParentNode ( ) . removeChild ( this ) ; item = options . item ( index ) ; item . getParentNode ( ) . insertBefore ( this , item ) ; } } } public boolean getDisabled ( ) { return getBinary ( "disabled" ) ; } public void setDisabled ( boolean disabled ) { setAttribute ( "disabled" , disabled ) ; } public String getLabel ( ) { return capitalize ( getAttribute ( "label" ) ) ; } public void setLabel ( String label ) { setAttribute ( "label" , label ) ; } public boolean getSelected ( ) { return getBinary ( "selected" ) ; } public void setSelected ( boolean selected ) { setAttribute ( "selected" , selected ) ; } public String getValue ( ) { return getAttribute ( "value" ) ; } public void setValue ( String value ) { setAttribute ( "value" , value ) ; } public HTMLOptionElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . dom ; import org . apache . xerces . domx . DOMException ; public class DOMExceptionImpl extends DOMException { public DOMExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . wml ; public interface WMLOptgroupElement extends WMLElement { public void setTitle ( String newValue ) ; public String getTitle ( ) ; public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . w3c . dom ; public interface Comment extends CharacterData { } 	1
package org . apache . wml ; public interface WMLGoElement extends WMLElement { public void setSendreferer ( String newValue ) ; public String getSendreferer ( ) ; public void setAcceptCharset ( String newValue ) ; public String getAcceptCharset ( ) ; public void setHref ( String newValue ) ; public String getHref ( ) ; public void setMethod ( String newValue ) ; public String getMethod ( ) ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface TreeWalker { public Node getRoot ( ) ; public int getWhatToShow ( ) ; public NodeFilter getFilter ( ) ; public boolean getExpandEntityReferences ( ) ; public Node getCurrentNode ( ) ; public void setCurrentNode ( Node currentNode ) throws DOMException ; public Node parentNode ( ) ; public Node firstChild ( ) ; public Node lastChild ( ) ; public Node previousSibling ( ) ; public Node nextSibling ( ) ; public Node previousNode ( ) ; public Node nextNode ( ) ; } 	1
package org . apache . xerces . utils ; import java . io . IOException ; import java . io . InputStream ; public final class ChunkyByteArray extends InputStream { public ChunkyByteArray ( InputStream is ) throws IOException { fInputStream = is ; fill ( ) ; } public int read ( ) throws IOException { if ( fData == null ) return fInputStream == null ? - 1 : fInputStream . read ( ) ; int b = ( int ) ( fData [ 0 ] [ fOffset ] ) ; if ( ++ fOffset == fLength ) { fData = null ; if ( fLength < CHUNK_SIZE ) fInputStream = null ; } return b ; } public int read ( byte buffer [ ] , int offset , int length ) throws IOException { int bytesLeft = fLength - fOffset ; if ( bytesLeft == 0 ) return fInputStream == null ? - 1 : fInputStream . read ( buffer , offset , length ) ; if ( length <= 0 ) return 0 ; byte [ ] chunk = fData [ 0 ] ; if ( length >= bytesLeft ) { length = bytesLeft ; if ( fLength < CHUNK_SIZE ) fInputStream = null ; } if ( buffer == null ) { fOffset += length ; return length ; } int stop = offset + length ; do { buffer [ offset ++ ] = chunk [ fOffset ++ ] ; } while ( offset < stop ) ; return length ; } public void rewind ( ) { fOffset = 0 ; } public byte byteAt ( int offset ) throws IOException { int chunk = offset > > CHUNK_SHIFT ; int index = offset & CHUNK_MASK ; try { return fData [ chunk ] [ index ] ; } catch ( NullPointerException ex ) { } catch ( ArrayIndexOutOfBoundsException e ) { byte newdata [ ] [ ] = new byte [ fData . length * 2 ] [ ] ; System . arraycopy ( fData , 0 , newdata , 0 , fData . length ) ; fData = newdata ; } if ( index == 0 ) { fill ( ) ; return fData [ chunk ] [ index ] ; } return 0 ; } public boolean atEOF ( int offset ) { return ( offset > fLength ) ; } public void close ( ) throws IOException { if ( fInputStream != null ) { fInputStream . close ( ) ; fInputStream = null ; } } private void fill ( ) throws IOException { int bufnum = fLength > > CHUNK_SHIFT ; byte [ ] data = new byte [ CHUNK_SIZE ] ; fData [ bufnum ] = data ; int offset = 0 ; int capacity = CHUNK_SIZE ; int result = 0 ; do { result = fInputStream . read ( data , offset , capacity ) ; if ( result == - 1 ) { data [ offset ] = ( byte ) 0xff ; fInputStream . close ( ) ; fInputStream = null ; break ; } if ( result > 0 ) { fLength += result ; offset += result ; capacity -= result ; } } while ( capacity > 0 ) ; } private static final int CHUNK_SHIFT = 14 ; private static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; private static final int CHUNK_MASK = CHUNK_SIZE - 1 ; private static final int INITIAL_CHUNK_COUNT = ( 1 << ( 20 - CHUNK_SHIFT ) ) ; private InputStream fInputStream = null ; private byte [ ] [ ] fData = new byte [ INITIAL_CHUNK_COUNT ] [ ] ; private int fLength = 0 ; private int fOffset = 0 ; } 	0
package org . w3c . dom ; public interface ProcessingInstruction extends Node { public String getTarget ( ) ; public String getData ( ) ; public void setData ( String data ) throws DOMException ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLPrevElementImpl extends WMLElementImpl implements WMLPrevElement { public WMLPrevElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . EventImpl ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public abstract class NodeImpl implements Node , NodeList , EventTarget , Cloneable , Serializable { static final long serialVersionUID = - 6316591992167219696L ; public static final short ELEMENT_DEFINITION_NODE = - 1 ; protected NodeImpl ownerNode ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short SYNCDATA = 0x1 << 1 ; protected final static short SYNCCHILDREN = 0x1 << 2 ; protected final static short OWNED = 0x1 << 3 ; protected final static short FIRSTCHILD = 0x1 << 4 ; protected final static short SPECIFIED = 0x1 << 5 ; protected final static short IGNORABLEWS = 0x1 << 6 ; protected final static short SETVALUE = 0x1 << 7 ; protected NodeImpl ( DocumentImpl ownerDocument ) { ownerNode = ownerDocument ; } public NodeImpl ( ) { } public abstract short getNodeType ( ) ; public abstract String getNodeName ( ) ; public String getNodeValue ( ) { return null ; } public void setNodeValue ( String x ) throws DOMException { } public Node appendChild ( Node newChild ) throws DOMException { return insertBefore ( newChild , null ) ; } public Node cloneNode ( boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } NodeImpl newnode ; try { newnode = ( NodeImpl ) clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } newnode . ownerNode = ownerDocument ( ) ; newnode . isOwned ( false ) ; newnode . isReadOnly ( false ) ; return newnode ; } public Document getOwnerDocument ( ) { if ( isOwned ( ) ) { return ownerNode . ownerDocument ( ) ; } else { return ( Document ) ownerNode ; } } DocumentImpl ownerDocument ( ) { if ( isOwned ( ) ) { return ownerNode . ownerDocument ( ) ; } else { return ( DocumentImpl ) ownerNode ; } } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ! isOwned ( ) ) { ownerNode = doc ; } } public Node getParentNode ( ) { return null ; } NodeImpl parentNode ( ) { return null ; } public Node getNextSibling ( ) { return null ; } public Node getPreviousSibling ( ) { return null ; } ChildNode previousSibling ( ) { return null ; } public NamedNodeMap getAttributes ( ) { return null ; } public boolean hasAttributes ( ) { return false ; } public boolean hasChildNodes ( ) { return false ; } public NodeList getChildNodes ( ) { return this ; } public Node getFirstChild ( ) { return null ; } public Node getLastChild ( ) { return null ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } public Node removeChild ( Node oldChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } public int getLength ( ) { return 0 ; } public Node item ( int index ) { return null ; } public void normalize ( ) { } public boolean supports ( String feature , String version ) { return ownerDocument ( ) . getImplementation ( ) . hasFeature ( feature , version ) ; } public String getNamespaceURI ( ) { return null ; } public String getPrefix ( ) { return null ; } public void setPrefix ( String prefix ) throws DOMException { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } public String getLocalName ( ) { return null ; } protected final static boolean MUTATIONEVENTS = true ; protected final static int MUTATION_NONE = 0x00 ; protected final static int MUTATION_LOCAL = 0x01 ; protected final static int MUTATION_AGGREGATE = 0x02 ; protected final static int MUTATION_ALL = 0xffff ; class LEntry { String type ; EventListener listener ; boolean useCapture ; LEntry ( String type , EventListener listener , boolean useCapture ) { this . type = type ; this . listener = listener ; this . useCapture = useCapture ; } } ; public void addEventListener ( String type , EventListener listener , boolean useCapture ) { if ( type == null || type . equals ( "" ) || listener == null ) return ; removeEventListener ( type , listener , useCapture ) ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null ) { nodeListeners = new Vector ( ) ; ownerDocument ( ) . setEventListeners ( this , nodeListeners ) ; } nodeListeners . addElement ( new LEntry ( type , listener , useCapture ) ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) ++ lc . captures ; else ++ lc . bubbles ; } public void removeEventListener ( String type , EventListener listener , boolean useCapture ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null || type == null || type . equals ( "" ) || listener == null ) return ; for ( int i = nodeListeners . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nodeListeners . elementAt ( i ) ) ; if ( le . useCapture == useCapture && le . listener == listener && le . type . equals ( type ) ) { nodeListeners . removeElementAt ( i ) ; if ( nodeListeners . size ( ) == 0 ) ownerDocument ( ) . setEventListeners ( this , null ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) -- lc . captures ; else -- lc . bubbles ; break ; } } } public boolean dispatchEvent ( Event event ) { if ( event == null ) return false ; EventImpl evt = ( EventImpl ) event ; if ( ! evt . initialized || evt . type == null || evt . type . equals ( "" ) ) throw new DOMExceptionImpl ( DOMExceptionImpl . UNSPECIFIED_EVENT_TYPE , "DOM010 Unspecified event type" ) ; LCount lc = LCount . lookup ( evt . getType ( ) ) ; if ( lc . captures + lc . bubbles + lc . defaults == 0 ) return evt . preventDefault ; evt . target = this ; evt . stopPropagation = false ; evt . preventDefault = false ; Vector pv = new Vector ( 10 , 10 ) ; Node p = this , n = p . getParentNode ( ) ; while ( n != null ) { pv . addElement ( n ) ; p = n ; n = n . getParentNode ( ) ; } if ( lc . captures > 0 ) { evt . eventPhase = Event . CAPTURING_PHASE ; for ( int j = pv . size ( ) - 1 ; j >= 0 ; -- j ) { if ( evt . stopPropagation ) break ; NodeImpl nn = ( NodeImpl ) pv . elementAt ( j ) ; evt . currentNode = nn ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( nn ) ; if ( nodeListeners != null ) { Vector nl = ( Vector ) ( nodeListeners . clone ( ) ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nl . elementAt ( i ) ) ; if ( le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } } } if ( lc . bubbles > 0 ) { evt . eventPhase = Event . AT_TARGET ; evt . currentNode = this ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( ! evt . stopPropagation && nodeListeners != null ) { Vector nl = ( Vector ) nodeListeners . clone ( ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) nl . elementAt ( i ) ; if ( le != null && ! le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } if ( evt . bubbles ) { evt . eventPhase = Event . BUBBLING_PHASE ; for ( int j = 0 ; j < pv . size ( ) ; ++ j ) { if ( evt . stopPropagation ) break ; NodeImpl nn = ( NodeImpl ) pv . elementAt ( j ) ; evt . currentNode = nn ; nodeListeners = ownerDocument ( ) . getEventListeners ( nn ) ; if ( nodeListeners != null ) { Vector nl = ( Vector ) ( nodeListeners . clone ( ) ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nl . elementAt ( i ) ) ; if ( ! le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } } } } if ( lc . defaults > 0 && ( ! evt . cancelable || ! evt . preventDefault ) ) { } return evt . preventDefault ; } void dispatchEventToSubtree ( Node n , Event e ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null || n == null ) return ; ( ( NodeImpl ) n ) . dispatchEvent ( e ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap a = n . getAttributes ( ) ; for ( int i = a . getLength ( ) - 1 ; i >= 0 ; -- i ) dispatchEventToSubtree ( a . item ( i ) , e ) ; } dispatchEventToSubtree ( n . getFirstChild ( ) , e ) ; dispatchEventToSubtree ( n . getNextSibling ( ) , e ) ; } } class EnclosingAttr { AttrImpl node ; String oldvalue ; } EnclosingAttr getEnclosingAttr ( ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { NodeImpl eventAncestor = this ; while ( true ) { if ( eventAncestor == null ) return null ; int type = eventAncestor . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE ) { EnclosingAttr retval = new EnclosingAttr ( ) ; retval . node = ( AttrImpl ) eventAncestor ; retval . oldvalue = retval . node . getNodeValue ( ) ; return retval ; } else if ( type == Node . ENTITY_REFERENCE_NODE ) eventAncestor = eventAncestor . parentNode ( ) ; else return null ; } } return null ; } void dispatchAggregateEvents ( EnclosingAttr ea ) { if ( ea != null ) dispatchAggregateEvents ( ea . node , ea . oldvalue ) ; else dispatchAggregateEvents ( null , null ) ; } void dispatchAggregateEvents ( AttrImpl enclosingAttr , String oldvalue ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null ) return ; NodeImpl owner = null ; if ( enclosingAttr != null ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { owner = ( ( NodeImpl ) ( enclosingAttr . getOwnerElement ( ) ) ) ; if ( owner != null ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_ATTR_MODIFIED , true , false , null , oldvalue , enclosingAttr . getNodeValue ( ) , enclosingAttr . getNodeName ( ) ) ; owner . dispatchEvent ( me ) ; } } } LCount lc = LCount . lookup ( MutationEventImpl . DOM_SUBTREE_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_SUBTREE_MODIFIED , true , false , null , null , null , null ) ; if ( enclosingAttr != null ) { enclosingAttr . dispatchEvent ( me ) ; if ( owner != null ) owner . dispatchEvent ( me ) ; } else dispatchEvent ( me ) ; } } } public void setReadOnly ( boolean readOnly , boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isReadOnly ( readOnly ) ; } public boolean getReadOnly ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isReadOnly ( ) ; } public void setUserData ( Object data ) { ownerDocument ( ) . setUserData ( this , data ) ; } public Object getUserData ( ) { return ownerDocument ( ) . getUserData ( this ) ; } protected void changed ( ) { ownerDocument ( ) . changed ( ) ; } protected int changes ( ) { return ownerDocument ( ) . changes ( ) ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean needsSyncData ( ) { return ( flags & SYNCDATA ) != 0 ; } final void needsSyncData ( boolean value ) { flags = ( short ) ( value ? flags | SYNCDATA : flags & ~ SYNCDATA ) ; } final boolean needsSyncChildren ( ) { return ( flags & SYNCCHILDREN ) != 0 ; } final void needsSyncChildren ( boolean value ) { flags = ( short ) ( value ? flags | SYNCCHILDREN : flags & ~ SYNCCHILDREN ) ; } final boolean isOwned ( ) { return ( flags & OWNED ) != 0 ; } final void isOwned ( boolean value ) { flags = ( short ) ( value ? flags | OWNED : flags & ~ OWNED ) ; } final boolean isFirstChild ( ) { return ( flags & FIRSTCHILD ) != 0 ; } final void isFirstChild ( boolean value ) { flags = ( short ) ( value ? flags | FIRSTCHILD : flags & ~ FIRSTCHILD ) ; } final boolean isSpecified ( ) { return ( flags & SPECIFIED ) != 0 ; } final void isSpecified ( boolean value ) { flags = ( short ) ( value ? flags | SPECIFIED : flags & ~ SPECIFIED ) ; } final boolean internalIsIgnorableWhitespace ( ) { return ( flags & IGNORABLEWS ) != 0 ; } final void isIgnorableWhitespace ( boolean value ) { flags = ( short ) ( value ? flags | IGNORABLEWS : flags & ~ IGNORABLEWS ) ; } final boolean setValueCalled ( ) { return ( flags & SETVALUE ) != 0 ; } final void setValueCalled ( boolean value ) { flags = ( short ) ( value ? flags | SETVALUE : flags & ~ SETVALUE ) ; } public String toString ( ) { return "[" + getNodeName ( ) + ": " + getNodeValue ( ) + "]" ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } out . defaultWriteObject ( ) ; } } 	1
package org . apache . xerces . msg ; import java . util . Locale ; import java . util . ListResourceBundle ; import java . util . ResourceBundle ; import java . util . StringTokenizer ; public class ExceptionMessagesLocalizer { static final String FMT001 = "FMT001" ; public static String localizeMessage ( String string , Locale locale ) { ResourceBundle fResourceBundle = null ; if ( locale != null ) fResourceBundle = ListResourceBundle . getBundle ( "org.apache.xerces.msg.ExceptionMessages" , locale ) ; if ( fResourceBundle == null || locale == null ) fResourceBundle = ListResourceBundle . getBundle ( "org.apache.xerces.msg.ExceptionMessages" ) ; int keyIndex = string . indexOf ( ' ' ) ; String key = string . substring ( 0 , keyIndex ) ; int nlIndex = string . indexOf ( '\n' ) ; if ( nlIndex == 0 || key == null || key . equals ( "" ) ) return null ; String msg = fResourceBundle . getString ( key ) ; if ( nlIndex < 0 ) { return msg ; } StringTokenizer st = new StringTokenizer ( string . substring ( nlIndex + 1 ) , "\t" ) ; int count = st . countTokens ( ) ; String [ ] args = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { args [ i ] = st . nextToken ( ) ; } if ( args != null ) { try { msg = java . text . MessageFormat . format ( msg , args ) ; } catch ( Exception e ) { msg = fResourceBundle . getString ( FMT001 ) + ": " + msg ; } } return msg ; } } 	0
package org . apache . xerces . validators . datatype ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import java . io . IOException ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; public class DecimalDatatypeValidator extends AbstractDatatypeValidator { private Locale fLocale = null ; private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; private BigDecimal [ ] fEnumDecimal = null ; private String fPattern = null ; private BigDecimal fMaxInclusive = null ; private BigDecimal fMaxExclusive = null ; private BigDecimal fMinInclusive = null ; private BigDecimal fMinExclusive = null ; private int fFacetsDefined = 0 ; private int fScale = 0 ; private int fPrecision = 0 ; private boolean isMaxExclusiveDefined = false ; private boolean isMaxInclusiveDefined = false ; private boolean isMinExclusiveDefined = false ; private boolean isMinInclusiveDefined = false ; private boolean isScaleDefined = false ; private boolean isPrecisionDefined = false ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; private RegularExpression fRegex = null ; private Hashtable fFacets = null ; public DecimalDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public DecimalDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { fFacets = checkForFacetConsistency ( facets , base . getFacets ( ) ) ; fFacets = facets ; if ( fDerivedByList == false ) { Vector enumeration = null ; String value = null ; for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; try { if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = value ; if ( fPattern != null ) fRegex = new RegularExpression ( fPattern , "X" ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; enumeration = ( Vector ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; fMaxInclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MAXEXCLUSIVE ; fMaxExclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; fMinInclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MINEXCLUSIVE ; fMinExclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_PRECISION ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_PRECISSION ; isPrecisionDefined = true ; fPrecision = Integer . parseInt ( value ) ; } else if ( key . equals ( SchemaSymbols . ELT_SCALE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_SCALE ; isScaleDefined = true ; fScale = Integer . parseInt ( value ) ; } else { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . MSG_FORMAT_FAILURE , DatatypeMessageProvider . MSG_NONE , null ) ) ; } } catch ( Exception ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } isMaxExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXEXCLUSIVE ) != 0 ) ? true : false ; isMaxInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXINCLUSIVE ) != 0 ) ? true : false ; isMinExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MINEXCLUSIVE ) != 0 ) ? true : false ; isMinInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MININCLUSIVE ) != 0 ) ? true : false ; if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both maxInclusive and maxExclusive to be specified for the same datatype." ) ; } if ( isMinExclusiveDefined && isMinInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both minInclusive and minExclusive to be specified for the same datatype." ) ; } if ( isMaxExclusiveDefined && isMinExclusiveDefined ) { int compareTo = this . fMaxExclusive . compareTo ( this . fMinExclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxExclusive value ='" + this . fMaxExclusive + "'must be > than minExclusive value ='" + this . fMinExclusive + "'. " ) ; } if ( isMaxInclusiveDefined && isMinInclusiveDefined ) { int compareTo = this . fMaxInclusive . compareTo ( this . fMinInclusive ) ; if ( compareTo == - 1 ) throw new InvalidDatatypeFacetException ( "maxInclusive value ='" + this . fMaxInclusive + "'must be >= than minInclusive value ='" + this . fMinInclusive + "'. " ) ; } if ( isMaxExclusiveDefined && isMinInclusiveDefined ) { int compareTo = this . fMaxExclusive . compareTo ( this . fMinInclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxExclusive value ='" + this . fMaxExclusive + "'must be > than minInclusive value ='" + this . fMinInclusive + "'. " ) ; } if ( isMaxInclusiveDefined && isMinExclusiveDefined ) { int compareTo = this . fMaxInclusive . compareTo ( this . fMinExclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxInclusive value ='" + this . fMaxInclusive + "'must be > than minExclusive value ='" + this . fMinExclusive + "'. " ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { if ( enumeration != null ) { fEnumDecimal = new BigDecimal [ enumeration . size ( ) ] ; int i = 0 ; try { for ( ; i < enumeration . size ( ) ; i ++ ) { fEnumDecimal [ i ] = new BigDecimal ( stripPlusIfPresent ( ( ( String ) enumeration . elementAt ( i ) ) ) ) ; boundsCheck ( fEnumDecimal [ i ] ) ; } } catch ( Exception idve ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . InvalidEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { enumeration . elementAt ( i ) } ) ) ; } } } } else { } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { if ( fDerivedByList == false ) { if ( this . fBaseValidator != null ) { this . fBaseValidator . validate ( content , state ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_PATTERN ) != 0 ) { if ( fRegex == null || fRegex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value'" + content + "' does not match regular expression facet " + fRegex . getPattern ( ) ) ; } BigDecimal d = null ; try { d = new BigDecimal ( stripPlusIfPresent ( content ) ) ; } catch ( Exception nfe ) { throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotDecimal , DatatypeMessageProvider . MSG_NONE , new Object [ ] { "'" + content + "'" } ) ) ; } if ( isScaleDefined == true ) { if ( d . scale ( ) > fScale ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . ScaleExceeded , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } if ( isPrecisionDefined == true ) { int precision = d . movePointRight ( d . scale ( ) ) . toString ( ) . length ( ) - ( ( d . signum ( ) < 0 ) ? 1 : 0 ) ; if ( precision > fPrecision ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . PrecisionExceeded , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } boundsCheck ( d ) ; if ( fEnumDecimal != null ) enumCheck ( d ) ; } else { } return null ; } public void boundsCheck ( BigDecimal d ) throws InvalidDatatypeValueException { boolean minOk = false ; boolean maxOk = false ; String upperBound = ( fMaxExclusive != null ) ? ( fMaxExclusive . toString ( ) ) : ( ( fMaxInclusive != null ) ? fMaxInclusive . toString ( ) : "" ) ; String lowerBound = ( fMinExclusive != null ) ? ( fMinExclusive . toString ( ) ) : ( ( fMinInclusive != null ) ? fMinInclusive . toString ( ) : "" ) ; String lowerBoundIndicator = "" ; String upperBoundIndicator = "" ; if ( isMaxInclusiveDefined ) { maxOk = ( d . compareTo ( fMaxInclusive ) <= 0 ) ; upperBound = fMaxInclusive . toString ( ) ; if ( upperBound != null ) { upperBoundIndicator = "<=" ; } else { upperBound = "" ; } } else if ( isMaxExclusiveDefined ) { maxOk = ( d . compareTo ( fMaxExclusive ) < 0 ) ; upperBound = fMaxExclusive . toString ( ) ; if ( upperBound != null ) { upperBoundIndicator = "<" ; } else { upperBound = "" ; } } else { maxOk = ( ! isMaxInclusiveDefined && ! isMaxExclusiveDefined ) ; } if ( isMinInclusiveDefined ) { minOk = ( d . compareTo ( fMinInclusive ) >= 0 ) ; lowerBound = fMinInclusive . toString ( ) ; if ( lowerBound != null ) { lowerBoundIndicator = "<=" ; } else { lowerBound = "" ; } } else if ( isMinExclusiveDefined ) { minOk = ( d . compareTo ( fMinExclusive ) > 0 ) ; lowerBound = fMinExclusive . toString ( ) ; if ( lowerBound != null ) { lowerBoundIndicator = "<" ; } else { lowerBound = "" ; } } else { minOk = ( ! isMinInclusiveDefined && ! isMinExclusiveDefined ) ; } if ( ! ( minOk && maxOk ) ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . OutOfBounds , DatatypeMessageProvider . MSG_NONE , new Object [ ] { d . toString ( ) , lowerBound , upperBound , lowerBoundIndicator , upperBoundIndicator } ) ) ; } private void enumCheck ( BigDecimal v ) throws InvalidDatatypeValueException { for ( int i = 0 ; i < fEnumDecimal . length ; i ++ ) { if ( v . equals ( fEnumDecimal [ i ] ) ) { return ; } } throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotAnEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { v } ) ) ; } public void setLocale ( Locale locale ) { fLocale = locale ; } public Hashtable getFacets ( ) { return fFacets ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } public int compare ( String content1 , String content2 ) { return 0 ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } static private String stripPlusIfPresent ( String value ) { String strippedPlus = value ; if ( value . length ( ) >= 2 && value . charAt ( 0 ) == '+' && value . charAt ( 1 ) != '-' ) { strippedPlus = value . substring ( 1 ) ; } return strippedPlus ; } private Hashtable checkForFacetConsistency ( Hashtable thisTypeFacets , Hashtable baseTypeFacets ) throws InvalidDatatypeFacetException { String thisTypeFacetValue ; String baseValue ; if ( baseTypeFacets != null ) { Enumeration setOfBaseKeys = baseTypeFacets . keys ( ) ; String keyInBase ; BigDecimal valueOfThisType = null ; BigDecimal valueOfBase = null ; while ( setOfBaseKeys . hasMoreElements ( ) ) { keyInBase = ( String ) setOfBaseKeys . nextElement ( ) ; baseValue = ( String ) baseTypeFacets . get ( keyInBase ) ; thisTypeFacetValue = ( String ) thisTypeFacets . get ( keyInBase ) ; if ( thisTypeFacetValue == null ) { String strThisType = null ; thisTypeFacets . put ( keyInBase , baseValue ) ; if ( keyInBase . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MAXINCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == - 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MAXINCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == - 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MININCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MININCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MININCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MININCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MINEXCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MINEXCLUSIVE ) ; } } } else { if ( keyInBase . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } } } } return thisTypeFacets ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLParamElementImpl extends HTMLElementImpl implements HTMLParamElement { public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } public void setType ( String type ) { setAttribute ( "type" , type ) ; } public String getValue ( ) { return getAttribute ( "value" ) ; } public void setValue ( String value ) { setAttribute ( "value" , value ) ; } public String getValueType ( ) { return capitalize ( getAttribute ( "valuetype" ) ) ; } public void setValueType ( String valueType ) { setAttribute ( "valuetype" , valueType ) ; } public HTMLParamElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package javax . xml . parsers ; public class FactoryConfigurationError extends Error { private Exception exception = null ; public FactoryConfigurationError ( ) { this ( null , null ) ; } public FactoryConfigurationError ( String msg ) { this ( null , msg ) ; } public FactoryConfigurationError ( Exception e ) { this ( e , null ) ; } public FactoryConfigurationError ( Exception e , String msg ) { super ( msg ) ; this . exception = e ; } public Exception getException ( ) { return ( this . exception ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLLabelElement extends HTMLElement { public HTMLFormElement getForm ( ) ; public String getAccessKey ( ) ; public void setAccessKey ( String accessKey ) ; public String getHtmlFor ( ) ; public void setHtmlFor ( String htmlFor ) ; } 	0
package org . w3c . dom ; public interface DocumentFragment extends Node { } 	1
package org . w3c . dom . html ; public interface HTMLInputElement extends HTMLElement { public String getDefaultValue ( ) ; public void setDefaultValue ( String defaultValue ) ; public boolean getDefaultChecked ( ) ; public void setDefaultChecked ( boolean defaultChecked ) ; public HTMLFormElement getForm ( ) ; public String getAccept ( ) ; public void setAccept ( String accept ) ; public String getAccessKey ( ) ; public void setAccessKey ( String accessKey ) ; public String getAlign ( ) ; public void setAlign ( String align ) ; public String getAlt ( ) ; public void setAlt ( String alt ) ; public boolean getChecked ( ) ; public void setChecked ( boolean checked ) ; public boolean getDisabled ( ) ; public void setDisabled ( boolean disabled ) ; public int getMaxLength ( ) ; public void setMaxLength ( int maxLength ) ; public String getName ( ) ; public void setName ( String name ) ; public boolean getReadOnly ( ) ; public void setReadOnly ( boolean readOnly ) ; public String getSize ( ) ; public void setSize ( String size ) ; public String getSrc ( ) ; public void setSrc ( String src ) ; public int getTabIndex ( ) ; public void setTabIndex ( int tabIndex ) ; public String getType ( ) ; public String getUseMap ( ) ; public void setUseMap ( String useMap ) ; public String getValue ( ) ; public void setValue ( String value ) ; public void blur ( ) ; public void focus ( ) ; public void select ( ) ; public void click ( ) ; } 	0
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface MutationEvent extends Event { public Node getRelatedNode ( ) ; public String getPrevValue ( ) ; public String getNewValue ( ) ; public String getAttrName ( ) ; public void initMutationEvent ( String typeArg , boolean canBubbleArg , boolean cancelableArg , Node relatedNodeArg , String prevValueArg , String newValueArg , String attrNameArg ) ; } 	1
package org . apache . xerces . utils ; public final class StringPool { private static final boolean DEBUG_ADDITIONS = false ; public static final int NULL_STRING = - 1 ; public static final int EMPTY_STRING = 0 ; public interface StringProducer { public String toString ( int offset , int length ) ; public void releaseString ( int offset , int length ) ; public boolean equalsString ( int offset , int length , char [ ] strChars , int strOffset , int strLength ) ; } ; private static final int INITIAL_CHUNK_SHIFT = 8 ; private static final int INITIAL_CHUNK_SIZE = ( 1 << INITIAL_CHUNK_SHIFT ) ; private static final int CHUNK_SHIFT = 13 ; private static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; private static final int CHUNK_MASK = CHUNK_SIZE - 1 ; private static final int INITIAL_CHUNK_COUNT = ( 1 << ( 16 - CHUNK_SHIFT ) ) ; private int fStringCount = 0 ; private int fStringFreeList = - 1 ; private String [ ] [ ] fString = new String [ INITIAL_CHUNK_COUNT ] [ ] ; private StringPool . StringProducer [ ] [ ] fStringProducer = new StringPool . StringProducer [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fOffset = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fLength = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fCharsOffset = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int fStringListCount = 0 ; private int fActiveStringList = - 1 ; private int [ ] [ ] fStringList = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private static final int INITIAL_BUCKET_SIZE = 4 ; private static final int HASHTABLE_SIZE = 128 ; private int [ ] [ ] fSymbolTable = new int [ HASHTABLE_SIZE ] [ ] ; private SymbolCache fSymbolCache = null ; public StringPool ( ) { fSymbolCache = new SymbolCache ( ) ; if ( addSymbol ( "" ) != EMPTY_STRING ) throw new RuntimeException ( "UTL002 cannot happen" ) ; } public void reset ( ) { int chunk = 0 ; int index = 0 ; for ( int i = 0 ; i < fStringCount ; i ++ ) { fString [ chunk ] [ index ] = null ; if ( fStringProducer [ chunk ] [ index ] != null ) fStringProducer [ chunk ] [ index ] . releaseString ( fOffset [ chunk ] [ index ] , fLength [ chunk ] [ index ] ) ; fStringProducer [ chunk ] [ index ] = null ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } for ( int i = 0 ; i < HASHTABLE_SIZE ; i ++ ) fSymbolTable [ i ] = null ; fStringCount = 0 ; fStringFreeList = - 1 ; fStringListCount = 0 ; fActiveStringList = - 1 ; fSymbolCache . reset ( ) ; fShuffleCount = 0 ; if ( addSymbol ( "" ) != EMPTY_STRING ) throw new RuntimeException ( "UTL002 cannot happen" ) ; } private boolean ensureCapacity ( int chunk , int index ) { try { return fOffset [ chunk ] [ index ] == 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { if ( index == 0 ) { String [ ] [ ] newString = new String [ chunk * 2 ] [ ] ; System . arraycopy ( fString , 0 , newString , 0 , chunk ) ; fString = newString ; StringPool . StringProducer [ ] [ ] newProducer = new StringPool . StringProducer [ chunk * 2 ] [ ] ; System . arraycopy ( fStringProducer , 0 , newProducer , 0 , chunk ) ; fStringProducer = newProducer ; int [ ] [ ] newInt = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fOffset , 0 , newInt , 0 , chunk ) ; fOffset = newInt ; newInt = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fLength , 0 , newInt , 0 , chunk ) ; fLength = newInt ; newInt = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fCharsOffset , 0 , newInt , 0 , chunk ) ; fCharsOffset = newInt ; } else { String [ ] newString = new String [ index * 2 ] ; System . arraycopy ( fString [ chunk ] , 0 , newString , 0 , index ) ; fString [ chunk ] = newString ; StringPool . StringProducer [ ] newProducer = new StringPool . StringProducer [ index * 2 ] ; System . arraycopy ( fStringProducer [ chunk ] , 0 , newProducer , 0 , index ) ; fStringProducer [ chunk ] = newProducer ; int [ ] newInt = new int [ index * 2 ] ; System . arraycopy ( fOffset [ chunk ] , 0 , newInt , 0 , index ) ; fOffset [ chunk ] = newInt ; newInt = new int [ index * 2 ] ; System . arraycopy ( fLength [ chunk ] , 0 , newInt , 0 , index ) ; fLength [ chunk ] = newInt ; newInt = new int [ index * 2 ] ; System . arraycopy ( fCharsOffset [ chunk ] , 0 , newInt , 0 , index ) ; fCharsOffset [ chunk ] = newInt ; return true ; } } catch ( NullPointerException ex ) { } fString [ chunk ] = new String [ INITIAL_CHUNK_SIZE ] ; fStringProducer [ chunk ] = new StringPool . StringProducer [ INITIAL_CHUNK_SIZE ] ; fOffset [ chunk ] = new int [ INITIAL_CHUNK_SIZE ] ; fLength [ chunk ] = new int [ INITIAL_CHUNK_SIZE ] ; fCharsOffset [ chunk ] = new int [ INITIAL_CHUNK_SIZE ] ; return true ; } public int addString ( String str ) { int chunk ; int index ; int stringIndex ; if ( fStringFreeList != - 1 ) { stringIndex = fStringFreeList ; chunk = stringIndex > > CHUNK_SHIFT ; index = stringIndex & CHUNK_MASK ; fStringFreeList = fOffset [ chunk ] [ index ] ; } else { stringIndex = fStringCount ++ ; chunk = stringIndex > > CHUNK_SHIFT ; index = stringIndex & CHUNK_MASK ; ensureCapacity ( chunk , index ) ; } fString [ chunk ] [ index ] = str ; fStringProducer [ chunk ] [ index ] = null ; fOffset [ chunk ] [ index ] = 0 ; fLength [ chunk ] [ index ] = str . length ( ) ; fCharsOffset [ chunk ] [ index ] = - 1 ; if ( DEBUG_ADDITIONS ) System . err . println ( "addString(" + str + ") " + stringIndex ) ; return stringIndex ; } public int addString ( StringPool . StringProducer stringProducer , int offset , int length ) { int chunk ; int index ; int stringIndex ; if ( fStringFreeList != - 1 ) { stringIndex = fStringFreeList ; chunk = stringIndex > > CHUNK_SHIFT ; index = stringIndex & CHUNK_MASK ; fStringFreeList = fOffset [ chunk ] [ index ] ; } else { stringIndex = fStringCount ++ ; chunk = stringIndex > > CHUNK_SHIFT ; index = stringIndex & CHUNK_MASK ; ensureCapacity ( chunk , index ) ; } fString [ chunk ] [ index ] = null ; fStringProducer [ chunk ] [ index ] = stringProducer ; fOffset [ chunk ] [ index ] = offset ; fLength [ chunk ] [ index ] = length ; fCharsOffset [ chunk ] [ index ] = - 1 ; if ( DEBUG_ADDITIONS ) System . err . println ( "addString(" + stringProducer . toString ( offset , length ) + ") " + stringIndex ) ; return stringIndex ; } public SymbolCache getSymbolCache ( ) { return fSymbolCache ; } private int fShuffleCount = 0 ; public void resetShuffleCount ( ) { fShuffleCount = 0 ; } public void updateCacheLine ( int symbolIndex , int totalMisses , int length ) { if ( ++ fShuffleCount > 200 ) { return ; } int chunk = symbolIndex > > CHUNK_SHIFT ; int index = symbolIndex & CHUNK_MASK ; int charsOffset = fCharsOffset [ chunk ] [ index ] ; fSymbolCache . updateCacheLine ( charsOffset , totalMisses , length ) ; } public int createNonMatchingSymbol ( int startOffset , int entry , int [ ] entries , int offset ) throws Exception { int chunk ; int index ; int stringIndex ; if ( fStringFreeList != - 1 ) { stringIndex = fStringFreeList ; chunk = stringIndex > > CHUNK_SHIFT ; index = stringIndex & CHUNK_MASK ; fStringFreeList = fOffset [ chunk ] [ index ] ; } else { stringIndex = fStringCount ++ ; chunk = stringIndex > > CHUNK_SHIFT ; index = stringIndex & CHUNK_MASK ; ensureCapacity ( chunk , index ) ; } String str = fSymbolCache . createSymbol ( stringIndex , startOffset , entry , entries , offset ) ; int slen = str . length ( ) ; fString [ chunk ] [ index ] = str ; fStringProducer [ chunk ] [ index ] = null ; fOffset [ chunk ] [ index ] = - 1 ; fLength [ chunk ] [ index ] = slen ; fCharsOffset [ chunk ] [ index ] = startOffset ; int hashcode = StringHasher . hashString ( str , slen ) ; int hc = hashcode % HASHTABLE_SIZE ; int [ ] bucket = fSymbolTable [ hc ] ; hashSymbol ( bucket , hashcode , chunk , index ) ; if ( DEBUG_ADDITIONS ) System . err . println ( "addSymbolNew(" + str + ") " + stringIndex ) ; return stringIndex ; } private void hashSymbol ( int [ ] bucket , int hashcode , int chunk , int index ) { if ( bucket == null ) { bucket = new int [ 1 + ( INITIAL_BUCKET_SIZE * 3 ) ] ; bucket [ 0 ] = 1 ; bucket [ 1 ] = hashcode ; bucket [ 2 ] = chunk ; bucket [ 3 ] = index ; int hc = hashcode % HASHTABLE_SIZE ; fSymbolTable [ hc ] = bucket ; } else { int count = bucket [ 0 ] ; int offset = 1 + ( count * 3 ) ; if ( offset == bucket . length ) { int newSize = count + INITIAL_BUCKET_SIZE ; int [ ] newBucket = new int [ 1 + ( newSize * 3 ) ] ; System . arraycopy ( bucket , 0 , newBucket , 0 , offset ) ; bucket = newBucket ; int hc = hashcode % HASHTABLE_SIZE ; fSymbolTable [ hc ] = bucket ; } bucket [ offset ++ ] = hashcode ; bucket [ offset ++ ] = chunk ; bucket [ offset ++ ] = index ; bucket [ 0 ] = ++ count ; } } public int addSymbol ( String str ) { int slen = str . length ( ) ; int hashcode = StringHasher . hashString ( str , slen ) ; int hc = hashcode % HASHTABLE_SIZE ; int [ ] bucket = fSymbolTable [ hc ] ; if ( bucket != null ) { int j = 1 ; for ( int i = 0 ; i < bucket [ 0 ] ; i ++ ) { if ( bucket [ j ] == hashcode ) { int chunk = bucket [ j + 1 ] ; int index = bucket [ j + 2 ] ; if ( slen == fLength [ chunk ] [ index ] ) { int symoff = fCharsOffset [ chunk ] [ index ] ; boolean match = true ; char [ ] symbolChars = fSymbolCache . getSymbolChars ( ) ; for ( int k = 0 ; k < slen ; k ++ ) { if ( symbolChars [ symoff ++ ] != str . charAt ( k ) ) { match = false ; break ; } } if ( match ) { return ( chunk << CHUNK_SHIFT ) + index ; } } } j += 3 ; } } int chunk ; int index ; int stringIndex ; if ( fStringFreeList != - 1 ) { stringIndex = fStringFreeList ; chunk = stringIndex > > CHUNK_SHIFT ; index = stringIndex & CHUNK_MASK ; fStringFreeList = fOffset [ chunk ] [ index ] ; } else { stringIndex = fStringCount ++ ; chunk = stringIndex > > CHUNK_SHIFT ; index = stringIndex & CHUNK_MASK ; ensureCapacity ( chunk , index ) ; } fString [ chunk ] [ index ] = str ; fStringProducer [ chunk ] [ index ] = null ; fOffset [ chunk ] [ index ] = - 1 ; fLength [ chunk ] [ index ] = slen ; fCharsOffset [ chunk ] [ index ] = fSymbolCache . addSymbolToCache ( str , slen , stringIndex ) ; hashSymbol ( bucket , hashcode , chunk , index ) ; if ( DEBUG_ADDITIONS ) System . err . println ( "addSymbolNew(" + str + ") " + stringIndex ) ; return stringIndex ; } public int addSymbol ( StringPool . StringProducer stringProducer , int offset , int length , int hashcode ) { int hc = hashcode % HASHTABLE_SIZE ; int [ ] bucket = fSymbolTable [ hc ] ; if ( bucket != null ) { int j = 1 ; for ( int i = 0 ; i < bucket [ 0 ] ; i ++ ) { if ( bucket [ j ] == hashcode ) { int chunk = bucket [ j + 1 ] ; int index = bucket [ j + 2 ] ; char [ ] symbolChars = fSymbolCache . getSymbolChars ( ) ; if ( stringProducer . equalsString ( offset , length , symbolChars , fCharsOffset [ chunk ] [ index ] , fLength [ chunk ] [ index ] ) ) { stringProducer . releaseString ( offset , length ) ; return ( chunk << CHUNK_SHIFT ) + index ; } } j += 3 ; } } int chunk ; int index ; int stringIndex ; if ( fStringFreeList != - 1 ) { stringIndex = fStringFreeList ; chunk = stringIndex > > CHUNK_SHIFT ; index = stringIndex & CHUNK_MASK ; fStringFreeList = fOffset [ chunk ] [ index ] ; } else { stringIndex = fStringCount ++ ; chunk = stringIndex > > CHUNK_SHIFT ; index = stringIndex & CHUNK_MASK ; ensureCapacity ( chunk , index ) ; } String str = stringProducer . toString ( offset , length ) ; stringProducer . releaseString ( offset , length ) ; int slen = str . length ( ) ; fString [ chunk ] [ index ] = str ; fStringProducer [ chunk ] [ index ] = null ; fOffset [ chunk ] [ index ] = - 1 ; fLength [ chunk ] [ index ] = slen ; fCharsOffset [ chunk ] [ index ] = fSymbolCache . addSymbolToCache ( str , slen , stringIndex ) ; hashSymbol ( bucket , hashcode , chunk , index ) ; if ( DEBUG_ADDITIONS ) System . err . println ( "addSymbol(" + str + ") " + stringIndex ) ; return stringIndex ; } public int lookupSymbol ( StringPool . StringProducer stringProducer , int offset , int length , int hashcode ) { int hc = hashcode % HASHTABLE_SIZE ; int [ ] bucket = fSymbolTable [ hc ] ; if ( bucket != null ) { int j = 1 ; for ( int i = 0 ; i < bucket [ 0 ] ; i ++ ) { if ( bucket [ j ] == hashcode ) { int chunk = bucket [ j + 1 ] ; int index = bucket [ j + 2 ] ; char [ ] symbolChars = fSymbolCache . getSymbolChars ( ) ; if ( stringProducer . equalsString ( offset , length , symbolChars , fCharsOffset [ chunk ] [ index ] , fLength [ chunk ] [ index ] ) ) { return ( chunk << CHUNK_SHIFT ) + index ; } } j += 3 ; } } return - 1 ; } public int addNewSymbol ( String str , int hashcode ) { int hc = hashcode % HASHTABLE_SIZE ; int [ ] bucket = fSymbolTable [ hc ] ; int chunk ; int index ; int stringIndex ; if ( fStringFreeList != - 1 ) { stringIndex = fStringFreeList ; chunk = stringIndex > > CHUNK_SHIFT ; index = stringIndex & CHUNK_MASK ; fStringFreeList = fOffset [ chunk ] [ index ] ; } else { stringIndex = fStringCount ++ ; chunk = stringIndex > > CHUNK_SHIFT ; index = stringIndex & CHUNK_MASK ; ensureCapacity ( chunk , index ) ; } int slen = str . length ( ) ; fString [ chunk ] [ index ] = str ; fStringProducer [ chunk ] [ index ] = null ; fOffset [ chunk ] [ index ] = - 1 ; fLength [ chunk ] [ index ] = slen ; fCharsOffset [ chunk ] [ index ] = fSymbolCache . addSymbolToCache ( str , slen , stringIndex ) ; hashSymbol ( bucket , hashcode , chunk , index ) ; if ( DEBUG_ADDITIONS ) System . err . println ( "addSymbolNew(" + str + ") " + stringIndex ) ; return stringIndex ; } public int addSymbol ( int stringIndex ) { if ( stringIndex < 0 || stringIndex >= fStringCount ) return - 1 ; int chunk = stringIndex > > CHUNK_SHIFT ; int index = stringIndex & CHUNK_MASK ; if ( fOffset [ chunk ] [ index ] == - 1 ) return stringIndex ; String s = fString [ chunk ] [ index ] ; if ( s == null ) { s = fStringProducer [ chunk ] [ index ] . toString ( fOffset [ chunk ] [ index ] , fLength [ chunk ] [ index ] ) ; fStringProducer [ chunk ] [ index ] . releaseString ( fOffset [ chunk ] [ index ] , fLength [ chunk ] [ index ] ) ; fString [ chunk ] [ index ] = s ; fStringProducer [ chunk ] [ index ] = null ; } return addSymbol ( s ) ; } public class CharArrayRange { public char [ ] chars ; public int offset ; public int length ; } public CharArrayRange createCharArrayRange ( ) { return new CharArrayRange ( ) ; } public void getCharArrayRange ( int symbolIndex , CharArrayRange r ) { if ( symbolIndex < 0 || symbolIndex >= fStringCount ) { r . chars = null ; r . offset = - 1 ; r . length = - 1 ; return ; } int chunk = symbolIndex > > CHUNK_SHIFT ; int index = symbolIndex & CHUNK_MASK ; r . chars = fSymbolCache . getSymbolChars ( ) ; r . offset = fCharsOffset [ chunk ] [ index ] ; r . length = fLength [ chunk ] [ index ] ; } public boolean equalNames ( int stringIndex1 , int stringIndex2 ) { if ( stringIndex1 == stringIndex2 ) return true ; return false ; } private boolean ensureListCapacity ( int chunk , int index ) { try { return fStringList [ chunk ] [ index ] == 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { if ( index == 0 ) { int [ ] [ ] newInt = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fStringList , 0 , newInt , 0 , chunk ) ; fStringList = newInt ; } else { int [ ] newInt = new int [ index * 2 ] ; System . arraycopy ( fStringList [ chunk ] , 0 , newInt , 0 , index ) ; fStringList [ chunk ] = newInt ; return true ; } } catch ( NullPointerException ex ) { } fStringList [ chunk ] = new int [ INITIAL_CHUNK_SIZE ] ; return true ; } public int startStringList ( ) { fActiveStringList = fStringListCount ; return fStringListCount ; } public boolean addStringToList ( int stringListIndex , int stringIndex ) { if ( stringIndex == - 1 || stringListIndex != fActiveStringList ) return false ; int chunk = fStringListCount > > CHUNK_SHIFT ; int index = fStringListCount & CHUNK_MASK ; ensureListCapacity ( chunk , index ) ; fStringList [ chunk ] [ index ] = stringIndex ; fStringListCount ++ ; return true ; } public void finishStringList ( int stringListIndex ) { if ( stringListIndex != fActiveStringList ) return ; int chunk = fStringListCount > > CHUNK_SHIFT ; int index = fStringListCount & CHUNK_MASK ; ensureListCapacity ( chunk , index ) ; fStringList [ chunk ] [ index ] = - 1 ; fActiveStringList = - 1 ; fStringListCount ++ ; } public int stringListLength ( int stringListIndex ) { int chunk = stringListIndex > > CHUNK_SHIFT ; int index = stringListIndex & CHUNK_MASK ; int count = 0 ; while ( true ) { if ( fStringList [ chunk ] [ index ] == - 1 ) return count ; count ++ ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } } public boolean stringInList ( int stringListIndex , int stringIndex ) { int chunk = stringListIndex > > CHUNK_SHIFT ; int index = stringListIndex & CHUNK_MASK ; while ( true ) { if ( fStringList [ chunk ] [ index ] == stringIndex ) return true ; if ( fStringList [ chunk ] [ index ] == - 1 ) return false ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } } public String stringListAsString ( int stringListIndex ) { int chunk = stringListIndex > > CHUNK_SHIFT ; int index = stringListIndex & CHUNK_MASK ; StringBuffer sb = new StringBuffer ( ) ; char sep = '(' ; while ( fStringList [ chunk ] [ index ] != - 1 ) { sb . append ( sep ) ; sep = '|' ; sb . append ( toString ( fStringList [ chunk ] [ index ] ) ) ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } if ( sep == '|' ) sb . append ( ')' ) ; return sb . toString ( ) ; } public int [ ] stringListAsIntArray ( int stringListIndex ) { int chunk = stringListIndex > > CHUNK_SHIFT ; int index = stringListIndex & CHUNK_MASK ; int len = stringListLength ( stringListIndex ) ; int [ ] ia = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { ia [ i ] = fStringList [ chunk ] [ index ] ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } return ia ; } private void releaseStringInternal ( int chunk , int index ) { fString [ chunk ] [ index ] = null ; fStringProducer [ chunk ] [ index ] = null ; fLength [ chunk ] [ index ] = 0 ; fOffset [ chunk ] [ index ] = fStringFreeList ; int offset = ( chunk << CHUNK_SHIFT ) + index ; fStringFreeList = offset ; } public void releaseString ( int stringIndex ) { if ( stringIndex < 0 || stringIndex >= fStringCount ) return ; int chunk = stringIndex > > CHUNK_SHIFT ; int index = stringIndex & CHUNK_MASK ; if ( fOffset [ chunk ] [ index ] != - 1 ) { if ( fStringProducer [ chunk ] [ index ] != null ) fStringProducer [ chunk ] [ index ] . releaseString ( fOffset [ chunk ] [ index ] , fLength [ chunk ] [ index ] ) ; releaseStringInternal ( chunk , index ) ; } } public String toString ( int stringIndex ) { if ( stringIndex >= 0 && stringIndex < fString [ 0 ] . length ) { String result = fString [ 0 ] [ stringIndex ] ; if ( result != null ) { return result ; } } if ( stringIndex < 0 || stringIndex >= fStringCount ) return null ; int chunk = stringIndex > > CHUNK_SHIFT ; int index = stringIndex & CHUNK_MASK ; String s = fString [ chunk ] [ index ] ; if ( s != null ) return s ; s = fStringProducer [ chunk ] [ index ] . toString ( fOffset [ chunk ] [ index ] , fLength [ chunk ] [ index ] ) ; fStringProducer [ chunk ] [ index ] . releaseString ( fOffset [ chunk ] [ index ] , fLength [ chunk ] [ index ] ) ; fString [ chunk ] [ index ] = s ; fStringProducer [ chunk ] [ index ] = null ; return s ; } public String orphanString ( int stringIndex ) { if ( stringIndex < 0 || stringIndex >= fStringCount ) return null ; int chunk = stringIndex > > CHUNK_SHIFT ; int index = stringIndex & CHUNK_MASK ; String s = fString [ chunk ] [ index ] ; if ( s == null ) { s = fStringProducer [ chunk ] [ index ] . toString ( fOffset [ chunk ] [ index ] , fLength [ chunk ] [ index ] ) ; fStringProducer [ chunk ] [ index ] . releaseString ( fOffset [ chunk ] [ index ] , fLength [ chunk ] [ index ] ) ; releaseStringInternal ( chunk , index ) ; } else if ( fOffset [ chunk ] [ index ] != - 1 ) { releaseStringInternal ( chunk , index ) ; } return s ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . w3c . dom . traversal . * ; import org . apache . xerces . dom . DocumentImpl ; import org . apache . xerces . dom . DOMExceptionImpl ; public class NodeIteratorImpl implements NodeIterator { private DocumentImpl fDocument ; private Node fRoot ; private int fWhatToShow = NodeFilter . SHOW_ALL ; private NodeFilter fNodeFilter ; private boolean fDetach = false ; private Node fCurrentNode ; private boolean fForward = true ; private boolean fEntityReferenceExpansion ; public NodeIteratorImpl ( DocumentImpl document , Node root , int whatToShow , NodeFilter nodeFilter , boolean entityReferenceExpansion ) { fDocument = document ; fRoot = root ; fCurrentNode = null ; fWhatToShow = whatToShow ; fNodeFilter = nodeFilter ; fEntityReferenceExpansion = entityReferenceExpansion ; } public Node getRoot ( ) { return fRoot ; } public int getWhatToShow ( ) { return fWhatToShow ; } public NodeFilter getFilter ( ) { return fNodeFilter ; } public boolean getExpandEntityReferences ( ) { return fEntityReferenceExpansion ; } public Node nextNode ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMExceptionImpl . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( fRoot == null ) return null ; Node nextNode = fCurrentNode ; boolean accepted = false ; accepted_loop : while ( ! accepted ) { if ( ! fForward && nextNode != null ) { nextNode = fCurrentNode ; } else { if ( ! fEntityReferenceExpansion && nextNode != null && nextNode . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) { nextNode = nextNode ( nextNode , false ) ; } else { nextNode = nextNode ( nextNode , true ) ; } } fForward = true ; if ( nextNode == null ) return null ; accepted = acceptNode ( nextNode ) ; if ( accepted ) { fCurrentNode = nextNode ; return fCurrentNode ; } else continue accepted_loop ; } return null ; } public Node previousNode ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMExceptionImpl . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( fRoot == null || fCurrentNode == null ) return null ; Node previousNode = fCurrentNode ; boolean accepted = false ; accepted_loop : while ( ! accepted ) { if ( fForward && previousNode != null ) { previousNode = fCurrentNode ; } else { previousNode = previousNode ( previousNode ) ; } fForward = false ; if ( previousNode == null ) return null ; accepted = acceptNode ( previousNode ) ; if ( accepted ) { fCurrentNode = previousNode ; return fCurrentNode ; } else continue accepted_loop ; } return null ; } boolean acceptNode ( Node node ) { if ( fNodeFilter == null ) { return ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ; } else { return ( ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ) && fNodeFilter . acceptNode ( node ) == NodeFilter . FILTER_ACCEPT ; } } Node matchNodeOrParent ( Node node ) { for ( Node n = node ; n != fRoot ; n = n . getParentNode ( ) ) { if ( node == n ) return n ; } return null ; } Node nextNode ( Node node , boolean visitChildren ) { if ( node == null ) return fRoot ; Node result ; if ( visitChildren ) { if ( node . hasChildNodes ( ) ) { result = node . getFirstChild ( ) ; return result ; } } result = node . getNextSibling ( ) ; if ( result != null ) return result ; Node parent = node . getParentNode ( ) ; while ( parent != null && parent != fRoot ) { result = parent . getNextSibling ( ) ; if ( result != null ) { return result ; } else { parent = parent . getParentNode ( ) ; } } return null ; } Node previousNode ( Node node ) { Node result ; if ( node == fRoot ) return null ; result = node . getPreviousSibling ( ) ; if ( result == null ) { result = node . getParentNode ( ) ; return result ; } if ( result . hasChildNodes ( ) && ! ( ! fEntityReferenceExpansion && result != null && result . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) ) { while ( result . hasChildNodes ( ) ) { result = result . getLastChild ( ) ; } } return result ; } public void removeNode ( Node node ) { if ( node == null ) return ; Node deleted = matchNodeOrParent ( node ) ; if ( deleted == null ) return ; if ( fForward ) { fCurrentNode = previousNode ( deleted ) ; } else { Node next = nextNode ( deleted , false ) ; if ( next != null ) { fCurrentNode = next ; } else { fCurrentNode = previousNode ( deleted ) ; fForward = true ; } } } public void detach ( ) { fDetach = true ; fDocument . removeNodeIterator ( this ) ; } } 	1
package org . apache . xerces . readers ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public abstract class XMLCatalogHandler implements EntityResolver { public abstract void loadCatalog ( InputSource source ) throws Exception ; private Hashtable publicMap = new Hashtable ( ) ; private Hashtable systemMap = new Hashtable ( ) ; public void addPublicMapping ( String publicId , String systemId ) { publicMap . put ( publicId , systemId ) ; } public void removePublicMapping ( System publicId ) { publicMap . remove ( publicId ) ; } public Enumeration getPublicMappingKeys ( ) { return publicMap . keys ( ) ; } public String getPublicMapping ( String publicId ) { return ( String ) publicMap . get ( publicId ) ; } public void addSystemMapping ( String systemId1 , String systemId2 ) { systemMap . put ( systemId1 , systemId2 ) ; } public void removeSystemMapping ( String systemId ) { systemMap . remove ( systemId ) ; } public Enumeration getSystemMappingKeys ( ) { return systemMap . keys ( ) ; } public String getSystemMapping ( String systemId ) { return ( String ) systemMap . get ( systemId ) ; } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( publicId != null ) { String value = getPublicMapping ( publicId ) ; if ( value != null ) { return new InputSource ( value ) ; } } if ( systemId != null ) { String value = getSystemMapping ( systemId ) ; if ( value == null ) { value = systemId ; } return new InputSource ( value ) ; } return null ; } } 	0
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . CharDataChunk ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringHasher ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . ImplementationMessages ; import org . xml . sax . SAXParseException ; import java . util . Vector ; abstract class AbstractCharReader extends XMLEntityReader { protected AbstractCharReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , StringPool stringPool ) { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fStringPool = stringPool ; fCurrentChunk = CharDataChunk . createChunk ( fStringPool , null ) ; } protected CharDataChunk fCurrentChunk = null ; protected int fCurrentIndex = 0 ; protected char [ ] fMostRecentData = null ; protected int fMostRecentChar = 0 ; protected int fLength = 0 ; protected abstract int fillCurrentChunk ( ) throws Exception ; protected void deferException ( int errorCode , Object [ ] args , int offset ) { if ( fDeferredErrors == null ) fDeferredErrors = new Vector ( ) ; DeferredError de = new DeferredError ( errorCode , args , offset ) ; fDeferredErrors . addElement ( de ) ; } protected XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; return nextReader ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } public boolean lookingAtChar ( char chr , boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch != chr ) { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( chr , skipPastChar ) ; } } return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ; } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0xD800 ) { if ( ch >= 0x20 || ch == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } if ( ch == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } return true ; } if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } if ( ch > 0xFFFD ) { return false ; } if ( ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; boolean valid = ( ch >= 0xDC00 && ch < 0xE000 ) ; if ( ! valid || ! skipPastChar ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return valid ; } } else if ( ch < 0xE000 ) { return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ; return true ; } public void skipToChar ( char chr ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == chr ) return ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( chr ) ; return ; } fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch >= 0xD800 && ch < 0xDC00 ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) continue ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } ch = loadNextChar ( ) ; } } public void skipPastName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return ; } while ( true ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int length = s . length ; char [ ] data = fMostRecentData ; int index = fCurrentIndex ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { for ( int i = 0 ; i < length ; i ++ ) { if ( data [ index ++ ] != s [ i ] ) return false ; } fCharacterCounter += length ; fCurrentOffset += length ; fCurrentIndex = index ; if ( index == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = data [ index ] & 0xFFFF ; return true ; } CharDataChunk dataChunk = fCurrentChunk ; int offset = fCurrentOffset ; int savedIndex = index ; int i = 0 ; while ( index < CharDataChunk . CHUNK_SIZE ) { if ( data [ index ++ ] != s [ i ++ ] ) return false ; } slowLoadNextChar ( ) ; data = fMostRecentData ; index = 0 ; while ( i < length ) { if ( data [ index ++ ] != s [ i ++ ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } fCharacterCounter += length ; fCurrentOffset += length ; fCurrentIndex = index ; if ( index == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = data [ index ] & 0xFFFF ; return true ; } public int scanInvalidChar ( ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } if ( fDeferredErrors != null ) { for ( int i = 0 ; i < fDeferredErrors . size ( ) ; i ++ ) { DeferredError de = ( DeferredError ) fDeferredErrors . elementAt ( i ) ; if ( de . offset == fCurrentIndex ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , de . errorCode , 0 , de . args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; fDeferredErrors . removeElementAt ( i ) ; fCharacterCounter ++ ; loadNextChar ( ) ; return - 1 ; } } } fCharacterCounter ++ ; loadNextChar ( ) ; } else { fCharacterCounter ++ ; if ( ch >= 0xD800 && ch < 0xDC00 ) { int ch2 = loadNextChar ( ) ; if ( ch2 >= 0xDC00 && ch2 < 0xE000 ) { ch = ( ( ch - 0xD800 ) << 10 ) + ( ch2 - 0xDC00 ) + 0x10000 ; loadNextChar ( ) ; } } else loadNextChar ( ) ; } return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextChar ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentChar ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextChar ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextChar ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( lookingAtChar ( qchar , false ) ) { break ; } if ( lookingAtChar ( ' ' , true ) ) { continue ; } if ( lookingAtSpace ( false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '<' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } int result = asSymbol ? addSymbol ( offset , fCurrentOffset - offset ) : addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return result ; } public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } if ( qchar != - 1 && lookingAtChar ( ( char ) qchar , false ) ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; break ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; } if ( lookingAtChar ( '%' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } int result = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( ( char ) qchar , true ) ; return result ; } public int scanName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return - 1 ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return - 1 ; } int offset = fCurrentOffset ; int index = fCurrentIndex ; char [ ] data = fMostRecentData ; if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; int hashcode = 0 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = data [ index ] & 0xFFFF ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; } fCurrentIndex = index ; fMostRecentChar = ch ; hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; int nameIndex = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; return nameIndex ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int ch = fMostRecentChar ; for ( int i = 0 ; i < len ; i ++ ) { if ( ch != expected [ offset ++ ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } fCharacterCounter ++ ; fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) ch = slowLoadNextChar ( ) ; else ch = ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; int index = fCurrentIndex ; char [ ] data = fMostRecentData ; if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; int hashcode = 0 ; int prefixend = - 1 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = data [ index ] & 0xFFFF ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; if ( index + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; ch = slowLoadNextChar ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; } else ch = data [ index + 1 ] & 0xFFFF ; boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; break ; } } } else { if ( fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; } fCurrentIndex = index ; fMostRecentChar = ch ; hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; qname . rawname = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentChar ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeMarkup ( ch ) ; } break ; case 2 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } break ; case 3 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch != ']' ) break ; if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) break ; fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , true ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } break ; } } else if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , false ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextChar ( ) ; break ; } callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentChar ; } } } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool fStringPool = null ; private boolean fCalledCharPropInit = false ; private boolean fCallClearPreviousChunk = true ; private Vector fDeferredErrors = null ; private class DeferredError { int errorCode ; Object [ ] args ; int offset ; DeferredError ( int ec , Object [ ] a , int o ) { errorCode = ec ; args = a ; offset = o ; } } private int recognizeMarkup ( int ch ) throws Exception { switch ( ch ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( ch == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } private boolean skipMultiByteCharData ( int ch ) throws Exception { if ( ch < 0xD800 ) { loadNextChar ( ) ; return true ; } if ( ch > 0xFFFD ) return false ; if ( ch >= 0xDC00 && ch < 0xE000 ) return false ; if ( ch >= 0xD800 && ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } loadNextChar ( ) ; return true ; } private int skipAsciiCharData ( ) throws Exception { int index = fCurrentIndex ; int offset = fCurrentOffset - index ; while ( true ) { char [ ] data = fMostRecentData ; while ( index < CharDataChunk . CHUNK_SIZE ) { int ch = data [ index ] & 0xFFFF ; if ( ch >= 0x80 ) { fCurrentOffset = offset + index ; fCurrentIndex = index ; fMostRecentChar = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { fCurrentOffset = offset + index ; fCurrentIndex = index ; fMostRecentChar = ch ; return ch ; } index ++ ; } offset += index ; slowLoadNextChar ( ) ; index = 0 ; } } private void callCharDataHandler ( int offset , int endOffset , boolean isWhitespace ) throws Exception { int length = endOffset - offset ; if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , length ) ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( stringIndex ) ; else fCharDataHandler . processCharacters ( stringIndex ) ; return ; } CharDataChunk dataChunk = fCurrentChunk . chunkFor ( offset ) ; int index = offset & CharDataChunk . CHUNK_MASK ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { if ( length != 0 ) { if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , length ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , length ) ; } return ; } int count = length ; int nbytes = CharDataChunk . CHUNK_SIZE - index ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , nbytes ) ; count -= nbytes ; do { dataChunk = dataChunk . nextChunk ( ) ; if ( dataChunk == null ) { throw new RuntimeException ( new ImplementationMessages ( ) . createMessage ( null , ImplementationMessages . INT_DCN , 0 , null ) ) ; } nbytes = count <= CharDataChunk . CHUNK_SIZE ? count : CharDataChunk . CHUNK_SIZE ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; count -= nbytes ; } while ( count > 0 ) ; } private int slowLoadNextChar ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toCharArray ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } else { fCurrentChunk = CharDataChunk . createChunk ( fStringPool , fCurrentChunk ) ; return fillCurrentChunk ( ) ; } } private int loadNextChar ( ) throws Exception { fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) return slowLoadNextChar ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } } 	1
package org . apache . xerces . msg ; import java . util . ListResourceBundle ; public class SchemaMessages extends ListResourceBundle { public static final Object CONTENTS [ ] [ ] = { { "BadMajorCode" , "The majorCode parameter to createMessage was out of bounds." } , { "FormatFailed" , "An internal error occurred while formatting the following message:\n  " } , { "NoValidatorFor" , "No validator for datatype {0}" } , { "IncorrectDatatype" , "Incorrect datatype: {0}" } , { "NotADatatype" , "{0} is not a datatype." } , { "TextOnlyContentWithType" , "The content attribute must be 'textOnly' if you specify a type attribute." } , { "FeatureUnsupported" , "{0} is unsupported" } , { "NestedOnlyInElemOnly" , "Nested Element decls only allowed in elementOnly content" } , { "EltRefOnlyInMixedElemOnly" , "Element references only allowed in mixed or elementOnly content" } , { "OnlyInEltContent" , "{0} only allowed in elementOnly content." } , { "OrderIsAll" , "{0} not allowed if the order is all." } , { "DatatypeWithType" , "Datatype qualifiers can only be used if you specify a type attribute." } , { "DatatypeQualUnsupported" , "The datatype qualifier {0} is not supported." } , { "GroupContentRestricted" , "Error: {0} content must be one of element, group, modelGroupRef.  Saw {1}" } , { "UnknownBaseDatatype" , "Unknown base type {0} for type {1}." } , { "OneOfTypeRefArchRef" , "Can only have one of type and ref attributes." } , { "NoContentForRef" , "Cannot have child content for an element declaration that has a ref attribute" } , { "IncorrectDefaultType" , "Incorrect type for {0}'s default value: {1}" } , { "IllegalAttContent" , "Illegal content {0} in attribute group" } , { "ValueNotInteger" , "Value of {0} is not an integer." } , { "DatatypeError" , "Datatype error: {0}." } , { "TypeAlreadySet" , "The type of the element has already been declared." } , { "GenericError" , "Schema error: {0}." } , { "UnexpectedError" , "UnexpectedError" } , } ; public Object [ ] [ ] getContents ( ) { return CONTENTS ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . range . * ; public class RangeExceptionImpl extends RangeException { public RangeExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ChildAndParentNode extends ChildNode { static final long serialVersionUID = 0 ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ChildAndParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ChildAndParentNode ( ) { } public Node cloneNode ( boolean deep ) { ChildAndParentNode newnode = ( ChildAndParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . ImplementationMessages ; public class CMUniOp extends CMNode { public CMUniOp ( int type , CMNode childNode ) throws CMException { super ( type ) ; if ( ( type ( ) != XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) && ( type ( ) != XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) && ( type ( ) != XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) ) { throw new CMException ( ImplementationMessages . VAL_UST ) ; } fChild = childNode ; } final CMNode getChild ( ) { return fChild ; } boolean isNullable ( ) throws CMException { if ( ( type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) || ( type ( ) == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) ) { throw new CMException ( ImplementationMessages . VAL_UST ) ; } return true ; } protected void calcFirstPos ( CMStateSet toSet ) throws CMException { toSet . setTo ( fChild . firstPos ( ) ) ; } protected void calcLastPos ( CMStateSet toSet ) throws CMException { toSet . setTo ( fChild . lastPos ( ) ) ; } private CMNode fChild ; } ; 	0
package org . w3c . dom . events ; import org . w3c . dom . DOMException ; public interface DocumentEvent { public Event createEvent ( String eventType ) throws DOMException ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLTableElementImpl extends HTMLElementImpl implements HTMLTableElement { public synchronized HTMLTableCaptionElement getCaption ( ) { Node child ; child = getFirstChild ( ) ; while ( child != null ) { if ( child instanceof HTMLTableCaptionElement && child . getNodeName ( ) . equals ( "CAPTION" ) ) return ( HTMLTableCaptionElement ) child ; child = child . getNextSibling ( ) ; } return null ; } public synchronized void setCaption ( HTMLTableCaptionElement caption ) { if ( caption != null && ! caption . getTagName ( ) . equals ( "CAPTION" ) ) throw new IllegalArgumentException ( "HTM016 Argument 'caption' is not an element of type <CAPTION>." ) ; deleteCaption ( ) ; if ( caption != null ) appendChild ( caption ) ; } public synchronized HTMLElement createCaption ( ) { HTMLElement section ; section = getCaption ( ) ; if ( section != null ) return section ; section = new HTMLTableCaptionElementImpl ( ( HTMLDocumentImpl ) getOwnerDocument ( ) , "CAPTION" ) ; appendChild ( section ) ; return section ; } public synchronized void deleteCaption ( ) { Node old ; old = getCaption ( ) ; if ( old != null ) removeChild ( old ) ; } public synchronized HTMLTableSectionElement getTHead ( ) { Node child ; child = getFirstChild ( ) ; while ( child != null ) { if ( child instanceof HTMLTableSectionElement && child . getNodeName ( ) . equals ( "THEAD" ) ) return ( HTMLTableSectionElement ) child ; child = child . getNextSibling ( ) ; } return null ; } public synchronized void setTHead ( HTMLTableSectionElement tHead ) { if ( tHead != null && ! tHead . getTagName ( ) . equals ( "THEAD" ) ) throw new IllegalArgumentException ( "HTM017 Argument 'tHead' is not an element of type <THEAD>." ) ; deleteTHead ( ) ; if ( tHead != null ) appendChild ( tHead ) ; } public synchronized HTMLElement createTHead ( ) { HTMLElement section ; section = getTHead ( ) ; if ( section != null ) return section ; section = new HTMLTableSectionElementImpl ( ( HTMLDocumentImpl ) getOwnerDocument ( ) , "THEAD" ) ; appendChild ( section ) ; return section ; } public synchronized void deleteTHead ( ) { Node old ; old = getTHead ( ) ; if ( old != null ) removeChild ( old ) ; } public synchronized HTMLTableSectionElement getTFoot ( ) { Node child ; child = getFirstChild ( ) ; while ( child != null ) { if ( child instanceof HTMLTableSectionElement && child . getNodeName ( ) . equals ( "TFOOT" ) ) return ( HTMLTableSectionElement ) child ; child = child . getNextSibling ( ) ; } return null ; } public synchronized void setTFoot ( HTMLTableSectionElement tFoot ) { if ( tFoot != null && ! tFoot . getTagName ( ) . equals ( "TFOOT" ) ) throw new IllegalArgumentException ( "HTM018 Argument 'tFoot' is not an element of type <TFOOT>." ) ; deleteTFoot ( ) ; if ( tFoot != null ) appendChild ( tFoot ) ; } public synchronized HTMLElement createTFoot ( ) { HTMLElement section ; section = getTFoot ( ) ; if ( section != null ) return section ; section = new HTMLTableSectionElementImpl ( ( HTMLDocumentImpl ) getOwnerDocument ( ) , "TFOOT" ) ; appendChild ( section ) ; return section ; } public synchronized void deleteTFoot ( ) { Node old ; old = getTFoot ( ) ; if ( old != null ) removeChild ( old ) ; } public HTMLCollection getRows ( ) { if ( _rows == null ) _rows = new HTMLCollectionImpl ( this , HTMLCollectionImpl . ROW ) ; return _rows ; } public HTMLCollection getTBodies ( ) { if ( _bodies == null ) _bodies = new HTMLCollectionImpl ( this , HTMLCollectionImpl . TBODY ) ; return _bodies ; } public String getAlign ( ) { return capitalize ( getAttribute ( "align" ) ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public String getBgColor ( ) { return getAttribute ( "bgcolor" ) ; } public void setBgColor ( String bgColor ) { setAttribute ( "bgcolor" , bgColor ) ; } public String getBorder ( ) { return getAttribute ( "border" ) ; } public void setBorder ( String border ) { setAttribute ( "border" , border ) ; } public String getCellPadding ( ) { return getAttribute ( "cellpadding" ) ; } public void setCellPadding ( String cellPadding ) { setAttribute ( "cellpadding" , cellPadding ) ; } public String getCellSpacing ( ) { return getAttribute ( "cellspacing" ) ; } public void setCellSpacing ( String cellSpacing ) { setAttribute ( "cellspacing" , cellSpacing ) ; } public String getFrame ( ) { return capitalize ( getAttribute ( "frame" ) ) ; } public void setFrame ( String frame ) { setAttribute ( "frame" , frame ) ; } public String getRules ( ) { return capitalize ( getAttribute ( "rules" ) ) ; } public void setRules ( String rules ) { setAttribute ( "rules" , rules ) ; } public String getSummary ( ) { return getAttribute ( "summary" ) ; } public void setSummary ( String summary ) { setAttribute ( "summary" , summary ) ; } public String getWidth ( ) { return getAttribute ( "width" ) ; } public void setWidth ( String width ) { setAttribute ( "width" , width ) ; } public HTMLElement insertRow ( int index ) { HTMLTableRowElementImpl newRow ; newRow = new HTMLTableRowElementImpl ( ( HTMLDocumentImpl ) getOwnerDocument ( ) , "TR" ) ; insertRowX ( index , newRow ) ; return newRow ; } void insertRowX ( int index , HTMLTableRowElementImpl newRow ) { Node child ; Node lastSection = null ; child = getFirstChild ( ) ; while ( child != null ) { if ( child instanceof HTMLTableRowElement ) { if ( index == 0 ) { insertBefore ( newRow , child ) ; return ; } } else if ( child instanceof HTMLTableSectionElementImpl ) { lastSection = child ; index = ( ( HTMLTableSectionElementImpl ) child ) . insertRowX ( index , newRow ) ; if ( index < 0 ) return ; } child = child . getNextSibling ( ) ; } if ( lastSection != null ) lastSection . appendChild ( newRow ) ; else appendChild ( newRow ) ; } public synchronized void deleteRow ( int index ) { Node child ; child = getFirstChild ( ) ; while ( child != null ) { if ( child instanceof HTMLTableRowElement ) { if ( index == 0 ) { removeChild ( child ) ; return ; } } else if ( child instanceof HTMLTableSectionElementImpl ) { index = ( ( HTMLTableSectionElementImpl ) child ) . deleteRowX ( index ) ; if ( index < 0 ) return ; } child = child . getNextSibling ( ) ; } } public HTMLTableElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } private HTMLCollectionImpl _rows ; private HTMLCollectionImpl _bodies ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ParentNode extends NodeImpl { static final long serialVersionUID = 2815829867152120872L ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ParentNode ( ) { } public Node cloneNode ( boolean deep ) { ParentNode newnode = ( ParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1
package org . w3c . dom . range ; import org . w3c . dom . DOMException ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Node ; public interface Range { public Node getStartContainer ( ) throws DOMException ; public int getStartOffset ( ) throws DOMException ; public Node getEndContainer ( ) throws DOMException ; public int getEndOffset ( ) throws DOMException ; public boolean getCollapsed ( ) throws DOMException ; public Node getCommonAncestorContainer ( ) throws DOMException ; public void setStart ( Node refNode , int offset ) throws RangeException , DOMException ; public void setEnd ( Node refNode , int offset ) throws RangeException , DOMException ; public void setStartBefore ( Node refNode ) throws RangeException , DOMException ; public void setStartAfter ( Node refNode ) throws RangeException , DOMException ; public void setEndBefore ( Node refNode ) throws RangeException , DOMException ; public void setEndAfter ( Node refNode ) throws RangeException , DOMException ; public void collapse ( boolean toStart ) throws DOMException ; public void selectNode ( Node refNode ) throws RangeException , DOMException ; public void selectNodeContents ( Node refNode ) throws RangeException , DOMException ; public static final short START_TO_START = 0 ; public static final short START_TO_END = 1 ; public static final short END_TO_END = 2 ; public static final short END_TO_START = 3 ; public short compareBoundaryPoints ( short how , Range sourceRange ) throws DOMException ; public void deleteContents ( ) throws DOMException ; public DocumentFragment extractContents ( ) throws DOMException ; public DocumentFragment cloneContents ( ) throws DOMException ; public void insertNode ( Node newNode ) throws DOMException , RangeException ; public void surroundContents ( Node newParent ) throws DOMException , RangeException ; public Range cloneRange ( ) throws DOMException ; public String toString ( ) throws DOMException ; public void detach ( ) throws DOMException ; } 	0
package javax . xml . parsers ; public abstract class DocumentBuilderFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.DocumentBuilderFactory" ; private static String factory = "org.apache.xerces.jaxp.DocumentBuilderFactoryImpl" ; protected DocumentBuilderFactory ( ) { super ( ) ; } public static DocumentBuilderFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( DocumentBuilderFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"" + "javax.xml.parsers.DocumentBuilderFactory\"" ) ; } } public abstract DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . wml ; public interface WMLAccessElement extends WMLElement { public void setDomain ( String newValue ) ; public String getDomain ( ) ; public void setPath ( String newValue ) ; public String getPath ( ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; public class NamedNodeMapImpl implements NamedNodeMap , Serializable { static final long serialVersionUID = - 7039242451046758020L ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short CHANGED = 0x1 << 1 ; protected final static short HASDEFAULTS = 0x1 << 2 ; protected Vector nodes ; protected NodeImpl ownerNode ; protected NamedNodeMapImpl ( NodeImpl ownerNode ) { this . ownerNode = ownerNode ; } public int getLength ( ) { return ( nodes != null ) ? nodes . size ( ) : 0 ; } public Node item ( int index ) { return ( nodes != null && index < nodes . size ( ) ) ? ( Node ) ( nodes . elementAt ( index ) ) : null ; } public Node getNamedItem ( String name ) { int i = findNamePoint ( name , 0 ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node getNamedItemNS ( String namespaceURI , String localName ) { int i = findNamePoint ( namespaceURI , localName ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNamespaceURI ( ) , arg . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { NamedNodeMapImpl newmap = new NamedNodeMapImpl ( ownerNode ) ; newmap . cloneContent ( this ) ; return newmap ; } protected void cloneContent ( NamedNodeMapImpl srcmap ) { if ( srcmap . nodes != null ) { nodes = new Vector ( srcmap . nodes . size ( ) ) ; for ( int i = 0 ; i < srcmap . nodes . size ( ) ; ++ i ) { NodeImpl n = ( NodeImpl ) srcmap . nodes . elementAt ( i ) ; NodeImpl clone = ( NodeImpl ) n . cloneNode ( true ) ; clone . isSpecified ( n . isSpecified ( ) ) ; nodes . insertElementAt ( clone , i ) ; } } } void setReadOnly ( boolean readOnly , boolean deep ) { isReadOnly ( readOnly ) ; if ( deep && nodes != null ) { Enumeration e = nodes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( NodeImpl ) e . nextElement ( ) ) . setReadOnly ( readOnly , deep ) ; } } } boolean getReadOnly ( ) { return isReadOnly ( ) ; } void setOwnerDocument ( DocumentImpl doc ) { if ( nodes != null ) { for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { ( ( NodeImpl ) item ( i ) ) . setOwnerDocument ( doc ) ; } } } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean changed ( ) { return ( flags & CHANGED ) != 0 ; } final void changed ( boolean value ) { flags = ( short ) ( value ? flags | CHANGED : flags & ~ CHANGED ) ; } final boolean hasDefaults ( ) { return ( flags & HASDEFAULTS ) != 0 ; } final void hasDefaults ( boolean value ) { flags = ( short ) ( value ? flags | HASDEFAULTS : flags & ~ HASDEFAULTS ) ; } protected int findNamePoint ( String name , int start ) { int i = 0 ; if ( nodes != null ) { int first = start ; int last = nodes . size ( ) - 1 ; while ( first <= last ) { i = ( first + last ) / 2 ; int test = name . compareTo ( ( ( Node ) ( nodes . elementAt ( i ) ) ) . getNodeName ( ) ) ; if ( test == 0 ) { return i ; } else if ( test < 0 ) { last = i - 1 ; } else { first = i + 1 ; } } if ( first > i ) { i = first ; } } return - 1 - i ; } protected int findNamePoint ( String namespaceURI , String name ) { if ( nodes == null ) return - 1 ; if ( namespaceURI == null ) return - 1 ; if ( name == null ) return - 1 ; for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { NodeImpl a = ( NodeImpl ) nodes . elementAt ( i ) ; if ( namespaceURI . equals ( a . getNamespaceURI ( ) ) && name . equals ( a . getLocalName ( ) ) ) { return i ; } } return - 1 ; } } 	1
package org . apache . xerces . utils ; import java . lang . * ; public final class ISO8601Format { public ISO8601Format ( String dateString ) { } } 	0
package org . w3c . dom ; public interface NamedNodeMap { public Node getNamedItem ( String name ) ; public Node setNamedItem ( Node arg ) throws DOMException ; public Node removeNamedItem ( String name ) throws DOMException ; public Node item ( int index ) ; public int getLength ( ) ; public Node getNamedItemNS ( String namespaceURI , String localName ) ; public Node setNamedItemNS ( Node arg ) throws DOMException ; public Node removeNamedItemNS ( String namespaceURI , String localName ) throws DOMException ; } 	1
package org . apache . xerces . validators . datatype ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; import org . apache . xerces . utils . Base64 ; import org . apache . xerces . utils . HexBin ; public class BinaryDatatypeValidator extends AbstractDatatypeValidator { private DatatypeValidator fBaseValidator = null ; private int fLength = 0 ; private int fMaxLength = Integer . MAX_VALUE ; private int fMinLength = 0 ; private String fPattern = null ; private Vector fEnumeration = null ; private int fFacetsDefined = 0 ; private String fEncoding = SchemaSymbols . ATTVAL_BASE64 ; private boolean fDerivedByList = false ; public BinaryDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public BinaryDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { if ( base != null ) setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { if ( fDerivedByList == false ) { for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . equals ( SchemaSymbols . ELT_LENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_LENGTH ; String lengthValue = ( String ) facets . get ( key ) ; try { fLength = Integer . parseInt ( lengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "' is invalid." ) ; } if ( fLength < 0 ) throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "'  must be a nonNegativeInteger." ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MINLENGTH ; String minLengthValue = ( String ) facets . get ( key ) ; try { fMinLength = Integer . parseInt ( minLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + minLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MAXLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXLENGTH ; String maxLengthValue = ( String ) facets . get ( key ) ; try { fMaxLength = Integer . parseInt ( maxLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + maxLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = ( String ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; fEnumeration = ( Vector ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENCODING ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; fEncoding = ( String ) facets . get ( key ) ; } else { throw new InvalidDatatypeFacetException ( ) ; } } if ( ( ( fFacetsDefined & DatatypeValidator . FACET_LENGTH ) != 0 ) ) { if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MAXLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and maxLength to be members of facets." ) ; } else if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MINLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and minLength to be members of facets." ) ; } } if ( ( ( fFacetsDefined & ( DatatypeValidator . FACET_MINLENGTH | DatatypeValidator . FACET_MAXLENGTH ) ) != 0 ) ) { if ( fMinLength > fMaxLength ) { throw new InvalidDatatypeFacetException ( "Value of maxLength = " + fMaxLength + "must be greater that the value of minLength" + fMinLength ) ; } } } else { } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { if ( fDerivedByList == false ) { if ( this . fBaseValidator != null ) { this . fBaseValidator . validate ( content , state ) ; } if ( ( ( fFacetsDefined & DatatypeValidator . FACET_ENCODING ) != 0 ) ) { if ( fEncoding . equals ( SchemaSymbols . ATTVAL_BASE64 ) ) { if ( Base64 . isBase64 ( content ) == false ) { throw new InvalidDatatypeValueException ( "Value '" + content + "'  must be" + "is not encoded in Base64" ) ; } } else { if ( HexBin . isHex ( content ) == false ) { throw new InvalidDatatypeValueException ( "Value '" + content + "'  must be" + "is not encoded in Hex" ) ; } } } } else { } return null ; } public int compare ( String content1 , String content2 ) { return 0 ; } public Hashtable getFacets ( ) { return null ; } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } } 	0
package org . apache . xml . serialize ; import java . util . Hashtable ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Node ; import org . w3c . dom . html . HTMLDocument ; public class OutputFormat { public static class DTD { public static final String HTMLPublicId = "-//W3C//DTD HTML 4.0//EN" ; public static final String HTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; public static final String XHTMLPublicId = "-//W3C//DTD XHTML 1.0 Strict//EN" ; public static final String XHTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; } public static class Defaults { public static final int Indent = 4 ; public static final String Encoding = "UTF-8" ; public static final int LineWidth = 72 ; } private String _method ; private String _version ; private int _indent = 0 ; private String _encoding = Defaults . Encoding ; private String _mediaType ; private String _doctypeSystem ; private String _doctypePublic ; private boolean _omitXmlDeclaration = false ; private boolean _omitDoctype = false ; private boolean _omitComments = false ; private boolean _stripComments = false ; private boolean _standalone = false ; private String [ ] _cdataElements ; private String [ ] _nonEscapingElements ; private String _lineSeparator = LineSeparator . Web ; private int _lineWidth = Defaults . LineWidth ; private boolean _preserve = false ; public OutputFormat ( ) { } public OutputFormat ( String method , String encoding , boolean indenting ) { setMethod ( method ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public OutputFormat ( Document doc ) { setMethod ( whichMethod ( doc ) ) ; setDoctype ( whichDoctypePublic ( doc ) , whichDoctypeSystem ( doc ) ) ; setMediaType ( whichMediaType ( getMethod ( ) ) ) ; } public OutputFormat ( Document doc , String encoding , boolean indenting ) { this ( doc ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public String getMethod ( ) { return _method ; } public void setMethod ( String method ) { _method = method ; } public String getVersion ( ) { return _version ; } public void setVersion ( String version ) { _version = version ; } public int getIndent ( ) { return _indent ; } public boolean getIndenting ( ) { return ( _indent > 0 ) ; } public void setIndent ( int indent ) { if ( indent < 0 ) _indent = 0 ; else _indent = indent ; } public void setIndenting ( boolean on ) { if ( on ) { _indent = Defaults . Indent ; _lineWidth = Defaults . LineWidth ; } else { _indent = 0 ; _lineWidth = 0 ; } } public String getEncoding ( ) { return _encoding ; } public void setEncoding ( String encoding ) { _encoding = encoding ; } public String getMediaType ( ) { return _mediaType ; } public void setMediaType ( String mediaType ) { _mediaType = mediaType ; } public void setDoctype ( String publicId , String systemId ) { _doctypePublic = publicId ; _doctypeSystem = systemId ; } public String getDoctypePublic ( ) { return _doctypePublic ; } public String getDoctypeSystem ( ) { return _doctypeSystem ; } public boolean getOmitComments ( ) { return _omitComments ; } public void setOmitComments ( boolean omit ) { _omitComments = omit ; } public boolean getOmitDocumentType ( ) { return _omitDoctype ; } public void setOmitDocumentType ( boolean omit ) { _omitDoctype = omit ; } public boolean getOmitXMLDeclaration ( ) { return _omitXmlDeclaration ; } public void setOmitXMLDeclaration ( boolean omit ) { _omitXmlDeclaration = omit ; } public boolean getStandalone ( ) { return _standalone ; } public void setStandalone ( boolean standalone ) { _standalone = standalone ; } public String [ ] getCDataElements ( ) { return _cdataElements ; } public boolean isCDataElement ( String tagName ) { int i ; if ( _cdataElements == null ) return false ; for ( i = 0 ; i < _cdataElements . length ; ++ i ) if ( _cdataElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setCDataElements ( String [ ] cdataElements ) { _cdataElements = cdataElements ; } public String [ ] getNonEscapingElements ( ) { return _nonEscapingElements ; } public boolean isNonEscapingElement ( String tagName ) { int i ; if ( _nonEscapingElements == null ) return false ; for ( i = 0 ; i < _nonEscapingElements . length ; ++ i ) if ( _nonEscapingElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setNonEscapingElements ( String [ ] nonEscapingElements ) { _nonEscapingElements = nonEscapingElements ; } public String getLineSeparator ( ) { return _lineSeparator ; } public void setLineSeparator ( String lineSeparator ) { if ( lineSeparator == null ) _lineSeparator = LineSeparator . Web ; else _lineSeparator = lineSeparator ; } public boolean getPreserveSpace ( ) { return _preserve ; } public void setPreserveSpace ( boolean preserve ) { _preserve = preserve ; } public int getLineWidth ( ) { return _lineWidth ; } public void setLineWidth ( int lineWidth ) { if ( lineWidth <= 0 ) _lineWidth = 0 ; else _lineWidth = lineWidth ; } public char getLastPrintable ( ) { if ( getEncoding ( ) != null && ( getEncoding ( ) . equalsIgnoreCase ( "ASCII" ) ) ) return 0xFF ; else return 0xFFFF ; } public static String whichMethod ( Document doc ) { Node node ; String value ; int i ; if ( doc instanceof HTMLDocument ) return Method . HTML ; node = doc . getFirstChild ( ) ; while ( node != null ) { if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( node . getNodeName ( ) . equalsIgnoreCase ( "html" ) ) { return Method . HTML ; } else if ( node . getNodeName ( ) . equalsIgnoreCase ( "root" ) ) { return Method . FOP ; } else { return Method . XML ; } } else if ( node . getNodeType ( ) == Node . TEXT_NODE ) { value = node . getNodeValue ( ) ; for ( i = 0 ; i < value . length ( ) ; ++ i ) if ( value . charAt ( i ) != 0x20 && value . charAt ( i ) != 0x0A && value . charAt ( i ) != 0x09 && value . charAt ( i ) != 0x0D ) return Method . XML ; } node = node . getNextSibling ( ) ; } return Method . XML ; } public static String whichDoctypePublic ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLPublicId ; return null ; } public static String whichDoctypeSystem ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLSystemId ; return null ; } public static String whichMediaType ( String method ) { if ( method . equalsIgnoreCase ( Method . XML ) ) return "text/xml" ; if ( method . equalsIgnoreCase ( Method . HTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . XHTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . TEXT ) ) return "text/plain" ; if ( method . equalsIgnoreCase ( Method . FOP ) ) return "application/pdf" ; return null ; } } 	1
package org . apache . html . dom ; import java . util . Vector ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; import org . xml . sax . * ; import org . apache . xerces . dom . TextImpl ; import org . apache . xerces . dom . ElementImpl ; import org . apache . xerces . dom . ProcessingInstructionImpl ; public class HTMLBuilder implements DocumentHandler { protected HTMLDocumentImpl _document ; protected ElementImpl _current ; private Locator _locator ; private boolean _ignoreWhitespace = true ; private boolean _done = true ; protected Vector _preRootNodes ; public void startDocument ( ) throws SAXException { if ( ! _done ) throw new SAXException ( "HTM001 State error: startDocument fired twice on one builder." ) ; _document = null ; _done = false ; } public void endDocument ( ) throws SAXException { if ( _document == null ) throw new SAXException ( "HTM002 State error: document never started or missing document element." ) ; if ( _current != null ) throw new SAXException ( "HTM003 State error: document ended before end of document element." ) ; _current = null ; _done = true ; } public synchronized void startElement ( String tagName , AttributeList attrList ) throws SAXException { ElementImpl elem ; int i ; if ( tagName == null ) throw new SAXException ( "HTM004 Argument 'tagName' is null." ) ; if ( _document == null ) { _document = new HTMLDocumentImpl ( ) ; elem = ( ElementImpl ) _document . getDocumentElement ( ) ; _current = elem ; if ( _current == null ) throw new SAXException ( "HTM005 State error: Document.getDocumentElement returns null." ) ; if ( _preRootNodes != null ) { for ( i = _preRootNodes . size ( ) ; i -- > 0 ; ) _document . insertBefore ( ( Node ) _preRootNodes . elementAt ( i ) , elem ) ; _preRootNodes = null ; } } else { if ( _current == null ) throw new SAXException ( "HTM006 State error: startElement called after end of document element." ) ; elem = ( ElementImpl ) _document . createElement ( tagName ) ; _current . appendChild ( elem ) ; _current = elem ; } if ( attrList != null ) { for ( i = 0 ; i < attrList . getLength ( ) ; ++ i ) elem . setAttribute ( attrList . getName ( i ) , attrList . getValue ( i ) ) ; } } public void endElement ( String tagName ) throws SAXException { if ( _current == null ) throw new SAXException ( "HTM007 State error: endElement called with no current node." ) ; if ( ! _current . getNodeName ( ) . equals ( tagName ) ) throw new SAXException ( "HTM008 State error: mismatch in closing tag name " + tagName + "\n" + tagName ) ; if ( _current . getParentNode ( ) == _current . getOwnerDocument ( ) ) _current = null ; else _current = ( ElementImpl ) _current . getParentNode ( ) ; } public void characters ( String text ) throws SAXException { if ( _current == null ) throw new SAXException ( "HTM009 State error: character data found outside of root element." ) ; _current . appendChild ( new TextImpl ( _document , text ) ) ; } public void characters ( char [ ] text , int start , int length ) throws SAXException { if ( _current == null ) throw new SAXException ( "HTM010 State error: character data found outside of root element." ) ; _current . appendChild ( new TextImpl ( _document , new String ( text , start , length ) ) ) ; } public void ignorableWhitespace ( char [ ] text , int start , int length ) throws SAXException { Node node ; if ( ! _ignoreWhitespace ) _current . appendChild ( new TextImpl ( _document , new String ( text , start , length ) ) ) ; } public void processingInstruction ( String target , String instruction ) throws SAXException { Node node ; if ( _current == null && _document == null ) { if ( _preRootNodes == null ) _preRootNodes = new Vector ( ) ; _preRootNodes . addElement ( new ProcessingInstructionImpl ( null , target , instruction ) ) ; } else if ( _current == null && _document != null ) _document . appendChild ( new ProcessingInstructionImpl ( _document , target , instruction ) ) ; else _current . appendChild ( new ProcessingInstructionImpl ( _document , target , instruction ) ) ; } public HTMLDocument getHTMLDocument ( ) { return ( HTMLDocument ) _document ; } public void setDocumentLocator ( Locator locator ) { _locator = locator ; } } 	0
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public abstract class SAXParser { protected SAXParser ( ) { super ( ) ; } public void parse ( InputStream stream , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( stream ) , base ) ; } public void parse ( String uri , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( uri ) , base ) ; } public void parse ( File file , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; String path = file . getAbsolutePath ( ) ; if ( File . separatorChar != '/' ) { path = path . replace ( File . separatorChar , '/' ) ; } if ( ! path . startsWith ( "/" ) ) { path = "/" + path ; } if ( ! path . endsWith ( "/" ) && file . isDirectory ( ) ) { path = path + "/" ; } java . net . URL url = new java . net . URL ( "file" , "" , path ) ; this . parse ( new InputSource ( url . toString ( ) ) , base ) ; } public void parse ( InputSource source , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( source == null ) throw new IllegalArgumentException ( ) ; Parser p = this . getParser ( ) ; if ( base != null ) { p . setDocumentHandler ( base ) ; p . setDTDHandler ( base ) ; p . setEntityResolver ( base ) ; p . setErrorHandler ( base ) ; } p . parse ( source ) ; } public abstract Parser getParser ( ) throws SAXException ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLSelectElementImpl extends WMLElementImpl implements WMLSelectElement { public WMLSelectElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setMultiple ( boolean newValue ) { setAttribute ( "multiple" , newValue ) ; } public boolean getMultiple ( ) { return getAttribute ( "multiple" , false ) ; } public void setValue ( String newValue ) { setAttribute ( "value" , newValue ) ; } public String getValue ( ) { return getAttribute ( "value" ) ; } public void setTabIndex ( int newValue ) { setAttribute ( "tabindex" , newValue ) ; } public int getTabIndex ( ) { return getAttribute ( "tabindex" , 0 ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setTitle ( String newValue ) { setAttribute ( "title" , newValue ) ; } public String getTitle ( ) { return getAttribute ( "title" ) ; } public void setIValue ( String newValue ) { setAttribute ( "ivalue" , newValue ) ; } public String getIValue ( ) { return getAttribute ( "ivalue" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setIName ( String newValue ) { setAttribute ( "iname" , newValue ) ; } public String getIName ( ) { return getAttribute ( "iname" ) ; } public void setName ( String newValue ) { setAttribute ( "name" , newValue ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } } 	0
package org . w3c . dom ; public interface Element extends Node { public String getTagName ( ) ; public String getAttribute ( String name ) ; public void setAttribute ( String name , String value ) throws DOMException ; public void removeAttribute ( String name ) throws DOMException ; public Attr getAttributeNode ( String name ) ; public Attr setAttributeNode ( Attr newAttr ) throws DOMException ; public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException ; public NodeList getElementsByTagName ( String name ) ; public String getAttributeNS ( String namespaceURI , String localName ) ; public void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException ; public void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException ; public Attr getAttributeNodeNS ( String namespaceURI , String localName ) ; public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public boolean hasAttribute ( String name ) ; public boolean hasAttributeNS ( String namespaceURI , String localName ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLLegendElementImpl extends HTMLElementImpl implements HTMLLegendElement { public String getAccessKey ( ) { String accessKey ; accessKey = getAttribute ( "accesskey" ) ; if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; return accessKey ; } public void setAccessKey ( String accessKey ) { if ( accessKey != null && accessKey . length ( ) > 1 ) accessKey = accessKey . substring ( 0 , 1 ) ; setAttribute ( "accesskey" , accessKey ) ; } public String getAlign ( ) { return getAttribute ( "align" ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public HTMLLegendElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class NotationImpl extends NodeImpl implements Notation { static final long serialVersionUID = - 764632195890658402L ; protected String name ; protected String publicId ; protected String systemId ; public NotationImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; } public short getNodeType ( ) { return Node . NOTATION_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public String getPublicId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return publicId ; } public String getSystemId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return systemId ; } public void setPublicId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } publicId = id ; } public void setSystemId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } systemId = id ; } } 	1
package org . apache . xerces . validators . common ; import java . util . * ; import org . apache . xerces . validators . common . Grammar ; public interface GrammarResolver { public Grammar getGrammar ( String nameSpaceKey ) ; public Enumeration nameSpaceKeys ( ) ; public void putGrammar ( String nameSpaceKey , Grammar grammar ) ; public Grammar removeGrammar ( String nameSpaceKey ) ; public boolean contains ( Grammar grammar ) ; public boolean containsNameSpace ( String nameSpaceKey ) ; public void clearGrammarResolver ( ) ; public int size ( ) ; } 	0
package org . w3c . dom . events ; public interface EventListener { public void handleEvent ( Event evt ) ; } 	1
package org . w3c . dom . html ; public interface HTMLMenuElement extends HTMLElement { public boolean getCompact ( ) ; public void setCompact ( boolean compact ) ; } 	0
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface LexicalHandler { public abstract void startDTD ( String name , String publicId , String systemId ) throws SAXException ; public abstract void endDTD ( ) throws SAXException ; public abstract void startEntity ( String name ) throws SAXException ; public abstract void endEntity ( String name ) throws SAXException ; public abstract void startCDATA ( ) throws SAXException ; public abstract void endCDATA ( ) throws SAXException ; public abstract void comment ( char ch [ ] , int start , int length ) throws SAXException ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLTableColElementImpl extends HTMLElementImpl implements HTMLTableColElement { public String getAlign ( ) { return capitalize ( getAttribute ( "align" ) ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public String getCh ( ) { String ch ; ch = getAttribute ( "char" ) ; if ( ch != null && ch . length ( ) > 1 ) ch = ch . substring ( 0 , 1 ) ; return ch ; } public void setCh ( String ch ) { if ( ch != null && ch . length ( ) > 1 ) ch = ch . substring ( 0 , 1 ) ; setAttribute ( "char" , ch ) ; } public String getChOff ( ) { return getAttribute ( "charoff" ) ; } public void setChOff ( String chOff ) { setAttribute ( "charoff" , chOff ) ; } public int getSpan ( ) { return getInteger ( getAttribute ( "span" ) ) ; } public void setSpan ( int span ) { setAttribute ( "span" , String . valueOf ( span ) ) ; } public String getVAlign ( ) { return capitalize ( getAttribute ( "valign" ) ) ; } public void setVAlign ( String vAlign ) { setAttribute ( "valign" , vAlign ) ; } public String getWidth ( ) { return getAttribute ( "width" ) ; } public void setWidth ( String width ) { setAttribute ( "width" , width ) ; } public HTMLTableColElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrImpl extends ParentNode implements Attr { static final long serialVersionUID = 7277707688218972102L ; protected String name ; protected AttrImpl ( DocumentImpl ownerDocument , String name ) { super ( ownerDocument ) ; this . name = name ; isSpecified ( true ) ; } protected AttrImpl ( ) { } public Node cloneNode ( boolean deep ) { AttrImpl clone = ( AttrImpl ) super . cloneNode ( deep ) ; clone . isSpecified ( true ) ; return clone ; } public short getNodeType ( ) { return Node . ATTRIBUTE_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setNodeValue ( String value ) throws DOMException { setValue ( value ) ; } public String getNodeValue ( ) { return getValue ( ) ; } public String getName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setValue ( String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } LCount lc = null ; String oldvalue = "" ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 && ownerNode != null ) { oldvalue = getValue ( ) ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } while ( firstChild != null ) internalRemoveChild ( firstChild , MUTATION_LOCAL ) ; } else { if ( firstChild != null ) { firstChild . previousSibling = null ; firstChild . isFirstChild ( false ) ; firstChild = null ; } needsSyncChildren ( false ) ; } isSpecified ( true ) ; if ( value != null ) { internalInsertBefore ( ownerDocument . createTextNode ( value ) , null , MUTATION_LOCAL ) ; } changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( this , oldvalue ) ; } } public String getValue ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( firstChild == null ) { return "" ; } ChildNode node = firstChild . nextSibling ; if ( node == null ) { return firstChild . getNodeValue ( ) ; } StringBuffer value = new StringBuffer ( firstChild . getNodeValue ( ) ) ; while ( node != null ) { value . append ( node . getNodeValue ( ) ) ; node = node . nextSibling ; } return value . toString ( ) ; } public boolean getSpecified ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isSpecified ( ) ; } public Element getElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public Element getOwnerElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public void normalize ( ) { Node kid , next ; for ( kid = firstChild ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } } } public void setSpecified ( boolean arg ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isSpecified ( arg ) ; } public String toString ( ) { return getName ( ) + "=" + "\"" + getValue ( ) + "\"" ; } } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import java . util . Locale ; public class NOTATIONDatatypeValidator extends AbstractDatatypeValidator { private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; public NOTATIONDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public NOTATIONDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { fDerivedByList = derivedByList ; setBasetype ( base ) ; } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { return null ; } public Hashtable getFacets ( ) { return null ; } public void setLocale ( Locale locale ) { } public int compare ( String content1 , String content2 ) { return - 1 ; } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } } 	0
package org . w3c . dom ; public interface CharacterData extends Node { public String getData ( ) throws DOMException ; public void setData ( String data ) throws DOMException ; public int getLength ( ) ; public String substringData ( int offset , int count ) throws DOMException ; public void appendData ( String arg ) throws DOMException ; public void insertData ( int offset , String arg ) throws DOMException ; public void deleteData ( int offset , int count ) throws DOMException ; public void replaceData ( int offset , int count , String arg ) throws DOMException ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLMenuElementImpl extends HTMLElementImpl implements HTMLMenuElement { public boolean getCompact ( ) { return getBinary ( "compact" ) ; } public void setCompact ( boolean compact ) { setAttribute ( "compact" , compact ) ; } public HTMLMenuElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface Event { public static final short CAPTURING_PHASE = 1 ; public static final short AT_TARGET = 2 ; public static final short BUBBLING_PHASE = 3 ; public String getType ( ) ; public EventTarget getTarget ( ) ; public Node getCurrentNode ( ) ; public short getEventPhase ( ) ; public boolean getBubbles ( ) ; public boolean getCancelable ( ) ; public long getTimeStamp ( ) ; public void stopPropagation ( ) ; public void preventDefault ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) ; } 	1
package org . apache . xerces . validators . datatype ; public interface StateMessageDatatype { public Object getDatatypeObject ( ) ; public void setDatatypeObject ( Object data ) ; public int getDatatypeState ( ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Enumeration ; import java . util . Vector ; import org . w3c . dom . * ; public class ElementImpl extends ChildAndParentNode implements Element { static final long serialVersionUID = 3717253516652722278L ; protected String name ; protected AttributeMap attributes ; public ElementImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; needsSyncData ( true ) ; } protected ElementImpl ( ) { } public short getNodeType ( ) { return Node . ELEMENT_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public NamedNodeMap getAttributes ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return attributes ; } public Node cloneNode ( boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } ElementImpl newnode = ( ElementImpl ) super . cloneNode ( deep ) ; if ( attributes != null ) { newnode . attributes = ( AttributeMap ) attributes . cloneMap ( newnode ) ; } return newnode ; } void setOwnerDocument ( DocumentImpl doc ) { super . setOwnerDocument ( doc ) ; if ( attributes != null ) { attributes . setOwnerDocument ( doc ) ; } } public String getAttribute ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return "" ; } Attr attr = ( Attr ) ( attributes . getNamedItem ( name ) ) ; return ( attr == null ) ? "" : attr . getValue ( ) ; } public Attr getAttributeNode ( String name ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItem ( name ) ; } public NodeList getElementsByTagName ( String tagname ) { return new DeepNodeListImpl ( this , tagname ) ; } public String getTagName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void normalize ( ) { Node kid , next ; for ( kid = getFirstChild ( ) ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } else if ( kid . getNodeType ( ) == Node . ELEMENT_NODE ) { ( ( Element ) kid ) . normalize ( ) ; } } } public void removeAttribute ( String name ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItem ( name ) ; } public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } return ( Attr ) attributes . removeNamedItem ( oldAttr . getName ( ) ) ; } public void setAttribute ( String name , String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } Attr newAttr = getAttributeNode ( name ) ; if ( newAttr == null ) { newAttr = getOwnerDocument ( ) . createAttribute ( name ) ; if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } attributes . setNamedItem ( newAttr ) ; } newAttr . setNodeValue ( value ) ; } public Attr setAttributeNode ( Attr newAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ownerDocument . errorChecking && newAttr . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return ( Attr ) attributes . setNamedItem ( newAttr ) ; } public String getAttributeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return "" ; } Attr attr = ( Attr ) ( attributes . getNamedItemNS ( namespaceURI , localName ) ) ; return ( attr == null ) ? null : attr . getValue ( ) ; } public void setAttributeNS ( String namespaceURI , String localName , String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } Attr newAttr = getAttributeNodeNS ( namespaceURI , localName ) ; if ( newAttr == null ) { newAttr = getOwnerDocument ( ) . createAttributeNS ( namespaceURI , localName ) ; if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } attributes . setNamedItemNS ( newAttr ) ; } newAttr . setNodeValue ( value ) ; } public void removeAttributeNS ( String namespaceURI , String localName ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return ; } attributes . safeRemoveNamedItemNS ( namespaceURI , localName ) ; } public Attr getAttributeNodeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItemNS ( namespaceURI , localName ) ; } public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ownerDocument . errorChecking && newAttr . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( attributes == null ) { attributes = new AttributeMap ( this , null ) ; } return ( Attr ) attributes . setNamedItemNS ( newAttr ) ; } public boolean hasAttributes ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return ( attributes != null && attributes . getLength ( ) != 0 ) ; } public boolean hasAttribute ( String name ) { return getAttributeNode ( name ) != null ; } public boolean hasAttributeNS ( String namespaceURI , String localName ) { return getAttributeNodeNS ( namespaceURI , localName ) != null ; } public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) { return new DeepNodeListImpl ( this , namespaceURI , localName ) ; } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( attributes != null ) { attributes . setReadOnly ( readOnly , true ) ; } } protected void synchronizeData ( ) { needsSyncData ( false ) ; setupDefaultAttributes ( ) ; } protected void setupDefaultAttributes ( ) { NamedNodeMapImpl defaults = getDefaultAttributes ( ) ; if ( defaults != null ) { attributes = new AttributeMap ( this , defaults ) ; } } protected NamedNodeMapImpl getDefaultAttributes ( ) { DocumentTypeImpl doctype = ( DocumentTypeImpl ) ownerDocument . getDoctype ( ) ; if ( doctype == null ) { return null ; } ElementDefinitionImpl eldef = ( ElementDefinitionImpl ) doctype . getElements ( ) . getNamedItem ( getNodeName ( ) ) ; if ( eldef == null ) { return null ; } return ( NamedNodeMapImpl ) eldef . getAttributes ( ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLFormElementImpl extends HTMLElementImpl implements HTMLFormElement { public HTMLCollection getElements ( ) { if ( _elements == null ) _elements = new HTMLCollectionImpl ( this , HTMLCollectionImpl . ELEMENT ) ; return _elements ; } public int getLength ( ) { return getElements ( ) . getLength ( ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public String getAcceptCharset ( ) { return getAttribute ( "accept-charset" ) ; } public void setAcceptCharset ( String acceptCharset ) { setAttribute ( "accept-charset" , acceptCharset ) ; } public String getAction ( ) { return getAttribute ( "action" ) ; } public void setAction ( String action ) { setAttribute ( "action" , action ) ; } public String getEnctype ( ) { return getAttribute ( "enctype" ) ; } public void setEnctype ( String enctype ) { setAttribute ( "enctype" , enctype ) ; } public String getMethod ( ) { return capitalize ( getAttribute ( "method" ) ) ; } public void setMethod ( String method ) { setAttribute ( "method" , method ) ; } public String getTarget ( ) { return getAttribute ( "target" ) ; } public void setTarget ( String target ) { setAttribute ( "target" , target ) ; } public void submit ( ) { } public void reset ( ) { } public HTMLFormElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } private HTMLCollectionImpl _elements ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class TextImpl extends CharacterDataImpl implements CharacterData , Text { static final long serialVersionUID = - 5294980852957403469L ; public TextImpl ( DocumentImpl ownerDoc , String data ) { super ( ownerDoc , data ) ; } public short getNodeType ( ) { return Node . TEXT_NODE ; } public String getNodeName ( ) { return "#text" ; } public void setIgnorableWhitespace ( boolean ignore ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isIgnorableWhitespace ( ignore ) ; } public boolean isIgnorableWhitespace ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return internalIsIgnorableWhitespace ( ) ; } public Text splitText ( int offset ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( offset < 0 || offset > data . length ( ) - 1 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } Text newText = getOwnerDocument ( ) . createTextNode ( data . substring ( offset ) ) ; setNodeValue ( data . substring ( 0 , offset ) ) ; Node parentNode = getParentNode ( ) ; if ( parentNode != null ) { parentNode . insertBefore ( newText , nextSibling ) ; } return newText ; } } 	1
package org . apache . xml . serialize ; import java . io . Writer ; import java . io . StringWriter ; import java . io . IOException ; class IndentPrinter extends Printer { private StringBuffer _line ; private StringBuffer _text ; private int _spaces ; private int _thisIndent ; private int _nextIndent ; IndentPrinter ( Writer writer , OutputFormat format ) { super ( writer , format ) ; _line = new StringBuffer ( 80 ) ; _text = new StringBuffer ( 20 ) ; _spaces = 0 ; _thisIndent = _nextIndent = 0 ; } public void enterDTD ( ) { if ( _dtdWriter == null ) { _line . append ( _text ) ; _text = new StringBuffer ( 20 ) ; flushLine ( false ) ; _dtdWriter = new StringWriter ( ) ; _docWriter = _writer ; _writer = _dtdWriter ; } } public String leaveDTD ( ) { if ( _writer == _dtdWriter ) { _line . append ( _text ) ; _text = new StringBuffer ( 20 ) ; flushLine ( false ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } else return null ; } public void printText ( String text ) { _text . append ( text ) ; } public void printText ( StringBuffer text ) { _text . append ( text ) ; } public void printText ( char ch ) { _text . append ( ch ) ; } public void printText ( char [ ] chars , int start , int length ) { _text . append ( chars , start , length ) ; } public void printSpace ( ) { if ( _text . length ( ) > 0 ) { if ( _format . getLineWidth ( ) > 0 && _thisIndent + _line . length ( ) + _spaces + _text . length ( ) > _format . getLineWidth ( ) ) { flushLine ( false ) ; try { _writer . write ( _format . getLineSeparator ( ) ) ; } catch ( IOException except ) { if ( _exception == null ) _exception = except ; } } while ( _spaces > 0 ) { _line . append ( ' ' ) ; -- _spaces ; } _line . append ( _text ) ; _text = new StringBuffer ( 20 ) ; } ++ _spaces ; } public void breakLine ( ) { breakLine ( false ) ; } public void breakLine ( boolean preserveSpace ) { if ( _text . length ( ) > 0 ) { while ( _spaces > 0 ) { _line . append ( ' ' ) ; -- _spaces ; } _line . append ( _text ) ; _text = new StringBuffer ( 20 ) ; } flushLine ( preserveSpace ) ; try { _writer . write ( _format . getLineSeparator ( ) ) ; } catch ( IOException except ) { if ( _exception == null ) _exception = except ; } } public void flushLine ( boolean preserveSpace ) { int indent ; if ( _line . length ( ) > 0 ) { try { if ( _format . getIndenting ( ) && ! preserveSpace ) { indent = _thisIndent ; if ( ( 2 * indent ) > _format . getLineWidth ( ) && _format . getLineWidth ( ) > 0 ) indent = _format . getLineWidth ( ) / 2 ; while ( indent > 0 ) { _writer . write ( ' ' ) ; -- indent ; } } _thisIndent = _nextIndent ; _spaces = 0 ; _writer . write ( _line . toString ( ) ) ; _line = new StringBuffer ( 40 ) ; } catch ( IOException except ) { if ( _exception == null ) _exception = except ; } } } public void flush ( ) { if ( _line . length ( ) > 0 || _text . length ( ) > 0 ) breakLine ( ) ; try { _writer . flush ( ) ; } catch ( IOException except ) { if ( _exception == null ) _exception = except ; } } public void indent ( ) { _nextIndent += _format . getIndent ( ) ; } public void unindent ( ) { _nextIndent -= _format . getIndent ( ) ; if ( _nextIndent < 0 ) _nextIndent = 0 ; if ( ( _line . length ( ) + _spaces + _text . length ( ) ) == 0 ) _thisIndent = _nextIndent ; } public int getNextIndent ( ) { return _nextIndent ; } public void setNextIndent ( int indent ) { _nextIndent = indent ; } public void setThisIndent ( int indent ) { _thisIndent = indent ; } } 	0
package org . w3c . dom ; public class DOMException extends RuntimeException { public DOMException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short INDEX_SIZE_ERR = 1 ; public static final short DOMSTRING_SIZE_ERR = 2 ; public static final short HIERARCHY_REQUEST_ERR = 3 ; public static final short WRONG_DOCUMENT_ERR = 4 ; public static final short INVALID_CHARACTER_ERR = 5 ; public static final short NO_DATA_ALLOWED_ERR = 6 ; public static final short NO_MODIFICATION_ALLOWED_ERR = 7 ; public static final short NOT_FOUND_ERR = 8 ; public static final short NOT_SUPPORTED_ERR = 9 ; public static final short INUSE_ATTRIBUTE_ERR = 10 ; public static final short INVALID_STATE_ERR = 11 ; public static final short SYNTAX_ERR = 12 ; public static final short INVALID_MODIFICATION_ERR = 13 ; public static final short NAMESPACE_ERR = 14 ; public static final short INVALID_ACCESS_ERR = 15 ; } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DeferredCDATASectionImpl extends CDATASectionImpl implements DeferredNode { static final long serialVersionUID = 1983580632355645726L ; protected transient int fNodeIndex ; DeferredCDATASectionImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; } public int getNodeIndex ( ) { return fNodeIndex ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ( ) ; data = ownerDocument . getNodeValueString ( fNodeIndex ) ; isIgnorableWhitespace ( ownerDocument . getLastChild ( fNodeIndex ) == 1 ) ; } } 	0
package org . w3c . dom . events ; public interface EventTarget { public void addEventListener ( String type , EventListener listener , boolean useCapture ) ; public void removeEventListener ( String type , EventListener listener , boolean useCapture ) ; public boolean dispatchEvent ( Event evt ) throws EventException ; } 	1
package org . apache . xml . serialize ; import java . io . IOException ; import org . w3c . dom . Element ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; public interface DOMSerializer { public void serialize ( Element elem ) throws IOException ; public void serialize ( Document doc ) throws IOException ; public void serialize ( DocumentFragment frag ) throws IOException ; } 	0
package org . w3c . dom ; public interface NodeList { public Node item ( int index ) ; public int getLength ( ) ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLPostfieldElementImpl extends WMLElementImpl implements WMLPostfieldElement { public WMLPostfieldElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setValue ( String newValue ) { setAttribute ( "value" , newValue ) ; } public String getValue ( ) { return getAttribute ( "value" ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setName ( String newValue ) { setAttribute ( "name" , newValue ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } } 	0
package javax . xml . parsers ; public class ParserConfigurationException extends Exception { public ParserConfigurationException ( ) { super ( ) ; } public ParserConfigurationException ( String msg ) { super ( msg ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLQuoteElementImpl extends HTMLElementImpl implements HTMLQuoteElement { public String getCite ( ) { return getAttribute ( "cite" ) ; } public void setCite ( String cite ) { setAttribute ( "cite" , cite ) ; } public HTMLQuoteElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . domx ; public abstract class DOMException extends org . w3c . dom . DOMException { public static final short UNSPECIFIED_EVENT_TYPE = 100 ; public static final short UNSUPPORTED_EVENT_TYPE = 101 ; public DOMException ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . xerces . validators . common ; import org . apache . xerces . utils . QName ; import org . apache . xerces . validators . datatype . DatatypeValidator ; public class XMLAttributeDecl { public static final int TYPE_CDATA = 0 ; public static final int TYPE_ENTITY = 1 ; public static final int TYPE_ENUMERATION = 2 ; public static final int TYPE_ID = 3 ; public static final int TYPE_IDREF = 4 ; public static final int TYPE_NMTOKEN = 5 ; public static final int TYPE_NOTATION = 6 ; public static final int TYPE_SIMPLE = 7 ; public static final int TYPE_ANY_ANY = 8 ; public static final int TYPE_ANY_OTHER = 9 ; public static final int TYPE_ANY_LOCAL = 10 ; public static final int TYPE_ANY_LIST = 11 ; public static final int DEFAULT_TYPE_IMPLIED = 0 ; public static final int DEFAULT_TYPE_FIXED = 1 ; public static final int DEFAULT_TYPE_REQUIRED = 2 ; public static final int DEFAULT_TYPE_DEFAULT = 3 ; public static final int PROCESSCONTENTS_STRICT = 4 ; public static final int PROCESSCONTENTS_LAX = 5 ; public static final int PROCESSCONTENTS_SKIP = 6 ; public QName name = new QName ( ) ; public DatatypeValidator datatypeValidator ; public int type ; public boolean list ; public int enumeration ; public int defaultType ; public String defaultValue ; public XMLAttributeDecl ( ) { clear ( ) ; } public XMLAttributeDecl ( XMLAttributeDecl attributeDecl ) { setValues ( attributeDecl ) ; } public void clear ( ) { name . clear ( ) ; datatypeValidator = null ; type = - 1 ; list = false ; enumeration = - 1 ; defaultType = DEFAULT_TYPE_IMPLIED ; defaultValue = null ; } public void setValues ( XMLAttributeDecl attributeDecl ) { name . setValues ( attributeDecl . name ) ; datatypeValidator = attributeDecl . datatypeValidator ; type = attributeDecl . type ; list = attributeDecl . list ; enumeration = attributeDecl . enumeration ; defaultType = attributeDecl . defaultType ; defaultValue = attributeDecl . defaultValue ; } public int hashCode ( ) { return super . hashCode ( ) ; } public boolean equals ( Object object ) { return super . equals ( object ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrNSImpl extends AttrImpl { static final long serialVersionUID = - 781906615369795414L ; protected String namespaceURI ; protected String localName ; protected AttrNSImpl ( DocumentImpl ownerDocument , String namespaceURI , String qualifiedName ) { super ( ownerDocument , qualifiedName ) ; if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = qualifiedName ; } else { prefix = qualifiedName . substring ( 0 , index ) ; localName = qualifiedName . substring ( index + 1 ) ; } if ( ( prefix != null && ( namespaceURI == null || namespaceURI . equals ( "" ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) || ( prefix . equals ( "xmlns" ) && ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) ) || ( qualifiedName . equals ( "xmlns" ) && ( namespaceURI == null || ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } this . namespaceURI = namespaceURI ; } protected AttrNSImpl ( DocumentImpl ownerDocument , String value ) { super ( ownerDocument , value ) ; } public String getNamespaceURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return namespaceURI ; } public String getPrefix ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int index = name . indexOf ( ':' ) ; return index < 0 ? null : name . substring ( 0 , index ) ; } public void setPrefix ( String prefix ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( namespaceURI == null || ( prefix != null && ( ( prefix . equals ( "xmlns" ) && ! namespaceURI . equals ( "http://www.w3.org/2000/xmlns/" ) ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } if ( ownerDocument . errorChecking && ! DocumentImpl . isXMLName ( prefix ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } name = prefix + ":" + localName ; } public String getLocalName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return localName ; } } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . NoSuchElementException ; import org . apache . xerces . utils . URI ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; public class URIReferenceDatatypeValidator extends AbstractDatatypeValidator { private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; private int fLength = 0 ; private int fMaxLength = Integer . MAX_VALUE ; private int fMinLength = 0 ; private String fPattern = null ; private Vector fEnumeration = null ; private int fFacetsDefined = 0 ; private RegularExpression fRegex = null ; public URIReferenceDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public URIReferenceDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { fDerivedByList = derivedByList ; setBasetype ( base ) ; if ( facets != null ) { if ( fDerivedByList == false ) { for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . equals ( SchemaSymbols . ELT_LENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_LENGTH ; String lengthValue = ( String ) facets . get ( key ) ; try { fLength = Integer . parseInt ( lengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "' is invalid." ) ; } if ( fLength < 0 ) throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "'  must be a nonNegativeInteger." ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MINLENGTH ; String minLengthValue = ( String ) facets . get ( key ) ; try { fMinLength = Integer . parseInt ( minLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + minLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MAXLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXLENGTH ; String maxLengthValue = ( String ) facets . get ( key ) ; try { fMaxLength = Integer . parseInt ( maxLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + maxLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = ( String ) facets . get ( key ) ; if ( fPattern != null ) fRegex = new RegularExpression ( fPattern , "X" ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; fEnumeration = ( Vector ) facets . get ( key ) ; } else { throw new InvalidDatatypeFacetException ( ) ; } } if ( ( ( fFacetsDefined & DatatypeValidator . FACET_LENGTH ) != 0 ) ) { if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MAXLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and maxLength to be members of facets." ) ; } else if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MINLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and minLength to be members of facets." ) ; } } if ( ( ( fFacetsDefined & ( DatatypeValidator . FACET_MINLENGTH | DatatypeValidator . FACET_MAXLENGTH ) ) != 0 ) ) { if ( fMinLength > fMaxLength ) { throw new InvalidDatatypeFacetException ( "Value of maxLength = " + fMaxLength + "must be greater that the value of minLength" + fMinLength ) ; } } } else { for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . equals ( SchemaSymbols . ELT_LENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_LENGTH ; String lengthValue = ( String ) facets . get ( key ) ; try { fLength = Integer . parseInt ( lengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "' is invalid." ) ; } if ( fLength < 0 ) throw new InvalidDatatypeFacetException ( "Length value '" + lengthValue + "'  must be a nonNegativeInteger." ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MINLENGTH ; String minLengthValue = ( String ) facets . get ( key ) ; try { fMinLength = Integer . parseInt ( minLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + minLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MAXLENGTH ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXLENGTH ; String maxLengthValue = ( String ) facets . get ( key ) ; try { fMaxLength = Integer . parseInt ( maxLengthValue ) ; } catch ( NumberFormatException nfe ) { throw new InvalidDatatypeFacetException ( "maxLength value '" + maxLengthValue + "' is invalid." ) ; } } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; fEnumeration = ( Vector ) facets . get ( key ) ; } else { throw new InvalidDatatypeFacetException ( ) ; } } if ( ( ( fFacetsDefined & DatatypeValidator . FACET_LENGTH ) != 0 ) ) { if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MAXLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and maxLength to be members of facets." ) ; } else if ( ( ( fFacetsDefined & DatatypeValidator . FACET_MINLENGTH ) != 0 ) ) { throw new InvalidDatatypeFacetException ( "It is an error for both length and minLength to be members of facets." ) ; } } if ( ( ( fFacetsDefined & ( DatatypeValidator . FACET_MINLENGTH | DatatypeValidator . FACET_MAXLENGTH ) ) != 0 ) ) { if ( fMinLength > fMaxLength ) { throw new InvalidDatatypeFacetException ( "Value of maxLength = " + fMinLength + "must be greater that the value of minLength" + fMaxLength ) ; } } } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { StringTokenizer parsedList = null ; URI uriContent = null ; if ( fDerivedByList == true ) { parsedList = new StringTokenizer ( content ) ; try { while ( parsedList . hasMoreTokens ( ) ) { } } catch ( NoSuchElementException e ) { e . printStackTrace ( ) ; } } else { if ( ( fFacetsDefined & DatatypeValidator . FACET_PATTERN ) != 0 ) { if ( fRegex == null || fRegex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value '" + content + "' does not match regular expression facet" + fPattern ) ; } try { uriContent = new URI ( content ) ; } catch ( URI . MalformedURIException ex ) { throw new InvalidDatatypeValueException ( "Value '" + content + "' is a Malformed URI " ) ; } } return null ; } public int compare ( String content1 , String content2 ) { return 0 ; } public Hashtable getFacets ( ) { return null ; } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } } 	0
package org . apache . xerces . jaxp ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . xml . sax . SAXException ; public class SAXParserFactoryImpl extends SAXParserFactory { public SAXParserFactoryImpl ( ) { super ( ) ; } public SAXParser newSAXParser ( ) throws ParserConfigurationException { return ( new SAXParserImpl ( this . isNamespaceAware ( ) , this . isValidating ( ) ) ) ; } } 	1
package org . w3c . dom . html ; import org . w3c . dom . Element ; public interface HTMLElement extends Element { public String getId ( ) ; public void setId ( String id ) ; public String getTitle ( ) ; public void setTitle ( String title ) ; public String getLang ( ) ; public void setLang ( String lang ) ; public String getDir ( ) ; public void setDir ( String dir ) ; public String getClassName ( ) ; public void setClassName ( String className ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public class AttributeMap extends NamedNodeMapImpl { protected AttributeMap ( ElementImpl ownerNode , NamedNodeMapImpl defaults ) { super ( ownerNode ) ; if ( defaults != null ) { cloneContent ( defaults ) ; if ( nodes != null ) { hasDefaults ( true ) ; } } } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } NodeImpl argn = ( NodeImpl ) arg ; if ( argn . isOwned ( ) ) { throw new DOMExceptionImpl ( DOMException . INUSE_ATTRIBUTE_ERR , "DOM009 Attribute already in use" ) ; } argn . ownerNode = ownerNode ; argn . isOwned ( true ) ; int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; previous . ownerNode = ownerNode . ownerDocument ( ) ; previous . isOwned ( false ) ; previous . isSpecified ( true ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { ownerNode . dispatchAggregateEvents ( ( AttrImpl ) arg , previous == null ? null : previous . getNodeValue ( ) ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } NodeImpl argn = ( NodeImpl ) arg ; if ( argn . isOwned ( ) ) { throw new DOMExceptionImpl ( DOMException . INUSE_ATTRIBUTE_ERR , "DOM009 Attribute already in use" ) ; } argn . ownerNode = ownerNode ; argn . isOwned ( true ) ; int i = findNamePoint ( argn . getNamespaceURI ( ) , argn . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; previous . ownerNode = ownerNode . ownerDocument ( ) ; previous . isOwned ( false ) ; previous . isSpecified ( true ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { ownerNode . dispatchAggregateEvents ( ( AttrImpl ) arg , previous == null ? null : previous . getNodeValue ( ) ) ; } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { return internalRemoveNamedItem ( name , true ) ; } Node safeRemoveNamedItem ( String name ) { return internalRemoveNamedItem ( name , false ) ; } final protected Node internalRemoveNamedItem ( String name , boolean raiseEx ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { if ( raiseEx ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } else { return null ; } } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; if ( hasDefaults ( ) ) { NamedNodeMapImpl defaults = ( ( ElementImpl ) ownerNode ) . getDefaultAttributes ( ) ; Node d ; if ( defaults != null && ( d = defaults . getNamedItem ( name ) ) != null && findNamePoint ( name , i + 1 ) < 0 ) { NodeImpl clone = ( NodeImpl ) d . cloneNode ( true ) ; clone . ownerNode = ownerNode ; clone . isOwned ( true ) ; clone . isSpecified ( false ) ; nodes . setElementAt ( clone , i ) ; } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } n . ownerNode = ownerNode . ownerDocument ( ) ; n . isOwned ( false ) ; n . isSpecified ( true ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { return internalRemoveNamedItemNS ( namespaceURI , name , true ) ; } Node safeRemoveNamedItemNS ( String namespaceURI , String name ) { return internalRemoveNamedItemNS ( namespaceURI , name , false ) ; } final protected Node internalRemoveNamedItemNS ( String namespaceURI , String name , boolean raiseEx ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { if ( raiseEx ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } else { return null ; } } LCount lc = null ; String oldvalue = "" ; AttrImpl enclosingAttribute = null ; if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttribute = ( AttrImpl ) ( nodes . elementAt ( i ) ) ; oldvalue = enclosingAttribute . getNodeValue ( ) ; } } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; String nodeName = n . getNodeName ( ) ; if ( hasDefaults ( ) ) { NamedNodeMapImpl defaults = ( ( ElementImpl ) ownerNode ) . getDefaultAttributes ( ) ; Node d ; if ( defaults != null && ( d = defaults . getNamedItem ( nodeName ) ) != null ) { int j = findNamePoint ( nodeName , 0 ) ; if ( j >= 0 && findNamePoint ( nodeName , j + 1 ) < 0 ) { NodeImpl clone = ( NodeImpl ) d . cloneNode ( true ) ; clone . ownerNode = ownerNode ; clone . isOwned ( true ) ; clone . isSpecified ( false ) ; nodes . setElementAt ( clone , i ) ; } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } } else { nodes . removeElementAt ( i ) ; } n . ownerNode = ownerNode . ownerDocument ( ) ; n . isOwned ( false ) ; n . isSpecified ( true ) ; if ( NodeImpl . MUTATIONEVENTS && ownerNode . ownerDocument ( ) . mutationEvents ) { if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_ATTR_MODIFIED , true , false , null , n . getNodeValue ( ) , ( ( ElementImpl ) ownerNode ) . getAttribute ( name ) , name ) ; ownerNode . dispatchEvent ( me ) ; } ownerNode . dispatchAggregateEvents ( null , null ) ; } return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { AttributeMap newmap = new AttributeMap ( ( ElementImpl ) ownerNode , null ) ; newmap . hasDefaults ( hasDefaults ( ) ) ; newmap . cloneContent ( this ) ; return newmap ; } } 	1
package org . xml . sax ; import java . io . IOException ; import java . util . Locale ; public interface Parser { public abstract void setLocale ( Locale locale ) throws SAXException ; public abstract void setEntityResolver ( EntityResolver resolver ) ; public abstract void setDTDHandler ( DTDHandler handler ) ; public abstract void setDocumentHandler ( DocumentHandler handler ) ; public abstract void setErrorHandler ( ErrorHandler handler ) ; public abstract void parse ( InputSource source ) throws SAXException , IOException ; public abstract void parse ( String systemId ) throws SAXException , IOException ; } 	0
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . w3c . dom . Document ; public abstract class DocumentBuilder { protected DocumentBuilder ( ) { super ( ) ; } public Document parse ( InputStream stream ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( stream ) ) ) ; } public Document parse ( String uri ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( uri ) ) ) ; } public Document parse ( File file ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; return ( this . parse ( new InputSource ( file . getName ( ) ) ) ) ; } public abstract Document parse ( InputSource source ) throws SAXException , IOException , IllegalArgumentException ; public abstract Document newDocument ( ) ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; public abstract void setEntityResolver ( EntityResolver er ) ; public abstract void setErrorHandler ( ErrorHandler eh ) ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; import org . w3c . dom . * ; import org . apache . xerces . dom . * ; public class WMLDOMImplementationImpl extends DOMImplementationImpl implements WMLDOMImplementation { static DOMImplementationImpl singleton = new WMLDOMImplementationImpl ( ) ; public static DOMImplementation getDOMImplementation ( ) { return singleton ; } public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException { DocumentImpl doc = new WMLDocumentImpl ( doctype ) ; Element e = doc . createElementNS ( namespaceURI , qualifiedName ) ; doc . appendChild ( e ) ; return doc ; } } 	0
package org . apache . xerces . dom . events ; import org . apache . xerces . dom . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; public class MutationEventImpl extends org . apache . xerces . dom . events . EventImpl implements MutationEvent { Node relatedNode = null ; String prevValue = null , newValue = null , attrName = null ; public static final String DOM_SUBTREE_MODIFIED = "DOMSubtreeModified" ; public static final String DOM_NODE_INSERTED = "DOMNodeInserted" ; public static final String DOM_NODE_REMOVED = "DOMNodeRemoved" ; public static final String DOM_NODE_REMOVED_FROM_DOCUMENT = "DOMNodeRemovedFromDocument" ; public static final String DOM_NODE_INSERTED_INTO_DOCUMENT = "DOMNodeInsertedIntoDocument" ; public static final String DOM_ATTR_MODIFIED = "DOMAttrModified" ; public static final String DOM_CHARACTER_DATA_MODIFIED = "DOMCharacterDataModified" ; public String getAttrName ( ) { return attrName ; } public String getNewValue ( ) { return newValue ; } public String getPrevValue ( ) { return prevValue ; } public Node getRelatedNode ( ) { return relatedNode ; } public void initMutationEvent ( String typeArg , boolean canBubbleArg , boolean cancelableArg , Node relatedNodeArg , String prevValueArg , String newValueArg , String attrNameArg ) { relatedNode = relatedNodeArg ; prevValue = prevValueArg ; newValue = newValueArg ; attrName = attrNameArg ; super . initEvent ( typeArg , canBubbleArg , cancelableArg ) ; } } 	1
package org . w3c . dom . html ; public interface HTMLDirectoryElement extends HTMLElement { public boolean getCompact ( ) ; public void setCompact ( boolean compact ) ; } 	0
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . SymbolCache ; import org . apache . xerces . utils . UTF8DataChunk ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . LocatorImpl ; import java . io . InputStream ; import java . util . Vector ; final class UTF8Reader extends XMLEntityReader { private final static boolean USE_OUT_OF_LINE_LOAD_NEXT_BYTE = false ; private final static boolean USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE = true ; public UTF8Reader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , InputStream dataStream , StringPool stringPool ) throws Exception { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fInputStream = dataStream ; fStringPool = stringPool ; fCharArrayRange = fStringPool . createCharArrayRange ( ) ; fCurrentChunk = UTF8DataChunk . createChunk ( fStringPool , null ) ; fillCurrentChunk ( ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } private int addSymbol ( int offset , int length , int hashcode ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , hashcode ) ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } private int slowLoadNextByte ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; return ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } else { fCurrentChunk = UTF8DataChunk . createChunk ( fStringPool , fCurrentChunk ) ; return fillCurrentChunk ( ) ; } } private int loadNextByte ( ) throws Exception { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; return fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { return slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) return slowLoadNextByte ( ) ; else return ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; fMostRecentData = null ; fMostRecentByte = 0 ; return nextReader ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) throws Exception { int b0 = fMostRecentByte ; if ( b0 != ch ) { if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( ch , skipPastChar ) ; } } if ( ch == 0x0A && b0 == 0x0D ) { if ( skipPastChar ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; b0 = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == 0x0A ) { fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } } return true ; } return false ; } if ( ch == 0x0D ) return false ; if ( skipPastChar ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int b0 = fMostRecentByte ; if ( b0 < 0x80 ) { if ( b0 >= 0x20 || b0 == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } if ( b0 == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } return true ; } if ( b0 == 0x0D ) { if ( skipPastChar ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; b0 = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == 0x0A ) { fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } } } return true ; } if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; } return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { boolean result = false ; if ( ! ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; return true ; } result = true ; } fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } int b3 = loadNextByte ( ) ; boolean result = false ; if ( ( ( b0 & 0xf8 ) == 0xf0 ) && ( ( b1 & 0xc0 ) == 0x80 ) && ( ( b2 & 0xc0 ) == 0x80 ) && ( ( b3 & 0xc0 ) == 0x80 ) ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextByte ( ) ; return true ; } result = true ; fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return result ; } } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentByte ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { if ( ! skipPastChar ) return true ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) return true ; fLinefeedCounter ++ ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return true ; } public void skipToChar ( char ch ) throws Exception { int b0 = fMostRecentByte ; while ( true ) { if ( b0 == ch ) return ; if ( b0 == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( ch ) ; return ; } fCharacterCounter ++ ; } else if ( b0 == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( b0 == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; if ( b0 != 0x0A ) continue ; fLinefeedCounter ++ ; } else if ( b0 < 0x80 ) { fCharacterCounter ++ ; } else { fCharacterCounter ++ ; if ( ( 0xe0 & b0 ) == 0xc0 ) { loadNextByte ( ) ; } else if ( ( 0xf0 & b0 ) == 0xe0 ) { loadNextByte ( ) ; loadNextByte ( ) ; } else { loadNextByte ( ) ; loadNextByte ( ) ; loadNextByte ( ) ; } } b0 = loadNextByte ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentByte ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) continue ; fLinefeedCounter ++ ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; ch = fMostRecentByte ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } } protected boolean skippedMultiByteCharWithFlag ( int b0 , int flag ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { if ( ( XMLCharacterProperties . fgCharFlags [ ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ] & flag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } if ( ( XMLCharacterProperties . fgCharFlags [ ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ] & flag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } return true ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } public void skipPastName ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ b0 ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_InitialNameCharFlag ) ) return ; } while ( true ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( fastcheck == b0 ) return ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_NameCharFlag ) ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; while ( true ) { if ( fastcheck == b0 ) return ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) return ; } else { if ( ! skippedMultiByteCharWithFlag ( b0 , XMLCharacterProperties . E_NameCharFlag ) ) return ; } fCharacterCounter ++ ; b0 = loadNextByte ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int length = s . length ; byte [ ] data = fMostRecentData ; int index = fCurrentIndex + length ; int sindex = length ; try { while ( sindex -- > 0 ) { if ( data [ -- index ] != s [ sindex ] ) return false ; } fCurrentIndex += length ; } catch ( ArrayIndexOutOfBoundsException ex ) { int i = 0 ; index = fCurrentIndex ; while ( index < UTF8DataChunk . CHUNK_SIZE ) { if ( data [ index ++ ] != s [ i ++ ] ) return false ; } UTF8DataChunk dataChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; int savedIndex = fCurrentIndex ; slowLoadNextByte ( ) ; data = fMostRecentData ; index = 0 ; while ( i < length ) { if ( data [ index ++ ] != s [ i ++ ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; return false ; } } fCurrentIndex = index ; } fCharacterCounter += length ; fCurrentOffset += length ; try { fMostRecentByte = data [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } return true ; } public int scanInvalidChar ( ) throws Exception { int b0 = fMostRecentByte ; int ch = b0 ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; if ( ch != 0x0A ) return 0x0A ; fLinefeedCounter ++ ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } fCharacterCounter ++ ; } else if ( b0 >= 0x80 ) { fCharacterCounter ++ ; int b1 = loadNextByte ( ) ; int b2 = 0 ; if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; } else if ( ( 0xf0 & b0 ) == 0xe0 ) { b2 = loadNextByte ( ) ; ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; } else if ( ( 0xf8 & b0 ) == 0xf0 ) { b2 = loadNextByte ( ) ; int b3 = loadNextByte ( ) ; ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; } } loadNextByte ( ) ; return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentByte ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextByte ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentByte ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextByte ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextByte ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = fCurrentChunk . addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public static final byte fgAsciiAttValueChar [ ] = { 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 2 , 2 , 4 , 4 , 2 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 0 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; int b0 = fMostRecentByte ; while ( true ) { if ( b0 < 0x80 ) { switch ( fgAsciiAttValueChar [ b0 ] ) { case 1 : if ( b0 == qchar ) { int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : ( asSymbol ? fCurrentChunk . addSymbol ( offset , length , 0 ) : fCurrentChunk . addString ( offset , length ) ) ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return result ; } case 0 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 2 : return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; case 3 : return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; case 4 : return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( b0 ) ) return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; b0 = fMostRecentByte ; } } } public static final byte fgAsciiEntityValueChar [ ] = { 7 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 5 , 4 , 4 , 6 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 3 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; int b0 = fMostRecentByte ; while ( true ) { if ( b0 < 0x80 ) { switch ( fgAsciiEntityValueChar [ b0 ] ) { case 1 : if ( b0 == qchar ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : fCurrentChunk . addString ( offset , length ) ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return result ; } case 0 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 5 : fLinefeedCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 6 : fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 != 0x0A ) { continue ; } fLinefeedCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } continue ; case 2 : return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; case 3 : return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; case 7 : if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } case 4 : return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( b0 ) ) return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; b0 = fMostRecentByte ; } } } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int b0 = fMostRecentByte ; int ch = 0 ; int i = 0 ; while ( true ) { if ( b0 < 0x80 ) { ch = b0 ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } } else { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; skipPastNmtoken ( fastcheck ) ; return false ; } } else { int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( i == len ) break ; if ( ch != expected [ offset ] ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; skipPastNmtoken ( fastcheck ) ; return false ; } } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } } i ++ ; offset ++ ; fCharacterCounter ++ ; fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentByte ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; int index = fCurrentIndex ; byte [ ] data = fMostRecentData ; int prefixend = - 1 ; while ( true ) { fCharacterCounter ++ ; fCurrentOffset ++ ; index ++ ; try { ch = data [ index ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; index = 0 ; data = fMostRecentData ; } if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; try { ch = data [ index + 1 ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { UTF8DataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; ch = slowLoadNextByte ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; } boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; break ; } } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } } fCurrentIndex = index ; fMostRecentByte = ch ; int length = fCurrentOffset - offset ; qname . rawname = addSymbol ( offset , length ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } private int getMultiByteSymbolChar ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } loadNextByte ( ) ; return ch ; } int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } loadNextByte ( ) ; return ch ; } fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } public int scanName ( char fastcheck ) throws Exception { int b0 = fMostRecentByte ; int ch ; if ( b0 < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ b0 ] == 0 ) { if ( b0 == 0 && atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanName ( fastcheck ) ; } return - 1 ; } ch = b0 ; } else { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int b1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b1 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b1 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b1 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b1 = slowLoadNextByte ( ) ; else b1 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xe0 & b0 ) == 0xc0 ) { ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } else { int b2 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b2 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b2 = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b2 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b2 = slowLoadNextByte ( ) ; else b2 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return - 1 ; } } } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return scanMatchingName ( ch , b0 , fastcheck ) ; } private int scanMatchingName ( int ch , int b0 , int fastcheck ) throws Exception { SymbolCache cache = fStringPool . getSymbolCache ( ) ; int [ ] [ ] cacheLines = cache . fCacheLines ; char [ ] symbolChars = cache . fSymbolChars ; boolean lengthOfOne = fastcheck == fMostRecentByte ; int startOffset = cache . fSymbolCharsOffset ; int entry = 0 ; int [ ] entries = cacheLines [ entry ] ; int offset = 1 + ( ( entries [ 0 ] - 1 ) * SymbolCache . CACHE_RECORD_SIZE ) ; int totalMisses = 0 ; if ( lengthOfOne ) { while ( offset > 0 ) { if ( entries [ offset + SymbolCache . CHAR_OFFSET ] == ch ) { if ( entries [ offset + SymbolCache . INDEX_OFFSET ] != - 1 ) { int symbolIndex = entries [ offset + SymbolCache . INDEX_OFFSET ] ; if ( totalMisses > 3 ) fStringPool . updateCacheLine ( symbolIndex , totalMisses , 1 ) ; return symbolIndex ; } break ; } offset -= SymbolCache . CACHE_RECORD_SIZE ; totalMisses ++ ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; if ( offset < 0 ) { offset = 1 + ( entries [ 0 ] * SymbolCache . CACHE_RECORD_SIZE ) ; entries [ 0 ] ++ ; try { entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; entries = new int [ newSize ] ; System . arraycopy ( cacheLines [ entry ] , 0 , entries , 0 , offset ) ; cacheLines [ entry ] = entries ; entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } entries [ offset + SymbolCache . NEXT_OFFSET ] = - 1 ; } int result = fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; return result ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; int depth = 1 ; while ( true ) { if ( offset < 0 ) break ; if ( entries [ offset + SymbolCache . CHAR_OFFSET ] != ch ) { offset -= SymbolCache . CACHE_RECORD_SIZE ; totalMisses ++ ; continue ; } if ( b0 >= 0x80 ) { ch = getMultiByteSymbolChar ( b0 ) ; b0 = fMostRecentByte ; } else if ( b0 == fastcheck || XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) { ch = - 1 ; } else { ch = b0 ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } if ( ch == - 1 ) { if ( entries [ offset + SymbolCache . INDEX_OFFSET ] == - 1 ) { return fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; } cache . fSymbolCharsOffset = startOffset ; int symbolIndex = entries [ offset + SymbolCache . INDEX_OFFSET ] ; if ( totalMisses > ( depth * 3 ) ) fStringPool . updateCacheLine ( symbolIndex , totalMisses , depth ) ; return symbolIndex ; } try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; entry = entries [ offset + SymbolCache . NEXT_OFFSET ] ; try { entries = cacheLines [ entry ] ; } catch ( ArrayIndexOutOfBoundsException ex ) { if ( entry == - 1 ) { entry = cache . fCacheLineCount ++ ; entries [ offset + SymbolCache . NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( SymbolCache . INITIAL_CACHE_RECORD_COUNT * SymbolCache . CACHE_RECORD_SIZE ) ] ; try { cacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex2 ) { cacheLines = new int [ entry * 2 ] [ ] ; System . arraycopy ( cache . fCacheLines , 0 , cacheLines , 0 , entry ) ; cache . fCacheLines = cacheLines ; cacheLines [ entry ] = entries ; } } else { entries = cacheLines [ entry ] ; throw new RuntimeException ( "RDR001 untested" ) ; } } offset = 1 + ( ( entries [ 0 ] - 1 ) * SymbolCache . CACHE_RECORD_SIZE ) ; depth ++ ; } if ( offset < 0 ) offset = 1 + ( entries [ 0 ] * SymbolCache . CACHE_RECORD_SIZE ) ; while ( true ) { entries [ 0 ] ++ ; try { entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { int newSize = 1 + ( ( offset - 1 ) * 2 ) ; entries = new int [ newSize ] ; System . arraycopy ( cacheLines [ entry ] , 0 , entries , 0 , offset ) ; cacheLines [ entry ] = entries ; entries [ offset + SymbolCache . CHAR_OFFSET ] = ch ; } if ( b0 >= 0x80 ) { ch = getMultiByteSymbolChar ( b0 ) ; b0 = fMostRecentByte ; } else if ( b0 == fastcheck || XMLCharacterProperties . fgAsciiNameChar [ b0 ] == 0 ) { ch = - 1 ; } else { ch = b0 ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } if ( ch == - 1 ) { entries [ offset + SymbolCache . NEXT_OFFSET ] = - 1 ; break ; } entry = cache . fCacheLineCount ++ ; entries [ offset + SymbolCache . INDEX_OFFSET ] = - 1 ; entries [ offset + SymbolCache . NEXT_OFFSET ] = entry ; entries = new int [ 1 + ( SymbolCache . INITIAL_CACHE_RECORD_COUNT * SymbolCache . CACHE_RECORD_SIZE ) ] ; try { cacheLines [ entry ] = entries ; } catch ( ArrayIndexOutOfBoundsException ex ) { cacheLines = new int [ entry * 2 ] [ ] ; System . arraycopy ( cache . fCacheLines , 0 , cacheLines , 0 , entry ) ; cache . fCacheLines = cacheLines ; cacheLines [ entry ] = entries ; } offset = 1 ; try { symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } catch ( ArrayIndexOutOfBoundsException ex ) { symbolChars = new char [ cache . fSymbolCharsOffset * 2 ] ; System . arraycopy ( cache . fSymbolChars , 0 , symbolChars , 0 , cache . fSymbolCharsOffset ) ; cache . fSymbolChars = symbolChars ; symbolChars [ cache . fSymbolCharsOffset ] = ( char ) ch ; } cache . fSymbolCharsOffset ++ ; } int result = fStringPool . createNonMatchingSymbol ( startOffset , entry , entries , offset ) ; return result ; } private int recognizeMarkup ( int b0 , QName element ) throws Exception { switch ( b0 ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 == '-' ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 == '-' ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( b0 == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; if ( b0 == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( b0 != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } int expectedName = element . rawname ; fStringPool . getCharArrayRange ( expectedName , fCharArrayRange ) ; char [ ] expected = fCharArrayRange . chars ; int offset = fCharArrayRange . offset ; int len = fCharArrayRange . length ; if ( b0 == expected [ offset ++ ] ) { UTF8DataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; for ( int i = 1 ; i < len ; i ++ ) { if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 != expected [ offset ++ ] ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; } } fCharacterCounter += len ; fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { b0 = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { b0 = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) b0 = slowLoadNextByte ( ) ; else b0 = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( b0 == '>' ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG ; } while ( b0 == 0x20 || b0 == 0x09 || b0 == 0x0A || b0 == 0x0D ) { if ( b0 == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; } else if ( b0 == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; b0 = loadNextByte ( ) ; if ( b0 == 0x0A ) { fLinefeedCounter ++ ; b0 = loadNextByte ( ) ; } } else { fCharacterCounter ++ ; b0 = loadNextByte ( ) ; } if ( b0 == '>' ) { fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) slowLoadNextByte ( ) ; else fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ; } } return XMLEntityHandler . CONTENT_RESULT_MATCHING_ETAG ; } } fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = fMostRecentData [ savedIndex ] & 0xFF ; } return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextByte ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; fCharDataLength = 0 ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentByte ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } break ; case 1 : fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ! fInCDSect ) { return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; break ; case 2 : fCharacterCounter ++ ; ch = loadNextByte ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; break ; case 3 : fCharacterCounter ++ ; ch = loadNextByte ( ) ; if ( ch != ']' ) { if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } if ( ch != 0x0A ) { if ( fSendCharDataAsCharArray ) appendCharData ( 0x0A ) ; if ( ch == 0x20 || ch == 0x09 || ch == 0x0D ) continue ; break ; } fLinefeedCounter ++ ; } else { fCharacterCounter ++ ; } if ( fSendCharDataAsCharArray ) { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A || ch == 0x0D ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 1 : if ( ! fInCDSect ) { if ( fSendCharDataAsCharArray ) { fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = addString ( charDataOffset , fCurrentOffset - charDataOffset ) ; fCharDataHandler . processWhitespace ( stringIndex ) ; } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 2 : if ( ! fInCDSect ) { whitespace ( charDataOffset , fCurrentOffset ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextByte ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; whitespace ( charDataOffset , endOffset ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : whitespace ( charDataOffset , fCurrentOffset ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { whitespace ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { whitespace ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } break ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } } if ( fSendCharDataAsCharArray ) ch = copyAsciiCharData ( ) ; else ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 1 : if ( ! fInCDSect ) { if ( fSendCharDataAsCharArray ) { fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = addString ( charDataOffset , fCurrentOffset - charDataOffset ) ; fCharDataHandler . processCharacters ( stringIndex ) ; } fCharacterCounter ++ ; if ( USE_OUT_OF_LINE_LOAD_NEXT_BYTE ) { ch = loadNextByte ( ) ; } else { fCurrentOffset ++ ; if ( USE_TRY_CATCH_FOR_LOAD_NEXT_BYTE ) { fCurrentIndex ++ ; try { ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { ch = slowLoadNextByte ( ) ; } } else { if ( ++ fCurrentIndex == UTF8DataChunk . CHUNK_SIZE ) ch = slowLoadNextByte ( ) ; else ch = ( fMostRecentByte = fMostRecentData [ fCurrentIndex ] & 0xFF ) ; } } return recognizeMarkup ( ch , element ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '<' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 2 : if ( ! fInCDSect ) { characters ( charDataOffset , fCurrentOffset ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; return recognizeReference ( ch ) ; } if ( fSendCharDataAsCharArray ) appendCharData ( '&' ) ; fCharacterCounter ++ ; ch = loadNextByte ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextByte ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } if ( fCurrentIndex + 1 == UTF8DataChunk . CHUNK_SIZE ) { UTF8DataChunk saveChunk = fCurrentChunk ; int saveIndex = fCurrentIndex ; int saveOffset = fCurrentOffset ; if ( loadNextByte ( ) != '>' ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = fCurrentChunk . toByteArray ( ) ; fMostRecentByte = ']' ; fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; if ( fSendCharDataAsCharArray ) appendCharData ( ']' ) ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextByte ( ) ; characters ( charDataOffset , endOffset ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { if ( fSendCharDataAsCharArray ) appendCharData ( ch ) ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; break ; } if ( ch == 0x0D ) { if ( fSendCharDataAsCharArray ) appendCharData ( 0x0A ) ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; ch = loadNextByte ( ) ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; ch = loadNextByte ( ) ; } break ; } characters ( charDataOffset , fCurrentOffset ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( fSendCharDataAsCharArray ) { if ( ! copyMultiByteCharData ( ch ) ) { characters ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { characters ( charDataOffset , fCurrentOffset ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentByte ; } } } private boolean copyMultiByteCharData ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { int ch = ( ( 0x1f & b0 ) << 6 ) + ( 0x3f & b1 ) ; appendCharData ( ch ) ; loadNextByte ( ) ; return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } int ch = ( ( 0x0f & b0 ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; appendCharData ( ch ) ; loadNextByte ( ) ; return true ; } int b3 = loadNextByte ( ) ; if ( ( 0xf8 & b0 ) == 0xf0 ) { if ( b0 > 0xF4 || ( b0 == 0xF4 && b1 >= 0x90 ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } int ch = ( ( 0x0f & b0 ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; if ( ch < 0x10000 ) { appendCharData ( ch ) ; } else { appendCharData ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; appendCharData ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; } loadNextByte ( ) ; return true ; } else { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } } private boolean skipMultiByteCharData ( int b0 ) throws Exception { UTF8DataChunk saveChunk = fCurrentChunk ; int saveOffset = fCurrentOffset ; int saveIndex = fCurrentIndex ; int b1 = loadNextByte ( ) ; if ( ( 0xe0 & b0 ) == 0xc0 ) { loadNextByte ( ) ; return true ; } int b2 = loadNextByte ( ) ; if ( ( 0xf0 & b0 ) == 0xe0 ) { if ( ( b0 == 0xED && b1 >= 0xA0 ) || ( b0 == 0xEF && b1 == 0xBF && b2 >= 0xBE ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } loadNextByte ( ) ; return true ; } int b3 = loadNextByte ( ) ; if ( b0 > 0xF4 || ( b0 == 0xF4 && b1 >= 0x90 ) ) { fCurrentChunk = saveChunk ; fCurrentIndex = saveIndex ; fCurrentOffset = saveOffset ; fMostRecentData = saveChunk . toByteArray ( ) ; fMostRecentByte = b0 ; return false ; } loadNextByte ( ) ; return true ; } private int copyAsciiCharData ( ) throws Exception { int srcIndex = fCurrentIndex ; int offset = fCurrentOffset - srcIndex ; byte [ ] data = fMostRecentData ; int dstIndex = fCharDataLength ; boolean skiplf = false ; while ( true ) { int ch ; try { ch = data [ srcIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { offset += srcIndex ; slowLoadNextByte ( ) ; srcIndex = 0 ; data = fMostRecentData ; ch = data [ srcIndex ] & 0xFF ; } if ( ch >= 0x80 ) { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; skiplf = false ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; if ( skiplf ) { skiplf = false ; srcIndex ++ ; continue ; } fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; skiplf = true ; ch = 0x0A ; } else { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } srcIndex ++ ; try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } } private int skipAsciiCharData ( ) throws Exception { int srcIndex = fCurrentIndex ; int offset = fCurrentOffset - srcIndex ; byte [ ] data = fMostRecentData ; while ( true ) { int ch ; try { ch = data [ srcIndex ] & 0xFF ; } catch ( ArrayIndexOutOfBoundsException ex ) { offset += srcIndex ; slowLoadNextByte ( ) ; srcIndex = 0 ; data = fMostRecentData ; ch = data [ srcIndex ] & 0xFF ; } if ( ch >= 0x80 ) { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else { fCurrentOffset = offset + srcIndex ; fCurrentIndex = srcIndex ; fMostRecentByte = ch ; return ch ; } srcIndex ++ ; } } private char [ ] fCharacters = new char [ UTF8DataChunk . CHUNK_SIZE ] ; private int fCharDataLength = 0 ; private void appendCharData ( int ch ) throws Exception { try { fCharacters [ fCharDataLength ] = ( char ) ch ; fCharDataLength ++ ; } catch ( ArrayIndexOutOfBoundsException ex ) { slowAppendCharData ( ch ) ; } } private void slowAppendCharData ( int ch ) throws Exception { characters ( 0 , fCharDataLength ) ; fCharDataLength = 0 ; fCharacters [ fCharDataLength ++ ] = ( char ) ch ; } private void characters ( int offset , int endOffset ) throws Exception { if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , endOffset - offset ) ; fCharDataHandler . processCharacters ( stringIndex ) ; return ; } fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } private void whitespace ( int offset , int endOffset ) throws Exception { if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , endOffset - offset ) ; fCharDataHandler . processWhitespace ( stringIndex ) ; return ; } fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool . CharArrayRange fCharArrayRange = null ; private InputStream fInputStream = null ; private StringPool fStringPool = null ; private UTF8DataChunk fCurrentChunk = null ; private int fCurrentIndex = 0 ; private byte [ ] fMostRecentData = null ; private int fMostRecentByte = 0 ; private int fLength = 0 ; private boolean fCalledCharPropInit = false ; private boolean fCallClearPreviousChunk = true ; private int fillCurrentChunk ( ) throws Exception { byte [ ] buf = fCurrentChunk . toByteArray ( ) ; if ( fInputStream == null ) { if ( buf == null ) buf = new byte [ 1 ] ; buf [ 0 ] = 0 ; fMostRecentData = buf ; fCurrentIndex = 0 ; fCurrentChunk . setByteArray ( fMostRecentData ) ; return ( fMostRecentByte = fMostRecentData [ 0 ] & 0xFF ) ; } if ( buf == null ) buf = new byte [ UTF8DataChunk . CHUNK_SIZE ] ; int offset = 0 ; int capacity = UTF8DataChunk . CHUNK_SIZE ; int result = 0 ; do { try { result = fInputStream . read ( buf , offset , capacity ) ; } catch ( java . io . IOException ex ) { result = - 1 ; } if ( result == - 1 ) { fInputStream . close ( ) ; fInputStream = null ; try { buf [ offset ] = 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { } break ; } if ( result > 0 ) { offset += result ; capacity -= result ; } } while ( capacity > 0 ) ; fMostRecentData = buf ; fLength += offset ; fCurrentIndex = 0 ; fCurrentChunk . setByteArray ( fMostRecentData ) ; return ( fMostRecentByte = fMostRecentData [ 0 ] & 0xFF ) ; } } 	1
package org . apache . xerces . utils . regex ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; import java . util . Vector ; class RegexParser { static final int T_CHAR = 0 ; static final int T_EOF = 1 ; static final int T_OR = 2 ; static final int T_STAR = 3 ; static final int T_PLUS = 4 ; static final int T_QUESTION = 5 ; static final int T_LPAREN = 6 ; static final int T_RPAREN = 7 ; static final int T_DOT = 8 ; static final int T_LBRACKET = 9 ; static final int T_BACKSOLIDUS = 10 ; static final int T_CARET = 11 ; static final int T_DOLLAR = 12 ; static final int T_LPAREN2 = 13 ; static final int T_LOOKAHEAD = 14 ; static final int T_NEGATIVELOOKAHEAD = 15 ; static final int T_LOOKBEHIND = 16 ; static final int T_NEGATIVELOOKBEHIND = 17 ; static final int T_INDEPENDENT = 18 ; static final int T_SET_OPERATIONS = 19 ; static final int T_POSIX_CHARCLASS_START = 20 ; static final int T_COMMENT = 21 ; static final int T_MODIFIERS = 22 ; static final int T_CONDITION = 23 ; static final int T_XMLSCHEMA_CC_SUBTRACTION = 24 ; static class ReferencePosition { int refNumber ; int position ; ReferencePosition ( int n , int pos ) { this . refNumber = n ; this . position = pos ; } } int offset ; String regex ; int regexlen ; int options ; ResourceBundle resources ; int chardata ; int nexttoken ; static protected final int S_NORMAL = 0 ; static protected final int S_INBRACKETS = 1 ; static protected final int S_INXBRACKETS = 2 ; int context = S_NORMAL ; int parennumber = 1 ; boolean hasBackReferences ; Vector references = null ; public RegexParser ( ) { } public RegexParser ( Locale locale ) { } public void setLocale ( Locale locale ) { try { this . resources = ResourceBundle . getBundle ( "org.apache.xerces.utils.regex.message" , locale ) ; } catch ( MissingResourceException mre ) { throw new RuntimeException ( "Installation Problem???  Couldn't load messages: " + mre . getMessage ( ) ) ; } } final ParseException ex ( String key , int loc ) { return new ParseException ( this . resources . getString ( key ) , loc ) ; } private final boolean isSet ( int flag ) { return ( this . options & flag ) == flag ; } synchronized Token parse ( String regex , int options ) throws ParseException { this . options = options ; this . offset = 0 ; this . setContext ( S_NORMAL ) ; this . parennumber = 1 ; this . hasBackReferences = false ; this . regex = regex ; if ( this . isSet ( RegularExpression . EXTENDED_COMMENT ) ) this . regex = REUtil . stripExtendedComment ( this . regex ) ; this . regexlen = this . regex . length ( ) ; this . next ( ) ; Token ret = this . parseRegex ( ) ; if ( this . offset != this . regexlen ) throw ex ( "parser.parse.1" , this . offset ) ; if ( this . references != null ) { for ( int i = 0 ; i < this . references . size ( ) ; i ++ ) { ReferencePosition position = ( ReferencePosition ) this . references . elementAt ( i ) ; if ( this . parennumber <= position . refNumber ) throw ex ( "parser.parse.2" , position . position ) ; } this . references . removeAllElements ( ) ; } return ret ; } protected final void setContext ( int con ) { this . context = con ; } final int read ( ) { return this . nexttoken ; } final void next ( ) { if ( this . offset >= this . regexlen ) { this . chardata = - 1 ; this . nexttoken = T_EOF ; return ; } int ret ; int ch = this . regex . charAt ( this . offset ++ ) ; this . chardata = ch ; if ( this . context == S_INBRACKETS ) { switch ( ch ) { case '\\' : ret = T_BACKSOLIDUS ; if ( this . offset >= this . regexlen ) throw ex ( "parser.next.1" , this . offset - 1 ) ; this . chardata = this . regex . charAt ( this . offset ++ ) ; break ; case '-' : if ( this . isSet ( RegularExpression . XMLSCHEMA_MODE ) && this . offset < this . regexlen && this . regex . charAt ( this . offset ) == '[' ) { this . offset ++ ; ret = T_XMLSCHEMA_CC_SUBTRACTION ; } else ret = T_CHAR ; break ; case '[' : if ( ! this . isSet ( RegularExpression . XMLSCHEMA_MODE ) && this . offset < this . regexlen && this . regex . charAt ( this . offset ) == ':' ) { this . offset ++ ; ret = T_POSIX_CHARCLASS_START ; break ; } default : if ( REUtil . isHighSurrogate ( ch ) && this . offset < this . regexlen ) { int low = this . regex . charAt ( this . offset ) ; if ( REUtil . isLowSurrogate ( low ) ) { this . chardata = REUtil . composeFromSurrogates ( ch , low ) ; this . offset ++ ; } } ret = T_CHAR ; } this . nexttoken = ret ; return ; } switch ( ch ) { case '|' : ret = T_OR ; break ; case '*' : ret = T_STAR ; break ; case '+' : ret = T_PLUS ; break ; case '?' : ret = T_QUESTION ; break ; case ')' : ret = T_RPAREN ; break ; case '.' : ret = T_DOT ; break ; case '[' : ret = T_LBRACKET ; break ; case '^' : ret = T_CARET ; break ; case '$' : ret = T_DOLLAR ; break ; case '(' : ret = T_LPAREN ; if ( this . offset >= this . regexlen ) break ; if ( this . regex . charAt ( this . offset ) != '?' ) break ; if ( ++ this . offset >= this . regexlen ) throw ex ( "parser.next.2" , this . offset - 1 ) ; ch = this . regex . charAt ( this . offset ++ ) ; switch ( ch ) { case ':' : ret = T_LPAREN2 ; break ; case '=' : ret = T_LOOKAHEAD ; break ; case '!' : ret = T_NEGATIVELOOKAHEAD ; break ; case '[' : ret = T_SET_OPERATIONS ; break ; case '>' : ret = T_INDEPENDENT ; break ; case '<' : if ( this . offset >= this . regexlen ) throw ex ( "parser.next.2" , this . offset - 3 ) ; ch = this . regex . charAt ( this . offset ++ ) ; if ( ch == '=' ) { ret = T_LOOKBEHIND ; } else if ( ch == '!' ) { ret = T_NEGATIVELOOKBEHIND ; } else throw ex ( "parser.next.3" , this . offset - 3 ) ; break ; case '#' : while ( this . offset < this . regexlen ) { ch = this . regex . charAt ( this . offset ++ ) ; if ( ch == ')' ) break ; } if ( ch != ')' ) throw ex ( "parser.next.4" , this . offset - 1 ) ; ret = T_COMMENT ; break ; default : if ( ch == '-' || 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' ) { this . offset -- ; ret = T_MODIFIERS ; break ; } else if ( ch == '(' ) { ret = T_CONDITION ; break ; } throw ex ( "parser.next.2" , this . offset - 2 ) ; } break ; case '\\' : ret = T_BACKSOLIDUS ; if ( this . offset >= this . regexlen ) throw ex ( "parser.next.1" , this . offset - 1 ) ; this . chardata = this . regex . charAt ( this . offset ++ ) ; break ; default : ret = T_CHAR ; if ( REUtil . isHighSurrogate ( this . chardata ) && this . offset < this . regexlen ) this . chardata = REUtil . composeFromSurrogates ( this . chardata , this . regex . charAt ( this . offset ++ ) ) ; } this . nexttoken = ret ; } Token parseRegex ( ) throws ParseException { Token tok = this . parseTerm ( ) ; Token parent = null ; while ( this . read ( ) == T_OR ) { this . next ( ) ; if ( parent == null ) { parent = Token . createUnion ( ) ; parent . addChild ( tok ) ; tok = parent ; } tok . addChild ( this . parseTerm ( ) ) ; } return tok ; } Token parseTerm ( ) throws ParseException { int ch = this . read ( ) ; if ( ch == T_OR || ch == T_RPAREN || ch == T_EOF ) { return Token . createEmpty ( ) ; } else { Token tok = this . parseFactor ( ) ; Token concat = null ; while ( ( ch = this . read ( ) ) != T_OR && ch != T_RPAREN && ch != T_EOF ) { if ( concat == null ) { concat = Token . createConcat ( ) ; concat . addChild ( tok ) ; tok = concat ; } concat . addChild ( this . parseFactor ( ) ) ; } return tok ; } } Token processCaret ( ) throws ParseException { this . next ( ) ; return Token . token_linebeginning ; } Token processDollar ( ) throws ParseException { this . next ( ) ; return Token . token_lineend ; } Token processLookahead ( ) throws ParseException { this . next ( ) ; Token tok = Token . createLook ( Token . LOOKAHEAD , this . parseRegex ( ) ) ; if ( this . read ( ) != T_RPAREN ) throw ex ( "parser.factor.1" , this . offset - 1 ) ; this . next ( ) ; return tok ; } Token processNegativelookahead ( ) throws ParseException { this . next ( ) ; Token tok = Token . createLook ( Token . NEGATIVELOOKAHEAD , this . parseRegex ( ) ) ; if ( this . read ( ) != T_RPAREN ) throw ex ( "parser.factor.1" , this . offset - 1 ) ; this . next ( ) ; return tok ; } Token processLookbehind ( ) throws ParseException { this . next ( ) ; Token tok = Token . createLook ( Token . LOOKBEHIND , this . parseRegex ( ) ) ; if ( this . read ( ) != T_RPAREN ) throw ex ( "parser.factor.1" , this . offset - 1 ) ; this . next ( ) ; return tok ; } Token processNegativelookbehind ( ) throws ParseException { this . next ( ) ; Token tok = Token . createLook ( Token . NEGATIVELOOKBEHIND , this . parseRegex ( ) ) ; if ( this . read ( ) != T_RPAREN ) throw ex ( "parser.factor.1" , this . offset - 1 ) ; this . next ( ) ; return tok ; } Token processBacksolidus_A ( ) throws ParseException { this . next ( ) ; return Token . token_stringbeginning ; } Token processBacksolidus_Z ( ) throws ParseException { this . next ( ) ; return Token . token_stringend2 ; } Token processBacksolidus_z ( ) throws ParseException { this . next ( ) ; return Token . token_stringend ; } Token processBacksolidus_b ( ) throws ParseException { this . next ( ) ; return Token . token_wordedge ; } Token processBacksolidus_B ( ) throws ParseException { this . next ( ) ; return Token . token_not_wordedge ; } Token processBacksolidus_lt ( ) throws ParseException { this . next ( ) ; return Token . token_wordbeginning ; } Token processBacksolidus_gt ( ) throws ParseException { this . next ( ) ; return Token . token_wordend ; } Token processStar ( Token tok ) throws ParseException { this . next ( ) ; if ( this . read ( ) == T_QUESTION ) { this . next ( ) ; return Token . createNGClosure ( tok ) ; } else return Token . createClosure ( tok ) ; } Token processPlus ( Token tok ) throws ParseException { this . next ( ) ; if ( this . read ( ) == T_QUESTION ) { this . next ( ) ; return Token . createConcat ( tok , Token . createNGClosure ( tok ) ) ; } else return Token . createConcat ( tok , Token . createClosure ( tok ) ) ; } Token processQuestion ( Token tok ) throws ParseException { this . next ( ) ; Token par = Token . createUnion ( ) ; if ( this . read ( ) == T_QUESTION ) { this . next ( ) ; par . addChild ( Token . createEmpty ( ) ) ; par . addChild ( tok ) ; } else { par . addChild ( tok ) ; par . addChild ( Token . createEmpty ( ) ) ; } return par ; } boolean checkQuestion ( int off ) { return off < this . regexlen && this . regex . charAt ( off ) == '?' ; } Token processParen ( ) throws ParseException { this . next ( ) ; int p = this . parennumber ++ ; Token tok = Token . createParen ( this . parseRegex ( ) , p ) ; if ( this . read ( ) != T_RPAREN ) throw ex ( "parser.factor.1" , this . offset - 1 ) ; this . next ( ) ; return tok ; } Token processParen2 ( ) throws ParseException { this . next ( ) ; Token tok = Token . createParen ( this . parseRegex ( ) , 0 ) ; if ( this . read ( ) != T_RPAREN ) throw ex ( "parser.factor.1" , this . offset - 1 ) ; this . next ( ) ; return tok ; } Token processCondition ( ) throws ParseException { if ( this . offset + 1 >= this . regexlen ) throw ex ( "parser.factor.4" , this . offset ) ; int refno = - 1 ; Token condition = null ; int ch = this . regex . charAt ( this . offset ) ; if ( '1' <= ch && ch <= '9' ) { refno = ch - '0' ; this . hasBackReferences = true ; if ( this . references == null ) this . references = new Vector ( ) ; this . references . addElement ( new ReferencePosition ( refno , this . offset ) ) ; this . offset ++ ; if ( this . regex . charAt ( this . offset ) != ')' ) throw ex ( "parser.factor.1" , this . offset ) ; this . offset ++ ; } else { if ( ch == '?' ) this . offset -- ; this . next ( ) ; condition = this . parseFactor ( ) ; switch ( condition . type ) { case Token . LOOKAHEAD : case Token . NEGATIVELOOKAHEAD : case Token . LOOKBEHIND : case Token . NEGATIVELOOKBEHIND : break ; case Token . ANCHOR : if ( this . read ( ) != T_RPAREN ) throw ex ( "parser.factor.1" , this . offset - 1 ) ; break ; default : throw ex ( "parser.factor.5" , this . offset ) ; } } this . next ( ) ; Token yesPattern = this . parseRegex ( ) ; Token noPattern = null ; if ( yesPattern . type == Token . UNION ) { if ( yesPattern . size ( ) != 2 ) throw ex ( "parser.factor.6" , this . offset ) ; noPattern = yesPattern . getChild ( 1 ) ; yesPattern = yesPattern . getChild ( 0 ) ; } if ( this . read ( ) != T_RPAREN ) throw ex ( "parser.factor.1" , this . offset - 1 ) ; this . next ( ) ; return Token . createCondition ( refno , condition , yesPattern , noPattern ) ; } Token processModifiers ( ) throws ParseException { int add = 0 , mask = 0 , ch = - 1 ; while ( this . offset < this . regexlen ) { ch = this . regex . charAt ( this . offset ) ; int v = REUtil . getOptionValue ( ch ) ; if ( v == 0 ) break ; add |= v ; this . offset ++ ; } if ( this . offset >= this . regexlen ) throw ex ( "parser.factor.2" , this . offset - 1 ) ; if ( ch == '-' ) { this . offset ++ ; while ( this . offset < this . regexlen ) { ch = this . regex . charAt ( this . offset ) ; int v = REUtil . getOptionValue ( ch ) ; if ( v == 0 ) break ; mask |= v ; this . offset ++ ; } if ( this . offset >= this . regexlen ) throw ex ( "parser.factor.2" , this . offset - 1 ) ; } Token tok ; if ( ch == ':' ) { this . offset ++ ; this . next ( ) ; tok = Token . createModifierGroup ( this . parseRegex ( ) , add , mask ) ; if ( this . read ( ) != T_RPAREN ) throw ex ( "parser.factor.1" , this . offset - 1 ) ; this . next ( ) ; } else if ( ch == ')' ) { this . offset ++ ; this . next ( ) ; tok = Token . createModifierGroup ( this . parseRegex ( ) , add , mask ) ; } else throw ex ( "parser.factor.3" , this . offset ) ; return tok ; } Token processIndependent ( ) throws ParseException { this . next ( ) ; Token tok = Token . createLook ( Token . INDEPENDENT , this . parseRegex ( ) ) ; if ( this . read ( ) != T_RPAREN ) throw ex ( "parser.factor.1" , this . offset - 1 ) ; this . next ( ) ; return tok ; } Token processBacksolidus_c ( ) throws ParseException { int ch2 ; if ( this . offset >= this . regexlen || ( ( ch2 = this . regex . charAt ( this . offset ++ ) ) & 0xffe0 ) != 0x0040 ) throw ex ( "parser.atom.1" , this . offset - 1 ) ; this . next ( ) ; return Token . createChar ( ch2 - 0x40 ) ; } Token processBacksolidus_C ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processBacksolidus_i ( ) throws ParseException { Token tok = Token . createChar ( 'i' ) ; this . next ( ) ; return tok ; } Token processBacksolidus_I ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processBacksolidus_g ( ) throws ParseException { this . next ( ) ; return Token . getGraphemePattern ( ) ; } Token processBacksolidus_X ( ) throws ParseException { this . next ( ) ; return Token . getCombiningCharacterSequence ( ) ; } Token processBackreference ( ) throws ParseException { int refnum = this . chardata - '0' ; Token tok = Token . createBackReference ( refnum ) ; this . hasBackReferences = true ; if ( this . references == null ) this . references = new Vector ( ) ; this . references . addElement ( new ReferencePosition ( refnum , this . offset - 2 ) ) ; this . next ( ) ; return tok ; } Token parseFactor ( ) throws ParseException { int ch = this . read ( ) ; Token tok ; switch ( ch ) { case T_CARET : return this . processCaret ( ) ; case T_DOLLAR : return this . processDollar ( ) ; case T_LOOKAHEAD : return this . processLookahead ( ) ; case T_NEGATIVELOOKAHEAD : return this . processNegativelookahead ( ) ; case T_LOOKBEHIND : return this . processLookbehind ( ) ; case T_NEGATIVELOOKBEHIND : return this . processNegativelookbehind ( ) ; case T_COMMENT : this . next ( ) ; return Token . createEmpty ( ) ; case T_BACKSOLIDUS : switch ( this . chardata ) { case 'A' : return this . processBacksolidus_A ( ) ; case 'Z' : return this . processBacksolidus_Z ( ) ; case 'z' : return this . processBacksolidus_z ( ) ; case 'b' : return this . processBacksolidus_b ( ) ; case 'B' : return this . processBacksolidus_B ( ) ; case '<' : return this . processBacksolidus_lt ( ) ; case '>' : return this . processBacksolidus_gt ( ) ; } } tok = this . parseAtom ( ) ; ch = this . read ( ) ; switch ( ch ) { case T_STAR : return this . processStar ( tok ) ; case T_PLUS : return this . processPlus ( tok ) ; case T_QUESTION : return this . processQuestion ( tok ) ; case T_CHAR : if ( this . chardata == '{' ) { int off = this . offset ; int min = 0 , max = - 1 ; if ( off >= this . regexlen ) break ; ch = this . regex . charAt ( off ++ ) ; if ( ch != ',' && ( ch < '0' || ch > '9' ) ) break ; if ( ch != ',' ) { min = ch - '0' ; while ( off < this . regexlen && ( ch = this . regex . charAt ( off ++ ) ) >= '0' && ch <= '9' ) { min = min * 10 + ch - '0' ; ch = - 1 ; } if ( ch < 0 ) break ; } max = min ; if ( ch == ',' ) { if ( off >= this . regexlen || ( ( ch = this . regex . charAt ( off ++ ) ) < '0' || ch > '9' ) && ch != '}' ) break ; if ( ch == '}' ) { max = - 1 ; } else { max = ch - '0' ; while ( off < this . regexlen && ( ch = this . regex . charAt ( off ++ ) ) >= '0' && ch <= '9' ) { max = max * 10 + ch - '0' ; ch = - 1 ; } if ( ch < 0 ) break ; } } if ( ch != '}' ) break ; if ( this . checkQuestion ( off ) ) { tok = Token . createNGClosure ( tok ) ; this . offset = off + 1 ; } else { tok = Token . createClosure ( tok ) ; this . offset = off ; } tok . setMin ( min ) ; tok . setMax ( max ) ; this . next ( ) ; } } return tok ; } Token parseAtom ( ) throws ParseException { int ch = this . read ( ) ; Token tok = null ; switch ( ch ) { case T_LPAREN : return this . processParen ( ) ; case T_LPAREN2 : return this . processParen2 ( ) ; case T_CONDITION : return this . processCondition ( ) ; case T_MODIFIERS : return this . processModifiers ( ) ; case T_INDEPENDENT : return this . processIndependent ( ) ; case T_DOT : this . next ( ) ; tok = Token . token_dot ; break ; case T_LBRACKET : return this . parseCharacterClass ( true ) ; case T_SET_OPERATIONS : return this . parseSetOperations ( ) ; case T_BACKSOLIDUS : switch ( this . chardata ) { case 'd' : case 'D' : case 'w' : case 'W' : case 's' : case 'S' : tok = this . getTokenForShorthand ( this . chardata ) ; this . next ( ) ; return tok ; case 'e' : case 'f' : case 'n' : case 'r' : case 't' : case 'u' : case 'v' : case 'x' : { int ch2 = this . decodeEscaped ( ) ; if ( ch2 < 0x10000 ) { tok = Token . createChar ( ch2 ) ; } else { tok = Token . createString ( REUtil . decomposeToSurrogates ( ch2 ) ) ; } } break ; case 'c' : return this . processBacksolidus_c ( ) ; case 'C' : return this . processBacksolidus_C ( ) ; case 'i' : return this . processBacksolidus_i ( ) ; case 'I' : return this . processBacksolidus_I ( ) ; case 'g' : return this . processBacksolidus_g ( ) ; case 'X' : return this . processBacksolidus_X ( ) ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : return this . processBackreference ( ) ; case 'P' : case 'p' : int pstart = this . offset ; tok = processBacksolidus_pP ( this . chardata ) ; if ( tok == null ) throw this . ex ( "parser.atom.5" , pstart ) ; break ; default : tok = Token . createChar ( this . chardata ) ; } this . next ( ) ; break ; case T_CHAR : tok = Token . createChar ( this . chardata ) ; this . next ( ) ; break ; default : throw this . ex ( "parser.atom.4" , this . offset - 1 ) ; } return tok ; } protected RangeToken processBacksolidus_pP ( int c ) throws ParseException { boolean positive = c == 'p' ; this . next ( ) ; if ( this . read ( ) != T_CHAR ) throw this . ex ( "parser.atom.2" , this . offset - 1 ) ; RangeToken tok ; switch ( this . chardata ) { case 'L' : tok = Token . getRange ( "L" , positive ) ; break ; case 'M' : tok = Token . getRange ( "M" , positive ) ; break ; case 'N' : tok = Token . getRange ( "N" , positive ) ; break ; case 'Z' : tok = Token . getRange ( "Z" , positive ) ; break ; case 'C' : tok = Token . getRange ( "C" , positive ) ; break ; case 'P' : tok = Token . getRange ( "P" , positive ) ; break ; case 'S' : tok = Token . getRange ( "S" , positive ) ; break ; case '{' : int namestart = this . offset ; int nameend = this . regex . indexOf ( '}' , namestart ) ; if ( nameend < 0 ) throw this . ex ( "parser.atom.3" , this . offset ) ; this . offset = nameend + 1 ; tok = Token . getRange ( this . regex . substring ( namestart , nameend ) , positive ) ; break ; default : throw this . ex ( "parser.atom.2" , this . offset - 1 ) ; } return tok ; } int processCIinCharacterClass ( RangeToken tok , int c ) { return this . decodeEscaped ( ) ; } protected RangeToken parseCharacterClass ( boolean useNrange ) throws ParseException { this . setContext ( S_INBRACKETS ) ; this . next ( ) ; boolean nrange = false ; RangeToken base = null ; RangeToken tok ; if ( this . read ( ) == T_CHAR && this . chardata == '^' ) { nrange = true ; this . next ( ) ; if ( useNrange ) { tok = Token . createNRange ( ) ; } else { base = Token . createRange ( ) ; base . addRange ( 0 , Token . UTF16_MAX ) ; tok = Token . createRange ( ) ; } } else { tok = Token . createRange ( ) ; } int type ; boolean firstloop = true ; while ( ( type = this . read ( ) ) != T_EOF ) { if ( type == T_CHAR && this . chardata == ']' && ! firstloop ) break ; firstloop = false ; int c = this . chardata ; boolean end = false ; if ( type == T_BACKSOLIDUS ) { switch ( c ) { case 'd' : case 'D' : case 'w' : case 'W' : case 's' : case 'S' : tok . mergeRanges ( this . getTokenForShorthand ( c ) ) ; end = true ; break ; case 'i' : case 'I' : case 'c' : case 'C' : c = this . processCIinCharacterClass ( tok , c ) ; if ( c < 0 ) end = true ; break ; case 'p' : case 'P' : int pstart = this . offset ; RangeToken tok2 = this . processBacksolidus_pP ( c ) ; if ( tok2 == null ) throw this . ex ( "parser.atom.5" , pstart ) ; tok . mergeRanges ( tok2 ) ; end = true ; break ; default : c = this . decodeEscaped ( ) ; } } else if ( type == T_POSIX_CHARCLASS_START ) { int nameend = this . regex . indexOf ( ':' , this . offset ) ; if ( nameend < 0 ) throw this . ex ( "parser.cc.1" , this . offset ) ; boolean positive = true ; if ( this . regex . charAt ( this . offset ) == '^' ) { this . offset ++ ; positive = false ; } String name = this . regex . substring ( this . offset , nameend ) ; RangeToken range = Token . getRange ( name , positive ) ; if ( range == null ) throw this . ex ( "parser.cc.3" , this . offset ) ; tok . mergeRanges ( range ) ; end = true ; if ( nameend + 1 >= this . regexlen || this . regex . charAt ( nameend + 1 ) != ']' ) throw this . ex ( "parser.cc.1" , nameend ) ; this . offset = nameend + 2 ; } this . next ( ) ; if ( ! end ) { if ( this . read ( ) != T_CHAR || this . chardata != '-' ) { tok . addRange ( c , c ) ; } else { this . next ( ) ; if ( ( type = this . read ( ) ) == T_EOF ) throw this . ex ( "parser.cc.2" , this . offset ) ; if ( type == T_CHAR && this . chardata == ']' ) { tok . addRange ( c , c ) ; tok . addRange ( '-' , '-' ) ; } else { int rangeend = this . chardata ; if ( type == T_BACKSOLIDUS ) rangeend = this . decodeEscaped ( ) ; this . next ( ) ; tok . addRange ( c , rangeend ) ; } } } if ( this . isSet ( RegularExpression . SPECIAL_COMMA ) && this . read ( ) == T_CHAR && this . chardata == ',' ) this . next ( ) ; } if ( this . read ( ) == T_EOF ) throw this . ex ( "parser.cc.2" , this . offset ) ; if ( ! useNrange && nrange ) { base . subtractRanges ( tok ) ; tok = base ; } tok . sortRanges ( ) ; tok . compactRanges ( ) ; this . setContext ( S_NORMAL ) ; this . next ( ) ; return tok ; } private RangeToken parseCharacterClass_old ( boolean useNrange ) throws ParseException { this . setContext ( S_INBRACKETS ) ; this . next ( ) ; boolean nrange = false ; RangeToken base = null ; RangeToken tok ; if ( this . read ( ) == T_CHAR && this . chardata == '^' ) { nrange = true ; this . next ( ) ; if ( useNrange ) { tok = Token . createNRange ( ) ; } else { base = Token . createRange ( ) ; base . addRange ( 0 , Token . UTF16_MAX ) ; tok = Token . createRange ( ) ; } } else { tok = Token . createRange ( ) ; } int type ; while ( ( type = this . read ( ) ) != T_EOF && ! ( type == T_CHAR && this . chardata == ']' ) ) { int c = this . chardata ; boolean end = false ; if ( type == T_BACKSOLIDUS ) { switch ( c ) { case 'd' : case 'D' : case 'w' : case 'W' : case 's' : case 'S' : tok . mergeRanges ( this . getTokenForShorthand ( c ) ) ; end = true ; break ; case 'i' : case 'I' : case 'c' : case 'C' : c = this . processCIinCharacterClass ( tok , c ) ; if ( c < 0 ) end = true ; break ; case 'p' : case 'P' : boolean positive = c == 'p' ; int pstart = this . offset ; this . next ( ) ; if ( this . read ( ) != T_CHAR ) throw ex ( "parser.atom.2" , this . offset - 1 ) ; RangeToken tok2 = null ; switch ( this . chardata ) { case 'L' : tok2 = Token . getRange ( "L" , positive ) ; break ; case 'M' : tok2 = Token . getRange ( "M" , positive ) ; break ; case 'N' : tok2 = Token . getRange ( "N" , positive ) ; break ; case 'Z' : tok2 = Token . getRange ( "Z" , positive ) ; break ; case 'C' : tok2 = Token . getRange ( "C" , positive ) ; break ; case 'P' : tok2 = Token . getRange ( "P" , positive ) ; break ; case 'S' : tok2 = Token . getRange ( "S" , positive ) ; break ; case '{' : pstart = this . offset ; int namestart = this . offset ; int nameend = this . regex . indexOf ( '}' , namestart ) ; if ( nameend < 0 ) throw ex ( "parser.atom.3" , this . offset ) ; this . offset = nameend + 1 ; tok2 = Token . getRange ( this . regex . substring ( namestart , nameend ) , positive ) ; break ; default : throw ex ( "parser.atom.2" , this . offset - 1 ) ; } if ( tok2 == null ) throw ex ( "parser.atom.5" , pstart ) ; tok . mergeRanges ( tok2 ) ; end = true ; break ; default : c = this . decodeEscaped ( ) ; } } else if ( type == T_POSIX_CHARCLASS_START ) { int nameend = this . regex . indexOf ( ':' , this . offset ) ; if ( nameend < 0 ) throw ex ( "parser.cc.1" , this . offset ) ; String name = this . regex . substring ( this . offset , nameend ) ; RangeToken range = Token . getRange ( name , true ) ; if ( range == null ) throw ex ( "parser.cc.3" , this . offset ) ; tok . mergeRanges ( range ) ; end = true ; if ( nameend + 1 >= this . regexlen || this . regex . charAt ( nameend + 1 ) != ']' ) throw ex ( "parser.cc.1" , nameend ) ; this . offset = nameend + 2 ; } this . next ( ) ; if ( ! end ) { if ( this . read ( ) != T_CHAR || this . chardata != '-' ) { tok . addRange ( c , c ) ; } else { this . next ( ) ; if ( ( type = this . read ( ) ) == T_EOF ) throw ex ( "parser.cc.2" , this . offset ) ; int rangeend = this . chardata ; if ( type == T_BACKSOLIDUS ) rangeend = this . decodeEscaped ( ) ; this . next ( ) ; tok . addRange ( c , rangeend ) ; } } if ( this . read ( ) == T_CHAR && this . chardata == ',' ) this . next ( ) ; } if ( this . read ( ) == T_EOF ) throw ex ( "parser.cc.2" , this . offset ) ; if ( ! useNrange && nrange ) { base . subtractRanges ( tok ) ; tok = base ; } tok . sortRanges ( ) ; tok . compactRanges ( ) ; this . setContext ( S_NORMAL ) ; this . next ( ) ; return tok ; } protected RangeToken parseSetOperations ( ) throws ParseException { RangeToken tok = this . parseCharacterClass ( false ) ; int type ; while ( ( type = this . read ( ) ) != T_RPAREN ) { int ch = this . chardata ; if ( type == T_CHAR && ( ch == '-' || ch == '&' ) || type == T_PLUS ) { this . next ( ) ; if ( this . read ( ) != T_LBRACKET ) throw ex ( "parser.ope.1" , this . offset - 1 ) ; RangeToken t2 = this . parseCharacterClass ( false ) ; if ( type == T_PLUS ) tok . mergeRanges ( t2 ) ; else if ( ch == '-' ) tok . subtractRanges ( t2 ) ; else if ( ch == '&' ) tok . intersectRanges ( t2 ) ; else throw new RuntimeException ( "ASSERT" ) ; } else { throw ex ( "parser.ope.2" , this . offset - 1 ) ; } } this . next ( ) ; return tok ; } Token getTokenForShorthand ( int ch ) { Token tok ; switch ( ch ) { case 'd' : tok = this . isSet ( RegularExpression . USE_UNICODE_CATEGORY ) ? Token . getRange ( "Nd" , true ) : Token . token_0to9 ; break ; case 'D' : tok = this . isSet ( RegularExpression . USE_UNICODE_CATEGORY ) ? Token . getRange ( "Nd" , false ) : Token . token_not_0to9 ; break ; case 'w' : tok = this . isSet ( RegularExpression . USE_UNICODE_CATEGORY ) ? Token . getRange ( "IsWord" , true ) : Token . token_wordchars ; break ; case 'W' : tok = this . isSet ( RegularExpression . USE_UNICODE_CATEGORY ) ? Token . getRange ( "IsWord" , false ) : Token . token_not_wordchars ; break ; case 's' : tok = this . isSet ( RegularExpression . USE_UNICODE_CATEGORY ) ? Token . getRange ( "IsSpace" , true ) : Token . token_spaces ; break ; case 'S' : tok = this . isSet ( RegularExpression . USE_UNICODE_CATEGORY ) ? Token . getRange ( "IsSpace" , false ) : Token . token_not_spaces ; break ; default : throw new RuntimeException ( "Internal Error: shorthands: \\u" + Integer . toString ( ch , 16 ) ) ; } return tok ; } int decodeEscaped ( ) throws ParseException { if ( this . read ( ) != T_BACKSOLIDUS ) throw ex ( "parser.next.1" , this . offset - 1 ) ; int c = this . chardata ; switch ( c ) { case 'e' : c = 0x1b ; break ; case 'f' : c = '\f' ; break ; case 'n' : c = '\n' ; break ; case 'r' : c = '\r' ; break ; case 't' : c = '\t' ; break ; case 'x' : this . next ( ) ; if ( this . read ( ) != T_CHAR ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; if ( this . chardata == '{' ) { int v1 = 0 ; int uv = 0 ; do { this . next ( ) ; if ( this . read ( ) != T_CHAR ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; if ( ( v1 = hexChar ( this . chardata ) ) < 0 ) break ; if ( uv > uv * 16 ) throw ex ( "parser.descape.2" , this . offset - 1 ) ; uv = uv * 16 + v1 ; } while ( true ) ; if ( this . chardata != '}' ) throw ex ( "parser.descape.3" , this . offset - 1 ) ; if ( uv > Token . UTF16_MAX ) throw ex ( "parser.descape.4" , this . offset - 1 ) ; c = uv ; } else { int v1 = 0 ; if ( this . read ( ) != T_CHAR || ( v1 = hexChar ( this . chardata ) ) < 0 ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; int uv = v1 ; this . next ( ) ; if ( this . read ( ) != T_CHAR || ( v1 = hexChar ( this . chardata ) ) < 0 ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; uv = uv * 16 + v1 ; c = uv ; } break ; case 'u' : int v1 = 0 ; this . next ( ) ; if ( this . read ( ) != T_CHAR || ( v1 = hexChar ( this . chardata ) ) < 0 ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; int uv = v1 ; this . next ( ) ; if ( this . read ( ) != T_CHAR || ( v1 = hexChar ( this . chardata ) ) < 0 ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; uv = uv * 16 + v1 ; this . next ( ) ; if ( this . read ( ) != T_CHAR || ( v1 = hexChar ( this . chardata ) ) < 0 ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; uv = uv * 16 + v1 ; this . next ( ) ; if ( this . read ( ) != T_CHAR || ( v1 = hexChar ( this . chardata ) ) < 0 ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; uv = uv * 16 + v1 ; c = uv ; break ; case 'v' : this . next ( ) ; if ( this . read ( ) != T_CHAR || ( v1 = hexChar ( this . chardata ) ) < 0 ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; uv = v1 ; this . next ( ) ; if ( this . read ( ) != T_CHAR || ( v1 = hexChar ( this . chardata ) ) < 0 ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; uv = uv * 16 + v1 ; this . next ( ) ; if ( this . read ( ) != T_CHAR || ( v1 = hexChar ( this . chardata ) ) < 0 ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; uv = uv * 16 + v1 ; this . next ( ) ; if ( this . read ( ) != T_CHAR || ( v1 = hexChar ( this . chardata ) ) < 0 ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; uv = uv * 16 + v1 ; this . next ( ) ; if ( this . read ( ) != T_CHAR || ( v1 = hexChar ( this . chardata ) ) < 0 ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; uv = uv * 16 + v1 ; this . next ( ) ; if ( this . read ( ) != T_CHAR || ( v1 = hexChar ( this . chardata ) ) < 0 ) throw ex ( "parser.descape.1" , this . offset - 1 ) ; uv = uv * 16 + v1 ; if ( uv > Token . UTF16_MAX ) throw ex ( "parser.descappe.4" , this . offset - 1 ) ; c = uv ; break ; case 'A' : case 'Z' : case 'z' : throw ex ( "parser.descape.5" , this . offset - 2 ) ; default : } return c ; } static private final int hexChar ( int ch ) { if ( ch < '0' ) return - 1 ; if ( ch > 'f' ) return - 1 ; if ( ch <= '9' ) return ch - '0' ; if ( ch < 'A' ) return - 1 ; if ( ch <= 'F' ) return ch - 'A' + 10 ; if ( ch < 'a' ) return - 1 ; return ch - 'a' + 10 ; } } 	0
package org . apache . xerces . dom . events ; import org . w3c . dom . events . * ; import org . w3c . dom . Node ; public class EventImpl implements Event { public String type = null ; public EventTarget target ; public Node currentNode ; public short eventPhase ; public boolean initialized = false , bubbles = true , cancelable = false ; public boolean stopPropagation = false , preventDefault = false ; protected long timeStamp = System . currentTimeMillis ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) { type = eventTypeArg ; bubbles = canBubbleArg ; cancelable = cancelableArg ; initialized = true ; } public boolean getBubbles ( ) { return bubbles ; } public boolean getCancelable ( ) { return cancelable ; } public Node getCurrentNode ( ) { return currentNode ; } public short getEventPhase ( ) { return eventPhase ; } public EventTarget getTarget ( ) { return target ; } public String getType ( ) { return type ; } public long getTimeStamp ( ) { return timeStamp ; } public void stopPropagation ( ) { stopPropagation = true ; } public void preventDefault ( ) { preventDefault = true ; } } 	1
package org . apache . wml ; import org . w3c . dom . * ; public interface WMLDOMImplementation extends DOMImplementation { } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DOMImplementationImpl implements DOMImplementation { static DOMImplementationImpl singleton = new DOMImplementationImpl ( ) ; public boolean hasFeature ( String feature , String version ) { return ( feature . equalsIgnoreCase ( "XML" ) && ( version == null || version . equals ( "1.0" ) || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "Events" ) && ( version == null || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "MutationEvents" ) && ( version == null || version . equals ( "2.0" ) ) ) || ( feature . equalsIgnoreCase ( "Traversal" ) && ( version == null || version . equals ( "2.0" ) ) ) ; } public static DOMImplementation getDOMImplementation ( ) { return singleton ; } public DocumentType createDocumentType ( String qualifiedName , String publicID , String systemID ) { if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; if ( index == 0 || index == qualifiedName . length ( ) - 1 ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } return new DocumentTypeImpl ( null , qualifiedName , publicID , systemID ) ; } public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException { if ( doctype != null && doctype . getOwnerDocument ( ) != null ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } DocumentImpl doc = new DocumentImpl ( doctype ) ; Element e = doc . createElementNS ( namespaceURI , qualifiedName ) ; doc . appendChild ( e ) ; return doc ; } } 	1
package org . xml . sax ; import java . io . IOException ; public interface EntityResolver { public abstract InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface DocumentTraversal { public NodeIterator createNodeIterator ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) ; public TreeWalker createTreeWalker ( Node root , int whatToShow , NodeFilter filter , boolean entityReferenceExpansion ) throws DOMException ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLHeadingElementImpl extends HTMLElementImpl implements HTMLHeadingElement { public String getAlign ( ) { return getCapitalized ( "align" ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public HTMLHeadingElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . readers ; import java . io . FileNotFoundException ; import java . io . UnsupportedEncodingException ; import java . net . MalformedURLException ; import java . util . Stack ; import java . util . Vector ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . URI ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; public class DefaultEntityHandler implements XMLEntityHandler , XMLEntityHandler . DTDHandler { public interface EventHandler { public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception ; public void sendEndOfInputNotifications ( int entityName , boolean moreToFollow ) throws Exception ; public void sendReaderChangeNotifications ( XMLEntityHandler . EntityReader reader , int readerId ) throws Exception ; public boolean externalEntityStandaloneCheck ( ) ; public boolean getValidating ( ) ; } private class ReaderState { XMLEntityHandler . EntityReader reader ; InputSource source ; int entityName ; int entityType ; int entityContext ; String publicId ; String systemId ; int readerId ; int depth ; ReaderState nextReaderState ; } private ReaderState fReaderStateFreeList = null ; private StringPool fStringPool = null ; private EventHandler fEventHandler = null ; private XMLEntityHandler . CharDataHandler fCharDataHandler = null ; private XMLErrorReporter fErrorReporter = null ; private EntityResolver fResolver = null ; private EntityPool fEntityPool = null ; private EntityPool fParameterEntityPool = null ; private byte [ ] fEntityTypeStack = null ; private int [ ] fEntityNameStack = null ; private int fEntityStackDepth = 0 ; private Stack fReaderStack = new Stack ( ) ; private XMLEntityHandler . EntityReader fReader = null ; private InputSource fSource = null ; private int fEntityName = - 1 ; private int fEntityType = - 1 ; private int fEntityContext = - 1 ; private String fPublicId = null ; private String fSystemId = null ; private int fReaderId = - 1 ; private int fReaderDepth = - 1 ; private int fNextReaderId = 0 ; private NullReader fNullReader = null ; protected XMLEntityReaderFactory fReaderFactory = null ; private boolean fSendCharDataAsCharArray = false ; public DefaultEntityHandler ( StringPool stringPool , XMLErrorReporter errorReporter ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fReaderFactory = new DefaultReaderFactory ( ) ; fEntityPool = new EntityPool ( fStringPool , fErrorReporter , true ) ; } public void setEventHandler ( EventHandler eventHandler ) { fEventHandler = eventHandler ; } public void setCharDataHandler ( XMLEntityHandler . CharDataHandler charDataHandler ) { fCharDataHandler = charDataHandler ; } public XMLEntityHandler . CharDataHandler getCharDataHandler ( ) { return fCharDataHandler ; } public void setSendCharDataAsCharArray ( boolean flag ) { fSendCharDataAsCharArray = flag ; fReaderFactory . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; } public void setReaderFactory ( XMLEntityReaderFactory readerFactory ) { fReaderFactory = readerFactory ; fReaderFactory . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fEntityPool . reset ( fStringPool ) ; fParameterEntityPool = null ; fReaderStack . removeAllElements ( ) ; fEntityStackDepth = 0 ; fReader = null ; fSource = null ; fEntityName = - 1 ; fEntityType = - 1 ; fEntityContext = - 1 ; fPublicId = null ; fSystemId = null ; fReaderId = - 1 ; fReaderDepth = - 1 ; fNextReaderId = 0 ; } public void setAllowJavaEncodings ( boolean flag ) { fReaderFactory . setAllowJavaEncodingName ( flag ) ; } public boolean getAllowJavaEncodings ( ) { return fReaderFactory . getAllowJavaEncodingName ( ) ; } public int addInternalPEDecl ( int name , int value , boolean isExternal ) throws Exception { if ( fParameterEntityPool == null ) fParameterEntityPool = new EntityPool ( fStringPool , fErrorReporter , false ) ; int entityHandle = fParameterEntityPool . addEntityDecl ( name , value , - 1 , - 1 , - 1 , - 1 , isExternal ) ; return entityHandle ; } public int addExternalPEDecl ( int name , int publicId , int systemId , boolean isExternal ) throws Exception { if ( fParameterEntityPool == null ) fParameterEntityPool = new EntityPool ( fStringPool , fErrorReporter , false ) ; int entityHandle = fParameterEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , - 1 , isExternal ) ; return entityHandle ; } public int addInternalEntityDecl ( int name , int value , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , value , - 1 , - 1 , - 1 , - 1 , isExternal ) ; return entityHandle ; } public int addExternalEntityDecl ( int name , int publicId , int systemId , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , - 1 , isExternal ) ; return entityHandle ; } public int addUnparsedEntityDecl ( int name , int publicId , int systemId , int notationName , boolean isExternal ) throws Exception { int entityHandle = fEntityPool . addEntityDecl ( name , - 1 , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , notationName , isExternal ) ; if ( ! fEntityPool . isNotationDeclared ( notationName ) ) { Object [ ] args = { fStringPool . toString ( name ) , fStringPool . toString ( notationName ) } ; fEntityPool . addRequiredNotation ( notationName , fErrorReporter . getLocator ( ) , XMLMessages . MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL , XMLMessages . VC_NOTATION_DECLARED , args ) ; } return entityHandle ; } public int addNotationDecl ( int notationName , int publicId , int systemId , boolean isExternal ) throws Exception { int notationHandle = fEntityPool . addNotationDecl ( notationName , publicId , systemId , fStringPool . addSymbol ( fSystemId ) , isExternal ) ; return notationHandle ; } public boolean isUnparsedEntity ( int entityName ) { int entityHandle = fEntityPool . lookupEntity ( entityName ) ; return ( entityHandle != - 1 && fEntityPool . isUnparsedEntity ( entityHandle ) ) ; } public boolean isNotationDeclared ( int notationName ) { return fEntityPool . isNotationDeclared ( notationName ) ; } public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { fEntityPool . addRequiredNotation ( notationName , locator , majorCode , minorCode , args ) ; } public void checkRequiredNotations ( ) throws Exception { fEntityPool . checkRequiredNotations ( ) ; } protected int lookupEntity ( int entityNameIndex ) { int entityIndex = fEntityPool . lookupEntity ( entityNameIndex ) ; return entityIndex ; } private void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } public boolean externalReferenceInContent ( int entityHandle ) throws Exception { boolean external = fEntityPool . isExternalEntity ( entityHandle ) ; if ( fEventHandler . externalEntityStandaloneCheck ( ) ) { if ( external ) { reportRecoverableXMLError ( XMLMessages . MSG_EXTERNAL_ENTITY_NOT_PERMITTED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } else if ( fEntityPool . getEntityDeclIsExternal ( entityHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } } return external ; } protected int valueOfReferenceInAttValue ( int entityHandle ) throws Exception { if ( fEventHandler . externalEntityStandaloneCheck ( ) && fEntityPool . getEntityDeclIsExternal ( entityHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fEntityName ) ; } int entityValue = fEntityPool . getEntityValue ( entityHandle ) ; return entityValue ; } protected boolean isExternalEntity ( int entityHandle ) { boolean external = fEntityPool . isExternalEntity ( entityHandle ) ; return external ; } protected int getEntityValue ( int entityHandle ) { int value = fEntityPool . getEntityValue ( entityHandle ) ; return value ; } protected String getPublicIdOfEntity ( int entityHandle ) { int publicId = fEntityPool . getPublicId ( entityHandle ) ; return fStringPool . toString ( publicId ) ; } protected String getSystemIdOfEntity ( int entityHandle ) { int systemId = fEntityPool . getSystemId ( entityHandle ) ; return fStringPool . toString ( systemId ) ; } protected int lookupParameterEntity ( int peName ) throws Exception { int entityHandle = - 1 ; if ( fParameterEntityPool != null ) entityHandle = fParameterEntityPool . lookupEntity ( peName ) ; return entityHandle ; } protected boolean isExternalParameterEntity ( int peIndex ) { boolean external = fParameterEntityPool . isExternalEntity ( peIndex ) ; return external ; } protected int getParameterEntityValue ( int peIndex ) { int value = fParameterEntityPool . getEntityValue ( peIndex ) ; return value ; } protected String getPublicIdOfParameterEntity ( int peIndex ) { int publicId = fParameterEntityPool . getPublicId ( peIndex ) ; return fStringPool . toString ( publicId ) ; } protected String getSystemIdOfParameterEntity ( int peIndex ) { int systemId = fParameterEntityPool . getSystemId ( peIndex ) ; return fStringPool . toString ( systemId ) ; } public XMLEntityHandler . EntityReader getEntityReader ( ) { return fReader ; } public void addRecognizer ( XMLDeclRecognizer recognizer ) { fReaderFactory . addRecognizer ( recognizer ) ; } public void setEntityResolver ( EntityResolver resolver ) { fResolver = resolver ; } public EntityResolver getEntityResolver ( ) { return fResolver ; } public String expandSystemId ( String systemId ) { return expandSystemId ( systemId , fSystemId ) ; } private String expandSystemId ( String systemId , String currentSystemId ) { String id = systemId ; if ( id == null || id . length ( ) == 0 ) { return systemId ; } try { URI uri = new URI ( id ) ; if ( uri != null ) { return systemId ; } } catch ( URI . MalformedURIException e ) { } id = fixURI ( id ) ; URI base = null ; URI uri = null ; try { if ( currentSystemId == null ) { String dir ; try { dir = fixURI ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { dir = "" ; } if ( ! dir . endsWith ( "/" ) ) { dir = dir + "/" ; } base = new URI ( "file" , "" , dir , null , null ) ; } else { base = new URI ( currentSystemId ) ; } uri = new URI ( base , id ) ; } catch ( Exception e ) { } if ( uri == null ) { return systemId ; } return uri . toString ( ) ; } private static String fixURI ( String str ) { str = str . replace ( java . io . File . separatorChar , '/' ) ; if ( str . length ( ) >= 2 ) { char ch1 = str . charAt ( 1 ) ; if ( ch1 == ':' ) { char ch0 = Character . toUpperCase ( str . charAt ( 0 ) ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { str = "/" + str ; } } } return str ; } public boolean startReadingFromDocument ( InputSource source ) throws Exception { pushEntity ( false , - 2 ) ; fSystemId = null ; pushNullReader ( ) ; fEntityName = - 2 ; fEntityType = ENTITYTYPE_DOCUMENT ; fEntityContext = ENTITYREF_DOCUMENT ; fReaderDepth = 0 ; fReaderId = fNextReaderId ++ ; fPublicId = source . getPublicId ( ) ; fSystemId = source . getSystemId ( ) ; fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; fSystemId = expandSystemId ( fSystemId , null ) ; fSource = source ; boolean xmlDecl = true ; try { fReader = fReaderFactory . createReader ( this , fErrorReporter , source , fSystemId , xmlDecl , fStringPool ) ; } catch ( MalformedURLException mu ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( FileNotFoundException fnf ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( UnsupportedEncodingException uee ) { fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; String encoding = uee . getMessage ( ) ; if ( encoding == null ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_REQUIRED , XMLMessages . P81_REQUIRED , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else if ( ! XMLCharacterProperties . validEncName ( encoding ) ) { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_NOT_SUPPORTED , XMLMessages . P81_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; return fReader != null ; } public void startReadingFromExternalSubset ( String publicId , String systemId , int readerDepth ) throws Exception { pushEntity ( true , - 1 ) ; pushReader ( ) ; pushNullReader ( ) ; fEntityName = - 1 ; fEntityType = ENTITYTYPE_EXTERNAL_SUBSET ; fEntityContext = ENTITYREF_EXTERNAL_SUBSET ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; fPublicId = publicId ; fSystemId = systemId ; startReadingFromExternalEntity ( false , - 1 ) ; } public void stopReadingFromExternalSubset ( ) throws Exception { if ( ! ( fReader instanceof NullReader ) ) throw new RuntimeException ( "FWK004 cannot happen 18" + "\n18" ) ; popReader ( ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; } public boolean startReadingFromEntity ( int entityName , int readerDepth , int context ) throws Exception { if ( context > XMLEntityHandler . ENTITYREF_IN_CONTENT ) return startReadingFromParameterEntity ( entityName , readerDepth , context ) ; int entityHandle = lookupEntity ( entityName ) ; if ( entityHandle < 0 ) { int minorCode = XMLMessages . VC_ENTITY_DECLARED ; int errorType = XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ; if ( fEntityContext == ENTITYREF_DOCUMENT || fEntityContext == ENTITYREF_IN_ATTVALUE ) { minorCode = XMLMessages . WFC_ENTITY_DECLARED ; errorType = XMLErrorReporter . ERRORTYPE_FATAL_ERROR ; } else if ( ! fEventHandler . getValidating ( ) ) { return false ; } Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENTITY_NOT_DECLARED , minorCode , args , errorType ) ; return false ; } if ( context == ENTITYREF_IN_CONTENT ) { if ( fEntityPool . isUnparsedEntity ( entityHandle ) ) { Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REFERENCE_TO_UNPARSED_ENTITY , XMLMessages . WFC_PARSED_ENTITY , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } } else { if ( isExternalEntity ( entityHandle ) ) { Object [ ] args = { fStringPool . toString ( entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REFERENCE_TO_EXTERNAL_ENTITY , XMLMessages . WFC_NO_EXTERNAL_ENTITY_REFERENCES , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } } if ( ! pushEntity ( false , entityName ) ) { Object [ ] args = { fStringPool . toString ( entityName ) , entityReferencePath ( false , entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_RECURSIVE_REFERENCE , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } pushReader ( ) ; fEntityName = entityName ; fEntityContext = context ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; if ( context != ENTITYREF_IN_CONTENT || ! externalReferenceInContent ( entityHandle ) ) { fEntityType = ENTITYTYPE_INTERNAL ; fPublicId = null ; fSystemId = fSystemId ; int value = - 1 ; if ( context == ENTITYREF_IN_CONTENT || context == ENTITYREF_IN_DEFAULTATTVALUE ) value = getEntityValue ( entityHandle ) ; else value = valueOfReferenceInAttValue ( entityHandle ) ; startReadingFromInternalEntity ( value , false ) ; return false ; } fEntityType = ENTITYTYPE_EXTERNAL ; fPublicId = getPublicIdOfEntity ( entityHandle ) ; fSystemId = getSystemIdOfEntity ( entityHandle ) ; return startReadingFromExternalEntity ( true , entityHandle ) ; } private boolean startReadingFromParameterEntity ( int peName , int readerDepth , int context ) throws Exception { int entityHandle = lookupParameterEntity ( peName ) ; if ( entityHandle == - 1 ) { if ( fEventHandler . getValidating ( ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ENTITY_NOT_DECLARED , XMLMessages . VC_ENTITY_DECLARED , peName ) ; } return false ; } if ( ! pushEntity ( true , peName ) ) { Object [ ] args = { fStringPool . toString ( peName ) , entityReferencePath ( true , peName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_RECURSIVE_PEREFERENCE , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } pushReader ( ) ; fEntityName = peName ; fEntityContext = context ; fReaderDepth = readerDepth ; fReaderId = fNextReaderId ++ ; if ( ! isExternalParameterEntity ( entityHandle ) ) { fEntityType = ENTITYTYPE_INTERNAL_PE ; fPublicId = null ; fSystemId = fSystemId ; int value = getParameterEntityValue ( entityHandle ) ; startReadingFromInternalEntity ( value , fEntityContext == ENTITYREF_IN_ENTITYVALUE ? false : true ) ; return false ; } fEntityType = ENTITYTYPE_EXTERNAL_PE ; fPublicId = getPublicIdOfParameterEntity ( entityHandle ) ; fSystemId = getSystemIdOfParameterEntity ( entityHandle ) ; return startReadingFromExternalEntity ( true , entityHandle ) ; } private void startReadingFromInternalEntity ( int value , boolean addSpaces ) throws Exception { if ( fEntityContext == ENTITYREF_IN_ENTITYVALUE ) { } fSource = null ; fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; fReader = fReaderFactory . createStringReader ( this , fErrorReporter , fSendCharDataAsCharArray , getLineNumber ( ) , getColumnNumber ( ) , value , fStringPool , addSpaces ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; } private boolean startReadingFromExternalEntity ( boolean checkForTextDecl , int entityHandle ) throws Exception { if ( fEntityContext == ENTITYREF_IN_ENTITYVALUE ) { } if ( fEntityContext == ENTITYREF_IN_DTD_WITHIN_MARKUP ) { } fEventHandler . startEntityReference ( fEntityName , fEntityType , fEntityContext ) ; String baseSystemId = null ; if ( entityHandle != - 1 ) { if ( fEntityType == ENTITYTYPE_EXTERNAL_PE ) baseSystemId = fParameterEntityPool . getBaseSystemId ( entityHandle ) ; else baseSystemId = fEntityPool . getBaseSystemId ( entityHandle ) ; } if ( baseSystemId == null ) { ReaderState rs = ( ReaderState ) fReaderStack . peek ( ) ; baseSystemId = rs . systemId ; } fSystemId = expandSystemId ( fSystemId , baseSystemId ) ; fSource = fResolver == null ? null : fResolver . resolveEntity ( fPublicId , fSystemId ) ; if ( fSource == null ) { fSource = new InputSource ( fSystemId ) ; if ( fPublicId != null ) fSource . setPublicId ( fPublicId ) ; } else { if ( fSource . getSystemId ( ) != null ) { fSystemId = expandSystemId ( fSource . getSystemId ( ) , baseSystemId ) ; } if ( fSource . getPublicId ( ) != null ) { fPublicId = fSource . getPublicId ( ) ; } } boolean textDecl = false ; try { fReader = fReaderFactory . createReader ( this , fErrorReporter , fSource , fSystemId , textDecl , fStringPool ) ; } catch ( MalformedURLException mu ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( FileNotFoundException fnf ) { String errorSystemId = fSystemId ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; Object [ ] args = { errorSystemId } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . IO0 , 0 , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } catch ( UnsupportedEncodingException uee ) { fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; popEntity ( ) ; fReader = null ; String encoding = uee . getMessage ( ) ; if ( encoding == null ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_REQUIRED , XMLMessages . P81_REQUIRED , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else if ( ! XMLCharacterProperties . validEncName ( encoding ) ) { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODINGDECL_INVALID , XMLMessages . P81_INVALID_VALUE , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } else { Object [ ] args = { encoding } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ENCODING_NOT_SUPPORTED , XMLMessages . P81_NOT_SUPPORTED , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } if ( fReader == null || ! checkForTextDecl ) { fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; return false ; } int readerId = fReaderId ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; boolean parseTextDecl = fReader . lookingAtChar ( '<' , false ) ; if ( readerId != fReaderId ) parseTextDecl = false ; return parseTextDecl ; } private void pushNullReader ( ) { ReaderState rs = fReaderStateFreeList ; if ( rs == null ) rs = new ReaderState ( ) ; else fReaderStateFreeList = rs . nextReaderState ; if ( fNullReader == null ) fNullReader = new NullReader ( ) ; rs . reader = fNullReader ; rs . source = null ; rs . entityName = - 1 ; rs . entityType = - 1 ; rs . entityContext = - 1 ; rs . publicId = "Null Entity" ; rs . systemId = fSystemId ; rs . readerId = fNextReaderId ++ ; rs . depth = - 1 ; rs . nextReaderState = null ; fReaderStack . push ( rs ) ; } private void pushReader ( ) { ReaderState rs = fReaderStateFreeList ; if ( rs == null ) rs = new ReaderState ( ) ; else fReaderStateFreeList = rs . nextReaderState ; rs . reader = fReader ; rs . source = fSource ; rs . entityName = fEntityName ; rs . entityType = fEntityType ; rs . entityContext = fEntityContext ; rs . publicId = fPublicId ; rs . systemId = fSystemId ; rs . readerId = fReaderId ; rs . depth = fReaderDepth ; rs . nextReaderState = null ; fReaderStack . push ( rs ) ; } private void popReader ( ) { if ( fReaderStack . empty ( ) ) throw new RuntimeException ( "FWK004 cannot happen 19" + "\n19" ) ; ReaderState rs = ( ReaderState ) fReaderStack . pop ( ) ; fReader = rs . reader ; fSource = rs . source ; fEntityName = rs . entityName ; fEntityType = rs . entityType ; fEntityContext = rs . entityContext ; fPublicId = rs . publicId ; fSystemId = rs . systemId ; fReaderId = rs . readerId ; fReaderDepth = rs . depth ; rs . nextReaderState = fReaderStateFreeList ; fReaderStateFreeList = rs ; } public boolean startEntityDecl ( boolean isPE , int entityName ) throws Exception { if ( ! pushEntity ( isPE , entityName ) ) { int majorCode = isPE ? XMLMessages . MSG_RECURSIVE_PEREFERENCE : XMLMessages . MSG_RECURSIVE_REFERENCE ; Object [ ] args = { fStringPool . toString ( entityName ) , entityReferencePath ( isPE , entityName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , XMLMessages . WFC_NO_RECURSION , args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; return false ; } return true ; } public void endEntityDecl ( ) throws Exception { popEntity ( ) ; } private boolean pushEntity ( boolean isPE , int entityName ) throws Exception { if ( entityName >= 0 ) { for ( int i = 0 ; i < fEntityStackDepth ; i ++ ) { if ( fEntityNameStack [ i ] == entityName && fEntityTypeStack [ i ] == ( isPE ? 1 : 0 ) ) { return false ; } } } if ( fEntityTypeStack == null ) { fEntityTypeStack = new byte [ 8 ] ; fEntityNameStack = new int [ 8 ] ; } else if ( fEntityStackDepth == fEntityTypeStack . length ) { byte [ ] newTypeStack = new byte [ fEntityStackDepth * 2 ] ; System . arraycopy ( fEntityTypeStack , 0 , newTypeStack , 0 , fEntityStackDepth ) ; fEntityTypeStack = newTypeStack ; int [ ] newNameStack = new int [ fEntityStackDepth * 2 ] ; System . arraycopy ( fEntityNameStack , 0 , newNameStack , 0 , fEntityStackDepth ) ; fEntityNameStack = newNameStack ; } fEntityTypeStack [ fEntityStackDepth ] = ( byte ) ( isPE ? 1 : 0 ) ; fEntityNameStack [ fEntityStackDepth ] = entityName ; fEntityStackDepth ++ ; return true ; } private String entityReferencePath ( boolean isPE , int entityName ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "(top-level)" ) ; for ( int i = 0 ; i < fEntityStackDepth ; i ++ ) { if ( fEntityNameStack [ i ] >= 0 ) { sb . append ( '-' ) ; sb . append ( fEntityTypeStack [ i ] == 1 ? '%' : '&' ) ; sb . append ( fStringPool . toString ( fEntityNameStack [ i ] ) ) ; sb . append ( ';' ) ; } } sb . append ( '-' ) ; sb . append ( isPE ? '%' : '&' ) ; sb . append ( fStringPool . toString ( entityName ) ) ; sb . append ( ';' ) ; return sb . toString ( ) ; } private void popEntity ( ) throws Exception { fEntityStackDepth -- ; } public int getReaderId ( ) { return fReaderId ; } public void setReaderDepth ( int depth ) { fReaderDepth = depth ; } public int getReaderDepth ( ) { return fReaderDepth ; } public String getPublicId ( ) { return fPublicId ; } public String getSystemId ( ) { return fSystemId ; } public int getLineNumber ( ) { return fReader == null ? 0 : fReader . getLineNumber ( ) ; } public int getColumnNumber ( ) { return fReader == null ? 0 : fReader . getColumnNumber ( ) ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { fEventHandler . sendEndOfInputNotifications ( fEntityName , fReaderStack . size ( ) > 1 ) ; fEventHandler . endEntityReference ( fEntityName , fEntityType , fEntityContext ) ; popReader ( ) ; fEventHandler . sendReaderChangeNotifications ( fReader , fReaderId ) ; popEntity ( ) ; return fReader ; } private final class NullReader implements XMLEntityHandler . EntityReader { public NullReader ( ) { } public int currentOffset ( ) { return - 1 ; } public int getLineNumber ( ) { return - 1 ; } public int getColumnNumber ( ) { return - 1 ; } public void setInCDSect ( boolean inCDSect ) { } public boolean getInCDSect ( ) { return false ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { } public int addString ( int offset , int length ) { return - 1 ; } public int addSymbol ( int offset , int length ) { return - 1 ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) { return false ; } public boolean lookingAtValidChar ( boolean skipPastChar ) { return false ; } public boolean lookingAtSpace ( boolean skipPastChar ) { return false ; } public void skipToChar ( char ch ) { } public void skipPastSpaces ( ) { } public void skipPastName ( char fastcheck ) { } public void skipPastNmtoken ( char fastcheck ) { } public boolean skippedString ( char [ ] s ) { return false ; } public int scanInvalidChar ( ) { return - 1 ; } public int scanCharRef ( boolean hex ) { return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } public int scanStringLiteral ( ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } public int scanAttValue ( char qchar , boolean asSymbol ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } public int scanEntityValue ( int qchar , boolean createString ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) { return false ; } public void scanQName ( char fastcheck , QName qname ) { qname . clear ( ) ; } public int scanName ( char fastcheck ) { return - 1 ; } public int scanContent ( QName element ) throws Exception { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } static final int CHUNK_SHIFT = 5 ; static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; static final int CHUNK_MASK = CHUNK_SIZE - 1 ; static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; public final class EntityPool { private StringPool fStringPool = null ; private XMLErrorReporter fErrorReporter = null ; private int fEntityCount = 0 ; private int [ ] [ ] fName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fValue = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fPublicId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fSystemId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fBaseSystemId = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private int [ ] [ ] fNotationName = new int [ INITIAL_CHUNK_COUNT ] [ ] ; private byte [ ] [ ] fDeclIsExternal = new byte [ INITIAL_CHUNK_COUNT ] [ ] ; private int fNotationListHead = - 1 ; private boolean fCreateStandardEntities = false ; private Vector fRequiredNotations = null ; public EntityPool ( StringPool stringPool , XMLErrorReporter errorReporter , boolean createStandardEntities ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fCreateStandardEntities = createStandardEntities ; if ( fCreateStandardEntities ) { createInternalEntity ( "lt" , "&#60;" ) ; createInternalEntity ( "gt" , ">" ) ; createInternalEntity ( "amp" , "&#38;" ) ; createInternalEntity ( "apos" , "\'" ) ; createInternalEntity ( "quot" , "\"" ) ; } } public void reset ( StringPool stringPool ) { fStringPool = stringPool ; fEntityCount = 0 ; fNotationListHead = - 1 ; if ( fRequiredNotations != null ) fRequiredNotations . removeAllElements ( ) ; if ( fCreateStandardEntities ) { createInternalEntity ( "lt" , "&#60;" ) ; createInternalEntity ( "gt" , ">" ) ; createInternalEntity ( "amp" , "&#38;" ) ; createInternalEntity ( "apos" , "\'" ) ; createInternalEntity ( "quot" , "\"" ) ; } } private void createInternalEntity ( String name , String value ) { int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = fStringPool . addSymbol ( name ) ; fValue [ chunk ] [ index ] = fStringPool . addString ( value ) ; fPublicId [ chunk ] [ index ] = - 1 ; fSystemId [ chunk ] [ index ] = - 1 ; fBaseSystemId [ chunk ] [ index ] = - 1 ; fNotationName [ chunk ] [ index ] = - 1 ; fEntityCount ++ ; } private boolean ensureCapacity ( int chunk ) { try { return fName [ chunk ] [ 0 ] == 0 ; } catch ( ArrayIndexOutOfBoundsException ex ) { int [ ] [ ] newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fName , 0 , newIntArray , 0 , chunk ) ; fName = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fValue , 0 , newIntArray , 0 , chunk ) ; fValue = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fPublicId , 0 , newIntArray , 0 , chunk ) ; fPublicId = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fSystemId , 0 , newIntArray , 0 , chunk ) ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fBaseSystemId , 0 , newIntArray , 0 , chunk ) ; fBaseSystemId = newIntArray ; fSystemId = newIntArray ; newIntArray = new int [ chunk * 2 ] [ ] ; System . arraycopy ( fNotationName , 0 , newIntArray , 0 , chunk ) ; fNotationName = newIntArray ; byte [ ] [ ] newByteArray = new byte [ chunk * 2 ] [ ] ; System . arraycopy ( fDeclIsExternal , 0 , newByteArray , 0 , chunk ) ; fDeclIsExternal = newByteArray ; } catch ( NullPointerException ex ) { } fName [ chunk ] = new int [ CHUNK_SIZE ] ; fValue [ chunk ] = new int [ CHUNK_SIZE ] ; fPublicId [ chunk ] = new int [ CHUNK_SIZE ] ; fSystemId [ chunk ] = new int [ CHUNK_SIZE ] ; fBaseSystemId [ chunk ] = new int [ CHUNK_SIZE ] ; fNotationName [ chunk ] = new int [ CHUNK_SIZE ] ; fDeclIsExternal [ chunk ] = new byte [ CHUNK_SIZE ] ; return true ; } public int addEntityDecl ( int name , int value , int publicId , int systemId , int baseSystemId , int notationName , boolean isExternal ) { int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = name ; fValue [ chunk ] [ index ] = value ; fPublicId [ chunk ] [ index ] = publicId ; fSystemId [ chunk ] [ index ] = systemId ; fBaseSystemId [ chunk ] [ index ] = baseSystemId ; fNotationName [ chunk ] [ index ] = notationName ; fDeclIsExternal [ chunk ] [ index ] = isExternal ? ( byte ) 0x80 : ( byte ) 0 ; int entityIndex = fEntityCount ++ ; return entityIndex ; } public int addNotationDecl ( int notationName , int publicId , int systemId , int baseSystemId , boolean isExternal ) { int nIndex = fNotationListHead ; while ( nIndex != - 1 ) { int chunk = nIndex > > CHUNK_SHIFT ; int index = nIndex & CHUNK_MASK ; if ( fNotationName [ chunk ] [ index ] == notationName ) return - 1 ; nIndex = fValue [ chunk ] [ index ] ; } int chunk = fEntityCount > > CHUNK_SHIFT ; int index = fEntityCount & CHUNK_MASK ; ensureCapacity ( chunk ) ; fName [ chunk ] [ index ] = - 1 ; fValue [ chunk ] [ index ] = fNotationListHead ; fPublicId [ chunk ] [ index ] = publicId ; fSystemId [ chunk ] [ index ] = systemId ; fBaseSystemId [ chunk ] [ index ] = baseSystemId ; fNotationName [ chunk ] [ index ] = notationName ; fDeclIsExternal [ chunk ] [ index ] = isExternal ? ( byte ) 0x80 : ( byte ) 0 ; fNotationListHead = fEntityCount ++ ; return fNotationListHead ; } public int lookupEntity ( int nameIndex ) { if ( nameIndex == - 1 ) return - 1 ; int chunk = 0 ; int index = 0 ; for ( int entityIndex = 0 ; entityIndex < fEntityCount ; entityIndex ++ ) { if ( fName [ chunk ] [ index ] == nameIndex ) return entityIndex ; if ( ++ index == CHUNK_SIZE ) { chunk ++ ; index = 0 ; } } return - 1 ; } public boolean isExternalEntity ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fValue [ chunk ] [ index ] == - 1 ) ; } public boolean isUnparsedEntity ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fNotationName [ chunk ] [ index ] != - 1 ) ; } public boolean getEntityDeclIsExternal ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fDeclIsExternal [ chunk ] [ index ] < 0 ) ; } public int getEntityName ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fName [ chunk ] [ index ] ; } public int getEntityValue ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fValue [ chunk ] [ index ] ; } public int getPublicId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fPublicId [ chunk ] [ index ] ; } public int getSystemId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fSystemId [ chunk ] [ index ] ; } public String getBaseSystemId ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; int baseIndex = fBaseSystemId [ chunk ] [ index ] ; if ( baseIndex == - 1 ) { return null ; } else { return fStringPool . toString ( baseIndex ) ; } } public boolean isNotationDeclared ( int nameIndex ) { int nIndex = fNotationListHead ; while ( nIndex != - 1 ) { int chunk = nIndex > > CHUNK_SHIFT ; int index = nIndex & CHUNK_MASK ; if ( fNotationName [ chunk ] [ index ] == nameIndex ) return true ; nIndex = fValue [ chunk ] [ index ] ; } return false ; } public boolean getNotationDeclIsExternal ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return ( fDeclIsExternal [ chunk ] [ index ] < 0 ) ; } public int getNotationName ( int entityIndex ) { int chunk = entityIndex > > CHUNK_SHIFT ; int index = entityIndex & CHUNK_MASK ; return fNotationName [ chunk ] [ index ] ; } class RequiredNotation { RequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { fNotationName = notationName ; fLocator = new LocatorImpl ( locator ) ; fMajorCode = majorCode ; fMinorCode = minorCode ; fArgs = args ; } int fNotationName ; LocatorImpl fLocator ; int fMajorCode ; int fMinorCode ; Object [ ] fArgs ; } ; public void addRequiredNotation ( int notationName , Locator locator , int majorCode , int minorCode , Object [ ] args ) { if ( fRequiredNotations == null ) fRequiredNotations = new Vector ( ) ; for ( int index = 0 ; index < fRequiredNotations . size ( ) ; index ++ ) { RequiredNotation rn = ( RequiredNotation ) fRequiredNotations . elementAt ( index ) ; if ( rn . fNotationName == notationName ) return ; } fRequiredNotations . addElement ( new RequiredNotation ( notationName , locator , majorCode , minorCode , args ) ) ; } public void checkRequiredNotations ( ) throws Exception { if ( fRequiredNotations == null ) return ; for ( int index = 0 ; index < fRequiredNotations . size ( ) ; index ++ ) { RequiredNotation rn = ( RequiredNotation ) fRequiredNotations . elementAt ( index ) ; if ( ! isNotationDeclared ( rn . fNotationName ) ) { fErrorReporter . reportError ( rn . fLocator , XMLMessages . XML_DOMAIN , rn . fMajorCode , rn . fMinorCode , rn . fArgs , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . xml . sax . Locator ; import org . xml . sax . InputSource ; import java . io . IOException ; final class StringReader extends XMLEntityReader { public static StringReader createStringReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , int lineNumber , int columnNumber , int stringHandle , StringPool stringPool , boolean addEnclosingSpaces ) { StringReader reader = null ; synchronized ( StringReader . class ) { reader = fgFreeReaders ; if ( reader == null ) { return new StringReader ( entityHandler , errorReporter , sendCharDataAsCharArray , lineNumber , columnNumber , stringHandle , stringPool , addEnclosingSpaces ) ; } fgFreeReaders = reader . fNextFreeReader ; } reader . init ( entityHandler , errorReporter , sendCharDataAsCharArray , lineNumber , columnNumber , stringHandle , stringPool , addEnclosingSpaces ) ; return reader ; } private StringReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , int lineNumber , int columnNumber , int stringHandle , StringPool stringPool , boolean addEnclosingSpaces ) { super ( entityHandler , errorReporter , sendCharDataAsCharArray , lineNumber , columnNumber ) ; fStringPool = stringPool ; fData = fStringPool . toString ( stringHandle ) ; fCurrentOffset = 0 ; fEndOffset = fData . length ( ) ; if ( addEnclosingSpaces ) { fMostRecentChar = ' ' ; fCurrentOffset -- ; oweTrailingSpace = hadTrailingSpace = true ; } else { fMostRecentChar = fEndOffset == 0 ? - 1 : fData . charAt ( 0 ) ; } } private void init ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , int lineNumber , int columnNumber , int stringHandle , StringPool stringPool , boolean addEnclosingSpaces ) { super . init ( entityHandler , errorReporter , sendCharDataAsCharArray , lineNumber , columnNumber ) ; fStringPool = stringPool ; fData = fStringPool . toString ( stringHandle ) ; fCurrentOffset = 0 ; fEndOffset = fData . length ( ) ; fNextFreeReader = null ; if ( addEnclosingSpaces ) { fMostRecentChar = ' ' ; fCurrentOffset -- ; oweTrailingSpace = hadTrailingSpace = true ; } else { fMostRecentChar = fEndOffset == 0 ? - 1 : fData . charAt ( 0 ) ; oweTrailingSpace = hadTrailingSpace = false ; } } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fStringPool . addString ( fData . substring ( offset , offset + length ) ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fStringPool . addSymbol ( fData . substring ( offset , offset + length ) ) ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { boolean addSpace = false ; for ( int i = 0 ; i < length ; i ++ ) { try { charBuffer . append ( fData . charAt ( offset ++ ) ) ; } catch ( StringIndexOutOfBoundsException ex ) { if ( offset == fEndOffset + 1 && hadTrailingSpace ) { charBuffer . append ( ' ' ) ; } else { System . err . println ( "StringReader.append()" ) ; throw ex ; } } } } private int loadNextChar ( ) { if ( ++ fCurrentOffset >= fEndOffset ) { if ( oweTrailingSpace ) { oweTrailingSpace = false ; fMostRecentChar = ' ' ; } else { fMostRecentChar = - 1 ; } } else { fMostRecentChar = fData . charAt ( fCurrentOffset ) ; } return fMostRecentChar ; } public XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; synchronized ( StringReader . class ) { fNextFreeReader = fgFreeReaders ; fgFreeReaders = this ; } return nextReader ; } public boolean lookingAtChar ( char chr , boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch != chr ) { if ( ch == - 1 ) { return changeReaders ( ) . lookingAtChar ( chr , skipPastChar ) ; } return false ; } if ( skipPastChar ) { if ( ++ fCurrentOffset >= fEndOffset ) { if ( oweTrailingSpace ) { oweTrailingSpace = false ; fMostRecentChar = ' ' ; } else { fMostRecentChar = - 1 ; } } else { fMostRecentChar = fData . charAt ( fCurrentOffset ) ; } } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0xD800 ) { if ( ch < 0x20 && ch != 0x09 && ch != 0x0A && ch != 0x0D ) { if ( ch == - 1 ) return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; return false ; } if ( skipPastChar ) { if ( ++ fCurrentOffset >= fEndOffset ) { if ( oweTrailingSpace ) { oweTrailingSpace = false ; fMostRecentChar = ' ' ; } else { fMostRecentChar = - 1 ; } } else { fMostRecentChar = fData . charAt ( fCurrentOffset ) ; } } return true ; } if ( ch > 0xFFFD ) { return false ; } if ( ch < 0xDC00 ) { if ( fCurrentOffset + 1 >= fEndOffset ) { return false ; } ch = fData . charAt ( fCurrentOffset + 1 ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) { return false ; } else if ( ! skipPastChar ) { return true ; } else { fCurrentOffset ++ ; } } else if ( ch < 0xE000 ) { return false ; } if ( skipPastChar ) { if ( ++ fCurrentOffset >= fEndOffset ) { if ( oweTrailingSpace ) { oweTrailingSpace = false ; fMostRecentChar = ' ' ; } else { fMostRecentChar = - 1 ; } } else { fMostRecentChar = fData . charAt ( fCurrentOffset ) ; } } return true ; } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x0A || ch == 0x0D || ch == 0x09 ) { if ( skipPastChar ) { loadNextChar ( ) ; } return true ; } if ( ch == - 1 ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } return false ; } public void skipToChar ( char chr ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == chr ) return ; if ( ch == - 1 ) { changeReaders ( ) . skipToChar ( chr ) ; return ; } ch = loadNextChar ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentChar ; if ( ch == - 1 ) { changeReaders ( ) . skipPastSpaces ( ) ; return ; } while ( true ) { if ( ch > 0x20 || ( ch != 0x20 && ch != 0x0A && ch != 0x09 && ch != 0x0D ) ) { fMostRecentChar = ch ; return ; } if ( ++ fCurrentOffset >= fEndOffset ) { changeReaders ( ) . skipPastSpaces ( ) ; return ; } ch = fData . charAt ( fCurrentOffset ) ; } } public void skipPastName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( ch == - 1 || XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return ; } while ( true ) { ch = loadNextChar ( ) ; if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( ch == - 1 || XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( ch == - 1 || XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } ch = loadNextChar ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int ch = fMostRecentChar ; if ( ch != s [ 0 ] ) { if ( ch == - 1 ) return changeReaders ( ) . skippedString ( s ) ; return false ; } if ( fCurrentOffset + s . length > fEndOffset ) return false ; for ( int i = 1 ; i < s . length ; i ++ ) { if ( fData . charAt ( fCurrentOffset + i ) != s [ i ] ) return false ; } fCurrentOffset += ( s . length - 1 ) ; loadNextChar ( ) ; return true ; } public int scanInvalidChar ( ) throws Exception { int ch = fMostRecentChar ; if ( ch == - 1 ) return changeReaders ( ) . scanInvalidChar ( ) ; loadNextChar ( ) ; return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentChar ; if ( ch == - 1 ) return changeReaders ( ) . scanCharRef ( hex ) ; int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } boolean toobig = false ; while ( true ) { ch = loadNextChar ( ) ; if ( ch == - 1 ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; loadNextChar ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( lookingAtChar ( qchar , false ) ) { break ; } if ( lookingAtChar ( ' ' , true ) ) { continue ; } if ( lookingAtSpace ( false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '<' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } int result = asSymbol ? addSymbol ( offset , fCurrentOffset - offset ) : addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return result ; } public static final byte fgAsciiEntityValueChar [ ] = { 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 4 , 4 , 0 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 1 , 0 , 0 , 3 , 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; int ch = fMostRecentChar ; while ( true ) { if ( ch == - 1 ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } if ( ch < 0x80 ) { switch ( fgAsciiEntityValueChar [ ch ] ) { case 1 : if ( ch == qchar ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; int length = fCurrentOffset - offset ; int result = length == 0 ? StringPool . EMPTY_STRING : addString ( offset , length ) ; loadNextChar ( ) ; return result ; } case 0 : if ( ++ fCurrentOffset >= fEndOffset ) { if ( oweTrailingSpace ) { oweTrailingSpace = false ; ch = fMostRecentChar = ' ' ; } else { ch = fMostRecentChar = - 1 ; } } else { ch = fMostRecentChar = fData . charAt ( fCurrentOffset ) ; } continue ; case 2 : return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; case 3 : return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; case 4 : return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } else if ( ch < 0xD800 ) { ch = loadNextChar ( ) ; } else if ( ch >= 0xE000 && ( ch <= 0xFFFD || ( ch >= 0x10000 && ch <= 0x10FFFF ) ) ) { ch = loadNextChar ( ) ; } else { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { int ch = fMostRecentChar ; if ( ch == - 1 ) { return changeReaders ( ) . scanExpectedName ( fastcheck , expectedName ) ; } if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int nameOffset = fCurrentOffset ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return false ; while ( true ) { ch = loadNextChar ( ) ; if ( fastcheck == ch ) break ; if ( ch == - 1 ) break ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } int nameIndex = fStringPool . addSymbol ( fData . substring ( nameOffset , fCurrentOffset ) ) ; return true ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentChar ; if ( ch == - 1 ) { changeReaders ( ) . scanQName ( fastcheck , qname ) ; return ; } if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int nameOffset = fCurrentOffset ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } while ( true ) { ch = loadNextChar ( ) ; if ( fastcheck == ch ) break ; if ( ch == - 1 ) break ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } qname . clear ( ) ; qname . rawname = fStringPool . addSymbol ( fData . substring ( nameOffset , fCurrentOffset ) ) ; int index = fData . indexOf ( ':' , nameOffset ) ; if ( index != - 1 ) { qname . prefix = fStringPool . addSymbol ( fData . substring ( nameOffset , index ) ) ; int indexOfSpaceChar = fData . indexOf ( ' ' , index + 1 ) ; String localPart ; if ( indexOfSpaceChar != - 1 ) { localPart = fData . substring ( index + 1 , indexOfSpaceChar ) ; qname . localpart = fStringPool . addSymbol ( localPart ) ; } else { int lenfData = fData . length ( ) ; localPart = fData . substring ( index + 1 , lenfData ) ; qname . localpart = fStringPool . addSymbol ( localPart ) ; } qname . localpart = fStringPool . addSymbol ( localPart ) ; } else { qname . localpart = qname . rawname ; } } public int scanName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch == - 1 ) { return changeReaders ( ) . scanName ( fastcheck ) ; } if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } int nameOffset = fCurrentOffset ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return - 1 ; while ( true ) { if ( ++ fCurrentOffset >= fEndOffset ) { if ( oweTrailingSpace ) { oweTrailingSpace = false ; fMostRecentChar = ' ' ; } else { fMostRecentChar = - 1 ; } break ; } ch = fMostRecentChar = fData . charAt ( fCurrentOffset ) ; if ( fastcheck == ch ) break ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } int nameIndex = fStringPool . addSymbol ( fData . substring ( nameOffset , fCurrentOffset ) ) ; return nameIndex ; } private int recognizeMarkup ( int ch ) throws Exception { if ( ch == - 1 ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } switch ( ch ) { case '?' : loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : ch = loadNextChar ( ) ; if ( ch == - 1 ) { fCurrentOffset -= 2 ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { ch = loadNextChar ( ) ; if ( ch == - 1 ) { fCurrentOffset -= 3 ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( ch == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { ch = loadNextChar ( ) ; if ( ch == - 1 ) { fCurrentOffset -= ( 3 + i ) ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == - 1 ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '#' ) { loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } public int scanContent ( QName element ) throws Exception { int ch = fMostRecentChar ; if ( ch == - 1 ) { return changeReaders ( ) . scanContent ( element ) ; } int offset = fCurrentOffset ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : ch = loadNextChar ( ) ; break ; case 1 : ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeMarkup ( ch ) ; } break ; case 2 : ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } break ; case 3 : ch = loadNextChar ( ) ; if ( ch == ']' && fCurrentOffset + 1 < fEndOffset && fData . charAt ( fCurrentOffset + 1 ) == '>' ) { loadNextChar ( ) ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; } break ; case 4 : return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { ch = loadNextChar ( ) ; if ( ch == - 1 ) { callCharDataHandler ( offset , fEndOffset , true ) ; return changeReaders ( ) . scanContent ( element ) ; } } while ( ch == 0x20 || ch == 0x0A || ch == 0x0D || ch == 0x09 ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : ch = loadNextChar ( ) ; break ; case 1 : ch = loadNextChar ( ) ; if ( ! fInCDSect ) { callCharDataHandler ( offset , fCurrentOffset - 1 , true ) ; return recognizeMarkup ( ch ) ; } break ; case 2 : ch = loadNextChar ( ) ; if ( ! fInCDSect ) { callCharDataHandler ( offset , fCurrentOffset - 1 , true ) ; return recognizeReference ( ch ) ; } break ; case 3 : ch = loadNextChar ( ) ; if ( ch == ']' && fCurrentOffset + 1 < fEndOffset && fData . charAt ( fCurrentOffset + 1 ) == '>' ) { callCharDataHandler ( offset , fCurrentOffset - 1 , true ) ; loadNextChar ( ) ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; } break ; case 4 : callCharDataHandler ( offset , fCurrentOffset , true ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ch == 0xFFFE || ch == 0xFFFF ) { callCharDataHandler ( offset , fCurrentOffset , true ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = loadNextChar ( ) ; } } } else { if ( ch == 0xFFFE || ch == 0xFFFF ) { callCharDataHandler ( offset , fCurrentOffset , false ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = loadNextChar ( ) ; } while ( true ) { if ( ch == - 1 ) { callCharDataHandler ( offset , fEndOffset , false ) ; return changeReaders ( ) . scanContent ( element ) ; } if ( ch >= 0x80 ) break ; if ( XMLCharacterProperties . fgAsciiCharData [ ch ] != 0 ) break ; ch = loadNextChar ( ) ; } while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : ch = loadNextChar ( ) ; break ; case 1 : ch = loadNextChar ( ) ; if ( ! fInCDSect ) { callCharDataHandler ( offset , fCurrentOffset - 1 , false ) ; return recognizeMarkup ( ch ) ; } break ; case 2 : ch = loadNextChar ( ) ; if ( ! fInCDSect ) { callCharDataHandler ( offset , fCurrentOffset - 1 , false ) ; return recognizeReference ( ch ) ; } break ; case 3 : ch = loadNextChar ( ) ; if ( ch == ']' && fCurrentOffset + 1 < fEndOffset && fData . charAt ( fCurrentOffset + 1 ) == '>' ) { callCharDataHandler ( offset , fCurrentOffset - 1 , false ) ; loadNextChar ( ) ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; } break ; case 4 : callCharDataHandler ( offset , fCurrentOffset , false ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ch == 0xFFFE || ch == 0xFFFF ) { callCharDataHandler ( offset , fCurrentOffset , false ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = loadNextChar ( ) ; } if ( ch == - 1 ) { callCharDataHandler ( offset , fCurrentOffset , false ) ; return changeReaders ( ) . scanContent ( element ) ; } } } private void callCharDataHandler ( int offset , int endOffset , boolean isWhitespace ) throws Exception { int length = endOffset - offset ; if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , length ) ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( stringIndex ) ; else fCharDataHandler . processCharacters ( stringIndex ) ; return ; } if ( isWhitespace ) fCharDataHandler . processWhitespace ( fData . toCharArray ( ) , offset , length ) ; else fCharDataHandler . processCharacters ( fData . toCharArray ( ) , offset , length ) ; } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool fStringPool = null ; private String fData = null ; private int fEndOffset ; private boolean hadTrailingSpace = false ; private boolean oweTrailingSpace = false ; private int fMostRecentChar ; private StringReader fNextFreeReader = null ; private static StringReader fgFreeReaders = null ; private boolean fCalledCharPropInit = false ; } 	0
package org . w3c . dom ; public interface DOMImplementation { public boolean hasFeature ( String feature , String version ) ; public DocumentType createDocumentType ( String qualifiedName , String publicId , String systemId ) throws DOMException ; public Document createDocument ( String namespaceURI , String qualifiedName , DocumentType doctype ) throws DOMException ; } 	1
package org . w3c . dom . html ; import org . w3c . dom . DOMImplementation ; public interface HTMLDOMImplementation extends DOMImplementation { public HTMLDocument createHTMLDocument ( String title ) ; } 	0
package org . apache . xerces . utils ; import java . lang . * ; public final class HexBin { static private final int BASELENGTH = 255 ; static private final int LOOKUPLENGTH = 16 ; static private byte [ ] hexNumberTable = new byte [ BASELENGTH ] ; static private byte [ ] lookUpHexAlphabet = new byte [ LOOKUPLENGTH ] ; static { for ( int i = 0 ; i < BASELENGTH ; i ++ ) { hexNumberTable [ i ] = - 1 ; } for ( int i = '9' ; i >= '0' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - '0' ) ; } for ( int i = 'F' ; i >= 'A' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - 'A' + 10 ) ; } for ( int i = 'f' ; i >= 'a' ; i -- ) { hexNumberTable [ i ] = ( byte ) ( i - 'a' + 10 ) ; } for ( int i = 0 ; i <= 25 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( 'A' + i ) ; for ( int i = 0 ; i < 10 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( '0' + i ) ; for ( int i = 10 ; i <= 15 ; i ++ ) lookUpHexAlphabet [ i ] = ( byte ) ( 'A' + i - 10 ) ; } static boolean isHex ( byte octect ) { return ( hexNumberTable [ octect ] != - 1 ) ; } static boolean isArrayByteHex ( byte [ ] arrayOctect ) { int length = arrayOctect . length ; if ( length == 0 ) return false ; for ( int i = 0 ; i < length ; i ++ ) { if ( HexBin . isHex ( arrayOctect [ i ] ) == false ) return false ; } return true ; } public static boolean isHex ( String isValidString ) { return ( isArrayByteHex ( isValidString . getBytes ( ) ) ) ; } static public byte [ ] encode ( byte [ ] binaryData ) { int lengthData = binaryData . length ; int lengthEncode = lengthData ; byte [ ] encodedData = new byte [ lengthData ] ; for ( int i = 0 ; i < lengthData ; i ++ ) { encodedData [ i ] = lookUpHexAlphabet [ binaryData [ i ] ] ; } return encodedData ; } static public byte [ ] decode ( byte [ ] binaryData ) { int lengthData = binaryData . length ; int lengthEncode = lengthData ; byte [ ] decodedData = new byte [ lengthData ] ; for ( int i = 0 ; i < lengthData ; i ++ ) { decodedData [ i ] = hexNumberTable [ binaryData [ i ] ] ; } return decodedData ; } } 	1
package org . apache . wml ; public interface WMLTimerElement extends WMLElement { public void setName ( String newValue ) ; public String getName ( ) ; public void setValue ( String newValue ) ; public String getValue ( ) ; } 	0
package org . w3c . dom ; public interface EntityReference extends Node { } 	1
package org . apache . wml ; public interface WMLHeadElement extends WMLElement { } 	0
package org . w3c . dom ; public interface Attr extends Node { public String getName ( ) ; public boolean getSpecified ( ) ; public String getValue ( ) ; public void setValue ( String value ) throws DOMException ; public Element getOwnerElement ( ) ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLFrameElementImpl extends HTMLElementImpl implements HTMLFrameElement { public String getFrameBorder ( ) { return getAttribute ( "frameborder" ) ; } public void setFrameBorder ( String frameBorder ) { setAttribute ( "frameborder" , frameBorder ) ; } public String getLongDesc ( ) { return getAttribute ( "longdesc" ) ; } public void setLongDesc ( String longDesc ) { setAttribute ( "longdesc" , longDesc ) ; } public String getMarginHeight ( ) { return getAttribute ( "marginheight" ) ; } public void setMarginHeight ( String marginHeight ) { setAttribute ( "marginheight" , marginHeight ) ; } public String getMarginWidth ( ) { return getAttribute ( "marginwidth" ) ; } public void setMarginWidth ( String marginWidth ) { setAttribute ( "marginwidth" , marginWidth ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public boolean getNoResize ( ) { return getBinary ( "noresize" ) ; } public void setNoResize ( boolean noResize ) { setAttribute ( "noresize" , noResize ) ; } public String getScrolling ( ) { return capitalize ( getAttribute ( "scrolling" ) ) ; } public void setScrolling ( String scrolling ) { setAttribute ( "scrolling" , scrolling ) ; } public String getSrc ( ) { return getAttribute ( "src" ) ; } public void setSrc ( String src ) { setAttribute ( "src" , src ) ; } public HTMLFrameElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . DOMException ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . CharacterData ; import org . apache . xerces . dom . DOMExceptionImpl ; import org . apache . xerces . dom . DocumentImpl ; import org . w3c . dom . range . * ; import java . util . Vector ; public class RangeImpl implements Range { static final int START = 0 ; static final int AFTER = 1 ; static final int BEFORE = - 1 ; DocumentImpl fDocument ; Node fStartContainer ; Node fEndContainer ; int fStartOffset ; int fEndOffset ; boolean fIsCollapsed ; boolean fDetach = false ; Node fInsertNode = null ; Node fDeleteNode = null ; Node fSplitNode = null ; public RangeImpl ( DocumentImpl document ) { fDocument = document ; fStartContainer = document ; fEndContainer = document ; fStartOffset = 0 ; fEndOffset = 0 ; fDetach = false ; } public Node getStartContainer ( ) { return fStartContainer ; } public int getStartOffset ( ) { return fStartOffset ; } public Node getEndContainer ( ) { return fEndContainer ; } public int getEndOffset ( ) { return fEndOffset ; } public boolean getCollapsed ( ) { return ( fStartContainer == fEndContainer && fStartOffset == fEndOffset ) ; } public Node getCommonAncestorContainer ( ) { Vector startV = new Vector ( ) ; Node node ; for ( node = fStartContainer ; node != null ; node = node . getParentNode ( ) ) { startV . addElement ( node ) ; } Vector endV = new Vector ( ) ; for ( node = fEndContainer ; node != null ; node = node . getParentNode ( ) ) { endV . addElement ( node ) ; } int s = startV . size ( ) - 1 ; int e = endV . size ( ) - 1 ; Object result = null ; while ( s >= 0 && e >= 0 ) { if ( startV . elementAt ( s ) == endV . elementAt ( e ) ) { result = startV . elementAt ( s ) ; } else { break ; } -- s ; -- e ; } return ( Node ) result ; } public void setStart ( Node refNode , int offset ) throws RangeException , DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } checkIndex ( refNode , offset ) ; fStartContainer = refNode ; fStartOffset = offset ; } public void setEnd ( Node refNode , int offset ) throws RangeException , DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } checkIndex ( refNode , offset ) ; fEndContainer = refNode ; fEndOffset = offset ; } public void setStartBefore ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i - 1 ; } public void setStartAfter ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i ; } public void setEndBefore ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fEndContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fEndOffset = i - 1 ; } public void setEndAfter ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fEndContainer = refNode . getParentNode ( ) ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fEndOffset = i ; } public void collapse ( boolean toStart ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( toStart ) { fEndContainer = fStartContainer ; fEndOffset = fStartOffset ; } else { fStartContainer = fEndContainer ; fStartOffset = fEndOffset ; } } public void selectNode ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } Node parent = refNode . getParentNode ( ) ; if ( parent != null ) { fStartContainer = parent ; fEndContainer = parent ; int i = 0 ; for ( Node n = refNode ; n != null ; n = n . getPreviousSibling ( ) ) { i ++ ; } fStartOffset = i - 1 ; fEndOffset = fStartOffset + 1 ; } } public void selectNodeContents ( Node refNode ) throws RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( ! isAncestorTypeValid ( refNode ) ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } fStartContainer = refNode ; fEndContainer = refNode ; Node first = refNode . getFirstChild ( ) ; fStartOffset = 0 ; if ( first == null ) { fEndOffset = 0 ; } else { int i = 0 ; for ( Node n = first ; n != null ; n = n . getNextSibling ( ) ) { i ++ ; } fEndOffset = i ; } } public short compareBoundaryPoints ( short how , Range sourceRange ) throws DOMException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Node endPointA ; Node endPointB ; int offsetA ; int offsetB ; if ( how == START_TO_START ) { endPointA = sourceRange . getStartContainer ( ) ; endPointB = fStartContainer ; offsetA = sourceRange . getStartOffset ( ) ; offsetB = fStartOffset ; } else if ( how == START_TO_END ) { endPointA = sourceRange . getStartContainer ( ) ; endPointB = fEndContainer ; offsetA = sourceRange . getStartOffset ( ) ; offsetB = fEndOffset ; } else if ( how == END_TO_START ) { endPointA = sourceRange . getEndContainer ( ) ; endPointB = fStartContainer ; offsetA = sourceRange . getEndOffset ( ) ; offsetB = fStartOffset ; } else { endPointA = sourceRange . getEndContainer ( ) ; endPointB = fEndContainer ; offsetA = sourceRange . getEndOffset ( ) ; offsetB = fEndOffset ; } if ( endPointA == endPointB ) { if ( offsetA < offsetB ) return - 1 ; if ( offsetA == offsetB ) return 0 ; return 1 ; } for ( Node node = endPointA . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { if ( isAncestorOf ( node , endPointB ) ) { int index = indexOf ( node , endPointA ) ; if ( offsetA < index ) return - 1 ; if ( offsetA == index ) return 0 ; return 1 ; } } for ( Node node = endPointB . getFirstChild ( ) ; node != null ; node = node . getNextSibling ( ) ) { if ( isAncestorOf ( node , endPointA ) ) { int index = indexOf ( node , endPointB ) ; if ( offsetB < index ) return - 1 ; if ( offsetB == index ) return 0 ; return 1 ; } } Node ancestor = getCommonAncestorContainer ( ) ; Node current = ancestor ; do { if ( current == endPointA ) return - 1 ; if ( current == endPointB ) return 1 ; current = nextNode ( current , true ) ; } while ( current != null && current != ancestor ) ; return - 2 ; } public void deleteContents ( ) throws DOMException { Node current = fStartContainer ; Node parent = null ; Node next ; boolean deleteCurrent = false ; Node root = getCommonAncestorContainer ( ) ; if ( fStartContainer == fEndContainer ) { if ( fStartOffset == fEndOffset ) { return ; } if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { String value = fStartContainer . getNodeValue ( ) ; int realStart = fStartOffset ; int realEnd = fEndOffset ; if ( fStartOffset > value . length ( ) ) realStart = value . length ( ) - 1 ; if ( fEndOffset > value . length ( ) ) realEnd = value . length ( ) - 1 ; deleteData ( ( CharacterData ) fStartContainer , realStart , realEnd - realStart ) ; } else { current = fStartContainer . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } for ( i = 0 ; i < fEndOffset - fStartOffset && current != null ; i ++ ) { Node newCurrent = current . getNextSibling ( ) ; removeChild ( fStartContainer , current ) ; current = newCurrent ; } } collapse ( true ) ; return ; } Node partialNode = null ; int partialInt = START ; Node startRoot = null ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { deleteData ( ( CharacterData ) current , fStartOffset , current . getNodeValue ( ) . length ( ) - fStartOffset ) ; } else { current = current . getFirstChild ( ) ; for ( int i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fStartContainer ; } else if ( current != fStartContainer ) { deleteCurrent = true ; } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { if ( startRoot == null ) startRoot = current ; } else { if ( partialNode == null ) { partialNode = parent ; partialInt = AFTER ; } } if ( parent != root ) { next = current . getNextSibling ( ) ; Node nextnext ; while ( next != null ) { nextnext = next . getNextSibling ( ) ; removeChild ( parent , next ) ; next = nextnext ; } } if ( deleteCurrent ) { removeChild ( parent , current ) ; deleteCurrent = false ; } current = parent ; } Node endRoot = null ; current = fEndContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { deleteData ( ( CharacterData ) current , 0 , fEndOffset ) ; } else { if ( fEndOffset == 0 ) { current = fEndContainer ; } else { current = current . getFirstChild ( ) ; for ( int i = 1 ; i < fEndOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fEndContainer . getLastChild ( ) ; } else if ( current != fStartContainer ) { deleteCurrent = true ; } } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { if ( endRoot == null ) endRoot = current ; } else { if ( partialNode == null ) { partialNode = parent ; partialInt = BEFORE ; } } if ( parent != root && parent != null ) { next = current . getPreviousSibling ( ) ; Node nextnext ; while ( next != null ) { nextnext = next . getPreviousSibling ( ) ; removeChild ( parent , next ) ; next = nextnext ; } } if ( deleteCurrent ) { removeChild ( parent , current ) ; deleteCurrent = false ; } current = parent ; } current = endRoot . getPreviousSibling ( ) ; Node prev = null ; while ( current != null && current != startRoot ) { prev = current . getPreviousSibling ( ) ; parent = current . getParentNode ( ) ; if ( parent != null ) { removeChild ( parent , current ) ; } current = prev ; } if ( partialNode == null ) { collapse ( true ) ; } else if ( partialInt == AFTER ) { setStartAfter ( partialNode ) ; setEndAfter ( partialNode ) ; } else if ( partialInt == BEFORE ) { setStartBefore ( partialNode ) ; setEndBefore ( partialNode ) ; } } public DocumentFragment extractContents ( ) throws DOMException { return traverseContents ( EXTRACT_CONTENTS ) ; } public DocumentFragment cloneContents ( ) throws DOMException { return traverseContents ( CLONE_CONTENTS ) ; } public void insertNode ( Node newNode ) throws DOMException , RangeException { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } int type = newNode . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_NODE || type == Node . DOCUMENT_FRAGMENT_NODE ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } if ( newNode == null ) return ; Node cloneCurrent ; Node current ; boolean MULTIPLE_MODE = false ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( newNode . getNodeType ( ) != Node . TEXT_NODE ) { cloneCurrent = fStartContainer . cloneNode ( false ) ; ( ( TextImpl ) cloneCurrent ) . setNodeValueInternal ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset ) ) ; ( ( TextImpl ) fStartContainer ) . setNodeValueInternal ( ( fStartContainer . getNodeValue ( ) ) . substring ( 0 , fStartOffset ) ) ; Node next = fStartContainer . getNextSibling ( ) ; if ( next != null ) { Node parent = fStartContainer . getParentNode ( ) ; if ( parent != null ) { parent . insertBefore ( newNode , next ) ; parent . insertBefore ( cloneCurrent , next ) ; } } else { Node parent = fStartContainer . getParentNode ( ) ; if ( parent != null ) { parent . appendChild ( newNode ) ; parent . appendChild ( cloneCurrent ) ; } } signalSplitData ( fStartContainer , cloneCurrent , fStartOffset ) ; } else { String value = fStartContainer . getNodeValue ( ) ; String newValue = newNode . getNodeValue ( ) ; insertData ( ( CharacterData ) fStartContainer , fStartOffset , newValue ) ; } } else { current = fStartContainer . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current != null ) { fStartContainer . insertBefore ( newNode , current ) ; } else { fStartContainer . appendChild ( newNode ) ; } } } public void surroundContents ( Node newParent ) throws DOMException , RangeException { if ( newParent == null ) return ; if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } int type = newParent . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_TYPE_NODE || type == Node . DOCUMENT_NODE || type == Node . DOCUMENT_FRAGMENT_NODE ) { throw new RangeExceptionImpl ( RangeException . INVALID_NODE_TYPE_ERR , "DOM012 Invalid node type" ) ; } Node root = getCommonAncestorContainer ( ) ; Node realStart = fStartContainer ; Node realEnd = fEndContainer ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { realStart = fStartContainer . getParentNode ( ) ; } if ( fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { realEnd = fEndContainer . getParentNode ( ) ; } if ( realStart != realEnd ) { throw new RangeExceptionImpl ( RangeException . BAD_BOUNDARYPOINTS_ERR , "DOM013 Bad boundary points" ) ; } DocumentFragment frag = extractContents ( ) ; insertNode ( newParent ) ; newParent . appendChild ( frag ) ; selectNode ( newParent ) ; } public Range cloneRange ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Range range = fDocument . createRange ( ) ; range . setStart ( fStartContainer , fStartOffset ) ; range . setEnd ( fEndContainer , fEndOffset ) ; return range ; } public String toString ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMException . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } Node node = fStartContainer ; StringBuffer sb = new StringBuffer ( ) ; if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE || fStartContainer . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { if ( fStartContainer == fEndContainer ) { sb . append ( fStartContainer . getNodeValue ( ) . substring ( fStartOffset , fEndOffset ) ) ; return sb . toString ( ) ; } else { sb . append ( fStartContainer . getNodeValue ( ) . substring ( fStartOffset ) ) ; } } while ( node != fEndContainer ) { node = nextNode ( node , true ) ; if ( node == null ) break ; if ( node . getNodeType ( ) == Node . TEXT_NODE || node . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { sb . append ( node . getNodeValue ( ) ) ; } } if ( fEndContainer . getNodeType ( ) == Node . TEXT_NODE || fEndContainer . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { sb . append ( fEndContainer . getNodeValue ( ) . substring ( 0 , fEndOffset ) ) ; } return sb . toString ( ) ; } public void detach ( ) { fDetach = true ; fDocument . removeRange ( this ) ; } void signalSplitData ( Node node , Node newNode , int offset ) { fSplitNode = node ; fDocument . splitData ( node , newNode , offset ) ; fSplitNode = null ; } void receiveSplitData ( Node node , Node newNode , int offset ) { if ( node == null || newNode == null ) return ; if ( fSplitNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fStartOffset > offset ) { fStartOffset = fStartOffset - offset ; fStartContainer = newNode ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fEndOffset > offset ) { fEndOffset = fEndOffset - offset ; fEndContainer = newNode ; } } } void deleteData ( CharacterData node , int offset , int count ) { fDeleteNode = node ; node . deleteData ( offset , count ) ; fDeleteNode = null ; } void receiveDeletedText ( Node node , int offset , int count ) { if ( node == null ) return ; if ( fDeleteNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fStartOffset > offset + count ) { fStartOffset = offset + ( fStartOffset - ( offset + count ) ) ; } else if ( fStartOffset > offset ) { fStartOffset = offset ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( fEndOffset > offset + count ) { fEndOffset = offset + ( fEndOffset - ( offset + count ) ) ; } else if ( fEndOffset > offset ) { fEndOffset = offset ; } } } void insertData ( CharacterData node , int index , String insert ) { fInsertNode = node ; node . insertData ( index , insert ) ; fInsertNode = null ; } void receiveInsertedText ( Node node , int index , int len ) { if ( node == null ) return ; if ( fInsertNode == node ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( index < fStartOffset ) { fStartOffset = fStartOffset + len ; } } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { if ( index < fEndOffset ) { fEndOffset = fEndOffset + len ; } } } void receiveReplacedText ( Node node ) { if ( node == null ) return ; if ( node == fStartContainer && fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { fStartOffset = 0 ; } if ( node == fEndContainer && fEndContainer . getNodeType ( ) == Node . TEXT_NODE ) { fEndOffset = 0 ; } } public void insertedNodeFromDOM ( Node node ) { if ( node == null ) return ; if ( fInsertNode == node ) return ; Node parent = node . getParentNode ( ) ; if ( parent == fStartContainer ) { int index = indexOf ( node , fStartContainer ) ; if ( index < fStartOffset ) { fStartOffset ++ ; } } if ( parent == fEndContainer ) { int index = indexOf ( node , fEndContainer ) ; if ( index < fEndOffset ) { fEndOffset ++ ; } } } Node fRemoveChild = null ; Node removeChild ( Node parent , Node child ) { fRemoveChild = child ; Node n = parent . removeChild ( child ) ; fRemoveChild = null ; return n ; } void removeNode ( Node node ) { if ( node == null ) return ; if ( fRemoveChild == node ) return ; Node parent = node . getParentNode ( ) ; if ( parent == fStartContainer ) { int index = indexOf ( node , fStartContainer ) ; if ( index <= fStartOffset ) { fStartOffset -- ; } } if ( parent == fEndContainer ) { int index = indexOf ( node , fEndContainer ) ; if ( index < fEndOffset ) { fEndOffset -- ; } } if ( parent != fStartContainer && parent != fEndContainer ) { if ( isAncestorOf ( node , fStartContainer ) ) { fStartContainer = parent ; fStartOffset = indexOf ( node , parent ) - 1 ; } if ( isAncestorOf ( node , fEndContainer ) ) { fEndContainer = parent ; fEndOffset = indexOf ( node , parent ) - 1 ; } } } static final int EXTRACT_CONTENTS = 1 ; static final int CLONE_CONTENTS = 2 ; DocumentFragment traverseContents ( int traversalType ) throws DOMException { if ( fStartContainer == null || fEndContainer == null ) { return null ; } DocumentFragment frag = fDocument . createDocumentFragment ( ) ; Node current = fStartContainer ; Node cloneCurrent = null ; Node cloneParent = null ; Node partialNode = null ; int partialInt = START ; Vector d = new Vector ( ) ; if ( fStartContainer == fEndContainer ) { if ( fStartOffset == fEndOffset ) { return frag ; } if ( fStartContainer . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = fStartContainer . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset , fEndOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , fStartOffset , fEndOffset - fStartOffset ) ; } frag . appendChild ( cloneCurrent ) ; } else { current = current . getFirstChild ( ) ; int i = 0 ; for ( i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } int n = fEndOffset - fStartOffset ; for ( i = 0 ; i < n && current != null ; i ++ ) { Node newCurrent = current . getNextSibling ( ) ; if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; frag . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { frag . appendChild ( current ) ; } current = newCurrent ; } } return frag ; } Node root = getCommonAncestorContainer ( ) ; Node parent = null ; current = fStartContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = current . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( fStartOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , fStartOffset , current . getNodeValue ( ) . length ( ) - fStartOffset ) ; } } else { current = current . getFirstChild ( ) ; for ( int i = 0 ; i < fStartOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fStartContainer ; } if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } } Node startRoot = null ; parent = null ; while ( current != root ) { parent = current . getParentNode ( ) ; if ( parent == root ) { cloneParent = frag ; startRoot = current ; } else { if ( parent == null ) System . out . println ( "parent==null: current=" + current ) ; cloneParent = parent . cloneNode ( false ) ; if ( partialNode == null && parent != root ) { partialNode = parent ; partialInt = AFTER ; } } Node next = null ; current = current . getNextSibling ( ) ; cloneParent . appendChild ( cloneCurrent ) ; while ( current != null ) { next = current . getNextSibling ( ) ; if ( current != null && parent != root ) { if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; cloneParent . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneParent . appendChild ( current ) ; } } current = next ; } current = parent ; cloneCurrent = cloneParent ; } Node endRoot = null ; current = fEndContainer ; if ( current . getNodeType ( ) == Node . TEXT_NODE ) { cloneCurrent = current . cloneNode ( false ) ; cloneCurrent . setNodeValue ( ( cloneCurrent . getNodeValue ( ) ) . substring ( 0 , fEndOffset ) ) ; if ( traversalType == EXTRACT_CONTENTS ) { deleteData ( ( CharacterData ) current , 0 , fEndOffset ) ; } } else { if ( fEndOffset == 0 ) { current = fEndContainer ; } else { current = current . getFirstChild ( ) ; for ( int i = 1 ; i < fEndOffset && current != null ; i ++ ) { current = current . getNextSibling ( ) ; } if ( current == null ) { current = fEndContainer . getLastChild ( ) ; } } if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } } while ( current != root && current != null ) { parent = current . getParentNode ( ) ; if ( parent == root ) { cloneParent = frag ; endRoot = current ; } else { cloneParent = parent . cloneNode ( false ) ; if ( partialNode == null && parent != root ) { partialNode = parent ; partialInt = BEFORE ; } } Node holdCurrent = current ; current = parent . getFirstChild ( ) ; cloneParent . appendChild ( cloneCurrent ) ; Node next = null ; while ( current != holdCurrent && current != null ) { next = current . getNextSibling ( ) ; if ( current != null && parent != root ) { if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; cloneParent . appendChild ( cloneCurrent ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneParent . appendChild ( current ) ; } } current = next ; } current = parent ; cloneCurrent = cloneParent ; } d . removeAllElements ( ) ; Node clonedPrevious = frag . getLastChild ( ) ; current = endRoot . getPreviousSibling ( ) ; Node prev = null ; while ( current != startRoot && current != null ) { prev = current . getPreviousSibling ( ) ; if ( traversalType == CLONE_CONTENTS ) { cloneCurrent = current . cloneNode ( true ) ; } else if ( traversalType == EXTRACT_CONTENTS ) { cloneCurrent = current ; } frag . insertBefore ( cloneCurrent , clonedPrevious ) ; current = prev ; clonedPrevious = cloneCurrent ; } if ( traversalType == EXTRACT_CONTENTS ) { if ( partialNode == null ) { collapse ( true ) ; } else if ( partialInt == AFTER ) { setStartAfter ( partialNode ) ; setEndAfter ( partialNode ) ; } else if ( partialInt == BEFORE ) { setStartBefore ( partialNode ) ; setEndBefore ( partialNode ) ; } } return frag ; } void checkIndex ( Node refNode , int offset ) throws DOMException { if ( offset < 0 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } int type = refNode . getNodeType ( ) ; if ( ( type == Node . TEXT_NODE || type == Node . CDATA_SECTION_NODE || type == Node . COMMENT_NODE || type == Node . PROCESSING_INSTRUCTION_NODE ) && offset > refNode . getNodeValue ( ) . length ( ) ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } Node child = refNode . getFirstChild ( ) ; int i = 1 ; for ( ; child != null ; i ++ ) { child = child . getNextSibling ( ) ; } if ( i > offset ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } boolean isAncestorTypeValid ( Node node ) { for ( Node n = node ; n != null ; n = n . getParentNode ( ) ) { int type = n . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE || type == Node . ENTITY_NODE || type == Node . NOTATION_NODE || type == Node . DOCUMENT_TYPE_NODE ) return false ; } return true ; } Node nextNode ( Node node , boolean visitChildren ) { if ( node == null ) return null ; Node result ; if ( visitChildren ) { result = node . getFirstChild ( ) ; if ( result != null ) { return result ; } } result = node . getNextSibling ( ) ; if ( result != null ) { return result ; } Node parent = node . getParentNode ( ) ; while ( parent != null && parent != fDocument ) { result = parent . getNextSibling ( ) ; if ( result != null ) { return result ; } else { parent = parent . getParentNode ( ) ; } } return null ; } boolean isAncestorOf ( Node a , Node b ) { for ( Node node = b ; node != null ; node = node . getParentNode ( ) ) { if ( node == a ) return true ; } return false ; } int indexOf ( Node child , Node parent ) { Node node ; int i = 0 ; if ( child . getParentNode ( ) != parent ) return - 1 ; for ( node = child ; node != null ; node = node . getPreviousSibling ( ) ) { i ++ ; } return i ; } } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . utils . StringPool ; public final class DeferredAttrImpl extends AttrImpl implements DeferredNode { static final long serialVersionUID = 6903232312469148636L ; protected transient int fNodeIndex ; DeferredAttrImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; needsSyncChildren ( true ) ; } public int getNodeIndex ( ) { return fNodeIndex ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; int elementTypeName = ownerDocument . getNodeName ( fNodeIndex ) ; StringPool pool = ownerDocument . getStringPool ( ) ; name = pool . toString ( elementTypeName ) ; isSpecified ( ownerDocument . getNodeValue ( fNodeIndex ) == 1 ) ; } protected void synchronizeChildren ( ) { synchronizeChildren ( fNodeIndex ) ; } } 	0
package org . apache . xerces . jaxp ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xerces . parsers . SAXParser ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public class SAXParserImpl extends javax . xml . parsers . SAXParser { private boolean namespaces = false ; private boolean validation = false ; private Parser parser = null ; private SAXParserImpl ( ) { super ( ) ; } protected SAXParserImpl ( boolean namespaces , boolean validation ) throws ParserConfigurationException { this ( ) ; SAXParser p = new SAXParser ( ) ; try { p . setFeature ( "http://xml.org/sax/features/namespaces" , namespaces ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set namespace " + "awareness to " + namespaces ) ; } try { p . setFeature ( "http://xml.org/sax/features/validation" , validation ) ; } catch ( SAXException e ) { throw new ParserConfigurationException ( "Cannot set validation to " + validation ) ; } this . namespaces = namespaces ; this . validation = validation ; this . parser = p ; } public Parser getParser ( ) { return ( this . parser ) ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLStyleElementImpl extends HTMLElementImpl implements HTMLStyleElement { public boolean getDisabled ( ) { return getBinary ( "disabled" ) ; } public void setDisabled ( boolean disabled ) { setAttribute ( "disabled" , disabled ) ; } public String getMedia ( ) { return getAttribute ( "media" ) ; } public void setMedia ( String media ) { setAttribute ( "media" , media ) ; } public String getType ( ) { return getAttribute ( "type" ) ; } public void setType ( String type ) { setAttribute ( "type" , type ) ; } public HTMLStyleElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package javax . xml . parsers ; import org . xml . sax . SAXException ; public abstract class SAXParserFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.SAXParserFactory" ; private static String factory = "org.apache.xerces.jaxp.SAXParserFactoryImpl" ; protected SAXParserFactory ( ) { super ( ) ; } public static SAXParserFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( SAXParserFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "SAXParserFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified SAXParserFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "SAXParserFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"javax.xml.parsers.SAXParserFactory\"" ) ; } } public abstract SAXParser newSAXParser ( ) throws ParserConfigurationException , SAXException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . ChunkyByteArray ; import org . apache . xerces . utils . ChunkyCharArray ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringHasher ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import java . io . IOException ; final class UCSReader extends XMLEntityReader implements StringPool . StringProducer { private static final boolean DEBUG_UTF16_BIG = false ; static final int E_UCS4B = 0 , E_UCS4L = 1 , E_UCS2B = 2 , E_UCS2L = 3 , E_UCS2B_NOBOM = 4 , E_UCS2L_NOBOM = 5 ; private ChunkyByteArray fData = null ; private int fEncoding = - 1 ; private StringPool fStringPool = null ; private int fBytesPerChar = - 1 ; private boolean fBigEndian = true ; private ChunkyCharArray fStringCharArray = null ; private boolean fCalledCharPropInit = false ; UCSReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , ChunkyByteArray data , int encoding , StringPool stringPool ) throws Exception { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fCurrentOffset = ( encoding == E_UCS2B || encoding == E_UCS2L ) ? 2 : 0 ; fData = data ; fEncoding = encoding ; fStringPool = stringPool ; fBytesPerChar = ( fEncoding == E_UCS4B || fEncoding == E_UCS4L ) ? 4 : 2 ; fBigEndian = fEncoding == E_UCS4B || fEncoding == E_UCS2B || fEncoding == E_UCS2B_NOBOM ; } private int getChar ( int offset ) throws IOException { int b0 = fData . byteAt ( offset ++ ) & 0xff ; if ( b0 == 0xff && fData . atEOF ( offset ) ) return - 1 ; int b1 = fData . byteAt ( offset ++ ) & 0xff ; if ( fBytesPerChar == 4 ) { int b2 = fData . byteAt ( offset ++ ) & 0xff ; int b3 = fData . byteAt ( offset ++ ) & 0xff ; if ( fBigEndian ) return ( b0 << 24 ) + ( b1 << 16 ) + ( b2 << 8 ) + b3 ; else return ( b3 << 24 ) + ( b2 << 16 ) + ( b1 << 8 ) + b0 ; } else { if ( fBigEndian ) return ( b0 << 8 ) + b1 ; else return ( b1 << 8 ) + b0 ; } } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fStringPool . addString ( this , offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fStringPool . addSymbol ( this , offset , length , getHashcode ( offset , length ) ) ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { int endOffset = offset + length ; while ( offset < endOffset ) { int ch ; try { ch = getChar ( offset ) ; } catch ( IOException ex ) { ch = 0 ; } charBuffer . append ( ( char ) ch ) ; offset += fBytesPerChar ; } } public void releaseString ( int offset , int length ) { } public String toString ( int offset , int length ) { if ( fStringCharArray == null ) fStringCharArray = new ChunkyCharArray ( fStringPool ) ; int newOffset = fStringCharArray . length ( ) ; append ( fStringCharArray , offset , length ) ; int newLength = fStringCharArray . length ( ) - newOffset ; int stringIndex = fStringCharArray . addString ( newOffset , newLength ) ; return fStringPool . toString ( stringIndex ) ; } private int getHashcode ( int offset , int length ) { int endOffset = offset + length ; int hashcode = 0 ; while ( offset < endOffset ) { int ch ; try { ch = getChar ( offset ) ; } catch ( IOException ex ) { ch = 0 ; } hashcode = StringHasher . hashChar ( hashcode , ch ) ; offset += fBytesPerChar ; } return StringHasher . finishHash ( hashcode ) ; } public boolean equalsString ( int offset , int length , char [ ] strChars , int strOffset , int strLength ) { int endOffset = offset + length ; int slen = strLength ; while ( offset < endOffset ) { if ( slen -- == 0 ) return false ; int ch ; try { ch = getChar ( offset ) ; } catch ( IOException ex ) { ch = 0 ; } if ( ch != strChars [ strOffset ++ ] ) return false ; offset += fBytesPerChar ; } return slen == 0 ; } private static char [ ] fCharacters = new char [ 256 ] ; private int fCharDataLength = 0 ; private void appendCharData ( int ch ) { if ( fCharacters . length == fCharDataLength ) { char [ ] newchars = new char [ fCharacters . length * 2 ] ; System . arraycopy ( fCharacters , 0 , newchars , 0 , fCharacters . length ) ; fCharacters = newchars ; } fCharacters [ fCharDataLength ++ ] = ( char ) ch ; } public void callCharDataHandler ( int offset , int length , boolean isWhitespace ) throws Exception { int endOffset = offset + length ; boolean skiplf = false ; while ( offset < endOffset ) { int ch = getChar ( offset ) ; if ( skiplf ) { skiplf = false ; if ( ch == 0x0A ) { offset += fBytesPerChar ; continue ; } } if ( ch == 0x0D ) { skiplf = true ; ch = 0x0A ; } appendCharData ( ch ) ; offset += fBytesPerChar ; } if ( fSendCharDataAsCharArray ) { if ( isWhitespace ) fCharDataHandler . processWhitespace ( fCharacters , 0 , fCharDataLength ) ; else fCharDataHandler . processCharacters ( fCharacters , 0 , fCharDataLength ) ; } else { int stringIndex = fStringPool . addString ( new String ( fCharacters , 0 , fCharDataLength ) ) ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( stringIndex ) ; else fCharDataHandler . processCharacters ( stringIndex ) ; } fCharDataLength = 0 ; } public boolean lookingAtChar ( char ch , boolean skipPastChar ) throws Exception { int ch2 = getChar ( fCurrentOffset ) ; if ( ch2 == ch ) { if ( skipPastChar ) { fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; } return true ; } return false ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int ch = getChar ( fCurrentOffset ) ; if ( ch < 0x20 ) { if ( ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { if ( ! skipPastChar ) return true ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == - 1 ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } return false ; } fCurrentOffset += fBytesPerChar ; return true ; } if ( ch <= 0xD7FF ) { if ( skipPastChar ) { fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; } return true ; } if ( ch <= 0xDFFF ) { if ( skipPastChar ) { fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; } return true ; } if ( ch <= 0xFFFD ) { if ( skipPastChar ) { fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; } return true ; } return false ; } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = getChar ( fCurrentOffset ) ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { if ( ! skipPastChar ) return true ; fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == - 1 ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } return false ; } fCurrentOffset += fBytesPerChar ; return true ; } public void skipToChar ( char chr ) throws Exception { while ( true ) { int ch = getChar ( fCurrentOffset ) ; if ( ch == chr ) return ; if ( ch == - 1 ) { changeReaders ( ) . skipToChar ( chr ) ; return ; } if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else if ( ch >= 0xD800 && ch < 0xDC00 ) { fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; ch = getChar ( fCurrentOffset ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) continue ; } else fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; } } public void skipPastSpaces ( ) throws Exception { while ( true ) { int ch = getChar ( fCurrentOffset ) ; if ( ch > 0x20 ) return ; if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == - 1 ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } fCurrentOffset += fBytesPerChar ; } } public void skipPastName ( char fastcheck ) throws Exception { int ch = getChar ( fCurrentOffset ) ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return ; while ( true ) { fCurrentOffset += fBytesPerChar ; fCharacterCounter ++ ; ch = getChar ( fCurrentOffset ) ; if ( fastcheck == ch ) return ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int ch = getChar ( fCurrentOffset ) ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } while ( true ) { if ( fastcheck == ch ) return ; if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; fCurrentOffset += fBytesPerChar ; fCharacterCounter ++ ; ch = getChar ( fCurrentOffset ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int offset = fCurrentOffset ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( getChar ( offset ) != s [ i ] ) return false ; offset += fBytesPerChar ; } fCurrentOffset = offset ; fCharacterCounter += s . length ; return true ; } public int scanInvalidChar ( ) throws Exception { int ch = getChar ( fCurrentOffset ) ; if ( ch == - 1 ) { return changeReaders ( ) . scanInvalidChar ( ) ; } fCurrentOffset += fBytesPerChar ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else { fCharacterCounter ++ ; if ( ch >= 0xD800 && ch < 0xDC00 ) { int ch2 = getChar ( fCurrentOffset ) ; if ( ch2 >= 0xDC00 && ch2 < 0xE000 ) { ch = ( ( ch - 0xD800 ) << 10 ) + ( ch2 - 0xDC00 ) + 0x10000 ; fCurrentOffset += fBytesPerChar ; } } } return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = getChar ( fCurrentOffset ) ; if ( ch == - 1 ) { return changeReaders ( ) . scanCharRef ( hex ) ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; boolean toobig = false ; while ( true ) { ch = getChar ( fCurrentOffset ) ; if ( ch == - 1 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( lookingAtChar ( qchar , false ) ) { break ; } if ( lookingAtChar ( ' ' , true ) ) { continue ; } if ( lookingAtSpace ( false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '<' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } int result = asSymbol ? addSymbol ( offset , fCurrentOffset - offset ) : addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return result ; } public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( qchar != - 1 && lookingAtChar ( ( char ) qchar , false ) ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; break ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; } if ( lookingAtChar ( '%' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } int result = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( ( char ) qchar , true ) ; return result ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { int nameOffset = fCurrentOffset ; skipPastName ( fastcheck ) ; int nameLength = fCurrentOffset - nameOffset ; if ( nameLength == 0 ) return false ; int nameIndex = addSymbol ( nameOffset , nameLength ) ; return true ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int nameOffset = fCurrentOffset ; skipPastName ( fastcheck ) ; int nameLength = fCurrentOffset - nameOffset ; if ( nameLength == 0 ) { qname . clear ( ) ; return ; } qname . prefix = - 1 ; qname . localpart = - 1 ; qname . rawname = addSymbol ( nameOffset , nameLength ) ; qname . uri = - 1 ; } public int scanName ( char fastcheck ) throws Exception { int nameOffset = fCurrentOffset ; skipPastName ( fastcheck ) ; int nameLength = fCurrentOffset - nameOffset ; if ( nameLength == 0 ) return - 1 ; int nameIndex = addSymbol ( nameOffset , nameLength ) ; return nameIndex ; } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private int recognizeMarkup ( ) throws Exception { int ch = getChar ( fCurrentOffset ) ; switch ( ch ) { case - 1 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; ch = getChar ( fCurrentOffset ) ; if ( ch == - 1 ) { fCharacterCounter -- ; fCurrentOffset -= fBytesPerChar ; ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; ch = getChar ( fCurrentOffset ) ; if ( ch == - 1 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( ch == '[' ) { fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; for ( int i = 0 ; i < 6 ; i ++ ) { ch = getChar ( fCurrentOffset ) ; if ( ch == - 1 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( ( 2 + i ) * fBytesPerChar ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; } return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( ) throws Exception { int ch = getChar ( fCurrentOffset ) ; if ( ch == - 1 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } public int scanContent ( QName element ) throws Exception { int offset = fCurrentOffset ; int ch = getChar ( fCurrentOffset ) ; fCurrentOffset += fBytesPerChar ; byte prop ; if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ch < 0x80 ) { if ( ch == - 1 ) { fCurrentOffset -= fBytesPerChar ; return changeReaders ( ) . scanContent ( element ) ; } prop = XMLCharacterProperties . fgCharFlags [ ch ] ; if ( ( prop & XMLCharacterProperties . E_CharDataFlag ) == 0 && ch != 0x0A && ch != 0x0D ) { if ( ch == '<' ) { fCharacterCounter ++ ; if ( ! fInCDSect ) { return recognizeMarkup ( ) ; } } else if ( ch == '&' ) { fCharacterCounter ++ ; if ( ! fInCDSect ) { return recognizeReference ( ) ; } } else if ( ch == ']' ) { if ( getChar ( fCurrentOffset ) == ']' && getChar ( fCurrentOffset + fBytesPerChar ) == '>' ) { fCharacterCounter += 3 ; fCurrentOffset += ( 2 * fBytesPerChar ) ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; } } else { fCurrentOffset -= fBytesPerChar ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ch == 0x20 || ch == 0x09 || ch == 0x0A || ch == 0x0D ) { do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else { fCharacterCounter ++ ; } ch = getChar ( fCurrentOffset ) ; fCurrentOffset += fBytesPerChar ; } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A || ch == 0x0D ) ; if ( ch < 0x80 ) { if ( ch == - 1 ) { fCurrentOffset -= fBytesPerChar ; callCharDataHandler ( offset , fCurrentOffset - offset , true ) ; return changeReaders ( ) . scanContent ( element ) ; } prop = XMLCharacterProperties . fgCharFlags [ ch ] ; if ( ( prop & XMLCharacterProperties . E_CharDataFlag ) == 0 ) { if ( ch == '<' ) { if ( ! fInCDSect ) { callCharDataHandler ( offset , ( fCurrentOffset - fBytesPerChar ) - offset , true ) ; fCharacterCounter ++ ; return recognizeMarkup ( ) ; } fCharacterCounter ++ ; } else if ( ch == '&' ) { if ( ! fInCDSect ) { callCharDataHandler ( offset , ( fCurrentOffset - fBytesPerChar ) - offset , true ) ; fCharacterCounter ++ ; return recognizeReference ( ) ; } fCharacterCounter ++ ; } else if ( ch == ']' ) { if ( getChar ( fCurrentOffset ) == ']' && getChar ( fCurrentOffset + fBytesPerChar ) == '>' ) { callCharDataHandler ( offset , ( fCurrentOffset - fBytesPerChar ) - offset , true ) ; fCharacterCounter += 3 ; fCurrentOffset += ( 2 * fBytesPerChar ) ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; } } else { fCurrentOffset -= fBytesPerChar ; callCharDataHandler ( offset , fCurrentOffset - offset , true ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } } else { if ( ch >= 0xD800 && ch <= 0xDFFF ) { fCurrentOffset += fBytesPerChar ; } else if ( ch == 0xFFFE || ch == 0xFFFF ) { fCurrentOffset -= fBytesPerChar ; callCharDataHandler ( offset , fCurrentOffset - offset , true ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } } } else { if ( ch >= 0xD800 && ch <= 0xDFFF ) { fCurrentOffset += fBytesPerChar ; } else if ( ch == 0xFFFE || ch == 0xFFFF ) { fCurrentOffset -= fBytesPerChar ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } fCharacterCounter ++ ; while ( true ) { ch = getChar ( fCurrentOffset ) ; fCurrentOffset += fBytesPerChar ; if ( ch >= 0x80 || ch < 0 ) break ; prop = XMLCharacterProperties . fgCharFlags [ ch ] ; if ( ( prop & XMLCharacterProperties . E_CharDataFlag ) == 0 ) { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else break ; } else fCharacterCounter ++ ; } while ( true ) { if ( ch < 0x80 ) { if ( ch == - 1 ) { fCurrentOffset -= fBytesPerChar ; callCharDataHandler ( offset , fCurrentOffset - offset , false ) ; return changeReaders ( ) . scanContent ( element ) ; } prop = XMLCharacterProperties . fgCharFlags [ ch ] ; if ( ( prop & XMLCharacterProperties . E_CharDataFlag ) == 0 ) { if ( ch == '<' ) { if ( ! fInCDSect ) { callCharDataHandler ( offset , ( fCurrentOffset - fBytesPerChar ) - offset , false ) ; fCharacterCounter ++ ; return recognizeMarkup ( ) ; } fCharacterCounter ++ ; } else if ( ch == '&' ) { if ( ! fInCDSect ) { callCharDataHandler ( offset , ( fCurrentOffset - fBytesPerChar ) - offset , false ) ; fCharacterCounter ++ ; return recognizeReference ( ) ; } fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == 0x0D ) { fCarriageReturnCounter ++ ; fCharacterCounter = 1 ; } else if ( ch == ']' ) { if ( getChar ( fCurrentOffset ) == ']' && getChar ( fCurrentOffset + fBytesPerChar ) == '>' ) { callCharDataHandler ( offset , ( fCurrentOffset - fBytesPerChar ) - offset , false ) ; fCharacterCounter += 3 ; fCurrentOffset += ( 2 * fBytesPerChar ) ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; } fCharacterCounter ++ ; } else { fCurrentOffset -= fBytesPerChar ; callCharDataHandler ( offset , fCurrentOffset - offset , false ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { fCharacterCounter ++ ; } } else { if ( ch >= 0xD800 && ch <= 0xDFFF ) { fCharacterCounter ++ ; fCurrentOffset += fBytesPerChar ; } else if ( ch == 0xFFFE || ch == 0xFFFF ) { fCurrentOffset -= fBytesPerChar ; callCharDataHandler ( offset , fCurrentOffset - offset , false ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } fCharacterCounter ++ ; } ch = getChar ( fCurrentOffset ) ; fCurrentOffset += fBytesPerChar ; } } } 	0
package org . apache . xerces . framework ; public class Version { public static String fVersion = "Xerces 1.2.0" ; public static void main ( String argv [ ] ) { System . out . println ( fVersion ) ; } } 	1
package org . xml . sax . helpers ; import java . lang . ClassNotFoundException ; import java . lang . IllegalAccessException ; import java . lang . InstantiationException ; import java . lang . SecurityException ; import java . lang . ClassCastException ; import org . xml . sax . Parser ; public class ParserFactory { private ParserFactory ( ) { } public static Parser makeParser ( ) throws ClassNotFoundException , IllegalAccessException , InstantiationException , NullPointerException , ClassCastException { String className = System . getProperty ( "org.xml.sax.parser" ) ; if ( className == null ) { throw new NullPointerException ( "No value for sax.parser property" ) ; } else { return makeParser ( className ) ; } } public static Parser makeParser ( String className ) throws ClassNotFoundException , IllegalAccessException , InstantiationException , ClassCastException { return ( Parser ) ( Class . forName ( className ) . newInstance ( ) ) ; } } 	0
package org . w3c . dom ; public interface CDATASection extends Text { } 	1
package org . w3c . dom . html ; public interface HTMLAppletElement extends HTMLElement { public String getAlign ( ) ; public void setAlign ( String align ) ; public String getAlt ( ) ; public void setAlt ( String alt ) ; public String getArchive ( ) ; public void setArchive ( String archive ) ; public String getCode ( ) ; public void setCode ( String code ) ; public String getCodeBase ( ) ; public void setCodeBase ( String codeBase ) ; public String getHeight ( ) ; public void setHeight ( String height ) ; public String getHspace ( ) ; public void setHspace ( String hspace ) ; public String getName ( ) ; public void setName ( String name ) ; public String getObject ( ) ; public void setObject ( String object ) ; public String getVspace ( ) ; public void setVspace ( String vspace ) ; public String getWidth ( ) ; public void setWidth ( String width ) ; } 	0
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . utils . QName ; import org . apache . xerces . validators . schema . EquivClassComparator ; public class DFAContentModel implements XMLContentModel { private static final int EPSILON = - 2 ; private static final int EOC = - 3 ; private static final boolean DEBUG_VALIDATE_CONTENT = false ; private EquivClassComparator comparator = null ; private QName fElemMap [ ] = null ; private int fElemMapType [ ] = null ; private int fElemMapSize = 0 ; private boolean fDTD ; private int fEOCIndex = 0 ; private int fEOCPos = 0 ; private int fEpsilonIndex = 0 ; private boolean fFinalStateFlags [ ] = null ; private CMStateSet fFollowList [ ] = null ; private CMNode fHeadNode = null ; private int fLeafCount = 0 ; private CMLeaf fLeafList [ ] = null ; private int fLeafListType [ ] = null ; private ContentLeafNameTypeVector fLeafNameTypeVector = null ; private int fTransTable [ ] [ ] = null ; private int fTransTableSize = 0 ; private boolean fEmptyContentIsValid = false ; private QName fQName = new QName ( ) ; public DFAContentModel ( CMNode syntaxTree , int leafCount ) throws CMException { this ( syntaxTree , leafCount , false ) ; } public DFAContentModel ( CMNode syntaxTree , int leafCount , boolean dtd ) throws CMException { fLeafCount = leafCount ; fEpsilonIndex = EPSILON ; fEOCIndex = EOC ; fDTD = dtd ; buildDFA ( syntaxTree ) ; } public int validateContent ( QName children [ ] , int offset , int length ) throws CMException { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "DFAContentModel#validateContent" ) ; if ( length == 0 ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! no children" ) ; System . out . println ( "elemMap=" + fElemMap ) ; for ( int i = 0 ; i < fElemMap . length ; i ++ ) { int uriIndex = fElemMap [ i ] . uri ; int localpartIndex = fElemMap [ i ] . localpart ; } System . out . println ( "EOCIndex=" + fEOCIndex ) ; } return fEmptyContentIsValid ? - 1 : 0 ; } int curState = 0 ; for ( int childIndex = 0 ; childIndex < length ; childIndex ++ ) { final QName curElem = children [ offset + childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { int type = fElemMapType [ elemIndex ] & 0x0f ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fDTD ) { if ( fElemMap [ elemIndex ] . rawname == curElem . rawname ) { break ; } } else { if ( fElemMap [ elemIndex ] . uri == curElem . uri && fElemMap [ elemIndex ] . localpart == curElem . localpart ) break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ elemIndex ] . uri ; if ( uri == - 1 || uri == curElem . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( curElem . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ elemIndex ] . uri != curElem . uri ) { break ; } } } if ( elemIndex == fElemMapSize ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! didn't find it" ) ; System . out . println ( "curElem : " + curElem ) ; for ( int i = 0 ; i < fElemMapSize ; i ++ ) { System . out . println ( "fElemMap[" + i + "] = " + fElemMap [ i ] ) ; System . out . println ( "fElemMapType[" + i + "] = " + fElemMapType [ i ] ) ; } } return childIndex ; } curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "!!! not a legal transition" ) ; return childIndex ; } } if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "curState=" + curState + ", childCount=" + length ) ; if ( ! fFinalStateFlags [ curState ] ) return length ; return - 1 ; } private boolean isEqual ( QName name1 , QName name2 ) { return name1 . localpart == name2 . localpart && name1 . uri == name2 . uri ; } public int validateContentSpecial ( QName children [ ] , int offset , int length ) throws Exception { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "DFAContentModel#validateContentSpecial" ) ; if ( comparator == null ) { return validateContent ( children , offset , length ) ; } if ( length == 0 ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! no children" ) ; System . out . println ( "elemMap=" + fElemMap ) ; for ( int i = 0 ; i < fElemMap . length ; i ++ ) { int uriIndex = fElemMap [ i ] . uri ; int localpartIndex = fElemMap [ i ] . localpart ; } System . out . println ( "EOCIndex=" + fEOCIndex ) ; } return fEmptyContentIsValid ? - 1 : 0 ; } int curState = 0 ; for ( int childIndex = 0 ; childIndex < length ; childIndex ++ ) { final QName curElem = children [ offset + childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { int type = fElemMapType [ elemIndex ] & 0x0f ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( comparator . isEquivalentTo ( curElem , fElemMap [ elemIndex ] ) ) break ; } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ elemIndex ] . uri ; if ( uri == - 1 || uri == curElem . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( curElem . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ elemIndex ] . uri != curElem . uri ) { break ; } } } if ( elemIndex == fElemMapSize ) { if ( DEBUG_VALIDATE_CONTENT ) { System . out . println ( "!!! didn't find it" ) ; System . out . println ( "curElem : " + curElem ) ; for ( int i = 0 ; i < fElemMapSize ; i ++ ) { System . out . println ( "fElemMap[" + i + "] = " + fElemMap [ i ] ) ; System . out . println ( "fElemMapType[" + i + "] = " + fElemMapType [ i ] ) ; } } return childIndex ; } curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) { if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "!!! not a legal transition" ) ; return childIndex ; } } if ( DEBUG_VALIDATE_CONTENT ) System . out . println ( "curState=" + curState + ", childCount=" + length ) ; if ( ! fFinalStateFlags [ curState ] ) return length ; return - 1 ; } public void setEquivClassComparator ( EquivClassComparator comparator ) { this . comparator = comparator ; } public int whatCanGoHere ( boolean fullyValid , InsertableElementsInfo info ) throws CMException { int curState = 0 ; for ( int childIndex = 0 ; childIndex < info . insertAt ; childIndex ++ ) { final QName curElem = info . curChildren [ childIndex ] ; int elemIndex = 0 ; for ( ; elemIndex < fElemMapSize ; elemIndex ++ ) { if ( fElemMap [ elemIndex ] . uri == curElem . uri && fElemMap [ elemIndex ] . localpart == curElem . localpart ) break ; } if ( elemIndex == fElemMapSize ) return childIndex ; curState = fTransTable [ curState ] [ elemIndex ] ; if ( curState == - 1 ) return childIndex ; } final int insertState = curState ; info . canHoldPCData = false ; info . isValidEOC = fFinalStateFlags [ insertState ] ; info . resultsCount = fElemMapSize ; if ( ( info . results == null ) || ( info . results . length < info . resultsCount ) ) info . results = new boolean [ info . resultsCount ] ; if ( ( info . possibleChildren == null ) || ( info . possibleChildren . length < info . resultsCount ) ) { info . possibleChildren = new QName [ info . resultsCount ] ; for ( int i = 0 ; i < info . possibleChildren . length ; i ++ ) { info . possibleChildren [ i ] = new QName ( ) ; } } for ( int index = 0 ; index < fElemMapSize ; index ++ ) { info . possibleChildren [ index ] . setValues ( fElemMap [ index ] ) ; info . results [ index ] = ( fTransTable [ insertState ] [ index ] != - 1 ) ; } if ( fullyValid ) { for ( int index = 0 ; index < info . resultsCount ; index ++ ) { if ( ! info . results [ index ] ) continue ; info . curChildren [ info . insertAt ] = info . possibleChildren [ index ] ; if ( validateContent ( info . curChildren , 0 , info . childCount ) != - 1 ) info . results [ index ] = false ; } } return - 1 ; } public ContentLeafNameTypeVector getContentLeafNameTypeVector ( ) { return fLeafNameTypeVector ; } private void buildDFA ( CMNode syntaxTree ) throws CMException { fQName . setValues ( - 1 , fEOCIndex , fEOCIndex ) ; CMLeaf nodeEOC = new CMLeaf ( fQName ) ; fHeadNode = new CMBinOp ( XMLContentSpec . CONTENTSPECNODE_SEQ , syntaxTree , nodeEOC ) ; fEOCPos = fLeafCount ; nodeEOC . setPosition ( fLeafCount ++ ) ; fLeafList = new CMLeaf [ fLeafCount ] ; fLeafListType = new int [ fLeafCount ] ; postTreeBuildInit ( fHeadNode , 0 ) ; fFollowList = new CMStateSet [ fLeafCount ] ; for ( int index = 0 ; index < fLeafCount ; index ++ ) fFollowList [ index ] = new CMStateSet ( fLeafCount ) ; calcFollowList ( fHeadNode ) ; fElemMap = new QName [ fLeafCount ] ; fElemMapType = new int [ fLeafCount ] ; fElemMapSize = 0 ; for ( int outIndex = 0 ; outIndex < fLeafCount ; outIndex ++ ) { fElemMap [ outIndex ] = new QName ( ) ; if ( ( fLeafListType [ outIndex ] & 0x0f ) != 0 ) { if ( fLeafNameTypeVector == null ) { fLeafNameTypeVector = new ContentLeafNameTypeVector ( ) ; } } final QName element = fLeafList [ outIndex ] . getElement ( ) ; int inIndex = 0 ; for ( ; inIndex < fElemMapSize ; inIndex ++ ) { if ( fDTD ) { if ( fElemMap [ inIndex ] . rawname == element . rawname ) { break ; } } else { if ( fElemMap [ inIndex ] . uri == element . uri && fElemMap [ inIndex ] . localpart == element . localpart && fElemMapType [ inIndex ] == fLeafListType [ outIndex ] ) break ; } } if ( inIndex == fElemMapSize ) { fElemMap [ fElemMapSize ] . setValues ( element ) ; fElemMapType [ fElemMapSize ] = fLeafListType [ outIndex ] ; fElemMapSize ++ ; } } if ( fLeafNameTypeVector != null ) { fLeafNameTypeVector . setValues ( fElemMap , fElemMapType , fElemMapSize ) ; } int curArraySize = fLeafCount * 4 ; CMStateSet [ ] statesToDo = new CMStateSet [ curArraySize ] ; fFinalStateFlags = new boolean [ curArraySize ] ; fTransTable = new int [ curArraySize ] [ ] ; CMStateSet setT = fHeadNode . firstPos ( ) ; int unmarkedState = 0 ; int curState = 0 ; fTransTable [ curState ] = makeDefStateList ( ) ; statesToDo [ curState ] = setT ; curState ++ ; while ( unmarkedState < curState ) { setT = statesToDo [ unmarkedState ] ; int [ ] transEntry = fTransTable [ unmarkedState ] ; fFinalStateFlags [ unmarkedState ] = setT . getBit ( fEOCPos ) ; unmarkedState ++ ; CMStateSet newSet = null ; for ( int elemIndex = 0 ; elemIndex < fElemMapSize ; elemIndex ++ ) { if ( newSet == null ) newSet = new CMStateSet ( fLeafCount ) ; else newSet . zeroBits ( ) ; for ( int leafIndex = 0 ; leafIndex < fLeafCount ; leafIndex ++ ) { if ( setT . getBit ( leafIndex ) ) { final QName leaf = fLeafList [ leafIndex ] . getElement ( ) ; final QName element = fElemMap [ elemIndex ] ; if ( fDTD ) { if ( leaf . rawname == element . rawname ) { newSet . union ( fFollowList [ leafIndex ] ) ; } } else { if ( leaf . uri == element . uri && leaf . localpart == element . localpart ) newSet . union ( fFollowList [ leafIndex ] ) ; } } } if ( ! newSet . isEmpty ( ) ) { int stateIndex = 0 ; for ( ; stateIndex < curState ; stateIndex ++ ) { if ( statesToDo [ stateIndex ] . isSameSet ( newSet ) ) break ; } if ( stateIndex == curState ) { statesToDo [ curState ] = newSet ; fTransTable [ curState ] = makeDefStateList ( ) ; curState ++ ; newSet = null ; } transEntry [ elemIndex ] = stateIndex ; if ( curState == curArraySize ) { final int newSize = ( int ) ( curArraySize * 1.5 ) ; CMStateSet [ ] newToDo = new CMStateSet [ newSize ] ; boolean [ ] newFinalFlags = new boolean [ newSize ] ; int [ ] [ ] newTransTable = new int [ newSize ] [ ] ; for ( int expIndex = 0 ; expIndex < curArraySize ; expIndex ++ ) { newToDo [ expIndex ] = statesToDo [ expIndex ] ; newFinalFlags [ expIndex ] = fFinalStateFlags [ expIndex ] ; newTransTable [ expIndex ] = fTransTable [ expIndex ] ; } curArraySize = newSize ; statesToDo = newToDo ; fFinalStateFlags = newFinalFlags ; fTransTable = newTransTable ; } } } } fEmptyContentIsValid = ( ( CMBinOp ) fHeadNode ) . getLeft ( ) . isNullable ( ) ; if ( DEBUG_VALIDATE_CONTENT ) dumpTree ( fHeadNode , 0 ) ; fHeadNode = null ; fLeafList = null ; fFollowList = null ; } private void calcFollowList ( CMNode nodeCur ) throws CMException { if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) { calcFollowList ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( CMBinOp ) nodeCur ) . getRight ( ) ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) { calcFollowList ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( CMBinOp ) nodeCur ) . getRight ( ) ) ; final CMStateSet last = ( ( CMBinOp ) nodeCur ) . getLeft ( ) . lastPos ( ) ; final CMStateSet first = ( ( CMBinOp ) nodeCur ) . getRight ( ) . firstPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { calcFollowList ( ( ( CMUniOp ) nodeCur ) . getChild ( ) ) ; final CMStateSet first = nodeCur . firstPos ( ) ; final CMStateSet last = nodeCur . lastPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE ) || ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE ) ) { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } } private void dumpTree ( CMNode nodeCur , int level ) throws CMException { for ( int index = 0 ; index < level ; index ++ ) System . out . print ( "   " ) ; int type = nodeCur . type ( ) ; if ( ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( type == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { if ( type == XMLContentSpec . CONTENTSPECNODE_CHOICE ) System . out . print ( "Choice Node " ) ; else System . out . print ( "Seq Node " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( "Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; dumpTree ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) , level + 1 ) ; dumpTree ( ( ( CMBinOp ) nodeCur ) . getRight ( ) , level + 1 ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { System . out . print ( "Rep Node " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( "Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; dumpTree ( ( ( CMUniOp ) nodeCur ) . getChild ( ) , level + 1 ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { System . out . print ( "Leaf: (pos=" + ( ( CMLeaf ) nodeCur ) . getPosition ( ) + "), " + ( ( CMLeaf ) nodeCur ) . getElement ( ) + "(elemIndex=" + ( ( CMLeaf ) nodeCur ) . getElement ( ) + ") " ) ; if ( nodeCur . isNullable ( ) ) System . out . print ( " Nullable " ) ; System . out . print ( "firstPos=" ) ; System . out . print ( nodeCur . firstPos ( ) . toString ( ) ) ; System . out . print ( " lastPos=" ) ; System . out . println ( nodeCur . lastPos ( ) . toString ( ) ) ; } else { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } } private int [ ] makeDefStateList ( ) { int [ ] retArray = new int [ fElemMapSize ] ; for ( int index = 0 ; index < fElemMapSize ; index ++ ) retArray [ index ] = - 1 ; return retArray ; } private int postTreeBuildInit ( CMNode nodeCur , int curIndex ) throws CMException { nodeCur . setMaxStates ( fLeafCount ) ; if ( ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY || ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL || ( nodeCur . type ( ) & 0x0f ) == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { QName qname = new QName ( - 1 , - 1 , - 1 , ( ( CMAny ) nodeCur ) . getURI ( ) ) ; fLeafList [ curIndex ] = new CMLeaf ( qname , ( ( CMAny ) nodeCur ) . getPosition ( ) ) ; fLeafListType [ curIndex ] = nodeCur . type ( ) ; curIndex ++ ; } else if ( ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_CHOICE ) || ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_SEQ ) ) { curIndex = postTreeBuildInit ( ( ( CMBinOp ) nodeCur ) . getLeft ( ) , curIndex ) ; curIndex = postTreeBuildInit ( ( ( CMBinOp ) nodeCur ) . getRight ( ) , curIndex ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE ) { curIndex = postTreeBuildInit ( ( ( CMUniOp ) nodeCur ) . getChild ( ) , curIndex ) ; } else if ( nodeCur . type ( ) == XMLContentSpec . CONTENTSPECNODE_LEAF ) { final QName node = ( ( CMLeaf ) nodeCur ) . getElement ( ) ; if ( node . localpart != fEpsilonIndex ) { fLeafList [ curIndex ] = ( CMLeaf ) nodeCur ; fLeafListType [ curIndex ] = XMLContentSpec . CONTENTSPECNODE_LEAF ; curIndex ++ ; } } else { throw new CMException ( ImplementationMessages . VAL_NIICM ) ; } return curIndex ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLMapElementImpl extends HTMLElementImpl implements HTMLMapElement { public HTMLCollection getAreas ( ) { if ( _areas == null ) _areas = new HTMLCollectionImpl ( this , HTMLCollectionImpl . AREA ) ; return _areas ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public HTMLMapElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } private HTMLCollection _areas ; } 	0
package org . apache . xerces . validators . common ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLDocumentScanner ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . readers . DefaultEntityHandler ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . ChunkyCharArray ; import org . apache . xerces . utils . Hash2intTable ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . XMLMessages ; import org . apache . xerces . utils . ImplementationMessages ; import org . apache . xerces . parsers . DOMParser ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . InputSource ; import org . xml . sax . EntityResolver ; import org . xml . sax . Locator ; import org . xml . sax . helpers . LocatorImpl ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xerces . validators . dtd . DTDGrammar ; import org . apache . xerces . validators . schema . EquivClassComparator ; import org . apache . xerces . validators . schema . SchemaGrammar ; import org . apache . xerces . validators . schema . SchemaMessageProvider ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . schema . TraverseSchema ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . validators . datatype . StateMessageDatatype ; import org . apache . xerces . validators . datatype . IDREFDatatypeValidator ; import org . apache . xerces . validators . datatype . IDDatatypeValidator ; import org . apache . xerces . validators . datatype . ENTITYDatatypeValidator ; public final class XMLValidator implements DefaultEntityHandler . EventHandler , XMLEntityHandler . CharDataHandler , XMLDocumentScanner . EventHandler , NamespacesScope . NamespacesHandler { private static final boolean PRINT_EXCEPTION_STACK_TRACE = false ; private static final boolean DEBUG_PRINT_ATTRIBUTES = false ; private static final boolean DEBUG_PRINT_CONTENT = false ; private static final boolean DEBUG_SCHEMA_VALIDATION = false ; private static final boolean DEBUG_ELEMENT_CHILDREN = false ; private static final int CHUNK_SHIFT = 8 ; private static final int CHUNK_SIZE = ( 1 << CHUNK_SHIFT ) ; private static final int CHUNK_MASK = CHUNK_SIZE - 1 ; private static final int INITIAL_CHUNK_COUNT = ( 1 << ( 10 - CHUNK_SHIFT ) ) ; private Hashtable fIdDefs = null ; private StateMessageDatatype fStoreIDRef = new StateMessageDatatype ( ) { private Hashtable fIdDefs ; public Object getDatatypeObject ( ) { return ( Object ) fIdDefs ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_STORE ; } public void setDatatypeObject ( Object data ) { fIdDefs = ( Hashtable ) data ; } } ; private StateMessageDatatype fResetID = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDDatatypeValidator . ID_CLEAR ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fResetIDRef = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_CLEAR ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fValidateIDRef = new StateMessageDatatype ( ) { public Object getDatatypeObject ( ) { return ( Object ) null ; } public int getDatatypeState ( ) { return IDREFDatatypeValidator . IDREF_VALIDATE ; } public void setDatatypeObject ( Object data ) { } } ; private StateMessageDatatype fValidateENTITYMsg = new StateMessageDatatype ( ) { private Object packagedMessage = null ; public Object getDatatypeObject ( ) { return packagedMessage ; } public int getDatatypeState ( ) { return ENTITYDatatypeValidator . ENTITY_INITIALIZE ; } public void setDatatypeObject ( Object data ) { packagedMessage = data ; } } ; private AttributeValidator fAttValidatorNOTATION = new AttValidatorNOTATION ( ) ; private AttributeValidator fAttValidatorENUMERATION = new AttValidatorENUMERATION ( ) ; private AttributeValidator fAttValidatorDATATYPE = null ; StringPool fStringPool = null ; boolean fValidating = false ; boolean fInElementContent = false ; int fStandaloneReader = - 1 ; private boolean fValidationEnabled = false ; private boolean fDynamicValidation = false ; private boolean fSchemaValidation = true ; private boolean fValidationEnabledByDynamic = false ; private boolean fDynamicDisabledByValidation = false ; private boolean fWarningOnDuplicateAttDef = false ; private boolean fWarningOnUndeclaredElements = false ; private boolean fLoadDTDGrammar = true ; private int fDeclaration [ ] ; private XMLErrorReporter fErrorReporter = null ; private DefaultEntityHandler fEntityHandler = null ; private QName fCurrentElement = new QName ( ) ; private ContentLeafNameTypeVector [ ] fContentLeafStack = new ContentLeafNameTypeVector [ 8 ] ; private int [ ] fValidationFlagStack = new int [ 8 ] ; private int [ ] fScopeStack = new int [ 8 ] ; private int [ ] fGrammarNameSpaceIndexStack = new int [ 8 ] ; private int [ ] fElementEntityStack = new int [ 8 ] ; private int [ ] fElementIndexStack = new int [ 8 ] ; private int [ ] fContentSpecTypeStack = new int [ 8 ] ; private static final int sizeQNameParts = 8 ; private QName [ ] fElementQNamePartsStack = new QName [ sizeQNameParts ] ; private QName [ ] fElementChildren = new QName [ 32 ] ; private int fElementChildrenLength = 0 ; private int [ ] fElementChildrenOffsetStack = new int [ 32 ] ; private int fElementDepth = - 1 ; private boolean fNamespacesEnabled = false ; private NamespacesScope fNamespacesScope = null ; private int fNamespacesPrefix = - 1 ; private QName fRootElement = new QName ( ) ; private int fAttrListHandle = - 1 ; private int fCurrentElementEntity = - 1 ; private int fCurrentElementIndex = - 1 ; private int fCurrentContentSpecType = - 1 ; private boolean fSeenDoctypeDecl = false ; private final int TOP_LEVEL_SCOPE = - 1 ; private int fCurrentScope = TOP_LEVEL_SCOPE ; private int fCurrentSchemaURI = - 1 ; private int fEmptyURI = - 1 ; private int fXsiPrefix = - 1 ; private int fXsiURI = - 2 ; private int fXsiTypeAttValue = - 1 ; private DatatypeValidator fXsiTypeValidator = null ; private Grammar fGrammar = null ; private int fGrammarNameSpaceIndex = - 1 ; private GrammarResolver fGrammarResolver = null ; private boolean fScanningDTD = false ; private XMLDocumentScanner fDocumentScanner = null ; private boolean fCalledStartDocument = false ; private XMLDocumentHandler fDocumentHandler = null ; private XMLDocumentHandler . DTDHandler fDTDHandler = null ; private boolean fSeenRootElement = false ; private XMLAttrList fAttrList = null ; private int fXMLLang = - 1 ; private LocatorImpl fAttrNameLocator = null ; private boolean fCheckedForSchema = false ; private boolean fDeclsAreExternal = false ; private StringPool . CharArrayRange fCurrentElementCharArrayRange = null ; private char [ ] fCharRefData = null ; private boolean fSendCharDataAsCharArray = false ; private boolean fBufferDatatype = false ; private StringBuffer fDatatypeBuffer = new StringBuffer ( ) ; private QName fTempQName = new QName ( ) ; private XMLAttributeDecl fTempAttDecl = new XMLAttributeDecl ( ) ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; private boolean fGrammarIsDTDGrammar = false ; private boolean fGrammarIsSchemaGrammar = false ; private boolean fNeedValidationOff = false ; private int fEMPTYSymbol = - 1 ; private int fANYSymbol = - 1 ; private int fMIXEDSymbol = - 1 ; private int fCHILDRENSymbol = - 1 ; private int fCDATASymbol = - 1 ; private int fIDSymbol = - 1 ; private int fIDREFSymbol = - 1 ; private int fIDREFSSymbol = - 1 ; private int fENTITYSymbol = - 1 ; private int fENTITIESSymbol = - 1 ; private int fNMTOKENSymbol = - 1 ; private int fNMTOKENSSymbol = - 1 ; private int fNOTATIONSymbol = - 1 ; private int fENUMERATIONSymbol = - 1 ; private int fREQUIREDSymbol = - 1 ; private int fFIXEDSymbol = - 1 ; private int fDATATYPESymbol = - 1 ; private int fEpsilonIndex = - 1 ; private DatatypeValidatorFactoryImpl fDataTypeReg = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; private DatatypeValidator fValID = this . fDataTypeReg . getDatatypeValidator ( "ID" ) ; private DatatypeValidator fValIDRef = this . fDataTypeReg . getDatatypeValidator ( "IDREF" ) ; private DatatypeValidator fValIDRefs = this . fDataTypeReg . getDatatypeValidator ( "IDREFS" ) ; private DatatypeValidator fValENTITY = this . fDataTypeReg . getDatatypeValidator ( "ENTITY" ) ; private DatatypeValidator fValENTITIES = this . fDataTypeReg . getDatatypeValidator ( "ENTITIES" ) ; private DatatypeValidator fValNMTOKEN = this . fDataTypeReg . getDatatypeValidator ( "NMTOKEN" ) ; private DatatypeValidator fValNMTOKENS = this . fDataTypeReg . getDatatypeValidator ( "NMTOKENS" ) ; private DatatypeValidator fValNOTATION = this . fDataTypeReg . getDatatypeValidator ( "NOTATION" ) ; public XMLValidator ( StringPool stringPool , XMLErrorReporter errorReporter , DefaultEntityHandler entityHandler , XMLDocumentScanner documentScanner ) { fStringPool = stringPool ; fErrorReporter = errorReporter ; fEntityHandler = entityHandler ; fDocumentScanner = documentScanner ; fEmptyURI = fStringPool . addSymbol ( "" ) ; fXsiURI = fStringPool . addSymbol ( SchemaSymbols . URI_XSI ) ; fAttrList = new XMLAttrList ( fStringPool ) ; entityHandler . setEventHandler ( this ) ; entityHandler . setCharDataHandler ( this ) ; fDocumentScanner . setEventHandler ( this ) ; for ( int i = 0 ; i < sizeQNameParts ; i ++ ) { fElementQNamePartsStack [ i ] = new QName ( ) ; } init ( ) ; } public void setGrammarResolver ( GrammarResolver grammarResolver ) { fGrammarResolver = grammarResolver ; } public void initHandlers ( boolean sendCharDataAsCharArray , XMLDocumentHandler docHandler , XMLDocumentHandler . DTDHandler dtdHandler ) { fSendCharDataAsCharArray = sendCharDataAsCharArray ; fEntityHandler . setSendCharDataAsCharArray ( fSendCharDataAsCharArray ) ; fDocumentHandler = docHandler ; fDTDHandler = dtdHandler ; } public void resetOrCopy ( StringPool stringPool ) throws Exception { fAttrList = new XMLAttrList ( stringPool ) ; resetCommon ( stringPool ) ; } public void reset ( StringPool stringPool ) throws Exception { fAttrList . reset ( stringPool ) ; resetCommon ( stringPool ) ; } public void setValidationEnabled ( boolean flag ) throws Exception { fValidationEnabled = flag ; fValidationEnabledByDynamic = false ; if ( fValidationEnabled ) { if ( fDynamicDisabledByValidation ) { fDynamicValidation = true ; fDynamicDisabledByValidation = false ; } } else if ( fDynamicValidation ) { fDynamicValidation = false ; fDynamicDisabledByValidation = true ; } fValidating = fValidationEnabled ; } public boolean getValidationEnabled ( ) { return fValidationEnabled ; } public void setSchemaValidationEnabled ( boolean flag ) { fSchemaValidation = flag ; } public boolean getSchemaValidationEnabled ( ) { return fSchemaValidation ; } public void setDynamicValidationEnabled ( boolean flag ) throws Exception { fDynamicValidation = flag ; fDynamicDisabledByValidation = false ; if ( ! fDynamicValidation ) { if ( fValidationEnabledByDynamic ) { fValidationEnabled = false ; fValidationEnabledByDynamic = false ; } } else if ( ! fValidationEnabled ) { fValidationEnabled = true ; fValidationEnabledByDynamic = true ; } fValidating = fValidationEnabled ; } public boolean getDynamicValidationEnabled ( ) { return fDynamicValidation ; } public void setLoadDTDGrammar ( boolean loadDG ) { if ( fValidating ) { fLoadDTDGrammar = true ; } else { fLoadDTDGrammar = loadDG ; } } public boolean getLoadDTDGrammar ( ) { return fLoadDTDGrammar ; } public void setNamespacesEnabled ( boolean flag ) { fNamespacesEnabled = flag ; } public boolean getNamespacesEnabled ( ) { return fNamespacesEnabled ; } public void setWarningOnDuplicateAttDef ( boolean flag ) { fWarningOnDuplicateAttDef = flag ; } public boolean getWarningOnDuplicateAttDef ( ) { return fWarningOnDuplicateAttDef ; } public void setWarningOnUndeclaredElements ( boolean flag ) { fWarningOnUndeclaredElements = flag ; } public boolean getWarningOnUndeclaredElements ( ) { return fWarningOnUndeclaredElements ; } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { fDocumentHandler . startEntityReference ( entityName , entityType , entityContext ) ; } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { fDocumentHandler . endEntityReference ( entityName , entityType , entityContext ) ; } public void sendEndOfInputNotifications ( int entityName , boolean moreToFollow ) throws Exception { fDocumentScanner . endOfInput ( entityName , moreToFollow ) ; } public void sendReaderChangeNotifications ( XMLEntityHandler . EntityReader reader , int readerId ) throws Exception { fDocumentScanner . readerChange ( reader , readerId ) ; } public boolean externalEntityStandaloneCheck ( ) { return ( fStandaloneReader != - 1 && fValidating ) ; } public boolean getValidating ( ) { return fValidating ; } public void processCharacters ( char [ ] chars , int offset , int length ) throws Exception { if ( fValidating ) { if ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } if ( fBufferDatatype ) { fDatatypeBuffer . append ( chars , offset , length ) ; } } fDocumentHandler . characters ( chars , offset , length ) ; } public void processCharacters ( int data ) throws Exception { if ( fValidating ) { if ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } if ( fBufferDatatype ) { fDatatypeBuffer . append ( fStringPool . toString ( data ) ) ; } } fDocumentHandler . characters ( data ) ; } public void processWhitespace ( char [ ] chars , int offset , int length ) throws Exception { if ( fInElementContent ) { if ( fStandaloneReader != - 1 && fValidating && getElementDeclIsExternal ( fCurrentElementIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION ) ; } fDocumentHandler . ignorableWhitespace ( chars , offset , length ) ; } else { if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } fDocumentHandler . characters ( chars , offset , length ) ; } } public void processWhitespace ( int data ) throws Exception { if ( fInElementContent ) { if ( fStandaloneReader != - 1 && fValidating && getElementDeclIsExternal ( fCurrentElementIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION ) ; } fDocumentHandler . ignorableWhitespace ( data ) ; } else { if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } fDocumentHandler . characters ( data ) ; } } public void scanElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( ! fNamespacesEnabled ) { element . clear ( ) ; element . localpart = entityReader . scanName ( fastchar ) ; element . rawname = element . localpart ; } else { entityReader . scanQName ( fastchar , element ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } public boolean scanExpectedElementType ( XMLEntityHandler . EntityReader entityReader , char fastchar , QName element ) throws Exception { if ( fCurrentElementCharArrayRange == null ) { fCurrentElementCharArrayRange = fStringPool . createCharArrayRange ( ) ; } fStringPool . getCharArrayRange ( fCurrentElement . rawname , fCurrentElementCharArrayRange ) ; return entityReader . scanExpectedName ( fastchar , fCurrentElementCharArrayRange ) ; } public void scanAttributeName ( XMLEntityHandler . EntityReader entityReader , QName element , QName attribute ) throws Exception { if ( ! fSeenRootElement ) { fSeenRootElement = true ; rootElementSpecified ( element ) ; fStringPool . resetShuffleCount ( ) ; } if ( ! fNamespacesEnabled ) { attribute . clear ( ) ; attribute . localpart = entityReader . scanName ( '=' ) ; attribute . rawname = attribute . localpart ; } else { entityReader . scanQName ( '=' , attribute ) ; if ( entityReader . lookingAtChar ( ':' , false ) ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_TWO_COLONS_IN_QNAME , XMLMessages . P5_INVALID_CHARACTER , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; entityReader . skipPastNmtoken ( ' ' ) ; } } } public void callStartDocument ( ) throws Exception { if ( ! fCalledStartDocument ) { fDocumentHandler . startDocument ( ) ; fCalledStartDocument = true ; } } public void callEndDocument ( ) throws Exception { if ( fCalledStartDocument ) { fDocumentHandler . endDocument ( ) ; } } public void callXMLDecl ( int version , int encoding , int standalone ) throws Exception { fDocumentHandler . xmlDecl ( version , encoding , standalone ) ; } public void callStandaloneIsYes ( ) throws Exception { fStandaloneReader = fEntityHandler . getReaderId ( ) ; } public void callTextDecl ( int version , int encoding ) throws Exception { fDocumentHandler . textDecl ( version , encoding ) ; } public void element ( QName element ) throws Exception { fAttrListHandle = - 1 ; } public boolean attribute ( QName element , QName attrName , int attrValue ) throws Exception { if ( fAttrListHandle == - 1 ) { fAttrListHandle = fAttrList . startAttrList ( ) ; } return fAttrList . addAttr ( attrName , attrValue , fCDATASymbol , true , true ) == - 1 ; } public void callStartElement ( QName element ) throws Exception { if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "\n=======StartElement : " + fStringPool . toString ( element . localpart ) ) ; if ( ! fSeenRootElement ) { fSeenRootElement = true ; rootElementSpecified ( element ) ; fStringPool . resetShuffleCount ( ) ; } if ( fGrammar != null && fGrammarIsDTDGrammar ) { fAttrListHandle = addDTDDefaultAttributes ( element , fAttrList , fAttrListHandle , fValidating , fStandaloneReader != - 1 ) ; } fCheckedForSchema = true ; if ( fNamespacesEnabled ) { bindNamespacesToElementAndAttributes ( element , fAttrList ) ; } validateElementAndAttributes ( element , fAttrList ) ; if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; } fDocumentHandler . startElement ( element , fAttrList , fAttrListHandle ) ; fAttrListHandle = - 1 ; fElementDepth ++ ; if ( fValidating ) { if ( fElementChildrenOffsetStack . length < fElementDepth ) { int newarray [ ] = new int [ fElementChildrenOffsetStack . length * 2 ] ; System . arraycopy ( fElementChildrenOffsetStack , 0 , newarray , 0 , fElementChildrenOffsetStack . length ) ; fElementChildrenOffsetStack = newarray ; } fElementChildrenOffsetStack [ fElementDepth ] = fElementChildrenLength ; if ( fElementChildren . length <= fElementChildrenLength ) { QName [ ] newarray = new QName [ fElementChildrenLength * 2 ] ; System . arraycopy ( fElementChildren , 0 , newarray , 0 , fElementChildren . length ) ; fElementChildren = newarray ; } QName qname = fElementChildren [ fElementChildrenLength ] ; if ( qname == null ) { for ( int i = fElementChildrenLength ; i < fElementChildren . length ; i ++ ) { fElementChildren [ i ] = new QName ( ) ; } qname = fElementChildren [ fElementChildrenLength ] ; } qname . setValues ( element ) ; fElementChildrenLength ++ ; if ( DEBUG_ELEMENT_CHILDREN ) { printChildren ( ) ; printStack ( ) ; } } ensureStackCapacity ( fElementDepth ) ; fCurrentElement . setValues ( element ) ; fCurrentElementEntity = fEntityHandler . getReaderId ( ) ; fElementQNamePartsStack [ fElementDepth ] . setValues ( fCurrentElement ) ; fElementEntityStack [ fElementDepth ] = fCurrentElementEntity ; fElementIndexStack [ fElementDepth ] = fCurrentElementIndex ; fContentSpecTypeStack [ fElementDepth ] = fCurrentContentSpecType ; if ( fNeedValidationOff ) { fValidating = false ; fNeedValidationOff = false ; } if ( fValidating && fGrammarIsSchemaGrammar ) { pushContentLeafStack ( ) ; } fValidationFlagStack [ fElementDepth ] = fValidating ? 0 : - 1 ; fScopeStack [ fElementDepth ] = fCurrentScope ; fGrammarNameSpaceIndexStack [ fElementDepth ] = fGrammarNameSpaceIndex ; } private void pushContentLeafStack ( ) throws Exception { int contentType = getContentSpecType ( fCurrentElementIndex ) ; if ( contentType == XMLElementDecl . TYPE_CHILDREN ) { XMLContentModel cm = getElementContentModel ( fCurrentElementIndex ) ; ContentLeafNameTypeVector cv = cm . getContentLeafNameTypeVector ( ) ; if ( cm != null ) { fContentLeafStack [ fElementDepth ] = cv ; } } } private void ensureStackCapacity ( int newElementDepth ) { if ( newElementDepth == fElementQNamePartsStack . length ) { int [ ] newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fScopeStack , 0 , newStack , 0 , newElementDepth ) ; fScopeStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fGrammarNameSpaceIndexStack , 0 , newStack , 0 , newElementDepth ) ; fGrammarNameSpaceIndexStack = newStack ; QName [ ] newStackOfQueue = new QName [ newElementDepth * 2 ] ; System . arraycopy ( this . fElementQNamePartsStack , 0 , newStackOfQueue , 0 , newElementDepth ) ; fElementQNamePartsStack = newStackOfQueue ; QName qname = fElementQNamePartsStack [ newElementDepth ] ; if ( qname == null ) { for ( int i = newElementDepth ; i < fElementQNamePartsStack . length ; i ++ ) { fElementQNamePartsStack [ i ] = new QName ( ) ; } } newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fElementEntityStack , 0 , newStack , 0 , newElementDepth ) ; fElementEntityStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fElementIndexStack , 0 , newStack , 0 , newElementDepth ) ; fElementIndexStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fContentSpecTypeStack , 0 , newStack , 0 , newElementDepth ) ; fContentSpecTypeStack = newStack ; newStack = new int [ newElementDepth * 2 ] ; System . arraycopy ( fValidationFlagStack , 0 , newStack , 0 , newElementDepth ) ; fValidationFlagStack = newStack ; ContentLeafNameTypeVector [ ] newStackV = new ContentLeafNameTypeVector [ newElementDepth * 2 ] ; System . arraycopy ( fContentLeafStack , 0 , newStackV , 0 , newElementDepth ) ; fContentLeafStack = newStackV ; } } public void callEndElement ( int readerId ) throws Exception { if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "=======EndElement : " + fStringPool . toString ( fCurrentElement . localpart ) + "\n" ) ; int prefixIndex = fCurrentElement . prefix ; int elementType = fCurrentElement . rawname ; if ( fCurrentElementEntity != readerId ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ELEMENT_ENTITY_MISMATCH , XMLMessages . P78_NOT_WELLFORMED , new Object [ ] { fStringPool . toString ( elementType ) } , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } fElementDepth -- ; if ( fValidating ) { int elementIndex = fCurrentElementIndex ; if ( elementIndex != - 1 && fCurrentContentSpecType != - 1 ) { QName children [ ] = fElementChildren ; int childrenOffset = fElementChildrenOffsetStack [ fElementDepth + 1 ] + 1 ; int childrenLength = fElementChildrenLength - childrenOffset ; if ( DEBUG_ELEMENT_CHILDREN ) { System . out . println ( "endElement(" + fStringPool . toString ( fCurrentElement . rawname ) + ')' ) ; System . out . println ( "fCurrentContentSpecType : " + fCurrentContentSpecType ) ; System . out . print ( "offset: " ) ; System . out . print ( childrenOffset ) ; System . out . print ( ", length: " ) ; System . out . print ( childrenLength ) ; System . out . println ( ) ; printChildren ( ) ; printStack ( ) ; } int result = checkContent ( elementIndex , children , childrenOffset , childrenLength ) ; if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "!!!!!!!!In XMLValidator, the return value from checkContent : " + result ) ; if ( result != - 1 ) { int majorCode = result != childrenLength ? XMLMessages . MSG_CONTENT_INVALID : XMLMessages . MSG_CONTENT_INCOMPLETE ; fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; if ( fTempElementDecl . type == XMLElementDecl . TYPE_EMPTY ) { reportRecoverableXMLError ( majorCode , 0 , fStringPool . toString ( elementType ) , "EMPTY" ) ; } else reportRecoverableXMLError ( majorCode , 0 , fStringPool . toString ( elementType ) , XMLContentSpec . toString ( fGrammar , fStringPool , fTempElementDecl . contentSpecIndex ) ) ; } } fElementChildrenLength = fElementChildrenOffsetStack [ fElementDepth + 1 ] + 1 ; } fDocumentHandler . endElement ( fCurrentElement ) ; if ( fNamespacesEnabled ) { fNamespacesScope . decreaseDepth ( ) ; } if ( fElementDepth < - 1 ) { throw new RuntimeException ( "FWK008 Element stack underflow" ) ; } if ( fElementDepth < 0 ) { fCurrentElement . clear ( ) ; fCurrentElementEntity = - 1 ; fCurrentElementIndex = - 1 ; fCurrentContentSpecType = - 1 ; fInElementContent = false ; if ( fValidating ) { try { this . fValIDRef . validate ( null , this . fValidateIDRef ) ; this . fValIDRefs . validate ( null , this . fValidateIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , ex . getMessage ( ) ) ; } } try { this . fValID . validate ( null , this . fResetID ) ; this . fValIDRef . validate ( null , this . fResetIDRef ) ; this . fValIDRefs . validate ( null , this . fResetIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error re-Initializing: ID,IDRef,IDRefs pools" ) ; } return ; } fCurrentElement . prefix = - 1 ; if ( fNamespacesEnabled ) { fCurrentElement . localpart = fElementQNamePartsStack [ fElementDepth ] . localpart ; } else { fCurrentElement . localpart = fElementQNamePartsStack [ fElementDepth ] . rawname ; } fCurrentElement . rawname = fElementQNamePartsStack [ fElementDepth ] . rawname ; fCurrentElement . uri = fElementQNamePartsStack [ fElementDepth ] . uri ; fCurrentElement . prefix = fElementQNamePartsStack [ fElementDepth ] . prefix ; fCurrentElementEntity = fElementEntityStack [ fElementDepth ] ; fCurrentElementIndex = fElementIndexStack [ fElementDepth ] ; fCurrentContentSpecType = fContentSpecTypeStack [ fElementDepth ] ; fValidating = fValidationFlagStack [ fElementDepth ] == 0 ? true : false ; fCurrentScope = fScopeStack [ fElementDepth ] ; if ( fGrammarNameSpaceIndex != fGrammarNameSpaceIndexStack [ fElementDepth ] ) { fGrammarNameSpaceIndex = fGrammarNameSpaceIndexStack [ fElementDepth ] ; if ( fValidating && fGrammarIsSchemaGrammar ) if ( ! switchGrammar ( fGrammarNameSpaceIndex ) ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fGrammarNameSpaceIndex ) + " , can not found" ) ; } } if ( fValidating ) { fBufferDatatype = false ; } fInElementContent = ( fCurrentContentSpecType == XMLElementDecl . TYPE_CHILDREN ) ; } public void callStartCDATA ( ) throws Exception { fDocumentHandler . startCDATA ( ) ; } public void callEndCDATA ( ) throws Exception { fDocumentHandler . endCDATA ( ) ; } public void callCharacters ( int ch ) throws Exception { if ( fCharRefData == null ) { fCharRefData = new char [ 2 ] ; } int count = ( ch < 0x10000 ) ? 1 : 2 ; if ( count == 1 ) { fCharRefData [ 0 ] = ( char ) ch ; } else { fCharRefData [ 0 ] = ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; fCharRefData [ 1 ] = ( char ) ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; } if ( fValidating && ( fInElementContent || fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) ) { charDataInContent ( ) ; } if ( fSendCharDataAsCharArray ) { fDocumentHandler . characters ( fCharRefData , 0 , count ) ; } else { int index = fStringPool . addString ( new String ( fCharRefData , 0 , count ) ) ; fDocumentHandler . characters ( index ) ; } } public void callProcessingInstruction ( int target , int data ) throws Exception { fDocumentHandler . processingInstruction ( target , data ) ; } public void callComment ( int comment ) throws Exception { fDocumentHandler . comment ( comment ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { fDocumentHandler . startNamespaceDeclScope ( prefix , uri ) ; } public void endNamespaceDeclScope ( int prefix ) throws Exception { fDocumentHandler . endNamespaceDeclScope ( prefix ) ; } public void setRootElementType ( QName rootElement ) { fRootElement . setValues ( rootElement ) ; } private boolean getElementDeclIsExternal ( int elementIndex ) { if ( fGrammarIsDTDGrammar ) { return ( ( DTDGrammar ) fGrammar ) . getElementDeclIsExternal ( elementIndex ) ; } return false ; } public int getContentSpecType ( int elementIndex ) { int contentSpecType = - 1 ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentSpecType = fTempElementDecl . type ; } } return contentSpecType ; } public int getContentSpecHandle ( int elementIndex ) { int contentSpecHandle = - 1 ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentSpecHandle = fTempElementDecl . contentSpecIndex ; } } return contentSpecHandle ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode ) throws Exception { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , null , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 ) throws Exception { Object [ ] args = { string1 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , int stringIndex1 , int stringIndex2 ) throws Exception { Object [ ] args = { fStringPool . toString ( stringIndex1 ) , fStringPool . toString ( stringIndex2 ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 ) throws Exception { Object [ ] args = { string1 , string2 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected void reportRecoverableXMLError ( int majorCode , int minorCode , String string1 , String string2 , String string3 ) throws Exception { Object [ ] args = { string1 , string2 , string3 } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , majorCode , minorCode , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } protected int whatCanGoHere ( int elementIndex , boolean fullyValid , InsertableElementsInfo info ) throws Exception { if ( info . insertAt > info . childCount || info . curChildren == null || info . childCount < 1 || info . childCount > info . curChildren . length ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . VAL_WCGHI , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } int retVal = 0 ; try { final XMLContentModel cmElem = getElementContentModel ( elementIndex ) ; retVal = cmElem . whatCanGoHere ( fullyValid , info ) ; } catch ( CMException excToCatch ) { int majorCode = excToCatch . getErrorCode ( ) ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , majorCode , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; throw excToCatch ; } return retVal ; } protected boolean getAttDefIsExternal ( QName element , QName attribute ) { int attDefIndex = getAttDef ( element , attribute ) ; if ( fGrammarIsDTDGrammar ) { return ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attDefIndex ) ; } return false ; } private boolean usingStandaloneReader ( ) { return fStandaloneReader == - 1 || fEntityHandler . getReaderId ( ) == fStandaloneReader ; } private LocatorImpl getLocatorImpl ( LocatorImpl fillin ) { Locator here = fErrorReporter . getLocator ( ) ; if ( fillin == null ) return new LocatorImpl ( here ) ; fillin . setPublicId ( here . getPublicId ( ) ) ; fillin . setSystemId ( here . getSystemId ( ) ) ; fillin . setLineNumber ( here . getLineNumber ( ) ) ; fillin . setColumnNumber ( here . getColumnNumber ( ) ) ; return fillin ; } private void poolReset ( ) { try { this . fValID . validate ( null , this . fResetID ) ; this . fValIDRef . validate ( null , this . fResetIDRef ) ; this . fValIDRefs . validate ( null , this . fResetIDRef ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error re-Initializing: ID,IDRef,IDRefs pools" ) ; } } private void resetCommon ( StringPool stringPool ) throws Exception { fStringPool = stringPool ; fValidating = fValidationEnabled ; fValidationEnabledByDynamic = false ; fDynamicDisabledByValidation = false ; poolReset ( ) ; fCalledStartDocument = false ; fStandaloneReader = - 1 ; fElementChildrenLength = 0 ; fElementDepth = - 1 ; fSeenRootElement = false ; fSeenDoctypeDecl = false ; fNamespacesScope = null ; fNamespacesPrefix = - 1 ; fRootElement . clear ( ) ; fAttrListHandle = - 1 ; fCheckedForSchema = false ; fCurrentScope = TOP_LEVEL_SCOPE ; fCurrentSchemaURI = - 1 ; fEmptyURI = - 1 ; fXsiPrefix = - 1 ; fXsiTypeValidator = null ; fGrammar = null ; fGrammarNameSpaceIndex = - 1 ; if ( fGrammarResolver != null ) { fGrammarResolver . clearGrammarResolver ( ) ; } fGrammarIsDTDGrammar = false ; fGrammarIsSchemaGrammar = false ; init ( ) ; } private void init ( ) { fEmptyURI = fStringPool . addSymbol ( "" ) ; fXsiURI = fStringPool . addSymbol ( SchemaSymbols . URI_XSI ) ; fEMPTYSymbol = fStringPool . addSymbol ( "EMPTY" ) ; fANYSymbol = fStringPool . addSymbol ( "ANY" ) ; fMIXEDSymbol = fStringPool . addSymbol ( "MIXED" ) ; fCHILDRENSymbol = fStringPool . addSymbol ( "CHILDREN" ) ; fCDATASymbol = fStringPool . addSymbol ( "CDATA" ) ; fIDSymbol = fStringPool . addSymbol ( "ID" ) ; fIDREFSymbol = fStringPool . addSymbol ( "IDREF" ) ; fIDREFSSymbol = fStringPool . addSymbol ( "IDREFS" ) ; fENTITYSymbol = fStringPool . addSymbol ( "ENTITY" ) ; fENTITIESSymbol = fStringPool . addSymbol ( "ENTITIES" ) ; fNMTOKENSymbol = fStringPool . addSymbol ( "NMTOKEN" ) ; fNMTOKENSSymbol = fStringPool . addSymbol ( "NMTOKENS" ) ; fNOTATIONSymbol = fStringPool . addSymbol ( "NOTATION" ) ; fENUMERATIONSymbol = fStringPool . addSymbol ( "ENUMERATION" ) ; fREQUIREDSymbol = fStringPool . addSymbol ( "#REQUIRED" ) ; fFIXEDSymbol = fStringPool . addSymbol ( "#FIXED" ) ; fDATATYPESymbol = fStringPool . addSymbol ( "<<datatype>>" ) ; fEpsilonIndex = fStringPool . addSymbol ( "<<CMNODE_EPSILON>>" ) ; fXMLLang = fStringPool . addSymbol ( "xml:lang" ) ; try { Object [ ] packageArgsEntityVal = { ( Object ) this . fEntityHandler , ( Object ) this . fStringPool } ; fValidateENTITYMsg . setDatatypeObject ( ( Object ) packageArgsEntityVal ) ; fValENTITIES . validate ( null , fValidateENTITYMsg ) ; fValENTITY . validate ( null , fValidateENTITYMsg ) ; } catch ( InvalidDatatypeValueException ex ) { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } private int addDefaultAttributes ( int elementIndex , XMLAttrList attrList , int attrIndex , boolean validationEnabled , boolean standalone ) throws Exception { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; int elementNameIndex = fTempElementDecl . name . localpart ; int attlistIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int firstCheck = attrIndex ; int lastCheck = - 1 ; while ( attlistIndex != - 1 ) { fGrammar . getAttributeDecl ( attlistIndex , fTempAttDecl ) ; int attPrefix = fTempAttDecl . name . prefix ; int attName = fTempAttDecl . name . localpart ; int attType = attributeTypeName ( fTempAttDecl ) ; int attDefType = fTempAttDecl . defaultType ; int attValue = - 1 ; if ( fTempAttDecl . defaultValue != null ) { attValue = fStringPool . addSymbol ( fTempAttDecl . defaultValue ) ; } boolean specified = false ; boolean required = attDefType == XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; if ( firstCheck != - 1 ) { boolean cdata = attType == fCDATASymbol ; if ( ! cdata || required || attValue != - 1 ) { int i = attrList . getFirstAttr ( firstCheck ) ; while ( i != - 1 && ( lastCheck == - 1 || i <= lastCheck ) ) { if ( ( fGrammarIsDTDGrammar && ( attrList . getAttrName ( i ) == fTempAttDecl . name . rawname ) ) || ( fStringPool . equalNames ( attrList . getAttrLocalpart ( i ) , attName ) && fStringPool . equalNames ( attrList . getAttrURI ( i ) , fTempAttDecl . name . uri ) ) ) { if ( validationEnabled && attDefType == XMLAttributeDecl . DEFAULT_TYPE_FIXED ) { int alistValue = attrList . getAttValue ( i ) ; if ( alistValue != attValue && ! fStringPool . toString ( alistValue ) . equals ( fStringPool . toString ( attValue ) ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) , fStringPool . toString ( alistValue ) , fStringPool . toString ( attValue ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_FIXED_ATTVALUE_INVALID , XMLMessages . VC_FIXED_ATTRIBUTE_DEFAULT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } specified = true ; break ; } i = attrList . getNextAttr ( i ) ; } } } if ( ! specified ) { if ( required ) { if ( validationEnabled ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_REQUIRED_ATTRIBUTE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else if ( attValue != - 1 ) { if ( validationEnabled && standalone ) if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attlistIndex ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( attType == fIDREFSymbol ) { this . fValIDRef . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } else if ( attType == fIDREFSSymbol ) { this . fValIDRefs . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } if ( attrIndex == - 1 ) { attrIndex = attrList . startAttrList ( ) ; } fTempQName . setValues ( attPrefix , attName , attName , fTempAttDecl . name . uri ) ; int newAttr = attrList . addAttr ( fTempQName , attValue , attType , false , false ) ; if ( lastCheck == - 1 ) { lastCheck = newAttr ; } } } attlistIndex = fGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } return attrIndex ; } private int addDTDDefaultAttributes ( QName element , XMLAttrList attrList , int attrIndex , boolean validationEnabled , boolean standalone ) throws Exception { int elementIndex = fGrammar . getElementDeclIndex ( element , - 1 ) ; if ( elementIndex == - 1 ) { return attrIndex ; } fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; int elementNameIndex = fTempElementDecl . name . rawname ; int attlistIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; int firstCheck = attrIndex ; int lastCheck = - 1 ; while ( attlistIndex != - 1 ) { fGrammar . getAttributeDecl ( attlistIndex , fTempAttDecl ) ; int attPrefix = fTempAttDecl . name . prefix ; int attName = fTempAttDecl . name . rawname ; int attLocalpart = fTempAttDecl . name . localpart ; int attType = attributeTypeName ( fTempAttDecl ) ; int attDefType = fTempAttDecl . defaultType ; int attValue = - 1 ; if ( fTempAttDecl . defaultValue != null ) { attValue = fStringPool . addSymbol ( fTempAttDecl . defaultValue ) ; } boolean specified = false ; boolean required = attDefType == XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; if ( firstCheck != - 1 ) { boolean cdata = attType == fCDATASymbol ; if ( ! cdata || required || attValue != - 1 ) { int i = attrList . getFirstAttr ( firstCheck ) ; while ( i != - 1 && ( lastCheck == - 1 || i <= lastCheck ) ) { if ( attrList . getAttrName ( i ) == fTempAttDecl . name . rawname ) { if ( validationEnabled && attDefType == XMLAttributeDecl . DEFAULT_TYPE_FIXED ) { int alistValue = attrList . getAttValue ( i ) ; if ( alistValue != attValue && ! fStringPool . toString ( alistValue ) . equals ( fStringPool . toString ( attValue ) ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) , fStringPool . toString ( alistValue ) , fStringPool . toString ( attValue ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_FIXED_ATTVALUE_INVALID , XMLMessages . VC_FIXED_ATTRIBUTE_DEFAULT , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } specified = true ; break ; } i = attrList . getNextAttr ( i ) ; } } } if ( ! specified ) { if ( required ) { if ( validationEnabled ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_REQUIRED_ATTRIBUTE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else if ( attValue != - 1 ) { if ( validationEnabled && standalone ) if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getAttributeDeclIsExternal ( attlistIndex ) ) { Object [ ] args = { fStringPool . toString ( elementNameIndex ) , fStringPool . toString ( attName ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XML_DOMAIN , XMLMessages . MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } if ( attType == fIDREFSymbol ) { this . fValIDRef . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } else if ( attType == fIDREFSSymbol ) { this . fValIDRefs . validate ( fStringPool . toString ( attValue ) , this . fStoreIDRef ) ; } if ( attrIndex == - 1 ) { attrIndex = attrList . startAttrList ( ) ; } fTempQName . setValues ( attPrefix , attLocalpart , attName , fTempAttDecl . name . uri ) ; int newAttr = attrList . addAttr ( fTempQName , attValue , attType , false , false ) ; if ( lastCheck == - 1 ) { lastCheck = newAttr ; } } } attlistIndex = fGrammar . getNextAttributeDeclIndex ( attlistIndex ) ; } return attrIndex ; } private XMLContentModel getElementContentModel ( int elementIndex ) throws CMException { XMLContentModel contentModel = null ; if ( elementIndex > - 1 ) { if ( fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ) { contentModel = fGrammar . getElementContentModel ( elementIndex ) ; } } return contentModel ; } private int getAttDef ( QName element , QName attribute ) { if ( fGrammar != null ) { int scope = fCurrentScope ; if ( element . uri > - 1 ) { scope = TOP_LEVEL_SCOPE ; } int elementIndex = fGrammar . getElementDeclIndex ( element , scope ) ; if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { fGrammar . getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . name . localpart == attribute . localpart && fTempAttributeDecl . name . uri == attribute . uri ) { return attDefIndex ; } attDefIndex = fGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } return - 1 ; } private int getAttDefByElementIndex ( int elementIndex , QName attribute ) { if ( fGrammar != null && elementIndex > - 1 ) { if ( elementIndex == - 1 ) { return - 1 ; } int attDefIndex = fGrammar . getFirstAttributeDeclIndex ( elementIndex ) ; while ( attDefIndex != - 1 ) { fGrammar . getAttributeDecl ( attDefIndex , fTempAttDecl ) ; if ( fGrammarIsDTDGrammar ) { if ( fTempAttDecl . name . rawname == attribute . rawname ) return attDefIndex ; } else if ( fTempAttDecl . name . localpart == attribute . localpart && fTempAttDecl . name . uri == attribute . uri ) { return attDefIndex ; } if ( fGrammarIsSchemaGrammar ) { if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return attDefIndex ; } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { if ( attribute . uri == - 1 ) { return attDefIndex ; } } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( attribute . uri != fTempAttDecl . name . uri ) { return attDefIndex ; } } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( fStringPool . stringInList ( fTempAttDecl . enumeration , attribute . uri ) ) { return attDefIndex ; } } } attDefIndex = fGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } return - 1 ; } private void rootElementSpecified ( QName rootElement ) throws Exception { if ( fLoadDTDGrammar ) if ( fGrammar == null ) { fGrammar = fGrammarResolver . getGrammar ( "" ) ; if ( fGrammar == null && DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "Oops! no grammar is found for validation" ) ; } if ( fDynamicValidation && fGrammar == null ) { fValidating = false ; } if ( fGrammar != null ) { if ( fGrammar instanceof DTDGrammar ) { fGrammarIsDTDGrammar = true ; fGrammarIsSchemaGrammar = false ; } else if ( fGrammar instanceof SchemaGrammar ) { fGrammarIsSchemaGrammar = true ; fGrammarIsDTDGrammar = false ; } fGrammarNameSpaceIndex = fEmptyURI ; } } if ( fValidating ) { if ( fGrammarIsDTDGrammar && ( ( DTDGrammar ) fGrammar ) . getRootElementQName ( fRootElement ) ) { String root1 = fStringPool . toString ( fRootElement . rawname ) ; String root2 = fStringPool . toString ( rootElement . rawname ) ; if ( ! root1 . equals ( root2 ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ROOT_ELEMENT_TYPE , XMLMessages . VC_ROOT_ELEMENT_TYPE , fRootElement . rawname , rootElement . rawname ) ; } } } if ( fNamespacesEnabled ) { if ( fNamespacesScope == null ) { fNamespacesScope = new NamespacesScope ( this ) ; fNamespacesPrefix = fStringPool . addSymbol ( "xmlns" ) ; fNamespacesScope . setNamespaceForPrefix ( fNamespacesPrefix , - 1 ) ; int xmlSymbol = fStringPool . addSymbol ( "xml" ) ; int xmlNamespace = fStringPool . addSymbol ( "http://www.w3.org/XML/1998/namespace" ) ; fNamespacesScope . setNamespaceForPrefix ( xmlSymbol , xmlNamespace ) ; } } } private boolean switchGrammar ( int newGrammarNameSpaceIndex ) throws Exception { Grammar tempGrammar = fGrammarResolver . getGrammar ( fStringPool . toString ( newGrammarNameSpaceIndex ) ) ; if ( tempGrammar == null ) { tempGrammar = fGrammarResolver . getGrammar ( "" ) ; } if ( tempGrammar == null ) { return false ; } else { fGrammar = tempGrammar ; if ( fGrammar instanceof DTDGrammar ) { fGrammarIsDTDGrammar = true ; fGrammarIsSchemaGrammar = false ; } else if ( fGrammar instanceof SchemaGrammar ) { fGrammarIsSchemaGrammar = true ; fGrammarIsDTDGrammar = false ; } return true ; } } private void bindNamespacesToElementAndAttributes ( QName element , XMLAttrList attrList ) throws Exception { fNamespacesScope . increaseDepth ( ) ; Hashtable locationUriPairs = null ; if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; int attPrefix = attrList . getAttrPrefix ( index ) ; if ( fStringPool . equalNames ( attName , fXMLLang ) ) { } else if ( fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int uri = fStringPool . addSymbol ( attrList . getAttValue ( index ) ) ; fNamespacesScope . setNamespaceForPrefix ( StringPool . EMPTY_STRING , uri ) ; } else { if ( attPrefix == fNamespacesPrefix ) { int nsPrefix = attrList . getAttrLocalpart ( index ) ; int uri = fStringPool . addSymbol ( attrList . getAttValue ( index ) ) ; fNamespacesScope . setNamespaceForPrefix ( nsPrefix , uri ) ; if ( fValidating && fSchemaValidation ) { boolean seeXsi = false ; String attrValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; if ( attrValue . equals ( SchemaSymbols . URI_XSI ) ) { fXsiPrefix = nsPrefix ; seeXsi = true ; } if ( ! seeXsi ) { } } } } index = attrList . getNextAttr ( index ) ; } if ( fValidating && fSchemaValidation ) { fXsiTypeAttValue = - 1 ; index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; int attPrefix = attrList . getAttrPrefix ( index ) ; if ( fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { } else { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "deal with XSI" ) ; System . out . println ( "before find XSI: " + fStringPool . toString ( attPrefix ) + "," + fStringPool . toString ( fXsiPrefix ) ) ; } if ( fXsiPrefix != - 1 && attPrefix == fXsiPrefix ) { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "find XSI: " + fStringPool . toString ( attPrefix ) + "," + fStringPool . toString ( attName ) ) ; } int localpart = attrList . getAttrLocalpart ( index ) ; if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_SCHEMALOCACTION ) ) { if ( locationUriPairs == null ) { locationUriPairs = new Hashtable ( ) ; } parseSchemaLocation ( fStringPool . toString ( attrList . getAttValue ( index ) ) , locationUriPairs ) ; } else if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_NONAMESPACESCHEMALOCACTION ) ) { if ( locationUriPairs == null ) { locationUriPairs = new Hashtable ( ) ; } locationUriPairs . put ( fStringPool . toString ( attrList . getAttValue ( index ) ) , "" ) ; if ( fNamespacesScope != null ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } } else if ( localpart == fStringPool . addSymbol ( SchemaSymbols . XSI_TYPE ) ) { fXsiTypeAttValue = attrList . getAttValue ( index ) ; } } } index = attrList . getNextAttr ( index ) ; } if ( locationUriPairs != null ) { Enumeration locations = locationUriPairs . keys ( ) ; while ( locations . hasMoreElements ( ) ) { String loc = ( String ) locations . nextElement ( ) ; String uri = ( String ) locationUriPairs . get ( loc ) ; resolveSchemaGrammar ( loc , uri ) ; } } } } int prefix = element . prefix != - 1 ? element . prefix : 0 ; int uri = fNamespacesScope . getNamespaceForPrefix ( prefix ) ; if ( element . prefix != - 1 || uri != - 1 ) { element . uri = uri ; if ( element . uri == - 1 ) { Object [ ] args = { fStringPool . toString ( element . prefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; if ( ! fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int attPrefix = attrList . getAttrPrefix ( index ) ; if ( attPrefix != fNamespacesPrefix ) { if ( attPrefix != - 1 ) { int attrUri = fNamespacesScope . getNamespaceForPrefix ( attPrefix ) ; if ( attrUri == - 1 ) { Object [ ] args = { fStringPool . toString ( attPrefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } attrList . setAttrURI ( index , attrUri ) ; } } } index = attrList . getNextAttr ( index ) ; } } } void parseSchemaLocation ( String schemaLocationStr , Hashtable locationUriPairs ) { if ( locationUriPairs != null ) { StringTokenizer tokenizer = new StringTokenizer ( schemaLocationStr , " \n\t\r" , false ) ; int tokenTotal = tokenizer . countTokens ( ) ; if ( tokenTotal % 2 != 0 ) { } else { while ( tokenizer . hasMoreTokens ( ) ) { String uri = tokenizer . nextToken ( ) ; String location = tokenizer . nextToken ( ) ; locationUriPairs . put ( location , uri ) ; } } } else { } } private void resolveSchemaGrammar ( String loc , String uri ) throws Exception { SchemaGrammar grammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uri ) ; if ( grammar == null ) { DOMParser parser = new DOMParser ( ) ; parser . setEntityResolver ( new Resolver ( fEntityHandler ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } InputSource source = null ; EntityResolver currentER = parser . getEntityResolver ( ) ; if ( currentER != null ) { source = currentER . resolveEntity ( "" , loc ) ; } if ( source == null ) { loc = fEntityHandler . expandSystemId ( loc ) ; source = new InputSource ( loc ) ; } try { parser . parse ( source ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , e . getMessage ( ) ) ; } Document document = parser . getDocument ( ) ; TraverseSchema tst = null ; try { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "I am geting the Schema Document" ) ; } Element root = document . getDocumentElement ( ) ; if ( root == null ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Can't get back Schema document's root element :" + loc ) ; } else { if ( uri == null || ! uri . equals ( root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ) ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Schema in " + loc + " has a different target namespace " + "from the one specified in the instance document :" + uri ) ; } grammar = new SchemaGrammar ( ) ; grammar . setGrammarDocument ( document ) ; tst = new TraverseSchema ( root , fStringPool , ( SchemaGrammar ) grammar , fGrammarResolver , fErrorReporter , source . getSystemId ( ) ) ; fGrammarResolver . putGrammar ( document . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) , grammar ) ; } } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } } } private void resolveSchemaGrammar ( String uri ) throws Exception { resolveSchemaGrammar ( uri , uri ) ; } static class Resolver implements EntityResolver { private static final String SYSTEM [ ] = { "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/structures.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/datatypes.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/versionInfo.ent" , } ; private static final String PATH [ ] = { "structures.dtd" , "datatypes.dtd" , "versionInfo.ent" , } ; private DefaultEntityHandler fEntityHandler ; public Resolver ( DefaultEntityHandler handler ) { fEntityHandler = handler ; } public InputSource resolveEntity ( String publicId , String systemId ) throws IOException , SAXException { for ( int i = 0 ; i < SYSTEM . length ; i ++ ) { if ( systemId . equals ( SYSTEM [ i ] ) ) { InputSource source = new InputSource ( getClass ( ) . getResourceAsStream ( PATH [ i ] ) ) ; source . setPublicId ( publicId ) ; source . setSystemId ( systemId ) ; return source ; } } EntityResolver resolver = fEntityHandler . getEntityResolver ( ) ; if ( resolver != null ) { InputSource source = resolver . resolveEntity ( publicId , systemId ) ; if ( source != null ) { return source ; } } return new InputSource ( fEntityHandler . expandSystemId ( systemId ) ) ; } } static class ErrorHandler implements org . xml . sax . ErrorHandler { public void warning ( SAXParseException ex ) { System . err . println ( "[Warning] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { System . err . println ( "[Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) { System . err . println ( "[Fatal Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId_ = ex . getSystemId ( ) ; if ( systemId_ != null ) { int index = systemId_ . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId_ = systemId_ . substring ( index + 1 ) ; str . append ( systemId_ ) ; } str . append ( ':' ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( ':' ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } } private int attributeTypeName ( XMLAttributeDecl attrDecl ) { switch ( attrDecl . type ) { case XMLAttributeDecl . TYPE_ENTITY : { return attrDecl . list ? fENTITIESSymbol : fENTITYSymbol ; } case XMLAttributeDecl . TYPE_ENUMERATION : { String enumeration = fStringPool . stringListAsString ( attrDecl . enumeration ) ; return fStringPool . addString ( enumeration ) ; } case XMLAttributeDecl . TYPE_ID : { return fIDSymbol ; } case XMLAttributeDecl . TYPE_IDREF : { return attrDecl . list ? fIDREFSSymbol : fIDREFSymbol ; } case XMLAttributeDecl . TYPE_NMTOKEN : { return attrDecl . list ? fNMTOKENSSymbol : fNMTOKENSSymbol ; } case XMLAttributeDecl . TYPE_NOTATION : { return fNOTATIONSymbol ; } } return fCDATASymbol ; } private void validateElementAndAttributes ( QName element , XMLAttrList attrList ) throws Exception { if ( ( fElementDepth >= 0 && fValidationFlagStack [ fElementDepth ] != 0 ) || ( fGrammar == null && ! fValidating && ! fNamespacesEnabled ) ) { fCurrentElementIndex = - 1 ; fCurrentContentSpecType = - 1 ; fInElementContent = false ; if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; int index = fAttrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { if ( fStringPool . equalNames ( fAttrList . getAttrName ( index ) , fXMLLang ) ) { fDocumentScanner . checkXMLLangAttributeValue ( fAttrList . getAttValue ( index ) ) ; break ; } index = fAttrList . getNextAttr ( index ) ; } } return ; } int elementIndex = - 1 ; int contentSpecType = - 1 ; boolean skipThisOne = false ; boolean laxThisOne = false ; if ( fGrammarIsSchemaGrammar && fContentLeafStack [ fElementDepth ] != null ) { ContentLeafNameTypeVector cv = fContentLeafStack [ fElementDepth ] ; QName [ ] fElemMap = cv . leafNames ; for ( int i = 0 ; i < cv . leafCount ; i ++ ) { int type = cv . leafTypes [ i ] ; if ( type == XMLContentSpec . CONTENTSPECNODE_LEAF ) { if ( fElemMap [ i ] . uri == element . uri && fElemMap [ i ] . localpart == element . localpart ) break ; } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ) { if ( element . uri == - 1 ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ) { if ( fElemMap [ i ] . uri != element . uri ) { break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_SKIP ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_SKIP ) { if ( element . uri == - 1 ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_SKIP ) { if ( fElemMap [ i ] . uri != element . uri ) { skipThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LAX ) { int uri = fElemMap [ i ] . uri ; if ( uri == - 1 || uri == element . uri ) { laxThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_LAX ) { if ( element . uri == - 1 ) { laxThisOne = true ; break ; } } else if ( type == XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_LAX ) { if ( fElemMap [ i ] . uri != element . uri ) { laxThisOne = true ; break ; } } } } if ( skipThisOne ) { fNeedValidationOff = true ; } else { if ( fNamespacesEnabled && fValidating && element . uri != fGrammarNameSpaceIndex && element . uri != - 1 ) { fGrammarNameSpaceIndex = element . uri ; boolean success = switchGrammar ( fGrammarNameSpaceIndex ) ; if ( ! success && ! laxThisOne ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fGrammarNameSpaceIndex ) + " , can not found" ) ; } } if ( fGrammar != null ) { if ( DEBUG_SCHEMA_VALIDATION ) { System . out . println ( "*******Lookup element: uri: " + fStringPool . toString ( element . uri ) + "localpart: '" + fStringPool . toString ( element . localpart ) + "' and scope : " + fCurrentScope + "\n" ) ; } elementIndex = fGrammar . getElementDeclIndex ( element , fCurrentScope ) ; if ( elementIndex == - 1 ) { elementIndex = fGrammar . getElementDeclIndex ( element , TOP_LEVEL_SCOPE ) ; } if ( elementIndex == - 1 ) { if ( fGrammarIsSchemaGrammar && fCurrentElementIndex != - 1 ) { TraverseSchema . ComplexTypeInfo baseTypeInfo = null ; baseTypeInfo = ( ( SchemaGrammar ) fGrammar ) . getElementComplexTypeInfo ( fCurrentElementIndex ) ; while ( baseTypeInfo != null ) { elementIndex = fGrammar . getElementDeclIndex ( element , baseTypeInfo . scopeDefined ) ; if ( elementIndex > - 1 ) { break ; } baseTypeInfo = baseTypeInfo . baseComplexTypeInfo ; } } if ( elementIndex == - 1 ) { if ( laxThisOne ) { fNeedValidationOff = true ; } else if ( DEBUG_SCHEMA_VALIDATION ) System . out . println ( "!!! can not find elementDecl in the grammar, " + " the element localpart: " + element . localpart + "[" + fStringPool . toString ( element . localpart ) + "]" + " the element uri: " + element . uri + "[" + fStringPool . toString ( element . uri ) + "]" + " and the current enclosing scope: " + fCurrentScope ) ; } } if ( DEBUG_SCHEMA_VALIDATION ) { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; System . out . println ( "elementIndex: " + elementIndex + " \n and itsName : '" + fStringPool . toString ( fTempElementDecl . name . localpart ) + "' \n its ContentType:" + fTempElementDecl . type + "\n its ContentSpecIndex : " + fTempElementDecl . contentSpecIndex + "\n" + " and the current enclosing scope: " + fCurrentScope ) ; } } contentSpecType = getContentSpecType ( elementIndex ) ; if ( fGrammarIsSchemaGrammar && elementIndex != - 1 ) { if ( fXsiTypeAttValue > - 1 ) { String xsiType = fStringPool . toString ( fXsiTypeAttValue ) ; int colonP = xsiType . indexOf ( ":" ) ; String prefix = "" ; String localpart = xsiType ; if ( colonP > - 1 ) { prefix = xsiType . substring ( 0 , colonP ) ; localpart = xsiType . substring ( colonP + 1 ) ; } String uri = "" ; int uriIndex = - 1 ; if ( fNamespacesScope != null ) { uriIndex = fNamespacesScope . getNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) ) ; if ( uriIndex > - 1 ) { uri = fStringPool . toString ( uriIndex ) ; if ( uriIndex != fGrammarNameSpaceIndex ) { fGrammarNameSpaceIndex = fCurrentSchemaURI = uriIndex ; boolean success = switchGrammar ( fCurrentSchemaURI ) ; if ( ! success && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fCurrentSchemaURI ) + " , can not found" ) ; } } } } Hashtable complexRegistry = ( ( SchemaGrammar ) fGrammar ) . getComplexTypeRegistry ( ) ; DatatypeValidatorFactoryImpl dataTypeReg = ( ( SchemaGrammar ) fGrammar ) . getDatatypeRegistry ( ) ; if ( complexRegistry == null || dataTypeReg == null ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , fErrorReporter . getLocator ( ) . getSystemId ( ) + " line" + fErrorReporter . getLocator ( ) . getLineNumber ( ) + ", canot resolve xsi:type = " + xsiType + "  ---2" ) ; } else { TraverseSchema . ComplexTypeInfo typeInfo = ( TraverseSchema . ComplexTypeInfo ) complexRegistry . get ( uri + "," + localpart ) ; if ( typeInfo == null ) { if ( uri . length ( ) == 0 || uri . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { fXsiTypeValidator = dataTypeReg . getDatatypeValidator ( localpart ) ; } else fXsiTypeValidator = dataTypeReg . getDatatypeValidator ( uri + "," + localpart ) ; if ( fXsiTypeValidator == null ) reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "unresolved type : " + uri + "," + localpart + " found  in xsi:type handling" ) ; } else elementIndex = typeInfo . templateElementIndex ; } fXsiTypeAttValue = - 1 ; } fCurrentScope = ( ( SchemaGrammar ) fGrammar ) . getElementDefinedScope ( elementIndex ) ; String anotherSchemaURI = ( ( SchemaGrammar ) fGrammar ) . getElementFromAnotherSchemaURI ( elementIndex ) ; if ( anotherSchemaURI != null ) { if ( contentSpecType != - 1 && contentSpecType != XMLElementDecl . TYPE_SIMPLE && contentSpecType != XMLElementDecl . TYPE_EMPTY ) { TraverseSchema . ComplexTypeInfo typeInfo = ( ( SchemaGrammar ) fGrammar ) . getElementComplexTypeInfo ( elementIndex ) ; if ( typeInfo != null ) { elementIndex = typeInfo . templateElementIndex ; } } fGrammarNameSpaceIndex = fCurrentSchemaURI = fStringPool . addSymbol ( anotherSchemaURI ) ; boolean success = switchGrammar ( fCurrentSchemaURI ) ; if ( ! success && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_GENERIC_SCHEMA_ERROR , XMLMessages . SCHEMA_GENERIC_ERROR , "Grammar with uri : " + fStringPool . toString ( fCurrentSchemaURI ) + " , can not found" ) ; } } } if ( contentSpecType == - 1 && fValidating && ! fNeedValidationOff ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_NOT_DECLARED , XMLMessages . VC_ELEMENT_VALID , element . rawname ) ; } if ( fGrammar != null && fGrammarIsSchemaGrammar && elementIndex != - 1 ) { fAttrListHandle = addDefaultAttributes ( elementIndex , attrList , fAttrListHandle , fValidating , fStandaloneReader != - 1 ) ; } if ( fAttrListHandle != - 1 ) { fAttrList . endAttrList ( ) ; } if ( DEBUG_PRINT_ATTRIBUTES ) { String elementStr = fStringPool . toString ( element . rawname ) ; System . out . print ( "startElement: <" + elementStr ) ; if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { System . out . print ( " " + fStringPool . toString ( attrList . getAttrName ( index ) ) + "=\"" + fStringPool . toString ( attrList . getAttValue ( index ) ) + "\"" ) ; index = attrList . getNextAttr ( index ) ; } } System . out . println ( ">" ) ; } if ( fAttrListHandle != - 1 && ! fNeedValidationOff ) { int index = fAttrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attrNameIndex = attrList . getAttrName ( index ) ; if ( fStringPool . equalNames ( attrNameIndex , fXMLLang ) ) { fDocumentScanner . checkXMLLangAttributeValue ( attrList . getAttValue ( index ) ) ; } int _xmlns = fStringPool . addSymbol ( "xmlns" ) ; if ( attrNameIndex != _xmlns && attrList . getAttrPrefix ( index ) != _xmlns ) if ( fGrammar != null ) { fAttrNameLocator = getLocatorImpl ( fAttrNameLocator ) ; fTempQName . setValues ( attrList . getAttrPrefix ( index ) , attrList . getAttrLocalpart ( index ) , attrList . getAttrName ( index ) , attrList . getAttrURI ( index ) ) ; int attDefIndex = getAttDefByElementIndex ( elementIndex , fTempQName ) ; if ( fTempQName . uri != fXsiURI ) if ( attDefIndex == - 1 ) { if ( fValidating ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( attrList . getAttrName ( index ) ) } ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } else { fGrammar . getAttributeDecl ( attDefIndex , fTempAttDecl ) ; int attributeType = attributeTypeName ( fTempAttDecl ) ; attrList . setAttType ( index , attributeType ) ; if ( fValidating ) { if ( fGrammarIsDTDGrammar && ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ENTITY || fTempAttDecl . type == XMLAttributeDecl . TYPE_ENUMERATION || fTempAttDecl . type == XMLAttributeDecl . TYPE_ID || fTempAttDecl . type == XMLAttributeDecl . TYPE_IDREF || fTempAttDecl . type == XMLAttributeDecl . TYPE_NMTOKEN || fTempAttDecl . type == XMLAttributeDecl . TYPE_NOTATION ) ) { validateDTDattribute ( element , attrList . getAttValue ( index ) , fTempAttDecl ) ; } else if ( fGrammarIsSchemaGrammar && ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_ANY || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LIST || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL || fTempAttDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) ) { if ( fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_SKIP ) { } else if ( fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_STRICT || fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_LAX ) { boolean reportError = false ; boolean processContentStrict = fTempAttDecl . defaultType == XMLAttributeDecl . PROCESSCONTENTS_STRICT ; if ( fTempQName . uri == - 1 ) { if ( processContentStrict ) { reportError = true ; } } else { Grammar aGrammar = fGrammarResolver . getGrammar ( fStringPool . toString ( fTempQName . uri ) ) ; if ( aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { if ( processContentStrict ) { reportError = true ; } } else { SchemaGrammar sGrammar = ( SchemaGrammar ) aGrammar ; Hashtable attRegistry = sGrammar . getAttirubteDeclRegistry ( ) ; if ( attRegistry == null ) { if ( processContentStrict ) { reportError = true ; } } else { XMLAttributeDecl attDecl = ( XMLAttributeDecl ) attRegistry . get ( fStringPool . toString ( fTempQName . localpart ) ) ; if ( attDecl == null ) { if ( processContentStrict ) { reportError = true ; } } else { DatatypeValidator attDV = attDecl . datatypeValidator ; if ( attDV == null ) { if ( processContentStrict ) { reportError = true ; } } else { try { String unTrimValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; String value = unTrimValue . trim ( ) ; if ( attDecl . type == XMLAttributeDecl . TYPE_ID ) { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } if ( attDecl . type == XMLAttributeDecl . TYPE_IDREF ) { attDV . validate ( value , this . fStoreIDRef ) ; } else attDV . validate ( unTrimValue , null ) ; } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } } if ( reportError ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , "ANY---" + fStringPool . toString ( attrList . getAttrName ( index ) ) } ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } else if ( fTempAttDecl . datatypeValidator == null ) { Object [ ] args = { fStringPool . toString ( element . rawname ) , fStringPool . toString ( attrList . getAttrName ( index ) ) } ; System . out . println ( "[Error] Datatypevalidator for attribute " + fStringPool . toString ( attrList . getAttrName ( index ) ) + " not found in element type " + fStringPool . toString ( element . rawname ) ) ; fErrorReporter . reportError ( fAttrNameLocator , XMLMessages . XML_DOMAIN , XMLMessages . MSG_ATTRIBUTE_NOT_DECLARED , XMLMessages . VC_ATTRIBUTE_VALUE_TYPE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } else { try { String unTrimValue = fStringPool . toString ( attrList . getAttValue ( index ) ) ; String value = unTrimValue . trim ( ) ; if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_ID ) { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } else if ( fTempAttDecl . type == XMLAttributeDecl . TYPE_IDREF ) { fTempAttDecl . datatypeValidator . validate ( value , this . fStoreIDRef ) ; } else { fTempAttDecl . datatypeValidator . validate ( unTrimValue , null ) ; } } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } } } index = fAttrList . getNextAttr ( index ) ; } } } if ( fAttrListHandle != - 1 ) { int index = attrList . getFirstAttr ( fAttrListHandle ) ; while ( index != - 1 ) { int attName = attrList . getAttrName ( index ) ; if ( ! fStringPool . equalNames ( attName , fNamespacesPrefix ) ) { int attPrefix = attrList . getAttrPrefix ( index ) ; if ( attPrefix != fNamespacesPrefix ) { if ( attPrefix != - 1 ) { int uri = fNamespacesScope . getNamespaceForPrefix ( attPrefix ) ; if ( uri == - 1 ) { Object [ ] args = { fStringPool . toString ( attPrefix ) } ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , XMLMessages . XMLNS_DOMAIN , XMLMessages . MSG_PREFIX_DECLARED , XMLMessages . NC_PREFIX_DECLARED , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } attrList . setAttrURI ( index , uri ) ; } } } index = attrList . getNextAttr ( index ) ; } } fCurrentElementIndex = elementIndex ; fCurrentContentSpecType = contentSpecType ; if ( fValidating && contentSpecType == XMLElementDecl . TYPE_SIMPLE ) { fBufferDatatype = true ; fDatatypeBuffer . setLength ( 0 ) ; } fInElementContent = ( contentSpecType == XMLElementDecl . TYPE_CHILDREN ) ; } private void validateDTDattribute ( QName element , int attValue , XMLAttributeDecl attributeDecl ) throws Exception { AttributeValidator av = null ; switch ( attributeDecl . type ) { case XMLAttributeDecl . TYPE_ENTITY : { boolean isAlistAttribute = attributeDecl . list ; String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValENTITIES . validate ( value , null ) ; } else { fValENTITY . validate ( value , null ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( ex . getMajorCode ( ) != 1 && ex . getMinorCode ( ) != - 1 ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } else { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } } break ; case XMLAttributeDecl . TYPE_ENUMERATION : av = fAttValidatorENUMERATION ; break ; case XMLAttributeDecl . TYPE_ID : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { this . fStoreIDRef . setDatatypeObject ( fValID . validate ( value , null ) ) ; } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } } break ; case XMLAttributeDecl . TYPE_IDREF : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; boolean isAlistAttribute = attributeDecl . list ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValIDRefs . validate ( value , this . fStoreIDRef ) ; } else { fValIDRef . validate ( value , this . fStoreIDRef ) ; } } catch ( InvalidDatatypeValueException ex ) { if ( ex . getMajorCode ( ) != 1 && ex . getMinorCode ( ) != - 1 ) { reportRecoverableXMLError ( ex . getMajorCode ( ) , ex . getMinorCode ( ) , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } else { System . err . println ( "Error: " + ex . getLocalizedMessage ( ) ) ; } } } break ; case XMLAttributeDecl . TYPE_NOTATION : { av = fAttValidatorNOTATION ; } break ; case XMLAttributeDecl . TYPE_NMTOKEN : { String unTrimValue = fStringPool . toString ( attValue ) ; String value = unTrimValue . trim ( ) ; boolean isAlistAttribute = attributeDecl . list ; if ( fValidationEnabled ) { if ( value != unTrimValue ) { if ( invalidStandaloneAttDef ( element , attributeDecl . name ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attributeDecl . name . rawname ) , unTrimValue , value ) ; } } } try { if ( isAlistAttribute ) { fValNMTOKENS . validate ( value , null ) ; } else { fValNMTOKEN . validate ( value , null ) ; } } catch ( InvalidDatatypeValueException ex ) { reportRecoverableXMLError ( XMLMessages . MSG_NMTOKEN_INVALID , XMLMessages . VC_NAME_TOKEN , fStringPool . toString ( attributeDecl . name . rawname ) , value ) ; } } break ; } if ( av != null ) av . normalize ( element , attributeDecl . name , attValue , attributeDecl . type , attributeDecl . enumeration ) ; } private void charDataInContent ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . println ( "charDataInContent()" ) ; } if ( fElementChildren . length <= fElementChildrenLength ) { QName [ ] newarray = new QName [ fElementChildren . length * 2 ] ; System . arraycopy ( fElementChildren , 0 , newarray , 0 , fElementChildren . length ) ; fElementChildren = newarray ; } QName qname = fElementChildren [ fElementChildrenLength ] ; if ( qname == null ) { for ( int i = fElementChildrenLength ; i < fElementChildren . length ; i ++ ) { fElementChildren [ i ] = new QName ( ) ; } qname = fElementChildren [ fElementChildrenLength ] ; } qname . clear ( ) ; fElementChildrenLength ++ ; } private int checkContent ( int elementIndex , QName [ ] children , int childOffset , int childCount ) throws Exception { final int elementType = fCurrentElement . rawname ; if ( DEBUG_PRINT_CONTENT ) { String strTmp = fStringPool . toString ( elementType ) ; System . out . println ( "Name: " + strTmp + ", " + "Count: " + childCount + ", " + "ContentSpecType: " + fCurrentContentSpecType ) ; for ( int index = childOffset ; index < ( childOffset + childCount ) && index < 10 ; index ++ ) { if ( index == 0 ) { System . out . print ( "  (" ) ; } String childName = ( children [ index ] . localpart == - 1 ) ? "#PCDATA" : fStringPool . toString ( children [ index ] . localpart ) ; if ( index + 1 == childCount ) { System . out . println ( childName + ")" ) ; } else if ( index + 1 == 10 ) { System . out . println ( childName + ",...)" ) ; } else { System . out . print ( childName + "," ) ; } } } final int contentType = fCurrentContentSpecType ; if ( contentType == XMLElementDecl . TYPE_EMPTY ) { if ( childCount != 0 ) { return 0 ; } } else if ( contentType == XMLElementDecl . TYPE_ANY ) { } else if ( contentType == XMLElementDecl . TYPE_MIXED || contentType == XMLElementDecl . TYPE_CHILDREN ) { XMLContentModel cmElem = null ; try { cmElem = getElementContentModel ( elementIndex ) ; int result = cmElem . validateContent ( children , childOffset , childCount ) ; if ( result != - 1 && fGrammarIsSchemaGrammar ) { EquivClassComparator comparator = new EquivClassComparator ( fGrammarResolver , fStringPool ) ; cmElem . setEquivClassComparator ( comparator ) ; result = cmElem . validateContentSpecial ( children , childOffset , childCount ) ; } return result ; } catch ( CMException excToCatch ) { int majorCode = excToCatch . getErrorCode ( ) ; fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , majorCode , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } } else if ( contentType == - 1 ) { reportRecoverableXMLError ( XMLMessages . MSG_ELEMENT_NOT_DECLARED , XMLMessages . VC_ELEMENT_VALID , elementType ) ; } else if ( contentType == XMLElementDecl . TYPE_SIMPLE ) { XMLContentModel cmElem = null ; if ( childCount > 0 ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { "In element '" + fStringPool . toString ( elementType ) + "' : " + "Can not have element children within a simple type content" } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } else { try { fGrammar . getElementDecl ( elementIndex , fTempElementDecl ) ; DatatypeValidator dv = fTempElementDecl . datatypeValidator ; if ( fXsiTypeValidator != null ) { dv = fXsiTypeValidator ; fXsiTypeValidator = null ; } if ( dv == null ) { System . out . println ( "Internal Error: this element have a simpletype " + "but no datatypevalidator was found, element " + fTempElementDecl . name + ",locapart: " + fStringPool . toString ( fTempElementDecl . name . localpart ) ) ; } else { dv . validate ( fDatatypeBuffer . toString ( ) , null ) ; } } catch ( InvalidDatatypeValueException idve ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , SchemaMessageProvider . DatatypeError , SchemaMessageProvider . MSG_NONE , new Object [ ] { idve . getMessage ( ) } , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } } else { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , ImplementationMessages . VAL_CST , 0 , null , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; } return - 1 ; } private void printChildren ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . print ( '[' ) ; for ( int i = 0 ; i < fElementChildrenLength ; i ++ ) { System . out . print ( ' ' ) ; QName qname = fElementChildren [ i ] ; if ( qname != null ) { System . out . print ( fStringPool . toString ( qname . rawname ) ) ; } else { System . out . print ( "null" ) ; } if ( i < fElementChildrenLength - 1 ) { System . out . print ( ", " ) ; } System . out . flush ( ) ; } System . out . print ( " ]" ) ; System . out . println ( ) ; } } private void printStack ( ) { if ( DEBUG_ELEMENT_CHILDREN ) { System . out . print ( '{' ) ; for ( int i = 0 ; i <= fElementDepth ; i ++ ) { System . out . print ( ' ' ) ; System . out . print ( fElementChildrenOffsetStack [ i ] ) ; if ( i < fElementDepth ) { System . out . print ( ", " ) ; } System . out . flush ( ) ; } System . out . print ( " }" ) ; System . out . println ( ) ; } } public interface AttributeValidator { public int normalize ( QName element , QName attribute , int attValue , int attType , int enumHandle ) throws Exception ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } final class AttValidatorNOTATION implements AttributeValidator { public int normalize ( QName element , QName attribute , int attValueHandle , int attType , int enumHandle ) throws Exception { String attValue = fStringPool . toString ( attValueHandle ) ; String newAttValue = attValue . trim ( ) ; if ( fValidating ) { if ( newAttValue != attValue ) { if ( invalidStandaloneAttDef ( element , attribute ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attribute . rawname ) , attValue , newAttValue ) ; } attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } else { attValueHandle = fStringPool . addSymbol ( attValueHandle ) ; } if ( ! fStringPool . stringInList ( enumHandle , attValueHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_NOT_IN_LIST , XMLMessages . VC_NOTATION_ATTRIBUTES , fStringPool . toString ( attribute . rawname ) , newAttValue , fStringPool . stringListAsString ( enumHandle ) ) ; } } else if ( newAttValue != attValue ) { attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } return attValueHandle ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } } final class AttValidatorENUMERATION implements AttributeValidator { public int normalize ( QName element , QName attribute , int attValueHandle , int attType , int enumHandle ) throws Exception { String attValue = fStringPool . toString ( attValueHandle ) ; String newAttValue = attValue . trim ( ) ; if ( fValidating ) { if ( newAttValue != attValue ) { if ( invalidStandaloneAttDef ( element , attribute ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE , XMLMessages . VC_STANDALONE_DOCUMENT_DECLARATION , fStringPool . toString ( attribute . rawname ) , attValue , newAttValue ) ; } attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } else { attValueHandle = fStringPool . addSymbol ( attValueHandle ) ; } if ( ! fStringPool . stringInList ( enumHandle , attValueHandle ) ) { reportRecoverableXMLError ( XMLMessages . MSG_ATTRIBUTE_VALUE_NOT_IN_LIST , XMLMessages . VC_ENUMERATION , fStringPool . toString ( attribute . rawname ) , newAttValue , fStringPool . stringListAsString ( enumHandle ) ) ; } } else if ( newAttValue != attValue ) { attValueHandle = fStringPool . addSymbol ( newAttValue ) ; } return attValueHandle ; } boolean invalidStandaloneAttDef ( QName element , QName attribute ) { if ( fStandaloneReader == - 1 ) { return false ; } if ( element . rawname == - 1 ) { return false ; } return getAttDefIsExternal ( element , attribute ) ; } } } 	1
package org . xml . sax ; public interface Locator { public abstract String getPublicId ( ) ; public abstract String getSystemId ( ) ; public abstract int getLineNumber ( ) ; public abstract int getColumnNumber ( ) ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class ElementNSImpl extends ElementImpl { static final long serialVersionUID = - 9142310625494392642L ; protected String namespaceURI ; protected String localName ; protected ElementNSImpl ( DocumentImpl ownerDocument , String namespaceURI , String qualifiedName ) throws DOMException { super ( ownerDocument , qualifiedName ) ; if ( ! DocumentImpl . isXMLName ( qualifiedName ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } int index = qualifiedName . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = qualifiedName ; } else { prefix = qualifiedName . substring ( 0 , index ) ; localName = qualifiedName . substring ( index + 1 ) ; } if ( prefix != null && ( namespaceURI == null || namespaceURI . equals ( "" ) || ( prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } this . namespaceURI = namespaceURI ; } protected ElementNSImpl ( DocumentImpl ownerDocument , String value ) { super ( ownerDocument , value ) ; } public String getNamespaceURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return namespaceURI ; } public String getPrefix ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int index = name . indexOf ( ':' ) ; return index < 0 ? null : name . substring ( 0 , index ) ; } public void setPrefix ( String prefix ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( namespaceURI == null || ( prefix != null && prefix . equals ( "xml" ) && ! namespaceURI . equals ( "http://www.w3.org/XML/1998/namespace" ) ) ) { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } if ( ownerDocument . errorChecking && ! DocumentImpl . isXMLName ( prefix ) ) { throw new DOMExceptionImpl ( DOMException . INVALID_CHARACTER_ERR , "DOM002 Illegal character" ) ; } name = prefix + ":" + localName ; } public String getLocalName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return localName ; } } 	1
package org . apache . xerces . validators . datatype ; public class InvalidDatatypeFacetException extends XMLException { private int majorCode = - 1 ; private int minorCode = - 1 ; public int getMinorCode ( ) { return minorCode ; } public int getMajorCode ( ) { return majorCode ; } public void setMinorCode ( int code ) { majorCode = code ; } public void setMajorCode ( int code ) { minorCode = code ; } public InvalidDatatypeFacetException ( ) { super ( ) ; } public InvalidDatatypeFacetException ( String message ) { super ( message ) ; } public InvalidDatatypeFacetException ( Exception exception ) { super ( exception ) ; } public InvalidDatatypeFacetException ( String message , Exception exception ) { super ( message , exception ) ; } } 	0
package org . w3c . dom ; public interface Document extends Node { public DocumentType getDoctype ( ) ; public DOMImplementation getImplementation ( ) ; public Element getDocumentElement ( ) ; public Element createElement ( String tagName ) throws DOMException ; public DocumentFragment createDocumentFragment ( ) ; public Text createTextNode ( String data ) ; public Comment createComment ( String data ) ; public CDATASection createCDATASection ( String data ) throws DOMException ; public ProcessingInstruction createProcessingInstruction ( String target , String data ) throws DOMException ; public Attr createAttribute ( String name ) throws DOMException ; public EntityReference createEntityReference ( String name ) throws DOMException ; public NodeList getElementsByTagName ( String tagname ) ; public Node importNode ( Node importedNode , boolean deep ) throws DOMException ; public Element createElementNS ( String namespaceURI , String qualifiedName ) throws DOMException ; public Attr createAttributeNS ( String namespaceURI , String qualifiedName ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public Element getElementById ( String elementId ) ; } 	1
package org . w3c . dom . html ; public interface HTMLAreaElement extends HTMLElement { public String getAccessKey ( ) ; public void setAccessKey ( String accessKey ) ; public String getAlt ( ) ; public void setAlt ( String alt ) ; public String getCoords ( ) ; public void setCoords ( String coords ) ; public String getHref ( ) ; public void setHref ( String href ) ; public boolean getNoHref ( ) ; public void setNoHref ( boolean noHref ) ; public String getShape ( ) ; public void setShape ( String shape ) ; public int getTabIndex ( ) ; public void setTabIndex ( int tabIndex ) ; public String getTarget ( ) ; public void setTarget ( String target ) ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface NodeIterator { public Node getRoot ( ) ; public int getWhatToShow ( ) ; public NodeFilter getFilter ( ) ; public boolean getExpandEntityReferences ( ) ; public Node nextNode ( ) throws DOMException ; public Node previousNode ( ) throws DOMException ; public void detach ( ) ; } 	1
package org . apache . xerces . dom ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . xerces . utils . StringPool ; import org . w3c . dom . * ; public class DeferredElementImpl extends ElementImpl implements DeferredNode { static final long serialVersionUID = - 7670981133940934842L ; protected transient int fNodeIndex ; DeferredElementImpl ( DeferredDocumentImpl ownerDoc , int nodeIndex ) { super ( ownerDoc , null ) ; fNodeIndex = nodeIndex ; needsSyncChildren ( true ) ; } public final int getNodeIndex ( ) { return fNodeIndex ; } protected final void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; int elementTypeName = ownerDocument . getNodeName ( fNodeIndex ) ; StringPool pool = ownerDocument . getStringPool ( ) ; name = pool . toString ( elementTypeName ) ; setupDefaultAttributes ( ) ; int index = ownerDocument . getNodeValue ( fNodeIndex ) ; if ( index != - 1 ) { NamedNodeMap attrs = getAttributes ( ) ; do { NodeImpl attr = ( NodeImpl ) ownerDocument . getNodeObject ( index ) ; attrs . setNamedItem ( attr ) ; index = ownerDocument . getPrevSibling ( index ) ; } while ( index != - 1 ) ; } } protected final void synchronizeChildren ( ) { synchronizeChildren ( fNodeIndex ) ; } } 	0
package org . w3c . dom . events ; public class EventException extends RuntimeException { public EventException ( short code , String message ) { super ( message ) ; this . code = code ; } public short code ; public static final short UNSPECIFIED_EVENT_TYPE_ERR = 0 ; } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class CDATASectionImpl extends TextImpl implements CDATASection { static final long serialVersionUID = 2372071297878177780L ; public CDATASectionImpl ( DocumentImpl ownerDoc , String data ) { super ( ownerDoc , data ) ; } public short getNodeType ( ) { return Node . CDATA_SECTION_NODE ; } public String getNodeName ( ) { return "#cdata-section" ; } } 	0
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface DeclHandler { public abstract void elementDecl ( String name , String model ) throws SAXException ; public abstract void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException ; public abstract void internalEntityDecl ( String name , String value ) throws SAXException ; public abstract void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException ; } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLHeadElementImpl extends HTMLElementImpl implements HTMLHeadElement { public String getProfile ( ) { return getAttribute ( "profile" ) ; } public void setProfile ( String profile ) { setAttribute ( "profile" , profile ) ; } public HTMLHeadElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . validators . schema ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . validators . common . Grammar ; import org . apache . xerces . validators . common . GrammarResolver ; import org . apache . xerces . validators . common . GrammarResolverImpl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . validators . schema . XUtil ; import org . apache . xerces . validators . datatype . DatatypeValidator ; import org . apache . xerces . validators . datatype . DatatypeValidatorFactoryImpl ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . utils . StringPool ; import org . w3c . dom . Element ; import org . w3c . dom . * ; import java . util . * ; import java . net . URL ; import java . net . MalformedURLException ; import org . apache . xerces . parsers . DOMParser ; import org . apache . xerces . validators . common . XMLValidator ; import org . apache . xerces . validators . datatype . DatatypeValidator . * ; import org . apache . xerces . validators . datatype . InvalidDatatypeValueException ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . NamespacesScope ; import org . apache . xerces . parsers . SAXParser ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . framework . XMLDocumentScanner ; import org . xml . sax . InputSource ; import org . xml . sax . SAXParseException ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import java . io . IOException ; import org . w3c . dom . Document ; import org . apache . xml . serialize . OutputFormat ; import org . apache . xml . serialize . XMLSerializer ; import org . apache . xerces . validators . schema . SchemaSymbols ; public class TraverseSchema implements NamespacesScope . NamespacesHandler { private static final int TOP_LEVEL_SCOPE = - 1 ; private static boolean DEBUGGING = false ; private XMLErrorReporter fErrorReporter = null ; private StringPool fStringPool = null ; private GrammarResolver fGrammarResolver = null ; private SchemaGrammar fSchemaGrammar = null ; private Element fSchemaRootElement ; private DatatypeValidatorFactoryImpl fDatatypeRegistry = DatatypeValidatorFactoryImpl . getDatatypeRegistry ( ) ; private Hashtable fComplexTypeRegistry = new Hashtable ( ) ; private Hashtable fAttributeDeclRegistry = new Hashtable ( ) ; private Vector fIncludeLocations = new Vector ( ) ; private Vector fImportLocations = new Vector ( ) ; private int fAnonTypeCount = 0 ; private int fScopeCount = 0 ; private int fCurrentScope = TOP_LEVEL_SCOPE ; private int fSimpleTypeAnonCount = 0 ; private Stack fCurrentTypeNameStack = new Stack ( ) ; private Hashtable fElementRecurseComplex = new Hashtable ( ) ; private boolean fElementDefaultQualified = false ; private boolean fAttributeDefaultQualified = false ; private int fTargetNSURI ; private String fTargetNSURIString = "" ; private NamespacesScope fNamespacesScope = null ; private String fCurrentSchemaURL = "" ; private XMLAttributeDecl fTempAttributeDecl = new XMLAttributeDecl ( ) ; private XMLElementDecl fTempElementDecl = new XMLElementDecl ( ) ; public class ComplexTypeInfo { public String typeName ; public DatatypeValidator baseDataTypeValidator ; public ComplexTypeInfo baseComplexTypeInfo ; public int derivedBy = 0 ; public int blockSet = 0 ; public int finalSet = 0 ; public boolean isAbstract = false ; public int scopeDefined = - 1 ; public int contentType ; public int contentSpecHandle = - 1 ; public int templateElementIndex = - 1 ; public int attlistHead = - 1 ; public DatatypeValidator datatypeValidator ; } public final static String SchemaForSchemaURI = "http://www.w3.org/TR-1/Schema" ; private TraverseSchema ( ) { } public void setGrammarResolver ( GrammarResolver grammarResolver ) { fGrammarResolver = grammarResolver ; } public void startNamespaceDeclScope ( int prefix , int uri ) { } public void endNamespaceDeclScope ( int prefix ) { } private String resolvePrefixToURI ( String prefix ) throws Exception { String uriStr = fStringPool . toString ( fNamespacesScope . getNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) ) ) ; if ( uriStr == null ) { reportGenericSchemaError ( "prefix : [" + prefix + "] can not be resolved to a URI" ) ; return "" ; } if ( prefix . length ( ) == 0 && uriStr . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && fTargetNSURIString . length ( ) == 0 ) { uriStr = "" ; } return uriStr ; } public TraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver , XMLErrorReporter errorReporter , String schemaURL ) throws Exception { fErrorReporter = errorReporter ; fCurrentSchemaURL = schemaURL ; doTraverseSchema ( root , stringPool , schemaGrammar , grammarResolver ) ; } public TraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver ) throws Exception { doTraverseSchema ( root , stringPool , schemaGrammar , grammarResolver ) ; } public void doTraverseSchema ( Element root , StringPool stringPool , SchemaGrammar schemaGrammar , GrammarResolver grammarResolver ) throws Exception { fNamespacesScope = new NamespacesScope ( this ) ; fSchemaRootElement = root ; fStringPool = stringPool ; fSchemaGrammar = schemaGrammar ; fGrammarResolver = grammarResolver ; if ( root == null ) { return ; } String rootPrefix = root . getPrefix ( ) ; if ( rootPrefix == null || rootPrefix . length ( ) == 0 ) { String xmlns = root . getAttribute ( "xmlns" ) ; if ( xmlns . length ( ) == 0 ) root . setAttribute ( "xmlns" , SchemaSymbols . URI_SCHEMAFORSCHEMA ) ; } fTargetNSURIString = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( fTargetNSURIString == null ) { fTargetNSURIString = "" ; } fTargetNSURI = fStringPool . addSymbol ( fTargetNSURIString ) ; if ( fGrammarResolver == null ) { reportGenericSchemaError ( "Internal error: don't have a GrammarResolver for TraverseSchema" ) ; } else { fSchemaGrammar . setComplexTypeRegistry ( fComplexTypeRegistry ) ; fSchemaGrammar . setDatatypeRegistry ( fDatatypeRegistry ) ; fSchemaGrammar . setAttributeDeclRegistry ( fAttributeDeclRegistry ) ; fSchemaGrammar . setNamespacesScope ( fNamespacesScope ) ; fSchemaGrammar . setTargetNamespaceURI ( fTargetNSURIString ) ; fGrammarResolver . putGrammar ( fTargetNSURIString , fSchemaGrammar ) ; } NamedNodeMap schemaEltAttrs = root . getAttributes ( ) ; int i = 0 ; Attr sattr = null ; boolean seenXMLNS = false ; while ( ( sattr = ( Attr ) schemaEltAttrs . item ( i ++ ) ) != null ) { String attName = sattr . getName ( ) ; if ( attName . startsWith ( "xmlns:" ) ) { String attValue = sattr . getValue ( ) ; String prefix = attName . substring ( attName . indexOf ( ":" ) + 1 ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) , fStringPool . addSymbol ( attValue ) ) ; } if ( attName . equals ( "xmlns" ) ) { String attValue = sattr . getValue ( ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( attValue ) ) ; seenXMLNS = true ; } } if ( ! seenXMLNS && fTargetNSURIString . length ( ) == 0 ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } fElementDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ELEMENTFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; fAttributeDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ATTRIBUTEFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; if ( fTargetNSURI == StringPool . EMPTY_STRING ) { fElementDefaultQualified = true ; } fCurrentScope = - 1 ; checkTopLevelDuplicateNames ( root ) ; extractTopLevel3Components ( root ) ; for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { traverseSimpleTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { traverseComplexTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ELEMENT ) ) { traverseElementDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , null ) ; } else if ( name . equals ( SchemaSymbols . ELT_WILDCARD ) ) { traverseWildcardDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { } else if ( name . equals ( SchemaSymbols . ELT_NOTATION ) ) { ; } else if ( name . equals ( SchemaSymbols . ELT_INCLUDE ) ) { traverseInclude ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_IMPORT ) ) { traverseImport ( child ) ; } } } private void checkTopLevelDuplicateNames ( Element root ) { } private void extractTopLevel3Components ( Element root ) { for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { fSchemaGrammar . topLevelAttrGrpDecls . put ( name , child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { fSchemaGrammar . topLevelAttrDecls . put ( name , child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { fSchemaGrammar . topLevelGroupDecls . put ( name , child ) ; } } } private String expandSystemId ( String systemId , String currentSystemId ) throws Exception { String id = systemId ; if ( id == null || id . length ( ) == 0 ) { return systemId ; } try { URL url = new URL ( id ) ; if ( url != null ) { return systemId ; } } catch ( MalformedURLException e ) { } id = fixURI ( id ) ; URL base = null ; URL url = null ; try { if ( currentSystemId == null ) { String dir ; try { dir = fixURI ( System . getProperty ( "user.dir" ) ) ; } catch ( SecurityException se ) { dir = "" ; } if ( ! dir . endsWith ( "/" ) ) { dir = dir + "/" ; } base = new URL ( "file" , "" , dir ) ; } else { base = new URL ( currentSystemId ) ; } url = new URL ( base , id ) ; } catch ( Exception e ) { } if ( url == null ) { return systemId ; } return url . toString ( ) ; } private static String fixURI ( String str ) { str = str . replace ( java . io . File . separatorChar , '/' ) ; if ( str . length ( ) >= 2 ) { char ch1 = str . charAt ( 1 ) ; if ( ch1 == ':' ) { char ch0 = Character . toUpperCase ( str . charAt ( 0 ) ) ; if ( ch0 >= 'A' && ch0 <= 'Z' ) { str = "/" + str ; } } } return str ; } private void traverseInclude ( Element includeDecl ) throws Exception { String location = includeDecl . getAttribute ( SchemaSymbols . ATT_SCHEMALOCATION ) ; location = expandSystemId ( location , fCurrentSchemaURL ) ; if ( fIncludeLocations . contains ( ( Object ) location ) ) { return ; } fIncludeLocations . addElement ( ( Object ) location ) ; DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( location ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { } Document document = parser . getDocument ( ) ; Element root = null ; if ( document != null ) { root = document . getDocumentElement ( ) ; } if ( root != null ) { String targetNSURI = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( targetNSURI . length ( ) > 0 && ! targetNSURI . equals ( fTargetNSURIString ) ) { reportGenericSchemaError ( "included schema '" + location + "' has a different targetNameSpace '" + targetNSURI + "'" ) ; } else { boolean saveElementDefaultQualified = fElementDefaultQualified ; boolean saveAttributeDefaultQualified = fAttributeDefaultQualified ; int saveScope = fCurrentScope ; String savedSchemaURL = fCurrentSchemaURL ; Element saveRoot = fSchemaRootElement ; fSchemaRootElement = root ; fCurrentSchemaURL = location ; traverseIncludedSchema ( root ) ; fCurrentSchemaURL = savedSchemaURL ; fCurrentScope = saveScope ; fElementDefaultQualified = saveElementDefaultQualified ; fAttributeDefaultQualified = saveAttributeDefaultQualified ; fSchemaRootElement = saveRoot ; } } } private void traverseIncludedSchema ( Element root ) throws Exception { NamedNodeMap schemaEltAttrs = root . getAttributes ( ) ; int i = 0 ; Attr sattr = null ; boolean seenXMLNS = false ; while ( ( sattr = ( Attr ) schemaEltAttrs . item ( i ++ ) ) != null ) { String attName = sattr . getName ( ) ; if ( attName . startsWith ( "xmlns:" ) ) { String attValue = sattr . getValue ( ) ; String prefix = attName . substring ( attName . indexOf ( ":" ) + 1 ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( prefix ) , fStringPool . addSymbol ( attValue ) ) ; } if ( attName . equals ( "xmlns" ) ) { String attValue = sattr . getValue ( ) ; fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( attValue ) ) ; seenXMLNS = true ; } } if ( ! seenXMLNS && fTargetNSURIString . length ( ) == 0 ) { fNamespacesScope . setNamespaceForPrefix ( fStringPool . addSymbol ( "" ) , fStringPool . addSymbol ( "" ) ) ; } fElementDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ELEMENTFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; fAttributeDefaultQualified = root . getAttribute ( SchemaSymbols . ATT_ATTRIBUTEFORMDEFAULT ) . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) ; if ( fTargetNSURI == StringPool . EMPTY_STRING ) { fElementDefaultQualified = true ; } fCurrentScope = - 1 ; checkTopLevelDuplicateNames ( root ) ; extractTopLevel3Components ( root ) ; for ( Element child = XUtil . getFirstChildElement ( root ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String name = child . getNodeName ( ) ; if ( name . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { traverseSimpleTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { traverseComplexTypeDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ELEMENT ) ) { traverseElementDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { } else if ( name . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , null ) ; } else if ( name . equals ( SchemaSymbols . ELT_WILDCARD ) ) { traverseWildcardDecl ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_GROUP ) && child . getAttribute ( SchemaSymbols . ATT_REF ) . equals ( "" ) ) { } else if ( name . equals ( SchemaSymbols . ELT_NOTATION ) ) { ; } else if ( name . equals ( SchemaSymbols . ELT_INCLUDE ) ) { traverseInclude ( child ) ; } else if ( name . equals ( SchemaSymbols . ELT_IMPORT ) ) { traverseImport ( child ) ; } } } private void traverseImport ( Element importDecl ) throws Exception { String location = importDecl . getAttribute ( SchemaSymbols . ATT_SCHEMALOCATION ) ; location = expandSystemId ( location , fCurrentSchemaURL ) ; String namespaceString = importDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) ; SchemaGrammar importedGrammar = new SchemaGrammar ( ) ; if ( fGrammarResolver . getGrammar ( namespaceString ) != null ) { importedGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( namespaceString ) ; } if ( fImportLocations . contains ( ( Object ) location ) ) { return ; } fImportLocations . addElement ( ( Object ) location ) ; DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://xml.org/sax/features/namespaces" , true ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( location ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } Document document = parser . getDocument ( ) ; Element root = null ; if ( document != null ) { root = document . getDocumentElement ( ) ; } if ( root != null ) { String targetNSURI = root . getAttribute ( SchemaSymbols . ATT_TARGETNAMESPACE ) ; if ( ! targetNSURI . equals ( namespaceString ) ) { reportGenericSchemaError ( "imported schema '" + location + "' has a different targetNameSpace '" + targetNSURI + "' from what is declared '" + namespaceString + "'." ) ; } else new TraverseSchema ( root , fStringPool , importedGrammar , fGrammarResolver , fErrorReporter , location ) ; } else { reportGenericSchemaError ( "Could not get the doc root for imported Schema file: " + location ) ; } } private void traverseAnnotationDecl ( Element comment ) { return ; } private int traverseSimpleTypeDecl ( Element simpleTypeDecl ) throws Exception { String varietyProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_DERIVEDBY ) ; if ( varietyProperty . length ( ) == 0 ) { varietyProperty = SchemaSymbols . ATTVAL_RESTRICTION ; } String nameProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; String baseTypeQNameProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) ; String abstractProperty = simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) ; int newSimpleTypeName = - 1 ; if ( nameProperty . equals ( "" ) ) { newSimpleTypeName = fStringPool . addSymbol ( "#S#" + fSimpleTypeAnonCount ++ ) ; } else newSimpleTypeName = fStringPool . addSymbol ( nameProperty ) ; int basetype ; DatatypeValidator baseValidator = null ; if ( baseTypeQNameProperty != null ) { basetype = fStringPool . addSymbol ( baseTypeQNameProperty ) ; String prefix = "" ; String localpart = baseTypeQNameProperty ; int colonptr = baseTypeQNameProperty . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = baseTypeQNameProperty . substring ( 0 , colonptr ) ; localpart = baseTypeQNameProperty . substring ( colonptr + 1 ) ; } String uri = resolvePrefixToURI ( prefix ) ; baseValidator = getDatatypeValidator ( uri , localpart ) ; if ( baseValidator == null ) { Element baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( baseTypeNode != null ) { traverseSimpleTypeDecl ( baseTypeNode ) ; baseValidator = getDatatypeValidator ( uri , localpart ) ; if ( baseValidator == null ) { reportSchemaError ( SchemaMessageProvider . UnknownBaseDatatype , new Object [ ] { simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) , simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) } ) ; return - 1 ; } } else { reportSchemaError ( SchemaMessageProvider . UnknownBaseDatatype , new Object [ ] { simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) , simpleTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) } ) ; return - 1 ; } } } Element content = XUtil . getFirstChildElement ( simpleTypeDecl ) ; int numFacets = 0 ; Hashtable facetData = null ; if ( content != null ) { if ( content . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content ) ; content = XUtil . getNextSiblingElement ( content ) ; } int numEnumerationLiterals = 0 ; facetData = new Hashtable ( ) ; Vector enumData = new Vector ( ) ; while ( content != null ) { if ( content . getNodeType ( ) == Node . ELEMENT_NODE ) { Element facetElt = ( Element ) content ; numFacets ++ ; if ( facetElt . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { numEnumerationLiterals ++ ; String enumVal = facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ; enumData . addElement ( enumVal ) ; Element enumContent = XUtil . getFirstChildElement ( facetElt ) ; if ( enumContent != null && enumContent != null && enumContent . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content ) ; } } else { facetData . put ( facetElt . getNodeName ( ) , facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; } } content = XUtil . getNextSiblingElement ( content ) ; } if ( numEnumerationLiterals > 0 ) { facetData . put ( SchemaSymbols . ELT_ENUMERATION , enumData ) ; } } String nameOfType = fStringPool . toString ( newSimpleTypeName ) ; if ( fTargetNSURIString . length ( ) != 0 ) { nameOfType = fTargetNSURIString + "," + nameOfType ; } try { DatatypeValidator newValidator = fDatatypeRegistry . getDatatypeValidator ( nameOfType ) ; if ( newValidator == null ) { boolean derivedByList = varietyProperty . equals ( SchemaSymbols . ATTVAL_LIST ) ? true : false ; fDatatypeRegistry . createDatatypeValidator ( nameOfType , baseValidator , facetData , derivedByList ) ; } } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . DatatypeError , new Object [ ] { e . getMessage ( ) } ) ; } return fStringPool . addSymbol ( nameOfType ) ; } private int traverseAny ( Element child ) throws Exception { int anyIndex = - 1 ; String namespace = child . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) . trim ( ) ; String processContents = child . getAttribute ( "processContents" ) . trim ( ) ; int processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY ; int processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER ; int processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL ; if ( processContents . length ( ) > 0 && ! processContents . equals ( "strict" ) ) { if ( processContents . equals ( "lax" ) ) { processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY_LAX ; processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_LAX ; processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_LAX ; } else if ( processContents . equals ( "skip" ) ) { processContentsAny = XMLContentSpec . CONTENTSPECNODE_ANY_SKIP ; processContentsAnyOther = XMLContentSpec . CONTENTSPECNODE_ANY_OTHER_SKIP ; processContentsAnyLocal = XMLContentSpec . CONTENTSPECNODE_ANY_LOCAL_SKIP ; } } if ( namespace . length ( ) == 0 || namespace . equals ( "##any" ) ) { anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , - 1 , false ) ; } else if ( namespace . equals ( "##other" ) ) { String uri = child . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; int uriIndex = fStringPool . addSymbol ( uri ) ; anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAnyOther , - 1 , uriIndex , false ) ; } else if ( namespace . equals ( "##local" ) ) { anyIndex = fSchemaGrammar . addContentSpecNode ( processContentsAnyLocal , - 1 , - 1 , false ) ; } else if ( namespace . length ( ) > 0 ) { StringTokenizer tokenizer = new StringTokenizer ( namespace ) ; Vector tokens = new Vector ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( "##targetNamespace" ) ) { token = child . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; } tokens . addElement ( token ) ; } String uri = ( String ) tokens . elementAt ( 0 ) ; int uriIndex = fStringPool . addSymbol ( uri ) ; int leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; int valueIndex = leafIndex ; int count = tokens . size ( ) ; if ( count > 1 ) { uri = ( String ) tokens . elementAt ( 1 ) ; uriIndex = fStringPool . addSymbol ( uri ) ; leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; int otherValueIndex = leafIndex ; int choiceIndex = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , valueIndex , otherValueIndex , false ) ; for ( int i = 2 ; i < count ; i ++ ) { uri = ( String ) tokens . elementAt ( i ) ; uriIndex = fStringPool . addSymbol ( uri ) ; leafIndex = fSchemaGrammar . addContentSpecNode ( processContentsAny , - 1 , uriIndex , false ) ; otherValueIndex = leafIndex ; choiceIndex = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , choiceIndex , otherValueIndex , false ) ; } anyIndex = choiceIndex ; } else { anyIndex = leafIndex ; } } else { reportGenericSchemaError ( "Empty namespace attribute for any element" ) ; } return anyIndex ; } public DatatypeValidator getDatatypeValidator ( String uri , String localpart ) { DatatypeValidator dv = null ; if ( uri . length ( ) == 0 || uri . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { dv = fDatatypeRegistry . getDatatypeValidator ( localpart ) ; } else { dv = fDatatypeRegistry . getDatatypeValidator ( uri + "," + localpart ) ; } return dv ; } private XMLAttributeDecl traverseAnyAttribute ( Element anyAttributeDecl ) throws Exception { XMLAttributeDecl anyAttDecl = new XMLAttributeDecl ( ) ; String processContents = anyAttributeDecl . getAttribute ( SchemaSymbols . ATT_PROCESSCONTENTS ) . trim ( ) ; String namespace = anyAttributeDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) . trim ( ) ; String curTargetUri = anyAttributeDecl . getOwnerDocument ( ) . getDocumentElement ( ) . getAttribute ( "targetNamespace" ) ; if ( namespace . length ( ) == 0 || namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDANY ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_ANY ; } else if ( namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDOTHER ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_OTHER ; anyAttDecl . name . uri = fStringPool . addSymbol ( curTargetUri ) ; } else if ( namespace . equals ( SchemaSymbols . ATTVAL_TWOPOUNDLOCAL ) ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_LOCAL ; } else if ( namespace . length ( ) > 0 ) { anyAttDecl . type = XMLAttributeDecl . TYPE_ANY_LIST ; StringTokenizer tokenizer = new StringTokenizer ( namespace ) ; int aStringList = fStringPool . startStringList ( ) ; Vector tokens = new Vector ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( "##targetNamespace" ) ) { token = curTargetUri ; } if ( ! fStringPool . addStringToList ( aStringList , fStringPool . addSymbol ( token ) ) ) { reportGenericSchemaError ( "Internal StringPool error when reading the " + "namespace attribute for anyattribute declaration" ) ; } } fStringPool . finishStringList ( aStringList ) ; anyAttDecl . enumeration = aStringList ; } else { reportGenericSchemaError ( "Empty namespace attribute for anyattribute declaration" ) ; } anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_STRICT ; if ( processContents . equals ( SchemaSymbols . ATTVAL_SKIP ) ) { anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_SKIP ; } else if ( processContents . equals ( SchemaSymbols . ATTVAL_LAX ) ) { anyAttDecl . defaultType = XMLAttributeDecl . PROCESSCONTENTS_LAX ; } return anyAttDecl ; } private XMLAttributeDecl mergeTwoAnyAttribute ( XMLAttributeDecl oneAny , XMLAttributeDecl anotherAny ) { if ( oneAny . type == - 1 ) { return oneAny ; } if ( anotherAny . type == - 1 ) { return anotherAny ; } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return anotherAny ; } if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_ANY ) { return oneAny ; } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( anotherAny . name . uri == oneAny . name . uri ) { return oneAny ; } else { oneAny . type = - 1 ; return oneAny ; } } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { return anotherAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( ! fStringPool . stringInList ( anotherAny . enumeration , oneAny . name . uri ) ) { return anotherAny ; } else { int [ ] anotherAnyURIs = fStringPool . stringListAsIntArray ( anotherAny . enumeration ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < anotherAnyURIs . length ; i ++ ) { if ( anotherAnyURIs [ i ] != oneAny . name . uri ) { fStringPool . addStringToList ( newList , anotherAnyURIs [ i ] ) ; } } fStringPool . finishStringList ( newList ) ; anotherAny . enumeration = newList ; return anotherAny ; } } } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER || anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { return oneAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { oneAny . type = - 1 ; return oneAny ; } } if ( oneAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( ! fStringPool . stringInList ( oneAny . enumeration , anotherAny . name . uri ) ) { return oneAny ; } else { int [ ] oneAnyURIs = fStringPool . stringListAsIntArray ( oneAny . enumeration ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < oneAnyURIs . length ; i ++ ) { if ( oneAnyURIs [ i ] != anotherAny . name . uri ) { fStringPool . addStringToList ( newList , oneAnyURIs [ i ] ) ; } } fStringPool . finishStringList ( newList ) ; oneAny . enumeration = newList ; return oneAny ; } } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LOCAL ) { oneAny . type = - 1 ; return oneAny ; } else if ( anotherAny . type == XMLAttributeDecl . TYPE_ANY_LIST ) { int [ ] result = intersect2sets ( fStringPool . stringListAsIntArray ( oneAny . enumeration ) , fStringPool . stringListAsIntArray ( anotherAny . enumeration ) ) ; int newList = fStringPool . startStringList ( ) ; for ( int i = 0 ; i < result . length ; i ++ ) { fStringPool . addStringToList ( newList , result [ i ] ) ; } fStringPool . finishStringList ( newList ) ; oneAny . enumeration = newList ; return oneAny ; } } return oneAny ; } int [ ] intersect2sets ( int [ ] one , int [ ] theOther ) { int [ ] result = new int [ ( one . length > theOther . length ? one . length : theOther . length ) ] ; int count = 0 ; for ( int i = 0 ; i < one . length ; i ++ ) { for ( int j = 0 ; j < theOther . length ; j ++ ) { if ( one [ i ] == theOther [ j ] ) { result [ count ++ ] = one [ i ] ; } } } int [ ] result2 = new int [ count ] ; System . arraycopy ( result , 0 , result2 , 0 , count ) ; return result2 ; } private int traverseComplexTypeDecl ( Element complexTypeDecl ) throws Exception { String isAbstract = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) ; String base = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BASE ) ; String blockSet = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ; String content = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_CONTENT ) ; String derivedBy = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_DERIVEDBY ) ; String finalSet = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ; String typeId = complexTypeDecl . getAttribute ( SchemaSymbols . ATTVAL_ID ) ; String typeName = complexTypeDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; boolean isNamedType = false ; if ( DEBUGGING ) System . out . println ( "traversing complex Type : " + typeName + "," + base + "," + content + "." ) ; if ( typeName . equals ( "" ) ) { typeName = "#" + fAnonTypeCount ++ ; } else { fCurrentTypeNameStack . push ( typeName ) ; isNamedType = true ; } if ( isTopLevel ( complexTypeDecl ) ) { String fullName = fTargetNSURIString + "," + typeName ; ComplexTypeInfo temp = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fullName ) ; if ( temp != null ) { return fStringPool . addSymbol ( fullName ) ; } } int scopeDefined = fScopeCount ++ ; int previousScope = fCurrentScope ; fCurrentScope = scopeDefined ; Element child = null ; int contentSpecType = - 1 ; int csnType = 0 ; int left = - 2 ; int right = - 2 ; ComplexTypeInfo baseTypeInfo = null ; DatatypeValidator baseTypeValidator = null ; DatatypeValidator simpleTypeValidator = null ; int baseTypeSymbol = - 1 ; String fullBaseName = "" ; boolean baseIsSimpleSimple = false ; boolean baseIsComplexSimple = false ; boolean derivedByRestriction = true ; boolean derivedByExtension = false ; int baseContentSpecHandle = - 1 ; Element baseTypeNode = null ; if ( base . length ( ) > 0 ) { if ( derivedBy . length ( ) == 0 ) { reportGenericSchemaError ( "derivedBy must be present when base is present in " + SchemaSymbols . ELT_COMPLEXTYPE + " " + typeName ) ; } else { if ( derivedBy . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { derivedByRestriction = false ; } String prefix = "" ; String localpart = base ; int colonptr = base . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = base . substring ( 0 , colonptr ) ; localpart = base . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String typeURI = resolvePrefixToURI ( prefix ) ; if ( ! typeURI . equals ( fTargetNSURIString ) && ! typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && typeURI . length ( ) != 0 ) { baseTypeInfo = getTypeInfoFromNS ( typeURI , localpart ) ; if ( baseTypeInfo == null ) { baseTypeValidator = getTypeValidatorFromNS ( typeURI , localpart ) ; if ( baseTypeValidator == null ) { System . out . println ( "Could not find base type " + localpart + " in schema " + typeURI ) ; } else { baseIsSimpleSimple = true ; } } } else { fullBaseName = typeURI + "," + localpart ; baseTypeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fullBaseName ) ; if ( baseTypeInfo == null ) { baseTypeValidator = getDatatypeValidator ( typeURI , localpart ) ; if ( baseTypeValidator == null ) { baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_COMPLEXTYPE , localpart ) ; if ( baseTypeNode != null ) { baseTypeSymbol = traverseComplexTypeDecl ( baseTypeNode ) ; baseTypeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( baseTypeSymbol ) ) ; } else { baseTypeNode = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( baseTypeNode != null ) { baseTypeSymbol = traverseSimpleTypeDecl ( baseTypeNode ) ; simpleTypeValidator = baseTypeValidator = getDatatypeValidator ( typeURI , localpart ) ; if ( simpleTypeValidator == null ) { } baseIsSimpleSimple = true ; } else { reportGenericSchemaError ( "Base type could not be found : " + base ) ; } } } else { simpleTypeValidator = baseTypeValidator ; baseIsSimpleSimple = true ; } } } if ( baseIsSimpleSimple && derivedByRestriction ) { reportGenericSchemaError ( "base is a simpledType, can't derive by restriction in " + typeName ) ; } if ( baseTypeInfo != null ) { if ( derivedByRestriction ) { } else { } if ( baseTypeInfo . contentSpecHandle > - 1 ) { if ( derivedByRestriction ) { checkParticleDerivationOK ( complexTypeDecl , baseTypeNode ) ; } baseContentSpecHandle = baseTypeInfo . contentSpecHandle ; } else if ( baseTypeInfo . datatypeValidator != null ) { baseTypeValidator = baseTypeInfo . datatypeValidator ; baseIsComplexSimple = true ; } } if ( baseIsComplexSimple && ! derivedByRestriction ) { reportGenericSchemaError ( "base is ComplexSimple, can't derive by extension in " + typeName ) ; } } } child = null ; if ( baseIsComplexSimple ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; int numEnumerationLiterals = 0 ; int numFacets = 0 ; Hashtable facetData = new Hashtable ( ) ; Vector enumData = new Vector ( ) ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null && ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MININCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PRECISION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SCALE ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_LENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MINLENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_MAXLENGTH ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENCODING ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PERIOD ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_DURATION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_PATTERN ) || child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { Element facetElt = ( Element ) child ; numFacets ++ ; if ( facetElt . getNodeName ( ) . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { numEnumerationLiterals ++ ; enumData . addElement ( facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; Element enumContent = XUtil . getFirstChildElement ( facetElt ) ; if ( enumContent != null && enumContent . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { traverseAnnotationDecl ( child ) ; } } else { facetData . put ( facetElt . getNodeName ( ) , facetElt . getAttribute ( SchemaSymbols . ATT_VALUE ) ) ; } } } if ( numEnumerationLiterals > 0 ) { facetData . put ( SchemaSymbols . ELT_ENUMERATION , enumData ) ; } if ( numFacets > 0 ) { simpleTypeValidator = fDatatypeRegistry . createDatatypeValidator ( typeName , baseTypeValidator , facetData , false ) ; } else simpleTypeValidator = baseTypeValidator ; if ( child != null ) { reportGenericSchemaError ( "Invalid child '" + child . getNodeName ( ) + "' in complexType : '" + typeName + "', because it restricts another complexSimpleType" ) ; } } if ( content . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { if ( base . length ( ) == 0 ) { simpleTypeValidator = baseTypeValidator = getDatatypeValidator ( "" , SchemaSymbols . ATTVAL_STRING ) ; } else if ( baseTypeValidator == null && baseTypeInfo != null && baseTypeInfo . datatypeValidator == null ) reportSchemaError ( SchemaMessageProvider . NotADatatype , new Object [ ] { base } ) ; contentSpecType = XMLElementDecl . TYPE_SIMPLE ; } else { if ( ! baseIsComplexSimple ) { contentSpecType = XMLElementDecl . TYPE_CHILDREN ; } csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; boolean mixedContent = false ; boolean elementContent = true ; boolean textContent = false ; boolean emptyContent = false ; left = - 2 ; right = - 2 ; boolean hadContent = false ; if ( content . equals ( SchemaSymbols . ATTVAL_EMPTY ) ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; emptyContent = true ; elementContent = false ; left = - 1 ; } else if ( content . equals ( SchemaSymbols . ATTVAL_MIXED ) ) { contentSpecType = XMLElementDecl . TYPE_MIXED ; mixedContent = true ; elementContent = false ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; } else if ( content . equals ( SchemaSymbols . ATTVAL_ELEMENTONLY ) || content . equals ( "" ) ) { elementContent = true ; } else if ( content . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { textContent = true ; elementContent = false ; } if ( mixedContent ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , - 1 , - 1 , false ) ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; } boolean seeParticle = false ; boolean seeOtherParticle = false ; boolean seeAll = false ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { if ( mixedContent || elementContent ) { if ( DEBUGGING ) System . out . println ( " child element name " + child . getAttribute ( SchemaSymbols . ATT_NAME ) ) ; QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; seeOtherParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . EltRefOnlyInMixedElemOnly , null ) ; } } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeParticle = true ; seeAll = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTE ) || childName . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { break ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; seeOtherParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } else if ( childName . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { break ; } else { if ( ! baseIsComplexSimple ) if ( base . equals ( "" ) ) reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "unrecogized child '" + childName + "' in compelx type " + typeName } ) ; else reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "unrecogized child '" + childName + "' in compelx type '" + typeName + "' with base " + base } ) ; } if ( baseIsComplexSimple && seeParticle ) { reportGenericSchemaError ( "In complexType " + typeName + ", base type is complextype with simpleType content, can't have any particle children at all" ) ; hadContent = false ; left = index = - 2 ; contentSpecType = XMLElementDecl . TYPE_SIMPLE ; break ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( seeAll && seeOtherParticle ) { reportGenericSchemaError ( " 'All' group needs to be the only child in Complextype : " + typeName ) ; } if ( seeAll ) { } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( ! ( seeOtherParticle || seeAll ) && ( elementContent || mixedContent ) && ( base . length ( ) == 0 || ( base . length ( ) > 0 && derivedByRestriction && ! baseIsComplexSimple ) ) ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; simpleTypeValidator = getDatatypeValidator ( "" , SchemaSymbols . ATTVAL_STRING ) ; reportGenericSchemaError ( " complexType '" + typeName + "' with a elementOnly or mixed content " + "need to have at least one particle child" ) ; } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; if ( mixedContent && hadContent ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , left , - 1 , false ) ; } } if ( ! derivedByRestriction && baseContentSpecHandle > - 1 ) { if ( left == - 2 ) { left = baseContentSpecHandle ; } else left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , baseContentSpecHandle , left , false ) ; } if ( content . length ( ) == 0 && base . length ( ) == 0 && left == - 2 ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } if ( content . length ( ) == 0 && simpleTypeValidator == null && left == - 2 ) { if ( base . length ( ) > 0 && baseTypeInfo != null && baseTypeInfo . contentType == XMLElementDecl . TYPE_EMPTY ) { contentSpecType = XMLElementDecl . TYPE_EMPTY ; } } if ( DEBUGGING ) System . out . println ( "!!!!!>>>>>" + typeName + ", " + baseTypeInfo + ", " + baseContentSpecHandle + ", " + left + ", " + scopeDefined ) ; ComplexTypeInfo typeInfo = new ComplexTypeInfo ( ) ; typeInfo . baseComplexTypeInfo = baseTypeInfo ; typeInfo . baseDataTypeValidator = baseTypeValidator ; int derivedByInt = - 1 ; if ( derivedBy . length ( ) > 0 ) { derivedByInt = parseComplexDerivedBy ( derivedBy ) ; } typeInfo . derivedBy = derivedByInt ; typeInfo . scopeDefined = scopeDefined ; typeInfo . contentSpecHandle = left ; typeInfo . contentType = contentSpecType ; typeInfo . datatypeValidator = simpleTypeValidator ; typeInfo . blockSet = parseBlockSet ( complexTypeDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ) ; typeInfo . finalSet = parseFinalSet ( complexTypeDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ) ; typeInfo . isAbstract = isAbstract . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; int typeNameIndex = fStringPool . addSymbol ( typeName ) ; int templateElementNameIndex = fStringPool . addSymbol ( "$" + typeName ) ; typeInfo . templateElementIndex = fSchemaGrammar . addElementDecl ( new QName ( - 1 , templateElementNameIndex , typeNameIndex , fTargetNSURI ) , ( fTargetNSURI == - 1 ) ? - 1 : fCurrentScope , scopeDefined , contentSpecType , left , - 1 , simpleTypeValidator ) ; typeInfo . attlistHead = fSchemaGrammar . getFirstAttributeDeclIndex ( typeInfo . templateElementIndex ) ; XMLAttributeDecl attWildcard = null ; Vector anyAttDecls = new Vector ( ) ; for ( child = XUtil . getFirstChildElement ( complexTypeDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { if ( ( baseIsComplexSimple || baseIsSimpleSimple ) && derivedByRestriction ) { reportGenericSchemaError ( "In complexType " + typeName + ", base type has simpleType " + "content and derivation method is" + " 'restriction', can't have any " + "attribute children at all" ) ; break ; } traverseAttributeDecl ( child , typeInfo ) ; } else if ( childName . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { if ( ( baseIsComplexSimple || baseIsSimpleSimple ) && derivedByRestriction ) { reportGenericSchemaError ( "In complexType " + typeName + ", base " + "type has simpleType content and " + "derivation method is 'restriction'," + " can't have any attribute children at all" ) ; break ; } traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( childName . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { attWildcard = traverseAnyAttribute ( child ) ; } } if ( attWildcard != null ) { XMLAttributeDecl fromGroup = null ; final int count = anyAttDecls . size ( ) ; if ( count > 0 ) { fromGroup = ( XMLAttributeDecl ) anyAttDecls . elementAt ( 0 ) ; for ( int i = 1 ; i < count ; i ++ ) { fromGroup = mergeTwoAnyAttribute ( fromGroup , ( XMLAttributeDecl ) anyAttDecls . elementAt ( i ) ) ; } } if ( fromGroup != null ) { int saveProcessContents = attWildcard . defaultType ; attWildcard = mergeTwoAnyAttribute ( attWildcard , fromGroup ) ; attWildcard . defaultType = saveProcessContents ; } } else { } XMLAttributeDecl baseAttWildcard = null ; if ( baseTypeInfo != null && baseTypeInfo . attlistHead > - 1 ) { int attDefIndex = baseTypeInfo . attlistHead ; while ( attDefIndex > - 1 ) { fTempAttributeDecl . clear ( ) ; fSchemaGrammar . getAttributeDecl ( attDefIndex , fTempAttributeDecl ) ; if ( fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_ANY || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_LIST || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_LOCAL || fTempAttributeDecl . type == XMLAttributeDecl . TYPE_ANY_OTHER ) { if ( attWildcard == null ) { baseAttWildcard = fTempAttributeDecl ; } attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; continue ; } int temp = fSchemaGrammar . getAttributeDeclIndex ( typeInfo . templateElementIndex , fTempAttributeDecl . name ) ; if ( temp > - 1 ) { if ( derivedByRestriction ) { attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; continue ; } } fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , fTempAttributeDecl . name , fTempAttributeDecl . type , fTempAttributeDecl . enumeration , fTempAttributeDecl . defaultType , fTempAttributeDecl . defaultValue , fTempAttributeDecl . datatypeValidator , fTempAttributeDecl . list ) ; attDefIndex = fSchemaGrammar . getNextAttributeDeclIndex ( attDefIndex ) ; } } if ( attWildcard != null ) { if ( attWildcard . type != - 1 ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , attWildcard . name , attWildcard . type , attWildcard . enumeration , attWildcard . defaultType , attWildcard . defaultValue , attWildcard . datatypeValidator , attWildcard . list ) ; } else { } } else if ( baseAttWildcard != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , baseAttWildcard . name , baseAttWildcard . type , baseAttWildcard . enumeration , baseAttWildcard . defaultType , baseAttWildcard . defaultValue , baseAttWildcard . datatypeValidator , baseAttWildcard . list ) ; } typeInfo . attlistHead = fSchemaGrammar . getFirstAttributeDeclIndex ( typeInfo . templateElementIndex ) ; if ( ! typeName . startsWith ( "#" ) ) { typeName = fTargetNSURIString + "," + typeName ; } typeInfo . typeName = new String ( typeName ) ; if ( DEBUGGING ) System . out . println ( "add complex Type to Registry: " + typeName + "," + content + "." ) ; fComplexTypeRegistry . put ( typeName , typeInfo ) ; fCurrentScope = previousScope ; if ( isNamedType ) { fCurrentTypeNameStack . pop ( ) ; checkRecursingComplexType ( ) ; } fSchemaGrammar . setElementComplexTypeInfo ( typeInfo . templateElementIndex , typeInfo ) ; typeNameIndex = fStringPool . addSymbol ( typeName ) ; return typeNameIndex ; } private void checkRecursingComplexType ( ) throws Exception { if ( fCurrentTypeNameStack . empty ( ) ) { if ( ! fElementRecurseComplex . isEmpty ( ) ) { Enumeration e = fElementRecurseComplex . keys ( ) ; while ( e . hasMoreElements ( ) ) { QName nameThenScope = ( QName ) e . nextElement ( ) ; String typeName = ( String ) fElementRecurseComplex . get ( nameThenScope ) ; int eltUriIndex = nameThenScope . uri ; int eltNameIndex = nameThenScope . localpart ; int enclosingScope = nameThenScope . prefix ; ComplexTypeInfo typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fTargetNSURIString + "," + typeName ) ; if ( typeInfo == null ) { throw new Exception ( "Internal Error in void checkRecursingComplexType(). " ) ; } else { int elementIndex = fSchemaGrammar . addElementDecl ( new QName ( - 1 , eltNameIndex , eltNameIndex , eltUriIndex ) , enclosingScope , typeInfo . scopeDefined , typeInfo . contentType , typeInfo . contentSpecHandle , typeInfo . attlistHead , typeInfo . datatypeValidator ) ; fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } } fElementRecurseComplex . clear ( ) ; } } } private void checkParticleDerivationOK ( Element derivedTypeNode , Element baseTypeNode ) { } private int expandContentModel ( int index , Element particle ) throws Exception { String minOccurs = particle . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ; String maxOccurs = particle . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ; int min = 1 , max = 1 ; if ( minOccurs . equals ( "" ) ) { minOccurs = "1" ; } if ( maxOccurs . equals ( "" ) ) { if ( minOccurs . equals ( "0" ) ) { maxOccurs = "1" ; } else { maxOccurs = minOccurs ; } } int leafIndex = index ; if ( minOccurs . equals ( "1" ) && maxOccurs . equals ( "1" ) ) { } else if ( minOccurs . equals ( "0" ) && maxOccurs . equals ( "1" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , index , - 1 , false ) ; } else if ( minOccurs . equals ( "0" ) && maxOccurs . equals ( "unbounded" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_MORE , index , - 1 , false ) ; } else if ( minOccurs . equals ( "1" ) && maxOccurs . equals ( "unbounded" ) ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , index , - 1 , false ) ; } else if ( maxOccurs . equals ( "unbounded" ) ) { try { min = Integer . parseInt ( minOccurs ) ; } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "illegal value for minOccurs : '" + e . getMessage ( ) + "' " } ) ; } if ( min < 2 ) { } index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ONE_OR_MORE , index , - 1 , false ) ; for ( int i = 0 ; i < ( min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , leafIndex , index , false ) ; } } else { try { min = Integer . parseInt ( minOccurs ) ; max = Integer . parseInt ( maxOccurs ) ; } catch ( Exception e ) { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { "illegal value for minOccurs or maxOccurs : '" + e . getMessage ( ) + "' " } ) ; } if ( min == 0 ) { int optional = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , leafIndex , - 1 , false ) ; index = optional ; for ( int i = 0 ; i < ( max - min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , optional , false ) ; } } else { for ( int i = 0 ; i < ( min - 1 ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , leafIndex , false ) ; } int optional = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_ZERO_OR_ONE , leafIndex , - 1 , false ) ; for ( int i = 0 ; i < ( max - min ) ; i ++ ) { index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , index , optional , false ) ; } } } return index ; } private int traverseAttributeDecl ( Element attrDecl , ComplexTypeInfo typeInfo ) throws Exception { String attNameStr = attrDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; int attName = fStringPool . addSymbol ( attNameStr ) ; String isQName = attrDecl . getAttribute ( SchemaSymbols . ATT_FORM ) ; DatatypeValidator dv = null ; int attType = - 1 ; boolean attIsList = false ; int dataTypeSymbol = - 1 ; String ref = attrDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; String datatype = attrDecl . getAttribute ( SchemaSymbols . ATT_TYPE ) ; String localpart = null ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( attrDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { addAttributeDeclFromAnotherSchema ( localpart , uriStr , typeInfo ) ; return - 1 ; } Element referredAttribute = getTopLevelComponentByName ( SchemaSymbols . ELT_ATTRIBUTE , localpart ) ; if ( referredAttribute != null ) { traverseAttributeDecl ( referredAttribute , typeInfo ) ; } else { reportGenericSchemaError ( "Couldn't find top level attribute " + ref ) ; } return - 1 ; } if ( datatype . equals ( "" ) ) { Element child = XUtil . getFirstChildElement ( attrDecl ) ; while ( child != null && ! child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) child = XUtil . getNextSiblingElement ( child ) ; if ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { attType = XMLAttributeDecl . TYPE_SIMPLE ; dataTypeSymbol = traverseSimpleTypeDecl ( child ) ; localpart = fStringPool . toString ( dataTypeSymbol ) ; } else { attType = XMLAttributeDecl . TYPE_SIMPLE ; localpart = "string" ; dataTypeSymbol = fStringPool . addSymbol ( localpart ) ; } localpart = fStringPool . toString ( dataTypeSymbol ) ; dv = fDatatypeRegistry . getDatatypeValidator ( localpart ) ; } else { String prefix = "" ; localpart = datatype ; dataTypeSymbol = fStringPool . addSymbol ( localpart ) ; int colonptr = datatype . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = datatype . substring ( 0 , colonptr ) ; localpart = datatype . substring ( colonptr + 1 ) ; } String typeURI = resolvePrefixToURI ( prefix ) ; if ( typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) || typeURI . length ( ) == 0 ) { dv = getDatatypeValidator ( "" , localpart ) ; if ( localpart . equals ( "ID" ) ) { attType = XMLAttributeDecl . TYPE_ID ; } else if ( localpart . equals ( "IDREF" ) ) { attType = XMLAttributeDecl . TYPE_IDREF ; } else if ( localpart . equals ( "IDREFS" ) ) { attType = XMLAttributeDecl . TYPE_IDREF ; attIsList = true ; } else if ( localpart . equals ( "ENTITY" ) ) { attType = XMLAttributeDecl . TYPE_ENTITY ; } else if ( localpart . equals ( "ENTITIES" ) ) { attType = XMLAttributeDecl . TYPE_ENTITY ; attIsList = true ; } else if ( localpart . equals ( "NMTOKEN" ) ) { attType = XMLAttributeDecl . TYPE_NMTOKEN ; } else if ( localpart . equals ( "NMTOKENS" ) ) { attType = XMLAttributeDecl . TYPE_NMTOKEN ; attIsList = true ; } else if ( localpart . equals ( SchemaSymbols . ELT_NOTATION ) ) { attType = XMLAttributeDecl . TYPE_NOTATION ; } else { attType = XMLAttributeDecl . TYPE_SIMPLE ; if ( dv == null && typeURI . length ( ) == 0 ) { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { reportGenericSchemaError ( "simpleType not found : " + localpart ) ; } } } } else { dv = getDatatypeValidator ( typeURI , localpart ) ; if ( dv == null && typeURI . equals ( fTargetNSURIString ) ) { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { reportGenericSchemaError ( "simpleType not found : " + localpart ) ; } } attType = XMLAttributeDecl . TYPE_SIMPLE ; } } int attDefaultType = - 1 ; int attDefaultValue = - 1 ; String use = attrDecl . getAttribute ( SchemaSymbols . ATT_USE ) ; boolean required = use . equals ( SchemaSymbols . ATTVAL_REQUIRED ) ; if ( dv == null ) { reportGenericSchemaError ( "could not resolve the type or get a null validator for datatype : " + fStringPool . toString ( dataTypeSymbol ) ) ; } if ( required ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_REQUIRED ; } else { if ( use . equals ( SchemaSymbols . ATTVAL_FIXED ) ) { String fixed = attrDecl . getAttribute ( SchemaSymbols . ATT_VALUE ) ; if ( ! fixed . equals ( "" ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_FIXED ; attDefaultValue = fStringPool . addString ( fixed ) ; } } else if ( use . equals ( SchemaSymbols . ATTVAL_DEFAULT ) ) { String defaultValue = attrDecl . getAttribute ( SchemaSymbols . ATT_VALUE ) ; if ( ! defaultValue . equals ( "" ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_DEFAULT ; attDefaultValue = fStringPool . addString ( defaultValue ) ; } } else if ( use . equals ( SchemaSymbols . ATTVAL_PROHIBITED ) ) { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } else { attDefaultType = XMLAttributeDecl . DEFAULT_TYPE_IMPLIED ; } if ( attType == XMLAttributeDecl . TYPE_SIMPLE && attDefaultValue != - 1 ) { try { if ( dv != null ) dv . validate ( fStringPool . toString ( attDefaultValue ) , null ) ; else reportSchemaError ( SchemaMessageProvider . NoValidatorFor , new Object [ ] { datatype } ) ; } catch ( InvalidDatatypeValueException idve ) { reportSchemaError ( SchemaMessageProvider . IncorrectDefaultType , new Object [ ] { attrDecl . getAttribute ( SchemaSymbols . ATT_NAME ) , idve . getMessage ( ) } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . out . println ( "Internal error in attribute datatype validation" ) ; } } } int uriIndex = - 1 ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fAttributeDefaultQualified || isTopLevel ( attrDecl ) ) { uriIndex = fTargetNSURI ; } QName attQName = new QName ( - 1 , attName , attName , uriIndex ) ; if ( DEBUGGING ) System . out . println ( " the dataType Validator for " + fStringPool . toString ( attName ) + " is " + dv ) ; if ( isTopLevel ( attrDecl ) ) { fTempAttributeDecl . datatypeValidator = dv ; fTempAttributeDecl . name . setValues ( attQName ) ; fTempAttributeDecl . type = attType ; fTempAttributeDecl . defaultType = attDefaultType ; fTempAttributeDecl . list = attIsList ; if ( attDefaultValue != - 1 ) { fTempAttributeDecl . defaultValue = new String ( fStringPool . toString ( attDefaultValue ) ) ; } fAttributeDeclRegistry . put ( attNameStr , new XMLAttributeDecl ( fTempAttributeDecl ) ) ; } if ( typeInfo != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , attQName , attType , dataTypeSymbol , attDefaultType , fStringPool . toString ( attDefaultValue ) , dv , attIsList ) ; } return - 1 ; } private int addAttributeDeclFromAnotherSchema ( String name , String uriStr , ComplexTypeInfo typeInfo ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #addAttributeDeclFromAnotherSchema, schema uri : " + uriStr ) ; return - 1 ; } Hashtable attrRegistry = aGrammar . getAttirubteDeclRegistry ( ) ; if ( attrRegistry == null ) { reportGenericSchemaError ( "no attribute was defined in schema : " + uriStr ) ; return - 1 ; } XMLAttributeDecl tempAttrDecl = ( XMLAttributeDecl ) attrRegistry . get ( name ) ; if ( tempAttrDecl == null ) { reportGenericSchemaError ( "no attribute named \"" + name + "\" was defined in schema : " + uriStr ) ; return - 1 ; } if ( typeInfo != null ) { fSchemaGrammar . addAttDef ( typeInfo . templateElementIndex , tempAttrDecl . name , tempAttrDecl . type , - 1 , tempAttrDecl . defaultType , tempAttrDecl . defaultValue , tempAttrDecl . datatypeValidator , tempAttrDecl . list ) ; } return 0 ; } private int traverseAttributeGroupDecl ( Element attrGrpDecl , ComplexTypeInfo typeInfo , Vector anyAttDecls ) throws Exception { int attGrpName = fStringPool . addSymbol ( attrGrpDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ) ; String ref = attrGrpDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; int attType = - 1 ; int enumeration = - 1 ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( attrGrpDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { traverseAttributeGroupDeclFromAnotherSchema ( localpart , uriStr , typeInfo , anyAttDecls ) ; return - 1 ; } Element referredAttrGrp = getTopLevelComponentByName ( SchemaSymbols . ELT_ATTRIBUTEGROUP , localpart ) ; if ( referredAttrGrp != null ) { traverseAttributeGroupDecl ( referredAttrGrp , typeInfo , anyAttDecls ) ; } else { reportGenericSchemaError ( "Couldn't find top level attributegroup " + ref ) ; } return - 1 ; } for ( Element child = XUtil . getFirstChildElement ( attrGrpDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { traverseAttributeDecl ( child , typeInfo ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { anyAttDecls . addElement ( traverseAnyAttribute ( child ) ) ; break ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } } return - 1 ; } private int traverseAttributeGroupDeclFromAnotherSchema ( String attGrpName , String uriStr , ComplexTypeInfo typeInfo , Vector anyAttDecls ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #traverseAttributeGroupDeclFromAnotherSchema, schema uri : " + uriStr ) ; return - 1 ; } Element attGrpDecl = ( Element ) aGrammar . topLevelAttrGrpDecls . get ( ( Object ) attGrpName ) ; if ( attGrpDecl == null ) { reportGenericSchemaError ( "no attribute group named \"" + attGrpName + "\" was defined in schema : " + uriStr ) ; return - 1 ; } NamespacesScope saveNSMapping = fNamespacesScope ; int saveTargetNSUri = fTargetNSURI ; fTargetNSURI = fStringPool . addSymbol ( aGrammar . getTargetNamespaceURI ( ) ) ; fNamespacesScope = aGrammar . getNamespacesScope ( ) ; int attType = - 1 ; int enumeration = - 1 ; for ( Element child = XUtil . getFirstChildElement ( attGrpDecl ) ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTE ) ) { String childAttName = child . getAttribute ( SchemaSymbols . ATT_NAME ) ; if ( childAttName . length ( ) > 0 ) { Hashtable attDeclRegistry = aGrammar . getAttirubteDeclRegistry ( ) ; if ( attDeclRegistry != null ) { if ( attDeclRegistry . get ( ( Object ) childAttName ) != null ) { addAttributeDeclFromAnotherSchema ( childAttName , uriStr , typeInfo ) ; return - 1 ; } } } else traverseAttributeDecl ( child , typeInfo ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ATTRIBUTEGROUP ) ) { traverseAttributeGroupDecl ( child , typeInfo , anyAttDecls ) ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANYATTRIBUTE ) ) { anyAttDecls . addElement ( traverseAnyAttribute ( child ) ) ; break ; } else if ( child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) { } } fNamespacesScope = saveNSMapping ; fTargetNSURI = saveTargetNSUri ; return - 1 ; } private QName traverseElementDecl ( Element elementDecl ) throws Exception { int contentSpecType = - 1 ; int contentSpecNodeIndex = - 1 ; int typeNameIndex = - 1 ; int scopeDefined = - 2 ; DatatypeValidator dv = null ; String name = elementDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; if ( DEBUGGING ) System . out . println ( "traversing element decl : " + name ) ; String ref = elementDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; String type = elementDecl . getAttribute ( SchemaSymbols . ATT_TYPE ) ; String minOccurs = elementDecl . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ; String maxOccurs = elementDecl . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ; String dflt = elementDecl . getAttribute ( SchemaSymbols . ATT_DEFAULT ) ; String fixed = elementDecl . getAttribute ( SchemaSymbols . ATT_FIXED ) ; String equivClass = elementDecl . getAttribute ( SchemaSymbols . ATT_EQUIVCLASS ) ; String isQName = elementDecl . getAttribute ( SchemaSymbols . ATT_FORM ) ; String fromAnotherSchema = null ; if ( isTopLevel ( elementDecl ) ) { int nameIndex = fStringPool . addSymbol ( name ) ; int eltKey = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , nameIndex , TOP_LEVEL_SCOPE ) ; if ( eltKey > - 1 ) { return new QName ( - 1 , nameIndex , nameIndex , fTargetNSURI ) ; } } int blockSet = parseBlockSet ( elementDecl . getAttribute ( SchemaSymbols . ATT_BLOCK ) ) ; int finalSet = parseFinalSet ( elementDecl . getAttribute ( SchemaSymbols . ATT_FINAL ) ) ; boolean isNullable = elementDecl . getAttribute ( SchemaSymbols . ATT_NULLABLE ) . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; boolean isAbstract = elementDecl . getAttribute ( SchemaSymbols . ATT_ABSTRACT ) . equals ( SchemaSymbols . ATTVAL_TRUE ) ? true : false ; int elementMiscFlags = 0 ; if ( isNullable ) { elementMiscFlags += SchemaSymbols . NULLABLE ; } if ( isAbstract ) { elementMiscFlags += SchemaSymbols . ABSTRACT ; } int attrCount = 0 ; if ( ! ref . equals ( "" ) ) attrCount ++ ; if ( ! type . equals ( "" ) ) attrCount ++ ; if ( attrCount > 1 ) reportSchemaError ( SchemaMessageProvider . OneOfTypeRefArchRef , null ) ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( elementDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String uriString = resolvePrefixToURI ( prefix ) ; QName eltName = new QName ( prefix != null ? fStringPool . addSymbol ( prefix ) : - 1 , localpartIndex , fStringPool . addSymbol ( ref ) , uriString != null ? fStringPool . addSymbol ( uriString ) : - 1 ) ; if ( ! uriString . equals ( fTargetNSURIString ) ) { return eltName ; } int elementIndex = fSchemaGrammar . getElementDeclIndex ( eltName , TOP_LEVEL_SCOPE ) ; if ( elementIndex == - 1 ) { Element targetElement = getTopLevelComponentByName ( SchemaSymbols . ELT_ELEMENT , localpart ) ; if ( targetElement == null ) { reportGenericSchemaError ( "Element " + localpart + " not found in the Schema" ) ; return eltName ; } else { } } return eltName ; } Element equivClassElementDecl = null ; int equivClassElementDeclIndex = - 1 ; boolean noErrorSoFar = true ; String equivClassUri = null ; String equivClassLocalpart = null ; String equivClassFullName = null ; ComplexTypeInfo equivClassEltTypeInfo = null ; DatatypeValidator equivClassEltDV = null ; if ( equivClass . length ( ) > 0 ) { equivClassUri = resolvePrefixToURI ( getPrefix ( equivClass ) ) ; equivClassLocalpart = getLocalPart ( equivClass ) ; equivClassFullName = equivClassUri + "," + equivClassLocalpart ; if ( ! equivClassUri . equals ( fTargetNSURIString ) ) { equivClassEltTypeInfo = getElementDeclTypeInfoFromNS ( equivClassUri , equivClassLocalpart ) ; if ( equivClassEltTypeInfo == null ) { equivClassEltDV = getElementDeclTypeValidatorFromNS ( equivClassUri , equivClassLocalpart ) ; if ( equivClassEltDV == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type for element '" + equivClassLocalpart + "' in schema '" + equivClassUri + "'" ) ; } } } else { equivClassElementDecl = getTopLevelComponentByName ( SchemaSymbols . ELT_ELEMENT , equivClassLocalpart ) ; if ( equivClassElementDecl == null ) { equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; if ( equivClassElementDeclIndex == - 1 ) { noErrorSoFar = false ; reportGenericSchemaError ( "Equivclass affiliation element " + equivClass + " in element declaration " + name ) ; } } else { equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; if ( equivClassElementDeclIndex == - 1 ) { traverseElementDecl ( equivClassElementDecl ) ; equivClassElementDeclIndex = fSchemaGrammar . getElementDeclIndex ( fTargetNSURI , getLocalPartIndex ( equivClass ) , TOP_LEVEL_SCOPE ) ; } } if ( equivClassElementDeclIndex != - 1 ) { equivClassEltTypeInfo = fSchemaGrammar . getElementComplexTypeInfo ( equivClassElementDeclIndex ) ; if ( equivClassEltTypeInfo == null ) { fSchemaGrammar . getElementDecl ( equivClassElementDeclIndex , fTempElementDecl ) ; equivClassEltDV = fTempElementDecl . datatypeValidator ; if ( equivClassEltDV == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type for element '" + equivClassLocalpart + "' in schema '" + equivClassUri + "'" ) ; } } } } } ComplexTypeInfo typeInfo = null ; Element child = XUtil . getFirstChildElement ( elementDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; boolean haveAnonType = false ; if ( child != null ) { String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_COMPLEXTYPE ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . length ( ) > 0 ) { noErrorSoFar = false ; reportGenericSchemaError ( "anonymous complexType in element '" + name + "' has a name attribute" ) ; } else typeNameIndex = traverseComplexTypeDecl ( child ) ; if ( typeNameIndex != - 1 ) { typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( typeNameIndex ) ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "traverse complexType error in element '" + name + "'" ) ; } haveAnonType = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SIMPLETYPE ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . length ( ) > 0 ) { noErrorSoFar = false ; reportGenericSchemaError ( "anonymous simpleType in element '" + name + "' has a name attribute" ) ; } else typeNameIndex = traverseSimpleTypeDecl ( child ) ; if ( typeNameIndex != - 1 ) { dv = fDatatypeRegistry . getDatatypeValidator ( fStringPool . toString ( typeNameIndex ) ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "traverse simpleType error in element '" + name + "'" ) ; } contentSpecType = XMLElementDecl . TYPE_SIMPLE ; haveAnonType = true ; } else if ( type . equals ( "" ) ) { contentSpecType = XMLElementDecl . TYPE_ANY ; contentSpecNodeIndex = - 1 ; } else { System . out . println ( "unhandled case in TraverseElementDecl" ) ; } } if ( haveAnonType && ( type . length ( ) > 0 ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "Element '" + name + "' have both a type attribute and a annoymous type child" ) ; } else if ( ! type . equals ( "" ) ) { if ( equivClassElementDecl != null ) { checkEquivClassOK ( elementDecl , equivClassElementDecl ) ; } String prefix = "" ; String localpart = type ; int colonptr = type . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = type . substring ( 0 , colonptr ) ; localpart = type . substring ( colonptr + 1 ) ; } String typeURI = resolvePrefixToURI ( prefix ) ; if ( ! typeURI . equals ( fTargetNSURIString ) && ! typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && typeURI . length ( ) != 0 ) { fromAnotherSchema = typeURI ; typeInfo = getTypeInfoFromNS ( typeURI , localpart ) ; if ( typeInfo == null ) { dv = getTypeValidatorFromNS ( typeURI , localpart ) ; if ( dv == null ) { noErrorSoFar = false ; reportGenericSchemaError ( "Could not find type " + localpart + " in schema " + typeURI ) ; } } } else { typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( typeURI + "," + localpart ) ; if ( typeInfo == null ) { dv = getDatatypeValidator ( typeURI , localpart ) ; if ( dv == null ) if ( typeURI . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) && ! fTargetNSURIString . equals ( SchemaSymbols . URI_SCHEMAFORSCHEMA ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "type not found : " + typeURI + ":" + localpart ) ; } else { Element topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_COMPLEXTYPE , localpart ) ; if ( topleveltype != null ) { if ( fCurrentTypeNameStack . search ( ( Object ) localpart ) > - 1 ) { int uriInd = - 1 ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fElementDefaultQualified ) { uriInd = fTargetNSURI ; } int nameIndex = fStringPool . addSymbol ( name ) ; QName tempQName = new QName ( fCurrentScope , nameIndex , nameIndex , uriInd ) ; fElementRecurseComplex . put ( tempQName , localpart ) ; return new QName ( - 1 , nameIndex , nameIndex , uriInd ) ; } else { typeNameIndex = traverseComplexTypeDecl ( topleveltype ) ; typeInfo = ( ComplexTypeInfo ) fComplexTypeRegistry . get ( fStringPool . toString ( typeNameIndex ) ) ; } } else { topleveltype = getTopLevelComponentByName ( SchemaSymbols . ELT_SIMPLETYPE , localpart ) ; if ( topleveltype != null ) { typeNameIndex = traverseSimpleTypeDecl ( topleveltype ) ; dv = getDatatypeValidator ( typeURI , localpart ) ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "type not found : " + typeURI + ":" + localpart ) ; } } } } } } else if ( haveAnonType ) { if ( equivClassElementDecl != null ) { checkEquivClassOK ( elementDecl , equivClassElementDecl ) ; } } else { if ( typeInfo == null && dv == null ) typeInfo = equivClassEltTypeInfo ; if ( typeInfo == null && dv == null ) dv = equivClassEltDV ; } if ( typeInfo == null && dv == null ) { if ( noErrorSoFar ) { contentSpecType = XMLElementDecl . TYPE_ANY ; } else { noErrorSoFar = false ; reportGenericSchemaError ( "untyped element : " + name ) ; } } if ( typeInfo != null ) { contentSpecNodeIndex = typeInfo . contentSpecHandle ; contentSpecType = typeInfo . contentType ; scopeDefined = typeInfo . scopeDefined ; dv = typeInfo . datatypeValidator ; } if ( dv != null ) { contentSpecType = XMLElementDecl . TYPE_SIMPLE ; } child = XUtil . getFirstChildElement ( elementDecl ) ; Vector idConstraints = null ; while ( child != null ) { String childName = child . getNodeName ( ) ; child = XUtil . getNextSiblingElement ( child ) ; } int elementNameIndex = fStringPool . addSymbol ( name ) ; int localpartIndex = elementNameIndex ; int uriIndex = - 1 ; int enclosingScope = fCurrentScope ; if ( isQName . equals ( SchemaSymbols . ATTVAL_QUALIFIED ) || fElementDefaultQualified ) { uriIndex = fTargetNSURI ; } if ( isTopLevel ( elementDecl ) ) { uriIndex = fTargetNSURI ; enclosingScope = TOP_LEVEL_SCOPE ; } int existSuchElementIndex = fSchemaGrammar . getElementDeclIndex ( uriIndex , localpartIndex , enclosingScope ) ; if ( existSuchElementIndex > - 1 ) { fSchemaGrammar . getElementDecl ( existSuchElementIndex , fTempElementDecl ) ; DatatypeValidator edv = fTempElementDecl . datatypeValidator ; ComplexTypeInfo eTypeInfo = fSchemaGrammar . getElementComplexTypeInfo ( existSuchElementIndex ) ; if ( ( ( eTypeInfo != null ) && ( eTypeInfo != typeInfo ) ) || ( ( edv != null ) && ( edv != dv ) ) ) { noErrorSoFar = false ; reportGenericSchemaError ( "duplicate element decl in the same scope : " + fStringPool . toString ( localpartIndex ) ) ; } } QName eltQName = new QName ( - 1 , localpartIndex , elementNameIndex , uriIndex ) ; int attrListHead = - 1 ; if ( typeInfo != null ) { attrListHead = typeInfo . attlistHead ; } int elementIndex = fSchemaGrammar . addElementDecl ( eltQName , enclosingScope , scopeDefined , contentSpecType , contentSpecNodeIndex , attrListHead , dv ) ; if ( DEBUGGING ) { System . out . println ( "########elementIndex:" + elementIndex + " (" + fStringPool . toString ( eltQName . uri ) + "," + fStringPool . toString ( eltQName . localpart ) + ")" + " eltType:" + type + " contentSpecType:" + contentSpecType + " SpecNodeIndex:" + contentSpecNodeIndex + " enclosingScope: " + enclosingScope + " scopeDefined: " + scopeDefined + "\n" ) ; } if ( typeInfo != null ) { fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } else { fSchemaGrammar . setElementComplexTypeInfo ( elementIndex , typeInfo ) ; } fSchemaGrammar . setElementFromAnotherSchemaURI ( elementIndex , fromAnotherSchema ) ; fSchemaGrammar . setElementDeclBlockSet ( elementIndex , blockSet ) ; fSchemaGrammar . setElementDeclFinalSet ( elementIndex , finalSet ) ; fSchemaGrammar . setElementDeclMiscFlags ( elementIndex , elementMiscFlags ) ; fSchemaGrammar . setElementDeclEquivClassElementFullName ( elementIndex , equivClassFullName ) ; return eltQName ; } int getLocalPartIndex ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String localpart = fullName ; if ( colonAt > - 1 ) { localpart = fullName . substring ( colonAt + 1 ) ; } return fStringPool . addSymbol ( localpart ) ; } String getLocalPart ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String localpart = fullName ; if ( colonAt > - 1 ) { localpart = fullName . substring ( colonAt + 1 ) ; } return localpart ; } int getPrefixIndex ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String prefix = "" ; if ( colonAt > - 1 ) { prefix = fullName . substring ( 0 , colonAt ) ; } return fStringPool . addSymbol ( prefix ) ; } String getPrefix ( String fullName ) { int colonAt = fullName . indexOf ( ":" ) ; String prefix = "" ; if ( colonAt > - 1 ) { prefix = fullName . substring ( 0 , colonAt ) ; } return prefix ; } private void checkEquivClassOK ( Element elementDecl , Element equivClassElementDecl ) { } private Element getTopLevelComponentByName ( String componentCategory , String name ) throws Exception { Element child = XUtil . getFirstChildElement ( fSchemaRootElement ) ; if ( child == null ) { return null ; } while ( child != null ) { if ( child . getNodeName ( ) . equals ( componentCategory ) ) { if ( child . getAttribute ( SchemaSymbols . ATT_NAME ) . equals ( name ) ) { return child ; } } child = XUtil . getNextSiblingElement ( child ) ; } return null ; } private boolean isTopLevel ( Element component ) { if ( component . getParentNode ( ) . getNodeName ( ) . endsWith ( SchemaSymbols . ELT_SCHEMA ) ) { return true ; } return false ; } DatatypeValidator getTypeValidatorFromNS ( String newSchemaURI , String localpart ) throws Exception { return getDatatypeValidator ( newSchemaURI , localpart ) ; } ComplexTypeInfo getTypeInfoFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; ComplexTypeInfo typeInfo = ( ComplexTypeInfo ) sGrammar . getComplexTypeRegistry ( ) . get ( newSchemaURI + "," + localpart ) ; return typeInfo ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getTypeInfoFromNS" ) ; } return null ; } DatatypeValidator getElementDeclTypeValidatorFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; int eltIndex = sGrammar . getElementDeclIndex ( fStringPool . addSymbol ( newSchemaURI ) , fStringPool . addSymbol ( localpart ) , TOP_LEVEL_SCOPE ) ; DatatypeValidator dv = null ; if ( eltIndex > - 1 ) { sGrammar . getElementDecl ( eltIndex , fTempElementDecl ) ; dv = fTempElementDecl . datatypeValidator ; } else { reportGenericSchemaError ( "could not find global element : '" + localpart + " in the SchemaGrammar " + newSchemaURI ) ; } return dv ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getELementDeclTypeValidatorFromNS" ) ; } return null ; } ComplexTypeInfo getElementDeclTypeInfoFromNS ( String newSchemaURI , String localpart ) throws Exception { Grammar grammar = fGrammarResolver . getGrammar ( newSchemaURI ) ; if ( grammar != null && grammar instanceof SchemaGrammar ) { SchemaGrammar sGrammar = ( SchemaGrammar ) grammar ; int eltIndex = sGrammar . getElementDeclIndex ( fStringPool . addSymbol ( newSchemaURI ) , fStringPool . addSymbol ( localpart ) , TOP_LEVEL_SCOPE ) ; ComplexTypeInfo typeInfo = null ; if ( eltIndex > - 1 ) { typeInfo = sGrammar . getElementComplexTypeInfo ( eltIndex ) ; } else { reportGenericSchemaError ( "could not find global element : '" + localpart + " in the SchemaGrammar " + newSchemaURI ) ; } return typeInfo ; } else { reportGenericSchemaError ( "could not resolve URI : " + newSchemaURI + " to a SchemaGrammar in getElementDeclTypeInfoFromNS" ) ; } return null ; } private int traverseGroupDecl ( Element groupDecl ) throws Exception { String groupName = groupDecl . getAttribute ( SchemaSymbols . ATT_NAME ) ; String ref = groupDecl . getAttribute ( SchemaSymbols . ATT_REF ) ; if ( ! ref . equals ( "" ) ) { if ( XUtil . getFirstChildElement ( groupDecl ) != null ) reportSchemaError ( SchemaMessageProvider . NoContentForRef , null ) ; String prefix = "" ; String localpart = ref ; int colonptr = ref . indexOf ( ":" ) ; if ( colonptr > 0 ) { prefix = ref . substring ( 0 , colonptr ) ; localpart = ref . substring ( colonptr + 1 ) ; } int localpartIndex = fStringPool . addSymbol ( localpart ) ; String uriStr = resolvePrefixToURI ( prefix ) ; if ( ! uriStr . equals ( fTargetNSURIString ) ) { return traverseGroupDeclFromAnotherSchema ( localpart , uriStr ) ; } int contentSpecIndex = - 1 ; Element referredGroup = getTopLevelComponentByName ( SchemaSymbols . ELT_GROUP , localpart ) ; if ( referredGroup == null ) { reportGenericSchemaError ( "Group " + localpart + " not found in the Schema" ) ; throw new Exception ( "Group " + localpart + " not found in the Schema" ) ; } else { contentSpecIndex = traverseGroupDecl ( referredGroup ) ; } return contentSpecIndex ; } boolean traverseElt = true ; if ( fCurrentScope == TOP_LEVEL_SCOPE ) { traverseElt = false ; } Element child = XUtil . getFirstChildElement ( groupDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; int allChildren [ ] = null ; int allChildCount = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; boolean seeAll = false ; boolean seeParticle = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean illegalChild = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeAll = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { illegalChild = true ; reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( ! illegalChild ) { index = expandContentModel ( index , child ) ; } if ( seeParticle && seeAll ) { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "'all' needs to be 'the' only Child" , childName } ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } private int traverseGroupDeclFromAnotherSchema ( String groupName , String uriStr ) throws Exception { SchemaGrammar aGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uriStr ) ; if ( uriStr == null || aGrammar == null || ! ( aGrammar instanceof SchemaGrammar ) ) { reportGenericSchemaError ( "!!Schema not found in #traverseGroupDeclFromAnotherSchema, " + "schema uri: " + uriStr + ", groupName: " + groupName ) ; return - 1 ; } Element groupDecl = ( Element ) aGrammar . topLevelGroupDecls . get ( ( Object ) groupName ) ; if ( groupDecl == null ) { reportGenericSchemaError ( "no group named \"" + groupName + "\" was defined in schema : " + uriStr ) ; return - 1 ; } NamespacesScope saveNSMapping = fNamespacesScope ; int saveTargetNSUri = fTargetNSURI ; fTargetNSURI = fStringPool . addSymbol ( aGrammar . getTargetNamespaceURI ( ) ) ; fNamespacesScope = aGrammar . getNamespacesScope ( ) ; boolean traverseElt = true ; if ( fCurrentScope == TOP_LEVEL_SCOPE ) { traverseElt = false ; } Element child = XUtil . getFirstChildElement ( groupDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; int allChildren [ ] = null ; int allChildCount = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; int childNameIndex = fStringPool . addSymbol ( childName ) ; String formAttrVal = child . getAttribute ( SchemaSymbols . ATT_FORM ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ALL ) ) { index = traverseAll ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; fNamespacesScope = saveNSMapping ; fTargetNSURI = saveTargetNSUri ; return left ; } int traverseSequence ( Element sequenceDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( sequenceDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_SEQ ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } int traverseChoice ( Element choiceDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( choiceDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int contentSpecType = 0 ; int csnType = 0 ; csnType = XMLContentSpec . CONTENTSPECNODE_CHOICE ; contentSpecType = XMLElementDecl . TYPE_CHILDREN ; int left = - 2 ; int right = - 2 ; boolean hadContent = false ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; hadContent = true ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } if ( left == - 2 ) { left = index ; } else if ( right == - 2 ) { right = index ; } else { left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; right = index ; } } if ( hadContent && right != - 2 ) left = fSchemaGrammar . addContentSpecNode ( csnType , left , right , false ) ; return left ; } int traverseAll ( Element allDecl ) throws Exception { Element child = XUtil . getFirstChildElement ( allDecl ) ; while ( child != null && child . getNodeName ( ) . equals ( SchemaSymbols . ELT_ANNOTATION ) ) child = XUtil . getNextSiblingElement ( child ) ; int allChildren [ ] = null ; int allChildCount = 0 ; int left = - 2 ; for ( ; child != null ; child = XUtil . getNextSiblingElement ( child ) ) { int index = - 2 ; boolean seeParticle = false ; String childName = child . getNodeName ( ) ; if ( childName . equals ( SchemaSymbols . ELT_ELEMENT ) ) { QName eltQName = traverseElementDecl ( child ) ; index = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , eltQName . localpart , eltQName . uri , false ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_GROUP ) ) { index = traverseGroupDecl ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_CHOICE ) ) { index = traverseChoice ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_SEQUENCE ) ) { index = traverseSequence ( child ) ; seeParticle = true ; } else if ( childName . equals ( SchemaSymbols . ELT_ANY ) ) { index = traverseAny ( child ) ; seeParticle = true ; } else { reportSchemaError ( SchemaMessageProvider . GroupContentRestricted , new Object [ ] { "group" , childName } ) ; } if ( seeParticle ) { index = expandContentModel ( index , child ) ; } try { allChildren [ allChildCount ] = index ; } catch ( NullPointerException ne ) { allChildren = new int [ 32 ] ; allChildren [ allChildCount ] = index ; } catch ( ArrayIndexOutOfBoundsException ae ) { int [ ] newArray = new int [ allChildren . length * 2 ] ; System . arraycopy ( allChildren , 0 , newArray , 0 , allChildren . length ) ; allChildren [ allChildCount ] = index ; } allChildCount ++ ; } left = buildAllModel ( allChildren , allChildCount ) ; return left ; } private int buildAllModel ( int children [ ] , int count ) throws Exception { if ( count > 1 ) { XMLContentSpec choice = new XMLContentSpec ( ) ; choice . type = XMLContentSpec . CONTENTSPECNODE_CHOICE ; choice . value = - 1 ; choice . otherValue = - 1 ; int [ ] exactChildren = new int [ count ] ; System . arraycopy ( children , 0 , exactChildren , 0 , count ) ; sort ( exactChildren , 0 , count ) ; int index = buildAllModel ( exactChildren , 0 , choice ) ; return index ; } if ( count > 0 ) { return children [ 0 ] ; } return - 1 ; } private int buildAllModel ( int src [ ] , int offset , XMLContentSpec choice ) throws Exception { if ( src . length - offset == 2 ) { int seqIndex = createSeq ( src ) ; if ( choice . value == - 1 ) { choice . value = seqIndex ; } else { if ( choice . otherValue != - 1 ) { choice . value = fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } choice . otherValue = seqIndex ; } swap ( src , offset , offset + 1 ) ; seqIndex = createSeq ( src ) ; if ( choice . value == - 1 ) { choice . value = seqIndex ; } else { if ( choice . otherValue != - 1 ) { choice . value = fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } choice . otherValue = seqIndex ; } return fSchemaGrammar . addContentSpecNode ( choice . type , choice . value , choice . otherValue , false ) ; } for ( int i = offset ; i < src . length - 1 ; i ++ ) { choice . value = buildAllModel ( src , offset + 1 , choice ) ; choice . otherValue = - 1 ; sort ( src , offset , src . length - offset ) ; shift ( src , offset , i + 1 ) ; } int choiceIndex = buildAllModel ( src , offset + 1 , choice ) ; sort ( src , offset , src . length - offset ) ; return choiceIndex ; } private int createSeq ( int src [ ] ) throws Exception { int left = src [ 0 ] ; int right = src [ 1 ] ; for ( int i = 2 ; i < src . length ; i ++ ) { left = fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , left , right , false ) ; right = src [ i ] ; } return fSchemaGrammar . addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_SEQ , left , right , false ) ; } private void shift ( int src [ ] , int pos , int offset ) { int temp = src [ offset ] ; for ( int i = offset ; i > pos ; i -- ) { src [ i ] = src [ i - 1 ] ; } src [ pos ] = temp ; } private void sort ( int src [ ] , final int offset , final int length ) { for ( int i = offset ; i < offset + length - 1 ; i ++ ) { int lowest = i ; for ( int j = i + 1 ; j < offset + length ; j ++ ) { if ( src [ j ] < src [ lowest ] ) { lowest = j ; } } if ( lowest != i ) { int temp = src [ i ] ; src [ i ] = src [ lowest ] ; src [ lowest ] = temp ; } } } private void swap ( int src [ ] , int i , int j ) { int temp = src [ i ] ; src [ i ] = src [ j ] ; src [ j ] = temp ; } private int traverseWildcardDecl ( Element wildcardDecl ) throws Exception { int wildcardID = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATTVAL_ID ) ) ; int wildcardMaxOccurs = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_MAXOCCURS ) ) ; int wildcardMinOccurs = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_MINOCCURS ) ) ; int wildcardNamespace = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_NAMESPACE ) ) ; int wildcardProcessContents = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_PROCESSCONTENTS ) ) ; int wildcardContent = fStringPool . addSymbol ( wildcardDecl . getAttribute ( SchemaSymbols . ATT_CONTENT ) ) ; return - 1 ; } private int parseInt ( String intString ) throws Exception { if ( intString . equals ( "*" ) ) { return SchemaSymbols . INFINITY ; } else { return Integer . parseInt ( intString ) ; } } private int parseSimpleDerivedBy ( String derivedByString ) throws Exception { if ( derivedByString . equals ( SchemaSymbols . ATTVAL_LIST ) ) { return SchemaSymbols . LIST ; } else if ( derivedByString . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { return SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "SimpleType: Invalid value for 'derivedBy'" ) ; return - 1 ; } } private int parseComplexDerivedBy ( String derivedByString ) throws Exception { if ( derivedByString . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { return SchemaSymbols . EXTENSION ; } else if ( derivedByString . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { return SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "ComplexType: Invalid value for 'derivedBy'" ) ; return - 1 ; } } private int parseSimpleFinal ( String finalString ) throws Exception { if ( finalString . equals ( SchemaSymbols . ATTVAL_POUNDALL ) ) { return SchemaSymbols . ENUMERATION + SchemaSymbols . RESTRICTION + SchemaSymbols . LIST + SchemaSymbols . REPRODUCTION ; } else { int enumerate = 0 ; int restrict = 0 ; int list = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction in set twice" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( list == 0 ) { list = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "list in set twice" ) ; } } else { reportGenericSchemaError ( "Invalid value (" + finalString + ")" ) ; } } return enumerate + restrict + list + reproduce ; } } private int parseComplexContent ( String contentString ) throws Exception { if ( contentString . equals ( SchemaSymbols . ATTVAL_EMPTY ) ) { return XMLElementDecl . TYPE_EMPTY ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_ELEMENTONLY ) ) { return XMLElementDecl . TYPE_CHILDREN ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_TEXTONLY ) ) { return XMLElementDecl . TYPE_SIMPLE ; } else if ( contentString . equals ( SchemaSymbols . ATTVAL_MIXED ) ) { return XMLElementDecl . TYPE_MIXED ; } else { reportGenericSchemaError ( "Invalid value for content" ) ; return - 1 ; } } private int parseDerivationSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EXTENSION + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private int parseBlockSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EQUIVCLASS + SchemaSymbols . EXTENSION + SchemaSymbols . LIST + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EQUIVCLASS ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EQUIVCLASS ; } else { reportGenericSchemaError ( "'equivClass' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( extend == 0 ) { extend = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "'list' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private int parseFinalSet ( String finalString ) throws Exception { if ( finalString . equals ( "#all" ) ) { return SchemaSymbols . EQUIVCLASS + SchemaSymbols . EXTENSION + SchemaSymbols . LIST + SchemaSymbols . RESTRICTION + SchemaSymbols . REPRODUCTION ; } else { int extend = 0 ; int restrict = 0 ; int reproduce = 0 ; StringTokenizer t = new StringTokenizer ( finalString , " " ) ; while ( t . hasMoreTokens ( ) ) { String token = t . nextToken ( ) ; if ( token . equals ( SchemaSymbols . ATTVAL_EQUIVCLASS ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EQUIVCLASS ; } else { reportGenericSchemaError ( "'equivClass' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_EXTENSION ) ) { if ( extend == 0 ) { extend = SchemaSymbols . EXTENSION ; } else { reportGenericSchemaError ( "extension already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_LIST ) ) { if ( extend == 0 ) { extend = SchemaSymbols . LIST ; } else { reportGenericSchemaError ( "'list' already in set" ) ; } } else if ( token . equals ( SchemaSymbols . ATTVAL_RESTRICTION ) ) { if ( restrict == 0 ) { restrict = SchemaSymbols . RESTRICTION ; } else { reportGenericSchemaError ( "restriction already in set" ) ; } } else { reportGenericSchemaError ( "Invalid final value (" + finalString + ")" ) ; } } return extend + restrict + reproduce ; } } private void reportGenericSchemaError ( String error ) throws Exception { if ( fErrorReporter == null ) { System . err . println ( "__TraverseSchemaError__ : " + error ) ; } else { reportSchemaError ( SchemaMessageProvider . GenericError , new Object [ ] { error } ) ; } } private void reportSchemaError ( int major , Object args [ ] ) throws Exception { if ( fErrorReporter == null ) { System . out . println ( "__TraverseSchemaError__ : " + SchemaMessageProvider . fgMessageKeys [ major ] ) ; for ( int i = 0 ; i < args . length ; i ++ ) { System . out . println ( ( String ) args [ i ] ) ; } } else { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , SchemaMessageProvider . SCHEMA_DOMAIN , major , SchemaMessageProvider . MSG_NONE , args , XMLErrorReporter . ERRORTYPE_RECOVERABLE_ERROR ) ; } } public static void main ( String args [ ] ) { if ( args . length != 1 ) { System . out . println ( "Error: Usage java TraverseSchema yourFile.xsd" ) ; System . exit ( 0 ) ; } DOMParser parser = new DOMParser ( ) { public void ignorableWhitespace ( char ch [ ] , int start , int length ) { } public void ignorableWhitespace ( int dataIdx ) { } } ; parser . setEntityResolver ( new Resolver ( ) ) ; parser . setErrorHandler ( new ErrorHandler ( ) ) ; try { parser . setFeature ( "http://xml.org/sax/features/validation" , false ) ; parser . setFeature ( "http://apache.org/xml/features/dom/defer-node-expansion" , false ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { e . printStackTrace ( ) ; } catch ( org . xml . sax . SAXNotSupportedException e ) { e . printStackTrace ( ) ; } try { parser . parse ( args [ 0 ] ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } Document document = parser . getDocument ( ) ; OutputFormat format = new OutputFormat ( document ) ; java . io . StringWriter outWriter = new java . io . StringWriter ( ) ; XMLSerializer serial = new XMLSerializer ( outWriter , format ) ; TraverseSchema tst = null ; try { Element root = document . getDocumentElement ( ) ; tst = new TraverseSchema ( root , new StringPool ( ) , new SchemaGrammar ( ) , ( GrammarResolver ) new GrammarResolverImpl ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( System . err ) ; } parser . getDocument ( ) ; } static class Resolver implements EntityResolver { private static final String SYSTEM [ ] = { "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/structures.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/datatypes.dtd" , "http://www.w3.org/TR/2000/WD-xmlschema-1-20000407/versionInfo.ent" , } ; private static final String PATH [ ] = { "structures.dtd" , "datatypes.dtd" , "versionInfo.ent" , } ; public InputSource resolveEntity ( String publicId , String systemId ) throws IOException { for ( int i = 0 ; i < SYSTEM . length ; i ++ ) { if ( systemId . equals ( SYSTEM [ i ] ) ) { InputSource source = new InputSource ( getClass ( ) . getResourceAsStream ( PATH [ i ] ) ) ; source . setPublicId ( publicId ) ; source . setSystemId ( systemId ) ; return source ; } } return null ; } } static class ErrorHandler implements org . xml . sax . ErrorHandler { public void warning ( SAXParseException ex ) { System . err . println ( "[Warning] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { System . err . println ( "[Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) throws SAXException { System . err . println ( "[Fatal Error] " + getLocationString ( ex ) + ": " + ex . getMessage ( ) ) ; throw ex ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId_ = ex . getSystemId ( ) ; if ( systemId_ != null ) { int index = systemId_ . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId_ = systemId_ . substring ( index + 1 ) ; str . append ( systemId_ ) ; } str . append ( ':' ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( ':' ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } } } 	1
package org . xml . sax ; public interface DocumentHandler { public abstract void setDocumentLocator ( Locator locator ) ; public abstract void startDocument ( ) throws SAXException ; public abstract void endDocument ( ) throws SAXException ; public abstract void startElement ( String name , AttributeList atts ) throws SAXException ; public abstract void endElement ( String name ) throws SAXException ; public abstract void characters ( char ch [ ] , int start , int length ) throws SAXException ; public abstract void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException ; public abstract void processingInstruction ( String target , String data ) throws SAXException ; } 	0
package org . w3c . dom ; public interface Node { public static final short ELEMENT_NODE = 1 ; public static final short ATTRIBUTE_NODE = 2 ; public static final short TEXT_NODE = 3 ; public static final short CDATA_SECTION_NODE = 4 ; public static final short ENTITY_REFERENCE_NODE = 5 ; public static final short ENTITY_NODE = 6 ; public static final short PROCESSING_INSTRUCTION_NODE = 7 ; public static final short COMMENT_NODE = 8 ; public static final short DOCUMENT_NODE = 9 ; public static final short DOCUMENT_TYPE_NODE = 10 ; public static final short DOCUMENT_FRAGMENT_NODE = 11 ; public static final short NOTATION_NODE = 12 ; public String getNodeName ( ) ; public String getNodeValue ( ) throws DOMException ; public void setNodeValue ( String nodeValue ) throws DOMException ; public short getNodeType ( ) ; public Node getParentNode ( ) ; public NodeList getChildNodes ( ) ; public Node getFirstChild ( ) ; public Node getLastChild ( ) ; public Node getPreviousSibling ( ) ; public Node getNextSibling ( ) ; public NamedNodeMap getAttributes ( ) ; public Document getOwnerDocument ( ) ; public Node insertBefore ( Node newChild , Node refChild ) throws DOMException ; public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException ; public Node removeChild ( Node oldChild ) throws DOMException ; public Node appendChild ( Node newChild ) throws DOMException ; public boolean hasChildNodes ( ) ; public Node cloneNode ( boolean deep ) ; public void normalize ( ) ; public boolean supports ( String feature , String version ) ; public String getNamespaceURI ( ) ; public String getPrefix ( ) ; public void setPrefix ( String prefix ) throws DOMException ; public String getLocalName ( ) ; public boolean hasAttributes ( ) ; } 	1
package org . apache . xerces . dom ; import org . apache . xerces . utils . StringPool ; import org . w3c . dom . * ; public class DeferredNotationImpl extends NotationImpl implements DeferredNode { static final long serialVersionUID = 5705337172887990848L ; protected transient int fNodeIndex ; DeferredNotationImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; } public int getNodeIndex ( ) { return fNodeIndex ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ( ) ; name = ownerDocument . getNodeNameString ( fNodeIndex ) ; StringPool pool = ownerDocument . getStringPool ( ) ; int extraDataIndex = ownerDocument . getNodeValue ( fNodeIndex ) ; ownerDocument . getNodeType ( extraDataIndex ) ; publicId = pool . toString ( ownerDocument . getNodeName ( extraDataIndex ) ) ; systemId = pool . toString ( ownerDocument . getNodeValue ( extraDataIndex ) ) ; } } 	0
package org . w3c . dom ; public interface Entity extends Node { public String getPublicId ( ) ; public String getSystemId ( ) ; public String getNotationName ( ) ; } 	1
package org . xml . sax ; public interface DTDHandler { public abstract void notationDecl ( String name , String publicId , String systemId ) throws SAXException ; public abstract void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException ; } 	0
package org . w3c . dom ; public interface Text extends CharacterData { public Text splitText ( int offset ) throws DOMException ; } 	1
package org . apache . wml ; public interface WMLEmElement extends WMLElement { public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . Node ; public interface NodeFilter { public static final short FILTER_ACCEPT = 1 ; public static final short FILTER_REJECT = 2 ; public static final short FILTER_SKIP = 3 ; public static final int SHOW_ALL = 0xFFFFFFFF ; public static final int SHOW_ELEMENT = 0x00000001 ; public static final int SHOW_ATTRIBUTE = 0x00000002 ; public static final int SHOW_TEXT = 0x00000004 ; public static final int SHOW_CDATA_SECTION = 0x00000008 ; public static final int SHOW_ENTITY_REFERENCE = 0x00000010 ; public static final int SHOW_ENTITY = 0x00000020 ; public static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040 ; public static final int SHOW_COMMENT = 0x00000080 ; public static final int SHOW_DOCUMENT = 0x00000100 ; public static final int SHOW_DOCUMENT_TYPE = 0x00000200 ; public static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400 ; public static final int SHOW_NOTATION = 0x00000800 ; public short acceptNode ( Node n ) ; } 	1
package org . w3c . dom . html ; public interface HTMLOptGroupElement extends HTMLElement { public boolean getDisabled ( ) ; public void setDisabled ( boolean disabled ) ; public String getLabel ( ) ; public void setLabel ( String label ) ; } 	0
package org . w3c . dom ; public interface Notation extends Node { public String getPublicId ( ) ; public String getSystemId ( ) ; } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class CommentImpl extends CharacterDataImpl implements CharacterData , Comment { static final long serialVersionUID = - 2685736833408134044L ; public CommentImpl ( DocumentImpl ownerDoc , String data ) { super ( ownerDoc , data ) ; } public short getNodeType ( ) { return Node . COMMENT_NODE ; } public String getNodeName ( ) { return "#comment" ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public abstract class CharacterDataImpl extends ChildNode { static final long serialVersionUID = 7931170150428474230L ; protected String data ; private static transient NodeList singletonNodeList = new NodeList ( ) { public Node item ( int index ) { return null ; } public int getLength ( ) { return 0 ; } } ; protected CharacterDataImpl ( DocumentImpl ownerDocument , String data ) { super ( ownerDocument ) ; this . data = data ; } public NodeList getChildNodes ( ) { return singletonNodeList ; } public String getNodeValue ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } void setNodeValueInternal ( String value ) { setValueCalled ( true ) ; setNodeValue ( value ) ; setValueCalled ( false ) ; } public void setNodeValue ( String value ) { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; if ( needsSyncData ( ) ) { synchronizeData ( ) ; } String oldvalue = value ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } this . data = value ; if ( ! setValueCalled ( ) ) { ownerDocument ( ) . replacedText ( this ) ; } if ( MUTATIONEVENTS ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_CHARACTER_DATA_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_CHARACTER_DATA_MODIFIED , true , false , null , oldvalue , value , null ) ; dispatchEvent ( me ) ; } dispatchAggregateEvents ( enclosingAttr ) ; } } public String getData ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data ; } public int getLength ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return data . length ( ) ; } public void appendData ( String data ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } setNodeValue ( this . data + data ) ; } public void deleteData ( int offset , int count ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( count < 0 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int tailLength = Math . max ( data . length ( ) - count - offset , 0 ) ; try { setNodeValueInternal ( data . substring ( 0 , offset ) + ( tailLength > 0 ? data . substring ( offset + count , offset + count + tailLength ) : "" ) ) ; ownerDocument ( ) . deletedText ( this , offset , count ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } public void insertData ( int offset , String data ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } try { setNodeValueInternal ( new StringBuffer ( this . data ) . insert ( offset , data ) . toString ( ) ) ; ownerDocument ( ) . insertedText ( this , offset , data . length ( ) ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } } public void replaceData ( int offset , int count , String data ) throws DOMException { deleteData ( offset , count ) ; insertData ( offset , data ) ; } public void setData ( String value ) throws DOMException { setNodeValue ( value ) ; } public String substringData ( int offset , int count ) throws DOMException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } int length = data . length ( ) ; if ( count < 0 || offset < 0 || offset > length - 1 ) { throw new DOMExceptionImpl ( DOMException . INDEX_SIZE_ERR , "DOM004 Index out of bounds" ) ; } int tailIndex = Math . min ( offset + count , length ) ; return data . substring ( offset , tailIndex ) ; } } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DeferredTextImpl extends TextImpl implements DeferredNode { static final long serialVersionUID = 2310613872100393425L ; protected transient int fNodeIndex ; DeferredTextImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; } public int getNodeIndex ( ) { return fNodeIndex ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ( ) ; data = ownerDocument . getNodeValueString ( fNodeIndex ) ; isIgnorableWhitespace ( ownerDocument . getLastChild ( fNodeIndex ) == 1 ) ; } } 	0
package org . apache . xerces . jaxp ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . xml . sax . SAXException ; public class DocumentBuilderFactoryImpl extends DocumentBuilderFactory { public DocumentBuilderFactoryImpl ( ) { super ( ) ; } public DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException { return ( new DocumentBuilderImpl ( this . isNamespaceAware ( ) , this . isValidating ( ) ) ) ; } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLImgElementImpl extends WMLElementImpl implements WMLImgElement { public WMLImgElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setWidth ( String newValue ) { setAttribute ( "width" , newValue ) ; } public String getWidth ( ) { return getAttribute ( "width" ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setLocalSrc ( String newValue ) { setAttribute ( "localsrc" , newValue ) ; } public String getLocalSrc ( ) { return getAttribute ( "localsrc" ) ; } public void setHeight ( String newValue ) { setAttribute ( "height" , newValue ) ; } public String getHeight ( ) { return getAttribute ( "height" ) ; } public void setAlign ( String newValue ) { setAttribute ( "align" , newValue ) ; } public String getAlign ( ) { return getAttribute ( "align" ) ; } public void setVspace ( String newValue ) { setAttribute ( "vspace" , newValue ) ; } public String getVspace ( ) { return getAttribute ( "vspace" ) ; } public void setAlt ( String newValue ) { setAttribute ( "alt" , newValue ) ; } public String getAlt ( ) { return getAttribute ( "alt" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setHspace ( String newValue ) { setAttribute ( "hspace" , newValue ) ; } public String getHspace ( ) { return getAttribute ( "hspace" ) ; } public void setSrc ( String newValue ) { setAttribute ( "src" , newValue ) ; } public String getSrc ( ) { return getAttribute ( "src" ) ; } } 	0
package org . apache . xerces . parsers ; import org . apache . xerces . framework . XMLAttrList ; import org . apache . xerces . framework . XMLContentSpec ; import org . apache . xerces . framework . XMLDocumentHandler ; import org . apache . xerces . framework . XMLParser ; import org . apache . xerces . readers . XMLEntityHandler ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . validators . common . XMLAttributeDecl ; import org . apache . xerces . validators . common . XMLElementDecl ; import org . xml . sax . Attributes ; import org . xml . sax . AttributeList ; import org . xml . sax . ContentHandler ; import org . xml . sax . DocumentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . Parser ; import org . xml . sax . XMLReader ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . AttributesImpl ; public class SAXParser extends XMLParser implements XMLDocumentHandler , XMLDocumentHandler . DTDHandler , Parser , XMLReader { private static final String RECOGNIZED_FEATURES [ ] = { "http://xml.org/sax/features/namespace-prefixes" , "http://xml.org/sax/features/string-interning" , } ; private static final String RECOGNIZED_PROPERTIES [ ] = { "http://xml.org/sax/properties/lexical-handler" , "http://xml.org/sax/properties/declaration-handler" , "http://xml.org/sax/properties/dom-node" , } ; private static final boolean DEBUG_CALLBACKS = false ; private DocumentHandler fDocumentHandler ; private org . xml . sax . DTDHandler fDTDHandler ; private ContentHandler fContentHandler ; private DeclHandler fDeclHandler ; private LexicalHandler fLexicalHandler ; private boolean fNamespacePrefixes = false ; private transient AttributesImpl fAttributes = new AttributesImpl ( ) ; public SAXParser ( ) { initHandlers ( true , this , this ) ; } public String [ ] getFeaturesRecognized ( ) { String superRecognized [ ] = super . getFeaturesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_FEATURES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } public String [ ] getPropertiesRecognized ( ) { String superRecognized [ ] = super . getPropertiesRecognized ( ) ; String thisRecognized [ ] = RECOGNIZED_PROPERTIES ; int thisLength = thisRecognized . length ; if ( thisLength == 0 ) { return superRecognized ; } int superLength = superRecognized . length ; if ( superLength == 0 ) { return thisRecognized ; } String recognized [ ] = new String [ superLength + thisLength ] ; System . arraycopy ( superRecognized , 0 , recognized , 0 , superLength ) ; System . arraycopy ( thisRecognized , 0 , recognized , superLength , thisLength ) ; return recognized ; } protected void setDeclHandler ( DeclHandler handler ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR011 Feature: http://xml.org/sax/properties/declaration-handler" + " is not supported during parse." + "\nhttp://xml.org/sax/properties/declaration-handler" ) ; } fDeclHandler = handler ; } protected DeclHandler getDeclHandler ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fDeclHandler ; } protected void setLexicalHandler ( LexicalHandler handler ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR011 Feature: http://xml.org/sax/properties/lexical-handler" + " is not supported during parse." + "\nhttp://xml.org/sax/properties/lexical-handler" ) ; } fLexicalHandler = handler ; } protected LexicalHandler getLexicalHandler ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fLexicalHandler ; } public void setDocumentHandler ( DocumentHandler handler ) { fDocumentHandler = handler ; } public void setDTDHandler ( org . xml . sax . DTDHandler handler ) { fDTDHandler = handler ; } public org . xml . sax . DTDHandler getDTDHandler ( ) { return fDTDHandler ; } protected void setNamespacePrefixes ( boolean process ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( fParseInProgress ) { throw new SAXNotSupportedException ( "PAR004 Cannot setFeature(http://xml.org/sax/features/namespace-prefixes): parse is in progress.\n" + "http://xml.org/sax/features/namespace-prefixes" ) ; } fNamespacePrefixes = process ; } protected boolean getNamespacePrefixes ( ) throws SAXNotRecognizedException , SAXNotSupportedException { return fNamespacePrefixes ; } public void setFeature ( String featureId , boolean state ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "namespace-prefixes" ) ) { setNamespacePrefixes ( state ) ; return ; } if ( feature . equals ( "string-interning" ) ) { if ( state ) { throw new SAXNotSupportedException ( "PAR018 " + state + " state for feature \"" + featureId + "\" is not supported.\n" + state + '\t' + featureId ) ; } return ; } } super . setFeature ( featureId , state ) ; } public boolean getFeature ( String featureId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( featureId . startsWith ( SAX2_FEATURES_PREFIX ) ) { String feature = featureId . substring ( SAX2_FEATURES_PREFIX . length ( ) ) ; if ( feature . equals ( "namespace-prefixes" ) ) { return getNamespacePrefixes ( ) ; } if ( feature . equals ( "string-interning" ) ) { return false ; } } return super . getFeature ( featureId ) ; } public void setProperty ( String propertyId , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "lexical-handler" ) ) { try { setLexicalHandler ( ( LexicalHandler ) value ) ; } catch ( ClassCastException e ) { throw new SAXNotSupportedException ( "PAR012 For propertyID \"" + propertyId + "\", the value \"" + value + "\" cannot be cast to LexicalHandler." + '\n' + propertyId + '\t' + value + "\tLexicalHandler" ) ; } return ; } if ( property . equals ( "declaration-handler" ) ) { try { setDeclHandler ( ( DeclHandler ) value ) ; } catch ( ClassCastException e ) { throw new SAXNotSupportedException ( "PAR012 For propertyID \"" + propertyId + "\", the value \"" + value + "\" cannot be cast to DeclHandler." + '\n' + propertyId + '\t' + value + "\tDeclHandler" ) ; } return ; } if ( property . equals ( "dom-node" ) ) { throw new SAXNotSupportedException ( "PAR013 Property \"" + propertyId + "\" is read only." + '\n' + propertyId ) ; } } super . setProperty ( propertyId , value ) ; } public Object getProperty ( String propertyId ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( propertyId . startsWith ( SAX2_PROPERTIES_PREFIX ) ) { String property = propertyId . substring ( SAX2_PROPERTIES_PREFIX . length ( ) ) ; if ( property . equals ( "lexical-handler" ) ) { return getLexicalHandler ( ) ; } if ( property . equals ( "declaration-handler" ) ) { return getDeclHandler ( ) ; } if ( property . equals ( "dom-node" ) ) { throw new SAXNotSupportedException ( "PAR014 Cannot getProperty(\"" + propertyId + "\". No DOM Tree exists.\n" + propertyId ) ; } } return super . getProperty ( propertyId ) ; } public void setContentHandler ( ContentHandler handler ) { if ( handler == null ) { throw new NullPointerException ( ) ; } fContentHandler = handler ; } public ContentHandler getContentHandler ( ) { return fContentHandler ; } public void startDTD ( QName rootElement , int publicId , int systemId ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( rootElement . rawname ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "startDTD(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startDTD ( name , pubid , sysid ) ; } } } public void endDTD ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endDTD()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endDTD ( ) ; } } public void elementDecl ( QName elementDecl , int contentSpecType , int contentSpecIndex , XMLContentSpec . Provider contentSpecProvider ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( elementDecl . rawname ) ; String contentModel ; if ( contentSpecType == XMLElementDecl . TYPE_ANY ) { contentModel = "ANY" ; } else if ( contentSpecType == XMLElementDecl . TYPE_EMPTY ) { contentModel = "EMPTY" ; } else { contentModel = XMLContentSpec . toString ( contentSpecProvider , fStringPool , contentSpecIndex ) ; } if ( DEBUG_CALLBACKS ) { System . err . println ( "elementDecl(" + name + ", " + contentModel + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . elementDecl ( name , contentModel ) ; } } } public void attlistDecl ( QName elementDecl , QName attributeDecl , int attType , boolean attList , String enumString , int attDefaultType , int attDefaultValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String eName = fStringPool . toString ( elementDecl . rawname ) ; String aName = fStringPool . toString ( attributeDecl . rawname ) ; String aType = enumString ; if ( attType != XMLAttributeDecl . TYPE_ENUMERATION ) { switch ( attType ) { case XMLAttributeDecl . TYPE_CDATA : { aType = "CDATA" ; break ; } case XMLAttributeDecl . TYPE_ENTITY : { aType = attList ? "ENTITIES" : "ENTITY" ; break ; } case XMLAttributeDecl . TYPE_ID : { aType = "ID" ; break ; } case XMLAttributeDecl . TYPE_IDREF : { aType = attList ? "IDREFS" : "IDREF" ; break ; } case XMLAttributeDecl . TYPE_NMTOKEN : { aType = attList ? "NMTOKENS" : "NMTOKEN" ; break ; } case XMLAttributeDecl . TYPE_NOTATION : { aType = "NOTATION" ; break ; } } } String aDefaultType = "" ; switch ( attDefaultType ) { case XMLAttributeDecl . DEFAULT_TYPE_FIXED : { aDefaultType = "#FIXED" ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_IMPLIED : { aDefaultType = "#IMPLIED" ; break ; } case XMLAttributeDecl . DEFAULT_TYPE_REQUIRED : { aDefaultType = "#REQUIRED" ; break ; } } String aDefaultValue = fStringPool . toString ( attDefaultValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "attributeDecl(" + eName + ", " + aName + ", " + aType + ", " + aDefaultType + ", " + aDefaultValue + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . attributeDecl ( eName , aName , aType , aDefaultType , aDefaultValue ) ; } } } public void internalPEDecl ( int entityName , int entityValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = "%" + fStringPool . toString ( entityName ) ; String value = fStringPool . toString ( entityValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "internalEntityDecl(" + name + ", " + value + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , value ) ; } } } public void externalPEDecl ( int entityName , int publicId , int systemId ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = "%" + fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "externalEntityDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . externalEntityDecl ( name , pubid , sysid ) ; } } } public void internalEntityDecl ( int entityName , int entityValue ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String value = fStringPool . toString ( entityValue ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "internalEntityDecl(" + name + ", " + value + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . internalEntityDecl ( name , value ) ; } } } public void externalEntityDecl ( int entityName , int publicId , int systemId ) throws Exception { if ( fDeclHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "externalEntityDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDeclHandler != null ) { fDeclHandler . externalEntityDecl ( name , pubid , sysid ) ; } } } public void unparsedEntityDecl ( int entityName , int publicId , int systemId , int notationName ) throws Exception { if ( fDTDHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( entityName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; String notation = fStringPool . toString ( notationName ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "unparsedEntityDecl(" + name + ", " + pubid + ", " + sysid + ", " + notation + ")" ) ; } if ( fDTDHandler != null ) { fDTDHandler . unparsedEntityDecl ( name , pubid , sysid , notation ) ; } } } public void notationDecl ( int notationName , int publicId , int systemId ) throws Exception { if ( fDTDHandler != null || DEBUG_CALLBACKS ) { String name = fStringPool . toString ( notationName ) ; String pubid = fStringPool . toString ( publicId ) ; String sysid = fStringPool . toString ( systemId ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "notationDecl(" + name + ", " + pubid + ", " + sysid + ")" ) ; } if ( fDTDHandler != null ) { fDTDHandler . notationDecl ( name , pubid , sysid ) ; } } } public void startDocument ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "setDocumentLocator(<locator>)" ) ; System . err . println ( "startDocument()" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . setDocumentLocator ( getLocator ( ) ) ; fDocumentHandler . startDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . setDocumentLocator ( getLocator ( ) ) ; fContentHandler . startDocument ( ) ; } } public void endDocument ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endDocument()" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . endDocument ( ) ; } if ( fContentHandler != null ) { fContentHandler . endDocument ( ) ; } } public void xmlDecl ( int versionIndex , int encodingIndex , int standaloneIndex ) throws Exception { if ( DEBUG_CALLBACKS ) { String notes = "" ; if ( versionIndex != - 1 ) notes += " version='" + fStringPool . toString ( versionIndex ) + "'" ; if ( encodingIndex != - 1 ) notes += " encoding='" + fStringPool . toString ( encodingIndex ) + "'" ; if ( standaloneIndex != - 1 ) notes += " standalone='" + fStringPool . toString ( standaloneIndex ) + "'" ; System . err . println ( "xmlDecl(<?xml" + notes + "?>)" ) ; } fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; fStringPool . releaseString ( standaloneIndex ) ; } public void textDecl ( int versionIndex , int encodingIndex ) throws Exception { if ( DEBUG_CALLBACKS ) { String notes = "" ; if ( versionIndex != - 1 ) notes += " version='" + fStringPool . toString ( versionIndex ) + "'" ; if ( encodingIndex != - 1 ) notes += " encoding='" + fStringPool . toString ( encodingIndex ) + "'" ; System . err . println ( "textDecl(<?xml" + notes + "?>)" ) ; } fStringPool . releaseString ( versionIndex ) ; fStringPool . releaseString ( encodingIndex ) ; } public void startNamespaceDeclScope ( int prefix , int uri ) throws Exception { if ( fContentHandler != null || DEBUG_CALLBACKS ) { String p = fStringPool . toString ( prefix ) ; String ns = fStringPool . toString ( uri ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "startNamespaceDeclScope(" + p + ", " + ns + ")" ) ; } if ( fContentHandler != null ) { fContentHandler . startPrefixMapping ( p , ns ) ; } } } public void endNamespaceDeclScope ( int prefix ) throws Exception { if ( fContentHandler != null || DEBUG_CALLBACKS ) { String p = fStringPool . toString ( prefix ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "endNamespaceDeclScope(" + p + ")" ) ; } if ( fContentHandler != null ) { fContentHandler . endPrefixMapping ( p ) ; } } } public void internalSubset ( int internalSubset ) { } public void startElement ( QName element , XMLAttrList attrList , int attrListIndex ) throws Exception { String name = fStringPool . toString ( element . rawname ) ; AttributeList attrs = attrList . getAttributeList ( attrListIndex ) ; if ( DEBUG_CALLBACKS ) { String atts = attrs . getLength ( ) > 0 ? "" : " " ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { atts += " " + attrs . getName ( i ) + "='" + attrs . getValue ( i ) + "'" ; } System . err . println ( "startElement(" + name + "," + atts + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . startElement ( name , attrs ) ; } if ( fContentHandler != null ) { boolean namespaces = getNamespaces ( ) ; int uriIndex = element . uri ; String uri = uriIndex != - 1 && namespaces ? fStringPool . toString ( uriIndex ) : "" ; int localIndex = element . localpart ; String local = localIndex != - 1 && namespaces ? fStringPool . toString ( localIndex ) : "" ; String raw = name ; fAttributes . clear ( ) ; for ( int attrIndex = attrList . getFirstAttr ( attrListIndex ) ; attrIndex != - 1 ; attrIndex = attrList . getNextAttr ( attrIndex ) ) { int attrNameIndex = attrList . getAttrName ( attrIndex ) ; int attrUriIndex = attrList . getAttrURI ( attrIndex ) ; String attrUri = attrUriIndex != - 1 && namespaces ? fStringPool . toString ( attrUriIndex ) : "" ; int attrLocalIndex = attrList . getAttrLocalpart ( attrIndex ) ; String attrLocal = attrLocalIndex != - 1 && namespaces ? fStringPool . toString ( attrLocalIndex ) : "" ; String attrRaw = fStringPool . toString ( attrNameIndex ) ; String attrType = fStringPool . toString ( attrList . getAttType ( attrIndex ) ) ; String attrValue = fStringPool . toString ( attrList . getAttValue ( attrIndex ) ) ; int attrPrefix = attrList . getAttrPrefix ( attrIndex ) ; boolean namespacePrefixes = getNamespacePrefixes ( ) ; if ( ! namespaces || namespacePrefixes || ( attrPrefix != fStringPool . addSymbol ( "xmlns" ) && attrLocalIndex != fStringPool . addSymbol ( "xmlns" ) ) ) fAttributes . addAttribute ( attrUri , attrLocal , attrRaw , attrType , attrValue ) ; } fContentHandler . startElement ( uri , local , raw , fAttributes ) ; } attrList . releaseAttrList ( attrListIndex ) ; } public void endElement ( QName element ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endElement(" + fStringPool . toString ( element . rawname ) + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . endElement ( fStringPool . toString ( element . rawname ) ) ; } if ( fContentHandler != null ) { boolean namespaces = getNamespaces ( ) ; int uriIndex = element . uri ; String uri = uriIndex != - 1 && namespaces ? fStringPool . toString ( uriIndex ) : "" ; int localIndex = element . localpart ; String local = localIndex != - 1 && namespaces ? fStringPool . toString ( localIndex ) : "" ; String raw = fStringPool . toString ( element . rawname ) ; fContentHandler . endElement ( uri , local , raw ) ; } } public void startEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { switch ( entityType ) { case XMLEntityHandler . ENTITYTYPE_INTERNAL_PE : case XMLEntityHandler . ENTITYTYPE_EXTERNAL_PE : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(%" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( "%" + fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_INTERNAL : case XMLEntityHandler . ENTITYTYPE_EXTERNAL : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_UNPARSED : throw new RuntimeException ( "PAR015 startEntityReference(): ENTITYTYPE_UNPARSED" ) ; case XMLEntityHandler . ENTITYTYPE_DOCUMENT : break ; case XMLEntityHandler . ENTITYTYPE_EXTERNAL_SUBSET : if ( DEBUG_CALLBACKS ) { System . err . println ( "startEntity(\"[dtd]\")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startEntity ( "[dtd]" ) ; } break ; } } } public void endEntityReference ( int entityName , int entityType , int entityContext ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { switch ( entityType ) { case XMLEntityHandler . ENTITYTYPE_INTERNAL_PE : case XMLEntityHandler . ENTITYTYPE_EXTERNAL_PE : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(%" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( "%" + fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_INTERNAL : case XMLEntityHandler . ENTITYTYPE_EXTERNAL : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(" + fStringPool . toString ( entityName ) + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( fStringPool . toString ( entityName ) ) ; } break ; case XMLEntityHandler . ENTITYTYPE_UNPARSED : throw new RuntimeException ( "PAR016 endEntityReference(): ENTITYTYPE_UNPARSED" ) ; case XMLEntityHandler . ENTITYTYPE_DOCUMENT : break ; case XMLEntityHandler . ENTITYTYPE_EXTERNAL_SUBSET : if ( DEBUG_CALLBACKS ) { System . err . println ( "endEntity(\"[dtd]\")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endEntity ( "[dtd]" ) ; } break ; } } } public void startCDATA ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "startCDATA()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "endCDATA()" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . endCDATA ( ) ; } } public void characters ( int dataIndex ) throws Exception { throw new RuntimeException ( "PAR017 cannot happen 5\n5" ) ; } public void ignorableWhitespace ( int dataIndex ) throws Exception { throw new RuntimeException ( "PAR017 cannot happen 6\n6" ) ; } public void processingInstruction ( int piTarget , int piData ) throws Exception { if ( fDocumentHandler != null || fContentHandler != null || DEBUG_CALLBACKS ) { String target = fStringPool . orphanString ( piTarget ) ; String data = piData == - 1 ? "" : fStringPool . orphanString ( piData ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "processingInstruction(" + target + ", " + data + ")" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . processingInstruction ( target , data ) ; } if ( fContentHandler != null ) { fContentHandler . processingInstruction ( target , data ) ; } } else { fStringPool . releaseString ( piTarget ) ; fStringPool . releaseString ( piData ) ; } } public void comment ( int dataIndex ) throws Exception { if ( fLexicalHandler != null || DEBUG_CALLBACKS ) { String data = fStringPool . orphanString ( dataIndex ) ; if ( DEBUG_CALLBACKS ) { System . err . println ( "comment(" + data + ")" ) ; } if ( fLexicalHandler != null ) { fLexicalHandler . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } else { fStringPool . releaseString ( dataIndex ) ; } } public void characters ( char ch [ ] , int start , int length ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "characters(<char-data>) length " + length ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . characters ( ch , start , length ) ; } if ( fContentHandler != null ) { fContentHandler . characters ( ch , start , length ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws Exception { if ( DEBUG_CALLBACKS ) { System . err . println ( "ignorableWhitespace(<white-space>)" ) ; } if ( fDocumentHandler != null ) { fDocumentHandler . ignorableWhitespace ( ch , start , length ) ; } if ( fContentHandler != null ) { fContentHandler . ignorableWhitespace ( ch , start , length ) ; } } } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLTableElementImpl extends WMLElementImpl implements WMLTableElement { public WMLTableElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setColumns ( int newValue ) { setAttribute ( "columns" , newValue ) ; } public int getColumns ( ) { return getAttribute ( "columns" , 0 ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setAlign ( String newValue ) { setAttribute ( "align" , newValue ) ; } public String getAlign ( ) { return getAttribute ( "align" ) ; } public void setTitle ( String newValue ) { setAttribute ( "title" , newValue ) ; } public String getTitle ( ) { return getAttribute ( "title" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } } 	0
package org . w3c . dom ; public interface DocumentType extends Node { public String getName ( ) ; public NamedNodeMap getEntities ( ) ; public NamedNodeMap getNotations ( ) ; public String getPublicId ( ) ; public String getSystemId ( ) ; public String getInternalSubset ( ) ; } 	1
package org . w3c . dom . html ; public interface HTMLParamElement extends HTMLElement { public String getName ( ) ; public void setName ( String name ) ; public String getType ( ) ; public void setType ( String type ) ; public String getValue ( ) ; public void setValue ( String value ) ; public String getValueType ( ) ; public void setValueType ( String valueType ) ; } 	0
package org . apache . xerces . dom ; import org . apache . xerces . domx . DOMException ; public class DOMExceptionImpl extends DOMException { public DOMExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLImageElementImpl extends HTMLElementImpl implements HTMLImageElement { public String getLowSrc ( ) { return getAttribute ( "lowsrc" ) ; } public void setLowSrc ( String lowSrc ) { setAttribute ( "lowsrc" , lowSrc ) ; } public String getSrc ( ) { return getAttribute ( "src" ) ; } public void setSrc ( String src ) { setAttribute ( "src" , src ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } public void setName ( String name ) { setAttribute ( "name" , name ) ; } public String getAlign ( ) { return capitalize ( getAttribute ( "align" ) ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public String getAlt ( ) { return getAttribute ( "alt" ) ; } public void setAlt ( String alt ) { setAttribute ( "alt" , alt ) ; } public String getBorder ( ) { return getAttribute ( "border" ) ; } public void setBorder ( String border ) { setAttribute ( "border" , border ) ; } public String getHeight ( ) { return getAttribute ( "height" ) ; } public void setHeight ( String height ) { setAttribute ( "height" , height ) ; } public String getHspace ( ) { return getAttribute ( "hspace" ) ; } public void setHspace ( String hspace ) { setAttribute ( "hspace" , hspace ) ; } public boolean getIsMap ( ) { return getBinary ( "ismap" ) ; } public void setIsMap ( boolean isMap ) { setAttribute ( "ismap" , isMap ) ; } public String getLongDesc ( ) { return getAttribute ( "longdesc" ) ; } public void setLongDesc ( String longDesc ) { setAttribute ( "longdesc" , longDesc ) ; } public String getUseMap ( ) { return getAttribute ( "useMap" ) ; } public void setUseMap ( String useMap ) { setAttribute ( "useMap" , useMap ) ; } public String getVspace ( ) { return getAttribute ( "vspace" ) ; } public void setVspace ( String vspace ) { setAttribute ( "vspace" , vspace ) ; } public String getWidth ( ) { return getAttribute ( "width" ) ; } public void setWidth ( String width ) { setAttribute ( "width" , width ) ; } public HTMLImageElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . w3c . dom ; public interface Comment extends CharacterData { } 	1
package org . xml . sax . helpers ; import java . io . IOException ; import java . util . Locale ; import org . xml . sax . Parser ; import org . xml . sax . Locator ; import org . xml . sax . InputSource ; import org . xml . sax . AttributeList ; import org . xml . sax . EntityResolver ; import org . xml . sax . DTDHandler ; import org . xml . sax . DocumentHandler ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . SAXNotSupportedException ; public class XMLReaderAdapter implements Parser , ContentHandler { public XMLReaderAdapter ( ) throws SAXException { setup ( XMLReaderFactory . createXMLReader ( ) ) ; } public XMLReaderAdapter ( XMLReader xmlReader ) { setup ( xmlReader ) ; } private void setup ( XMLReader xmlReader ) { if ( xmlReader == null ) { throw new NullPointerException ( "XMLReader must not be null" ) ; } this . xmlReader = xmlReader ; qAtts = new AttributesAdapter ( ) ; } public void setLocale ( Locale locale ) throws SAXException { throw new SAXNotSupportedException ( "setLocale not supported" ) ; } public void setEntityResolver ( EntityResolver resolver ) { xmlReader . setEntityResolver ( resolver ) ; } public void setDTDHandler ( DTDHandler handler ) { xmlReader . setDTDHandler ( handler ) ; } public void setDocumentHandler ( DocumentHandler handler ) { documentHandler = handler ; } public void setErrorHandler ( ErrorHandler handler ) { xmlReader . setErrorHandler ( handler ) ; } public void parse ( String systemId ) throws IOException , SAXException { parse ( new InputSource ( systemId ) ) ; } public void parse ( InputSource input ) throws IOException , SAXException { setupXMLReader ( ) ; xmlReader . parse ( input ) ; } private void setupXMLReader ( ) throws SAXException { xmlReader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; try { xmlReader . setFeature ( "http://xml.org/sax/features/namespaces" , false ) ; } catch ( SAXException e ) { } xmlReader . setContentHandler ( this ) ; } public void setDocumentLocator ( Locator locator ) { documentHandler . setDocumentLocator ( locator ) ; } public void startDocument ( ) throws SAXException { documentHandler . startDocument ( ) ; } public void endDocument ( ) throws SAXException { documentHandler . endDocument ( ) ; } public void startPrefixMapping ( String prefix , String uri ) { } public void endPrefixMapping ( String prefix ) { } public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { qAtts . setAttributes ( atts ) ; documentHandler . startElement ( qName , qAtts ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { documentHandler . endElement ( qName ) ; } public void characters ( char ch [ ] , int start , int length ) throws SAXException { documentHandler . characters ( ch , start , length ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { documentHandler . ignorableWhitespace ( ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { documentHandler . processingInstruction ( target , data ) ; } public void skippedEntity ( String name ) throws SAXException { } XMLReader xmlReader ; DocumentHandler documentHandler ; AttributesAdapter qAtts ; final class AttributesAdapter implements AttributeList { AttributesAdapter ( ) { } void setAttributes ( Attributes attributes ) { this . attributes = attributes ; } public int getLength ( ) { return attributes . getLength ( ) ; } public String getName ( int i ) { return attributes . getQName ( i ) ; } public String getType ( int i ) { return attributes . getType ( i ) ; } public String getValue ( int i ) { return attributes . getValue ( i ) ; } public String getType ( String qName ) { return attributes . getType ( qName ) ; } public String getValue ( String qName ) { return attributes . getValue ( qName ) ; } private Attributes attributes ; } } 	0
package org . w3c . dom . traversal ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public interface TreeWalker { public Node getRoot ( ) ; public int getWhatToShow ( ) ; public NodeFilter getFilter ( ) ; public boolean getExpandEntityReferences ( ) ; public Node getCurrentNode ( ) ; public void setCurrentNode ( Node currentNode ) throws DOMException ; public Node parentNode ( ) ; public Node firstChild ( ) ; public Node lastChild ( ) ; public Node previousSibling ( ) ; public Node nextSibling ( ) ; public Node previousNode ( ) ; public Node nextNode ( ) ; } 	1
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; class LCount { static java . util . Hashtable lCounts = new java . util . Hashtable ( ) ; public int captures = 0 , bubbles = 0 , defaults = 0 ; static LCount lookup ( String evtName ) { LCount lc = ( LCount ) lCounts . get ( evtName ) ; if ( lc == null ) lCounts . put ( evtName , ( lc = new LCount ( ) ) ) ; return lc ; } } 	0
package org . w3c . dom ; public interface ProcessingInstruction extends Node { public String getTarget ( ) ; public String getData ( ) ; public void setData ( String data ) throws DOMException ; } 	1
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . CharDataChunk ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . ImplementationMessages ; import java . io . InputStream ; final class UTF8CharReader extends AbstractCharReader { UTF8CharReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , InputStream dataStream , StringPool stringPool ) throws Exception { super ( entityHandler , errorReporter , sendCharDataAsCharArray , stringPool ) ; fInputStream = dataStream ; fillCurrentChunk ( ) ; } private InputStream fInputStream = null ; private boolean fCheckOverflow = false ; private byte [ ] fOverflow = null ; private int fOverflowOffset = 0 ; private int fOverflowEnd = 0 ; private int fOutputOffset = 0 ; private boolean fSkipLinefeed = false ; private int fPartialMultiByteIn = 0 ; private byte [ ] fPartialMultiByteChar = new byte [ 3 ] ; private int fPartialSurrogatePair = 0 ; private boolean fPartialMultiByteResult = false ; protected int fillCurrentChunk ( ) throws Exception { char [ ] recycledData = fCurrentChunk . toCharArray ( ) ; fOutputOffset = 0 ; if ( fCheckOverflow ) { fMostRecentData = recycledData ; if ( fOverflowEnd < CharDataChunk . CHUNK_SIZE ) { recycledData = null ; if ( fOverflowEnd > 0 ) { if ( fMostRecentData == null || fMostRecentData . length < 1 + fOverflowEnd - fOverflowOffset ) fMostRecentData = new char [ 1 + fOverflowEnd - fOverflowOffset ] ; copyNormalize ( fOverflow , fOverflowOffset , fMostRecentData , fOutputOffset ) ; } else { if ( fMostRecentData == null ) fMostRecentData = new char [ 1 ] ; } fMostRecentData [ fOutputOffset ] = 0 ; fOverflow = null ; fLength += fOutputOffset ; fCurrentIndex = 0 ; fCurrentChunk . setCharArray ( fMostRecentData ) ; return ( fMostRecentChar = fMostRecentData [ 0 ] ) ; } if ( fMostRecentData == null || fMostRecentData . length < CharDataChunk . CHUNK_SIZE ) fMostRecentData = new char [ CharDataChunk . CHUNK_SIZE ] ; else recycledData = null ; copyNormalize ( fOverflow , fOverflowOffset , fMostRecentData , fOutputOffset ) ; fCheckOverflow = false ; } else { if ( fOverflow == null ) fOverflow = new byte [ CharDataChunk . CHUNK_SIZE ] ; fMostRecentData = null ; } while ( true ) { fOverflowOffset = 0 ; fOverflowEnd = 0 ; int capacity = CharDataChunk . CHUNK_SIZE ; int result = 0 ; do { try { result = fInputStream . read ( fOverflow , fOverflowEnd , capacity ) ; } catch ( java . io . IOException ex ) { result = - 1 ; } if ( result == - 1 ) { fInputStream . close ( ) ; fInputStream = null ; if ( fMostRecentData == null ) { fMostRecentData = recycledData ; if ( fMostRecentData == null || fMostRecentData . length < 1 + fOverflowEnd ) fMostRecentData = new char [ 1 + fOverflowEnd ] ; else recycledData = null ; copyNormalize ( fOverflow , fOverflowOffset , fMostRecentData , fOutputOffset ) ; fOverflow = null ; fMostRecentData [ fOutputOffset ] = 0 ; } else { boolean alldone = copyNormalize ( fOverflow , fOverflowOffset , fMostRecentData , fOutputOffset ) ; if ( alldone ) { if ( fOverflowEnd == CharDataChunk . CHUNK_SIZE ) { fCheckOverflow = true ; fOverflowOffset = 0 ; fOverflowEnd = 0 ; } else { fOverflow = null ; fMostRecentData [ fOutputOffset ] = 0 ; } } else { fCheckOverflow = true ; } } break ; } if ( result > 0 ) { fOverflowEnd += result ; capacity -= result ; } } while ( capacity > 0 ) ; if ( result == - 1 ) break ; if ( fMostRecentData != null ) { boolean alldone = copyNormalize ( fOverflow , fOverflowOffset , fMostRecentData , fOutputOffset ) ; if ( fOutputOffset == CharDataChunk . CHUNK_SIZE ) { if ( ! alldone ) { fCheckOverflow = true ; } break ; } } else { fMostRecentData = recycledData ; if ( fMostRecentData == null || fMostRecentData . length < CharDataChunk . CHUNK_SIZE ) fMostRecentData = new char [ CharDataChunk . CHUNK_SIZE ] ; else recycledData = null ; copyNormalize ( fOverflow , fOverflowOffset , fMostRecentData , fOutputOffset ) ; if ( fOutputOffset == CharDataChunk . CHUNK_SIZE ) { break ; } } } fLength += fOutputOffset ; fCurrentIndex = 0 ; fCurrentChunk . setCharArray ( fMostRecentData ) ; return ( fMostRecentChar = fMostRecentData [ 0 ] ) ; } private boolean copyNormalize ( byte [ ] in , int inOffset , char [ ] out , int outOffset ) throws Exception { int inEnd = fOverflowEnd ; int outEnd = out . length ; if ( inOffset == inEnd ) return true ; byte b = in [ inOffset ] ; if ( fSkipLinefeed ) { fSkipLinefeed = false ; if ( b == 0x0A ) { if ( ++ inOffset == inEnd ) return exitNormalize ( inOffset , outOffset , true ) ; b = in [ inOffset ] ; } } else if ( fPartialMultiByteIn > 0 ) { if ( ! handlePartialMultiByteChar ( b , in , inOffset , inEnd , out , outOffset , outEnd ) ) return fPartialMultiByteResult ; inOffset = fOverflowOffset ; outOffset = fOutputOffset ; b = in [ inOffset ] ; } while ( outOffset < outEnd ) { int inCount = inEnd - inOffset ; int outCount = outEnd - outOffset ; if ( inCount > outCount ) inCount = outCount ; inOffset ++ ; while ( true ) { while ( b == 0x0D || b < 0 ) { if ( b == 0x0D ) { out [ outOffset ++ ] = 0x0A ; if ( inOffset == inEnd ) { fSkipLinefeed = true ; return exitNormalize ( inOffset , outOffset , true ) ; } b = in [ inOffset ] ; if ( b == 0x0A ) { if ( ++ inOffset == inEnd ) return exitNormalize ( inOffset , outOffset , true ) ; b = in [ inOffset ] ; } if ( outOffset == outEnd ) return exitNormalize ( inOffset , outOffset , false ) ; } else { if ( ! handleMultiByteChar ( b , in , inOffset , inEnd , out , outOffset , outEnd ) ) return fPartialMultiByteResult ; inOffset = fOverflowOffset ; outOffset = fOutputOffset ; b = in [ inOffset ] ; } inCount = inEnd - inOffset ; outCount = outEnd - outOffset ; if ( inCount > outCount ) inCount = outCount ; inOffset ++ ; } while ( true ) { out [ outOffset ++ ] = ( char ) b ; if ( -- inCount == 0 ) break ; b = in [ inOffset ++ ] ; if ( b == 0x0D || b < 0 ) break ; } if ( inCount == 0 ) break ; } if ( inOffset == inEnd ) break ; } return exitNormalize ( inOffset , outOffset , inOffset == inEnd ) ; } private boolean exitNormalize ( int inOffset , int outOffset , boolean result ) { fOverflowOffset = inOffset ; fOutputOffset = outOffset ; return result ; } private void savePartialMultiByte ( int inCount , byte bz , byte by , byte bx ) { fPartialMultiByteIn = inCount ; fPartialMultiByteChar [ -- inCount ] = bz ; fPartialMultiByteChar [ -- inCount ] = by ; fPartialMultiByteChar [ -- inCount ] = bx ; } private void savePartialMultiByte ( int inCount , byte bz , byte by ) { fPartialMultiByteIn = inCount ; fPartialMultiByteChar [ -- inCount ] = bz ; fPartialMultiByteChar [ -- inCount ] = by ; } private void savePartialMultiByte ( int inCount , byte bz ) { fPartialMultiByteIn = inCount ; fPartialMultiByteChar [ -- inCount ] = bz ; } private boolean handleMultiByteChar ( byte b , byte [ ] in , int inOffset , int inEnd , char [ ] out , int outOffset , int outEnd ) throws Exception { if ( inOffset == inEnd ) { savePartialMultiByte ( 1 , b ) ; fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , true ) ; return false ; } byte b1 = in [ inOffset ++ ] ; if ( ( b1 & 0xc0 ) != 0x80 ) { Object [ ] args = { Integer . toHexString ( b & 0xff ) , Integer . toHexString ( b1 & 0xff ) } ; deferException ( ImplementationMessages . ENC5 , args , outOffset ) ; out [ outOffset ++ ] = 0 ; return exitNormalize ( inOffset , outOffset , true ) ; } if ( ( b & 0xe0 ) == 0xc0 ) { int ch = ( ( 0x1f & b ) << 6 ) + ( 0x3f & b1 ) ; out [ outOffset ++ ] = ( char ) ch ; if ( inOffset == inEnd || outOffset == outEnd ) { fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , inOffset == inEnd ) ; return false ; } } else { if ( inOffset == inEnd ) { savePartialMultiByte ( 2 , b1 , b ) ; fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , true ) ; return false ; } byte b2 = in [ inOffset ++ ] ; if ( ( b2 & 0xc0 ) != 0x80 ) { Object [ ] args = { Integer . toHexString ( b & 0xff ) , Integer . toHexString ( b1 & 0xff ) , Integer . toHexString ( b2 & 0xff ) } ; deferException ( ImplementationMessages . ENC6 , args , outOffset ) ; out [ outOffset ++ ] = 0 ; return exitNormalize ( inOffset , outOffset , true ) ; } if ( ( b & 0xf0 ) == 0xe0 ) { int ch = ( ( 0x0f & b ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; out [ outOffset ++ ] = ( char ) ch ; if ( inOffset == inEnd || outOffset == outEnd ) { fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , inOffset == inEnd ) ; return false ; } } else { if ( ( b & 0xf8 ) != 0xf0 ) { Object [ ] args = { Integer . toHexString ( b & 0xff ) } ; deferException ( ImplementationMessages . ENC4 , args , outOffset ) ; out [ outOffset ++ ] = 0 ; return exitNormalize ( inOffset , outOffset , true ) ; } if ( inOffset == inEnd ) { savePartialMultiByte ( 3 , b2 , b1 , b ) ; fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , true ) ; return false ; } byte b3 = in [ inOffset ++ ] ; if ( ( b3 & 0xc0 ) != 0x80 ) { Object [ ] args = { Integer . toHexString ( b & 0xff ) , Integer . toHexString ( b1 & 0xff ) , Integer . toHexString ( b2 & 0xff ) , Integer . toHexString ( b3 & 0xff ) } ; deferException ( ImplementationMessages . ENC7 , args , outOffset ) ; out [ outOffset ++ ] = 0 ; return exitNormalize ( inOffset , outOffset , true ) ; } int ch = ( ( 0x0f & b ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; if ( ch >= 0x10000 ) { out [ outOffset ++ ] = ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; ch = ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; if ( outOffset == outEnd ) { fPartialSurrogatePair = ch ; fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , inOffset == inEnd ) ; return false ; } } out [ outOffset ++ ] = ( char ) ch ; if ( inOffset == inEnd || outOffset == outEnd ) { fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , inOffset == inEnd ) ; return false ; } } } return exitNormalize ( inOffset , outOffset , true ) ; } private boolean handlePartialMultiByteChar ( byte b , byte [ ] in , int inOffset , int inEnd , char [ ] out , int outOffset , int outEnd ) throws Exception { if ( outOffset == outEnd ) { fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , inOffset == inEnd ) ; return false ; } if ( fPartialMultiByteIn == 4 ) { out [ outOffset ++ ] = ( char ) fPartialSurrogatePair ; if ( outOffset == outEnd ) { fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , false ) ; return false ; } fOutputOffset = outOffset ; return true ; } int byteIn = fPartialMultiByteIn ; fPartialMultiByteIn = 0 ; byte b1 = 0 ; byte b2 = 0 ; byte b3 = 0 ; switch ( byteIn ) { case 1 : b1 = b ; break ; case 2 : b2 = b ; break ; case 3 : b3 = b ; break ; } int i = byteIn ; switch ( byteIn ) { case 3 : b2 = fPartialMultiByteChar [ -- i ] ; case 2 : b1 = fPartialMultiByteChar [ -- i ] ; case 1 : b = fPartialMultiByteChar [ -- i ] ; } switch ( byteIn ) { case 1 : if ( ( b1 & 0xc0 ) != 0x80 ) { Object [ ] args = { Integer . toHexString ( b ) , Integer . toHexString ( b1 ) } ; deferException ( ImplementationMessages . ENC5 , args , outOffset ) ; out [ outOffset ++ ] = 0 ; break ; } case 2 : if ( ( b & 0xe0 ) == 0xc0 ) { int ch = ( ( 0x1f & b ) << 6 ) + ( 0x3f & b1 ) ; out [ outOffset ++ ] = ( char ) ch ; if ( outOffset == outEnd ) { fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , false ) ; return false ; } if ( byteIn < 2 && ++ inOffset == inEnd ) { fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , true ) ; return false ; } break ; } if ( byteIn < 2 ) { if ( ++ inOffset == inEnd ) { savePartialMultiByte ( 2 , b1 ) ; fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , true ) ; return false ; } b2 = in [ inOffset ] ; } if ( ( b2 & 0xc0 ) != 0x80 ) { Object [ ] args = { Integer . toHexString ( b ) , Integer . toHexString ( b1 ) , Integer . toHexString ( b2 ) } ; deferException ( ImplementationMessages . ENC6 , args , outOffset ) ; out [ outOffset ++ ] = 0 ; break ; } case 3 : if ( ( b & 0xf0 ) == 0xe0 ) { int ch = ( ( 0x0f & b ) << 12 ) + ( ( 0x3f & b1 ) << 6 ) + ( 0x3f & b2 ) ; out [ outOffset ++ ] = ( char ) ch ; if ( outOffset == outEnd ) { fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , false ) ; return false ; } if ( byteIn < 3 && ++ inOffset == inEnd ) { fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , true ) ; return false ; } break ; } if ( byteIn < 3 ) { if ( ( b & 0xf8 ) != 0xf0 ) { Object [ ] args = { Integer . toHexString ( b ) } ; deferException ( ImplementationMessages . ENC4 , args , outOffset ) ; out [ outOffset ++ ] = 0 ; break ; } if ( ++ inOffset == inEnd ) { savePartialMultiByte ( 3 , b2 , b1 ) ; fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , true ) ; return false ; } b3 = in [ inOffset ] ; } if ( ( b3 & 0xc0 ) != 0x80 ) { Object [ ] args = { Integer . toHexString ( b ) , Integer . toHexString ( b1 ) , Integer . toHexString ( b2 ) , Integer . toHexString ( b3 ) } ; deferException ( ImplementationMessages . ENC7 , args , outOffset ) ; out [ outOffset ++ ] = 0 ; break ; } int ch = ( ( 0x0f & b ) << 18 ) + ( ( 0x3f & b1 ) << 12 ) + ( ( 0x3f & b2 ) << 6 ) + ( 0x3f & b3 ) ; if ( ch >= 0x10000 ) { out [ outOffset ++ ] = ( char ) ( ( ( ch - 0x00010000 ) > > 10 ) + 0xd800 ) ; ch = ( ( ( ch - 0x00010000 ) & 0x3ff ) + 0xdc00 ) ; if ( outOffset == outEnd ) { fPartialSurrogatePair = ch ; fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , false ) ; return false ; } } out [ outOffset ++ ] = ( char ) ch ; if ( outOffset == outEnd ) { fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , false ) ; return false ; } if ( ++ inOffset == inEnd ) { fPartialMultiByteResult = exitNormalize ( inOffset , outOffset , true ) ; return false ; } break ; } return exitNormalize ( inOffset , outOffset , true ) ; } } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . EventImpl ; import org . apache . xerces . dom . events . MutationEventImpl ; import org . w3c . dom . events . * ; public abstract class NodeImpl implements Node , NodeList , EventTarget , Cloneable , Serializable { static final long serialVersionUID = - 6316591992167219696L ; public static final short ELEMENT_DEFINITION_NODE = - 1 ; protected NodeImpl ownerNode ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short SYNCDATA = 0x1 << 1 ; protected final static short SYNCCHILDREN = 0x1 << 2 ; protected final static short OWNED = 0x1 << 3 ; protected final static short FIRSTCHILD = 0x1 << 4 ; protected final static short SPECIFIED = 0x1 << 5 ; protected final static short IGNORABLEWS = 0x1 << 6 ; protected final static short SETVALUE = 0x1 << 7 ; protected NodeImpl ( DocumentImpl ownerDocument ) { ownerNode = ownerDocument ; } public NodeImpl ( ) { } public abstract short getNodeType ( ) ; public abstract String getNodeName ( ) ; public String getNodeValue ( ) { return null ; } public void setNodeValue ( String x ) throws DOMException { } public Node appendChild ( Node newChild ) throws DOMException { return insertBefore ( newChild , null ) ; } public Node cloneNode ( boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } NodeImpl newnode ; try { newnode = ( NodeImpl ) clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } newnode . ownerNode = ownerDocument ( ) ; newnode . isOwned ( false ) ; newnode . isReadOnly ( false ) ; return newnode ; } public Document getOwnerDocument ( ) { if ( isOwned ( ) ) { return ownerNode . ownerDocument ( ) ; } else { return ( Document ) ownerNode ; } } DocumentImpl ownerDocument ( ) { if ( isOwned ( ) ) { return ownerNode . ownerDocument ( ) ; } else { return ( DocumentImpl ) ownerNode ; } } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( ! isOwned ( ) ) { ownerNode = doc ; } } public Node getParentNode ( ) { return null ; } NodeImpl parentNode ( ) { return null ; } public Node getNextSibling ( ) { return null ; } public Node getPreviousSibling ( ) { return null ; } ChildNode previousSibling ( ) { return null ; } public NamedNodeMap getAttributes ( ) { return null ; } public boolean hasAttributes ( ) { return false ; } public boolean hasChildNodes ( ) { return false ; } public NodeList getChildNodes ( ) { return this ; } public Node getFirstChild ( ) { return null ; } public Node getLastChild ( ) { return null ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } public Node removeChild ( Node oldChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } public int getLength ( ) { return 0 ; } public Node item ( int index ) { return null ; } public void normalize ( ) { } public boolean supports ( String feature , String version ) { return ownerDocument ( ) . getImplementation ( ) . hasFeature ( feature , version ) ; } public String getNamespaceURI ( ) { return null ; } public String getPrefix ( ) { return null ; } public void setPrefix ( String prefix ) throws DOMException { throw new DOMExceptionImpl ( DOMException . NAMESPACE_ERR , "DOM003 Namespace error" ) ; } public String getLocalName ( ) { return null ; } protected final static boolean MUTATIONEVENTS = true ; protected final static int MUTATION_NONE = 0x00 ; protected final static int MUTATION_LOCAL = 0x01 ; protected final static int MUTATION_AGGREGATE = 0x02 ; protected final static int MUTATION_ALL = 0xffff ; class LEntry { String type ; EventListener listener ; boolean useCapture ; LEntry ( String type , EventListener listener , boolean useCapture ) { this . type = type ; this . listener = listener ; this . useCapture = useCapture ; } } ; public void addEventListener ( String type , EventListener listener , boolean useCapture ) { if ( type == null || type . equals ( "" ) || listener == null ) return ; removeEventListener ( type , listener , useCapture ) ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null ) { nodeListeners = new Vector ( ) ; ownerDocument ( ) . setEventListeners ( this , nodeListeners ) ; } nodeListeners . addElement ( new LEntry ( type , listener , useCapture ) ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) ++ lc . captures ; else ++ lc . bubbles ; } public void removeEventListener ( String type , EventListener listener , boolean useCapture ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null || type == null || type . equals ( "" ) || listener == null ) return ; for ( int i = nodeListeners . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nodeListeners . elementAt ( i ) ) ; if ( le . useCapture == useCapture && le . listener == listener && le . type . equals ( type ) ) { nodeListeners . removeElementAt ( i ) ; if ( nodeListeners . size ( ) == 0 ) ownerDocument ( ) . setEventListeners ( this , null ) ; LCount lc = LCount . lookup ( type ) ; if ( useCapture ) -- lc . captures ; else -- lc . bubbles ; break ; } } } public boolean dispatchEvent ( Event event ) { if ( event == null ) return false ; EventImpl evt = ( EventImpl ) event ; if ( ! evt . initialized || evt . type == null || evt . type . equals ( "" ) ) throw new DOMExceptionImpl ( DOMExceptionImpl . UNSPECIFIED_EVENT_TYPE , "DOM010 Unspecified event type" ) ; LCount lc = LCount . lookup ( evt . getType ( ) ) ; if ( lc . captures + lc . bubbles + lc . defaults == 0 ) return evt . preventDefault ; evt . target = this ; evt . stopPropagation = false ; evt . preventDefault = false ; Vector pv = new Vector ( 10 , 10 ) ; Node p = this , n = p . getParentNode ( ) ; while ( n != null ) { pv . addElement ( n ) ; p = n ; n = n . getParentNode ( ) ; } if ( lc . captures > 0 ) { evt . eventPhase = Event . CAPTURING_PHASE ; for ( int j = pv . size ( ) - 1 ; j >= 0 ; -- j ) { if ( evt . stopPropagation ) break ; NodeImpl nn = ( NodeImpl ) pv . elementAt ( j ) ; evt . currentNode = nn ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( nn ) ; if ( nodeListeners != null ) { Vector nl = ( Vector ) ( nodeListeners . clone ( ) ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nl . elementAt ( i ) ) ; if ( le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } } } if ( lc . bubbles > 0 ) { evt . eventPhase = Event . AT_TARGET ; evt . currentNode = this ; Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( ! evt . stopPropagation && nodeListeners != null ) { Vector nl = ( Vector ) nodeListeners . clone ( ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) nl . elementAt ( i ) ; if ( le != null && ! le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } if ( evt . bubbles ) { evt . eventPhase = Event . BUBBLING_PHASE ; for ( int j = 0 ; j < pv . size ( ) ; ++ j ) { if ( evt . stopPropagation ) break ; NodeImpl nn = ( NodeImpl ) pv . elementAt ( j ) ; evt . currentNode = nn ; nodeListeners = ownerDocument ( ) . getEventListeners ( nn ) ; if ( nodeListeners != null ) { Vector nl = ( Vector ) ( nodeListeners . clone ( ) ) ; for ( int i = nl . size ( ) - 1 ; i >= 0 ; -- i ) { LEntry le = ( LEntry ) ( nl . elementAt ( i ) ) ; if ( ! le . useCapture && le . type . equals ( evt . type ) ) try { le . listener . handleEvent ( evt ) ; } catch ( Exception e ) { } } } } } } if ( lc . defaults > 0 && ( ! evt . cancelable || ! evt . preventDefault ) ) { } return evt . preventDefault ; } void dispatchEventToSubtree ( Node n , Event e ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null || n == null ) return ; ( ( NodeImpl ) n ) . dispatchEvent ( e ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { NamedNodeMap a = n . getAttributes ( ) ; for ( int i = a . getLength ( ) - 1 ; i >= 0 ; -- i ) dispatchEventToSubtree ( a . item ( i ) , e ) ; } dispatchEventToSubtree ( n . getFirstChild ( ) , e ) ; dispatchEventToSubtree ( n . getNextSibling ( ) , e ) ; } } class EnclosingAttr { AttrImpl node ; String oldvalue ; } EnclosingAttr getEnclosingAttr ( ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { NodeImpl eventAncestor = this ; while ( true ) { if ( eventAncestor == null ) return null ; int type = eventAncestor . getNodeType ( ) ; if ( type == Node . ATTRIBUTE_NODE ) { EnclosingAttr retval = new EnclosingAttr ( ) ; retval . node = ( AttrImpl ) eventAncestor ; retval . oldvalue = retval . node . getNodeValue ( ) ; return retval ; } else if ( type == Node . ENTITY_REFERENCE_NODE ) eventAncestor = eventAncestor . parentNode ( ) ; else return null ; } } return null ; } void dispatchAggregateEvents ( EnclosingAttr ea ) { if ( ea != null ) dispatchAggregateEvents ( ea . node , ea . oldvalue ) ; else dispatchAggregateEvents ( null , null ) ; } void dispatchAggregateEvents ( AttrImpl enclosingAttr , String oldvalue ) { if ( MUTATIONEVENTS && ownerDocument ( ) . mutationEvents ) { Vector nodeListeners = ownerDocument ( ) . getEventListeners ( this ) ; if ( nodeListeners == null ) return ; NodeImpl owner = null ; if ( enclosingAttr != null ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { owner = ( ( NodeImpl ) ( enclosingAttr . getOwnerElement ( ) ) ) ; if ( owner != null ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_ATTR_MODIFIED , true , false , null , oldvalue , enclosingAttr . getNodeValue ( ) , enclosingAttr . getNodeName ( ) ) ; owner . dispatchEvent ( me ) ; } } } LCount lc = LCount . lookup ( MutationEventImpl . DOM_SUBTREE_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_SUBTREE_MODIFIED , true , false , null , null , null , null ) ; if ( enclosingAttr != null ) { enclosingAttr . dispatchEvent ( me ) ; if ( owner != null ) owner . dispatchEvent ( me ) ; } else dispatchEvent ( me ) ; } } } public void setReadOnly ( boolean readOnly , boolean deep ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isReadOnly ( readOnly ) ; } public boolean getReadOnly ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isReadOnly ( ) ; } public void setUserData ( Object data ) { ownerDocument ( ) . setUserData ( this , data ) ; } public Object getUserData ( ) { return ownerDocument ( ) . getUserData ( this ) ; } protected void changed ( ) { ownerDocument ( ) . changed ( ) ; } protected int changes ( ) { return ownerDocument ( ) . changes ( ) ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean needsSyncData ( ) { return ( flags & SYNCDATA ) != 0 ; } final void needsSyncData ( boolean value ) { flags = ( short ) ( value ? flags | SYNCDATA : flags & ~ SYNCDATA ) ; } final boolean needsSyncChildren ( ) { return ( flags & SYNCCHILDREN ) != 0 ; } final void needsSyncChildren ( boolean value ) { flags = ( short ) ( value ? flags | SYNCCHILDREN : flags & ~ SYNCCHILDREN ) ; } final boolean isOwned ( ) { return ( flags & OWNED ) != 0 ; } final void isOwned ( boolean value ) { flags = ( short ) ( value ? flags | OWNED : flags & ~ OWNED ) ; } final boolean isFirstChild ( ) { return ( flags & FIRSTCHILD ) != 0 ; } final void isFirstChild ( boolean value ) { flags = ( short ) ( value ? flags | FIRSTCHILD : flags & ~ FIRSTCHILD ) ; } final boolean isSpecified ( ) { return ( flags & SPECIFIED ) != 0 ; } final void isSpecified ( boolean value ) { flags = ( short ) ( value ? flags | SPECIFIED : flags & ~ SPECIFIED ) ; } final boolean internalIsIgnorableWhitespace ( ) { return ( flags & IGNORABLEWS ) != 0 ; } final void isIgnorableWhitespace ( boolean value ) { flags = ( short ) ( value ? flags | IGNORABLEWS : flags & ~ IGNORABLEWS ) ; } final boolean setValueCalled ( ) { return ( flags & SETVALUE ) != 0 ; } final void setValueCalled ( boolean value ) { flags = ( short ) ( value ? flags | SETVALUE : flags & ~ SETVALUE ) ; } public String toString ( ) { return "[" + getNodeName ( ) + ": " + getNodeValue ( ) + "]" ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } out . defaultWriteObject ( ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import org . w3c . dom . html . * ; public final class HTMLTableCellElementImpl extends HTMLElementImpl implements HTMLTableCellElement { public int getCellIndex ( ) { Node parent ; Node child ; int index ; parent = getParentNode ( ) ; index = 0 ; if ( parent instanceof HTMLTableRowElement ) { child = parent . getFirstChild ( ) ; while ( child != null ) { if ( child instanceof HTMLTableCellElement ) { if ( child == this ) return index ; ++ index ; } child = child . getNextSibling ( ) ; } } return - 1 ; } public void setCellIndex ( int cellIndex ) { Node parent ; Node child ; int index ; parent = getParentNode ( ) ; if ( parent instanceof HTMLTableRowElement ) { child = parent . getFirstChild ( ) ; while ( child != null ) { if ( child instanceof HTMLTableCellElement ) { if ( cellIndex == 0 ) { if ( this != child ) parent . insertBefore ( this , child ) ; return ; } -- cellIndex ; } child = child . getNextSibling ( ) ; } } parent . appendChild ( this ) ; } public String getAbbr ( ) { return getAttribute ( "abbr" ) ; } public void setAbbr ( String abbr ) { setAttribute ( "abbr" , abbr ) ; } public String getAlign ( ) { return capitalize ( getAttribute ( "align" ) ) ; } public void setAlign ( String align ) { setAttribute ( "align" , align ) ; } public String getAxis ( ) { return getAttribute ( "axis" ) ; } public void setAxis ( String axis ) { setAttribute ( "axis" , axis ) ; } public String getBgColor ( ) { return getAttribute ( "bgcolor" ) ; } public void setBgColor ( String bgColor ) { setAttribute ( "bgcolor" , bgColor ) ; } public String getCh ( ) { String ch ; ch = getAttribute ( "char" ) ; if ( ch != null && ch . length ( ) > 1 ) ch = ch . substring ( 0 , 1 ) ; return ch ; } public void setCh ( String ch ) { if ( ch != null && ch . length ( ) > 1 ) ch = ch . substring ( 0 , 1 ) ; setAttribute ( "char" , ch ) ; } public String getChOff ( ) { return getAttribute ( "charoff" ) ; } public void setChOff ( String chOff ) { setAttribute ( "charoff" , chOff ) ; } public int getColSpan ( ) { return getInteger ( getAttribute ( "colspan" ) ) ; } public void setColSpan ( int colspan ) { setAttribute ( "colspan" , String . valueOf ( colspan ) ) ; } public String getHeaders ( ) { return getAttribute ( "headers" ) ; } public void setHeaders ( String headers ) { setAttribute ( "headers" , headers ) ; } public String getHeight ( ) { return getAttribute ( "height" ) ; } public void setHeight ( String height ) { setAttribute ( "height" , height ) ; } public boolean getNoWrap ( ) { return getBinary ( "nowrap" ) ; } public void setNoWrap ( boolean noWrap ) { setAttribute ( "nowrap" , noWrap ) ; } public int getRowSpan ( ) { return getInteger ( getAttribute ( "rowspan" ) ) ; } public void setRowSpan ( int rowspan ) { setAttribute ( "rowspan" , String . valueOf ( rowspan ) ) ; } public String getScope ( ) { return getAttribute ( "scope" ) ; } public void setScope ( String scope ) { setAttribute ( "scope" , scope ) ; } public String getVAlign ( ) { return capitalize ( getAttribute ( "valign" ) ) ; } public void setVAlign ( String vAlign ) { setAttribute ( "valign" , vAlign ) ; } public String getWidth ( ) { return getAttribute ( "width" ) ; } public void setWidth ( String width ) { setAttribute ( "width" , width ) ; } public HTMLTableCellElementImpl ( HTMLDocumentImpl owner , String name ) { super ( owner , name ) ; } } 	0
package org . apache . xerces . validators . datatype ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import java . io . IOException ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; public class DecimalDatatypeValidator extends AbstractDatatypeValidator { private Locale fLocale = null ; private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; private BigDecimal [ ] fEnumDecimal = null ; private String fPattern = null ; private BigDecimal fMaxInclusive = null ; private BigDecimal fMaxExclusive = null ; private BigDecimal fMinInclusive = null ; private BigDecimal fMinExclusive = null ; private int fFacetsDefined = 0 ; private int fScale = 0 ; private int fPrecision = 0 ; private boolean isMaxExclusiveDefined = false ; private boolean isMaxInclusiveDefined = false ; private boolean isMinExclusiveDefined = false ; private boolean isMinInclusiveDefined = false ; private boolean isScaleDefined = false ; private boolean isPrecisionDefined = false ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; private RegularExpression fRegex = null ; private Hashtable fFacets = null ; public DecimalDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public DecimalDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { fFacets = checkForFacetConsistency ( facets , base . getFacets ( ) ) ; fFacets = facets ; if ( fDerivedByList == false ) { Vector enumeration = null ; String value = null ; for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; try { if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = value ; if ( fPattern != null ) fRegex = new RegularExpression ( fPattern , "X" ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; enumeration = ( Vector ) facets . get ( key ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; fMaxInclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MAXEXCLUSIVE ; fMaxExclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; fMinInclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_MINEXCLUSIVE ; fMinExclusive = new BigDecimal ( stripPlusIfPresent ( value ) ) ; } else if ( key . equals ( SchemaSymbols . ELT_PRECISION ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_PRECISSION ; isPrecisionDefined = true ; fPrecision = Integer . parseInt ( value ) ; } else if ( key . equals ( SchemaSymbols . ELT_SCALE ) ) { value = ( ( String ) facets . get ( key ) ) ; fFacetsDefined += DatatypeValidator . FACET_SCALE ; isScaleDefined = true ; fScale = Integer . parseInt ( value ) ; } else { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . MSG_FORMAT_FAILURE , DatatypeMessageProvider . MSG_NONE , null ) ) ; } } catch ( Exception ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } isMaxExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXEXCLUSIVE ) != 0 ) ? true : false ; isMaxInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXINCLUSIVE ) != 0 ) ? true : false ; isMinExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MINEXCLUSIVE ) != 0 ) ? true : false ; isMinInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MININCLUSIVE ) != 0 ) ? true : false ; if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both maxInclusive and maxExclusive to be specified for the same datatype." ) ; } if ( isMinExclusiveDefined && isMinInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both minInclusive and minExclusive to be specified for the same datatype." ) ; } if ( isMaxExclusiveDefined && isMinExclusiveDefined ) { int compareTo = this . fMaxExclusive . compareTo ( this . fMinExclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxExclusive value ='" + this . fMaxExclusive + "'must be > than minExclusive value ='" + this . fMinExclusive + "'. " ) ; } if ( isMaxInclusiveDefined && isMinInclusiveDefined ) { int compareTo = this . fMaxInclusive . compareTo ( this . fMinInclusive ) ; if ( compareTo == - 1 ) throw new InvalidDatatypeFacetException ( "maxInclusive value ='" + this . fMaxInclusive + "'must be >= than minInclusive value ='" + this . fMinInclusive + "'. " ) ; } if ( isMaxExclusiveDefined && isMinInclusiveDefined ) { int compareTo = this . fMaxExclusive . compareTo ( this . fMinInclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxExclusive value ='" + this . fMaxExclusive + "'must be > than minInclusive value ='" + this . fMinInclusive + "'. " ) ; } if ( isMaxInclusiveDefined && isMinExclusiveDefined ) { int compareTo = this . fMaxInclusive . compareTo ( this . fMinExclusive ) ; if ( compareTo != 1 ) throw new InvalidDatatypeFacetException ( "maxInclusive value ='" + this . fMaxInclusive + "'must be > than minExclusive value ='" + this . fMinExclusive + "'. " ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { if ( enumeration != null ) { fEnumDecimal = new BigDecimal [ enumeration . size ( ) ] ; int i = 0 ; try { for ( ; i < enumeration . size ( ) ; i ++ ) { fEnumDecimal [ i ] = new BigDecimal ( stripPlusIfPresent ( ( ( String ) enumeration . elementAt ( i ) ) ) ) ; boundsCheck ( fEnumDecimal [ i ] ) ; } } catch ( Exception idve ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . InvalidEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { enumeration . elementAt ( i ) } ) ) ; } } } } else { } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { if ( fDerivedByList == false ) { if ( this . fBaseValidator != null ) { this . fBaseValidator . validate ( content , state ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_PATTERN ) != 0 ) { if ( fRegex == null || fRegex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value'" + content + "' does not match regular expression facet " + fRegex . getPattern ( ) ) ; } BigDecimal d = null ; try { d = new BigDecimal ( stripPlusIfPresent ( content ) ) ; } catch ( Exception nfe ) { throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotDecimal , DatatypeMessageProvider . MSG_NONE , new Object [ ] { "'" + content + "'" } ) ) ; } if ( isScaleDefined == true ) { if ( d . scale ( ) > fScale ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . ScaleExceeded , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } if ( isPrecisionDefined == true ) { int precision = d . movePointRight ( d . scale ( ) ) . toString ( ) . length ( ) - ( ( d . signum ( ) < 0 ) ? 1 : 0 ) ; if ( precision > fPrecision ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . PrecisionExceeded , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } boundsCheck ( d ) ; if ( fEnumDecimal != null ) enumCheck ( d ) ; } else { } return null ; } public void boundsCheck ( BigDecimal d ) throws InvalidDatatypeValueException { boolean minOk = false ; boolean maxOk = false ; String upperBound = ( fMaxExclusive != null ) ? ( fMaxExclusive . toString ( ) ) : ( ( fMaxInclusive != null ) ? fMaxInclusive . toString ( ) : "" ) ; String lowerBound = ( fMinExclusive != null ) ? ( fMinExclusive . toString ( ) ) : ( ( fMinInclusive != null ) ? fMinInclusive . toString ( ) : "" ) ; String lowerBoundIndicator = "" ; String upperBoundIndicator = "" ; if ( isMaxInclusiveDefined ) { maxOk = ( d . compareTo ( fMaxInclusive ) <= 0 ) ; upperBound = fMaxInclusive . toString ( ) ; if ( upperBound != null ) { upperBoundIndicator = "<=" ; } else { upperBound = "" ; } } else if ( isMaxExclusiveDefined ) { maxOk = ( d . compareTo ( fMaxExclusive ) < 0 ) ; upperBound = fMaxExclusive . toString ( ) ; if ( upperBound != null ) { upperBoundIndicator = "<" ; } else { upperBound = "" ; } } else { maxOk = ( ! isMaxInclusiveDefined && ! isMaxExclusiveDefined ) ; } if ( isMinInclusiveDefined ) { minOk = ( d . compareTo ( fMinInclusive ) >= 0 ) ; lowerBound = fMinInclusive . toString ( ) ; if ( lowerBound != null ) { lowerBoundIndicator = "<=" ; } else { lowerBound = "" ; } } else if ( isMinExclusiveDefined ) { minOk = ( d . compareTo ( fMinExclusive ) > 0 ) ; lowerBound = fMinExclusive . toString ( ) ; if ( lowerBound != null ) { lowerBoundIndicator = "<" ; } else { lowerBound = "" ; } } else { minOk = ( ! isMinInclusiveDefined && ! isMinExclusiveDefined ) ; } if ( ! ( minOk && maxOk ) ) throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . OutOfBounds , DatatypeMessageProvider . MSG_NONE , new Object [ ] { d . toString ( ) , lowerBound , upperBound , lowerBoundIndicator , upperBoundIndicator } ) ) ; } private void enumCheck ( BigDecimal v ) throws InvalidDatatypeValueException { for ( int i = 0 ; i < fEnumDecimal . length ; i ++ ) { if ( v . equals ( fEnumDecimal [ i ] ) ) { return ; } } throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotAnEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { v } ) ) ; } public void setLocale ( Locale locale ) { fLocale = locale ; } public Hashtable getFacets ( ) { return fFacets ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } public int compare ( String content1 , String content2 ) { return 0 ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } static private String stripPlusIfPresent ( String value ) { String strippedPlus = value ; if ( value . length ( ) >= 2 && value . charAt ( 0 ) == '+' && value . charAt ( 1 ) != '-' ) { strippedPlus = value . substring ( 1 ) ; } return strippedPlus ; } private Hashtable checkForFacetConsistency ( Hashtable thisTypeFacets , Hashtable baseTypeFacets ) throws InvalidDatatypeFacetException { String thisTypeFacetValue ; String baseValue ; if ( baseTypeFacets != null ) { Enumeration setOfBaseKeys = baseTypeFacets . keys ( ) ; String keyInBase ; BigDecimal valueOfThisType = null ; BigDecimal valueOfBase = null ; while ( setOfBaseKeys . hasMoreElements ( ) ) { keyInBase = ( String ) setOfBaseKeys . nextElement ( ) ; baseValue = ( String ) baseTypeFacets . get ( keyInBase ) ; thisTypeFacetValue = ( String ) thisTypeFacets . get ( keyInBase ) ; if ( thisTypeFacetValue == null ) { String strThisType = null ; thisTypeFacets . put ( keyInBase , baseValue ) ; if ( keyInBase . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MAXINCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == - 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MAXINCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == - 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MININCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MININCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MININCLUSIVE ) ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MININCLUSIVE ) && thisTypeFacets . containsKey ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { strThisType = ( String ) thisTypeFacets . get ( SchemaSymbols . ELT_MINEXCLUSIVE ) ; valueOfThisType = new BigDecimal ( stripPlusIfPresent ( strThisType ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( valueOfThisType . compareTo ( valueOfBase ) == 1 ) { thisTypeFacets . remove ( keyInBase ) ; } else { thisTypeFacets . remove ( SchemaSymbols . ELT_MINEXCLUSIVE ) ; } } } else { if ( keyInBase . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } else if ( keyInBase . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { valueOfThisType = new BigDecimal ( stripPlusIfPresent ( thisTypeFacetValue ) ) ; valueOfBase = new BigDecimal ( stripPlusIfPresent ( baseValue ) ) ; if ( ( valueOfThisType . compareTo ( valueOfBase ) ) == - 1 ) { ; } else { ; } } } } } return thisTypeFacets ; } } 	1
package org . apache . wml ; public interface WMLWmlElement extends WMLElement { public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package javax . xml . parsers ; public class FactoryConfigurationError extends Error { private Exception exception = null ; public FactoryConfigurationError ( ) { this ( null , null ) ; } public FactoryConfigurationError ( String msg ) { this ( null , msg ) ; } public FactoryConfigurationError ( Exception e ) { this ( e , null ) ; } public FactoryConfigurationError ( Exception e , String msg ) { super ( msg ) ; this . exception = e ; } public Exception getException ( ) { return ( this . exception ) ; } } 	1
package org . apache . xml . serialize ; import java . io . Writer ; import java . io . OutputStream ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import org . w3c . dom . Element ; import org . w3c . dom . Document ; import org . xml . sax . DocumentHandler ; import org . xml . sax . ContentHandler ; public interface Serializer { public void setOutputByteStream ( OutputStream output ) ; public void setOutputCharStream ( Writer output ) ; public void setOutputFormat ( OutputFormat format ) ; public DocumentHandler asDocumentHandler ( ) throws IOException ; public ContentHandler asContentHandler ( ) throws IOException ; public DOMSerializer asDOMSerializer ( ) throws IOException ; } 	0
package org . w3c . dom ; public interface DocumentFragment extends Node { } 	1
package org . apache . xerces . utils ; import java . util . Locale ; public interface XMLMessageProvider { public void setLocale ( Locale locale ) ; public Locale getLocale ( ) ; public String createMessage ( Locale locale , int majorCode , int minorCode , Object args [ ] ) ; } ; 	0
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface MutationEvent extends Event { public Node getRelatedNode ( ) ; public String getPrevValue ( ) ; public String getNewValue ( ) ; public String getAttrName ( ) ; public void initMutationEvent ( String typeArg , boolean canBubbleArg , boolean cancelableArg , Node relatedNodeArg , String prevValueArg , String newValueArg , String attrNameArg ) ; } 	1
package org . apache . xerces . utils . regex ; import java . util . Hashtable ; import java . util . Locale ; class ParserForXMLSchema extends RegexParser { public ParserForXMLSchema ( ) { } public ParserForXMLSchema ( Locale locale ) { } Token processCaret ( ) throws ParseException { this . next ( ) ; return Token . createChar ( '^' ) ; } Token processDollar ( ) throws ParseException { this . next ( ) ; return Token . createChar ( '$' ) ; } Token processLookahead ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processNegativelookahead ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processLookbehind ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processNegativelookbehind ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processBacksolidus_A ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processBacksolidus_Z ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processBacksolidus_z ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processBacksolidus_b ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processBacksolidus_B ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processBacksolidus_lt ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processBacksolidus_gt ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processStar ( Token tok ) throws ParseException { this . next ( ) ; return Token . createClosure ( tok ) ; } Token processPlus ( Token tok ) throws ParseException { this . next ( ) ; return Token . createConcat ( tok , Token . createClosure ( tok ) ) ; } Token processQuestion ( Token tok ) throws ParseException { this . next ( ) ; Token par = Token . createUnion ( ) ; par . addChild ( tok ) ; par . addChild ( Token . createEmpty ( ) ) ; return par ; } boolean checkQuestion ( int off ) { return false ; } Token processParen ( ) throws ParseException { this . next ( ) ; Token tok = Token . createParen ( this . parseRegex ( ) , 0 ) ; if ( this . read ( ) != super . T_RPAREN ) throw ex ( "parser.factor.1" , this . offset - 1 ) ; this . next ( ) ; return tok ; } Token processParen2 ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processCondition ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processModifiers ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processIndependent ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset ) ; } Token processBacksolidus_c ( ) throws ParseException { this . next ( ) ; return this . getTokenForShorthand ( 'c' ) ; } Token processBacksolidus_C ( ) throws ParseException { this . next ( ) ; return this . getTokenForShorthand ( 'C' ) ; } Token processBacksolidus_i ( ) throws ParseException { this . next ( ) ; return this . getTokenForShorthand ( 'i' ) ; } Token processBacksolidus_I ( ) throws ParseException { this . next ( ) ; return this . getTokenForShorthand ( 'I' ) ; } Token processBacksolidus_g ( ) throws ParseException { throw this . ex ( "parser.process.1" , this . offset - 2 ) ; } Token processBacksolidus_X ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset - 2 ) ; } Token processBackreference ( ) throws ParseException { throw ex ( "parser.process.1" , this . offset - 4 ) ; } int processCIinCharacterClass ( RangeToken tok , int c ) { tok . mergeRanges ( this . getTokenForShorthand ( c ) ) ; return - 1 ; } protected RangeToken parseCharacterClass ( boolean useNrange ) throws ParseException { this . setContext ( S_INBRACKETS ) ; this . next ( ) ; boolean nrange = false ; RangeToken base = null ; RangeToken tok ; if ( this . read ( ) == T_CHAR && this . chardata == '^' ) { nrange = true ; this . next ( ) ; base = Token . createRange ( ) ; base . addRange ( 0 , Token . UTF16_MAX ) ; tok = Token . createRange ( ) ; } else { tok = Token . createRange ( ) ; } int type ; boolean firstloop = true ; while ( ( type = this . read ( ) ) != T_EOF ) { if ( type == T_CHAR && this . chardata == ']' && ! firstloop ) { if ( nrange ) { base . subtractRanges ( tok ) ; tok = base ; } break ; } int c = this . chardata ; boolean end = false ; if ( type == T_BACKSOLIDUS ) { switch ( c ) { case 'd' : case 'D' : case 'w' : case 'W' : case 's' : case 'S' : tok . mergeRanges ( this . getTokenForShorthand ( c ) ) ; end = true ; break ; case 'i' : case 'I' : case 'c' : case 'C' : c = this . processCIinCharacterClass ( tok , c ) ; if ( c < 0 ) end = true ; break ; case 'p' : case 'P' : int pstart = this . offset ; RangeToken tok2 = this . processBacksolidus_pP ( c ) ; if ( tok2 == null ) throw this . ex ( "parser.atom.5" , pstart ) ; tok . mergeRanges ( tok2 ) ; end = true ; break ; default : c = this . decodeEscaped ( ) ; } } else if ( type == T_XMLSCHEMA_CC_SUBTRACTION && ! firstloop ) { if ( nrange ) { base . subtractRanges ( tok ) ; tok = base ; } RangeToken range2 = this . parseCharacterClass ( false ) ; tok . subtractRanges ( range2 ) ; if ( this . read ( ) != T_CHAR || this . chardata != ']' ) throw this . ex ( "parser.cc.5" , this . offset ) ; break ; } this . next ( ) ; if ( ! end ) { if ( type == T_CHAR ) { if ( c == '[' ) throw this . ex ( "parser.cc.6" , this . offset - 2 ) ; if ( c == ']' ) throw this . ex ( "parser.cc.7" , this . offset - 2 ) ; } if ( this . read ( ) != T_CHAR || this . chardata != '-' ) { tok . addRange ( c , c ) ; } else { this . next ( ) ; if ( ( type = this . read ( ) ) == T_EOF ) throw this . ex ( "parser.cc.2" , this . offset ) ; if ( type == T_CHAR && this . chardata == ']' ) { tok . addRange ( c , c ) ; tok . addRange ( '-' , '-' ) ; } else if ( type == T_XMLSCHEMA_CC_SUBTRACTION ) { tok . addRange ( c , c ) ; tok . addRange ( '-' , '-' ) ; } else { int rangeend = this . chardata ; if ( type == T_CHAR ) { if ( rangeend == '[' ) throw this . ex ( "parser.cc.6" , this . offset - 1 ) ; if ( rangeend == ']' ) throw this . ex ( "parser.cc.7" , this . offset - 1 ) ; } if ( type == T_BACKSOLIDUS ) rangeend = this . decodeEscaped ( ) ; this . next ( ) ; tok . addRange ( c , rangeend ) ; } } } firstloop = false ; } if ( this . read ( ) == T_EOF ) throw this . ex ( "parser.cc.2" , this . offset ) ; tok . sortRanges ( ) ; tok . compactRanges ( ) ; this . setContext ( S_NORMAL ) ; this . next ( ) ; return tok ; } protected RangeToken parseSetOperations ( ) throws ParseException { throw this . ex ( "parser.process.1" , this . offset ) ; } Token getTokenForShorthand ( int ch ) { switch ( ch ) { case 'd' : return ParserForXMLSchema . getRange ( "xml:isDigit" , true ) ; case 'D' : return ParserForXMLSchema . getRange ( "xml:isDigit" , false ) ; case 'w' : return ParserForXMLSchema . getRange ( "xml:isWord" , true ) ; case 'W' : return ParserForXMLSchema . getRange ( "xml:isWord" , false ) ; case 's' : return ParserForXMLSchema . getRange ( "xml:isSpace" , true ) ; case 'S' : return ParserForXMLSchema . getRange ( "xml:isSpace" , false ) ; case 'c' : return ParserForXMLSchema . getRange ( "xml:isNameChar" , true ) ; case 'C' : return ParserForXMLSchema . getRange ( "xml:isNameChar" , false ) ; case 'i' : return ParserForXMLSchema . getRange ( "xml:isInitialNameChar" , true ) ; case 'I' : return ParserForXMLSchema . getRange ( "xml:isInitialNameChar" , false ) ; default : throw new RuntimeException ( "Internal Error: shorthands: \\u" + Integer . toString ( ch , 16 ) ) ; } } int decodeEscaped ( ) throws ParseException { if ( this . read ( ) != T_BACKSOLIDUS ) throw ex ( "parser.next.1" , this . offset - 1 ) ; int c = this . chardata ; switch ( c ) { case 'n' : c = '\n' ; break ; case 'r' : c = '\r' ; break ; case 't' : c = '\t' ; break ; case 'e' : case 'f' : case 'x' : case 'u' : case 'v' : throw ex ( "parser.process.1" , this . offset - 2 ) ; case 'A' : case 'Z' : case 'z' : throw ex ( "parser.descape.5" , this . offset - 2 ) ; default : } return c ; } static protected Hashtable ranges = null ; static protected Hashtable ranges2 = null ; static synchronized protected RangeToken getRange ( String name , boolean positive ) { if ( ranges == null ) { ranges = new Hashtable ( ) ; ranges2 = new Hashtable ( ) ; Token tok = Token . createRange ( ) ; setupRange ( tok , SPACES ) ; ranges . put ( "xml:isSpace" , tok ) ; ranges2 . put ( "xml:isSpace" , Token . complementRanges ( tok ) ) ; tok = Token . createRange ( ) ; setupRange ( tok , DIGITS ) ; ranges . put ( "xml:isDigit" , tok ) ; ranges2 . put ( "xml:isDigit" , Token . complementRanges ( tok ) ) ; tok = Token . createRange ( ) ; setupRange ( tok , DIGITS ) ; ranges . put ( "xml:isDigit" , tok ) ; ranges2 . put ( "xml:isDigit" , Token . complementRanges ( tok ) ) ; tok = Token . createRange ( ) ; setupRange ( tok , LETTERS ) ; tok . mergeRanges ( ( Token ) ranges . get ( "xml:isDigit" ) ) ; ranges . put ( "xml:isWord" , tok ) ; ranges2 . put ( "xml:isWord" , Token . complementRanges ( tok ) ) ; tok = Token . createRange ( ) ; setupRange ( tok , NAMECHARS ) ; ranges . put ( "xml:isNameChar" , tok ) ; ranges2 . put ( "xml:isNameChar" , Token . complementRanges ( tok ) ) ; tok = Token . createRange ( ) ; setupRange ( tok , LETTERS ) ; tok . addRange ( '_' , '_' ) ; tok . addRange ( ':' , ':' ) ; ranges . put ( "xml:isInitialNameChar" , tok ) ; ranges2 . put ( "xml:isInitialNameChar" , Token . complementRanges ( tok ) ) ; } RangeToken tok = positive ? ( RangeToken ) ranges . get ( name ) : ( RangeToken ) ranges2 . get ( name ) ; return tok ; } static void setupRange ( Token range , String src ) { int len = src . length ( ) ; for ( int i = 0 ; i < len ; i += 2 ) range . addRange ( src . charAt ( i ) , src . charAt ( i + 1 ) ) ; } private static final String SPACES = "\t\n\r\r  " ; private static final String NAMECHARS = "-.0:AZ__az" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" ; private static final String LETTERS = "AZaz" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" ; private static final String DIGITS = "09" + "" + "" ; } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . w3c . dom . traversal . * ; import org . apache . xerces . dom . DocumentImpl ; import org . apache . xerces . dom . DOMExceptionImpl ; public class NodeIteratorImpl implements NodeIterator { private DocumentImpl fDocument ; private Node fRoot ; private int fWhatToShow = NodeFilter . SHOW_ALL ; private NodeFilter fNodeFilter ; private boolean fDetach = false ; private Node fCurrentNode ; private boolean fForward = true ; private boolean fEntityReferenceExpansion ; public NodeIteratorImpl ( DocumentImpl document , Node root , int whatToShow , NodeFilter nodeFilter , boolean entityReferenceExpansion ) { fDocument = document ; fRoot = root ; fCurrentNode = null ; fWhatToShow = whatToShow ; fNodeFilter = nodeFilter ; fEntityReferenceExpansion = entityReferenceExpansion ; } public Node getRoot ( ) { return fRoot ; } public int getWhatToShow ( ) { return fWhatToShow ; } public NodeFilter getFilter ( ) { return fNodeFilter ; } public boolean getExpandEntityReferences ( ) { return fEntityReferenceExpansion ; } public Node nextNode ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMExceptionImpl . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( fRoot == null ) return null ; Node nextNode = fCurrentNode ; boolean accepted = false ; accepted_loop : while ( ! accepted ) { if ( ! fForward && nextNode != null ) { nextNode = fCurrentNode ; } else { if ( ! fEntityReferenceExpansion && nextNode != null && nextNode . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) { nextNode = nextNode ( nextNode , false ) ; } else { nextNode = nextNode ( nextNode , true ) ; } } fForward = true ; if ( nextNode == null ) return null ; accepted = acceptNode ( nextNode ) ; if ( accepted ) { fCurrentNode = nextNode ; return fCurrentNode ; } else continue accepted_loop ; } return null ; } public Node previousNode ( ) { if ( fDetach ) { throw new DOMExceptionImpl ( DOMExceptionImpl . INVALID_STATE_ERR , "DOM011 Invalid state" ) ; } if ( fRoot == null || fCurrentNode == null ) return null ; Node previousNode = fCurrentNode ; boolean accepted = false ; accepted_loop : while ( ! accepted ) { if ( fForward && previousNode != null ) { previousNode = fCurrentNode ; } else { previousNode = previousNode ( previousNode ) ; } fForward = false ; if ( previousNode == null ) return null ; accepted = acceptNode ( previousNode ) ; if ( accepted ) { fCurrentNode = previousNode ; return fCurrentNode ; } else continue accepted_loop ; } return null ; } boolean acceptNode ( Node node ) { if ( fNodeFilter == null ) { return ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ; } else { return ( ( fWhatToShow & ( 1 << node . getNodeType ( ) - 1 ) ) != 0 ) && fNodeFilter . acceptNode ( node ) == NodeFilter . FILTER_ACCEPT ; } } Node matchNodeOrParent ( Node node ) { for ( Node n = node ; n != fRoot ; n = n . getParentNode ( ) ) { if ( node == n ) return n ; } return null ; } Node nextNode ( Node node , boolean visitChildren ) { if ( node == null ) return fRoot ; Node result ; if ( visitChildren ) { if ( node . hasChildNodes ( ) ) { result = node . getFirstChild ( ) ; return result ; } } result = node . getNextSibling ( ) ; if ( result != null ) return result ; Node parent = node . getParentNode ( ) ; while ( parent != null && parent != fRoot ) { result = parent . getNextSibling ( ) ; if ( result != null ) { return result ; } else { parent = parent . getParentNode ( ) ; } } return null ; } Node previousNode ( Node node ) { Node result ; if ( node == fRoot ) return null ; result = node . getPreviousSibling ( ) ; if ( result == null ) { result = node . getParentNode ( ) ; return result ; } if ( result . hasChildNodes ( ) && ! ( ! fEntityReferenceExpansion && result != null && result . getNodeType ( ) == Node . ENTITY_REFERENCE_NODE ) ) { while ( result . hasChildNodes ( ) ) { result = result . getLastChild ( ) ; } } return result ; } public void removeNode ( Node node ) { if ( node == null ) return ; Node deleted = matchNodeOrParent ( node ) ; if ( deleted == null ) return ; if ( fForward ) { fCurrentNode = previousNode ( deleted ) ; } else { Node next = nextNode ( deleted , false ) ; if ( next != null ) { fCurrentNode = next ; } else { fCurrentNode = previousNode ( deleted ) ; fForward = true ; } } } public void detach ( ) { fDetach = true ; fDocument . removeNodeIterator ( this ) ; } } 	1
package org . xml . sax ; public interface ErrorHandler { public abstract void warning ( SAXParseException exception ) throws SAXException ; public abstract void error ( SAXParseException exception ) throws SAXException ; public abstract void fatalError ( SAXParseException exception ) throws SAXException ; } 	0
package org . apache . xerces . readers ; import org . apache . xerces . framework . XMLErrorReporter ; import org . apache . xerces . utils . CharDataChunk ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringHasher ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . utils . XMLCharacterProperties ; import org . apache . xerces . utils . ImplementationMessages ; import org . xml . sax . SAXParseException ; import java . util . Vector ; abstract class AbstractCharReader extends XMLEntityReader { protected AbstractCharReader ( XMLEntityHandler entityHandler , XMLErrorReporter errorReporter , boolean sendCharDataAsCharArray , StringPool stringPool ) { super ( entityHandler , errorReporter , sendCharDataAsCharArray ) ; fStringPool = stringPool ; fCurrentChunk = CharDataChunk . createChunk ( fStringPool , null ) ; } protected CharDataChunk fCurrentChunk = null ; protected int fCurrentIndex = 0 ; protected char [ ] fMostRecentData = null ; protected int fMostRecentChar = 0 ; protected int fLength = 0 ; protected abstract int fillCurrentChunk ( ) throws Exception ; protected void deferException ( int errorCode , Object [ ] args , int offset ) { if ( fDeferredErrors == null ) fDeferredErrors = new Vector ( ) ; DeferredError de = new DeferredError ( errorCode , args , offset ) ; fDeferredErrors . addElement ( de ) ; } protected XMLEntityHandler . EntityReader changeReaders ( ) throws Exception { XMLEntityHandler . EntityReader nextReader = super . changeReaders ( ) ; fCurrentChunk . releaseChunk ( ) ; fCurrentChunk = null ; return nextReader ; } public void append ( XMLEntityHandler . CharBuffer charBuffer , int offset , int length ) { fCurrentChunk . append ( charBuffer , offset , length ) ; } public int addString ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addString ( offset , length ) ; } public int addSymbol ( int offset , int length ) { if ( length == 0 ) return 0 ; return fCurrentChunk . addSymbol ( offset , length , 0 ) ; } public boolean lookingAtChar ( char chr , boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch != chr ) { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtChar ( chr , skipPastChar ) ; } } return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ; } return true ; } public boolean lookingAtValidChar ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0xD800 ) { if ( ch >= 0x20 || ch == 0x09 ) { if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } if ( ch == 0x0A ) { if ( skipPastChar ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } return true ; } if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtValidChar ( skipPastChar ) ; } } return false ; } if ( ch > 0xFFFD ) { return false ; } if ( ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; boolean valid = ( ch >= 0xDC00 && ch < 0xE000 ) ; if ( ! valid || ! skipPastChar ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return valid ; } } else if ( ch < 0xE000 ) { return false ; } if ( skipPastChar ) { fCharacterCounter ++ ; loadNextChar ( ) ; } return true ; } public boolean lookingAtSpace ( boolean skipPastChar ) throws Exception { int ch = fMostRecentChar ; if ( ch > 0x20 ) return false ; if ( ch == 0x20 || ch == 0x09 ) { if ( ! skipPastChar ) return true ; fCharacterCounter ++ ; } else if ( ch == 0x0A ) { if ( ! skipPastChar ) return true ; fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . lookingAtSpace ( skipPastChar ) ; } } return false ; } fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ; return true ; } public void skipToChar ( char chr ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == chr ) return ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) . skipToChar ( chr ) ; return ; } fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else if ( ch >= 0xD800 && ch < 0xDC00 ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) continue ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public void skipPastSpaces ( ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( ch == 0x20 || ch == 0x09 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) changeReaders ( ) . skipPastSpaces ( ) ; return ; } ch = loadNextChar ( ) ; } } public void skipPastName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return ; } while ( true ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } } } public void skipPastNmtoken ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; while ( true ) { if ( fastcheck == ch ) return ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; } } public boolean skippedString ( char [ ] s ) throws Exception { int length = s . length ; char [ ] data = fMostRecentData ; int index = fCurrentIndex ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { for ( int i = 0 ; i < length ; i ++ ) { if ( data [ index ++ ] != s [ i ] ) return false ; } fCharacterCounter += length ; fCurrentOffset += length ; fCurrentIndex = index ; if ( index == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = data [ index ] & 0xFFFF ; return true ; } CharDataChunk dataChunk = fCurrentChunk ; int offset = fCurrentOffset ; int savedIndex = index ; int i = 0 ; while ( index < CharDataChunk . CHUNK_SIZE ) { if ( data [ index ++ ] != s [ i ++ ] ) return false ; } slowLoadNextChar ( ) ; data = fMostRecentData ; index = 0 ; while ( i < length ) { if ( data [ index ++ ] != s [ i ++ ] ) { fCurrentChunk = dataChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } fCharacterCounter += length ; fCurrentOffset += length ; fCurrentIndex = index ; if ( index == CharDataChunk . CHUNK_SIZE ) slowLoadNextChar ( ) ; else fMostRecentChar = data [ index ] & 0xFFFF ; return true ; } public int scanInvalidChar ( ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; loadNextChar ( ) ; } else if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanInvalidChar ( ) ; } if ( fDeferredErrors != null ) { for ( int i = 0 ; i < fDeferredErrors . size ( ) ; i ++ ) { DeferredError de = ( DeferredError ) fDeferredErrors . elementAt ( i ) ; if ( de . offset == fCurrentIndex ) { fErrorReporter . reportError ( fErrorReporter . getLocator ( ) , ImplementationMessages . XERCES_IMPLEMENTATION_DOMAIN , de . errorCode , 0 , de . args , XMLErrorReporter . ERRORTYPE_FATAL_ERROR ) ; fDeferredErrors . removeElementAt ( i ) ; fCharacterCounter ++ ; loadNextChar ( ) ; return - 1 ; } } } fCharacterCounter ++ ; loadNextChar ( ) ; } else { fCharacterCounter ++ ; if ( ch >= 0xD800 && ch < 0xDC00 ) { int ch2 = loadNextChar ( ) ; if ( ch2 >= 0xDC00 && ch2 < 0xE000 ) { ch = ( ( ch - 0xD800 ) << 10 ) + ( ch2 - 0xDC00 ) + 0x10000 ; loadNextChar ( ) ; } } else loadNextChar ( ) ; } return ch ; } public int scanCharRef ( boolean hex ) throws Exception { int ch = fMostRecentChar ; if ( ch == 0 ) { if ( atEOF ( fCurrentOffset + 1 ) ) { return changeReaders ( ) . scanCharRef ( hex ) ; } return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; } int num = 0 ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; } else { if ( ch < '0' || ch > '9' ) return XMLEntityHandler . CHARREF_RESULT_INVALID_CHAR ; num = ch - '0' ; } fCharacterCounter ++ ; loadNextChar ( ) ; boolean toobig = false ; while ( true ) { ch = fMostRecentChar ; if ( ch == 0 ) break ; if ( hex ) { if ( ch > 'f' || XMLCharacterProperties . fgAsciiXDigitChar [ ch ] == 0 ) break ; } else { if ( ch < '0' || ch > '9' ) break ; } fCharacterCounter ++ ; loadNextChar ( ) ; if ( hex ) { int dig = ch - ( ch < 'A' ? '0' : ( ch < 'a' ? 'A' : 'a' ) - 10 ) ; num = ( num << 4 ) + dig ; } else { int dig = ch - '0' ; num = ( num * 10 ) + dig ; } if ( num > 0x10FFFF ) { toobig = true ; num = 0 ; } } if ( ch != ';' ) return XMLEntityHandler . CHARREF_RESULT_SEMICOLON_REQUIRED ; fCharacterCounter ++ ; loadNextChar ( ) ; if ( toobig ) return XMLEntityHandler . CHARREF_RESULT_OUT_OF_RANGE ; return num ; } public int scanStringLiteral ( ) throws Exception { boolean single ; if ( ! ( single = lookingAtChar ( '\'' , true ) ) && ! lookingAtChar ( '\"' , true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_QUOTE_REQUIRED ; } int offset = fCurrentOffset ; char qchar = single ? '\'' : '\"' ; while ( ! lookingAtChar ( qchar , false ) ) { if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . STRINGLIT_RESULT_INVALID_CHAR ; } } int stringIndex = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return stringIndex ; } public int scanAttValue ( char qchar , boolean asSymbol ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( lookingAtChar ( qchar , false ) ) { break ; } if ( lookingAtChar ( ' ' , true ) ) { continue ; } if ( lookingAtSpace ( false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_COMPLEX ; } if ( lookingAtChar ( '<' , false ) ) { return XMLEntityHandler . ATTVALUE_RESULT_LESSTHAN ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ATTVALUE_RESULT_INVALID_CHAR ; } } int result = asSymbol ? addSymbol ( offset , fCurrentOffset - offset ) : addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( qchar , true ) ; return result ; } public int scanEntityValue ( int qchar , boolean createString ) throws Exception { int offset = fCurrentOffset ; while ( true ) { if ( atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . ENTITYVALUE_RESULT_END_OF_INPUT ; } if ( qchar != - 1 && lookingAtChar ( ( char ) qchar , false ) ) { if ( ! createString ) return XMLEntityHandler . ENTITYVALUE_RESULT_FINISHED ; break ; } if ( lookingAtChar ( '&' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_REFERENCE ; } if ( lookingAtChar ( '%' , false ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_PEREF ; } if ( ! lookingAtValidChar ( true ) ) { return XMLEntityHandler . ENTITYVALUE_RESULT_INVALID_CHAR ; } } int result = addString ( offset , fCurrentOffset - offset ) ; lookingAtChar ( ( char ) qchar , true ) ; return result ; } public int scanName ( char fastcheck ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) return - 1 ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) return - 1 ; } int offset = fCurrentOffset ; int index = fCurrentIndex ; char [ ] data = fMostRecentData ; if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; int hashcode = 0 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = data [ index ] & 0xFFFF ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; } fCurrentIndex = index ; fMostRecentChar = ch ; hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; int nameIndex = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; return nameIndex ; } public boolean scanExpectedName ( char fastcheck , StringPool . CharArrayRange expectedName ) throws Exception { char [ ] expected = expectedName . chars ; int offset = expectedName . offset ; int len = expectedName . length ; int ch = fMostRecentChar ; for ( int i = 0 ; i < len ; i ++ ) { if ( ch != expected [ offset ++ ] ) { skipPastNmtoken ( fastcheck ) ; return false ; } fCharacterCounter ++ ; fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) ch = slowLoadNextChar ( ) ; else ch = ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } if ( ch == fastcheck ) return true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) return true ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) return true ; } skipPastNmtoken ( fastcheck ) ; return false ; } public void scanQName ( char fastcheck , QName qname ) throws Exception { int ch = fMostRecentChar ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 ) { qname . clear ( ) ; return ; } if ( ch == ':' ) { qname . clear ( ) ; return ; } } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) { qname . clear ( ) ; return ; } } int offset = fCurrentOffset ; int index = fCurrentIndex ; char [ ] data = fMostRecentData ; if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; int hashcode = 0 ; int prefixend = - 1 ; while ( true ) { hashcode = StringHasher . hashChar ( hashcode , ch ) ; ch = data [ index ] & 0xFFFF ; if ( fastcheck == ch ) break ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiNameChar [ ch ] == 0 ) break ; if ( ch == ':' ) { if ( prefixend != - 1 ) break ; prefixend = fCurrentOffset ; if ( index + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk savedChunk = fCurrentChunk ; int savedOffset = fCurrentOffset ; ch = slowLoadNextChar ( ) ; fCurrentChunk = savedChunk ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; } else ch = data [ index + 1 ] & 0xFFFF ; boolean lpok = true ; if ( ch < 0x80 ) { if ( XMLCharacterProperties . fgAsciiInitialNameChar [ ch ] == 0 || ch == ':' ) lpok = false ; } else { if ( ! fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_InitialNameCharFlag ) == 0 ) lpok = false ; } ch = ':' ; if ( ! lpok ) { prefixend = - 1 ; break ; } } } else { if ( fCalledCharPropInit ) { XMLCharacterProperties . initCharFlags ( ) ; fCalledCharPropInit = true ; } if ( ( XMLCharacterProperties . fgCharFlags [ ch ] & XMLCharacterProperties . E_NameCharFlag ) == 0 ) break ; } if ( ++ index == CharDataChunk . CHUNK_SIZE ) { slowLoadNextChar ( ) ; index = 0 ; data = fMostRecentData ; } fCharacterCounter ++ ; fCurrentOffset ++ ; } fCurrentIndex = index ; fMostRecentChar = ch ; hashcode = StringHasher . finishHash ( hashcode ) ; int length = fCurrentOffset - offset ; qname . rawname = fCurrentChunk . addSymbol ( offset , length , hashcode ) ; qname . prefix = prefixend == - 1 ? - 1 : addSymbol ( offset , prefixend - offset ) ; qname . localpart = prefixend == - 1 ? qname . rawname : addSymbol ( prefixend + 1 , fCurrentOffset - ( prefixend + 1 ) ) ; qname . uri = - 1 ; } public int scanContent ( QName element ) throws Exception { if ( fCallClearPreviousChunk && fCurrentChunk . clearPreviousChunk ( ) ) fCallClearPreviousChunk = false ; int charDataOffset = fCurrentOffset ; int ch = fMostRecentChar ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiWSCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeMarkup ( ch ) ; } break ; case 2 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ! fInCDSect ) { return recognizeReference ( ch ) ; } break ; case 3 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch != ']' ) break ; if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) break ; fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; fCharacterCounter += 2 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; case 5 : do { if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else fCharacterCounter ++ ; ch = loadNextChar ( ) ; } while ( ch == 0x20 || ch == 0x09 || ch == 0x0A ) ; if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , true ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , true ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } break ; } } else if ( ! skipMultiByteCharData ( ch ) ) { return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = skipAsciiCharData ( ) ; while ( true ) { if ( ch < 0x80 ) { switch ( XMLCharacterProperties . fgAsciiCharData [ ch ] ) { case 0 : fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 1 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeMarkup ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 2 : if ( ! fInCDSect ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; fCharacterCounter ++ ; ch = loadNextChar ( ) ; return recognizeReference ( ch ) ; } fCharacterCounter ++ ; ch = loadNextChar ( ) ; break ; case 3 : int endOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch != ']' ) { fCharacterCounter ++ ; break ; } if ( fCurrentIndex + 1 == CharDataChunk . CHUNK_SIZE ) { CharDataChunk dataChunk = fCurrentChunk ; int index = fCurrentIndex ; int offset = fCurrentOffset ; if ( loadNextChar ( ) != '>' ) { fCurrentChunk = dataChunk ; fCurrentIndex = index ; fCurrentOffset = offset ; fMostRecentData = dataChunk . toCharArray ( ) ; fMostRecentChar = ']' ; fCharacterCounter ++ ; break ; } } else { if ( fMostRecentData [ fCurrentIndex + 1 ] != '>' ) { fCharacterCounter ++ ; break ; } fCurrentIndex ++ ; fCurrentOffset ++ ; } loadNextChar ( ) ; callCharDataHandler ( charDataOffset , endOffset , false ) ; fCharacterCounter += 3 ; return XMLEntityHandler . CONTENT_RESULT_END_OF_CDSECT ; case 4 : if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; ch = loadNextChar ( ) ; break ; } callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; if ( ch == 0 && atEOF ( fCurrentOffset + 1 ) ) { changeReaders ( ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } } else { if ( ! skipMultiByteCharData ( ch ) ) { callCharDataHandler ( charDataOffset , fCurrentOffset , false ) ; return XMLEntityHandler . CONTENT_RESULT_INVALID_CHAR ; } ch = fMostRecentChar ; } } } private static final char [ ] cdata_string = { 'C' , 'D' , 'A' , 'T' , 'A' , '[' } ; private StringPool fStringPool = null ; private boolean fCalledCharPropInit = false ; private boolean fCallClearPreviousChunk = true ; private Vector fDeferredErrors = null ; private class DeferredError { int errorCode ; Object [ ] args ; int offset ; DeferredError ( int ec , Object [ ] a , int o ) { errorCode = ec ; args = a ; offset = o ; } } private int recognizeMarkup ( int ch ) throws Exception { switch ( ch ) { case 0 : return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; case '?' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_PI ; case '!' : fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -- ; fCurrentOffset -- ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= 2 ; fCurrentOffset -= 2 ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch == '-' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_COMMENT ; } break ; } if ( ch == '[' ) { for ( int i = 0 ; i < 6 ; i ++ ) { fCharacterCounter ++ ; ch = loadNextChar ( ) ; if ( ch == 0 ) { fCharacterCounter -= ( 2 + i ) ; fCurrentOffset -= ( 2 + i ) ; return XMLEntityHandler . CONTENT_RESULT_MARKUP_END_OF_INPUT ; } if ( ch != cdata_string [ i ] ) { return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } } fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CDSECT ; } break ; case '/' : fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_ETAG ; default : return XMLEntityHandler . CONTENT_RESULT_START_OF_ELEMENT ; } return XMLEntityHandler . CONTENT_RESULT_MARKUP_NOT_RECOGNIZED ; } private int recognizeReference ( int ch ) throws Exception { if ( ch == 0 ) { return XMLEntityHandler . CONTENT_RESULT_REFERENCE_END_OF_INPUT ; } if ( ch == '#' ) { fCharacterCounter ++ ; loadNextChar ( ) ; return XMLEntityHandler . CONTENT_RESULT_START_OF_CHARREF ; } else { return XMLEntityHandler . CONTENT_RESULT_START_OF_ENTITYREF ; } } private boolean skipMultiByteCharData ( int ch ) throws Exception { if ( ch < 0xD800 ) { loadNextChar ( ) ; return true ; } if ( ch > 0xFFFD ) return false ; if ( ch >= 0xDC00 && ch < 0xE000 ) return false ; if ( ch >= 0xD800 && ch < 0xDC00 ) { CharDataChunk savedChunk = fCurrentChunk ; int savedIndex = fCurrentIndex ; int savedOffset = fCurrentOffset ; ch = loadNextChar ( ) ; if ( ch < 0xDC00 || ch >= 0xE000 ) { fCurrentChunk = savedChunk ; fCurrentIndex = savedIndex ; fCurrentOffset = savedOffset ; fMostRecentData = savedChunk . toCharArray ( ) ; fMostRecentChar = fMostRecentData [ savedIndex ] & 0xFFFF ; return false ; } } loadNextChar ( ) ; return true ; } private int skipAsciiCharData ( ) throws Exception { int index = fCurrentIndex ; int offset = fCurrentOffset - index ; while ( true ) { char [ ] data = fMostRecentData ; while ( index < CharDataChunk . CHUNK_SIZE ) { int ch = data [ index ] & 0xFFFF ; if ( ch >= 0x80 ) { fCurrentOffset = offset + index ; fCurrentIndex = index ; fMostRecentChar = ch ; return ch ; } if ( XMLCharacterProperties . fgAsciiCharData [ ch ] == 0 ) { fCharacterCounter ++ ; } else if ( ch == 0x0A ) { fLinefeedCounter ++ ; fCharacterCounter = 1 ; } else { fCurrentOffset = offset + index ; fCurrentIndex = index ; fMostRecentChar = ch ; return ch ; } index ++ ; } offset += index ; slowLoadNextChar ( ) ; index = 0 ; } } private void callCharDataHandler ( int offset , int endOffset , boolean isWhitespace ) throws Exception { int length = endOffset - offset ; if ( ! fSendCharDataAsCharArray ) { int stringIndex = addString ( offset , length ) ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( stringIndex ) ; else fCharDataHandler . processCharacters ( stringIndex ) ; return ; } CharDataChunk dataChunk = fCurrentChunk . chunkFor ( offset ) ; int index = offset & CharDataChunk . CHUNK_MASK ; if ( index + length <= CharDataChunk . CHUNK_SIZE ) { if ( length != 0 ) { if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , length ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , length ) ; } return ; } int count = length ; int nbytes = CharDataChunk . CHUNK_SIZE - index ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , index , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , index , nbytes ) ; count -= nbytes ; do { dataChunk = dataChunk . nextChunk ( ) ; if ( dataChunk == null ) { throw new RuntimeException ( new ImplementationMessages ( ) . createMessage ( null , ImplementationMessages . INT_DCN , 0 , null ) ) ; } nbytes = count <= CharDataChunk . CHUNK_SIZE ? count : CharDataChunk . CHUNK_SIZE ; if ( isWhitespace ) fCharDataHandler . processWhitespace ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; else fCharDataHandler . processCharacters ( dataChunk . toCharArray ( ) , 0 , nbytes ) ; count -= nbytes ; } while ( count > 0 ) ; } private int slowLoadNextChar ( ) throws Exception { fCallClearPreviousChunk = true ; if ( fCurrentChunk . nextChunk ( ) != null ) { fCurrentChunk = fCurrentChunk . nextChunk ( ) ; fCurrentIndex = 0 ; fMostRecentData = fCurrentChunk . toCharArray ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } else { fCurrentChunk = CharDataChunk . createChunk ( fStringPool , fCurrentChunk ) ; return fillCurrentChunk ( ) ; } } private int loadNextChar ( ) throws Exception { fCurrentOffset ++ ; if ( ++ fCurrentIndex == CharDataChunk . CHUNK_SIZE ) return slowLoadNextChar ( ) ; return ( fMostRecentChar = fMostRecentData [ fCurrentIndex ] & 0xFFFF ) ; } private boolean atEOF ( int offset ) { return ( offset > fLength ) ; } } 	1
package org . apache . xerces . utils . regex ; import java . text . CharacterIterator ; public class BMPattern { char [ ] pattern ; int [ ] shiftTable ; boolean ignoreCase ; public BMPattern ( String pat , boolean ignoreCase ) { this ( pat , 256 , ignoreCase ) ; } public BMPattern ( String pat , int tableSize , boolean ignoreCase ) { this . pattern = pat . toCharArray ( ) ; this . shiftTable = new int [ tableSize ] ; this . ignoreCase = ignoreCase ; int length = pattern . length ; for ( int i = 0 ; i < this . shiftTable . length ; i ++ ) this . shiftTable [ i ] = length ; for ( int i = 0 ; i < length ; i ++ ) { char ch = this . pattern [ i ] ; int diff = length - i - 1 ; int index = ch % this . shiftTable . length ; if ( diff < this . shiftTable [ index ] ) this . shiftTable [ index ] = diff ; if ( this . ignoreCase ) { ch = Character . toUpperCase ( ch ) ; index = ch % this . shiftTable . length ; if ( diff < this . shiftTable [ index ] ) this . shiftTable [ index ] = diff ; ch = Character . toLowerCase ( ch ) ; index = ch % this . shiftTable . length ; if ( diff < this . shiftTable [ index ] ) this . shiftTable [ index ] = diff ; } } } public int matches ( CharacterIterator iterator , int start , int limit ) { if ( this . ignoreCase ) return this . matchesIgnoreCase ( iterator , start , limit ) ; int plength = this . pattern . length ; if ( plength == 0 ) return start ; int index = start + plength ; while ( index <= limit ) { int pindex = plength ; int nindex = index + 1 ; char ch ; do { if ( ( ch = iterator . setIndex ( -- index ) ) != this . pattern [ -- pindex ] ) break ; if ( pindex == 0 ) return index ; } while ( pindex > 0 ) ; index += this . shiftTable [ ch % this . shiftTable . length ] + 1 ; if ( index < nindex ) index = nindex ; } return - 1 ; } public int matches ( String str , int start , int limit ) { if ( this . ignoreCase ) return this . matchesIgnoreCase ( str , start , limit ) ; int plength = this . pattern . length ; if ( plength == 0 ) return start ; int index = start + plength ; while ( index <= limit ) { int pindex = plength ; int nindex = index + 1 ; char ch ; do { if ( ( ch = str . charAt ( -- index ) ) != this . pattern [ -- pindex ] ) break ; if ( pindex == 0 ) return index ; } while ( pindex > 0 ) ; index += this . shiftTable [ ch % this . shiftTable . length ] + 1 ; if ( index < nindex ) index = nindex ; } return - 1 ; } public int matches ( char [ ] chars , int start , int limit ) { if ( this . ignoreCase ) return this . matchesIgnoreCase ( chars , start , limit ) ; int plength = this . pattern . length ; if ( plength == 0 ) return start ; int index = start + plength ; while ( index <= limit ) { int pindex = plength ; int nindex = index + 1 ; char ch ; do { if ( ( ch = chars [ -- index ] ) != this . pattern [ -- pindex ] ) break ; if ( pindex == 0 ) return index ; } while ( pindex > 0 ) ; index += this . shiftTable [ ch % this . shiftTable . length ] + 1 ; if ( index < nindex ) index = nindex ; } return - 1 ; } int matchesIgnoreCase ( CharacterIterator iterator , int start , int limit ) { int plength = this . pattern . length ; if ( plength == 0 ) return start ; int index = start + plength ; while ( index <= limit ) { int pindex = plength ; int nindex = index + 1 ; char ch ; do { char ch1 = ch = iterator . setIndex ( -- index ) ; char ch2 = this . pattern [ -- pindex ] ; if ( ch1 != ch2 ) { ch1 = Character . toUpperCase ( ch1 ) ; ch2 = Character . toUpperCase ( ch2 ) ; if ( ch1 != ch2 && Character . toLowerCase ( ch1 ) != Character . toLowerCase ( ch2 ) ) break ; } if ( pindex == 0 ) return index ; } while ( pindex > 0 ) ; index += this . shiftTable [ ch % this . shiftTable . length ] + 1 ; if ( index < nindex ) index = nindex ; } return - 1 ; } int matchesIgnoreCase ( String text , int start , int limit ) { int plength = this . pattern . length ; if ( plength == 0 ) return start ; int index = start + plength ; while ( index <= limit ) { int pindex = plength ; int nindex = index + 1 ; char ch ; do { char ch1 = ch = text . charAt ( -- index ) ; char ch2 = this . pattern [ -- pindex ] ; if ( ch1 != ch2 ) { ch1 = Character . toUpperCase ( ch1 ) ; ch2 = Character . toUpperCase ( ch2 ) ; if ( ch1 != ch2 && Character . toLowerCase ( ch1 ) != Character . toLowerCase ( ch2 ) ) break ; } if ( pindex == 0 ) return index ; } while ( pindex > 0 ) ; index += this . shiftTable [ ch % this . shiftTable . length ] + 1 ; if ( index < nindex ) index = nindex ; } return - 1 ; } int matchesIgnoreCase ( char [ ] chars , int start , int limit ) { int plength = this . pattern . length ; if ( plength == 0 ) return start ; int index = start + plength ; while ( index <= limit ) { int pindex = plength ; int nindex = index + 1 ; char ch ; do { char ch1 = ch = chars [ -- index ] ; char ch2 = this . pattern [ -- pindex ] ; if ( ch1 != ch2 ) { ch1 = Character . toUpperCase ( ch1 ) ; ch2 = Character . toUpperCase ( ch2 ) ; if ( ch1 != ch2 && Character . toLowerCase ( ch1 ) != Character . toLowerCase ( ch2 ) ) break ; } if ( pindex == 0 ) return index ; } while ( pindex > 0 ) ; index += this . shiftTable [ ch % this . shiftTable . length ] + 1 ; if ( index < nindex ) index = nindex ; } return - 1 ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . range . * ; public class RangeExceptionImpl extends RangeException { public RangeExceptionImpl ( short code , String message ) { super ( code , message ) ; } } 	1
package org . apache . wml ; public interface WMLAElement extends WMLElement { public void setHref ( String newValue ) ; public String getHref ( ) ; public void setTitle ( String newValue ) ; public String getTitle ( ) ; public void setId ( String newValue ) ; public String getId ( ) ; public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ChildAndParentNode extends ChildNode { static final long serialVersionUID = 0 ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ChildAndParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ChildAndParentNode ( ) { } public Node cloneNode ( boolean deep ) { ChildAndParentNode newnode = ( ChildAndParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1
package org . apache . wml . dom ; import org . apache . xerces . dom . ElementImpl ; import org . apache . wml . * ; public class WMLElementImpl extends ElementImpl implements WMLElement { public WMLElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setXmlLang ( String newValue ) { setAttribute ( "xml:lang" , newValue ) ; } public String getXmlLang ( ) { return getAttribute ( "xml:lang" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } void setAttribute ( String attr , boolean value ) { setAttribute ( attr , value ? "true" : "false" ) ; } boolean getAttribute ( String attr , boolean defaultValue ) { boolean ret = defaultValue ; String value ; if ( ( ( value = getAttribute ( "emptyok" ) ) != null ) && value . equals ( "true" ) ) ret = true ; return ret ; } void setAttribute ( String attr , int value ) { setAttribute ( attr , value + "" ) ; } int getAttribute ( String attr , int defaultValue ) { int ret = defaultValue ; String value ; if ( ( value = getAttribute ( "emptyok" ) ) != null ) ret = Integer . parseInt ( value ) ; return ret ; } } 	0
package org . w3c . dom . events ; import org . w3c . dom . DOMException ; public interface DocumentEvent { public Event createEvent ( String eventType ) throws DOMException ; } 	1
package org . apache . xerces . validators . datatype ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import org . apache . xerces . validators . schema . SchemaSymbols ; import org . apache . xerces . utils . regex . RegularExpression ; import java . util . StringTokenizer ; import java . util . NoSuchElementException ; public class FloatDatatypeValidator extends AbstractDatatypeValidator { private Locale fLocale = null ; private DatatypeValidator fBaseValidator = null ; private float [ ] fEnumFloats = null ; private String fPattern = null ; private boolean fDerivedByList = false ; private float fMaxInclusive = Float . MAX_VALUE ; private float fMaxExclusive = Float . MAX_VALUE ; private float fMinInclusive = Float . MIN_VALUE ; private float fMinExclusive = Float . MIN_VALUE ; private int fFacetsDefined = 0 ; private boolean isMaxExclusiveDefined = false ; private boolean isMaxInclusiveDefined = false ; private boolean isMinExclusiveDefined = false ; private boolean isMinInclusiveDefined = false ; private DatatypeMessageProvider fMessageProvider = new DatatypeMessageProvider ( ) ; private RegularExpression fRegex = null ; public FloatDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public FloatDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { if ( base != null ) setBasetype ( base ) ; fDerivedByList = derivedByList ; if ( facets != null ) { if ( fDerivedByList == false ) { for ( Enumeration e = facets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . equals ( SchemaSymbols . ELT_PATTERN ) ) { fFacetsDefined += DatatypeValidator . FACET_PATTERN ; fPattern = ( String ) facets . get ( key ) ; if ( fPattern != null ) fRegex = new RegularExpression ( fPattern , "X" ) ; } else if ( key . equals ( SchemaSymbols . ELT_ENUMERATION ) ) { fFacetsDefined += DatatypeValidator . FACET_ENUMERATION ; continue ; } else if ( key . equals ( SchemaSymbols . ELT_MAXINCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXINCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMaxInclusive = Float . valueOf ( value ) . floatValue ( ) ; } catch ( NumberFormatException ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MAXEXCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MAXEXCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMaxExclusive = Float . valueOf ( value ) . floatValue ( ) ; } catch ( NumberFormatException ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MININCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMinInclusive = Float . valueOf ( value ) . floatValue ( ) ; } catch ( NumberFormatException ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else if ( key . equals ( SchemaSymbols . ELT_MINEXCLUSIVE ) ) { fFacetsDefined += DatatypeValidator . FACET_MININCLUSIVE ; String value = null ; try { value = ( ( String ) facets . get ( key ) ) ; fMinExclusive = Float . valueOf ( value ) . floatValue ( ) ; } catch ( NumberFormatException ex ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . IllegalFacetValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { value , key } ) ) ; } } else { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . MSG_FORMAT_FAILURE , DatatypeMessageProvider . MSG_NONE , null ) ) ; } } isMaxExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXEXCLUSIVE ) != 0 ) ? true : false ; isMaxInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MAXINCLUSIVE ) != 0 ) ? true : false ; isMinExclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MINEXCLUSIVE ) != 0 ) ? true : false ; isMinInclusiveDefined = ( ( fFacetsDefined & DatatypeValidator . FACET_MININCLUSIVE ) != 0 ) ? true : false ; if ( isMaxExclusiveDefined && isMaxInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both maxInclusive and maxExclusive to be specified for the same datatype." ) ; } if ( isMinExclusiveDefined && isMinInclusiveDefined ) { throw new InvalidDatatypeFacetException ( "It is an error for both minInclusive and minExclusive to be specified for the same datatype." ) ; } if ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) { Vector v = ( Vector ) facets . get ( SchemaSymbols . ELT_ENUMERATION ) ; if ( v != null ) { fEnumFloats = new float [ v . size ( ) ] ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) try { fEnumFloats [ i ] = Float . valueOf ( ( String ) v . elementAt ( i ) ) . floatValue ( ) ; boundsCheck ( fEnumFloats [ i ] ) ; } catch ( InvalidDatatypeValueException idve ) { throw new InvalidDatatypeFacetException ( getErrorString ( DatatypeMessageProvider . InvalidEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { v . elementAt ( i ) } ) ) ; } catch ( NumberFormatException nfe ) { System . out . println ( "Internal Error parsing enumerated values for real type" ) ; } } } } else { } } } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { if ( fDerivedByList == false ) { checkContent ( content ) ; } else { StringTokenizer parsedList = new StringTokenizer ( content ) ; try { while ( parsedList . hasMoreTokens ( ) ) { checkContent ( parsedList . nextToken ( ) ) ; } } catch ( NoSuchElementException e ) { e . printStackTrace ( ) ; } } return null ; } private void boundsCheck ( float f ) throws InvalidDatatypeValueException { boolean inUpperBound = false ; boolean inLowerBound = false ; if ( isMaxInclusiveDefined ) { inUpperBound = ( f <= fMaxInclusive ) ; } else if ( isMaxExclusiveDefined ) { inUpperBound = ( f < fMaxExclusive ) ; } if ( isMinInclusiveDefined ) { inLowerBound = ( f >= fMinInclusive ) ; } else if ( isMinExclusiveDefined ) { inLowerBound = ( f > fMinExclusive ) ; } if ( inUpperBound == false || inLowerBound == false ) { getErrorString ( DatatypeMessageProvider . OutOfBounds , DatatypeMessageProvider . MSG_NONE , new Object [ ] { new Float ( f ) , "" , "" , "" , "" } ) ; } } private void enumCheck ( float v ) throws InvalidDatatypeValueException { for ( int i = 0 ; i < fEnumFloats . length ; i ++ ) { if ( v == fEnumFloats [ i ] ) return ; } throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotAnEnumValue , DatatypeMessageProvider . MSG_NONE , new Object [ ] { new Float ( v ) } ) ) ; } public void setLocale ( Locale locale ) { fLocale = locale ; } public int compare ( String content1 , String content2 ) { return 0 ; } public Hashtable getFacets ( ) { return null ; } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } private String getErrorString ( int major , int minor , Object args [ ] ) { try { return fMessageProvider . createMessage ( fLocale , major , minor , args ) ; } catch ( Exception e ) { return "Illegal Errorcode " + minor ; } } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } private void checkContent ( String content ) throws InvalidDatatypeValueException { if ( ( fFacetsDefined & DatatypeValidator . FACET_PATTERN ) != 0 ) { if ( fRegex == null || fRegex . matches ( content ) == false ) throw new InvalidDatatypeValueException ( "Value'" + content + "does not match regular expression facet" + fPattern ) ; } float f = 0 ; try { f = Float . valueOf ( content ) . floatValue ( ) ; } catch ( NumberFormatException nfe ) { if ( content . equals ( "INF" ) ) { f = Float . POSITIVE_INFINITY ; } else if ( content . equals ( "-INF" ) ) { f = Float . NEGATIVE_INFINITY ; } else if ( content . equals ( "NaN" ) ) { f = Float . NaN ; } else { throw new InvalidDatatypeValueException ( getErrorString ( DatatypeMessageProvider . NotFloat , DatatypeMessageProvider . MSG_NONE , new Object [ ] { content } ) ) ; } } boundsCheck ( f ) ; if ( ( ( fFacetsDefined & DatatypeValidator . FACET_ENUMERATION ) != 0 ) ) enumCheck ( f ) ; } } 	0
package org . apache . xerces . dom ; import java . io . * ; import org . w3c . dom . * ; import org . w3c . dom . events . * ; import org . apache . xerces . dom . * ; import org . apache . xerces . dom . events . * ; public abstract class ParentNode extends NodeImpl { static final long serialVersionUID = 2815829867152120872L ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ParentNode ( DocumentImpl ownerDocument ) { super ( ownerDocument ) ; this . ownerDocument = ownerDocument ; } public ParentNode ( ) { } public Node cloneNode ( boolean deep ) { ParentNode newnode = ( ParentNode ) super . cloneNode ( deep ) ; newnode . ownerDocument = ownerDocument ; if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } newnode . firstChild = null ; newnode . nodeListIndex = - 1 ; newnode . nodeListLength = - 1 ; if ( deep ) { for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { newnode . appendChild ( child . cloneNode ( true ) ) ; } } return newnode ; } public Document getOwnerDocument ( ) { return ownerDocument ; } DocumentImpl ownerDocument ( ) { return ownerDocument ; } void setOwnerDocument ( DocumentImpl doc ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( Node child = firstChild ; child != null ; child = child . getNextSibling ( ) ) { ( ( NodeImpl ) child ) . setOwnerDocument ( doc ) ; } ownerDocument = doc ; } public boolean hasChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild != null ; } public NodeList getChildNodes ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return this ; } public Node getFirstChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return firstChild ; } public Node getLastChild ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } return lastChild ( ) ; } final ChildNode lastChild ( ) { return firstChild != null ? firstChild . previousSibling : null ; } final void lastChild ( ChildNode node ) { if ( firstChild != null ) { firstChild . previousSibling = node ; } } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { return internalInsertBefore ( newChild , refChild , MUTATION_ALL ) ; } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; boolean errorChecking = ownerDocument . errorChecking ; if ( errorChecking && newChild . getOwnerDocument ( ) != ownerDocument ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( errorChecking ) { boolean treeSafe = true ; for ( NodeImpl a = parentNode ( ) ; treeSafe && a != null ; a = a . parentNode ( ) ) { treeSafe = newChild != a ; } if ( ! treeSafe ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } if ( refChild != null && refChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } } if ( newChild . getNodeType ( ) == Node . DOCUMENT_FRAGMENT_NODE ) { for ( Node kid = newChild . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( errorChecking && ! ownerDocument . isKidOK ( this , kid ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } } while ( newChild . hasChildNodes ( ) ) { insertBefore ( newChild . getFirstChild ( ) , refChild ) ; } } else if ( errorChecking && ( ! ( newChild instanceof ChildNode ) || ! ownerDocument . isKidOK ( this , newChild ) ) ) { throw new DOMExceptionImpl ( DOMException . HIERARCHY_REQUEST_ERR , "DOM006 Hierarchy request error" ) ; } else { ChildNode newInternal = ( ChildNode ) newChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents && ( mutationMask & MUTATION_AGGREGATE ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } Node oldparent = newInternal . parentNode ( ) ; if ( oldparent != null ) { oldparent . removeChild ( newInternal ) ; } ChildNode refInternal = ( ChildNode ) refChild ; newInternal . ownerNode = this ; newInternal . isOwned ( true ) ; if ( firstChild == null ) { firstChild = newInternal ; newInternal . isFirstChild ( true ) ; newInternal . previousSibling = newInternal ; } else { if ( refInternal == null ) { ChildNode lastChild = firstChild . previousSibling ; lastChild . nextSibling = newInternal ; newInternal . previousSibling = lastChild ; firstChild . previousSibling = newInternal ; } else { if ( refChild == firstChild ) { firstChild . isFirstChild ( false ) ; newInternal . nextSibling = firstChild ; newInternal . previousSibling = firstChild . previousSibling ; firstChild . previousSibling = newInternal ; firstChild = newInternal ; newInternal . isFirstChild ( true ) ; } else { ChildNode prev = refInternal . previousSibling ; newInternal . nextSibling = refInternal ; prev . nextSibling = newInternal ; refInternal . previousSibling = newInternal ; newInternal . previousSibling = prev ; } } } changed ( ) ; if ( nodeListLength != - 1 ) { nodeListLength ++ ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == refInternal ) { nodeListNode = newInternal ; } else { nodeListIndex = - 1 ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED , true , false , this , null , null , null ) ; newInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) ( enclosingAttr . node . getOwnerElement ( ) ) ; if ( eventAncestor != null ) { NodeImpl p = eventAncestor ; while ( p != null ) { eventAncestor = p ; if ( p . getNodeType ( ) == ATTRIBUTE_NODE ) p = ( ElementImpl ) ( ( AttrImpl ) p ) . getOwnerElement ( ) ; else p = p . parentNode ( ) ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_INSERTED_INTO_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( newInternal , me ) ; } } } } if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } } return newChild ; } public Node removeChild ( Node oldChild ) throws DOMException { return internalRemoveChild ( oldChild , MUTATION_ALL ) ; } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( ownerDocument . errorChecking && oldChild != null && oldChild . getParentNode ( ) != this ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } ownerDocument . removedChildNode ( oldChild ) ; ChildNode oldInternal = ( ChildNode ) oldChild ; EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } if ( ( mutationMask & MUTATION_LOCAL ) != 0 ) { lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED , true , false , this , null , null , null ) ; oldInternal . dispatchEvent ( me ) ; } lc = LCount . lookup ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { NodeImpl eventAncestor = this ; if ( enclosingAttr != null ) eventAncestor = ( NodeImpl ) enclosingAttr . node . getOwnerElement ( ) ; if ( eventAncestor != null ) { for ( NodeImpl p = eventAncestor . parentNode ( ) ; p != null ; p = p . parentNode ( ) ) { eventAncestor = p ; } if ( eventAncestor . getNodeType ( ) == Node . DOCUMENT_NODE ) { MutationEvent me = new MutationEventImpl ( ) ; me . initMutationEvent ( MutationEventImpl . DOM_NODE_REMOVED_FROM_DOCUMENT , false , false , null , null , null , null ) ; dispatchEventToSubtree ( oldInternal , me ) ; } } } } } if ( nodeListLength != - 1 ) { nodeListLength -- ; } if ( nodeListIndex != - 1 ) { if ( nodeListNode == oldInternal ) { nodeListIndex -- ; nodeListNode = oldInternal . previousSibling ( ) ; } else { nodeListIndex = - 1 ; } } if ( oldInternal == firstChild ) { oldInternal . isFirstChild ( false ) ; firstChild = oldInternal . nextSibling ; if ( firstChild != null ) { firstChild . isFirstChild ( true ) ; firstChild . previousSibling = oldInternal . previousSibling ; } } else { ChildNode prev = oldInternal . previousSibling ; ChildNode next = oldInternal . nextSibling ; prev . nextSibling = next ; if ( next == null ) { firstChild . previousSibling = prev ; } else { next . previousSibling = prev ; } } oldInternal . ownerNode = ownerDocument ; oldInternal . isOwned ( false ) ; oldInternal . nextSibling = null ; oldInternal . previousSibling = null ; changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( ( mutationMask & MUTATION_AGGREGATE ) != 0 ) dispatchAggregateEvents ( enclosingAttr ) ; } return oldInternal ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { EnclosingAttr enclosingAttr = null ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { LCount lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 ) { enclosingAttr = getEnclosingAttr ( ) ; } } internalInsertBefore ( newChild , oldChild , MUTATION_LOCAL ) ; internalRemoveChild ( oldChild , MUTATION_LOCAL ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( enclosingAttr ) ; } return oldChild ; } public int getLength ( ) { if ( nodeListLength == - 1 ) { ChildNode node ; if ( nodeListIndex != - 1 && nodeListNode != null ) { nodeListLength = nodeListIndex ; node = nodeListNode ; } else { node = firstChild ; nodeListLength = 0 ; } for ( ; node != null ; node = node . nextSibling ) { nodeListLength ++ ; } } return nodeListLength ; } public Node item ( int index ) { if ( nodeListIndex != - 1 && nodeListNode != null ) { if ( nodeListIndex < index ) { while ( nodeListIndex < index && nodeListNode != null ) { nodeListIndex ++ ; nodeListNode = nodeListNode . nextSibling ; } } else if ( nodeListIndex > index ) { while ( nodeListIndex > index && nodeListNode != null ) { nodeListIndex -- ; nodeListNode = nodeListNode . previousSibling ( ) ; } } return nodeListNode ; } nodeListNode = firstChild ; for ( nodeListIndex = 0 ; nodeListIndex < index && nodeListNode != null ; nodeListIndex ++ ) { nodeListNode = nodeListNode . nextSibling ; } return nodeListNode ; } public void normalize ( ) { Node kid ; for ( kid = firstChild ; kid != null ; kid = kid . getNextSibling ( ) ) { kid . normalize ( ) ; } } public void setReadOnly ( boolean readOnly , boolean deep ) { super . setReadOnly ( readOnly , deep ) ; if ( deep ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } for ( ChildNode mykid = firstChild ; mykid != null ; mykid = mykid . nextSibling ) { if ( ! ( mykid instanceof EntityReference ) ) { mykid . setReadOnly ( readOnly , true ) ; } } } } protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } protected final void synchronizeChildren ( int nodeIndex ) { boolean orig = ownerDocument . mutationEvents ; ownerDocument . mutationEvents = false ; needsSyncChildren ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ; ChildNode first = null ; ChildNode last = null ; for ( int index = ownerDocument . getLastChild ( nodeIndex ) ; index != - 1 ; index = ownerDocument . getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) ownerDocument . getNodeObject ( index ) ; if ( last == null ) { last = node ; } else { first . previousSibling = node ; } node . ownerNode = this ; node . isOwned ( true ) ; node . nextSibling = first ; first = node ; } if ( last != null ) { firstChild = first ; first . isFirstChild ( true ) ; lastChild ( last ) ; } ownerDocument . mutationEvents = orig ; } private void writeObject ( ObjectOutputStream out ) throws IOException { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; nodeListLength = - 1 ; nodeListIndex = - 1 ; } } 	1
package org . apache . wml ; public interface WMLBrElement extends WMLElement { public void setXmlLang ( String newValue ) ; public String getXmlLang ( ) ; } 	0
package javax . xml . parsers ; public abstract class DocumentBuilderFactory { private boolean namespaces = false ; private boolean validation = false ; private static String property = "javax.xml.parsers.DocumentBuilderFactory" ; private static String factory = "org.apache.xerces.jaxp.DocumentBuilderFactoryImpl" ; protected DocumentBuilderFactory ( ) { super ( ) ; } public static DocumentBuilderFactory newInstance ( ) { String n = factory ; try { n = System . getProperty ( property , factory ) ; } catch ( SecurityException e ) { n = factory ; } try { return ( DocumentBuilderFactory ) Class . forName ( n ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new FactoryConfigurationError ( "Cannot load class " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( InstantiationException e ) { throw new FactoryConfigurationError ( "Cannot instantiate the " + "specified DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( IllegalAccessException e ) { throw new FactoryConfigurationError ( "Cannot access the specified " + "DocumentBuilderFactory class \"" + n + "\"" ) ; } catch ( ClassCastException e ) { throw new FactoryConfigurationError ( "The specified class \"" + n + "\" is not instance of \"" + "javax.xml.parsers.DocumentBuilderFactory\"" ) ; } } public abstract DocumentBuilder newDocumentBuilder ( ) throws ParserConfigurationException ; public void setNamespaceAware ( boolean aware ) { this . namespaces = aware ; } public void setValidating ( boolean validating ) { this . validation = validating ; } public boolean isNamespaceAware ( ) { return ( this . namespaces ) ; } public boolean isValidating ( ) { return ( this . validation ) ; } } 	1
package org . apache . html . dom ; import org . w3c . dom . * ; import java . util . Vector ; import org . apache . xerces . dom . NodeImpl ; import org . apache . xerces . dom . ElementImpl ; import org . apache . xerces . dom . DeepNodeListImpl ; public class NameNodeListImpl extends DeepNodeListImpl implements NodeList { public NameNodeListImpl ( NodeImpl rootNode , String tagName ) { super ( rootNode , tagName ) ; } protected Node nextMatchingElementAfter ( Node current ) { Node next ; while ( current != null ) { if ( current . hasChildNodes ( ) ) { current = ( current . getFirstChild ( ) ) ; } else if ( current != rootNode && null != ( next = current . getNextSibling ( ) ) ) { current = next ; } else { next = null ; for ( ; current != rootNode ; current = current . getParentNode ( ) ) { next = current . getNextSibling ( ) ; if ( next != null ) break ; } current = next ; } if ( current != rootNode && current != null && current . getNodeType ( ) == Node . ELEMENT_NODE ) { String name = ( ( ElementImpl ) current ) . getAttribute ( "name" ) ; if ( name . equals ( "*" ) || name . equals ( tagName ) ) return current ; } } return null ; } } 	0
package org . apache . xerces . dom ; import java . io . * ; import java . util . Vector ; import java . util . Enumeration ; import org . w3c . dom . * ; public class NamedNodeMapImpl implements NamedNodeMap , Serializable { static final long serialVersionUID = - 7039242451046758020L ; protected short flags ; protected final static short READONLY = 0x1 << 0 ; protected final static short CHANGED = 0x1 << 1 ; protected final static short HASDEFAULTS = 0x1 << 2 ; protected Vector nodes ; protected NodeImpl ownerNode ; protected NamedNodeMapImpl ( NodeImpl ownerNode ) { this . ownerNode = ownerNode ; } public int getLength ( ) { return ( nodes != null ) ? nodes . size ( ) : 0 ; } public Node item ( int index ) { return ( nodes != null && index < nodes . size ( ) ) ? ( Node ) ( nodes . elementAt ( index ) ) : null ; } public Node getNamedItem ( String name ) { int i = findNamePoint ( name , 0 ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node getNamedItemNS ( String namespaceURI , String localName ) { int i = findNamePoint ( namespaceURI , localName ) ; return ( i < 0 ) ? null : ( Node ) ( nodes . elementAt ( i ) ) ; } public Node setNamedItem ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } return previous ; } public Node setNamedItemNS ( Node arg ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( arg . getOwnerDocument ( ) != ownerNode . ownerDocument ( ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "DOM005 Wrong document" ) ; } int i = findNamePoint ( arg . getNamespaceURI ( ) , arg . getLocalName ( ) ) ; NodeImpl previous = null ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . setElementAt ( arg , i ) ; } else { i = findNamePoint ( arg . getNodeName ( ) , 0 ) ; if ( i >= 0 ) { previous = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . insertElementAt ( arg , i ) ; } else { i = - 1 - i ; if ( null == nodes ) { nodes = new Vector ( 5 , 10 ) ; } nodes . insertElementAt ( arg , i ) ; } } return previous ; } public Node removeNamedItem ( String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( name , 0 ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < 0 ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "DOM008 Not found" ) ; } NodeImpl n = ( NodeImpl ) nodes . elementAt ( i ) ; nodes . removeElementAt ( i ) ; return n ; } public NamedNodeMapImpl cloneMap ( NodeImpl ownerNode ) { NamedNodeMapImpl newmap = new NamedNodeMapImpl ( ownerNode ) ; newmap . cloneContent ( this ) ; return newmap ; } protected void cloneContent ( NamedNodeMapImpl srcmap ) { if ( srcmap . nodes != null ) { nodes = new Vector ( srcmap . nodes . size ( ) ) ; for ( int i = 0 ; i < srcmap . nodes . size ( ) ; ++ i ) { NodeImpl n = ( NodeImpl ) srcmap . nodes . elementAt ( i ) ; NodeImpl clone = ( NodeImpl ) n . cloneNode ( true ) ; clone . isSpecified ( n . isSpecified ( ) ) ; nodes . insertElementAt ( clone , i ) ; } } } void setReadOnly ( boolean readOnly , boolean deep ) { isReadOnly ( readOnly ) ; if ( deep && nodes != null ) { Enumeration e = nodes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( NodeImpl ) e . nextElement ( ) ) . setReadOnly ( readOnly , deep ) ; } } } boolean getReadOnly ( ) { return isReadOnly ( ) ; } void setOwnerDocument ( DocumentImpl doc ) { if ( nodes != null ) { for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { ( ( NodeImpl ) item ( i ) ) . setOwnerDocument ( doc ) ; } } } final boolean isReadOnly ( ) { return ( flags & READONLY ) != 0 ; } final void isReadOnly ( boolean value ) { flags = ( short ) ( value ? flags | READONLY : flags & ~ READONLY ) ; } final boolean changed ( ) { return ( flags & CHANGED ) != 0 ; } final void changed ( boolean value ) { flags = ( short ) ( value ? flags | CHANGED : flags & ~ CHANGED ) ; } final boolean hasDefaults ( ) { return ( flags & HASDEFAULTS ) != 0 ; } final void hasDefaults ( boolean value ) { flags = ( short ) ( value ? flags | HASDEFAULTS : flags & ~ HASDEFAULTS ) ; } protected int findNamePoint ( String name , int start ) { int i = 0 ; if ( nodes != null ) { int first = start ; int last = nodes . size ( ) - 1 ; while ( first <= last ) { i = ( first + last ) / 2 ; int test = name . compareTo ( ( ( Node ) ( nodes . elementAt ( i ) ) ) . getNodeName ( ) ) ; if ( test == 0 ) { return i ; } else if ( test < 0 ) { last = i - 1 ; } else { first = i + 1 ; } } if ( first > i ) { i = first ; } } return - 1 - i ; } protected int findNamePoint ( String namespaceURI , String name ) { if ( nodes == null ) return - 1 ; if ( namespaceURI == null ) return - 1 ; if ( name == null ) return - 1 ; for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { NodeImpl a = ( NodeImpl ) nodes . elementAt ( i ) ; if ( namespaceURI . equals ( a . getNamespaceURI ( ) ) && name . equals ( a . getLocalName ( ) ) ) { return i ; } } return - 1 ; } } 	1
package org . xml . sax . helpers ; import java . util . EmptyStackException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; public class NamespaceSupport { public final static String XMLNS = "http://www.w3.org/XML/1998/namespace" ; private final static Enumeration EMPTY_ENUMERATION = new Vector ( ) . elements ( ) ; public NamespaceSupport ( ) { reset ( ) ; } public void reset ( ) { contexts = new Context [ 32 ] ; contextPos = 0 ; contexts [ contextPos ] = currentContext = new Context ( ) ; currentContext . declarePrefix ( "xml" , XMLNS ) ; } public void pushContext ( ) { int max = contexts . length ; contextPos ++ ; if ( contextPos >= max ) { Context newContexts [ ] = new Context [ max * 2 ] ; System . arraycopy ( contexts , 0 , newContexts , 0 , max ) ; max *= 2 ; contexts = newContexts ; } currentContext = contexts [ contextPos ] ; if ( currentContext == null ) { contexts [ contextPos ] = currentContext = new Context ( ) ; } if ( contextPos > 0 ) { currentContext . setParent ( contexts [ contextPos - 1 ] ) ; } } public void popContext ( ) { contextPos -- ; if ( contextPos < 0 ) { throw new EmptyStackException ( ) ; } currentContext = contexts [ contextPos ] ; } public boolean declarePrefix ( String prefix , String uri ) { if ( prefix . equals ( "xml" ) || prefix . equals ( "xmlns" ) ) { return false ; } else { currentContext . declarePrefix ( prefix , uri ) ; return true ; } } public String [ ] processName ( String qName , String parts [ ] , boolean isAttribute ) { String myParts [ ] = currentContext . processName ( qName , isAttribute ) ; if ( myParts == null ) { return null ; } else { parts [ 0 ] = myParts [ 0 ] ; parts [ 1 ] = myParts [ 1 ] ; parts [ 2 ] = myParts [ 2 ] ; return parts ; } } public String getURI ( String prefix ) { return currentContext . getURI ( prefix ) ; } public Enumeration getPrefixes ( ) { return currentContext . getPrefixes ( ) ; } public String getPrefix ( String uri ) { return currentContext . getPrefix ( uri ) ; } public Enumeration getPrefixes ( String uri ) { Vector prefixes = new Vector ( ) ; Enumeration allPrefixes = getPrefixes ( ) ; while ( allPrefixes . hasMoreElements ( ) ) { String prefix = ( String ) allPrefixes . nextElement ( ) ; if ( uri . equals ( getURI ( prefix ) ) ) { prefixes . addElement ( prefix ) ; } } return prefixes . elements ( ) ; } public Enumeration getDeclaredPrefixes ( ) { return currentContext . getDeclaredPrefixes ( ) ; } private Context contexts [ ] ; private Context currentContext ; private int contextPos ; final class Context { Context ( ) { copyTables ( ) ; } void setParent ( Context parent ) { this . parent = parent ; declarations = null ; prefixTable = parent . prefixTable ; uriTable = parent . uriTable ; elementNameTable = parent . elementNameTable ; attributeNameTable = parent . attributeNameTable ; defaultNS = parent . defaultNS ; tablesDirty = false ; } void declarePrefix ( String prefix , String uri ) { if ( ! tablesDirty ) { copyTables ( ) ; } if ( declarations == null ) { declarations = new Vector ( ) ; } prefix = prefix . intern ( ) ; uri = uri . intern ( ) ; if ( "" . equals ( prefix ) ) { if ( "" . equals ( uri ) ) { defaultNS = null ; } else { defaultNS = uri ; } } else { prefixTable . put ( prefix , uri ) ; uriTable . put ( uri , prefix ) ; } declarations . addElement ( prefix ) ; } String [ ] processName ( String qName , boolean isAttribute ) { String name [ ] ; Hashtable table ; if ( isAttribute ) { table = elementNameTable ; } else { table = attributeNameTable ; } name = ( String [ ] ) table . get ( qName ) ; if ( name != null ) { return name ; } name = new String [ 3 ] ; int index = qName . indexOf ( ':' ) ; if ( index == - 1 ) { if ( isAttribute || defaultNS == null ) { name [ 0 ] = "" ; } else { name [ 0 ] = defaultNS ; } name [ 1 ] = qName . intern ( ) ; name [ 2 ] = name [ 1 ] ; } else { String prefix = qName . substring ( 0 , index ) ; String local = qName . substring ( index + 1 ) ; String uri ; if ( "" . equals ( prefix ) ) { uri = defaultNS ; } else { uri = ( String ) prefixTable . get ( prefix ) ; } if ( uri == null ) { return null ; } name [ 0 ] = uri ; name [ 1 ] = local . intern ( ) ; name [ 2 ] = qName . intern ( ) ; } table . put ( name [ 2 ] , name ) ; tablesDirty = true ; return name ; } String getURI ( String prefix ) { if ( "" . equals ( prefix ) ) { return defaultNS ; } else if ( prefixTable == null ) { return null ; } else { return ( String ) prefixTable . get ( prefix ) ; } } String getPrefix ( String uri ) { if ( uriTable == null ) { return null ; } else { return ( String ) uriTable . get ( uri ) ; } } Enumeration getDeclaredPrefixes ( ) { if ( declarations == null ) { return EMPTY_ENUMERATION ; } else { return declarations . elements ( ) ; } } Enumeration getPrefixes ( ) { if ( prefixTable == null ) { return EMPTY_ENUMERATION ; } else { return prefixTable . keys ( ) ; } } private void copyTables ( ) { if ( prefixTable != null ) { prefixTable = ( Hashtable ) prefixTable . clone ( ) ; } else { prefixTable = new Hashtable ( ) ; } if ( uriTable != null ) { uriTable = ( Hashtable ) uriTable . clone ( ) ; } else { uriTable = new Hashtable ( ) ; } elementNameTable = new Hashtable ( ) ; attributeNameTable = new Hashtable ( ) ; tablesDirty = true ; } Hashtable prefixTable ; Hashtable uriTable ; Hashtable elementNameTable ; Hashtable attributeNameTable ; String defaultNS = null ; private Vector declarations = null ; private boolean tablesDirty = false ; private Context parent = null ; } } 	0
package org . w3c . dom ; public interface NamedNodeMap { public Node getNamedItem ( String name ) ; public Node setNamedItem ( Node arg ) throws DOMException ; public Node removeNamedItem ( String name ) throws DOMException ; public Node item ( int index ) ; public int getLength ( ) ; public Node getNamedItemNS ( String namespaceURI , String localName ) ; public Node setNamedItemNS ( Node arg ) throws DOMException ; public Node removeNamedItemNS ( String namespaceURI , String localName ) throws DOMException ; } 	1
package org . apache . xml . serialize ; import java . io . OutputStream ; import java . io . Writer ; import java . io . UnsupportedEncodingException ; import java . util . Hashtable ; import java . util . StringTokenizer ; public abstract class SerializerFactory { public static final String FactoriesProperty = "org.apache.xml.serialize.factories" ; private static Hashtable _factories = new Hashtable ( ) ; static { SerializerFactory factory ; String list ; StringTokenizer token ; String className ; factory = new SerializerFactoryImpl ( Method . XML ) ; registerSerializerFactory ( factory ) ; factory = new SerializerFactoryImpl ( Method . HTML ) ; registerSerializerFactory ( factory ) ; factory = new SerializerFactoryImpl ( Method . XHTML ) ; registerSerializerFactory ( factory ) ; factory = new SerializerFactoryImpl ( Method . TEXT ) ; registerSerializerFactory ( factory ) ; list = System . getProperty ( FactoriesProperty ) ; if ( list != null ) { token = new StringTokenizer ( list , " ;,:" ) ; while ( token . hasMoreTokens ( ) ) { className = token . nextToken ( ) ; try { factory = ( SerializerFactory ) Class . forName ( className ) . newInstance ( ) ; if ( _factories . contains ( factory . getSupportedMethod ( ) ) ) _factories . put ( factory . getSupportedMethod ( ) , factory ) ; } catch ( Exception except ) { } } } } public static void registerSerializerFactory ( SerializerFactory factory ) { String method ; synchronized ( _factories ) { method = factory . getSupportedMethod ( ) ; _factories . put ( method , factory ) ; } } public static SerializerFactory getSerializerFactory ( String method ) { return ( SerializerFactory ) _factories . get ( method ) ; } protected abstract String getSupportedMethod ( ) ; public abstract Serializer makeSerializer ( OutputFormat format ) ; public abstract Serializer makeSerializer ( Writer writer , OutputFormat format ) ; public abstract Serializer makeSerializer ( OutputStream output , OutputFormat format ) throws UnsupportedEncodingException ; } 	0
package org . apache . xml . serialize ; import java . util . Hashtable ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentType ; import org . w3c . dom . Node ; import org . w3c . dom . html . HTMLDocument ; public class OutputFormat { public static class DTD { public static final String HTMLPublicId = "-//W3C//DTD HTML 4.0//EN" ; public static final String HTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; public static final String XHTMLPublicId = "-//W3C//DTD XHTML 1.0 Strict//EN" ; public static final String XHTMLSystemId = "http://www.w3.org/TR/WD-html-in-xml/DTD/xhtml1-strict.dtd" ; } public static class Defaults { public static final int Indent = 4 ; public static final String Encoding = "UTF-8" ; public static final int LineWidth = 72 ; } private String _method ; private String _version ; private int _indent = 0 ; private String _encoding = Defaults . Encoding ; private String _mediaType ; private String _doctypeSystem ; private String _doctypePublic ; private boolean _omitXmlDeclaration = false ; private boolean _omitDoctype = false ; private boolean _omitComments = false ; private boolean _stripComments = false ; private boolean _standalone = false ; private String [ ] _cdataElements ; private String [ ] _nonEscapingElements ; private String _lineSeparator = LineSeparator . Web ; private int _lineWidth = Defaults . LineWidth ; private boolean _preserve = false ; public OutputFormat ( ) { } public OutputFormat ( String method , String encoding , boolean indenting ) { setMethod ( method ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public OutputFormat ( Document doc ) { setMethod ( whichMethod ( doc ) ) ; setDoctype ( whichDoctypePublic ( doc ) , whichDoctypeSystem ( doc ) ) ; setMediaType ( whichMediaType ( getMethod ( ) ) ) ; } public OutputFormat ( Document doc , String encoding , boolean indenting ) { this ( doc ) ; setEncoding ( encoding ) ; setIndenting ( indenting ) ; } public String getMethod ( ) { return _method ; } public void setMethod ( String method ) { _method = method ; } public String getVersion ( ) { return _version ; } public void setVersion ( String version ) { _version = version ; } public int getIndent ( ) { return _indent ; } public boolean getIndenting ( ) { return ( _indent > 0 ) ; } public void setIndent ( int indent ) { if ( indent < 0 ) _indent = 0 ; else _indent = indent ; } public void setIndenting ( boolean on ) { if ( on ) { _indent = Defaults . Indent ; _lineWidth = Defaults . LineWidth ; } else { _indent = 0 ; _lineWidth = 0 ; } } public String getEncoding ( ) { return _encoding ; } public void setEncoding ( String encoding ) { _encoding = encoding ; } public String getMediaType ( ) { return _mediaType ; } public void setMediaType ( String mediaType ) { _mediaType = mediaType ; } public void setDoctype ( String publicId , String systemId ) { _doctypePublic = publicId ; _doctypeSystem = systemId ; } public String getDoctypePublic ( ) { return _doctypePublic ; } public String getDoctypeSystem ( ) { return _doctypeSystem ; } public boolean getOmitComments ( ) { return _omitComments ; } public void setOmitComments ( boolean omit ) { _omitComments = omit ; } public boolean getOmitDocumentType ( ) { return _omitDoctype ; } public void setOmitDocumentType ( boolean omit ) { _omitDoctype = omit ; } public boolean getOmitXMLDeclaration ( ) { return _omitXmlDeclaration ; } public void setOmitXMLDeclaration ( boolean omit ) { _omitXmlDeclaration = omit ; } public boolean getStandalone ( ) { return _standalone ; } public void setStandalone ( boolean standalone ) { _standalone = standalone ; } public String [ ] getCDataElements ( ) { return _cdataElements ; } public boolean isCDataElement ( String tagName ) { int i ; if ( _cdataElements == null ) return false ; for ( i = 0 ; i < _cdataElements . length ; ++ i ) if ( _cdataElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setCDataElements ( String [ ] cdataElements ) { _cdataElements = cdataElements ; } public String [ ] getNonEscapingElements ( ) { return _nonEscapingElements ; } public boolean isNonEscapingElement ( String tagName ) { int i ; if ( _nonEscapingElements == null ) return false ; for ( i = 0 ; i < _nonEscapingElements . length ; ++ i ) if ( _nonEscapingElements [ i ] . equals ( tagName ) ) return true ; return false ; } public void setNonEscapingElements ( String [ ] nonEscapingElements ) { _nonEscapingElements = nonEscapingElements ; } public String getLineSeparator ( ) { return _lineSeparator ; } public void setLineSeparator ( String lineSeparator ) { if ( lineSeparator == null ) _lineSeparator = LineSeparator . Web ; else _lineSeparator = lineSeparator ; } public boolean getPreserveSpace ( ) { return _preserve ; } public void setPreserveSpace ( boolean preserve ) { _preserve = preserve ; } public int getLineWidth ( ) { return _lineWidth ; } public void setLineWidth ( int lineWidth ) { if ( lineWidth <= 0 ) _lineWidth = 0 ; else _lineWidth = lineWidth ; } public char getLastPrintable ( ) { if ( getEncoding ( ) != null && ( getEncoding ( ) . equalsIgnoreCase ( "ASCII" ) ) ) return 0xFF ; else return 0xFFFF ; } public static String whichMethod ( Document doc ) { Node node ; String value ; int i ; if ( doc instanceof HTMLDocument ) return Method . HTML ; node = doc . getFirstChild ( ) ; while ( node != null ) { if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( node . getNodeName ( ) . equalsIgnoreCase ( "html" ) ) { return Method . HTML ; } else if ( node . getNodeName ( ) . equalsIgnoreCase ( "root" ) ) { return Method . FOP ; } else { return Method . XML ; } } else if ( node . getNodeType ( ) == Node . TEXT_NODE ) { value = node . getNodeValue ( ) ; for ( i = 0 ; i < value . length ( ) ; ++ i ) if ( value . charAt ( i ) != 0x20 && value . charAt ( i ) != 0x0A && value . charAt ( i ) != 0x09 && value . charAt ( i ) != 0x0D ) return Method . XML ; } node = node . getNextSibling ( ) ; } return Method . XML ; } public static String whichDoctypePublic ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLPublicId ; return null ; } public static String whichDoctypeSystem ( Document doc ) { DocumentType doctype ; if ( doc instanceof HTMLDocument ) return DTD . XHTMLSystemId ; return null ; } public static String whichMediaType ( String method ) { if ( method . equalsIgnoreCase ( Method . XML ) ) return "text/xml" ; if ( method . equalsIgnoreCase ( Method . HTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . XHTML ) ) return "text/html" ; if ( method . equalsIgnoreCase ( Method . TEXT ) ) return "text/plain" ; if ( method . equalsIgnoreCase ( Method . FOP ) ) return "application/pdf" ; return null ; } } 	1
package org . apache . wml ; import org . w3c . dom . Element ; public interface WMLElement extends Element { public void setId ( String newValue ) ; public String getId ( ) ; public void setClassName ( String newValue ) ; public String getClassName ( ) ; } 	0
package javax . xml . parsers ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; public abstract class SAXParser { protected SAXParser ( ) { super ( ) ; } public void parse ( InputStream stream , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( stream == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( stream ) , base ) ; } public void parse ( String uri , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( uri == null ) throw new IllegalArgumentException ( ) ; this . parse ( new InputSource ( uri ) , base ) ; } public void parse ( File file , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( file == null ) throw new IllegalArgumentException ( ) ; String path = file . getAbsolutePath ( ) ; if ( File . separatorChar != '/' ) { path = path . replace ( File . separatorChar , '/' ) ; } if ( ! path . startsWith ( "/" ) ) { path = "/" + path ; } if ( ! path . endsWith ( "/" ) && file . isDirectory ( ) ) { path = path + "/" ; } java . net . URL url = new java . net . URL ( "file" , "" , path ) ; this . parse ( new InputSource ( url . toString ( ) ) , base ) ; } public void parse ( InputSource source , HandlerBase base ) throws SAXException , IOException , IllegalArgumentException { if ( source == null ) throw new IllegalArgumentException ( ) ; Parser p = this . getParser ( ) ; if ( base != null ) { p . setDocumentHandler ( base ) ; p . setDTDHandler ( base ) ; p . setEntityResolver ( base ) ; p . setErrorHandler ( base ) ; } p . parse ( source ) ; } public abstract Parser getParser ( ) throws SAXException ; public abstract boolean isNamespaceAware ( ) ; public abstract boolean isValidating ( ) ; } 	1
package org . apache . xerces . validators . datatype ; import java . util . Hashtable ; import java . util . Locale ; import java . util . StringTokenizer ; import org . apache . xerces . readers . DefaultEntityHandler ; import org . apache . xerces . utils . XMLMessages ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . validators . datatype . StateMessageDatatype ; public class ENTITYDatatypeValidator extends AbstractDatatypeValidator { private DatatypeValidator fBaseValidator = null ; private boolean fDerivedByList = false ; private DefaultEntityHandler fEntityHandler = null ; private StringPool fStringPool = null ; public static final int ENTITY_INITIALIZE = 0 ; public ENTITYDatatypeValidator ( ) throws InvalidDatatypeFacetException { this ( null , null , false ) ; } public ENTITYDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { setBasetype ( base ) ; fDerivedByList = derivedByList ; } public Object validate ( String content , Object state ) throws InvalidDatatypeValueException { StateMessageDatatype message = ( StateMessageDatatype ) state ; int attValueHandle ; if ( message != null && message . getDatatypeState ( ) == ENTITYDatatypeValidator . ENTITY_INITIALIZE ) { Object [ ] unpackMessage = ( Object [ ] ) message . getDatatypeObject ( ) ; this . fEntityHandler = ( DefaultEntityHandler ) unpackMessage [ 0 ] ; this . fStringPool = ( StringPool ) unpackMessage [ 1 ] ; } else { if ( this . fEntityHandler == null ) { InvalidDatatypeValueException error = new InvalidDatatypeValueException ( "ERROR: ENTITYDatatype Validator: Failed Initialization DefaultEntityHandler is null" ) ; throw error ; } if ( this . fStringPool == null ) { InvalidDatatypeValueException error = new InvalidDatatypeValueException ( "ERROR: ENTITYDatatype Validator: Failed Initialization StrinPool is null" ) ; throw error ; } if ( this . fDerivedByList == false ) { attValueHandle = this . fStringPool . addSymbol ( content ) ; if ( ! this . fEntityHandler . isUnparsedEntity ( attValueHandle ) ) { InvalidDatatypeValueException error = new InvalidDatatypeValueException ( "ENTITY '" + content + "' is not valid" ) ; error . setMinorCode ( XMLMessages . MSG_ENTITY_INVALID ) ; error . setMajorCode ( XMLMessages . VC_ENTITY_NAME ) ; throw error ; } } else { StringTokenizer listOfEntities = new StringTokenizer ( content ) ; StringBuffer sb = new StringBuffer ( content . length ( ) ) ; boolean ok = true ; if ( listOfEntities . hasMoreTokens ( ) ) { while ( true ) { String nextEntity = listOfEntities . nextToken ( ) ; if ( this . fEntityHandler . isUnparsedEntity ( this . fStringPool . addSymbol ( nextEntity ) ) == false ) { ok = false ; } sb . append ( nextEntity ) ; if ( ! listOfEntities . hasMoreTokens ( ) ) { break ; } sb . append ( ' ' ) ; } } String errorContent = sb . toString ( ) ; if ( ! ok || errorContent . length ( ) == 0 ) { InvalidDatatypeValueException error = new InvalidDatatypeValueException ( errorContent ) ; error . setMinorCode ( XMLMessages . MSG_ENTITIES_INVALID ) ; error . setMajorCode ( XMLMessages . VC_ENTITY_NAME ) ; throw error ; } } } return null ; } public int compare ( String content1 , String content2 ) { return - 1 ; } public Hashtable getFacets ( ) { return null ; } public Object clone ( ) throws CloneNotSupportedException { throw new CloneNotSupportedException ( "clone() is not supported in " + this . getClass ( ) . getName ( ) ) ; } private void setBasetype ( DatatypeValidator base ) { fBaseValidator = base ; } } 	0
package org . w3c . dom ; public interface Element extends Node { public String getTagName ( ) ; public String getAttribute ( String name ) ; public void setAttribute ( String name , String value ) throws DOMException ; public void removeAttribute ( String name ) throws DOMException ; public Attr getAttributeNode ( String name ) ; public Attr setAttributeNode ( Attr newAttr ) throws DOMException ; public Attr removeAttributeNode ( Attr oldAttr ) throws DOMException ; public NodeList getElementsByTagName ( String name ) ; public String getAttributeNS ( String namespaceURI , String localName ) ; public void setAttributeNS ( String namespaceURI , String qualifiedName , String value ) throws DOMException ; public void removeAttributeNS ( String namespaceURI , String localName ) throws DOMException ; public Attr getAttributeNodeNS ( String namespaceURI , String localName ) ; public Attr setAttributeNodeNS ( Attr newAttr ) throws DOMException ; public NodeList getElementsByTagNameNS ( String namespaceURI , String localName ) ; public boolean hasAttribute ( String name ) ; public boolean hasAttributeNS ( String namespaceURI , String localName ) ; } 	1
package org . apache . xerces . validators . schema ; import org . apache . xerces . utils . QName ; import org . apache . xerces . utils . StringPool ; import org . apache . xerces . validators . common . GrammarResolver ; import org . xml . sax . SAXException ; import java . lang . ClassCastException ; public class EquivClassComparator { private final int TOP_LEVEL_SCOPE = - 1 ; private StringPool fStringPool = null ; private GrammarResolver fGrammarResolver = null ; private EquivClassComparator ( ) { } public EquivClassComparator ( GrammarResolver grammarResolver , StringPool stringPool ) { fGrammarResolver = grammarResolver ; fStringPool = stringPool ; } public boolean isEquivalentTo ( QName aElement , QName examplar ) throws Exception { if ( aElement . localpart == examplar . localpart && aElement . uri == examplar . uri ) { return true ; } if ( fGrammarResolver == null || fStringPool == null ) { throw new SAXException ( "Try to check equivalency by equivClass, but no GrammarResolver is defined" ) ; } int count = 16 ; int uriIndex = aElement . uri ; int localpartIndex = aElement . localpart ; String uri = fStringPool . toString ( aElement . uri ) ; String localpart = fStringPool . toString ( aElement . localpart ) ; while ( count >= 0 ) { if ( uri == null ) { return false ; } SchemaGrammar sGrammar = null ; try { sGrammar = ( SchemaGrammar ) fGrammarResolver . getGrammar ( uri ) ; } catch ( ClassCastException ce ) { return false ; } if ( sGrammar == null ) return false ; int elementIndex = sGrammar . getElementDeclIndex ( uriIndex , localpartIndex , TOP_LEVEL_SCOPE ) ; if ( elementIndex == - 1 ) { return false ; } String equivClassFullName = sGrammar . getElementDeclEquivClassElementFullName ( elementIndex ) ; if ( equivClassFullName == null ) { return false ; } int commaAt = equivClassFullName . indexOf ( "," ) ; uri = "" ; localpart = equivClassFullName ; if ( commaAt >= 0 ) { if ( commaAt > 0 ) { uri = equivClassFullName . substring ( 0 , commaAt ) ; } localpart = equivClassFullName . substring ( commaAt + 1 ) ; } uriIndex = fStringPool . addSymbol ( uri ) ; localpartIndex = fStringPool . addSymbol ( localpart ) ; if ( uriIndex == examplar . uri && localpartIndex == examplar . localpart ) { return true ; } count -- ; } return false ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class NotationImpl extends NodeImpl implements Notation { static final long serialVersionUID = - 764632195890658402L ; protected String name ; protected String publicId ; protected String systemId ; public NotationImpl ( DocumentImpl ownerDoc , String name ) { super ( ownerDoc ) ; this . name = name ; } public short getNodeType ( ) { return Node . NOTATION_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public String getPublicId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return publicId ; } public String getSystemId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return systemId ; } public void setPublicId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } publicId = id ; } public void setSystemId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } systemId = id ; } } 	1
package org . w3c . dom . html ; public interface HTMLOListElement extends HTMLElement { public boolean getCompact ( ) ; public void setCompact ( boolean compact ) ; public int getStart ( ) ; public void setStart ( int start ) ; public String getType ( ) ; public void setType ( String type ) ; } 	0
package org . w3c . dom . events ; public interface EventListener { public void handleEvent ( Event evt ) ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLGoElementImpl extends WMLElementImpl implements WMLGoElement { public WMLGoElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setSendreferer ( String newValue ) { setAttribute ( "sendreferer" , newValue ) ; } public String getSendreferer ( ) { return getAttribute ( "sendreferer" ) ; } public void setAcceptCharset ( String newValue ) { setAttribute ( "accept-charset" , newValue ) ; } public String getAcceptCharset ( ) { return getAttribute ( "accept-charset" ) ; } public void setHref ( String newValue ) { setAttribute ( "href" , newValue ) ; } public String getHref ( ) { return getAttribute ( "href" ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setMethod ( String newValue ) { setAttribute ( "method" , newValue ) ; } public String getMethod ( ) { return getAttribute ( "method" ) ; } } 	0
package org . xml . sax . ext ; import org . xml . sax . SAXException ; public interface LexicalHandler { public abstract void startDTD ( String name , String publicId , String systemId ) throws SAXException ; public abstract void endDTD ( ) throws SAXException ; public abstract void startEntity ( String name ) throws SAXException ; public abstract void endEntity ( String name ) throws SAXException ; public abstract void startCDATA ( ) throws SAXException ; public abstract void endCDATA ( ) throws SAXException ; public abstract void comment ( char ch [ ] , int start , int length ) throws SAXException ; } 	1
package org . apache . xerces . dom ; import org . w3c . dom . * ; public class DeferredProcessingInstructionImpl extends ProcessingInstructionImpl implements DeferredNode { static final long serialVersionUID = - 4643577954293565388L ; protected transient int fNodeIndex ; DeferredProcessingInstructionImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; } public int getNodeIndex ( ) { return fNodeIndex ; } protected void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( DeferredDocumentImpl ) this . ownerDocument ( ) ; target = ownerDocument . getNodeNameString ( fNodeIndex ) ; data = ownerDocument . getNodeValueString ( fNodeIndex ) ; } } 	0
package org . apache . xerces . dom ; import org . w3c . dom . * ; import org . apache . xerces . dom . events . MutationEventImpl ; public class AttrImpl extends ParentNode implements Attr { static final long serialVersionUID = 7277707688218972102L ; protected String name ; protected AttrImpl ( DocumentImpl ownerDocument , String name ) { super ( ownerDocument ) ; this . name = name ; isSpecified ( true ) ; } protected AttrImpl ( ) { } public Node cloneNode ( boolean deep ) { AttrImpl clone = ( AttrImpl ) super . cloneNode ( deep ) ; clone . isSpecified ( true ) ; return clone ; } public short getNodeType ( ) { return Node . ATTRIBUTE_NODE ; } public String getNodeName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setNodeValue ( String value ) throws DOMException { setValue ( value ) ; } public String getNodeValue ( ) { return getValue ( ) ; } public String getName ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return name ; } public void setValue ( String value ) { if ( isReadOnly ( ) ) { throw new DOMExceptionImpl ( DOMException . NO_MODIFICATION_ALLOWED_ERR , "DOM001 Modification not allowed" ) ; } LCount lc = null ; String oldvalue = "" ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { lc = LCount . lookup ( MutationEventImpl . DOM_ATTR_MODIFIED ) ; if ( lc . captures + lc . bubbles + lc . defaults > 0 && ownerNode != null ) { oldvalue = getValue ( ) ; } } if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } while ( firstChild != null ) internalRemoveChild ( firstChild , MUTATION_LOCAL ) ; } else { if ( firstChild != null ) { firstChild . previousSibling = null ; firstChild . isFirstChild ( false ) ; firstChild = null ; } needsSyncChildren ( false ) ; } isSpecified ( true ) ; if ( value != null ) { internalInsertBefore ( ownerDocument . createTextNode ( value ) , null , MUTATION_LOCAL ) ; } changed ( ) ; if ( MUTATIONEVENTS && ownerDocument . mutationEvents ) { dispatchAggregateEvents ( this , oldvalue ) ; } } public String getValue ( ) { if ( needsSyncChildren ( ) ) { synchronizeChildren ( ) ; } if ( firstChild == null ) { return "" ; } ChildNode node = firstChild . nextSibling ; if ( node == null ) { return firstChild . getNodeValue ( ) ; } StringBuffer value = new StringBuffer ( firstChild . getNodeValue ( ) ) ; while ( node != null ) { value . append ( node . getNodeValue ( ) ) ; node = node . nextSibling ; } return value . toString ( ) ; } public boolean getSpecified ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return isSpecified ( ) ; } public Element getElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public Element getOwnerElement ( ) { return ( Element ) ( isOwned ( ) ? ownerNode : null ) ; } public void normalize ( ) { Node kid , next ; for ( kid = firstChild ; kid != null ; kid = next ) { next = kid . getNextSibling ( ) ; if ( next != null && kid . getNodeType ( ) == Node . TEXT_NODE && next . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) kid ) . appendData ( next . getNodeValue ( ) ) ; removeChild ( next ) ; next = kid ; } } } public void setSpecified ( boolean arg ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } isSpecified ( arg ) ; } public String toString ( ) { return getName ( ) + "=" + "\"" + getValue ( ) + "\"" ; } } 	1
package org . w3c . dom . html ; public interface HTMLIsIndexElement extends HTMLElement { public HTMLFormElement getForm ( ) ; public String getPrompt ( ) ; public void setPrompt ( String prompt ) ; } 	0
package org . w3c . dom ; public interface CharacterData extends Node { public String getData ( ) throws DOMException ; public void setData ( String data ) throws DOMException ; public int getLength ( ) ; public String substringData ( int offset , int count ) throws DOMException ; public void appendData ( String arg ) throws DOMException ; public void insertData ( int offset , String arg ) throws DOMException ; public void deleteData ( int offset , int count ) throws DOMException ; public void replaceData ( int offset , int count , String arg ) throws DOMException ; } 	1
package org . apache . wml . dom ; import org . apache . wml . * ; public class WMLMetaElementImpl extends WMLElementImpl implements WMLMetaElement { public WMLMetaElementImpl ( WMLDocumentImpl owner , String tagName ) { super ( owner , tagName ) ; } public void setForua ( boolean newValue ) { setAttribute ( "forua" , newValue ) ; } public boolean getForua ( ) { return getAttribute ( "forua" , false ) ; } public void setScheme ( String newValue ) { setAttribute ( "scheme" , newValue ) ; } public String getScheme ( ) { return getAttribute ( "scheme" ) ; } public void setClassName ( String newValue ) { setAttribute ( "class" , newValue ) ; } public String getClassName ( ) { return getAttribute ( "class" ) ; } public void setHttpEquiv ( String newValue ) { setAttribute ( "http-equiv" , newValue ) ; } public String getHttpEquiv ( ) { return getAttribute ( "http-equiv" ) ; } public void setId ( String newValue ) { setAttribute ( "id" , newValue ) ; } public String getId ( ) { return getAttribute ( "id" ) ; } public void setContent ( String newValue ) { setAttribute ( "content" , newValue ) ; } public String getContent ( ) { return getAttribute ( "content" ) ; } public void setName ( String newValue ) { setAttribute ( "name" , newValue ) ; } public String getName ( ) { return getAttribute ( "name" ) ; } } 	0
package org . w3c . dom . events ; import org . w3c . dom . Node ; public interface Event { public static final short CAPTURING_PHASE = 1 ; public static final short AT_TARGET = 2 ; public static final short BUBBLING_PHASE = 3 ; public String getType ( ) ; public EventTarget getTarget ( ) ; public Node getCurrentNode ( ) ; public short getEventPhase ( ) ; public boolean getBubbles ( ) ; public boolean getCancelable ( ) ; public long getTimeStamp ( ) ; public void stopPropagation ( ) ; public void preventDefault ( ) ; public void initEvent ( String eventTypeArg , boolean canBubbleArg , boolean cancelableArg ) ; } 	1
